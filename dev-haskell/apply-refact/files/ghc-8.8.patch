--- a/src/Refact/Apply.hs 2019-09-14 13:52:44.786277927 +0200
+++ b/src/Refact/Apply.hs 2019-09-14 15:14:13.080038569 +0200
@@ -1,3 +1,4 @@
+{-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE ViewPatterns #-}
 {-# LANGUAGE RecordWildCards #-}
@@ -16,7 +17,6 @@
   )  where
 
 import Language.Haskell.GHC.ExactPrint
-import Language.Haskell.GHC.ExactPrint.Annotate
 import Language.Haskell.GHC.ExactPrint.Delta
 import Language.Haskell.GHC.ExactPrint.Parsers
 import Language.Haskell.GHC.ExactPrint.Print
@@ -138,7 +138,7 @@
 getSeed = get <* modify (+1)
 
 -- | Peform a @Refactoring@.
-runRefactoring :: Data a => Anns -> a -> Refactoring GHC.SrcSpan -> State Int (Anns, a)
+runRefactoring :: Constraints a => Anns -> a -> Refactoring GHC.SrcSpan -> State Int (Anns, a)
 runRefactoring as m r@Replace{}  = do
   seed <- getSeed
   return $ case rtype r of
@@ -212,7 +212,7 @@
 -- Substitute variables into templates
 -- Finds places in the templates where we need to insert variables.
 
-substTransform :: (Data a, Data b) => b -> [(String, GHC.SrcSpan)] -> a -> M a
+substTransform :: (Data a, Constraints b) => b -> [(String, GHC.SrcSpan)] -> a -> M a
 substTransform m ss = everywhereM (mkM (typeSub m ss)
                                     `extM` identSub m ss
                                     `extM` patSub m ss
@@ -220,22 +220,22 @@
                                     `extM` exprSub m ss
                                     )
 
-stmtSub :: Data a => a -> [(String, GHC.SrcSpan)] -> Stmt -> M Stmt
+stmtSub :: Constraints a => a -> [(String, GHC.SrcSpan)] -> Stmt -> M Stmt
 stmtSub m subs old@(GHC.L _ (BodyStmt _ (GHC.L _ (HsVar _ (L _ name))) _ _) ) =
   resolveRdrName m (findStmt m) old subs name
 stmtSub _ _ e = return e
 
-patSub :: Data a => a -> [(String, GHC.SrcSpan)] -> Pat -> M Pat
-patSub m subs old@(GHC.L _ (VarPat _ (L _ name))) =
+patSub :: Constraints a => a -> [(String, GHC.SrcSpan)] -> Pat -> M Pat
+patSub m subs old@(dL->GHC.L _ (VarPat _ (L _ name))) =
   resolveRdrName m (findPat m) old subs name
 patSub _ _ e = return e
 
-typeSub :: Data a => a -> [(String, GHC.SrcSpan)] -> Type -> M Type
+typeSub :: Constraints a => a -> [(String, GHC.SrcSpan)] -> Type -> M Type
 typeSub m subs old@(GHC.L _ (HsTyVar _ _ (L _ name))) =
   resolveRdrName m (findType m) old subs name
 typeSub _ _ e = return e
 
-exprSub :: Data a => a -> [(String, GHC.SrcSpan)] -> Expr -> M Expr
+exprSub :: Constraints a => a -> [(String, GHC.SrcSpan)] -> Expr -> M Expr
 exprSub m subs old@(GHC.L _ (HsVar _ (L _ name))) =
   resolveRdrName m (findExpr m) old subs name
 exprSub _ _ e = return e
@@ -248,8 +248,8 @@
 -- This looks convoluted but we can't match directly on a located name as
 -- it is not specific enough. Instead we match on some bigger context which
 -- is contains the located name we want to replace.
-identSub :: Data a => a -> [(String, GHC.SrcSpan)] -> FunBind -> M FunBind
-identSub m subs old@(GHC.FunRhs (GHC.L _ name) _ _) =
+identSub :: Constraints a => a -> [(String, GHC.SrcSpan)] -> FunBind -> M FunBind
+identSub m subs old@(GHC.FunRhs (dL->GHC.L _ name) _ _) =
   resolveRdrName' subst (findName m) old subs name
   where
     subst :: FunBind -> Name -> M FunBind
@@ -283,13 +283,13 @@
               Nothing -> return old
     _ -> return old
 
-resolveRdrName :: (Data old, Data a)
+resolveRdrName :: (Constraints old, Data a)
                => a
-               -> (SrcSpan -> Located old)
-               -> Located old
+               -> (SrcSpan -> old)
+               -> old
                -> [(String, SrcSpan)]
                -> GHC.RdrName
-               -> M (Located old)
+               -> M old
 resolveRdrName m = resolveRdrName' (modifyAnnKey m)
 
 insertComment :: AnnKey -> String
@@ -302,12 +302,12 @@
 
 
 -- Substitute the template into the original AST.
-doGenReplacement :: (Data ast, Data a)
+doGenReplacement :: (Constraints ast, Data a)
               => a
-              -> (GHC.Located ast -> Bool)
-              -> GHC.Located ast
-              -> GHC.Located ast
-              -> State (Anns, Bool) (GHC.Located ast)
+              -> (ast -> Bool)
+              -> ast
+              -> ast
+              -> State (Anns, Bool) ast
 doGenReplacement m p new old =
   if p old then do
                   s <- get
@@ -316,8 +316,8 @@
                   return v
            else return old
 
-replaceWorker :: (Annotate a, Data mod) => Anns -> mod
-              -> Parser (GHC.Located a) -> Int
+replaceWorker :: (Constraints a, Constraints mod) => Anns -> mod
+              -> Parser a -> Int
               -> Refactoring GHC.SrcSpan -> (Anns, mod)
 replaceWorker as m parser seed Replace{..} =
   let replExprLocation = pos
@@ -327,7 +327,7 @@
                               Right xs -> xs
                               Left err -> error (show err)
       (newExpr, newAnns) = runState (substTransform m subts template) (mergeAnns as relat)
-      replacementPred (GHC.L l _) = l == replExprLocation
+      replacementPred (dL->GHC.L l _) = l == replExprLocation
       transformation = everywhereM (mkM (doGenReplacement m replacementPred newExpr))
    in case runState (transformation m) (newAnns, False) of
         (finalM, (finalAs, True)) -> (finalAs, finalM)
@@ -338,33 +338,33 @@
 
 
 -- Find the largest expression with a given SrcSpan
-findGen :: forall ast a . (Data ast, Data a) => String -> a -> SrcSpan -> GHC.Located ast
+findGen :: forall ast a . (Constraints ast, Constraints a) => String -> a -> SrcSpan -> ast
 findGen s m ss = fromMaybe (error (s ++ " " ++ showGhc ss)) (doTrans m)
   where
-    doTrans :: a -> Maybe (GHC.Located ast)
+    doTrans :: (HasSrcSpan a) => a -> Maybe ast
     doTrans = something (mkQ Nothing (findLargestExpression ss))
 
-findExpr :: Data a => a -> SrcSpan -> Expr
+findExpr :: Constraints a => a -> SrcSpan -> Expr
 findExpr = findGen "expr"
 
-findPat :: Data a => a -> SrcSpan -> Pat
+findPat :: Constraints a => a -> SrcSpan -> Pat
 findPat = findGen "pat"
 
-findType :: Data a => a -> SrcSpan -> Type
+findType :: Constraints a => a -> SrcSpan -> Type
 findType = findGen "type"
 
-findDecl :: Data a => a -> SrcSpan -> Decl
+findDecl :: Constraints a => a -> SrcSpan -> Decl
 findDecl = findGen "decl"
 
-findStmt :: Data a => a -> SrcSpan -> Stmt
+findStmt :: Constraints a => a -> SrcSpan -> Stmt
 findStmt = findGen "stmt"
 
-findName :: Data a => a -> SrcSpan -> Name
+findName :: Constraints a => a -> SrcSpan -> Name
 findName = findGen "name"
 
-findLargestExpression :: SrcSpan -> GHC.Located ast
-                      -> Maybe (GHC.Located ast)
-findLargestExpression ss e@(GHC.L l _) =
+findLargestExpression :: HasSrcSpan ast => SrcSpan -> ast
+                      -> Maybe ast
+findLargestExpression ss e@(dL->GHC.L l _) =
   if l == ss
     then Just e
     else Nothing
--- a/src/Refact/Run.hs   2019-09-14 13:54:49.610118876 +0200
+++ b/src/Refact/Run.hs   2019-09-14 13:55:20.487834583 +0200
@@ -75,7 +75,7 @@
              "2" -> Loud
              _   -> Normal
 
-parsePos :: Monad m => String -> m (Int, Int)
+parsePos :: (MonadFail m, Monad m) => String -> m (Int, Int)
 parsePos s =
   case span isDigit s of
     (line, ',':col) ->
--- a/src/Refact/Utils.hs	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Refact/Utils.hs	2019-09-14 15:15:32.739370800 +0200
@@ -1,3 +1,4 @@
+{-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE ViewPatterns #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables  #-}
@@ -143,7 +144,7 @@
 --
 -- For example, this function will ensure the correct relative position and
 -- make sure that any trailing semi colons or commas are transferred.
-modifyAnnKey :: (Data old, Data new, Data mod) => mod -> Located old -> Located new -> M (Located new)
+modifyAnnKey :: (Constraints old, Constraints new, Data mod) => mod -> old -> new -> M new
 modifyAnnKey m e1 e2 = do
     as <- get
     let parentKey = fromMaybe (mkAnnKey e2) (findParent (getLoc e2) as m)

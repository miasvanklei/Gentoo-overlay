diff --git a/GhcMod/HomeModuleGraph.hs b/GhcMod/HomeModuleGraph.hs
index f80d8dc..7b770ff 100644
--- a/GhcMod/HomeModuleGraph.hs
+++ b/GhcMod/HomeModuleGraph.hs
@@ -14,7 +14,7 @@
 -- You should have received a copy of the GNU Affero General Public License
 -- along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-{-# LANGUAGE ScopedTypeVariables, RecordWildCards #-}
+{-# LANGUAGE ScopedTypeVariables, RecordWildCards, CPP #-}
 module GhcMod.HomeModuleGraph (
    GmModuleGraph(..)
  , ModulePath(..)
@@ -38,6 +38,7 @@ import ErrUtils
 import Exception
 import Finder
 import GHC
+import Bag
 import HscTypes
 import Pretty
 
@@ -50,6 +51,7 @@ import Control.Monad.State.Class
 import Data.Maybe
 import Data.Monoid as Monoid
 import Data.Map  (Map)
+import Data.List (intercalate)
 import qualified Data.Map  as Map
 import Data.Set (Set)
 import qualified Data.Set as Set
@@ -251,7 +253,18 @@ preprocessFile env file =
   withLogger' env $ \setDf -> do
     withMappedFile file $ \fn -> do
       let env' = env { hsc_dflags = setDf (hsc_dflags env) }
+#if __GLASGOW_HASKELL__ < 808
       liftIO $ preprocess env' (fn, Nothing)
+#else
+      liftIO $ do
+        res <- preprocess env' fn Nothing Nothing
+        case res of
+          Right x -> return x
+          Left err -> error $ showErrorMessages err
+
+showErrorMessages :: ErrorMessages -> String
+showErrorMessages msgs = intercalate "\n" $ map show $ bagToList msgs
+#endif
 
 fileModuleName :: (IOish m, GmEnv m, GmState m) =>
   HscEnv -> FilePath -> m (Either [String] (Maybe ModuleName))
diff --git a/GhcMod/SrcUtils.hs b/GhcMod/SrcUtils.hs
index 49be3a3..fb20261 100644
--- a/GhcMod/SrcUtils.hs
+++ b/GhcMod/SrcUtils.hs
@@ -221,14 +221,20 @@ collectSpansTypes' withConstraints tcs f =
                , G.isPredTy c = first (c:) $ getPreds t
                | otherwise = ([], x)
 
-listifySpans :: Typeable a => TypecheckedSource -> (Int, Int) -> [Located a]
+#if __GLASGOW_HASKELL__ >= 808
+type Constraints a = (Typeable a, Typeable (G.SrcSpanLess a), G.HasSrcSpan a)
+#else
+type Constraints a = (Typeable a)
+#endif
+
+listifySpans :: Constraints a => TypecheckedSource -> (Int, Int) -> [a]
 #if __GLASGOW_HASKELL__ >= 804
 listifySpans tcs lc = listify p tcs
 #else
 listifySpans tcs lc = listifyStaged TypeChecker p tcs
 #endif
   where
-    p (L spn _) = G.isGoodSrcSpan spn && spn `G.spans` lc
+    p (G.dL->L spn _) = G.isGoodSrcSpan spn && spn `G.spans` lc
 
 -- listifyParsedSpans :: Typeable a => ParsedSource -> (Int, Int) -> [Located a]
 -- #if __GLASGOW_HASKELL__ >= 804
diff --git a/GhcMod/DebugLogger.hs b/GhcMod/DebugLogger.hs
index 1b10e2f7..81c85c11 100644
--- a/GhcMod/DebugLogger.hs
+++ b/GhcMod/DebugLogger.hs
@@ -112,7 +112,10 @@ gmPrintDoc_ mode pprCols putS doc
     put (Str s)  next = putS s >> next
     put (PStr s) next = putS (unpackFS s) >> next
     put (ZStr s) next = putS (zString s) >> next
-#if __GLASGOW_HASKELL__ >= 806
+#if __GLASGOW_HASKELL__ >= 808
+    put (LStr s) next   = putS (unpackPtrString s) >> next
+    put (RStr n c) next = putS (replicate n c) >> next
+#elif __GLASGOW_HASKELL__ >= 806
     put (LStr s) next   = putS (unpackLitString s) >> next
     put (RStr n c) next = putS (replicate n c) >> next
 #else
diff --git a/GhcMod/DynFlagsTH.hs b/GhcMod/DynFlagsTH.hs
index d10d7e91..853b924a 100644
--- a/GhcMod/DynFlagsTH.hs
+++ b/GhcMod/DynFlagsTH.hs
@@ -94,6 +94,8 @@ deriveEqDynFlags qds = do
            , "OverridingBool" -- added for ghc-8.2
            , "Scheme"         -- added for ghc-8.2
            , "LoadedPlugin"   -- added for ghc-8.6
+           , "StaticPlugin"   -- added for ghc-8.8
+           , "CfgWeights"     -- added for ghc-8.8 AZ:Correct?
            ]
        ignoredTypeOccNames = [ "OnOff" ]
 
diff --git a/GhcMod/Gap.hs b/GhcMod/Gap.hs
index 3f3be28b..134d09e4 100644
--- a/GhcMod/Gap.hs
+++ b/GhcMod/Gap.hs
@@ -213,7 +213,12 @@ renderGm = Pretty.fullRender Pretty.PageMode 80 1.2 string_txt ""
    string_txt (Pretty.Chr c)   s  = c:s
    string_txt (Pretty.Str s1)  s2 = s1 ++ s2
    string_txt (Pretty.PStr s1) s2 = unpackFS s1 ++ s2
-#if __GLASGOW_HASKELL__ >= 806
+#if __GLASGOW_HASKELL__ >= 808
+   string_txt (Pretty.LStr s1) s2 = unpackPtrString s1 ++ s2
+                   -- a '\0'-terminated array of bytes
+   string_txt (Pretty.RStr n c) s2 = replicate n c ++ s2
+                   -- a repeated character (e.g., ' ')
+#elif __GLASGOW_HASKELL__ >= 806
    string_txt (Pretty.LStr s1) s2 = unpackLitString s1 ++ s2
                    -- a '\0'-terminated array of bytes
    string_txt (Pretty.RStr n c) s2 = replicate n c ++ s2
@@ -405,7 +410,11 @@ setNoMaxRelevantBindings = id
 ----------------------------------------------------------------
 ----------------------------------------------------------------
 
+#if __GLASGOW_HASKELL__ >= 808
+class (HasSrcSpan a) => HasType a where
+#else
 class HasType a where
+#endif
     getType :: GhcMonad m => TypecheckedModule -> a -> m (Maybe (SrcSpan, Type))
 
 
diff --git a/GhcMod/LightGhc.hs b/GhcMod/LightGhc.hs
index 37b0ccbe..1b1ca705 100644
--- a/GhcMod/LightGhc.hs
+++ b/GhcMod/LightGhc.hs
@@ -41,7 +41,11 @@ newLightEnv mdf = do
 #else
      initStaticOpts
 #endif
+#if __GLASGOW_HASKELL__ >= 808
+     settings <- initSysTools libdir
+#else
      settings <- initSysTools (Just libdir)
+#endif
 #if __GLASGOW_HASKELL__ >= 806
      let llvmTgtList = ([],[]) -- TODO: where should this come from?
      initDynFlags $ defaultDynFlags settings llvmTgtList
diff --git a/GhcMod/SrcUtils.hs b/GhcMod/SrcUtils.hs
index fc68a19c..49be3a3a 100644
--- a/GhcMod/SrcUtils.hs
+++ b/GhcMod/SrcUtils.hs
@@ -3,6 +3,8 @@
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}
+{-# LANGUAGE ViewPatterns       #-}
+{-# LANGUAGE PatternSynonyms    #-}
 
 module GhcMod.SrcUtils
   (
@@ -21,7 +23,10 @@ import CoreUtils (exprType)
 import Data.Generics
 import Data.Maybe
 import Data.Ord as O
-import GHC (LHsExpr, LPat, DynFlags, SrcSpan, Type, Located, TypecheckedSource, GenLocated(L))
+import GHC (LHsBind,LHsExpr,HsExpr, LPat, Pat, DynFlags, SrcSpan, Type, Located, TypecheckedSource, GenLocated(L))
+#if __GLASGOW_HASKELL__ >= 808
+import SrcLoc (pattern LL)
+#endif
 import qualified GHC as G
 import qualified Var as G
 import qualified Type as G
@@ -49,7 +54,11 @@ instance HasType (LHsExpr GhcTc) where
         return $ (G.getLoc e, ) <$> CoreUtils.exprType <$> mbe
 
 instance HasType (LPat GhcTc) where
+#if __GLASGOW_HASKELL__ >= 808
+    getType _ (G.dL-> (G.L spn pat)) = return $ Just (spn, hsPatType pat)
+#else
     getType _ (G.L spn pat) = return $ Just (spn, hsPatType pat)
+#endif
 
 ----------------------------------------------------------------
 
@@ -85,8 +94,11 @@ collectSpansTypes' withConstraints tcs f =
     ((return [],)
       `mkQ`  (hsBind    :: G.LHsBind GhcTc -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)) -- matches on binds
       `extQ` (genericCT :: G.LHsExpr GhcTc -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)) -- matches on expressions
+#if __GLASGOW_HASKELL__ >= 808
+      `extQ` (genericCTT:: G.LPat    GhcTc -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)) -- matches on patterns
+#else
       `extQ` (genericCT :: G.LPat    GhcTc -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)) -- matches on patterns
-
+#endif
       )
     (G.tm_typechecked_source tcs)
   where
@@ -115,12 +127,25 @@ collectSpansTypes' withConstraints tcs f =
     -- Otherwise, it's the same as other cases
     hsBind x s = genericCT x s
     -- Generic SYB function to get type
+    -- genericCT :: forall b . (Data (b GhcTc), HasType (Located (b GhcTc)))
+    -- genericCT :: forall b . (Data (b GhcTc), HasType (b GhcTc))
+    --           => (b GhcTc) -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)
+    -- genericCT :: forall b . Located (G.HsBind GhcTc) -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)
     genericCT :: forall b . (Data (b GhcTc), HasType (Located (b GhcTc)))
               => Located (b GhcTc) -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)
     genericCT x s
       | withConstraints
       = (maybe [] (uncurry $ constrainedType (collectBinders x) s) <$> getType' x, s)
       | otherwise = (maybeToList <$> getType' x, s)
+
+#if __GLASGOW_HASKELL__ >= 808
+    genericCTT :: forall b .
+                 LPat GhcTc -> CstGenQS -> (m [(SrcSpan, Type)], CstGenQS)
+    genericCTT x s
+      | withConstraints
+      = (maybe [] (uncurry $ constrainedType (collectBinders x) s) <$> getType' x, s)
+      | otherwise = (maybeToList <$> getType' x, s)
+#endif
 #if __GLASGOW_HASKELL__ >= 804
     -- Collects everything with Id from LHsBind, LHsExpr, or LPat
     collectBinders :: Data a => a -> [G.IdP GhcTc]
@@ -131,8 +156,15 @@ collectSpansTypes' withConstraints tcs f =
     collectBinders = listifyStaged TypeChecker (const True)
 #endif
     -- Gets monomorphic type with location
+    -- getType' :: forall t . (HasType (Located t)) => Located t -> m (Maybe (SrcSpan, Type))
+    -- getType' :: forall t . (HasType (t)) => Located t -> m (Maybe (SrcSpan, Type))
+#if __GLASGOW_HASKELL__ >= 808
+    getType' :: forall t . (HasType t) => t -> m (Maybe (SrcSpan, Type))
+    getType' x@(LL spn _)
+#else
     getType' :: forall t . (HasType (Located t)) => Located t -> m (Maybe (SrcSpan, Type))
     getType' x@(L spn _)
+#endif
       | G.isGoodSrcSpan spn && f spn
       = getType tcs x
       | otherwise = return Nothing

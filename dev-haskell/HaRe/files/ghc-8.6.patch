diff --git a/src/Language/Haskell/Refact/Refactoring/DeleteDef.hs b/src/Language/Haskell/Refact/Refactoring/DeleteDef.hs
index 039eee30..99ab2437 100644
--- a/src/Language/Haskell/Refact/Refactoring/DeleteDef.hs
+++ b/src/Language/Haskell/Refact/Refactoring/DeleteDef.hs
@@ -36,7 +36,10 @@ compDeleteDef fileName (row,col) = do
     Just pn@(GHC.L _ n) ->
       do
         logm $ "DeleteDef.comp: before isPNUsed"
-        Just ghcn <- locToName (row,col) parsed
+        mghcn <- locToName (row,col) parsed
+        ghcn <- case mghcn of
+          Just ghcn' -> return ghcn'
+          Nothing -> error "ghcn must be a Just value"
         pnIsUsedLocal <- isPNUsed ghcn targetModule fileName
         clients <- clientModsAndFiles targetModule
         pnUsedClients <- isPNUsedInClients ghcn n targetModule
diff --git a/src/Language/Haskell/Refact/Refactoring/MaybeToMonadPlus.hs b/src/Language/Haskell/Refact/Refactoring/MaybeToMonadPlus.hs
index 82e06037..e2a5def7 100644
--- a/src/Language/Haskell/Refact/Refactoring/MaybeToMonadPlus.hs
+++ b/src/Language/Haskell/Refact/Refactoring/MaybeToMonadPlus.hs
@@ -96,16 +96,22 @@ doMaybeToPlus pos argNum = do
 isOutputType :: Int -> SimpPos -> GHC.HsBind GhcPs -> RefactGhc Bool
 isOutputType argNum pos funBind = do
   parsed <- getRefactParsed
-  (Just name) <- locToName pos parsed
-  (Just ty)   <- getTypeForName name
-  -- logDataWithAnns "isOutputType:ty" ty
+  mname <- locToName pos parsed
+  name <- case mname of
+    Just name' -> return name'
+    Nothing -> error "mempty value of Bool must use a just value"
+  mty   <- getTypeForName name
+  ty <- case mty of
+    Just ty' -> return ty'
+    Nothing -> error "mempty value of Bool must use a just value"
   let depth = typeDepth ty
+  -- logDataWithAnns "isOutputType:ty" ty
   logm $ "isOutputType:depth=" ++ show depth
   return $ depth == argNum
     where typeDepth :: GHC.Type -> Int
           typeDepth ty = case (GHC.isFunTy ty) of
-            True  -> 1 + typeDepth (GHC.funResultTy ty)
-            False -> 1
+                True  -> 1 + typeDepth (GHC.funResultTy ty)
+                False -> 1
 
 -- | This handles the case where only the output type of the function is being
 -- modified so calls to Nothing and Just can be replaced with mzero and return
diff --git a/src/Language/Haskell/Refact/Utils/MonadFunctions.hs b/src/Language/Haskell/Refact/Utils/MonadFunctions.hs
index 7abc01e1..940a1fb8 100644
--- a/src/Language/Haskell/Refact/Utils/MonadFunctions.hs
+++ b/src/Language/Haskell/Refact/Utils/MonadFunctions.hs
@@ -120,9 +120,10 @@ import Outputable
 -- |fetch the final annotations
 fetchAnnsFinal :: RefactGhc Anns
 fetchAnnsFinal = do
-  Just tm <- gets rsModule
-  let anns = (tkCache $ rsTokenCache tm) Map.! mainTid
-  return anns
+  mtm <- gets rsModule
+  case mtm of
+    Just tm -> return ((tkCache $ rsTokenCache tm) Map.! mainTid)
+    Nothing -> error "mempty value of Anns must use a just value"
 
 -- ---------------------------------------------------------------------
 
@@ -135,8 +136,10 @@ getTypecheckedModule = do
 
 getRefactStreamModified :: RefactGhc RefacResult
 getRefactStreamModified = do
-  Just tm <- gets rsModule
-  return $ rsStreamModified tm
+  mtm <- gets rsModule
+  case mtm of
+     Just tm -> return $ rsStreamModified tm
+     Nothing -> error "mempty value of RefacResult must use a just value"
 
 -- |For testing
 setRefactStreamModified :: RefacResult -> RefactGhc ()

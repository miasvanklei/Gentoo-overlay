diff --git a/cl4d/buffer.d b/cl4d/buffer.d
index 76fe6b4..6d2f30a 100644
--- a/cl4d/buffer.d
+++ b/cl4d/buffer.d
@@ -137,46 +137,3 @@ struct CLBufferGL
 		));
 	}
 }
-
-/**
- *	memory buffer interface for GL interop with renderbuffer
- * 
- *	NB: If the state of a GL renderbuffer object is modified through the GL API (i.e. changes to the
- *	dimensions or format used to represent pixels of the GL renderbuffer using appropriate GL API
- *	calls such as glRenderbufferStorage) while there exists a corresponding CL image object,
- *	subsequent use of the CL image object will result in undefined behavior
- */
-struct CLBufferRenderGL
-{
-	CLBuffer sup;
-	alias sup this;
-
-	/**
-	 *	creates an OpenCL 2D image object from an OpenGL renderbuffer object
-	 *
-	 *	Params:
-	 *		context			=	a valid OpenCL context created from an OpenGL context
-	 *		flags			=	only CL_MEM_READ_ONLY, CL_MEM_WRITE_ONLY and CL_MEM_READ_WRITE can be used
-	 *		renderbuffer	=	renderbuffer is the name of a GL renderbuffer object.
-	 *							The renderbuffer storage must be specified before the image object can be created. The renderbuffer format and dimensions
-	 *							defined by OpenGL will be used to create the 2D image object. Only GL renderbuffers with
-	 *							internal formats that maps to appropriate image channel order and data type specified in tables
-	 *							5.5 and 5.6 of the spec can be used to create the 2D image object
-	 */
-	this(CLContext context, cl_mem_flags flags, cl_GLuint renderbuffer)
-	{
-		cl_errcode res;
-		sup = CLBuffer(clCreateFromGLRenderbuffer(context.cptr, flags, renderbuffer, &res));
-		
-		mixin(exceptionHandling(
-			["CL_INVALID_CONTEXT",					"context is not a valid context or was not created from a GL context"],
-			["CL_INVALID_VALUE",					"invalid flags"],
-			["CL_INVALID_GL_OBJECT",				"renderbuffer is not a GL renderbuffer object or if the width or height of renderbuffer is zero"],
-			["CL_INVALID_IMAGE_FORMAT_DESCRIPTOR",	"the OpenGL renderbuffer internal format does not map to a supported OpenCL image format"],
-			["CL_INVALID_OPERATION",				"renderbuffer is a multi-sample GL renderbuffer object"],
-			["CL_OUT_OF_RESOURCES",					""],
-			["CL_OUT_OF_HOST_MEMORY",				""]
-			
-		));
-	}
-}
diff --git a/cl4d/image.d b/cl4d/image.d
index b4640aa..3e00bb6 100644
--- a/cl4d/image.d
+++ b/cl4d/image.d
@@ -88,18 +88,6 @@ struct CLImage
 		{
 			return this.getInfo!(size_t, clGetImageInfo)(CL_IMAGE_DEPTH);
 		}
-
-		//! The target argument specified in CLImage2DGL, CLImage3DGL constructors
-		cl_GLenum textureTarget()
-		{
-			return this.getInfo!(cl_GLenum, clGetGLTextureInfo)(CL_GL_TEXTURE_TARGET);
-		}
-
-		//! The miplevel argument specified in CLImage2DGL, CLImage3DGL constructors
-		cl_GLint mipmapLevel()
-		{
-			return this.getInfo!(cl_GLint, clGetGLTextureInfo)(CL_GL_MIPMAP_LEVEL);
-		}
 	} // of @property
 }
 
diff --git a/cl4d/memory.d b/cl4d/memory.d
index 235b6ed..8167fbc 100644
--- a/cl4d/memory.d
+++ b/cl4d/memory.d
@@ -48,26 +48,6 @@ public:
 		));
 	}
 
-	/**
-	 *	The OpenGL object used to create the OpenCL memory object (if any) and information about the object
-	 *	type i.e. whether it is a texture, renderbuffer or buffer object can be queried using the following function.
-	 *
-	 *	Params:
-	 *	    glObjectType = returns the type of GL object attached to this memory object
-	 *	    glObjectName = returns the GL object used to create this memory object
-	 */
-	void getGLObjectInfo(out cl_gl_object_type glObjectType, out cl_GLuint glObjectName)
-	{
-		cl_errcode res = clGetGLObjectInfo(this._object, &glObjectType, &glObjectName);
-
-		mixin(exceptionHandling(
-			["CL_INVALID_MEM_OBJECT",	""],
-			["CL_INVALID_GL_OBJECT",	"there is no GL object associated with memobj"],
-			["CL_OUT_OF_RESOURCES",		""],
-			["CL_OUT_OF_HOST_MEMORY",	""]
-		));
-	}
-
 @property
 {
 	version(CL_VERSION_1_1)

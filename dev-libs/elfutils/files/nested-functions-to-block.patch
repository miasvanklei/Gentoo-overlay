--- a/libcpu/i386_parse.y	2016-02-05 17:30:50.282704097 +0100
+++ b/libcpu/i386_parse.y	2016-02-04 17:16:15.701542115 +0100
@@ -1,3 +1,4 @@
+
 %{
 /* Parser for i386 CPU description.
    Copyright (C) 2004, 2005, 2007, 2008, 2009 Red Hat, Inc.
@@ -309,10 +310,10 @@
 			  newp->mnemonic = $4;
 			  if (newp->mnemonic != (void *) -1l
 			      && tfind ($4, &mnemonics,
-					(comparison_fn_t) strcmp) == NULL)
+					strcmp) == NULL)
 			    {
 			      if (tsearch ($4, &mnemonics,
-					   (comparison_fn_t) strcmp) == NULL)
+					   strcmp) == NULL)
 				error (EXIT_FAILURE, errno, "tsearch");
 			      ++nmnemonics;
 			    }
--- a/libdwfl/dwfl_segment_report_module.c	2016-02-05 17:30:50.296704626 +0100
+++ b/libdwfl/dwfl_segment_report_module.c	2016-02-04 17:28:59.205683132 +0100
@@ -235,6 +235,7 @@
   return false;
 }
 
+
 int
 dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
 			    Dwfl_Memory_Callback *memory_callback,
@@ -260,19 +261,19 @@
 
   GElf_Addr start = dwfl->lookup_addr[segment];
 
-  inline bool segment_read (int segndx,
+  bool (^segment_read) (int, void**, size_t*, GElf_Addr, size_t) = ^bool (int segndx,
 			    void **buffer, size_t *buffer_available,
 			    GElf_Addr addr, size_t minread)
   {
     return ! (*memory_callback) (dwfl, segndx, buffer, buffer_available,
 				 addr, minread, memory_callback_arg);
-  }
+  };
 
-  inline void release_buffer (void **buffer, size_t *buffer_available)
+  void (^release_buffer) (void**, size_t*) = ^void (void **buffer, size_t *buffer_available)
   {
     if (*buffer != NULL)
       (void) segment_read (-1, buffer, buffer_available, 0, 0);
-  }
+  };
 
   /* First read in the file header and check its sanity.  */
 
@@ -285,7 +286,7 @@
      here so we can always safely free it.  */
   void *phdrsp = NULL;
 
-  inline int finish (void)
+  int (^finish) (void) = ^int (void)
   {
     free (phdrsp);
     release_buffer (&buffer, &buffer_available);
@@ -294,14 +295,14 @@
     if (fd != -1)
       close (fd);
     return ndx;
-  }
+  };
 
   if (segment_read (ndx, &buffer, &buffer_available,
 		    start, sizeof (Elf64_Ehdr))
       || memcmp (buffer, ELFMAG, SELFMAG) != 0)
     return finish ();
 
-  inline bool read_portion (void **data, size_t *data_size,
+  bool (^read_portion)(void**, size_t*, GElf_Addr, size_t) = ^bool (void **data, size_t *data_size,
 			    GElf_Addr vaddr, size_t filesz)
   {
     if (vaddr - start + filesz > buffer_available
@@ -320,13 +321,13 @@
     *data = vaddr - start + buffer;
     *data_size = 0;
     return false;
-  }
+  };
 
-  inline void finish_portion (void **data, size_t *data_size)
+  void (^finish_portion) (void **, size_t*) = ^void (void **data, size_t *data_size)
   {
     if (*data_size != 0)
       release_buffer (data, data_size);
-  }
+  };
 
   /* Extract the information we need from the file header.  */
   const unsigned char *e_ident;
@@ -342,13 +343,13 @@
   uint_fast16_t phnum;
   uint_fast16_t phentsize;
   GElf_Off shdrs_end;
-  Elf_Data xlatefrom =
+  __block Elf_Data xlatefrom =
     {
       .d_type = ELF_T_EHDR,
       .d_buf = (void *) buffer,
       .d_version = EV_CURRENT,
     };
-  Elf_Data xlateto =
+  __block Elf_Data xlateto =
     {
       .d_type = ELF_T_EHDR,
       .d_buf = &ehdr,
@@ -421,31 +422,31 @@
   xlateto.d_size = phdrsp_bytes;
 
   /* Track the bounds of the file visible in memory.  */
-  GElf_Off file_trimmed_end = 0; /* Proper p_vaddr + p_filesz end.  */
-  GElf_Off file_end = 0;	 /* Rounded up to effective page size.  */
-  GElf_Off contiguous = 0;	 /* Visible as contiguous file from START.  */
-  GElf_Off total_filesz = 0;	 /* Total size of data to read.  */
+  __block GElf_Off file_trimmed_end = 0; /* Proper p_vaddr + p_filesz end.  */
+  __block GElf_Off file_end = 0;	 /* Rounded up to effective page size.  */
+  __block GElf_Off contiguous = 0;	 /* Visible as contiguous file from START.  */
+  __block GElf_Off total_filesz = 0;	 /* Total size of data to read.  */
 
   /* Collect the bias between START and the containing PT_LOAD's p_vaddr.  */
-  GElf_Addr bias = 0;
-  bool found_bias = false;
+  __block GElf_Addr bias = 0;
+  __block bool found_bias = false;
 
   /* Collect the unbiased bounds of the module here.  */
-  GElf_Addr module_start = -1l;
-  GElf_Addr module_end = 0;
-  GElf_Addr module_address_sync = 0;
+  __block GElf_Addr module_start = -1l;
+  __block GElf_Addr module_end = 0;
+  __block GElf_Addr module_address_sync = 0;
 
   /* If we see PT_DYNAMIC, record it here.  */
-  GElf_Addr dyn_vaddr = 0;
-  GElf_Xword dyn_filesz = 0;
+  __block GElf_Addr dyn_vaddr = 0;
+  __block GElf_Xword dyn_filesz = 0;
 
   /* Collect the build ID bits here.  */
-  void *build_id = NULL;
-  size_t build_id_len = 0;
-  GElf_Addr build_id_vaddr = 0;
+  __block void *build_id = NULL;
+  __block size_t build_id_len = 0;
+  __block GElf_Addr build_id_vaddr = 0;
 
   /* Consider a PT_NOTE we've found in the image.  */
-  inline void consider_notes (GElf_Addr vaddr, GElf_Xword filesz)
+  void (^consider_notes) (GElf_Addr, GElf_Xword) = ^void (GElf_Addr vaddr, GElf_Xword filesz)
   {
     /* If we have already seen a build ID, we don't care any more.  */
     if (build_id != NULL || filesz == 0)
@@ -505,10 +506,10 @@
     if (notes != data)
       free (notes);
     finish_portion (&data, &data_size);
-  }
+  };
 
   /* Consider each of the program headers we've read from the image.  */
-  inline void consider_phdr (GElf_Word type,
+  void (^consider_phdr) (GElf_Word, GElf_Addr, GElf_Xword, GElf_Off, GElf_Xword, GElf_Xword) = ^void (GElf_Word type,
 			     GElf_Addr vaddr, GElf_Xword memsz,
 			     GElf_Off offset, GElf_Xword filesz,
 			     GElf_Xword align)
@@ -574,7 +575,7 @@
 	  module_end = vaddr_end;
 	break;
       }
-  }
+  };
 
   Elf32_Phdr (*p32)[phnum] = phdrsp;
   Elf64_Phdr (*p64)[phnum] = phdrsp;
@@ -721,11 +722,11 @@
      We need its DT_STRTAB and DT_STRSZ to decipher DT_SONAME,
      and they also tell us the essential portion of the file
      for fetching symbols.  */
-  GElf_Addr soname_stroff = 0;
-  GElf_Addr dynstr_vaddr = 0;
-  GElf_Xword dynstrsz = 0;
-  bool execlike = false;
-  inline bool consider_dyn (GElf_Sxword tag, GElf_Xword val)
+  __block GElf_Addr soname_stroff = 0;
+  __block GElf_Addr dynstr_vaddr = 0;
+  __block GElf_Xword dynstrsz = 0;
+  __block bool execlike = false;
+  bool (^consider_dyn) (GElf_Sxword, GElf_Xword) = ^bool (GElf_Sxword tag, GElf_Xword val)
   {
     switch (tag)
       {
@@ -750,7 +751,7 @@
       }
 
     return soname_stroff != 0 && dynstr_vaddr != 0 && dynstrsz != 0;
-  }
+  };
 
   const size_t dyn_entsize = (ei_class == ELFCLASS32
 			      ? sizeof (Elf32_Dyn) : sizeof (Elf64_Dyn));
@@ -879,25 +880,25 @@
       if (unlikely (contents == NULL))
 	return finish ();
 
-      inline void final_read (size_t offset, GElf_Addr vaddr, size_t size)
+      void (^final_read) (size_t, GElf_Addr, size_t) = ^void (size_t offset, GElf_Addr vaddr, size_t size)
       {
 	void *into = contents + offset;
 	size_t read_size = size;
 	(void) segment_read (addr_segndx (dwfl, segment, vaddr, false),
 			     &into, &read_size, vaddr, size);
-      }
+      };
 
       if (contiguous < file_trimmed_end)
 	{
 	  /* We can't use the memory image verbatim as the file image.
 	     So we'll be reading into a local image of the virtual file.  */
 
-	  inline void read_phdr (GElf_Word type, GElf_Addr vaddr,
+	  void (^read_phdr) (GElf_Word, GElf_Addr, GElf_Off, GElf_Xword) = ^void (GElf_Word type, GElf_Addr vaddr,
 				 GElf_Off offset, GElf_Xword filesz)
 	  {
 	    if (type == PT_LOAD)
 	      final_read (offset, vaddr + bias, filesz);
-	  }
+	  };
 
 	  if (ei_class == ELFCLASS32)
 	    for (uint_fast16_t i = 0; i < phnum; ++i)
--- a/libdwfl/link_map.c	2016-02-05 17:30:50.298704701 +0100
+++ b/libdwfl/link_map.c	2016-02-04 17:09:08.529213499 +0100
@@ -249,20 +249,23 @@
 		struct r_debug_info *r_debug_info)
 {
   /* Skip r_version, to aligned r_map field.  */
-  GElf_Addr read_vaddr = r_debug_vaddr + addrsize (elfclass);
+  __block GElf_Addr read_vaddr = r_debug_vaddr + addrsize (elfclass);
 
   void *buffer = NULL;
   size_t buffer_available = 0;
-  inline int release_buffer (int result)
+  int (^release_buffer) (int) = ^int (int result)
   {
     if (buffer != NULL)
       (void) (*memory_callback) (dwfl, -1, &buffer, &buffer_available, 0, 0,
 				 memory_callback_arg);
     return result;
-  }
+  };
 
+  __block struct {
   GElf_Addr addrs[4];
-  inline bool read_addrs (GElf_Addr vaddr, size_t n)
+  } results;
+
+  bool (^read_addrs) (GElf_Addr, size_t) = ^bool (GElf_Addr vaddr, size_t n)
   {
     size_t nb = n * addrsize (elfclass); /* Address words -> bytes to read.  */
 
@@ -289,28 +292,28 @@
       {
 	if (elfdata == ELFDATA2MSB)
 	  for (size_t i = 0; i < n; ++i)
-	    addrs[i] = BE32 (read_4ubyte_unaligned_noncvt (&(*a32)[i]));
+	    results.addrs[i] = BE32 (read_4ubyte_unaligned_noncvt (&(*a32)[i]));
 	else
 	  for (size_t i = 0; i < n; ++i)
-	    addrs[i] = LE32 (read_4ubyte_unaligned_noncvt (&(*a32)[i]));
+	    results.addrs[i] = LE32 (read_4ubyte_unaligned_noncvt (&(*a32)[i]));
       }
     else
       {
 	if (elfdata == ELFDATA2MSB)
 	  for (size_t i = 0; i < n; ++i)
-	    addrs[i] = BE64 (read_8ubyte_unaligned_noncvt (&(*a64)[i]));
+	    results.addrs[i] = BE64 (read_8ubyte_unaligned_noncvt (&(*a64)[i]));
 	else
 	  for (size_t i = 0; i < n; ++i)
-	    addrs[i] = LE64 (read_8ubyte_unaligned_noncvt (&(*a64)[i]));
+	    results.addrs[i] = LE64 (read_8ubyte_unaligned_noncvt (&(*a64)[i]));
       }
 
     return false;
-  }
+  };
 
   if (unlikely (read_addrs (read_vaddr, 1)))
     return release_buffer (-1);
 
-  GElf_Addr next = addrs[0];
+  GElf_Addr next = results.addrs[0];
 
   Dwfl_Module **lastmodp = &dwfl->modulelist;
   int result = 0;
@@ -330,9 +333,9 @@
          recalculate the difference below because the ELF file we use
          might be differently pre-linked.  */
       // GElf_Addr l_addr = addrs[0];
-      GElf_Addr l_name = addrs[1];
-      GElf_Addr l_ld = addrs[2];
-      next = addrs[3];
+      GElf_Addr l_name = results.addrs[1];
+      GElf_Addr l_ld = results.addrs[2];
+      next = results.addrs[3];
 
       /* If a clobbered or truncated memory image has no useful pointer,
 	 just skip this element.  */
@@ -754,11 +757,11 @@
 	}
 
       /* If we found the phdr dimensions, search phdrs for PT_DYNAMIC.  */
-      GElf_Addr dyn_vaddr = 0;
-      GElf_Xword dyn_filesz = 0;
-      GElf_Addr dyn_bias = (GElf_Addr) -1;
+      __block GElf_Addr dyn_vaddr = 0;
+      __block GElf_Xword dyn_filesz = 0;
+      __block GElf_Addr dyn_bias = (GElf_Addr) -1;
 
-      inline bool consider_phdr (GElf_Word type,
+      bool (^consider_phdr) (GElf_Word, GElf_Addr, GElf_Xword) = ^bool (GElf_Word type,
 				 GElf_Addr vaddr, GElf_Xword filesz)
       {
 	switch (type)
@@ -781,7 +784,7 @@
 	  }
 
 	return false;
-      }
+      };
 
       if (phdr != 0 && phnum != 0)
 	{
--- a/src/addr2line.c	2016-02-05 17:30:50.325705720 +0100
+++ b/src/addr2line.c	2016-02-04 19:24:43.317921331 +0100
@@ -705,20 +705,20 @@
 	  Dwarf_Line *info = dwfl_dwarf_line (line, &bias);
 	  assert (info != NULL);
 
-	  inline void show (int (*get) (Dwarf_Line *, bool *),
+	  void (^show) (int (*get) (Dwarf_Line*, bool *), const char*) = ^void (int (*get) (Dwarf_Line *, bool *),
 			    const char *note)
 	  {
 	    bool flag;
 	    if ((*get) (info, &flag) == 0 && flag)
 	      fputs (note, stdout);
-	  }
-	  inline void show_int (int (*get) (Dwarf_Line *, unsigned int *),
+	  };
+	  void (^show_int) (int (*get) (Dwarf_Line *, unsigned int *), const char*) = ^void (int (*get) (Dwarf_Line *, unsigned int *),
 				const char *name)
 	  {
 	    unsigned int val;
 	    if ((*get) (info, &val) == 0 && val != 0)
 	      printf (" (%s %u)", name, val);
-	  }
+	  };
 
 	  show (&dwarf_linebeginstatement, " (is_stmt)");
 	  show (&dwarf_lineblock, " (basic_block)");
--- a/src/ar.c	2016-02-05 17:30:50.325705720 +0100
+++ b/src/ar.c	2016-02-04 19:28:43.175445638 +0100
@@ -43,7 +43,8 @@
 #include <system.h>
 
 #include "arlib.h"
-
+# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)
+#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
 
 /* Name and version of program.  */
 static void print_version (FILE *stream, struct argp_state *state);
@@ -459,8 +460,8 @@
   bool found[argc];
   memset (found, '\0', sizeof (found));
 
-  size_t name_max = 0;
-  inline bool should_truncate_fname (void)
+  __block size_t name_max = 0;
+  bool (^should_truncate_fname) (void) = ^bool (void)
   {
     if (errno == ENAMETOOLONG && allow_truncate_fname)
       {
@@ -473,7 +474,7 @@
 	return name_max != 0;
       }
     return false;
-  }
+  };
 
   off_t index_off = -1;
   size_t index_size = 0;
--- a/src/elfcompress.c	2016-02-05 17:32:10.339713698 +0100
+++ b/src/elfcompress.c	2016-02-04 19:47:13.228386241 +0100
@@ -263,7 +263,7 @@
   Elf *elf = NULL;
 
   /* The output ELF.  */
-  char *fnew = NULL;
+  __block char *fnew = NULL;
   int fdnew = -1;
   Elf *elfnew = NULL;
 
@@ -286,17 +286,17 @@
   size_t shnum = 0;
 
 #define WORD_BITS (8U * sizeof (unsigned int))
-  void set_section (size_t ndx)
+  void (^set_section) (size_t) = ^void (size_t ndx)
   {
     sections[ndx / WORD_BITS] |= (1U << (ndx % WORD_BITS));
-  }
+  };
 
-  bool get_section (size_t ndx)
+  bool (^get_section) (size_t) = ^bool (size_t ndx)
   {
     return (sections[ndx / WORD_BITS] & (1U << (ndx % WORD_BITS))) != 0;
-  }
+  };
 
-  int cleanup (int res)
+  int (^cleanup) (int) = ^int (int res)
   {
     elf_end (elf);
     close (fd);
@@ -329,7 +329,7 @@
     free (sections);
 
     return res;
-  }
+  };
 
   fd = open (fname, O_RDONLY);
   if (fd < 0)
--- a/src/elflint.c	2016-02-05 17:30:50.326705757 +0100
+++ b/src/elflint.c	2016-02-04 19:20:51.957709812 +0100
@@ -3403,10 +3403,10 @@
       return;
     }
 
-  inline size_t pos (const unsigned char *p)
+  size_t (^pos) (const unsigned char *) = ^size_t (const unsigned char *p)
   {
     return p - (const unsigned char *) data->d_buf;
-  }
+  };
 
   const unsigned char *p = data->d_buf;
   if (*p++ != 'A')
@@ -3416,10 +3416,10 @@
       return;
     }
 
-  inline size_t left (void)
+  size_t (^left) (void) = ^size_t (void)
   {
     return (const unsigned char *) data->d_buf + data->d_size - p;
-  }
+  };
 
   while (left () >= 4)
     {
--- a/src/ld.h	2016-02-05 17:30:50.327705795 +0100
+++ b/src/ld.h	2016-02-04 19:17:23.148363874 +0100
@@ -291,7 +291,7 @@
   const char **(*lib_extensions) (struct ld_state *)
        __attribute__ ((__const__));
 #define LIB_EXTENSION(state) \
-  DL_CALL_FCT ((state)->callbacks.lib_extensions, (state))
+  (state)->callbacks.lib_extensions(state)
 
   /* Process the given file.  If the file is not yet open, open it.
      The first parameter is a file descriptor for the file which can
@@ -302,12 +302,13 @@
   int (*file_process) (int fd, struct usedfiles *, struct ld_state *,
 		       struct usedfiles **);
 #define FILE_PROCESS(fd, file, state, nextp) \
-  DL_CALL_FCT ((state)->callbacks.file_process, (fd, file, state, nextp))
+  (state)->callbacks.file_process(fd, file, state, nextp)
+
 
   /* Close the given file.  */
   int (*file_close) (struct usedfiles *, struct ld_state *);
 #define FILE_CLOSE(file, state) \
-  DL_CALL_FCT ((state)->callbacks.file_close, (file, state))
+  (state)->callbacks.file_close(file, state)
 
   /* Create the output sections now.  This requires knowledge about
      all the sections we will need.  It may be necessary to sort the
@@ -319,99 +320,99 @@
      output routines.  */
   void (*create_sections) (struct ld_state *);
 #define CREATE_SECTIONS(state) \
-  DL_CALL_FCT ((state)->callbacks.create_sections, (state))
+  (state)->callbacks.create_sections(state)
 
   /* Determine whether we have any non-weak unresolved references left.  */
   int (*flag_unresolved) (struct ld_state *);
 #define FLAG_UNRESOLVED(state) \
-  DL_CALL_FCT ((state)->callbacks.flag_unresolved, (state))
+  (state)->callbacks.flag_unresolved(state)
 
   /* Create the sections which are generated by the linker and are not
      present in the input file.  */
   void (*generate_sections) (struct ld_state *);
 #define GENERATE_SECTIONS(state) \
-  DL_CALL_FCT ((state)->callbacks.generate_sections, (state))
+  (state)->callbacks.generate_sections(state)
 
   /* Open the output file.  The file name is given or "a.out".  We
      create as much of the ELF structure as possible.  */
   int (*open_outfile) (struct ld_state *, int, int, int);
 #define OPEN_OUTFILE(state, machine, class, data) \
-  DL_CALL_FCT ((state)->callbacks.open_outfile, (state, machine, class, data))
+  (state)->callbacks.open_outfile(state, machine, class, data)
 
   /* Create the data for the output file.  */
   int (*create_outfile) (struct ld_state *);
 #define CREATE_OUTFILE(state) \
-  DL_CALL_FCT ((state)->callbacks.create_outfile, (state))
+  (state)->callbacks.create_outfile(state)
 
   /* Process a relocation section.  */
   void (*relocate_section) (struct ld_state *, Elf_Scn *, struct scninfo *,
 			    const Elf32_Word *);
 #define RELOCATE_SECTION(state, outscn, first, dblindirect) \
-  DL_CALL_FCT ((state)->callbacks.relocate_section, (state, outscn, first,    \
-						     dblindirect))
+  (state)->callbacks.relocate_section(state, outscn, first,    \
+						     dblindirect)
 
   /* Allocate a data buffer for the relocations of the given output
      section.  */
   void (*count_relocations) (struct ld_state *, struct scninfo *);
 #define COUNT_RELOCATIONS(state, scninfo) \
-  DL_CALL_FCT ((state)->callbacks.count_relocations, (state, scninfo))
+  (state)->callbacks.count_relocations(state, scninfo)
 
   /* Create relocations for executable or DSO.  */
   void (*create_relocations) (struct ld_state *, const Elf32_Word *);
 #define CREATE_RELOCATIONS(state, dlbindirect) \
-  DL_CALL_FCT ((state)->callbacks.create_relocations, (state, dblindirect))
+  (state)->callbacks.create_relocations(state, dblindirect)
 
   /* Finalize the output file.  */
   int (*finalize) (struct ld_state *);
 #define FINALIZE(state) \
-  DL_CALL_FCT ((state)->callbacks.finalize, (state))
+  (state)->callbacks.finalize(state)
 
   /* Check whether special section number is known.  */
   bool (*special_section_number_p) (struct ld_state *, size_t);
 #define SPECIAL_SECTION_NUMBER_P(state, number) \
-  DL_CALL_FCT ((state)->callbacks.special_section_number_p, (state, number))
+  (state)->callbacks.special_section_number_p(state, number)
 
   /* Check whether section type is known.  */
   bool (*section_type_p) (struct ld_state *, XElf_Word);
 #define SECTION_TYPE_P(state, type) \
-  DL_CALL_FCT ((state)->callbacks.section_type_p, (state, type))
+  (state)->callbacks.section_type_p(state, type)
 
   /* Return section flags for .dynamic section.  */
   XElf_Xword (*dynamic_section_flags) (struct ld_state *);
 #define DYNAMIC_SECTION_FLAGS(state) \
-  DL_CALL_FCT ((state)->callbacks.dynamic_section_flags, (state))
+  (state)->callbacks.dynamic_section_flags(state)
 
   /* Create the data structures for the .plt section and initialize it.  */
   void (*initialize_plt) (struct ld_state *, Elf_Scn *scn);
 #define INITIALIZE_PLT(state, scn) \
-  DL_CALL_FCT ((state)->callbacks.initialize_plt, (state, scn))
+  (state)->callbacks.initialize_plt(state, scn)
 
   /* Create the data structures for the .rel.plt section and initialize it.  */
   void (*initialize_pltrel) (struct ld_state *, Elf_Scn *scn);
 #define INITIALIZE_PLTREL(state, scn) \
-  DL_CALL_FCT ((state)->callbacks.initialize_pltrel, (state, scn))
+  (state)->callbacks.initialize_pltrel(state, scn)
 
   /* Finalize the .plt section the what belongs to them.  */
   void (*finalize_plt) (struct ld_state *, size_t, size_t, struct symbol **);
 #define FINALIZE_PLT(state, nsym, nsym_dyn, ndxtosym) \
-  DL_CALL_FCT ((state)->callbacks.finalize_plt, (state, nsym, nsym_dyn, \
-						 ndxtosym))
+  (state)->callbacks.finalize_plt(state, nsym, nsym_dyn, \
+						 ndxtosym)
 
   /* Create the data structures for the .got section and initialize it.  */
   void (*initialize_got) (struct ld_state *, Elf_Scn *scn);
 #define INITIALIZE_GOT(state, scn) \
-  DL_CALL_FCT ((state)->callbacks.initialize_got, (state, scn))
+  (state)->callbacks.initialize_got(state, scn)
 
   /* Create the data structures for the .got.plt section and initialize it.  */
   void (*initialize_gotplt) (struct ld_state *, Elf_Scn *scn);
 #define INITIALIZE_GOTPLT(state, scn) \
-  DL_CALL_FCT ((state)->callbacks.initialize_gotplt, (state, scn))
+  (state)->callbacks.initialize_gotplt(state, scn)
 
   /* Return the tag corresponding to the native relocation type for
      the platform.  */
   int (*rel_type) (struct ld_state *);
 #define REL_TYPE(state) \
-  DL_CALL_FCT ((state)->callbacks.rel_type, (state))
+  (state)->callbacks.rel_type(state)
 };
 
 
--- a/src/ldgeneric.c	2016-02-05 17:30:50.328705833 +0100
+++ b/src/ldgeneric.c	2016-02-04 19:19:04.305411748 +0100
@@ -44,6 +44,8 @@
 #include <sha1.h>
 #include <system.h>
 
+#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
+#   define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)
 
 /* Header of .eh_frame_hdr section.  */
 struct unw_eh_frame_hdr
--- a/src/ranlib.c	2016-02-05 17:30:50.329705870 +0100
+++ b/src/ranlib.c	2016-02-04 19:26:01.993047691 +0100
@@ -42,6 +42,7 @@
 
 #include "arlib.h"
 
+# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)
 
 /* Prototypes for local functions.  */
 static int handle_file (const char *fname);
--- a/src/readelf.c	2016-02-05 17:32:10.342713810 +0100
+++ b/src/readelf.c	2016-02-04 18:54:40.583563561 +0100
@@ -314,7 +314,7 @@
 parse_opt (int key, char *arg,
 	   struct argp_state *state __attribute__ ((unused)))
 {
-  void add_dump_section (const char *name, bool implicit)
+  void (^add_dump_section) (const char*, bool) = ^void (const char *name, bool implicit)
   {
     struct section_argument *a = xmalloc (sizeof *a);
     a->arg = name;
@@ -324,7 +324,7 @@
       = key == 'x' ? &dump_data_sections_tail : &string_sections_tail;
     **tailp = a;
     *tailp = &a->next;
-  }
+  };
 
   switch (key)
     {
@@ -3438,10 +3438,10 @@
 
       fputs_unlocked (gettext ("  Owner          Size\n"), stdout);
 
-      inline size_t left (void)
+      size_t (^left) (void) = ^size_t (void)
       {
 	return (const unsigned char *) data->d_buf + data->d_size - p;
-      }
+      };
 
       /* Loop over the sections.  */
       while (left () >= 4)
@@ -5054,12 +5054,15 @@
 		   unsigned int version, unsigned int ptr_size,
 		   Dwfl_Module *dwflmod, Ebl *ebl, Dwarf *dbg)
 {
+  __block struct {
   char regnamebuf[REGNAMESZ];
-  const char *regname (unsigned int regno)
+   } result;
+
+  const char* (^regname) (unsigned int) = ^const char* (unsigned int regno)
   {
-    register_info (ebl, regno, NULL, regnamebuf, NULL, NULL);
-    return regnamebuf;
-  }
+    register_info (ebl, regno, NULL, result.regnamebuf, NULL, NULL);
+    return result.regnamebuf;
+  };
 
   puts ("\n   Program:");
   Dwarf_Word pc = vma_base;
@@ -6647,8 +6650,8 @@
       ++linep;
 
       puts (gettext ("\nLine number statements:"));
-      Dwarf_Word address = 0;
-      unsigned int op_index = 0;
+      __block Dwarf_Word address = 0;
+      __block unsigned int op_index = 0;
       size_t line = 1;
       uint_fast8_t is_stmt = default_is_stmt;
 
@@ -6682,9 +6685,9 @@
 
       /* Apply the "operation advance" from a special opcode
 	 or DW_LNS_advance_pc (as per DWARF4 6.2.5.1).  */
-      unsigned int op_addr_advance;
-      bool show_op_index;
-      inline void advance_pc (unsigned int op_advance)
+      __block unsigned int op_addr_advance;
+      __block bool show_op_index;
+      void (^advance_pc) (unsigned int) = ^void (unsigned int op_advance)
       {
 	op_addr_advance = minimum_instr_len * ((op_index + op_advance)
 					       / max_ops_per_instr);
@@ -6692,7 +6695,7 @@
 	show_op_index = (op_index > 0 ||
 			 (op_index + op_advance) % max_ops_per_instr > 0);
 	op_index = (op_index + op_advance) % max_ops_per_instr;
-      }
+      };
 
       if (max_ops_per_instr == 0)
 	{
@@ -9018,6 +9021,7 @@
     }
 
   struct register_info regs[maxnreg];
+  struct register_info *values = regs;
   memset (regs, 0, sizeof regs);
 
   /* Sort to collect the sets together.  */
@@ -9039,14 +9043,14 @@
   qsort (regs, maxreg + 1, sizeof regs[0], &compare_registers);
 
   /* Collect the unique sets and sort them.  */
-  inline bool same_set (const struct register_info *a,
+  bool (^same_set) (const struct register_info*, const struct register_info*) = ^bool (const struct register_info *a,
 			const struct register_info *b)
   {
-    return (a < &regs[maxnreg] && a->regloc != NULL
-	    && b < &regs[maxnreg] && b->regloc != NULL
+    return (a < &values[maxnreg] && a->regloc != NULL
+	    && b < &values[maxnreg] && b->regloc != NULL
 	    && a->bits == b->bits
 	    && (a->set == b->set || !strcmp (a->set, b->set)));
-  }
+  };
   struct register_info *sets[maxreg + 1];
   sets[0] = &regs[0];
   size_t nsets = 1;
--- a/src/strip.c	2016-02-05 17:30:50.331705946 +0100
+++ b/src/strip.c	2016-02-04 19:08:08.781330076 +0100
@@ -44,6 +44,8 @@
 #include <libebl.h>
 #include <system.h>
 
+#define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)
+
 typedef uint8_t GElf_Byte;
 
 /* Name and version of program.  */
@@ -438,7 +440,7 @@
   Elf_Scn *scn;
   size_t cnt;
   size_t idx;
-  bool changes;
+  __block bool changes;
   GElf_Ehdr newehdr_mem;
   GElf_Ehdr *newehdr;
   GElf_Ehdr debugehdr_mem;
@@ -931,7 +933,7 @@
 		 file's .data pointer.  Below, we'll copy the section
 		 contents.  */
 
-	      inline void check_preserved (size_t i)
+	      void (^check_preserved) (size_t) = ^void (size_t i)
 	      {
 		if (i != 0 && i < shnum + 2 && shdr_info[i].idx != 0
 		    && shdr_info[i].debug_data == NULL)
@@ -944,7 +946,7 @@
 		    shdr_info[i].debug_data = shdr_info[i].data;
 		    changes |= i < cnt;
 		  }
-	      }
+	      };
 
 	      check_preserved (shdr_info[cnt].shdr.sh_link);
 	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
@@ -1438,7 +1440,7 @@
 	/* Update section headers when the data size has changed.
 	   We also update the SHT_NOBITS section in the debug
 	   file so that the section headers match in sh_size.  */
-	inline void update_section_size (const Elf_Data *newdata)
+	void (^update_section_size) (const Elf_Data*) = ^void (const Elf_Data *newdata)
 	{
 	  GElf_Shdr shdr_mem;
 	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
@@ -1453,7 +1455,7 @@
 		INTERNAL_ERROR (fname);
 	      debugdata->d_size = newdata->d_size;
 	    }
-	}
+	};
 
 	if (shdr_info[cnt].idx == 0 && debug_fname == NULL)
 	  /* Ignore sections which are discarded.  When we are saving a
@@ -1466,7 +1468,7 @@
 	const Elf32_Word *const newsymidx = shdr_info[symtabidx].newsymidx;
 	switch (shdr_info[cnt].shdr.sh_type)
 	  {
-	    inline bool no_symtab_updates (void)
+	    bool (^no_symtab_updates) (void) = ^bool (void)
 	    {
 	      /* If the symbol table hasn't changed, do not do anything.  */
 	      if (shdr_info[symtabidx].newsymidx == NULL)
@@ -1477,7 +1479,7 @@
 		 is discarded, don't adjust anything.  */
 	      return (shdr_info[cnt].idx == 0
 		      && shdr_info[symtabidx].debug_data != NULL);
-	    }
+	    };
 
 	  case SHT_REL:
 	  case SHT_RELA:
@@ -1805,7 +1807,7 @@
 
 	      /* Apply one relocation.  Returns true when trivial
 		 relocation actually done.  */
-	      bool relocate (GElf_Addr offset, const GElf_Sxword addend,
+	      bool (^relocate) (GElf_Addr, const GElf_Sxword, bool, int, int)  = ^bool (GElf_Addr offset, const GElf_Sxword addend,
 			     bool is_rela, int rtype, int symndx)
 	      {
 		/* R_*_NONE relocs can always just be removed.  */
@@ -1929,7 +1931,7 @@
 		    return true;
 		  }
 		return false;
-	      }
+	      };
 
 	      if (shdr->sh_entsize == 0)
 		INTERNAL_ERROR (fname);
--- a/configure.ac	2016-02-05 19:02:03.233593887 +0100
+++ b/configure.ac	2016-02-05 19:02:45.977279320 +0100
@@ -75,39 +75,6 @@
 AC_CHECK_TOOL([READELF], [readelf])
 AC_CHECK_TOOL([NM], [nm])
 
-# We use -std=gnu99 but have explicit checks for some language constructs
-# and GNU extensions since some compilers claim GNU99 support, but don't
-# really support all language extensions. In particular we need
-# Mixed Declarations and Code
-# https://gcc.gnu.org/onlinedocs/gcc/Mixed-Declarations.html
-# Nested Functions
-# https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html
-# Arrays of Variable Length
-# https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html
-AC_CACHE_CHECK([for gcc with GNU99 support], ac_cv_c99, [dnl
-old_CFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS -std=gnu99"
-AC_COMPILE_IFELSE([AC_LANG_SOURCE([dnl
-int foo (int a)
-{
-  for (int i = 0; i < a; ++i) if (i % 4) break; int s = a; return s;
-}
-
-double bar (double a, double b)
-{
-  double square (double z) { return z * z; }
-  return square (a) + square (b);
-}
-
-void baz (int n)
-{
-  struct S { int x[[n]]; };
-}])],
-		  ac_cv_c99=yes, ac_cv_c99=no)
-CFLAGS="$old_CFLAGS"])
-AS_IF([test "x$ac_cv_c99" != xyes],
-      AC_MSG_ERROR([gcc with GNU99 support required]))
-
 AC_CACHE_CHECK([for __thread support], ac_cv_tls, [dnl
 # Use the same flags that we use for our DSOs, so the test is representative.
 # Some old compiler/linker/libc combinations fail some ways and not others.
--- a/src/unstrip.c	2016-02-05 19:25:42.712746109 +0100
+++ b/src/unstrip.c	2016-02-05 19:46:20.013116842 +0100
@@ -429,12 +429,12 @@
 {
   Elf_Data *data = elf_getdata (outscn, NULL);
 
-  inline void adjust_reloc (GElf_Xword *info)
+  void (^adjust_reloc) (GElf_Xword*) = ^void (GElf_Xword *info)
     {
       size_t ndx = GELF_R_SYM (*info);
       if (ndx != STN_UNDEF)
 	*info = GELF_R_INFO (map[ndx - 1], GELF_R_TYPE (*info));
-    }
+    };
 
   switch (shdr->sh_type)
     {
@@ -1099,8 +1099,8 @@
       free (shdr);
     }
 
-  bool fail = false;
-  inline void check_match (bool match, Elf_Scn *scn, const char *name)
+  __block bool fail = false;
+  void (^check_match) (bool, Elf_Scn*, const char*) = ^void (bool match, Elf_Scn *scn, const char *name)
     {
       if (!match)
 	{
@@ -1108,7 +1108,7 @@
 	  error (0, 0, _("cannot find matching section for [%zu] '%s'"),
 		 elf_ndxscn (scn), name);
 	}
-    }
+    };
 
   Elf_Scn *scn = NULL;
   while ((scn = elf_nextscn (debug, scn)) != NULL)
@@ -1332,8 +1332,8 @@
     }
 
   /* Locate a matching unallocated section in SECTIONS.  */
-  inline struct section *find_unalloc_section (const GElf_Shdr *shdr,
-					       const char *name)
+  struct section * (^find_unalloc_section) (const GElf_Shdr*, const char*, struct section*) = ^struct section* (const GElf_Shdr *shdr,
+					       const char *name, struct section *sections)
     {
       size_t l = nalloc, u = stripped_shnum - 1;
       while (l < u)
@@ -1350,7 +1350,7 @@
 	    return sec;
 	}
       return NULL;
-    }
+    };
 
   Elf_Data *shstrtab = elf_getdata (elf_getscn (unstripped,
 						unstripped_shstrndx), NULL);
@@ -1412,7 +1412,7 @@
       else
 	{
 	  /* Look for the section that matches.  */
-	  sec = find_unalloc_section (shdr, name);
+	  sec = find_unalloc_section (shdr, name, sections);
 	  if (sec == NULL)
 	    {
 	      /* An additional unallocated section is fine if not SHT_NOBITS.
@@ -2067,13 +2067,13 @@
 
   /* Warn, and exit if not forced to continue, if some ELF header
      sanity check for the stripped and unstripped files failed.  */
-  void warn (const char *msg)
+  void (^warn) (const char*) = ^void (const char *msg)
   {
     error (force ? 0 : EXIT_FAILURE, 0, "%s'%s' and '%s' %s%s.",
 	   force ? _("WARNING: ") : "",
 	   stripped_file, unstripped_file, msg,
 	   force ? "" : _(", use --force"));
-  }
+  };
 
   int stripped_fd = open_file (stripped_file, false);
   Elf *stripped = elf_begin (stripped_fd, ELF_C_READ, NULL);
@@ -2328,10 +2328,10 @@
 handle_implicit_modules (const struct arg_info *info)
 {
   struct match_module_info mmi = { info->args, NULL, info->match_files };
-  inline ptrdiff_t next (ptrdiff_t offset)
+  ptrdiff_t (^next) (ptrdiff_t) = ^ptrdiff_t (ptrdiff_t offset)
     {
       return dwfl_getmodules (info->dwfl, &match_module, &mmi, offset);
-    }
+    };
   ptrdiff_t offset = next (0);
   if (offset == 0)
     error (EXIT_FAILURE, 0, _("no matching modules found"));
--- a/libdwfl/argp-std.c	2016-02-05 19:05:46.257357123 +0100
+++ b/libdwfl/argp-std.c	2016-02-05 19:07:51.717259169 +0100
@@ -103,7 +103,7 @@
 static error_t
 parse_opt (int key, char *arg, struct argp_state *state)
 {
-  inline void failure (Dwfl *dwfl, int errnum, const char *msg)
+  void (^failure) (Dwfl*, int , const char*) = ^void (Dwfl *dwfl, int errnum, const char *msg)
     {
       if (dwfl != NULL)
 	dwfl_end (dwfl);
@@ -112,12 +112,12 @@
 		      msg, INTUSE(dwfl_errmsg) (-1));
       else
 	argp_failure (state, EXIT_FAILURE, errnum, "%s", msg);
-    }
-  inline error_t fail (Dwfl *dwfl, int errnum, const char *msg)
+    };
+  error_t (^fail) (Dwfl*, int, const char*) = ^error_t (Dwfl *dwfl, int errnum, const char *msg)
     {
       failure (dwfl, errnum, msg);
       return errnum == -1 ? EIO : errnum;
-    }
+    };
 
   switch (key)
     {
--- a/src/arlib-argp.c	2016-02-05 19:51:13.036837579 +0100
+++ b/src/arlib-argp.c	2016-02-05 19:49:03.380661910 +0100
@@ -59,13 +59,13 @@
 static char *
 help_filter (int key, const char *text, void *input __attribute__ ((unused)))
 {
-  inline char *text_for_default (void)
+  char* (^text_for_default) (void) = ^char* (void)
   {
     char *new_text;
     if (unlikely (asprintf (&new_text, gettext ("%s (default)"), text) < 0))
       return (char *) text;
     return new_text;
-  }
+  };
 
   switch (key)
     {
@@ -80,7 +80,7 @@
     }
 
   return (char *) text;
-}
+};
 
 static const struct argp argp =
   {
--- a/libdwfl/elf-from-memory.c	2016-02-05 19:51:13.007836422 +0100
+++ b/libdfwl/elf-from-memory.c	2016-02-05 19:49:36.886000784 +0100
@@ -78,7 +78,7 @@
       return NULL;
     }
 
-  ssize_t nread = (*read_memory) (arg, buffer, ehdr_vma,
+  __block ssize_t nread = (*read_memory) (arg, buffer, ehdr_vma,
 				  sizeof (Elf32_Ehdr), initial_bufsize);
   if (nread <= 0)
     {
@@ -210,11 +210,11 @@
   xlateto.d_size = phdrsp_bytes;
 
   /* Scan for PT_LOAD segments to find the total size of the file image.  */
-  size_t contents_size = 0;
-  GElf_Off segments_end = 0;
-  GElf_Off segments_end_mem = 0;
-  GElf_Addr loadbase = ehdr_vma;
-  bool found_base = false;
+  __block size_t contents_size = 0;
+  __block GElf_Off segments_end = 0;
+  __block GElf_Off segments_end_mem = 0;
+  __block GElf_Addr loadbase = ehdr_vma;
+  __block bool found_base = false;
   Elf32_Phdr (*p32)[phnum] = phdrsp;
   Elf64_Phdr (*p64)[phnum] = phdrsp;
   switch (ehdr.e32.e_ident[EI_CLASS])
@@ -223,7 +223,7 @@
 	 segments_end, segments_end_mem and loadbase (if not
 	 found_base yet).  Returns true if sanity checking failed,
 	 false otherwise.  */
-      inline bool handle_segment (GElf_Addr vaddr, GElf_Off offset,
+      bool (^handle_segment) (GElf_Addr, GElf_Off, GElf_Xword, GElf_Xword) = ^bool (GElf_Addr vaddr, GElf_Off offset,
 				  GElf_Xword filesz, GElf_Xword memsz)
 	{
 	  /* Sanity check the segment load aligns with the pagesize.  */
@@ -245,7 +245,7 @@
 	  segments_end = offset + filesz;
 	  segments_end_mem = offset + memsz;
 	  return false;
-	}
+	};
 
     case ELFCLASS32:
       if (elf32_xlatetom (&xlateto, &xlatefrom,
@@ -303,7 +303,7 @@
     {
       /* Reads the given segment.  Returns true if reading fails,
 	 false otherwise.  */
-      inline bool handle_segment (GElf_Addr vaddr, GElf_Off offset,
+      bool (^handle_segment) (GElf_Addr, GElf_Off, GElf_Xword) = ^bool (GElf_Addr vaddr, GElf_Off offset,
 				  GElf_Xword filesz)
 	{
 	  GElf_Off start = offset & -pagesize;
@@ -314,7 +314,7 @@
 				  (loadbase + vaddr) & -pagesize,
 				  end - start, end - start);
 	  return nread <= 0;
-	}
+	};
 
     case ELFCLASS32:
       for (uint_fast16_t i = 0; i < phnum; ++i)

diff --git a/backend/src/llvm/llvm_printf_parser.cpp b/backend/src/llvm/llvm_printf_parser.cpp
index 800f343f..45ceeda1 100644
--- a/backend/src/llvm/llvm_printf_parser.cpp
+++ b/backend/src/llvm/llvm_printf_parser.cpp
@@ -309,7 +309,11 @@ error:
     bool parseOnePrintfInstruction(CallInst * call);
     bool generateOneParameterInst(PrintfSlot& slot, Value* arg, Value*& new_arg);
 
-    virtual const char *getPassName() const
+#if LLVM_VERSION_MAJOR == 4
+      virtual StringRef getPassName() const
+#else
+      virtual const char *getPassName() const
+#endif
     {
       return "Printf Parser";
     }
@@ -521,7 +525,7 @@ error:
       case Type::FloatTyID: {
         /* llvm 3.6 will give a undef value for NAN. */
         if (dyn_cast<llvm::UndefValue>(arg)) {
-          APFloat nan = APFloat::getNaN(APFloat::IEEEsingle, false);
+          APFloat nan = APFloat::getNaN(APFloat::IEEEsingle(), false);
           new_arg = ConstantFP::get(module->getContext(), nan);
         }
 
diff --git a/backend/src/ir/half.cpp b/backend/src/ir/half.cpp
index 1c0d7eb9..7765f4fe 100644
--- a/backend/src/ir/half.cpp
+++ b/backend/src/ir/half.cpp
@@ -29,7 +29,7 @@ namespace ir {
   {
     uint64_t v64 = static_cast<uint64_t>(v);
     llvm::APInt apInt(16, v64, false);
-    return llvm::APFloat(llvm::APFloat::IEEEhalf, apInt);
+    return llvm::APFloat(llvm::APFloat::IEEEhalf(), apInt);
   }
 
   static uint16_t convAPFloatToU16(const llvm::APFloat& apf)
@@ -42,14 +42,14 @@ namespace ir {
   half::operator float(void) const {
     bool loseInfo;
     llvm::APFloat apf_self = convU16ToAPFloat(this->val);
-    apf_self.convert(llvm::APFloat::IEEEsingle, llvm::APFloat::rmNearestTiesToEven, &loseInfo);
+    apf_self.convert(llvm::APFloat::IEEEsingle(), llvm::APFloat::rmNearestTiesToEven, &loseInfo);
     return apf_self.convertToFloat();
   }
 
   half::operator double(void) const {
     bool loseInfo;
     llvm::APFloat apf_self = convU16ToAPFloat(this->val);
-    apf_self.convert(llvm::APFloat::IEEEdouble, llvm::APFloat::rmNearestTiesToEven, &loseInfo);
+    apf_self.convert(llvm::APFloat::IEEEdouble(), llvm::APFloat::rmNearestTiesToEven, &loseInfo);
     return apf_self.convertToDouble();
   }
 
@@ -70,7 +70,7 @@ namespace ir {
   }
 
   half half::convToHalf(uint16_t u16) {
-    llvm::APFloat res(llvm::APFloat::IEEEhalf, llvm::APInt(16, 0, false));
+    llvm::APFloat res(llvm::APFloat::IEEEhalf(), llvm::APInt(16, 0, false));
     uint64_t u64 = static_cast<uint64_t>(u16);
     llvm::APInt apInt(16, u64, false);
     res.convertFromAPInt(apInt, false, llvm::APFloat::rmNearestTiesToEven);
@@ -78,7 +78,7 @@ namespace ir {
   }
 
   half half::convToHalf(int16_t v16) {
-    llvm::APFloat res(llvm::APFloat::IEEEhalf, llvm::APInt(16, 0, true));
+    llvm::APFloat res(llvm::APFloat::IEEEhalf(), llvm::APInt(16, 0, true));
     uint64_t u64 = static_cast<uint64_t>(v16);
     llvm::APInt apInt(16, u64, true);
     res.convertFromAPInt(apInt, true, llvm::APFloat::rmNearestTiesToEven);

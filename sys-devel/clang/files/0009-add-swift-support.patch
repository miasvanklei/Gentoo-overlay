diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index e69de29bb2..a0c1644fc6 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -0,0 +1,14 @@
+By submitting a pull request, you represent that you have the right to license
+your contribution to Apple and the community, and agree by submitting the patch
+that your contributions are licensed under the [Swift
+license](https://swift.org/LICENSE.txt).
+
+---
+
+Changes to this repository follow special considerations as described on
+Swift.org under "[LLVM and Swift](https://swift.org/contributing/#llvm-and-swift)".
+Please make sure your change is appropriate for this repository.
+
+Before submitting a pull request, please make sure you have tested your
+changes and that they follow the Swift project [guidelines for contributing
+code](https://swift.org/contributing/#contributing-code).
diff --git a/include/clang-c/CXErrorCode.h b/include/clang-c/CXErrorCode.h
index aff73b7467..9bee50b4b7 100644
--- a/include/clang-c/CXErrorCode.h
+++ b/include/clang-c/CXErrorCode.h
@@ -54,7 +54,25 @@ enum CXErrorCode {
   /**
    * \brief An AST deserialization error has occurred.
    */
-  CXError_ASTReadError = 4
+  CXError_ASTReadError = 4,
+
+  /**
+  * \brief A refactoring action is not available at the given location
+  * or in the given source range.
+  */
+  CXError_RefactoringActionUnavailable = 5,
+
+  /**
+  * \brief A refactoring action is not able to use the given name because
+  * it contains an unexpected number of strings.
+  */
+  CXError_RefactoringNameSizeMismatch = 6,
+
+  /**
+  * \brief A name of a symbol is invalid, i.e. it is reserved by the source
+  * language and can't be used as a name for this symbol.
+  */
+  CXError_RefactoringNameInvalid = 7
 };
 
 #ifdef __cplusplus
diff --git a/include/clang-c/Refactor.h b/include/clang-c/Refactor.h
index e69de29bb2..d6e8d84eb6 100644
--- a/include/clang-c/Refactor.h
+++ b/include/clang-c/Refactor.h
@@ -0,0 +1,1312 @@
+/*==-- clang-c/Refactor.h - Refactoring Public C Interface --------*- C -*-===*\
+|*                                                                            *|
+|*                     The LLVM Compiler Infrastructure                       *|
+|*                                                                            *|
+|* This file is distributed under the University of Illinois Open Source      *|
+|* License. See LICENSE.TXT for details.                                      *|
+|*                                                                            *|
+|*===----------------------------------------------------------------------===*|
+|*                                                                            *|
+|* This header provides a public inferface to a Clang library for performing  *|
+|* refactoring actions on projects without exposing the full Clang C++ API.   *|
+|*                                                                            *|
+\*===----------------------------------------------------------------------===*/
+
+#ifndef LLVM_CLANG_C_REFACTOR_H
+#define LLVM_CLANG_C_REFACTOR_H
+
+#include "clang-c/Index.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup CINDEX_REFACTOR Refactoring options.
+ *
+ * @{
+ */
+
+/**
+ * \brief The refactoring options that can be specified for each refactoring
+ * action.
+ */
+enum CXRefactoringOption {
+  /**
+   * \brief The refactoring actions like 'rename' will avoid looking for
+   * occurrences of the renamed symbol in comments if this option is enabled.
+   */
+  CXRefactorOption_AvoidTextualMatches = 1
+};
+
+/**
+ * \brief Opaque pointer representing a set of options that can be given to
+ * a refactoring action.
+ */
+typedef void *CXRefactoringOptionSet;
+
+/**
+ * \brief Returns a new option set.
+ */
+CINDEX_LINKAGE
+CXRefactoringOptionSet clang_RefactoringOptionSet_create(void);
+
+/**
+ * \brief Parses and returns a new option set or NULL if the given string is
+ * invalid.
+ */
+CINDEX_LINKAGE
+CXRefactoringOptionSet
+clang_RefactoringOptionSet_createFromString(const char *String);
+
+/**
+ * \brief Adds a new option to the given refactoring option set.
+ */
+CINDEX_LINKAGE
+void clang_RefactoringOptionSet_add(CXRefactoringOptionSet Set,
+                                    enum CXRefactoringOption Option);
+
+/**
+ * \brief Converts the given refactoring option set to a string value.
+ */
+CINDEX_LINKAGE
+CXString clang_RefactoringOptionSet_toString(CXRefactoringOptionSet Set);
+
+/**
+ * \brief Free the given option set.
+ *
+ * Option sets should be freed by this function only when they were created
+ * using the \c clang_RefactoringOptionSet_create* methods.
+ */
+CINDEX_LINKAGE
+void clang_RefactoringOptionSet_dispose(CXRefactoringOptionSet Set);
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup CINDEX_REFACTOR Refactoring actions.
+ *
+ * @{
+ */
+
+/**
+ * \brief The refactoring actions that can be performed by libclang.
+ */
+enum CXRefactoringActionType {
+  /**
+   * \brief The 'rename' refactoring action.
+   */
+  CXRefactor_Rename = 0,
+
+  /**
+   * \brief The local 'rename' refactoring action.
+   */
+  CXRefactor_Rename_Local = 1,
+
+  /**
+   * \brief The 'extract' refactoring action extracts source code into a
+   * new function.
+   */
+  CXRefactor_Extract = 2,
+
+  /**
+   * \brief The sub-action of 'extract' that extracts source code into a new
+   * method.
+   */
+  CXRefactor_Extract_Method = 3,
+
+  /**
+  * \brief The action that converts an if/else constructs to a switch block.
+  */
+  CXRefactor_IfSwitchConversion = 4,
+
+  /**
+  * \brief The action that wraps an Objective-C string literal in an
+  * NSLocalizedString macro.
+  */
+  CXRefactor_LocalizeObjCStringLiteral = 5,
+
+  /**
+  * \brief The action that adds missing switch cases to an switch over an enum.
+  */
+  CXRefactor_FillInEnumSwitchCases = 6,
+
+  /**
+  * \brief The action that adds missing protocol methods to an Objective-C
+  * class.
+  */
+  CXRefactor_FillInMissingProtocolStubs = 7,
+
+  /**
+  * \brief The action that extracts an expression that's repeated in a function
+  * into a new variable.
+  */
+  CXRefactor_ExtractRepeatedExpressionIntoVariable = 8,
+
+  /**
+  * \brief The action that adds missing abstract class method overrides to a
+  * class.
+  */
+  CXRefactor_FillInMissingMethodStubsFromAbstractClasses = 9,
+
+  /**
+  * \brief The action that generates dummy method definitions for method
+  * declarations without respective definitions.
+  */
+  CXRefactor_ImplementDeclaredMethods = 10,
+
+  /**
+   * \brief The sub-action of 'extract' that extracts source expression into a
+   * new variable.
+   */
+  CXRefactor_Extract_Expression = 11,
+};
+
+/**
+ * \brief Return the name of the given refactoring action.
+ */
+CINDEX_LINKAGE
+CXString
+clang_RefactoringActionType_getName(enum CXRefactoringActionType Action);
+
+/**
+ * \brief A set of refactoring actions that can be performed at some specific
+ * location in a source file.
+ *
+ * The actions in the action set are ordered by their priority: most important
+ * actions are placed before the less important ones.
+ */
+typedef struct {
+  const enum CXRefactoringActionType *Actions;
+  unsigned NumActions;
+} CXRefactoringActionSet;
+
+/**
+ * \brief Free the given refactoring action set.
+ */
+CINDEX_LINKAGE void
+clang_RefactoringActionSet_dispose(CXRefactoringActionSet *Set);
+
+typedef struct {
+  enum CXRefactoringActionType Action;
+  /**
+   * \brief The set of diagnostics that describes the reason why this action
+   * couldn't be initiated. This set of diagnostics is managed by the
+   * \c CXRefactoringActionSetWithDiagnostics and shouldn't be freed manually.
+   */
+  CXDiagnosticSet Diagnostics;
+} CXRefactoringActionWithDiagnostics;
+
+/**
+ * \brief A set of refactoring actions that couldn't be initiated at some
+ * location and their respective diagnostics that describe the reason why
+ * the initiation failed.
+ */
+typedef struct {
+  CXRefactoringActionWithDiagnostics *Actions;
+  unsigned NumActions;
+} CXRefactoringActionSetWithDiagnostics;
+
+/**
+ * \brief Free the given refactoring action set with diagnostics.
+ */
+CINDEX_LINKAGE void clang_RefactoringActionSetWithDiagnostics_dispose(
+    CXRefactoringActionSetWithDiagnostics *Set);
+
+/**
+ * \brief Find the set of refactoring actions that can be performed at the given
+ * location.
+ *
+ * This function examines the AST around the given source range and creates a
+ * \c CXRefactoringActionSet that contains all of the actions that can be
+ * performed in the given source range.
+ *
+ * \param TU The translation unit which contains the given source range.
+ *
+ * \param Location The location at which the refactoring action will be
+ * performed.
+ *
+ * \param SelectionRange The range in which the AST should be checked. Usually
+ * corresponds to the selection range or location of the cursor in the editor.
+ * Can be a null range.
+ *
+ * \param Options The optional refactoring options that might influence the way
+ * the search is performed.
+ *
+ * \param[out] OutSet A non-NULL pointer to store the created
+ * \c CXRefactoringActionSet.
+ *
+ * \returns Zero on success, CXError_RefactoringActionUnavailable when
+ * there are no actions available in the given range, or an error code
+ * otherwise.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode
+clang_Refactoring_findActionsAt(CXTranslationUnit TU, CXSourceLocation Location,
+                                CXSourceRange SelectionRange,
+                                CXRefactoringOptionSet Options,
+                                CXRefactoringActionSet *OutSet);
+
+/**
+ * \brief Find the set of refactoring actions that can be performed at the given
+ * location.
+ *
+ * This function examines the AST around the given source range and creates a
+ * \c CXRefactoringActionSet that contains all of the actions that can be
+ * performed in the given source range. It also creates a
+ * \c CXRefactoringActionSetWithDiagnostics that might describe the reason why
+ * some refactoring actions are not be available.
+ *
+ * \param TU The translation unit which contains the given source range.
+ *
+ * \param Location The location at which the refactoring action will be
+ * performed.
+ *
+ * \param SelectionRange The range in which the AST should be checked. Usually
+ * corresponds to the selection range or location of the cursor in the editor.
+ * Can be a null range.
+ *
+ * \param Options The optional refactoring options that might influence the way
+ * the search is performed.
+ *
+ * \param[out] OutSet A non-NULL pointer to store the created
+ * \c CXRefactoringActionSet.
+ *
+ * \param[out] OutFailureSet An optional pointer to store the created
+ * \c CXRefactoringActionSetWithDiagnostics that describes the failures reasons
+ * for some of the refactoring actions.
+ *
+ * \returns Zero on success, CXError_RefactoringActionUnavailable when
+ * there are no actions available in the given range, or an error code
+ * otherwise.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_findActionsWithInitiationFailureDiagnosicsAt(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, CXRefactoringOptionSet Options,
+    CXRefactoringActionSet *OutSet,
+    CXRefactoringActionSetWithDiagnostics *OutFailureSet);
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup CINDEX_REFACTOR_INITIATE Refactoring initiation
+ *
+ * @{
+ */
+
+/**
+ * \brief Opaque pointer representing the initiated refactoring action.
+ */
+typedef void *CXRefactoringAction;
+
+/**
+ * \brief Free the given refactoring action.
+ *
+ * The refactoring action should be freed before the initiation and/or
+ * implementation translation units.
+ */
+CINDEX_LINKAGE void clang_RefactoringAction_dispose(CXRefactoringAction Action);
+
+/**
+ * \brief Return the source range that's associated with the initiated
+ * refactoring action.
+ *
+ * The returned source range covers the source that will be modified by the
+ * given refactoring action. If the action has no associated source range,
+ * then this function will return a null \c CXSourceRange.
+ */
+CINDEX_LINKAGE CXSourceRange
+clang_RefactoringAction_getSourceRangeOfInterest(CXRefactoringAction Action);
+
+/**
+ * \brief Return the type of the initiated action, which might be different
+ * to the type of the requested action. For an operation 'rename', the action
+ * could actually initiate the local 'rename' operation.
+ */
+CINDEX_LINKAGE
+enum CXRefactoringActionType
+clang_RefactoringAction_getInitiatedActionType(CXRefactoringAction Action);
+
+/**
+ * \brief Return a non-zero value when the refactoring action requires access
+ * to an additional translation unit that contains an implementation of some
+ * declaration.
+ */
+// TODO: Remove (this is no longer needed due to refactoring continuations).
+CINDEX_LINKAGE
+int clang_RefactoringAction_requiresImplementationTU(
+    CXRefactoringAction Action);
+
+/**
+ * \brief Return a USR that corresponds to the declaration whose implementation
+ * is required in order for the given refactoring action to work correctly.
+ */
+// TODO: Remove (this is no longer needed due to refactoring continuations).
+CINDEX_LINKAGE
+CXString clang_RefactoringAction_getUSRThatRequiresImplementationTU(
+    CXRefactoringAction Action);
+
+/**
+ * \brief Set the translation unit that contains the declaration whose
+ * implementation is required for the given refactoring action to work
+ * correctly.
+ */
+// TODO: Remove (this is no longer needed due to refactoring continuations).
+CINDEX_LINKAGE
+enum CXErrorCode
+clang_RefactoringAction_addImplementationTU(CXRefactoringAction Action,
+                                            CXTranslationUnit TU);
+
+/**
+ * \brief A refactoring candidate determines on which piece of source code the
+ * action should be applied.
+ *
+ * Most refactoring actions have just one candidate, but some actions, like
+ * 'Extract' can produce multiple candidates.
+ *
+ * The candidates are managed by the refactoring action, and their description
+ * string doesn't need to be freed manually.
+ */
+typedef struct { CXString Description; } CXRefactoringCandidate;
+
+/**
+ * \brief A set of refactoring candidates on which the previously initiatied
+ * refactoring action can be performed.
+ *
+ * The candidates in the candidate set are ordered by their priority: the
+ * ones that are more likely to be selected are placed before the other ones.
+ *
+ * A non-empty refactoring candidate set always has more than one refactoring
+ * candidate, because when a refactoring action has just one candidate,
+ * \c clang_RefactoringAction_getRefactoringCandidates will return an empty
+ * candidate set.
+ */
+typedef struct {
+  const CXRefactoringCandidate *Candidates;
+  unsigned NumCandidates;
+} CXRefactoringCandidateSet;
+
+/**
+ * \brief Returns the given action's refactoring candidates.
+ *
+ * The resulting refactoring candidate set will be empty when the given \c
+ * CXRefactoringAction has just one refactoring candidate.
+ *
+ * \param Action A previously initiated \c CXRefactoringAction.
+ *
+ * \param[out] OutRefactoringCandidateSet An pointer to store the action's
+ * refactoring candidate set.
+ *
+ * \returns Zero on success, or an error code otherwise.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode clang_RefactoringAction_getRefactoringCandidates(
+    CXRefactoringAction Action,
+    CXRefactoringCandidateSet *OutRefactoringCandidateSet);
+
+/**
+ * \brief Tells the given refactoring action that it has to perform the
+ * operation on the refactoring candidate that's located at \p Index in the \c
+ * CXRefactoringCandidateSet.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode
+clang_RefactoringAction_selectRefactoringCandidate(CXRefactoringAction Action,
+                                                   unsigned Index);
+
+// TODO: Remove.
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_initiateActionAt(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, enum CXRefactoringActionType ActionType,
+    CXRefactoringOptionSet Options, CXRefactoringAction *OutAction,
+    CXString *OutFailureReason);
+
+/**
+ * \brief Initiate a specific refactoring action at the given location.
+ *
+ * This function initiates an \p ActionType refactoring action when it can
+ * be initiated at the given location and creates a \c CXRefactoringAction
+ * action that will allow the control.
+ *
+ * \param TU The translation unit in which the action should be initiated.
+ *
+ * \param Location The location at which the refactoring action will be
+ * performed.
+ *
+ * \param SelectionRange The range in which the AST should be checked. Usually
+ * corresponds to the selection range or location of the cursor in the editor.
+ * Can be a null range.
+ *
+ * \param ActionType The type of action that should be initiated.
+ *
+ * \param Options The optional refactoring options that might have an influence
+ * on the initiation process.
+ *
+ * \param[out] OutAction A non-NULL pointer to store the created
+ * \c CXRefactoringAction.
+ *
+ * \param[out] OutDiagnostics An optional pointer to store any diagnostics that
+ * describe why the action wasn't initiated.
+ *
+ * \returns Zero on success, CXError_RefactoringActionUnavailable when
+ * the given refactoring action can't be performed at the given location, or an
+ * error code otherwise.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_initiateAction(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, enum CXRefactoringActionType ActionType,
+    CXRefactoringOptionSet Options, CXRefactoringAction *OutAction,
+    CXDiagnosticSet *OutDiagnostics);
+
+/**
+ * \brief Initiate a specific refactoring action on a particular declaration.
+ *
+ * This function searches for the declaration that corresponds to \p DeclUSR
+ * and initiates an \p ActionType a refactoring action on that declaration
+ * if possible.
+ *
+ * \param TU The translation unit in which the declaration is defined.
+ *
+ * \param DeclUSR The USR that corresponds to the declaration of interest.
+ *
+ * \param ActionType The type of action that should be initiated.
+ *
+ * \param Options The optional refactoring options that might have an influence
+ * on the initiation process.
+ *
+ * \param[out] OutAction A non-NULL pointer to store the created
+ * \c CXRefactoringAction.
+ *
+ * \returns Zero on success, CXError_RefactoringActionUnavailable when
+ * the given refactoring action can't be performed on the found declaration, or
+ * an error code otherwise.
+ */
+// TODO: Remove (not needed).
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_initiateActionOnDecl(
+    CXTranslationUnit TU, const char *DeclUSR,
+    enum CXRefactoringActionType ActionType, CXRefactoringOptionSet Options,
+    CXRefactoringAction *OutAction, CXString *OutFailureReason);
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup CINDEX_REFACTOR_REPLACEMENT Refactoring replacement
+ *
+ * @{
+ */
+
+/**
+ * \brief A source location in a single file that is independent of \c
+ * CXTranslationUnit.
+ */
+typedef struct { unsigned Line, Column; } CXFileLocation;
+
+/**
+ * \brief A source range in a single file that is independent of \c
+ * CXTranslationUnit.
+ */
+typedef struct { CXFileLocation Begin, End; } CXFileRange;
+
+// TODO: Remove
+typedef struct {
+  CXFileRange Range;
+  CXString ReplacementString;
+} CXRefactoringReplacement_Old;
+
+// TODO: Remove
+typedef struct {
+  CXString Filename;
+  const CXRefactoringReplacement_Old *Replacements;
+  unsigned NumReplacements;
+} CXRefactoringFileReplacementSet_Old;
+
+// TODO: Remove
+typedef struct {
+  const CXRefactoringFileReplacementSet_Old *FileReplacementSets;
+  unsigned NumFileReplacementSets;
+} CXRefactoringReplacements_Old;
+
+/**
+ * \brief Identifies a character range in the source code of a single file that
+ * should be replaced with the replacement string.
+ *
+ * Replacements are managed by the result of a specific refactoring action,
+ * like \c CXRenamingResult, and are invalidated when the refactoring result is
+ * destroyed.
+ */
+typedef struct {
+  CXFileRange Range;
+  CXString ReplacementString;
+  void *AssociatedData;
+} CXRefactoringReplacement;
+
+/**
+* \brief A set of refactoring replacements that are applicable to a certain
+ * file.
+ */
+typedef struct {
+  CXString Filename;
+  const CXRefactoringReplacement *Replacements;
+  unsigned NumReplacements;
+} CXRefactoringFileReplacementSet;
+
+/**
+ * \brief A set of refactoring replacements that have been produced by a
+ * refactoring operation.
+ *
+ * The refactoring replacements depend on \c CXRefactoringResult, and can't be
+ * used after the refactoring result is freed.
+ */
+typedef struct {
+  const CXRefactoringFileReplacementSet *FileReplacementSets;
+  unsigned NumFileReplacementSets;
+} CXRefactoringReplacements;
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup CINDEX_SYMBOL_OPERATION Symbol-based refactoring operation
+ * (e.g. Rename).
+ *
+ * @{
+ */
+
+/**
+ * \brief The type of a symbol occurrence.
+ *
+ * The occurrence kind determines if an occurrence can be renamed automatically
+ * or if the user has to make the decision whether or not this occurrence
+ * should be renamed.
+ */
+enum CXSymbolOccurrenceKind {
+  /**
+   * \brief This occurrence is an exact match and can be renamed automatically.
+   */
+  CXSymbolOccurrence_MatchingSymbol = 0,
+
+  /**
+  * \brief This is an occurrence of a matching selector. It can't be renamed
+  * automatically unless the indexer proves that this selector refers only
+  * to the declarations that correspond to the renamed symbol.
+  */
+  CXSymbolOccurrence_MatchingSelector = 1,
+
+  /**
+  * \brief This is an occurrence of an implicit property that uses the
+  * renamed method.
+  */
+  CXSymbolOccurrence_MatchingImplicitProperty = 2,
+
+  /**
+  * \brief This is an occurrence of an symbol name in a comment.
+  */
+  CXSymbolOccurrence_MatchingCommentString = 3,
+
+  /**
+  * \brief This is an occurrence of an symbol name in a documentation comment.
+  */
+  CXSymbolOccurrence_MatchingDocCommentString = 4,
+
+  /**
+  * \brief This is an occurrence of an symbol name in a filename in an inclusion
+  * directive.
+  */
+  CXSymbolOccurrence_MatchingFilename = 5,
+
+  /**
+  * \brief This is an occurrence of an symbol name in a string literal.
+  */
+  CXSymbolOccurrence_MatchingStringLiteral = 6,
+
+  /**
+  * \brief This is an occurrence of a symbol name that belongs to the extracted
+  * declaration. Note: this occurrence can be in two replacements as we might
+  * extract an out-of-line method that will be both declared and defined.
+  */
+  CXSymbolOccurrence_ExtractedDeclaration = 100,
+
+  /**
+  * \brief This is an occurrence of a symbol name that references the extracted
+  * declaration.
+  */
+  CXSymbolOccurrence_ExtractedDeclaration_Reference = 101,
+};
+
+// TODO: Remove
+typedef struct {
+  const CXRefactoringReplacement_Old *Replacements;
+  unsigned ReplacementCount;
+  enum CXSymbolOccurrenceKind Kind;
+  /**
+   * Whether or not this occurrence is inside a macro. When this is true, the
+   * replacements of the occurrence contain just a single empty replacement that
+   * points to the location of the macro expansion.
+   */
+  int IsMacroExpansion;
+} CXRenamedSymbolOccurrence;
+
+/**
+ * \brief An occurrence of a symbol.
+ *
+ * Contains the source ranges that represent the pieces of the name of the
+ * symbol. The occurrences are managed by \c CXRenamingResult, and are
+ * invalidated when \c CXRenamingResult is destroyed.
+ */
+typedef struct {
+  const CXFileRange *NamePieces;
+  unsigned NumNamePieces;
+  enum CXSymbolOccurrenceKind Kind;
+  /**
+   * Whether or not this occurrence is inside a macro. When this is true, the
+   * replacements of the occurrence contain just a single empty replacement that
+   * points to the location of the macro expansion.
+   */
+  int IsMacroExpansion;
+  unsigned SymbolIndex;
+} CXSymbolOccurrence;
+
+// TODO: Remove
+typedef struct {
+  CXString Filename;
+  const CXRenamedSymbolOccurrence *Occurrences;
+  unsigned NumOccurrences;
+} CXFileRenamingResult; // TODO: Remove
+
+/**
+* \brief A set of symbol occurrences that occur in a single file.
+ */
+typedef struct {
+  CXString Filename;
+  /**
+   * The set of occurrences for each symbol of interest.
+   */
+  const CXSymbolOccurrence *Occurrences;
+  unsigned NumOccurrences;
+} CXSymbolOccurrencesInFile;
+
+/**
+ * \brief Opaque pointer representing all of the renames that should take place
+ * in a single translation unit.
+ *
+ * The result of a renaming action is indepedent from \c CXRenamingAction, and
+ * remains valid after \c CXRenamingAction is destroyed.
+ */
+typedef void *CXRenamingResult;
+
+/**
+ * \brief Opaque pointer representing all of the symbol occurrences from a
+ * single TU/file.
+ *
+ * The result of a symbol search occurrence search operation is indepedent from
+ * \c CXRefactoringAction, and remains valid after \c CXRefactoringAction is
+ * destroyed.
+ */
+typedef void *CXSymbolOccurrencesResult;
+
+/**
+ * \brief Find the cursor that's being renamed at the given location.
+ *
+ * \param TU The translation unit in which the cursor is present.
+ *
+ * \param Location The location at which the refactoring action will be
+ * performed.
+ *
+ * \param SelectionRange The range in which the AST should be checked. Usually
+ * corresponds to the selection range or location of the cursor in the editor.
+ * Can be a null range.
+ *
+ * \returns Zero on success, CXError_RefactoringActionUnavailable when
+ * there's no suitable cursor at the given location, or an error code otherwise.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_findRenamedCursor(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, CXCursor *OutCursor);
+
+/**
+ * \brief Initiates a renaming operation on a previously initiated refactoring
+ * action.
+ *
+ * The initiation process finds the symbols that have to be renamed for a
+ * previously initiated \c CXRefactor_Rename refactoring action.
+ *
+ * \returns Zero on success, or an error code otherwise.
+ */
+// TODO: Remove
+CINDEX_LINKAGE
+enum CXErrorCode
+clang_Refactoring_initiateRenamingOperation(CXRefactoringAction Action);
+
+/**
+ * \brief Set the new name of the renamed symbol in the given \c
+ * RenamingAction.
+ *
+ * \returns Zero on success, CXError_RefactoringNameInvalid when the new name
+ * isn't a valid identifier, CXError_RefactoringNameSizeMismatch when the new
+ * name has an incorrect number of pieces or a different error code otherwise.
+ */
+// TODO: Remove
+CINDEX_LINKAGE
+enum CXErrorCode clang_RenamingOperation_setNewName(CXRefactoringAction Action,
+                                                    const char *NewName);
+
+/**
+ * \brief Return the number of symbols that are renamed by the given renaming
+ * action.
+ *
+ * A renaming action typically works on just one symbol. However, there are
+ * certain language constructs that require work with more than one symbol in
+ * order for them to be renamed correctly. Property declarations in Objective-C
+ * are the perfect example: in addition to the actual property, the action has
+ * to rename the corresponding getters and setters, as well as the backing ivar.
+ */
+// TODO: Remove
+CINDEX_LINKAGE
+unsigned clang_RenamingOperation_getNumSymbols(CXRefactoringAction Action);
+
+/**
+ * \brief Return the USR of the declaration that was found for the symbol at the
+ * given \p Index in the given renaming action.
+ */
+// TODO: Remove
+CINDEX_LINKAGE
+CXString clang_RenamingOperation_getUSRForSymbol(CXRefactoringAction Action,
+                                                 unsigned Index);
+
+// TODO: Remove
+CINDEX_LINKAGE
+CXRenamingResult clang_Refactoring_findRenamedOccurrencesInPrimaryTUs(
+    CXRefactoringAction Action, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles);
+
+/**
+ * \brief Find all of the occurrences of the symbol that is being searched for
+ * by the given refactoring action in the translation unit that was used to
+ * initiate the refactoring action.
+ *
+ * This function searches for all of the \c CXSymbolOccurrence in the
+ * translation units that are referenced by the given \c CXRefactoringAction by
+ * iterating through the AST of the each translation unit. The occurrences that
+ * are found don't have to be from the main file in the translation unit, they
+ * can be from files included in that translation unit.
+ *
+ * \param Action The \c CXRefactoringAction operation that was inititated by
+ * \c clang_Refactoring_initiateActionAt().
+ *
+ * \param CommandLineArgs The command-line arguments that would be
+ * passed to the \c clang executable if it were being invoked out-of-process.
+ *
+ * \param NumCommandLineArgs The number of command-line arguments in
+ * \c CommandLineArgs.
+ *
+ * \param UnsavedFiles the files that have not yet been saved to disk
+ * but may be required for parsing, including the contents of
+ * those files.  The contents and name of these files (as specified by
+ * CXUnsavedFile) are copied when necessary, so the client only needs to
+ * guarantee their validity until the call to this function returns.
+ *
+ * \param NumUnsavedFiles the number of unsaved file entries in \p
+ * UnsavedFiles.
+ *
+ * \returns If successful, a new \c CXSymbolOccurrencesResult structure
+ * containing the occurrences of the symbol in the initiation translation unit,
+ * which should eventually be freed with \c clang_SymbolOccurrences_dispose().
+ * If symbol search fails, returns NULL.
+ */
+CINDEX_LINKAGE
+CXSymbolOccurrencesResult clang_Refactoring_findSymbolOccurrencesInInitiationTU(
+    CXRefactoringAction Action, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles);
+
+// TODO: Remove
+typedef struct {
+  CXFileLocation Location;
+  /**
+   * The kind of the declaration/expression that was indexed at this location.
+   * This is particularly important for Objective-C selectors. The refactoring
+   * engine requires the following cursor kinds for the following indexed
+   * occurrences:
+   *   - ObjC method declaration:  CXCursor_ObjC(Instance/Class)MethodDecl
+   *   - ObjC method message send: CXCursor_ObjCMessageExpr
+   * Other occurrences can use any other cursor cursor kinds.
+   */
+  enum CXCursorKind CursorKind;
+} CXRenamedIndexedSymbolLocation;
+
+// TODO: Remove
+typedef struct {
+  /**
+   * An array of occurrences that represent indexed occurrences of a symbol.
+   * It's valid to pass-in no indexed locations, the refactoring engine will
+   * just perform textual search in that case.
+   */
+  const CXRenamedIndexedSymbolLocation *IndexedLocations;
+  unsigned IndexedLocationCount;
+  /**
+  * The kind of the declaration that is being renamed.
+  * This is particularly important for Objective-C selectors. The refactoring
+  * engine requires the following cursor kinds for the following renamed
+  * declaration:
+  *   - ObjC methods:  CXCursor_ObjC(Instance/Class)MethodDecl
+  * Other declarations can use any other cursor cursor kinds.
+  */
+  enum CXCursorKind CursorKind;
+  const char *Name;
+  const char *NewName;
+} CXRenamedIndexedSymbol;
+
+// TODO: Remove
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_findRenamedOccurrencesInIndexedFile(
+    const CXRenamedIndexedSymbol *Symbols, unsigned NumSymbols, CXIndex CIdx,
+    const char *Filename, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles, CXRefactoringOptionSet Options,
+    CXRenamingResult *OutResult);
+
+/**
+ * \brief A location of an already known occurrence of a symbol.
+ *
+ * Used for rename-indexed operation where the renaming is performed on an
+ * already indexed source file.
+ */
+typedef struct {
+  CXFileLocation Location;
+  /**
+   * The kind of the declaration/expression that was indexed at this location.
+   * This is particularly important for Objective-C selectors. The refactoring
+   * engine requires the following cursor kinds for the following indexed
+   * occurrences:
+   *   - ObjC method declaration:  CXCursor_ObjC(Instance/Class)MethodDecl
+   *   - ObjC method message send: CXCursor_ObjCMessageExpr
+   *   - filename in an #include: CXCursor_InclusionDirective
+   * Other occurrences can use any other cursor cursor kinds.
+   */
+  enum CXCursorKind CursorKind;
+} CXIndexedSymbolLocation;
+
+/**
+ * \brief A symbol that should be found the an indexer symbol search operation.
+ *
+ * Used for rename-indexed operation where the renaming is performed on an
+ * already indexed source file.
+ */
+typedef struct {
+  /**
+   * An array of occurrences that represent indexed occurrences of a symbol.
+   * It's valid to pass-in no indexed locations, the refactoring engine will
+   * just perform textual search in that case.
+   */
+  const CXIndexedSymbolLocation *IndexedLocations;
+  unsigned IndexedLocationCount;
+  /**
+   * The kind of the declaration that is being renamed.
+   * This is particularly important for Objective-C selectors. The refactoring
+   * engine requires the following cursor kinds for the following renamed
+   * declaration:
+   *   - ObjC methods:  CXCursor_ObjC(Instance/Class)MethodDecl
+   *   - ObjC class:    CXCursor_ObjCInterfaceDecl
+   * Other declarations can use any other cursor cursor kinds.
+   */
+  enum CXCursorKind CursorKind;
+  /**
+   * The name of the symbol. Objective-C selector names should be specified
+   * using the ':' separator for selector pieces.
+   */
+  const char *Name;
+} CXIndexedSymbol;
+
+/**
+ * \brief Find all of the occurrences of a symbol in an indexed file.
+ *
+ * This function searches for all of the \c CXIndexedSymbol in the
+ * given file by inspecting the source code at the given indexed locations.
+ *
+ * The indexed operations are thread-safe and can be performed concurrently.
+ *
+ * \param Symbols The information about the symbols that includes the locations
+ * for a symbol in the file as determined by the indexer.
+ *
+ * \param NumSymbols The number of symbols in \p Symbols.
+ *
+ * \param CIdx The index object with which the translation unit will be
+ * associated.
+ *
+ * \param Filename The name of the source file that contains the given
+ * \p Locations.
+ *
+ * \param CommandLineArgs The command-line arguments that would be
+ * passed to the \c clang executable if it were being invoked out-of-process.
+ * These command-line options will be parsed and will affect how the translation
+ * unit is parsed.
+ *
+ * \param NumCommandLineArgs The number of command-line arguments in
+ * \c CommandLineArgs.
+ *
+ * \param UnsavedFiles the files that have not yet been saved to disk
+ * but may be required for parsing, including the contents of
+ * those files.  The contents and name of these files (as specified by
+ * CXUnsavedFile) are copied when necessary, so the client only needs to
+ * guarantee their validity until the call to this function returns.
+ *
+ * \param NumUnsavedFiles the number of unsaved file entries in \p
+ * UnsavedFiles.
+ *
+ * \param Options The optional refactoring options that might have an influence
+ * on the initiation process.
+ *
+ * \param[out] OutResult A non-NULL pointer to store the created
+ * \c CXSymbolOccurrencesResult.
+ *
+ * \returns Zero on success, or a different error code otherwise.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_findSymbolOccurrencesInIndexedFile(
+    const CXIndexedSymbol *Symbols, unsigned NumSymbols, CXIndex CIdx,
+    const char *Filename, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles, CXRefactoringOptionSet Options,
+    CXSymbolOccurrencesResult *OutResult);
+
+// TODO: Remove
+CINDEX_LINKAGE
+unsigned clang_RenamingResult_getNumModifiedFiles(CXRenamingResult Result);
+
+// TODO: Remove
+CINDEX_LINKAGE
+void clang_RenamingResult_getResultForFile(CXRenamingResult Result,
+                                           unsigned FileIndex,
+                                           CXFileRenamingResult *OutResult);
+
+// TODO: Remove
+CINDEX_LINKAGE
+void clang_RenamingResult_dispose(CXRenamingResult Result);
+
+/**
+ * \brief Return the number of files that have occurrences of the specific
+ * symbol.
+ */
+CINDEX_LINKAGE
+unsigned clang_SymbolOccurrences_getNumFiles(CXSymbolOccurrencesResult Result);
+
+/**
+ * \brief Return the set of symbol occurrences in a single file.
+ *
+ * The resulting \c CXSymbolOccurrencesInFile is managed by the
+ * \c CXSymbolOccurrencesResult and doesn't have to be disposed of manually.
+ */
+CINDEX_LINKAGE
+void clang_SymbolOccurrences_getOccurrencesForFile(
+    CXSymbolOccurrencesResult Result, unsigned FileIndex,
+    CXSymbolOccurrencesInFile *OutResult);
+
+// TODO: Support refactoring continuations for \c CXSymbolOccurrencesResult,
+// e.g. for function parameter name rename.
+
+/**
+ * \brief Free the given symbol occurrences result.
+ */
+CINDEX_LINKAGE
+void clang_SymbolOccurrences_dispose(CXSymbolOccurrencesResult Result);
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup CINDEX_REFACTOR_PERFORM Performing refactoring operations.
+ *
+ * @{
+ */
+
+/**
+ * \brief Opaque pointer representing the results of the refactoring operation.
+ *
+ * The result of a refactoring action depends on the \c CXRefactoringAction, and
+ * is invalidated after \c CXRefactoringAction is destroyed.
+ */
+typedef void *CXRefactoringResult;
+
+/**
+ * \brief Opaque pointer representing a refactoring continuation.
+ *
+ * Refactoring continuations allow refactoring operations to run in external
+ * AST units with some results that were obtained after querying the indexer.
+ *
+ * The refactoring continuation is not dependent on the \c CXRefactoringAction
+ * or \c CXRefactoringResult. It does depend on the initiation
+ * \c CXTranslationUnit initially, but that dependency can be terminated.
+ */
+typedef void *CXRefactoringContinuation;
+
+/**
+ * \brief Opaque pointer representing a query to the indexer.
+ */
+typedef void *CXIndexerQuery;
+
+/**
+ * \brief Performs the previously initiated refactoring operation.
+ *
+ * This function executes the refactoring operation which produces a set of
+ * candidate source replacements that can be applied to the source files.
+ *
+ * \param Action The refactoring action.
+ *
+ * \param CommandLineArgs The command-line arguments that would be
+ * passed to the \c clang executable if it were being invoked out-of-process.
+ * These command-line options will be parsed and will affect how the translation
+ * unit is parsed.
+ *
+ * \param NumCommandLineArgs The number of command-line arguments in
+ * \c CommandLineArgs.
+ *
+ * \param UnsavedFiles the files that have not yet been saved to disk
+ * but may be required for parsing, including the contents of
+ * those files.  The contents and name of these files (as specified by
+ * CXUnsavedFile) are copied when necessary, so the client only needs to
+ * guarantee their validity until the call to this function returns.
+ *
+ * \param NumUnsavedFiles the number of unsaved file entries in \p
+ * UnsavedFiles.
+ *
+ * \param Options The optional refactoring options that might have an influence
+ * on the way the particular action will be performed.
+ *
+ * \param[out] OutFailureReason An optional pointer to store a message that
+ * describes why the action wasn't performed.
+ *
+ * \returns If successful, a new \c CXRefactoringResult structure containing the
+ * source replacement candidates, which should eventually be freed with
+ * \c clang_RefactoringResult_dispose(). If the refactoring operation fails,
+ * returns NULL.
+ */
+CINDEX_LINKAGE
+CXRefactoringResult clang_Refactoring_performOperation(
+    CXRefactoringAction Action, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles, CXRefactoringOptionSet Options,
+    CXString *OutFailureReason);
+
+// TODO: Remove. This is the deprecated API.
+CINDEX_LINKAGE
+void clang_RefactoringResult_getReplacements(
+    CXRefactoringResult Result, CXRefactoringReplacements_Old *OutReplacements);
+
+/**
+ * \brief Return the set of refactoring source replacements.
+ *
+ * The resulting \c CXRefactoringReplacements are managed by the
+ * \c CXRefactoringResult and don't have to be disposed of manually.
+ */
+CINDEX_LINKAGE
+CXRefactoringReplacements
+clang_RefactoringResult_getSourceReplacements(CXRefactoringResult Result);
+
+/**
+ * \brief Represents a set of symbol occurrences that are associated with a
+ * single refactoring replacement.
+ *
+ * The symbol occurrences depend on \c CXRefactoringResult, and can't be
+ * used after the refactoring result is freed.
+ */
+typedef struct {
+  const CXSymbolOccurrence *AssociatedSymbolOccurrences;
+  unsigned NumAssociatedSymbolOccurrences;
+} CXRefactoringReplacementAssociatedSymbolOccurrences;
+
+/**
+ * \brief Return the set of symbol occurrences that are associated with the
+ * given \p Replacement.
+ */
+CXRefactoringReplacementAssociatedSymbolOccurrences
+clang_RefactoringReplacement_getAssociatedSymbolOccurrences(
+    CXRefactoringReplacement Replacement);
+
+/**
+ * \brief Returns the refactoring continuation associated with this result, or
+ * NULL if this result has no refactoring continuation.
+ */
+CINDEX_LINKAGE
+CXRefactoringContinuation
+clang_RefactoringResult_getContinuation(CXRefactoringResult Result);
+
+/**
+ * \brief Free the given refactoring result.
+ */
+CINDEX_LINKAGE
+void clang_RefactoringResult_dispose(CXRefactoringResult Result);
+
+/**
+ * \brief Load the indexer query results from a YAML string.
+ *
+ * Mainly used for testing.
+ */
+CINDEX_LINKAGE
+enum CXErrorCode
+clang_RefactoringContinuation_loadSerializedIndexerQueryResults(
+    CXRefactoringContinuation Continuation, const char *Source);
+
+/**
+ * \brief Return the number of indexer queries that a refactoring continuation
+ * has.
+ */
+CINDEX_LINKAGE
+unsigned clang_RefactoringContinuation_getNumIndexerQueries(
+    CXRefactoringContinuation Continuation);
+
+/**
+ * \brief Return the indexer query at index \p Index.
+ */
+CINDEX_LINKAGE
+CXIndexerQuery clang_RefactoringContinuation_getIndexerQuery(
+    CXRefactoringContinuation Continuation, unsigned Index);
+
+/**
+ * \brief Verify that the all of the indexer queries are satisfied by the
+ * continuation.
+ *
+ * \returns Null if all of the queries are satisfied an no errors have been
+ * reported, or a set of diagnostics that describes why the continuation should
+ * not be run.
+ */
+CINDEX_LINKAGE
+CXDiagnosticSet clang_RefactoringContinuation_verifyBeforeFinalizing(
+    CXRefactoringContinuation Continuation);
+
+/**
+ * \brief Terminate the connection between the initiation TU and the refactoring
+ * continuation.
+ *
+ * The continuation converts all the TU-specific state to TU-independent state.
+ * The indexer queries that are associate with this continuation are also
+ * invalidated.
+ */
+CINDEX_LINKAGE
+void clang_RefactoringContinuation_finalizeEvaluationInInitationTU(
+    CXRefactoringContinuation Continuation);
+
+/**
+ * \brief Continue performing the previously initiated and performed refactoring
+ * operation in the given translation unit \p TU.
+ */
+CINDEX_LINKAGE
+CXRefactoringResult clang_RefactoringContinuation_continueOperationInTU(
+    CXRefactoringContinuation Continuation, CXTranslationUnit TU,
+    CXString *OutFailureReason);
+
+/**
+ * \brief Free the given refactoring continuation.
+ */
+CINDEX_LINKAGE
+void clang_RefactoringContinuation_dispose(
+    CXRefactoringContinuation Continuation);
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup CINDEX_REFACTOR_INDEXER_QUERY Indexer Queries.
+ *
+ * @{
+ */
+
+/**
+ * \brief The types of indexer queries.
+ */
+enum CXIndexerQueryKind {
+  CXIndexerQuery_Unknown = 0,
+
+  /**
+   * \brief The indexer should find the file that contains/should contain the
+   * implementation of some declaration.
+   * A file result is expected.
+   */
+  CXIndexerQuery_Decl_FileThatShouldImplement = 1,
+
+  /**
+   * \brief The indexer should determine if the some declaration is defined.
+   * An integer result is expected.
+   */
+  CXIndexerQuery_Decl_IsDefined = 2,
+};
+
+/**
+ * \brief Return the kind of the indexer query \p Query.
+ */
+CINDEX_LINKAGE
+enum CXIndexerQueryKind clang_IndexerQuery_getKind(CXIndexerQuery Query);
+
+/**
+ * \brief Return the number of cursors that the \p Query has.
+ */
+CINDEX_LINKAGE
+unsigned clang_IndexerQuery_getNumCursors(CXIndexerQuery Query);
+
+/**
+ * \brief Return the cursor at the given \p CursorIndex.
+ */
+CINDEX_LINKAGE
+CXCursor clang_IndexerQuery_getCursor(CXIndexerQuery Query,
+                                      unsigned CursorIndex);
+
+/**
+ * \brief The action that the indexer should take after evaluating the query.
+ */
+enum CXIndexerQueryAction {
+  /**
+   * \brief This result requires no further action.
+   */
+  CXIndexerQueryAction_None = 0,
+
+  /**
+   * \brief The indexer should run the \c CXRefactoringContinuaton in a
+   * translation unit that contains this file.
+   */
+  CXIndexerQueryAction_RunContinuationInTUThatHasThisFile = 1,
+};
+
+/**
+ * \brief Consumes an integer/boolean query result.
+ */
+CINDEX_LINKAGE
+enum CXIndexerQueryAction
+clang_IndexerQuery_consumeIntResult(CXIndexerQuery Query, unsigned CursorIndex,
+                                    int Value);
+
+/**
+ * \brief Consumes a filename query result.
+ *
+ * This function may return
+ * \c CXIndexerQueryAction_RunContinuationInTUThatHasThisFile which
+ * should tell the indexer that it has to run the refactoring continuation in
+ * the TU that contains this file.
+ */
+CINDEX_LINKAGE
+enum CXIndexerQueryAction
+clang_IndexerQuery_consumeFileResult(CXIndexerQuery Query, unsigned CursorIndex,
+                                     const char *Filename);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LLVM_CLANG_C_REFACTOR_H */
diff --git a/include/clang/APINotes/APINotesManager.h b/include/clang/APINotes/APINotesManager.h
index e69de29bb2..6eb0534060 100644
--- a/include/clang/APINotes/APINotesManager.h
+++ b/include/clang/APINotes/APINotesManager.h
@@ -0,0 +1,144 @@
+//===--- APINotesManager.h - Manage API Notes Files -------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the APINotesManager interface.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_APINOTES_APINOTESMANAGER_H
+#define LLVM_CLANG_APINOTES_APINOTESMANAGER_H
+
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Basic/Module.h"
+#include "clang/Basic/VersionTuple.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/PointerUnion.h"
+#include "llvm/ADT/StringRef.h"
+#include <memory>
+#include <string>
+
+namespace clang {
+
+class DirectoryEntry;
+class FileEntry;
+class LangOptions;
+class SourceManager;
+
+namespace api_notes {
+
+class APINotesReader;
+
+/// The API notes manager helps find API notes associated with declarations.
+///
+/// API notes are externally-provided annotations for declarations that can
+/// introduce new attributes (covering availability, nullability of
+/// parameters/results, and so on) for specific declarations without directly
+/// modifying the headers that contain those declarations.
+///
+/// The API notes manager is responsible for finding and loading the
+/// external API notes files that correspond to a given header. Its primary
+/// operation is \c findAPINotes(), which finds the API notes reader that
+/// provides information about the declarations at that location.
+class APINotesManager {
+  typedef llvm::PointerUnion<const DirectoryEntry *, APINotesReader *>
+    ReaderEntry;
+
+  SourceManager &SourceMgr;
+
+  /// Whether to implicitly search for API notes files based on the
+  /// source file from which an entity was declared.
+  bool ImplicitAPINotes;
+
+  /// The Swift version to use when interpreting versioned API notes.
+  VersionTuple SwiftVersion;
+
+  /// API notes readers for the current module.
+  ///
+  /// There can be up to two of these, one for public headers and one
+  /// for private headers.
+  APINotesReader *CurrentModuleReaders[2] = { nullptr, nullptr };
+
+  /// A mapping from header file directories to the API notes reader for
+  /// that directory, or a redirection to another directory entry that may
+  /// have more information, or NULL to indicate that there is no API notes
+  /// reader for this directory.
+  llvm::DenseMap<const DirectoryEntry *, ReaderEntry> Readers;
+
+  /// Load the API notes associated with the given file, whether it is
+  /// the binary or source form of API notes.
+  ///
+  /// \returns the API notes reader for this file, or null if there is
+  /// a failure.
+  std::unique_ptr<APINotesReader> loadAPINotes(const FileEntry *apiNotesFile);
+
+  /// Load the given API notes file for the given header directory.
+  ///
+  /// \param HeaderDir The directory at which we
+  ///
+  /// \returns true if an error occurred.
+  bool loadAPINotes(const DirectoryEntry *HeaderDir,
+                    const FileEntry *APINotesFile);
+
+  /// Look for API notes in the given directory.
+  ///
+  /// This might find either a binary or source API notes.
+  const FileEntry *findAPINotesFile(const DirectoryEntry *directory,
+                                    StringRef filename,
+                                    bool wantPublic = true);
+
+  /// Attempt to load API notes for the given framework.
+  ///
+  /// \param FrameworkPath The path to the framework.
+  /// \param Public Whether to load the public API notes. Otherwise, attempt
+  /// to load the private API notes.
+  ///
+  /// \returns the header directory entry (e.g., for Headers or PrivateHeaders)
+  /// for which the API notes were successfully loaded, or NULL if API notes
+  /// could not be loaded for any reason.
+  const DirectoryEntry *loadFrameworkAPINotes(llvm::StringRef FrameworkPath,
+                                              llvm::StringRef FrameworkName,
+                                              bool Public);
+
+public:
+  APINotesManager(SourceManager &sourceMgr, const LangOptions &langOpts);
+  ~APINotesManager();
+
+  /// Set the Swift version to use when filtering API notes.
+  void setSwiftVersion(VersionTuple swiftVersion) {
+    SwiftVersion = swiftVersion;
+  }
+
+  /// Load the API notes for the current module.
+  ///
+  /// \param module The current module.
+  /// \param lookInModule Whether to look inside the module itself.
+  /// \param searchPaths The paths in which we should search for API notes
+  /// for the current module.
+  ///
+  /// \returns true if API notes were successfully loaded, \c false otherwise.
+  bool loadCurrentModuleAPINotes(const Module *module,
+                                 bool lookInModule,
+                                 ArrayRef<std::string> searchPaths);
+
+  /// Retrieve the set of API notes readers for the current module.
+  ArrayRef<APINotesReader *> getCurrentModuleReaders() const {
+    unsigned numReaders = static_cast<unsigned>(CurrentModuleReaders[0] != nullptr) +
+      static_cast<unsigned>(CurrentModuleReaders[1] != nullptr);
+    return llvm::makeArrayRef(CurrentModuleReaders).slice(0, numReaders);
+  }
+
+  /// Find the API notes readers that correspond to the given source location.
+  llvm::SmallVector<APINotesReader *, 2> findAPINotes(SourceLocation Loc);
+};
+
+} // end namespace api_notes
+} // end namespace clang
+
+#endif
diff --git a/include/clang/APINotes/APINotesOptions.h b/include/clang/APINotes/APINotesOptions.h
index e69de29bb2..24bb9134b2 100644
--- a/include/clang/APINotes/APINotesOptions.h
+++ b/include/clang/APINotes/APINotesOptions.h
@@ -0,0 +1,41 @@
+//===--- APINotesOptions.h --------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//  This file defines the APINotesOptions class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_APINOTES_APINOTESOPTIONS_H
+#define LLVM_CLANG_APINOTES_APINOTESOPTIONS_H
+
+#include "clang/Basic/VersionTuple.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+
+/// APINotesOptions - Track various options which control how API
+/// notes are found and handled.
+class APINotesOptions {
+public:
+  /// The Swift version which should be used for API notes.
+  VersionTuple SwiftVersion;
+
+  /// The set of search paths where we API notes can be found for
+  /// particular modules.
+  ///
+  /// The API notes in this directory are stored as
+  /// <ModuleName>.apinotes or <ModuleName>.apinotesc, and are only
+  /// applied when building the module <ModuleName>.
+  std::vector<std::string> ModuleSearchPaths;
+};
+
+}  // end namespace clang
+
+#endif
diff --git a/include/clang/APINotes/APINotesReader.h b/include/clang/APINotes/APINotesReader.h
index e69de29bb2..a71c74da7b 100644
--- a/include/clang/APINotes/APINotesReader.h
+++ b/include/clang/APINotes/APINotesReader.h
@@ -0,0 +1,269 @@
+//===--- APINotesReader.h - API Notes Reader ----------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the \c APINotesReader class that reads source
+// API notes data providing additional information about source code as
+// a separate input, such as the non-nil/nilable annotations for
+// method parameters.
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_CLANG_API_NOTES_READER_H
+#define LLVM_CLANG_API_NOTES_READER_H
+
+#include "clang/APINotes/Types.h"
+#include "clang/Basic/VersionTuple.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include <memory>
+
+namespace clang {
+namespace api_notes {
+
+/// A class that reads API notes data from a binary file that was written by
+/// the \c APINotesWriter.
+class APINotesReader {
+  class Implementation;
+
+  Implementation &Impl;
+
+  APINotesReader(llvm::MemoryBuffer *inputBuffer, bool ownsInputBuffer,
+                 VersionTuple swiftVersion, bool &failed);
+
+public:
+  /// Create a new API notes reader from the given member buffer, which
+  /// contains the contents of a binary API notes file.
+  ///
+  /// \returns the new API notes reader, or null if an error occurred.
+  static std::unique_ptr<APINotesReader>
+  get(std::unique_ptr<llvm::MemoryBuffer> inputBuffer,
+      VersionTuple swiftVersion);
+
+  /// Create a new API notes reader from the given member buffer, which
+  /// contains the contents of a binary API notes file.
+  ///
+  /// \returns the new API notes reader, or null if an error occurred.
+  static std::unique_ptr<APINotesReader>
+  getUnmanaged(llvm::MemoryBuffer *inputBuffer,
+               VersionTuple swiftVersion);
+
+  ~APINotesReader();
+
+  APINotesReader(const APINotesReader &) = delete;
+  APINotesReader &operator=(const APINotesReader &) = delete;
+
+  /// Retrieve the name of the module for which this reader is providing API
+  /// notes.
+  StringRef getModuleName() const;
+
+  /// Retrieve the size and modification time of the source file from
+  /// which this API notes file was created, if known.
+  Optional<std::pair<off_t, time_t>> getSourceFileSizeAndModTime() const;
+
+  /// Retrieve the module options
+  ModuleOptions getModuleOptions() const;
+
+  /// Captures the completed versioned information for a particular part of
+  /// API notes, including both unversioned API notes and each versioned API
+  /// note for that particular entity.
+  template<typename T>
+  class VersionedInfo {
+    /// The complete set of results.
+    SmallVector<std::pair<VersionTuple, T>, 1> Results;
+
+    /// The index of the result that is the "selected" set based on the desired
+    /// Swift version, or \c Results.size() if nothing matched.
+    unsigned Selected;
+
+  public:
+    /// Form an empty set of versioned information.
+    VersionedInfo(llvm::NoneType) : Selected(0) { }
+    
+    /// Form a versioned info set given the desired version and a set of
+    /// results.
+    VersionedInfo(VersionTuple version,
+                  SmallVector<std::pair<VersionTuple, T>, 1> results);
+
+    /// Determine whether there is a result that should be applied directly
+    /// to the AST.
+    explicit operator bool() const { return Selected != size(); }
+
+    /// Retrieve the information to apply directly to the AST.
+    const T& operator*() const {
+      assert(*this && "No result to apply directly");
+      return (*this)[Selected].second;
+    }
+
+    /// Retrieve the selected index in the result set.
+    Optional<unsigned> getSelected() const {
+      if (Selected == Results.size()) return None;
+      return Selected;
+    }
+
+    /// Return the number of versioned results we know about.
+    unsigned size() const { return Results.size(); }
+
+    /// Access all versioned results.
+    const std::pair<VersionTuple, T> *begin() const { return Results.begin(); }
+    const std::pair<VersionTuple, T> *end() const { return Results.end(); }
+
+    /// Access a specific versioned result.
+    const std::pair<VersionTuple, T> &operator[](unsigned index) const {
+      return Results[index];
+    }
+  };
+
+  /// Look for the context ID of the given Objective-C class.
+  ///
+  /// \param name The name of the class we're looking for.
+  ///
+  /// \returns The ID, if known.
+  Optional<ContextID> lookupObjCClassID(StringRef name);
+
+  /// Look for information regarding the given Objective-C class.
+  ///
+  /// \param name The name of the class we're looking for.
+  ///
+  /// \returns The information about the class, if known.
+  VersionedInfo<ObjCContextInfo> lookupObjCClassInfo(StringRef name);
+
+  /// Look for the context ID of the given Objective-C protocol.
+  ///
+  /// \param name The name of the protocol we're looking for.
+  ///
+  /// \returns The ID of the protocol, if known.
+  Optional<ContextID> lookupObjCProtocolID(StringRef name);
+
+  /// Look for information regarding the given Objective-C protocol.
+  ///
+  /// \param name The name of the protocol we're looking for.
+  ///
+  /// \returns The information about the protocol, if known.
+  VersionedInfo<ObjCContextInfo> lookupObjCProtocolInfo(StringRef name);
+
+  /// Look for information regarding the given Objective-C property in
+  /// the given context.
+  ///
+  /// \param contextID The ID that references the context we are looking for.
+  /// \param name The name of the property we're looking for.
+  /// \param isInstance Whether we are looking for an instance property (vs.
+  /// a class property).
+  ///
+  /// \returns Information about the property, if known.
+  VersionedInfo<ObjCPropertyInfo> lookupObjCProperty(ContextID contextID,
+                                                     StringRef name,
+                                                     bool isInstance);
+
+  /// Look for information regarding the given Objective-C method in
+  /// the given context.
+  ///
+  /// \param contextID The ID that references the context we are looking for.
+  /// \param selector The selector naming the method we're looking for.
+  /// \param isInstanceMethod Whether we are looking for an instance method.
+  ///
+  /// \returns Information about the method, if known.
+  VersionedInfo<ObjCMethodInfo> lookupObjCMethod(ContextID contextID,
+                                                 ObjCSelectorRef selector,
+                                                 bool isInstanceMethod);
+
+  /// Look for information regarding the given global variable.
+  ///
+  /// \param name The name of the global variable.
+  ///
+  /// \returns information about the global variable, if known.
+  VersionedInfo<GlobalVariableInfo> lookupGlobalVariable(StringRef name);
+
+  /// Look for information regarding the given global function.
+  ///
+  /// \param name The name of the global function.
+  ///
+  /// \returns information about the global function, if known.
+  VersionedInfo<GlobalFunctionInfo> lookupGlobalFunction(StringRef name);
+
+  /// Look for information regarding the given enumerator.
+  ///
+  /// \param name The name of the enumerator.
+  ///
+  /// \returns information about the enumerator, if known.
+  VersionedInfo<EnumConstantInfo> lookupEnumConstant(StringRef name);
+
+  /// Look for information regarding the given tag
+  /// (struct/union/enum/C++ class).
+  ///
+  /// \param name The name of the tag.
+  ///
+  /// \returns information about the tag, if known.
+  VersionedInfo<TagInfo> lookupTag(StringRef name);
+
+  /// Look for information regarding the given typedef.
+  ///
+  /// \param name The name of the typedef.
+  ///
+  /// \returns information about the typedef, if known.
+  VersionedInfo<TypedefInfo> lookupTypedef(StringRef name);
+
+  /// Visitor used when walking the contents of the API notes file.
+  class Visitor {
+  public:
+    virtual ~Visitor();
+
+    /// Visit an Objective-C class.
+    virtual void visitObjCClass(ContextID contextID, StringRef name,
+                                const ObjCContextInfo &info,
+                                VersionTuple swiftVersion);
+
+    /// Visit an Objective-C protocol.
+    virtual void visitObjCProtocol(ContextID contextID, StringRef name,
+                                   const ObjCContextInfo &info,
+                                   VersionTuple swiftVersion);
+
+    /// Visit an Objective-C method.
+    virtual void visitObjCMethod(ContextID contextID, StringRef selector,
+                                 bool isInstanceMethod,
+                                 const ObjCMethodInfo &info,
+                                 VersionTuple swiftVersion);
+
+    /// Visit an Objective-C property.
+    virtual void visitObjCProperty(ContextID contextID, StringRef name,
+                                   bool isInstance,
+                                   const ObjCPropertyInfo &info,
+                                   VersionTuple swiftVersion);
+
+    /// Visit a global variable.
+    virtual void visitGlobalVariable(StringRef name,
+                                     const GlobalVariableInfo &info,
+                                     VersionTuple swiftVersion);
+
+    /// Visit a global function.
+    virtual void visitGlobalFunction(StringRef name,
+                                     const GlobalFunctionInfo &info,
+                                     VersionTuple swiftVersion);
+
+    /// Visit an enumerator.
+    virtual void visitEnumConstant(StringRef name,
+                                   const EnumConstantInfo &info,
+                                   VersionTuple swiftVersion);
+
+    /// Visit a tag.
+    virtual void visitTag(StringRef name, const TagInfo &info,
+                          VersionTuple swiftVersion);
+
+    /// Visit a typedef.
+    virtual void visitTypedef(StringRef name, const TypedefInfo &info,
+                              VersionTuple swiftVersion);
+  };
+
+  /// Visit the contents of the API notes file, passing each entity to the
+  /// given visitor.
+  void visit(Visitor &visitor);
+};
+
+} // end namespace api_notes
+} // end namespace clang
+
+#endif // LLVM_CLANG_API_NOTES_READER_H
diff --git a/include/clang/APINotes/APINotesWriter.h b/include/clang/APINotes/APINotesWriter.h
index e69de29bb2..62defc1f94 100644
--- a/include/clang/APINotes/APINotesWriter.h
+++ b/include/clang/APINotes/APINotesWriter.h
@@ -0,0 +1,126 @@
+//===--- APINotesWriter.h - API Notes Writer ----------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the \c APINotesWriter class that writes out source
+// API notes data providing additional information about source code as
+// a separate input, such as the non-nil/nilable annotations for
+// method parameters.
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_CLANG_API_NOTES_WRITER_H
+#define LLVM_CLANG_API_NOTES_WRITER_H
+
+#include "clang/Basic/VersionTuple.h"
+#include "clang/APINotes/Types.h"
+
+namespace llvm {
+  class raw_ostream;
+}
+
+namespace clang {
+
+class FileEntry;
+
+namespace api_notes {
+
+/// A class that writes API notes data to a binary representation that can be
+/// read by the \c APINotesReader.
+class APINotesWriter {
+  class Implementation;
+  Implementation &Impl;
+
+public:
+  /// Create a new API notes writer with the given module name and
+  /// (optional) source file.
+  APINotesWriter(StringRef moduleName, const FileEntry *sourceFile);
+  ~APINotesWriter();
+
+  APINotesWriter(const APINotesWriter &) = delete;
+  APINotesWriter &operator=(const APINotesWriter &) = delete;
+
+  /// Write the API notes data to the given stream.
+  void writeToStream(llvm::raw_ostream &os);
+
+  /// Add information about a specific Objective-C class or protocol.
+  ///
+  /// \param name The name of this class/protocol.
+  /// \param isClass Whether this is a class (vs. a protocol).
+  /// \param info Information about this class/protocol.
+  ///
+  /// \returns the ID of the class or protocol, which can be used to add
+  /// properties and methods to the class/protocol.
+  ContextID addObjCContext(StringRef name, bool isClass,
+                           const ObjCContextInfo &info,
+                           VersionTuple swiftVersion);
+
+  /// Add information about a specific Objective-C property.
+  ///
+  /// \param contextID The context in which this property resides.
+  /// \param name The name of this property.
+  /// \param info Information about this property.
+  void addObjCProperty(ContextID contextID, StringRef name,
+                       bool isInstanceProperty,
+                       const ObjCPropertyInfo &info,
+                       VersionTuple swiftVersion);
+
+  /// Add information about a specific Objective-C method.
+  ///
+  /// \param contextID The context in which this method resides.
+  /// \param selector The selector that names this method.
+  /// \param isInstanceMethod Whether this method is an instance method
+  /// (vs. a class method).
+  /// \param info Information about this method.
+  void addObjCMethod(ContextID contextID, ObjCSelectorRef selector,
+                     bool isInstanceMethod, const ObjCMethodInfo &info,
+                     VersionTuple swiftVersion);
+
+  /// Add information about a global variable.
+  ///
+  /// \param name The name of this global variable.
+  /// \param info Information about this global variable.
+  void addGlobalVariable(StringRef name, const GlobalVariableInfo &info,
+                         VersionTuple swiftVersion);
+
+  /// Add information about a global function.
+  ///
+  /// \param name The name of this global function.
+  /// \param info Information about this global function.
+  void addGlobalFunction(StringRef name, const GlobalFunctionInfo &info,
+                         VersionTuple swiftVersion);
+
+  /// Add information about an enumerator.
+  ///
+  /// \param name The name of this enumerator.
+  /// \param info Information about this enumerator.
+  void addEnumConstant(StringRef name, const EnumConstantInfo &info,
+                       VersionTuple swiftVersion);
+
+  /// Add information about a tag (struct/union/enum/C++ class).
+  ///
+  /// \param name The name of this tag.
+  /// \param info Information about this tag.
+  void addTag(StringRef name, const TagInfo &info,
+              VersionTuple swiftVersion);
+
+  /// Add information about a typedef.
+  ///
+  /// \param name The name of this typedef.
+  /// \param info Information about this typedef.
+  void addTypedef(StringRef name, const TypedefInfo &info,
+                  VersionTuple swiftVersion);
+
+  /// Add module options
+  void addModuleOptions(ModuleOptions opts);
+};
+
+} // end namespace api_notes
+} // end namespace clang
+
+#endif // LLVM_CLANG_API_NOTES_WRITER_H
+
diff --git a/include/clang/APINotes/APINotesYAMLCompiler.h b/include/clang/APINotes/APINotesYAMLCompiler.h
index e69de29bb2..508da65993 100644
--- a/include/clang/APINotes/APINotesYAMLCompiler.h
+++ b/include/clang/APINotes/APINotesYAMLCompiler.h
@@ -0,0 +1,62 @@
+//=== APINotesYAMLCompiler.h - API Notes YAML to binary compiler *- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file reads sidecar API notes specified in YAML format.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_API_NOTES_YAML_COMPILER_H
+#define LLVM_CLANG_API_NOTES_YAML_COMPILER_H
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Support/SourceMgr.h"
+#include <memory>
+
+namespace llvm {
+  class raw_ostream;
+  class MemoryBuffer;
+}
+
+namespace clang {
+
+class FileEntry;
+
+namespace api_notes {
+
+  enum class ActionType {
+    None,
+    YAMLToBinary,
+    BinaryToYAML,
+    Dump,
+  };
+
+  enum class OSType {
+    OSX,
+    IOS,
+    TvOS,
+    WatchOS,
+    Absent
+  };
+
+  /// Converts API notes from YAML format to binary format.
+  bool compileAPINotes(llvm::StringRef yamlInput,
+                       const FileEntry *sourceFile,
+                       llvm::raw_ostream &os,
+                       OSType targetOS,
+                       llvm::SourceMgr::DiagHandlerTy diagHandler = nullptr,
+                       void *diagHandlerCtxt = nullptr);
+
+  bool parseAndDumpAPINotes(llvm::StringRef yamlInput);
+
+  /// Converts API notes from the compiled binary format to the YAML format.
+  bool decompileAPINotes(std::unique_ptr<llvm::MemoryBuffer> input,
+                         llvm::raw_ostream &os);
+} // end namespace api_notes
+} // end namespace clang
+
+#endif // LLVM_CLANG_API_NOTES_YAML_COMPILER_H
diff --git a/include/clang/APINotes/Types.h b/include/clang/APINotes/Types.h
index e69de29bb2..0438ab6f0a 100644
--- a/include/clang/APINotes/Types.h
+++ b/include/clang/APINotes/Types.h
@@ -0,0 +1,794 @@
+//===--- Types.h - API Notes Data Types --------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines data types used in the representation of API notes data.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_API_NOTES_TYPES_H
+#define LLVM_CLANG_API_NOTES_TYPES_H
+#include "clang/Basic/Specifiers.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/ADT/StringRef.h"
+#include <cassert>
+#include <climits>
+
+namespace llvm {
+  class raw_ostream;
+}
+
+namespace clang {
+namespace api_notes {
+
+/// The file extension used for the source representation of API notes.
+static const char SOURCE_APINOTES_EXTENSION[] = "apinotes";
+
+/// The file extension used for the binary representation of API notes.
+static const char BINARY_APINOTES_EXTENSION[] = "apinotesc";
+
+using llvm::ArrayRef;
+using llvm::StringRef;
+using llvm::Optional;
+using llvm::None;
+
+/// Opaque context ID used to refer to an Objective-C class or protocol.
+class ContextID {
+public:
+  unsigned Value;
+
+  explicit ContextID(unsigned value) : Value(value) { }
+};
+
+enum class RetainCountConventionKind {
+  None,
+  CFReturnsRetained,
+  CFReturnsNotRetained,
+  NSReturnsRetained,
+  NSReturnsNotRetained,
+};
+
+
+/// Describes API notes data for any entity.
+///
+/// This is used as the base of all API notes.
+class CommonEntityInfo {
+public:
+  /// Message to use when this entity is unavailable.
+  std::string UnavailableMsg;
+
+  /// Whether this entity is marked unavailable.
+  unsigned Unavailable : 1;
+
+  /// Whether this entity is marked unavailable in Swift.
+  unsigned UnavailableInSwift : 1;
+
+private:
+  /// Whether SwiftPrivate was specified.
+  unsigned SwiftPrivateSpecified : 1;
+
+  /// Whether this entity is considered "private" to a Swift overlay.
+  unsigned SwiftPrivate : 1;
+
+public:
+  /// Swift name of this entity.
+  std::string SwiftName;
+
+  CommonEntityInfo()
+    : Unavailable(0), UnavailableInSwift(0), SwiftPrivateSpecified(0),
+      SwiftPrivate(0) { }
+
+  Optional<bool> isSwiftPrivate() const {
+    if (!SwiftPrivateSpecified) return None;
+    return SwiftPrivate;
+  }
+
+  void setSwiftPrivate(Optional<bool> swiftPrivate) {
+    if (swiftPrivate) {
+      SwiftPrivateSpecified = 1;
+      SwiftPrivate = *swiftPrivate;
+    } else {
+      SwiftPrivateSpecified = 0;
+      SwiftPrivate = 0;
+    }
+  }
+
+  friend bool operator==(const CommonEntityInfo &lhs,
+                         const CommonEntityInfo &rhs) {
+    return lhs.UnavailableMsg == rhs.UnavailableMsg &&
+           lhs.Unavailable == rhs.Unavailable &&
+           lhs.UnavailableInSwift == rhs.UnavailableInSwift &&
+           lhs.SwiftPrivateSpecified == rhs.SwiftPrivateSpecified &&
+           lhs.SwiftPrivate == rhs.SwiftPrivate &&
+           lhs.SwiftName == rhs.SwiftName;
+  }
+
+  friend bool operator!=(const CommonEntityInfo &lhs,
+                         const CommonEntityInfo &rhs) {
+    return !(lhs == rhs);
+  }
+
+  friend CommonEntityInfo &operator|=(CommonEntityInfo &lhs,
+                                      const CommonEntityInfo &rhs) {
+    // Merge unavailability.
+    if (rhs.Unavailable) {
+      lhs.Unavailable = true;
+      if (rhs.UnavailableMsg.length() != 0 &&
+          lhs.UnavailableMsg.length() == 0) {
+        lhs.UnavailableMsg = rhs.UnavailableMsg;
+      }
+    }
+
+    if (rhs.UnavailableInSwift) {
+      lhs.UnavailableInSwift = true;
+      if (rhs.UnavailableMsg.length() != 0 &&
+          lhs.UnavailableMsg.length() == 0) {
+        lhs.UnavailableMsg = rhs.UnavailableMsg;
+      }
+    }
+
+    if (rhs.SwiftPrivateSpecified && !lhs.SwiftPrivateSpecified) {
+      lhs.SwiftPrivateSpecified = 1;
+      lhs.SwiftPrivate = rhs.SwiftPrivate;
+    }
+
+    if (rhs.SwiftName.length() != 0 &&
+        lhs.SwiftName.length() == 0)
+      lhs.SwiftName = rhs.SwiftName;
+
+    return lhs;
+  }
+};
+
+/// Describes API notes for types.
+class CommonTypeInfo : public CommonEntityInfo {
+  /// The Swift type to which a given type is bridged.
+  ///
+  /// Reflects the swift_bridge attribute.
+  Optional<std::string> SwiftBridge;
+
+  /// The NS error domain for this type.
+  Optional<std::string> NSErrorDomain;
+
+public:
+  CommonTypeInfo() : CommonEntityInfo() { }
+
+  const Optional<std::string> &getSwiftBridge() const { return SwiftBridge; }
+
+  void setSwiftBridge(const Optional<std::string> &swiftType) {
+    SwiftBridge = swiftType;
+  }
+
+  void setSwiftBridge(const Optional<StringRef> &swiftType) {
+    if (swiftType)
+      SwiftBridge = *swiftType;
+    else
+      SwiftBridge = None;
+  }
+
+  const Optional<std::string> &getNSErrorDomain() const {
+    return NSErrorDomain;
+  }
+
+  void setNSErrorDomain(const Optional<std::string> &domain) {
+    NSErrorDomain = domain;
+  }
+
+  void setNSErrorDomain(const Optional<StringRef> &domain) {
+    if (domain)
+      NSErrorDomain = *domain;
+    else
+      NSErrorDomain = None;
+  }
+
+  friend CommonTypeInfo &operator|=(CommonTypeInfo &lhs,
+                                    const CommonTypeInfo &rhs) {
+    static_cast<CommonEntityInfo &>(lhs) |= rhs;
+    if (!lhs.SwiftBridge && rhs.SwiftBridge)
+      lhs.SwiftBridge = rhs.SwiftBridge;
+    if (!lhs.NSErrorDomain && rhs.NSErrorDomain)
+      lhs.NSErrorDomain = rhs.NSErrorDomain;
+    return lhs;
+  }
+
+  friend bool operator==(const CommonTypeInfo &lhs,
+                         const CommonTypeInfo &rhs) {
+    return static_cast<const CommonEntityInfo &>(lhs) == rhs &&
+      lhs.SwiftBridge == rhs.SwiftBridge &&
+      lhs.NSErrorDomain == rhs.NSErrorDomain;
+  }
+
+  friend bool operator!=(const CommonTypeInfo &lhs,
+                         const CommonTypeInfo &rhs) {
+    return !(lhs == rhs);
+  }
+};
+
+/// Describes API notes data for an Objective-C class or protocol.
+class ObjCContextInfo : public CommonTypeInfo {
+  /// Whether this class has a default nullability.
+  unsigned HasDefaultNullability : 1;
+
+  /// The default nullability.
+  unsigned DefaultNullability : 2;
+
+  /// Whether this class has designated initializers recorded.
+  unsigned HasDesignatedInits : 1;
+
+  unsigned SwiftImportAsNonGenericSpecified : 1;
+  unsigned SwiftImportAsNonGeneric : 1;
+
+  unsigned SwiftObjCMembersSpecified : 1;
+  unsigned SwiftObjCMembers : 1;
+
+public:
+  ObjCContextInfo()
+    : CommonTypeInfo(),
+      HasDefaultNullability(0),
+      DefaultNullability(0),
+      HasDesignatedInits(0),
+      SwiftImportAsNonGenericSpecified(false),
+      SwiftImportAsNonGeneric(false),
+      SwiftObjCMembersSpecified(false),
+      SwiftObjCMembers(false)
+  { }
+
+  /// Determine the default nullability for properties and methods of this
+  /// class.
+  ///
+  /// \returns the default nullability, if implied, or None if there is no
+  Optional<NullabilityKind> getDefaultNullability() const {
+    if (HasDefaultNullability)
+      return static_cast<NullabilityKind>(DefaultNullability);
+
+    return None;
+  }
+
+  /// Set the default nullability for properties and methods of this class.
+  void setDefaultNullability(NullabilityKind kind) {
+    HasDefaultNullability = true;
+    DefaultNullability = static_cast<unsigned>(kind);
+  }
+
+  bool hasDesignatedInits() const { return HasDesignatedInits; }
+  void setHasDesignatedInits(bool value) { HasDesignatedInits = value; }
+
+  Optional<bool> getSwiftImportAsNonGeneric() const {
+    if (SwiftImportAsNonGenericSpecified)
+      return SwiftImportAsNonGeneric;
+    return None;
+  }
+  void setSwiftImportAsNonGeneric(Optional<bool> value) {
+    if (value.hasValue()) {
+      SwiftImportAsNonGenericSpecified = true;
+      SwiftImportAsNonGeneric = value.getValue();
+    } else {
+      SwiftImportAsNonGenericSpecified = false;
+      SwiftImportAsNonGeneric = false;
+    }
+  }
+
+  Optional<bool> getSwiftObjCMembers() const {
+    if (SwiftObjCMembersSpecified)
+      return SwiftObjCMembers;
+    return None;
+  }
+  void setSwiftObjCMembers(Optional<bool> value) {
+    SwiftObjCMembersSpecified = value.hasValue();
+    SwiftObjCMembers = value.hasValue() ? *value : false;
+  }
+
+  /// Strip off any information within the class information structure that is
+  /// module-local, such as 'audited' flags.
+  void stripModuleLocalInfo() {
+    HasDefaultNullability = false;
+    DefaultNullability = 0;
+  }
+
+  friend bool operator==(const ObjCContextInfo &lhs, const ObjCContextInfo &rhs) {
+    return static_cast<const CommonTypeInfo &>(lhs) == rhs &&
+           lhs.getDefaultNullability() == rhs.getDefaultNullability() &&
+           lhs.HasDesignatedInits == rhs.HasDesignatedInits &&
+           lhs.getSwiftImportAsNonGeneric() ==
+             rhs.getSwiftImportAsNonGeneric() &&
+           lhs.getSwiftObjCMembers() == rhs.getSwiftObjCMembers();
+  }
+
+  friend bool operator!=(const ObjCContextInfo &lhs, const ObjCContextInfo &rhs) {
+    return !(lhs == rhs);
+  }
+
+  friend ObjCContextInfo &operator|=(ObjCContextInfo &lhs,
+                                     const ObjCContextInfo &rhs) {
+    // Merge inherited info.
+    static_cast<CommonTypeInfo &>(lhs) |= rhs;
+
+    // Merge nullability.
+    if (!lhs.getDefaultNullability()) {
+      if (auto nullable = rhs.getDefaultNullability()) {
+        lhs.setDefaultNullability(*nullable);
+      }
+    }
+
+    if (!lhs.SwiftImportAsNonGenericSpecified &&
+        rhs.SwiftImportAsNonGenericSpecified) {
+      lhs.SwiftImportAsNonGenericSpecified = true;
+      lhs.SwiftImportAsNonGeneric = rhs.SwiftImportAsNonGeneric;
+    }
+
+    if (!lhs.SwiftObjCMembersSpecified && rhs.SwiftObjCMembersSpecified) {
+      lhs.SwiftObjCMembersSpecified = true;
+      lhs.SwiftObjCMembers = rhs.SwiftObjCMembers;
+    }
+
+    lhs.HasDesignatedInits |= rhs.HasDesignatedInits;
+
+    return lhs;
+  }
+  
+  void dump(llvm::raw_ostream &os);
+};
+
+/// API notes for a variable/property.
+class VariableInfo : public CommonEntityInfo {
+  /// Whether this property has been audited for nullability.
+  unsigned NullabilityAudited : 1;
+
+  /// The kind of nullability for this property. Only valid if the nullability
+  /// has been audited.
+  unsigned Nullable : 2;
+
+  /// The C type of the variable, as a string.
+  std::string Type;
+
+public:
+  VariableInfo()
+    : CommonEntityInfo(),
+      NullabilityAudited(false),
+      Nullable(0) { }
+
+  Optional<NullabilityKind> getNullability() const {
+    if (NullabilityAudited)
+      return static_cast<NullabilityKind>(Nullable);
+
+    return None;
+  }
+
+  void setNullabilityAudited(NullabilityKind kind) {
+    NullabilityAudited = true;
+    Nullable = static_cast<unsigned>(kind);
+  }
+
+  const std::string &getType() const { return Type; }
+  void setType(const std::string &type) { Type = type; }
+
+  friend bool operator==(const VariableInfo &lhs, const VariableInfo &rhs) {
+    return static_cast<const CommonEntityInfo &>(lhs) == rhs &&
+           lhs.NullabilityAudited == rhs.NullabilityAudited &&
+           lhs.Nullable == rhs.Nullable &&
+           lhs.Type == rhs.Type;
+  }
+
+  friend bool operator!=(const VariableInfo &lhs, const VariableInfo &rhs) {
+    return !(lhs == rhs);
+  }
+
+  friend VariableInfo &operator|=(VariableInfo &lhs,
+                                  const VariableInfo &rhs) {
+    static_cast<CommonEntityInfo &>(lhs) |= rhs;
+    if (!lhs.NullabilityAudited && rhs.NullabilityAudited)
+      lhs.setNullabilityAudited(*rhs.getNullability());
+    if (lhs.Type.empty() && !rhs.Type.empty())
+      lhs.Type = rhs.Type;
+    return lhs;
+  }
+};
+
+/// Describes API notes data for an Objective-C property.
+class ObjCPropertyInfo : public VariableInfo {
+  unsigned SwiftImportAsAccessorsSpecified : 1;
+  unsigned SwiftImportAsAccessors : 1;
+
+public:
+  ObjCPropertyInfo()
+      : VariableInfo(), SwiftImportAsAccessorsSpecified(false),
+        SwiftImportAsAccessors(false) {}
+
+  /// Merge class-wide information into the given property.
+  friend ObjCPropertyInfo &operator|=(ObjCPropertyInfo &lhs,
+                                      const ObjCContextInfo &rhs) {
+    static_cast<VariableInfo &>(lhs) |= rhs;
+
+    // Merge nullability.
+    if (!lhs.getNullability()) {
+      if (auto nullable = rhs.getDefaultNullability()) {
+        lhs.setNullabilityAudited(*nullable);
+      }
+    }
+
+    return lhs;
+  }
+
+  Optional<bool> getSwiftImportAsAccessors() const {
+    if (SwiftImportAsAccessorsSpecified)
+      return SwiftImportAsAccessors;
+    return None;
+  }
+  void setSwiftImportAsAccessors(Optional<bool> value) {
+    if (value.hasValue()) {
+      SwiftImportAsAccessorsSpecified = true;
+      SwiftImportAsAccessors = value.getValue();
+    } else {
+      SwiftImportAsAccessorsSpecified = false;
+      SwiftImportAsAccessors = false;
+    }
+  }
+
+  friend ObjCPropertyInfo &operator|=(ObjCPropertyInfo &lhs,
+                                      const ObjCPropertyInfo &rhs) {
+    lhs |= static_cast<const VariableInfo &>(rhs);
+    if (!lhs.SwiftImportAsAccessorsSpecified &&
+        rhs.SwiftImportAsAccessorsSpecified) {
+      lhs.SwiftImportAsAccessorsSpecified = true;
+      lhs.SwiftImportAsAccessors = rhs.SwiftImportAsAccessors;
+    }
+    return lhs;
+  }
+
+  friend bool operator==(const ObjCPropertyInfo &lhs,
+                         const ObjCPropertyInfo &rhs) {
+    return static_cast<const VariableInfo &>(lhs) == rhs &&
+           lhs.getSwiftImportAsAccessors() == rhs.getSwiftImportAsAccessors();
+  }
+};
+
+/// Describes a function or method parameter.
+class ParamInfo : public VariableInfo {
+  /// Whether noescape was specified.
+  unsigned NoEscapeSpecified : 1;
+
+  /// Whether the this parameter has the 'noescape' attribute.
+  unsigned NoEscape : 1;
+
+  /// A biased RetainCountConventionKind, where 0 means "unspecified".
+  ///
+  /// Only relevant for out-parameters.
+  unsigned RawRetainCountConvention : 3;
+
+public:
+  ParamInfo() : VariableInfo(), NoEscapeSpecified(false), NoEscape(false),
+      RawRetainCountConvention() { }
+
+  Optional<bool> isNoEscape() const {
+    if (!NoEscapeSpecified) return None;
+    return NoEscape;
+  }
+  void setNoEscape(Optional<bool> noescape) {
+    if (noescape) {
+      NoEscapeSpecified = true;
+      NoEscape = *noescape;
+    } else {
+      NoEscapeSpecified = false;
+      NoEscape = false;
+    }
+  }
+
+  Optional<RetainCountConventionKind> getRetainCountConvention() const {
+    if (!RawRetainCountConvention)
+      return None;
+    return static_cast<RetainCountConventionKind>(RawRetainCountConvention - 1);
+  }
+  void setRetainCountConvention(Optional<RetainCountConventionKind> convention){
+    if (convention)
+      RawRetainCountConvention = static_cast<unsigned>(convention.getValue())+1;
+    else
+      RawRetainCountConvention = 0;
+    assert(getRetainCountConvention() == convention && "bitfield too small");
+  }
+
+  friend ParamInfo &operator|=(ParamInfo &lhs, const ParamInfo &rhs) {
+    static_cast<VariableInfo &>(lhs) |= rhs;
+    if (!lhs.NoEscapeSpecified && rhs.NoEscapeSpecified) {
+      lhs.NoEscapeSpecified = true;
+      lhs.NoEscape = rhs.NoEscape;
+    }
+    if (!lhs.RawRetainCountConvention)
+      lhs.RawRetainCountConvention = rhs.RawRetainCountConvention;
+    return lhs;
+  }
+
+  friend bool operator==(const ParamInfo &lhs, const ParamInfo &rhs) {
+    return static_cast<const VariableInfo &>(lhs) == rhs &&
+           lhs.NoEscapeSpecified == rhs.NoEscapeSpecified &&
+           lhs.NoEscape == rhs.NoEscape &&
+           lhs.RawRetainCountConvention == rhs.RawRetainCountConvention;
+  }
+
+  friend bool operator!=(const ParamInfo &lhs, const ParamInfo &rhs) {
+    return !(lhs == rhs);
+  }
+};
+
+/// A temporary reference to an Objective-C selector, suitable for
+/// referencing selector data on the stack.
+///
+/// Instances of this struct do not store references to any of the
+/// data they contain; it is up to the user to ensure that the data
+/// referenced by the identifier list persists.
+struct ObjCSelectorRef {
+  unsigned NumPieces;
+  ArrayRef<StringRef> Identifiers;
+};
+
+/// API notes for a function or method.
+class FunctionInfo : public CommonEntityInfo {
+private:
+  static unsigned const NullabilityKindMask = 0x3;
+  static unsigned const NullabilityKindSize = 2;
+
+public:
+  /// Whether the signature has been audited with respect to nullability.
+  /// If yes, we consider all types to be non-nullable unless otherwise noted.
+  /// If this flag is not set, the pointer types are considered to have
+  /// unknown nullability.
+  unsigned NullabilityAudited : 1;
+
+  /// Number of types whose nullability is encoded with the NullabilityPayload.
+  unsigned NumAdjustedNullable : 8;
+
+  /// A biased RetainCountConventionKind, where 0 means "unspecified".
+  unsigned RawRetainCountConvention : 3;
+
+  /// Stores the nullability of the return type and the parameters.
+  //  NullabilityKindSize bits are used to encode the nullability. The info
+  //  about the return type is stored at position 0, followed by the nullability
+  //  of the parameters.
+  uint64_t NullabilityPayload = 0;
+
+  /// The result type of this function, as a C type.
+  std::string ResultType;
+
+  /// The function parameters.
+  std::vector<ParamInfo> Params;
+
+  FunctionInfo()
+    : CommonEntityInfo(),
+      NullabilityAudited(false),
+      NumAdjustedNullable(0),
+      RawRetainCountConvention() { }
+
+  static unsigned getMaxNullabilityIndex() {
+    return ((sizeof(NullabilityPayload) * CHAR_BIT)/NullabilityKindSize);
+  }
+
+  void addTypeInfo(unsigned index, NullabilityKind kind) {
+    assert(index <= getMaxNullabilityIndex());
+    assert(static_cast<unsigned>(kind) < NullabilityKindMask);
+    NullabilityAudited = true;
+    if (NumAdjustedNullable < index + 1)
+      NumAdjustedNullable = index + 1;
+
+    // Mask the bits.
+    NullabilityPayload &= ~(NullabilityKindMask << (index * NullabilityKindSize));
+
+    // Set the value.
+    unsigned kindValue =
+      (static_cast<unsigned>(kind)) << (index * NullabilityKindSize);
+    NullabilityPayload |= kindValue;
+  }
+
+  /// Adds the return type info.
+  void addReturnTypeInfo(NullabilityKind kind) {
+    addTypeInfo(0, kind);
+  }
+
+  /// Adds the parameter type info.
+  void addParamTypeInfo(unsigned index, NullabilityKind kind) {
+    addTypeInfo(index + 1, kind);
+  }
+
+private:
+  NullabilityKind getTypeInfo(unsigned index) const {
+    assert(NullabilityAudited &&
+           "Checking the type adjustment on non-audited method.");
+    // If we don't have info about this parameter, return the default.
+    if (index > NumAdjustedNullable)
+      return NullabilityKind::NonNull;
+    return static_cast<NullabilityKind>(( NullabilityPayload
+                                          >> (index * NullabilityKindSize) )
+                                         & NullabilityKindMask);
+  }
+
+public:
+  NullabilityKind getParamTypeInfo(unsigned index) const {
+    return getTypeInfo(index + 1);
+  }
+  
+  NullabilityKind getReturnTypeInfo() const {
+    return getTypeInfo(0);
+  }
+
+  Optional<RetainCountConventionKind> getRetainCountConvention() const {
+    if (!RawRetainCountConvention)
+      return None;
+    return static_cast<RetainCountConventionKind>(RawRetainCountConvention - 1);
+  }
+  void setRetainCountConvention(Optional<RetainCountConventionKind> convention){
+    if (convention)
+      RawRetainCountConvention = static_cast<unsigned>(convention.getValue())+1;
+    else
+      RawRetainCountConvention = 0;
+    assert(getRetainCountConvention() == convention && "bitfield too small");
+  }
+
+  friend bool operator==(const FunctionInfo &lhs, const FunctionInfo &rhs) {
+    return static_cast<const CommonEntityInfo &>(lhs) == rhs &&
+           lhs.NullabilityAudited == rhs.NullabilityAudited &&
+           lhs.NumAdjustedNullable == rhs.NumAdjustedNullable &&
+           lhs.NullabilityPayload == rhs.NullabilityPayload &&
+           lhs.ResultType == rhs.ResultType &&
+           lhs.Params == rhs.Params &&
+           lhs.RawRetainCountConvention == rhs.RawRetainCountConvention;
+  }
+
+  friend bool operator!=(const FunctionInfo &lhs, const FunctionInfo &rhs) {
+    return !(lhs == rhs);
+  }
+
+};
+
+/// Describes API notes data for an Objective-C method.
+class ObjCMethodInfo : public FunctionInfo {
+public:
+  /// Whether this is a designated initializer of its class.
+  unsigned DesignatedInit : 1;
+
+  /// Whether this is a required initializer.
+  unsigned Required : 1;
+
+  ObjCMethodInfo()
+    : FunctionInfo(),
+      DesignatedInit(false),
+      Required(false) { }
+
+  friend bool operator==(const ObjCMethodInfo &lhs, const ObjCMethodInfo &rhs) {
+    return static_cast<const FunctionInfo &>(lhs) == rhs &&
+           lhs.DesignatedInit == rhs.DesignatedInit &&
+           lhs.Required == rhs.Required;
+  }
+
+  friend bool operator!=(const ObjCMethodInfo &lhs, const ObjCMethodInfo &rhs) {
+    return !(lhs == rhs);
+  }
+
+  void mergePropInfoIntoSetter(const ObjCPropertyInfo &pInfo);
+
+  void mergePropInfoIntoGetter(const ObjCPropertyInfo &pInfo);
+
+  /// Merge class-wide information into the given method.
+  friend ObjCMethodInfo &operator|=(ObjCMethodInfo &lhs,
+                                    const ObjCContextInfo &rhs) {
+    // Merge nullability.
+    if (!lhs.NullabilityAudited) {
+      if (auto nullable = rhs.getDefaultNullability()) {
+        lhs.NullabilityAudited = true;
+        lhs.addTypeInfo(0, *nullable);
+      }
+    }
+
+    return lhs;
+  }
+
+  void dump(llvm::raw_ostream &os);
+};
+
+/// Describes API notes data for a global variable.
+class GlobalVariableInfo : public VariableInfo {
+public:
+  GlobalVariableInfo() : VariableInfo() { }
+};
+
+/// Describes API notes data for a global function.
+class GlobalFunctionInfo : public FunctionInfo {
+public:
+  GlobalFunctionInfo() : FunctionInfo() { }
+};
+
+/// Describes API notes data for an enumerator.
+class EnumConstantInfo : public CommonEntityInfo {
+public:
+  EnumConstantInfo() : CommonEntityInfo() { }
+};
+
+/// The payload for an enum_extensibility attribute. This is a tri-state rather
+/// than just a boolean because the presence of the attribute indicates
+/// auditing.
+enum class EnumExtensibilityKind {
+  None,
+  Open,
+  Closed,
+};
+
+/// Describes API notes data for a tag.
+class TagInfo : public CommonTypeInfo {
+  unsigned HasFlagEnum : 1;
+  unsigned IsFlagEnum : 1;
+public:
+  Optional<EnumExtensibilityKind> EnumExtensibility;
+
+  Optional<bool> isFlagEnum() const {
+    if (HasFlagEnum)
+      return IsFlagEnum;
+    return None;
+  }
+  void setFlagEnum(Optional<bool> Value) {
+    if (Value.hasValue()) {
+      HasFlagEnum = true;
+      IsFlagEnum = Value.getValue();
+    } else {
+      HasFlagEnum = false;
+    }
+  }
+
+  TagInfo() : CommonTypeInfo(), HasFlagEnum(0), IsFlagEnum(0) { }
+
+  friend TagInfo &operator|=(TagInfo &lhs, const TagInfo &rhs) {
+    lhs |= static_cast<const CommonTypeInfo &>(rhs);
+    if (!lhs.HasFlagEnum && rhs.HasFlagEnum) {
+      lhs.HasFlagEnum = true;
+      lhs.IsFlagEnum = rhs.IsFlagEnum;
+    }
+    if (!lhs.EnumExtensibility.hasValue() && rhs.EnumExtensibility.hasValue())
+      lhs.EnumExtensibility = rhs.EnumExtensibility;
+    return lhs;
+  }
+
+  friend bool operator==(const TagInfo &lhs, const TagInfo &rhs) {
+    return static_cast<const CommonTypeInfo &>(lhs) == rhs &&
+           lhs.isFlagEnum() == rhs.isFlagEnum() &&
+           lhs.EnumExtensibility == rhs.EnumExtensibility;
+  }
+};
+
+/// The kind of a swift_wrapper/swift_newtype.
+enum class SwiftWrapperKind {
+  None,
+  Struct,
+  Enum
+};
+
+/// Describes API notes data for a typedef.
+class TypedefInfo : public CommonTypeInfo {
+public:
+  Optional<SwiftWrapperKind> SwiftWrapper;
+
+  TypedefInfo() : CommonTypeInfo() { }
+
+  friend TypedefInfo &operator|=(TypedefInfo &lhs, const TypedefInfo &rhs) {
+    lhs |= static_cast<const CommonTypeInfo &>(rhs);
+    if (!lhs.SwiftWrapper.hasValue() && rhs.SwiftWrapper.hasValue())
+      lhs.SwiftWrapper = rhs.SwiftWrapper;
+    return lhs;
+  }
+
+  friend bool operator==(const TypedefInfo &lhs, const TypedefInfo &rhs) {
+    return static_cast<const CommonTypeInfo &>(lhs) == rhs &&
+           lhs.SwiftWrapper == rhs.SwiftWrapper;
+  }
+};
+
+/// Descripts a series of options for a module
+struct ModuleOptions {
+  bool SwiftInferImportAsMember = false;
+};
+
+} // end namespace api_notes
+} // end namespace clang
+
+#endif // LLVM_CLANG_API_NOTES_TYPES_H
diff --git a/include/clang/AST/Attr.h b/include/clang/AST/Attr.h
index bbe320c28a..58566db60b 100644
--- a/include/clang/AST/Attr.h
+++ b/include/clang/AST/Attr.h
@@ -24,6 +24,7 @@
 #include "clang/Basic/Sanitizers.h"
 #include "clang/Basic/SourceLocation.h"
 #include "clang/Basic/VersionTuple.h"
+#include "llvm/ADT/PointerEmbeddedInt.h"
 #include "llvm/ADT/StringSwitch.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/raw_ostream.h"
diff --git a/include/clang/AST/AttrIterator.h b/include/clang/AST/AttrIterator.h
index 56807b4590..54aea4636a 100644
--- a/include/clang/AST/AttrIterator.h
+++ b/include/clang/AST/AttrIterator.h
@@ -115,6 +115,8 @@ public:
                          specific_attr_iterator Right) {
     return !(Left == Right);
   }
+
+  Iterator getCurrent() const { return Current; }
 };
 
 template <typename SpecificAttr, typename Container>
diff --git a/include/clang/AST/DeclObjC.h b/include/clang/AST/DeclObjC.h
index cef7d93537..f17db943b8 100644
--- a/include/clang/AST/DeclObjC.h
+++ b/include/clang/AST/DeclObjC.h
@@ -920,6 +920,11 @@ public:
     return Assign;
   }
 
+  /// Return true if this property has an explicitly specified getter name.
+  bool hasExplicitGetterName() const {
+    return (PropertyAttributes & OBJC_PR_getter);
+  }
+
   Selector getGetterName() const { return GetterName; }
   SourceLocation getGetterNameLoc() const { return GetterNameLoc; }
 
@@ -928,6 +933,11 @@ public:
     GetterNameLoc = Loc;
   }
 
+  /// Return true if this property has an explicitly specified setter name.
+  bool hasExplicitSetterName() const {
+    return (PropertyAttributes & OBJC_PR_setter);
+  }
+
   Selector getSetterName() const { return SetterName; }
   SourceLocation getSetterNameLoc() const { return SetterNameLoc; }
 
@@ -2748,17 +2758,25 @@ raw_ostream &operator<<(raw_ostream &OS, const ObjCImplementationDecl &ID);
 class ObjCCompatibleAliasDecl : public NamedDecl {
   /// Class that this is an alias of.
   ObjCInterfaceDecl *AliasedClass;
+  /// The location of the name of the referenced class.
+  SourceLocation AliasedClassLoc;
+  /// The location of the '@'.
+  SourceLocation AtLoc;
 
-  ObjCCompatibleAliasDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,
-                          ObjCInterfaceDecl* aliasedClass)
-      : NamedDecl(ObjCCompatibleAlias, DC, L, Id), AliasedClass(aliasedClass) {}
+  ObjCCompatibleAliasDecl(DeclContext *DC, SourceLocation NameLoc,
+                          IdentifierInfo *Id, ObjCInterfaceDecl *AliasedClass,
+                          SourceLocation AliasedClassLoc, SourceLocation AtLoc)
+      : NamedDecl(ObjCCompatibleAlias, DC, NameLoc, Id),
+        AliasedClass(AliasedClass), AliasedClassLoc(AliasedClassLoc),
+        AtLoc(AtLoc) {}
 
   void anchor() override;
 
 public:
-  static ObjCCompatibleAliasDecl *Create(ASTContext &C, DeclContext *DC,
-                                         SourceLocation L, IdentifierInfo *Id,
-                                         ObjCInterfaceDecl* aliasedClass);
+  static ObjCCompatibleAliasDecl *
+  Create(ASTContext &C, DeclContext *DC, SourceLocation NameLoc,
+         IdentifierInfo *Id, ObjCInterfaceDecl *AliasedClass,
+         SourceLocation AliasedClassLoc, SourceLocation AtLoc);
 
   static ObjCCompatibleAliasDecl *CreateDeserialized(ASTContext &C, 
                                                      unsigned ID);
@@ -2767,6 +2785,17 @@ public:
   ObjCInterfaceDecl *getClassInterface() { return AliasedClass; }
   void setClassInterface(ObjCInterfaceDecl *D) { AliasedClass = D; }
 
+  SourceLocation getClassInterfaceLoc() const { return AliasedClassLoc; }
+
+  void setClassInterfaceLoc(SourceLocation Loc) { AliasedClassLoc = Loc; }
+
+  SourceLocation getAtLoc() const { return AtLoc; }
+  void setAtLoc(SourceLocation Loc) { AtLoc = Loc; }
+
+  SourceRange getSourceRange() const override LLVM_READONLY {
+    return SourceRange(AtLoc, AtLoc);
+  }
+
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K == ObjCCompatibleAlias; }
 };
diff --git a/include/clang/AST/DeclTemplate.h b/include/clang/AST/DeclTemplate.h
index 7842d70971..dc495ba509 100644
--- a/include/clang/AST/DeclTemplate.h
+++ b/include/clang/AST/DeclTemplate.h
@@ -177,6 +177,14 @@ public:
     return SourceRange(TemplateLoc, RAngleLoc);
   }
 
+  void print(llvm::raw_ostream &Out, const PrintingPolicy &Policy,
+             const ASTContext &Context, unsigned Indentation = 0) const;
+
+  friend TrailingObjects;
+
+  template <size_t N, bool HasRequiresClause>
+  friend class FixedSizeTemplateParameterListStorage;
+
 public:
   // FIXME: workaround for MSVC 2013; remove when no longer needed
   using FixedSizeStorageOwner = TrailingObjects::FixedSizeStorageOwner;
diff --git a/include/clang/AST/DependentASTVisitor.h b/include/clang/AST/DependentASTVisitor.h
index e69de29bb2..4177344f0a 100644
--- a/include/clang/AST/DependentASTVisitor.h
+++ b/include/clang/AST/DependentASTVisitor.h
@@ -0,0 +1,91 @@
+//===--- DependentASTVisitor.h - Helper for dependent nodes -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//  This file defines the DependentASTVisitor RecursiveASTVisitor layer, which
+//  is responsible for visiting unresolved symbol references.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_AST_DEPENDENT_AST_VISITOR_H
+#define LLVM_CLANG_AST_DEPENDENT_AST_VISITOR_H
+
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/DeclTemplate.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/AST/Type.h"
+
+namespace clang {
+
+// TODO: Use in the indexer.
+template <typename Derived>
+class DependentASTVisitor : public RecursiveASTVisitor<Derived> {
+private:
+  bool visitDependentReference(
+      const Type *T, const DeclarationName &Name, SourceLocation Loc,
+      llvm::function_ref<bool(const NamedDecl *ND)> Filter) {
+    if (!T)
+      return true;
+    const TemplateSpecializationType *TST =
+        T->getAs<TemplateSpecializationType>();
+    if (!TST)
+      return true;
+    TemplateName TN = TST->getTemplateName();
+    const ClassTemplateDecl *TD =
+        dyn_cast_or_null<ClassTemplateDecl>(TN.getAsTemplateDecl());
+    if (!TD)
+      return true;
+    CXXRecordDecl *RD = TD->getTemplatedDecl();
+    if (!RD->hasDefinition())
+      return true;
+    RD = RD->getDefinition();
+    std::vector<const NamedDecl *> Symbols =
+        RD->lookupDependentName(Name, Filter);
+    // FIXME: Improve overload handling.
+    if (Symbols.size() != 1)
+      return true;
+    if (Loc.isInvalid())
+      return true;
+    return RecursiveASTVisitor<Derived>::getDerived()
+        .VisitDependentSymbolReference(Symbols[0], Loc);
+  }
+
+public:
+  bool VisitCXXDependentScopeMemberExpr(CXXDependentScopeMemberExpr *E) {
+    const DeclarationNameInfo &Info = E->getMemberNameInfo();
+    return visitDependentReference(
+        E->getBaseType().getTypePtrOrNull(), Info.getName(), Info.getLoc(),
+        [](const NamedDecl *D) { return D->isCXXInstanceMember(); });
+  }
+
+  bool VisitDependentScopeDeclRefExpr(DependentScopeDeclRefExpr *E) {
+    const DeclarationNameInfo &Info = E->getNameInfo();
+    const NestedNameSpecifier *NNS = E->getQualifier();
+    return visitDependentReference(
+        NNS->getAsType(), Info.getName(), Info.getLoc(),
+        [](const NamedDecl *D) { return !D->isCXXInstanceMember(); });
+  }
+
+  bool VisitDependentNameTypeLoc(DependentNameTypeLoc TL) {
+    const DependentNameType *DNT = TL.getTypePtr();
+    const NestedNameSpecifier *NNS = DNT->getQualifier();
+    DeclarationName Name(DNT->getIdentifier());
+    return visitDependentReference(
+        NNS->getAsType(), Name, TL.getNameLoc(),
+        [](const NamedDecl *ND) { return isa<TypeDecl>(ND); });
+  }
+
+  bool VisitDependentSymbolReference(const NamedDecl *Symbol,
+                                     SourceLocation SymbolNameLoc) {
+    return true;
+  }
+};
+
+} // end namespace clang
+
+#endif // LLVM_CLANG_AST_DEPENDENT_AST_VISITOR_H
diff --git a/include/clang/AST/NestedNameSpecifier.h b/include/clang/AST/NestedNameSpecifier.h
index e2cb45c36d..d6b9a06f56 100644
--- a/include/clang/AST/NestedNameSpecifier.h
+++ b/include/clang/AST/NestedNameSpecifier.h
@@ -225,6 +225,23 @@ public:
   /// in debugging.
   void dump(const LangOptions &LO) const;
   void dump() const;
+
+  /// \brief Compute the qualification required to get from the current context
+  /// (\p CurContext) to the target context (\p TargetContext).
+  ///
+  /// \param Context the AST context in which the qualification will be used.
+  ///
+  /// \param CurContext the context where an entity is being named, which is
+  /// typically based on the current scope.
+  ///
+  /// \param TargetContext the context in which the named entity actually
+  /// resides.
+  ///
+  /// \returns a nested name specifier that refers into the target context, or
+  /// NULL if no qualification is needed.
+  static NestedNameSpecifier *
+  getRequiredQualification(ASTContext &Context, const DeclContext *CurContext,
+                           const DeclContext *TargetContext);
 };
 
 /// \brief A C++ nested-name-specifier augmented with source location
diff --git a/include/clang/AST/PrettyPrinter.h b/include/clang/AST/PrettyPrinter.h
index e831b903cb..76f3ca4913 100644
--- a/include/clang/AST/PrettyPrinter.h
+++ b/include/clang/AST/PrettyPrinter.h
@@ -39,7 +39,7 @@ struct PrintingPolicy {
   /// \brief Create a default printing policy for the specified language.
   PrintingPolicy(const LangOptions &LO)
     : Indentation(2), SuppressSpecifiers(false),
-      SuppressTagKeyword(LO.CPlusPlus),
+      SupressStorageClassSpecifiers(false), SuppressTagKeyword(LO.CPlusPlus),
       IncludeTagDefinition(false), SuppressScope(false),
       SuppressUnwrittenScope(false), SuppressInitializers(false),
       ConstantArraySizeAsWritten(false), AnonymousTagLocations(true),
@@ -52,6 +52,7 @@ struct PrintingPolicy {
       Half(LO.Half), MSWChar(LO.MicrosoftExt && !LO.WChar),
       IncludeNewlines(true), MSVCFormatting(false),
       ConstantsAsWritten(false), SuppressImplicitBase(false),
+      UseStdFunctionForLambda(false),
       FullyQualifiedName(false) { }
 
   /// Adjust this printing policy for cases where it's known that we're
@@ -83,6 +84,10 @@ struct PrintingPolicy {
   /// "const int" type specifier and instead only print the "*y".
   bool SuppressSpecifiers : 1;
 
+  /// \brief Whether we should supress the printing of the actual storage class
+  /// specifiers for the given declaration.
+  bool SupressStorageClassSpecifiers : 1;
+
   /// Whether type printing should skip printing the tag keyword.
   ///
   /// This is used when printing the inner type of elaborated types,
@@ -222,6 +227,9 @@ struct PrintingPolicy {
   /// When true, don't print the implicit 'self' or 'this' expressions.
   bool SuppressImplicitBase : 1;
 
+  /// \brief Whether we should use std::function<...> for lambda record types.
+  bool UseStdFunctionForLambda : 1;
+
   /// When true, print the fully qualified name of function declarations.
   /// This is the opposite of SuppressScope and thus overrules it.
   bool FullyQualifiedName : 1;
diff --git a/include/clang/Basic/Attr.td b/include/clang/Basic/Attr.td
index 59f595e03c..000847faa5 100644
--- a/include/clang/Basic/Attr.td
+++ b/include/clang/Basic/Attr.td
@@ -87,6 +87,10 @@ def NonBitField : SubsetSubject<Field,
                                 [{!S->isBitField()}],
                                 "non-bit-field non-static data members">;
 
+def ObjCClassMethod : SubsetSubject<ObjCMethod,
+                                    [{!S->isInstanceMethod()}],
+                                    "Objective-C class methods">;
+
 def ObjCInstanceMethod : SubsetSubject<ObjCMethod,
                                        [{S->isInstanceMethod()}],
                                        "Objective-C instance methods">;
@@ -200,6 +204,9 @@ class VariadicEnumArgument<string name, string type, list<string> values,
   list<string> Enums = enums;
 }
 
+// Represents an attribute wrapped by another attribute.
+class AttrArgument<string name, bit opt = 0> : Argument<name, opt>;
+
 // This handles one spelling of an attribute.
 class Spelling<string name, string variety> {
   string Name = name;
@@ -680,6 +687,7 @@ def Availability : InheritableAttr {
              .Case("macos_app_extension", "macOS (App Extension)")
              .Case("tvos_app_extension", "tvOS (App Extension)")
              .Case("watchos_app_extension", "watchOS (App Extension)")
+             .Case("swift", "Swift")
              .Default(llvm::StringRef());
 }
 static llvm::StringRef getPlatformNameSourceSpelling(llvm::StringRef Platform) {
@@ -1495,6 +1503,12 @@ def ObjCBridgeRelated : InheritableAttr {
   let Documentation = [Undocumented];
 }
 
+def NSErrorDomain : Attr {
+  let Spellings = [GNU<"ns_error_domain">];
+  let Args = [IdentifierArgument<"ErrorDomain">];
+  let Documentation = [NSErrorDomainDocs];
+}
+
 def NSReturnsRetained : InheritableAttr {
   let Spellings = [Clang<"ns_returns_retained">];
 //  let Subjects = SubjectList<[ObjCMethod, ObjCProperty, Function]>;
@@ -1581,6 +1595,12 @@ def ObjCSubclassingRestricted : InheritableAttr {
   let Documentation = [ObjCSubclassingRestrictedDocs];
 }
 
+def ObjCCompleteDefinition : InheritableAttr {
+  let Spellings = [GNU<"objc_complete_definition">];
+  let Subjects = SubjectList<[ObjCInterface], ErrorDiag>;
+  let Documentation = [Undocumented];
+}
+
 def ObjCExplicitProtocolImpl : InheritableAttr {
   let Spellings = [Clang<"objc_protocol_requires_explicit_implementation">];
   let Subjects = SubjectList<[ObjCProtocol], ErrorDiag>;
@@ -1681,6 +1701,94 @@ def Regparm : TypeAttr {
   let Documentation = [RegparmDocs];
 }
 
+def SwiftBridge : Attr {
+  let Spellings = [GNU<"swift_bridge">];
+  let Subjects = SubjectList<[Tag, TypedefName, ObjCInterface, ObjCProtocol],
+                             ErrorDiag, "ExpectedType">;
+  let Args = [StringArgument<"SwiftType">];
+  let Documentation = [SwiftBridgeDocs];
+}
+
+def SwiftObjCMembers : Attr {
+  let Spellings = [GNU<"swift_objc_members">];
+  let Subjects = SubjectList<[ObjCInterface], ErrorDiag>;
+  let Documentation = [SwiftObjCMembersDocs];
+}
+
+def SwiftError : InheritableAttr {
+  let Spellings = [GCC<"swift_error">];
+  let Args = [EnumArgument<"Convention", "ConventionKind",
+               ["none", "nonnull_error", "null_result", "zero_result", "nonzero_result"],
+               ["None", "NonNullError", "NullResult", "ZeroResult", "NonZeroResult"]>];
+  let Subjects = SubjectList<[Function, ObjCMethod], ErrorDiag>;
+  let Documentation = [SwiftErrorDocs];
+}
+
+def SwiftName : InheritableAttr {
+  let Spellings = [GCC<"swift_name">];
+  let Args = [StringArgument<"Name">];
+  // Proper subject list disabled because of the custom error needed.
+  // Let's avoid merge conflicts for now.
+//  let Subjects = SubjectList<[EnumConstant, ObjCProtocol, ObjCClassMethod],
+//                             ErrorDiag, "ExpectedSwiftNameSubjects">;
+  let Documentation = [Undocumented];
+}
+
+def SwiftNewtype : InheritableAttr {
+  let Spellings = [GNU<"swift_newtype">, GNU<"swift_wrapper">];
+  let Subjects = SubjectList<[TypedefName], ErrorDiag, "ExpectedType">;
+  let Args = [EnumArgument<"NewtypeKind", "NewtypeKind",
+               ["struct", "enum"],
+               ["NK_Struct", "NK_Enum"]>];
+  let Documentation = [SwiftNewtypeDocs];
+}
+
+def SwiftPrivate : InheritableAttr {
+  let Spellings = [GCC<"swift_private">];
+  let Documentation = [Undocumented];
+}
+
+def SwiftImportAsNonGeneric : InheritableAttr {
+  // This attribute has no spellings as it is only ever created implicitly
+  // from API notes.
+  let Spellings = [];
+  let SemaHandler = 0;
+  let Documentation = [Undocumented];
+}
+
+def SwiftImportPropertyAsAccessors : InheritableAttr { 
+  // This attribute has no spellings as it is only ever created implicitly
+  // from API notes.
+  let Spellings = [];
+  let SemaHandler = 0;
+  let Documentation = [Undocumented];
+}
+
+def SwiftVersioned : Attr {
+  // This attribute has no spellings as it is only ever created implicitly
+  // from API notes.
+  let Spellings = [];
+  let Args = [VersionArgument<"Version">, AttrArgument<"AttrToAdd">,
+              BoolArgument<"IsReplacedByActive">];
+  let SemaHandler = 0;
+  let Documentation = [Undocumented];
+}
+
+def SwiftVersionedRemoval : Attr {
+  // This attribute has no spellings as it is only ever created implicitly
+  // from API notes.
+  let Spellings = [];
+  let Args = [VersionArgument<"Version">, UnsignedArgument<"RawKind">,
+              BoolArgument<"IsReplacedByActive">];
+  let SemaHandler = 0;
+  let Documentation = [Undocumented];
+  let AdditionalMembers = [{
+    attr::Kind getAttrKindToRemove() const {
+      return static_cast<attr::Kind>(getRawKind());
+    }
+  }];
+}
+
 def ReqdWorkGroupSize : InheritableAttr {
   // Does not have a [[]] spelling because it is an OpenCL-related attribute.
   let Spellings = [GNU<"reqd_work_group_size">];
diff --git a/include/clang/Basic/AttrDocs.td b/include/clang/Basic/AttrDocs.td
index ecff329c4c..4630df188a 100644
--- a/include/clang/Basic/AttrDocs.td
+++ b/include/clang/Basic/AttrDocs.td
@@ -2662,6 +2662,65 @@ where clause is one of the following:
   }];
 }
 
+def SwiftDocs : DocumentationCategory<"Controlling Swift Import"> {
+  let Content = [{
+Clang supports additional attributes for controlling how APIs are imported into Swift.
+  }];
+}
+
+def NSErrorDomainDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The ``ns_error_domain`` attribute indicates a global constant representing the error domain.
+  }];
+}
+
+def SwiftBridgeDocs : Documentation {
+  let Category = SwiftDocs;
+  let Content = [{
+The ``swift_bridge`` attribute indicates that the type to which the attribute appertains is bridged to the named Swift type. 
+  }];
+}
+
+def SwiftObjCMembersDocs : Documentation {
+  let Category = SwiftDocs;
+  let Content = [{
+The ``swift_objc_members`` attribute maps to the Swift ``@objcMembers`` attribute, which indicates that Swift members of this class, its subclasses, and all of the extensions thereof, will implicitly be exposed back to Objective-C.
+  }];
+}
+
+def SwiftErrorDocs : Documentation {
+  let Category = SwiftDocs;
+  let Heading = "swift_error";
+  let Content = [{
+The ``swift_error`` attribute controls whether a particular function (or Objective-C method) is imported into Swift as a throwing function, and if so, the dynamic convention it uses.
+
+All of these conventions except ``none`` require the function to have an error parameter.  Currently, the error parameter is always the last parameter of type ``NSError**`` or ``CFErrorRef*``.  Swift will remove the error parameter from the imported API, and dynamically will always pass a valid address initialized to a null pointer.
+
+* ``swift_error(none)`` means that the function should not be imported as throwing.  The error parameter and result type will be left alone.
+
+* ``swift_error(null_result)`` means that calls to the function should be considered to have thrown if they return a null value.  The return type must be a pointer type, and it will be imported into Swift with a non-optional type.  This is the default error convention for Objective-C methods that return pointers.
+
+* ``swift_error(zero_result)`` means that calls to the function should be considered to have thrown if they return a zero result.  The return type must be an integral type.  If the return type would have been imported as ``Bool``, it is instead imported as ``Void``.  This is the default error convention for Objective-C methods that return a type that would be imported as ``Bool``.
+
+* ``swift_error(nonzero_result)`` means that calls to the function should be considered to have thrown if they return a non-zero result.  The return type must be an integral type.  If the return type would have been imported as ``Bool``, it is instead imported as ``Void``.
+
+* ``swift_error(nonnull_error)`` means that calls to the function should be considered to have thrown if they leave a non-null error in the error parameter.  The return type is left unmodified.
+
+}];
+}
+
+def SwiftNewtypeDocs : Documentation {
+  let Category = SwiftDocs;
+  let Heading = "swift_newtype";
+  let Content = [{
+The ``swift_newtype`` attribute indicates that the typedef to which the attribute appertains is imported as a new Swift type of the typedef's name.
+* ``swift_newtype(struct)`` means that a Swift struct will be created for this typedef.
+* ``swift_newtype(enum)`` means that a Swift enum will be created for this typedef.
+  }];
+}
+
+
 def OMPDeclareTargetDocs : Documentation {
   let Category = DocCatFunction;
   let Heading = "#pragma omp declare target";
diff --git a/include/clang/Basic/Diagnostic.td b/include/clang/Basic/Diagnostic.td
index 52ccf350e6..2f083e90ee 100644
--- a/include/clang/Basic/Diagnostic.td
+++ b/include/clang/Basic/Diagnostic.td
@@ -141,4 +141,3 @@ include "DiagnosticParseKinds.td"
 include "DiagnosticRefactoringKinds.td"
 include "DiagnosticSemaKinds.td"
 include "DiagnosticSerializationKinds.td"
-
diff --git a/include/clang/Basic/DiagnosticCommonKinds.td b/include/clang/Basic/DiagnosticCommonKinds.td
index 82ca27b734..83f159969e 100644
--- a/include/clang/Basic/DiagnosticCommonKinds.td
+++ b/include/clang/Basic/DiagnosticCommonKinds.td
@@ -94,6 +94,12 @@ def remark_module_lock_failure : Remark<
   "could not acquire lock file for module '%0': %1">, InGroup<ModuleBuild>;
 def remark_module_lock_timeout : Remark<
   "timed out waiting to acquire lock file for module '%0'">, InGroup<ModuleBuild>;
+def err_module_shadowed : Error<
+  "import of shadowed module '%0'">;
+def err_module_lock_failure : Error<
+  "could not acquire lock file for module '%0': %1">, DefaultFatal;
+def err_module_lock_timeout : Error<
+  "timed out waiting to acquire lock file for module '%0'">, DefaultFatal;
 def err_module_cycle : Error<"cyclic dependency in module '%0': %1">, 
   DefaultFatal;
 def err_module_prebuilt : Error<
@@ -226,6 +232,11 @@ def note_mt_message : Note<"[rewriter] %0">;
 def warn_arcmt_nsalloc_realloc : Warning<"[rewriter] call returns pointer to GC managed memory; it will become unmanaged in ARC">;
 def err_arcmt_nsinvocation_ownership : Error<"NSInvocation's %0 is not safe to be used with an object with ownership other than __unsafe_unretained">;
 
+// API notes
+def err_apinotes_message : Error<"%0">;
+def warn_apinotes_message : Warning<"%0">, InGroup<DiagGroup<"apinotes">>;
+def note_apinotes_message : Note<"%0">;
+
 // OpenMP
 def err_omp_more_one_clause : Error<
   "directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2">;
diff --git a/include/clang/Basic/DiagnosticFrontendKinds.td b/include/clang/Basic/DiagnosticFrontendKinds.td
index b25181f256..1f67744a32 100644
--- a/include/clang/Basic/DiagnosticFrontendKinds.td
+++ b/include/clang/Basic/DiagnosticFrontendKinds.td
@@ -223,6 +223,10 @@ def err_modules_embed_file_not_found :
   Error<"file '%0' specified by '-fmodules-embed-file=' not found">,
   DefaultFatal;
 
+def remark_index_producing_module_file_data : Remark<"producing index data for "
+  "module file '%0'">,
+  InGroup<IndexStore>;
+
 def err_test_module_file_extension_version : Error<
   "test module file extension '%0' has different version (%1.%2) than expected "
   "(%3.%4)">;
diff --git a/include/clang/Basic/DiagnosticGroups.td b/include/clang/Basic/DiagnosticGroups.td
index 2d471f1fa5..b67e36d5c1 100644
--- a/include/clang/Basic/DiagnosticGroups.td
+++ b/include/clang/Basic/DiagnosticGroups.td
@@ -327,6 +327,7 @@ def MissingFieldInitializers : DiagGroup<"missing-field-initializers">;
 def ModuleBuild : DiagGroup<"module-build">;
 def ModuleConflict : DiagGroup<"module-conflict">;
 def ModuleFileExtension : DiagGroup<"module-file-extension">;
+def IndexStore : DiagGroup<"index-store">;
 def NewlineEOF : DiagGroup<"newline-eof">;
 def Nullability : DiagGroup<"nullability">;
 def NullabilityDeclSpec : DiagGroup<"nullability-declspec">;
@@ -435,6 +436,7 @@ def StringCompare : DiagGroup<"string-compare">;
 def StringPlusInt : DiagGroup<"string-plus-int">;
 def StringPlusChar : DiagGroup<"string-plus-char">;
 def StrncatSize : DiagGroup<"strncat-size">;
+def SwiftNameAttribute : DiagGroup<"swift-name-attribute">;
 def TautologicalTypeLimitCompare : DiagGroup<"tautological-type-limit-compare">;
 def TautologicalUnsignedZeroCompare : DiagGroup<"tautological-unsigned-zero-compare">;
 def TautologicalUnsignedEnumZeroCompare : DiagGroup<"tautological-unsigned-enum-zero-compare">;
diff --git a/include/clang/Basic/DiagnosticParseKinds.td b/include/clang/Basic/DiagnosticParseKinds.td
index 7936cdd96f..f61f536f39 100644
--- a/include/clang/Basic/DiagnosticParseKinds.td
+++ b/include/clang/Basic/DiagnosticParseKinds.td
@@ -1112,6 +1112,9 @@ def err_pragma_fp_scope : Error<
 def err_pragma_invalid_keyword : Error<
   "invalid argument; expected 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 or 'disable'">;
 
+// API notes.
+def err_type_unparsed : Error<"unparsed tokens following type">;
+
 // Pragma unroll support.
 def warn_pragma_unroll_cuda_value_in_parens : Warning<
   "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++">,
diff --git a/include/clang/Basic/DiagnosticRefactoringKinds.td b/include/clang/Basic/DiagnosticRefactoringKinds.td
index ee396b9307..b7c4b8f558 100644
--- a/include/clang/Basic/DiagnosticRefactoringKinds.td
+++ b/include/clang/Basic/DiagnosticRefactoringKinds.td
@@ -31,4 +31,29 @@ def err_refactor_extract_prohibited_expression : Error<"the selected "
 
 }
 
+// On github swift-clang only; to be upstreamed:
+
+let CategoryName = "Rename Issue" in {
+def err_rename_builtin_function : Error<"%0 is a builtin function that "
+  "cannot be renamed">;
+def err_rename_sys_header : Error<"%0 cannot be renamed because it is "
+  "declared in a system header">;
+def err_method_rename_override_sys_framework : Error<"method %0 cannot be "
+  "renamed because it overrides a method declared in a system framework">;
+def err_rename_external_source_symbol : Error<"%0 is declared in a %1 file; "
+  "rename can be initiated in a %1 file only">;
+}
+
+let CategoryName = "Refactoring Continuation Issue" in {
+
+def err_ref_continuation_missing_implementation : Error<
+  "no %select{implementation file|@implementation declaration}0 for the "
+  "selected %select{declaration|@interface}0 %1; please add one and run the "
+  "refactoring action again">;
+
+def err_implement_declared_methods_all_implemented : Error<
+  "the selected methods are already implemented">;
+
+}
+
 } // end of Refactoring diagnostics
diff --git a/include/clang/Basic/DiagnosticSemaKinds.td b/include/clang/Basic/DiagnosticSemaKinds.td
index ec624a0cc1..b78fe71615 100644
--- a/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/include/clang/Basic/DiagnosticSemaKinds.td
@@ -1218,6 +1218,12 @@ def warn_unimplemented_selector:  Warning<
   InGroup<Selector>, DefaultIgnore;
 def warn_unimplemented_protocol_method : Warning<
   "method %0 in protocol %1 not implemented">, InGroup<Protocol>;
+def warn_class_does_not_conform_protocol : Warning<
+  "%select{class|category}0 %1 does not conform to protocol"
+  "%plural{1: %3|2:s %3 and %4|3:s %3, %4 and %5|:s %3, %4, %5, ...}2">,
+  InGroup<Protocol>;
+def note_add_missing_protocol_stubs : Note<
+  "add stubs for missing protocol requirements">;
 def warn_multiple_selectors: Warning<
   "several methods with selector %0 of mismatched types are found "
   "for the @selector expression">,
@@ -2902,6 +2908,9 @@ def warn_mismatched_availability_override_unavail : Warning<
   InGroup<Availability>;
 def note_overridden_method : Note<
   "overridden method is here">;
+def warn_availability_swift_unavailable_deprecated_only : Warning<
+  "only 'unavailable' and 'deprecated' are supported for Swift availability">,
+  InGroup<Availability>;
 def note_protocol_method : Note<
   "protocol method is here">;
 
@@ -3276,6 +3285,9 @@ def warn_attribute_nonnull_no_pointers : Warning<
 def warn_attribute_nonnull_parm_no_args : Warning<
   "'nonnull' attribute when used on parameters takes no arguments">,
   InGroup<IgnoredAttributes>;
+def warn_attribute_noescape_non_pointer : Warning<
+  "'noescape' attribute ignored on parameter of non-pointer type %0">,
+  InGroup<IgnoredAttributes>;
 def note_declared_nonnull : Note<
   "declared %select{'returns_nonnull'|'nonnull'}0 here">;
 def warn_attribute_sentinel_named_arguments : Warning<
@@ -3401,6 +3413,68 @@ def err_objc_bridged_related_known_method : Error<
 def err_objc_attr_protocol_requires_definition : Error<
   "attribute %0 can only be applied to @protocol definitions, not forward declarations">;
 
+// Swift attributes
+def warn_attr_swift_name_decl_kind : Warning<
+  "%0 attribute cannot be applied to this declaration">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_function : Warning<
+  "parameter of %0 attribute must be a Swift function name string">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_function_no_prototype : Warning<
+  "%0 attribute can only be applied to function declarations with prototypes">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_context_name_invalid_identifier : Warning<
+  "%0 attribute has invalid identifier for context name">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_basename_invalid_identifier : Warning<
+  "%0 attribute has invalid identifier for base name">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_parameter_invalid_identifier : Warning<
+  "%0 attribute has invalid identifier for parameter name">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_missing_parameters : Warning<
+  "%0 attribute is missing parameter label clause">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_subscript_not_accessor : Warning<
+  "%0 attribute for 'subscript' must be a getter or setter">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_subscript_no_parameter : Warning<
+  "%0 attribute for 'subscript' must take at least one parameter">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_subscript_getter_newValue : Warning<
+  "%0 attribute for 'subscript' getter cannot take a 'newValue:' parameter">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_subscript_setter_no_newValue : Warning<
+  "%0 attribute for 'subscript' setter must take a 'newValue:' parameter">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_subscript_setter_multiple_newValues : Warning<
+  "%0 attribute for 'subscript' setter cannot take multiple 'newValue:' parameters">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_getter_parameters : Warning<
+  "%0 attribute for getter must not take any parameters besides 'self:'">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_setter_parameters : Warning<
+  "%0 attribute for setter must take one parameter for new value">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_multiple_selfs : Warning<
+  "%0 attribute cannot specify more than one 'self:' parameter">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_static_subscript : Warning<
+  "%0 attribute for 'subscript' must take a 'self:' parameter">,
+  InGroup<SwiftNameAttribute>;
+def warn_attr_swift_name_num_params : Warning<
+  "too %select{few|many}0 parameters in %1 attribute (expected %2; got %3)">,
+  InGroup<SwiftNameAttribute>;
+def err_attr_swift_error_no_error_parameter : Error<
+  "%0 attribute can only be applied to a %select{function|method}1 "
+  "with an error parameter">;
+def err_attr_swift_error_return_type : Error<
+  "%0 attribute with '%1' convention can only be applied to a "
+  "%select{function|method}2 returning %select{an integral type|a pointer}3">;
+def warn_swift_newtype_attribute_non_typedef : Warning<
+  "'swift_newtype' attribute may be put on a typedef only; "
+  "attribute is ignored">, InGroup<DiagGroup<"swift-newtype-attribute">>;
+
 // Function Parameter Semantic Analysis.
 def err_param_with_void_type : Error<"argument may not have 'void' type">;
 def err_void_only_param : Error<
@@ -8030,6 +8104,7 @@ def warn_missing_case : Warning<"%plural{"
   "3:enumeration values %1, %2, and %3 not handled in switch|"
   ":%0 enumeration values not handled in switch: %1, %2, %3...}0">,
   InGroup<Switch>;
+def note_fill_in_missing_cases : Note<"add missing switch cases">;
 
 def warn_unannotated_fallthrough : Warning<
   "unannotated fall-through between switch labels">,
@@ -8306,6 +8381,14 @@ def warn_nsconsumed_attribute_mismatch : Warning<
 def warn_nsreturns_retained_attribute_mismatch : Warning<
   "overriding method has mismatched ns_returns_%select{not_retained|retained}0"
   " attributes">, InGroup<NSReturnsMismatch>;
+
+def err_nserrordomain_not_tagdecl : Error<
+  "ns_error_domain attribute only valid on "
+  "%select{enums, structs, and unions|enums, structs, unions, and classes}0">;
+def err_nserrordomain_invalid_decl : Error<
+  "domain argument %0 does not refer to global constant">;
+def err_nserrordomain_requires_identifier : Error<
+  "domain argument must be an identifier">;
   
 def note_getter_unavailable : Note<
   "or because setter is declared here, but no getter method %0 is found">;
@@ -8588,6 +8671,13 @@ def ext_opencl_ext_vector_type_rgba_selector: ExtWarn<
   InGroup<OpenCLUnsupportedRGBA>;
 } // end of sema category
 
+let CategoryName = "API Notes Issue" in {
+
+def err_incompatible_replacement_type : Error<
+  "API notes replacement type %0 has a different size from original type %1">;
+
+}
+
 let CategoryName = "OpenMP Issue" in {
 // OpenMP support.
 def err_omp_expected_var_arg : Error<
diff --git a/include/clang/Basic/LangOptions.def b/include/clang/Basic/LangOptions.def
index c6ed256dd6..a7b4f7b18b 100644
--- a/include/clang/Basic/LangOptions.def
+++ b/include/clang/Basic/LangOptions.def
@@ -159,6 +159,7 @@ COMPATIBLE_LANGOPT(ModulesStrictDeclUse, 1, 0, "requiring declaration of module
 BENIGN_LANGOPT(ModulesErrorRecovery, 1, 1, "automatically importing modules as needed when performing error recovery")
 BENIGN_LANGOPT(ImplicitModules, 1, 1, "building modules that are not specified via -fmodule-file")
 COMPATIBLE_LANGOPT(ModulesLocalVisibility, 1, 0, "local submodule visibility")
+COMPATIBLE_LANGOPT(ModulesHashErrorDiags, 1, 0, "hash out diagnostic errors as part of the module hash")
 COMPATIBLE_LANGOPT(Optimize          , 1, 0, "__OPTIMIZE__ predefined macro")
 COMPATIBLE_LANGOPT(OptimizeSize      , 1, 0, "__OPTIMIZE_SIZE__ predefined macro")
 COMPATIBLE_LANGOPT(Static            , 1, 0, "__STATIC__ predefined macro (as opposed to __DYNAMIC__)")
@@ -268,6 +269,9 @@ VALUE_LANGOPT(VtorDispMode, 2, 1, "How many vtordisps to insert")
 LANGOPT(ApplePragmaPack, 1, 0, "Apple gcc-compatible #pragma pack handling")
 
 LANGOPT(RetainCommentsFromSystemHeaders, 1, 0, "retain documentation comments from system headers in the AST")
+LANGOPT(APINotes, 1, 0, "use external API notes")
+LANGOPT(APINotesModules, 1, 0, "use external API notes")
+LANGOPT(NeededByPCHOrCompilationUsesPCH, 1, 0, "compilation involves pch")
 
 LANGOPT(SanitizeAddressFieldPadding, 2, 0, "controls how aggressive is ASan "
                                            "field padding (0: none, 1:least "
diff --git a/include/clang/Basic/Module.h b/include/clang/Basic/Module.h
index 6631721e35..c5b1fb04b1 100644
--- a/include/clang/Basic/Module.h
+++ b/include/clang/Basic/Module.h
@@ -197,6 +197,9 @@ public:
   /// will be false to indicate that this (sub)module is not available.
   SmallVector<Requirement, 2> Requirements;
 
+  /// \brief A module with the same name that shadows this module.
+  Module *ShadowingModule = nullptr;
+
   /// \brief Whether this module is missing a feature from \c Requirements.
   unsigned IsMissingRequirement : 1;
 
@@ -230,6 +233,9 @@ public:
   /// \brief Whether this is an inferred submodule (module * { ... }).
   unsigned IsInferred : 1;
 
+  /// \brief Whether this is a module who has its swift_names inferred.
+  unsigned IsSwiftInferImportAsMember : 1;
+
   /// \brief Whether we should infer submodules for this module based on 
   /// the headers.
   ///
@@ -375,13 +381,20 @@ public:
   ///
   /// \param Target The target options used for the current translation unit.
   ///
-  /// \param Req If this module is unavailable, this parameter
-  /// will be set to one of the requirements that is not met for use of
-  /// this module.
+  /// \param Req If this module is unavailable because of a missing requirement,
+  /// this parameter will be set to one of the requirements that is not met for
+  /// use of this module.
+  ///
+  /// \param MissingHeader If this module is unavailable because of a missing
+  /// header, this parameter will be set to one of the missing headers.
+  ///
+  /// \param ShadowingModule If this module is unavailable because it is
+  /// shadowed, this parameter will be set to the shadowing module.
   bool isAvailable(const LangOptions &LangOpts, 
                    const TargetInfo &Target,
                    Requirement &Req,
-                   UnresolvedHeaderDirective &MissingHeader) const;
+                   UnresolvedHeaderDirective &MissingHeader,
+                   Module *&ShadowingModule) const;
 
   /// \brief Determine whether this module is a submodule.
   bool isSubModule() const { return Parent != nullptr; }
diff --git a/include/clang/Basic/SourceMgrAdapter.h b/include/clang/Basic/SourceMgrAdapter.h
index e69de29bb2..dd7b83f1a5 100644
--- a/include/clang/Basic/SourceMgrAdapter.h
+++ b/include/clang/Basic/SourceMgrAdapter.h
@@ -0,0 +1,85 @@
+//=== SourceMgrAdapter.h - SourceMgr to SourceManager Adapter ---*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file provides an adapter that maps diagnostics from llvm::SourceMgr
+// to Clang's SourceManager.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_SOURCEMGRADAPTER_H
+#define LLVM_CLANG_SOURCEMGRADAPTER_H
+
+#include "clang/Basic/SourceManager.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/Support/SourceMgr.h"
+#include <string>
+#include <utility>
+
+namespace clang {
+
+class DiagnosticsEngine;
+class FileEntry;
+
+/// An adapter that can be used to translate diagnostics from one or more
+/// llvm::SourceMgr instances to a ,
+class SourceMgrAdapter {
+  /// Clang source manager.
+  SourceManager &SrcMgr;
+
+  /// Clang diagnostics engine.
+  DiagnosticsEngine &Diag;
+
+  /// Diagnostic IDs for errors, warnings, and notes.
+  unsigned ErrorDiagID, WarningDiagID, NoteDiagID;
+
+  /// The default file to use when mapping buffers.
+  const FileEntry *DefaultFile;
+
+  /// A mapping from (LLVM source manager, buffer ID) pairs to the
+  /// corresponding file ID within the Clang source manager.
+  llvm::DenseMap<std::pair<const llvm::SourceMgr *, unsigned>, FileID>
+    FileIDMapping;
+
+  /// Diagnostic handler.
+  static void handleDiag(const llvm::SMDiagnostic &diag, void *context);
+
+public:
+  /// Create a new \c SourceMgr adaptor that maps to the given source
+  /// manager and diagnostics engine.
+  SourceMgrAdapter(SourceManager &srcMgr, DiagnosticsEngine &diag,
+                   unsigned errorDiagID, unsigned warningDiagID,
+                   unsigned noteDiagID, const FileEntry *defaultFile = nullptr);
+
+  ~SourceMgrAdapter();
+
+  /// Map a source location in the given LLVM source manager to its
+  /// corresponding location in the Clang source manager.
+  SourceLocation mapLocation(const llvm::SourceMgr &llvmSrcMgr,llvm::SMLoc loc);
+
+  /// Map a source range in the given LLVM source manager to its corresponding
+  /// range in the Clang source manager.
+  SourceRange mapRange(const llvm::SourceMgr &llvmSrcMgr, llvm::SMRange range);
+
+  /// Handle the given diagnostic from an LLVM source manager.
+  void handleDiag(const llvm::SMDiagnostic &diag);
+
+  /// Retrieve the diagnostic handler to use with the underlying SourceMgr.
+  llvm::SourceMgr::DiagHandlerTy getDiagHandler() {
+    return &SourceMgrAdapter::handleDiag;
+  }
+
+  /// Retrieve the context to use with the diagnostic handler produced by
+  /// \c getDiagHandler().
+  void *getDiagContext() { return this; }
+};
+
+
+} // end namespace clang
+
+#endif
diff --git a/include/clang/Basic/VersionTuple.h b/include/clang/Basic/VersionTuple.h
index da3b01903e..07315f008c 100644
--- a/include/clang/Basic/VersionTuple.h
+++ b/include/clang/Basic/VersionTuple.h
@@ -17,6 +17,7 @@
 
 #include "clang/Basic/LLVM.h"
 #include "llvm/ADT/Optional.h"
+#include "llvm/ADT/DenseMapInfo.h"
 #include <string>
 #include <tuple>
 
@@ -70,6 +71,9 @@ public:
     return Major == 0 && Minor == 0 && Subminor == 0 && Build == 0;
   }
 
+  /// Whether this is a non-empty version tuple.
+  explicit operator bool () const { return !empty(); }
+
   /// \brief Retrieve the major version number.
   unsigned getMajor() const { return Major; }
 
@@ -165,4 +169,35 @@ public:
 raw_ostream& operator<<(raw_ostream &Out, const VersionTuple &V);
 
 } // end namespace clang
+
+namespace llvm {
+  // Provide DenseMapInfo for version tuples.
+  template<>
+  struct DenseMapInfo<clang::VersionTuple> {
+    static inline clang::VersionTuple getEmptyKey() {
+      return clang::VersionTuple(0x7FFFFFFF);
+    }
+    static inline clang::VersionTuple getTombstoneKey() {
+      return clang::VersionTuple(0x7FFFFFFE);
+    }
+    static unsigned getHashValue(const clang::VersionTuple& value) {
+      unsigned result = value.getMajor();
+      if (auto minor = value.getMinor())
+        result = combineHashValue(result, *minor);
+      if (auto subminor = value.getSubminor())
+        result = combineHashValue(result, *subminor);
+      if (auto build = value.getBuild())
+        result = combineHashValue(result, *build);
+
+      return result;
+    }
+
+    static bool isEqual(const clang::VersionTuple &lhs,
+                        const clang::VersionTuple &rhs) {
+      return lhs == rhs;
+    }
+  };
+
+} // end namespace llvm
+
 #endif // LLVM_CLANG_BASIC_VERSIONTUPLE_H
diff --git a/include/clang/DirectoryWatcher/DirectoryWatcher.h b/include/clang/DirectoryWatcher/DirectoryWatcher.h
index e69de29bb2..09d17a9961 100644
--- a/include/clang/DirectoryWatcher/DirectoryWatcher.h
+++ b/include/clang/DirectoryWatcher/DirectoryWatcher.h
@@ -0,0 +1,47 @@
+//===- DirectoryWatcher.h - Listens for directory file changes --*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+/// \file
+/// \brief Utility class for listening for file system changes in a directory.
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_DIRECTORYWATCHER_DIRECTORYWATCHER_H
+#define LLVM_CLANG_DIRECTORYWATCHER_DIRECTORYWATCHER_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Index/IndexDataStore.h"
+#include <functional>
+#include <memory>
+#include <string>
+
+namespace clang {
+
+/// Provides notifications for file system changes in a directory.
+///
+/// Guarantees that the first time the directory is processed, the receiver will
+/// be invoked even if the directory is empty.
+class DirectoryWatcher : public index::AbstractDirectoryWatcher {
+  struct Implementation;
+  Implementation &Impl;
+
+  DirectoryWatcher();
+
+  DirectoryWatcher(const DirectoryWatcher&) = delete;
+  DirectoryWatcher &operator =(const DirectoryWatcher&) = delete;
+
+public:
+  ~DirectoryWatcher();
+
+  static std::unique_ptr<DirectoryWatcher>
+    create(StringRef Path, EventReceiver Receiver, bool waitInitialSync,
+           std::string &Error);
+};
+
+} // namespace clang
+
+#endif
diff --git a/include/clang/Driver/CC1Options.td b/include/clang/Driver/CC1Options.td
index 7dea88b62c..19d1e8788b 100644
--- a/include/clang/Driver/CC1Options.td
+++ b/include/clang/Driver/CC1Options.td
@@ -497,6 +497,8 @@ def fmodules_debuginfo :
 def fmodule_format_EQ : Joined<["-"], "fmodule-format=">,
   HelpText<"Select the container format for clang modules and PCH. "
            "Supported options are 'raw' and 'obj'.">;
+def fmodules_hash_error_diagnostics : Flag<["-"], "fmodules-hash-error-diagnostics">,
+  HelpText<"Use a separate module cache for modules compiled with conflicting -Werror options">;
 def ftest_module_file_extension_EQ :
   Joined<["-"], "ftest-module-file-extension=">,
   HelpText<"introduce a module file extension for testing purposes. "
diff --git a/include/clang/Driver/Job.h b/include/clang/Driver/Job.h
index b74b3b4b35..b45ae92f26 100644
--- a/include/clang/Driver/Job.h
+++ b/include/clang/Driver/Job.h
@@ -34,9 +34,11 @@ using llvm::opt::ArgStringList;
 struct CrashReportInfo {
   StringRef Filename;
   StringRef VFSPath;
+  StringRef IndexStorePath;
 
-  CrashReportInfo(StringRef Filename, StringRef VFSPath)
-      : Filename(Filename), VFSPath(VFSPath) {}
+  CrashReportInfo(StringRef Filename, StringRef VFSPath,
+                  StringRef IndexStorePath)
+      : Filename(Filename), VFSPath(VFSPath), IndexStorePath(IndexStorePath) {}
 };
 
 /// Command - An executable path/name and argument vector to
diff --git a/include/clang/Driver/Options.td b/include/clang/Driver/Options.td
index ad72aef3fc..79085f84f2 100644
--- a/include/clang/Driver/Options.td
+++ b/include/clang/Driver/Options.td
@@ -324,6 +324,13 @@ def objcmt_whitelist_dir_path: Joined<["-"], "objcmt-whitelist-dir-path=">, Flag
 def : Joined<["-"], "objcmt-white-list-dir-path=">, Flags<[CC1Option]>,
     Alias<objcmt_whitelist_dir_path>;
 
+def index_store_path : Separate<["-"], "index-store-path">, Flags<[CC1Option]>,
+  HelpText<"Enable indexing with the specified data store path">;
+def index_ignore_system_symbols : Flag<["-"], "index-ignore-system-symbols">, Flags<[CC1Option]>,
+  HelpText<"Ignore symbols from system headers">;
+def index_record_codegen_name : Flag<["-"], "index-record-codegen-name">, Flags<[CC1Option]>,
+  HelpText<"Record the codegen name for symbols">;
+
 // Make sure all other -ccc- options are rejected.
 def ccc_ : Joined<["-"], "ccc-">, Group<internal_Group>, Flags<[Unsupported]>;
 
@@ -721,6 +728,21 @@ def fno_profile_instr_use : Flag<["-"], "fno-profile-instr-use">,
 def fno_profile_use : Flag<["-"], "fno-profile-use">,
     Alias<fno_profile_instr_use>;
 
+def fapinotes : Flag<["-"], "fapinotes">, Group<f_clang_Group>,
+  Flags<[CC1Option]>, HelpText<"Enable external API notes support">;
+def fapinotes_modules : Flag<["-"], "fapinotes-modules">, Group<f_clang_Group>,
+  Flags<[CC1Option]>, HelpText<"Enable module-based external API notes support">;
+def fno_apinotes : Flag<["-"], "fno-apinotes">, Group<f_clang_Group>,
+  Flags<[CC1Option]>, HelpText<"Disable external API notes support">;
+def fno_apinotes_modules : Flag<["-"], "fno-apinotes-modules">, Group<f_clang_Group>,
+  Flags<[CC1Option]>, HelpText<"Disable module-based external API notes support">;
+def fapinotes_cache_path : Joined<["-"], "fapinotes-cache-path=">,
+  Group<i_Group>, Flags<[DriverOption]>, MetaVarName<"<directory>">,
+  HelpText<"Does nothing; API notes are no longer cached separately from modules">;
+def fapinotes_swift_version : Joined<["-"], "fapinotes-swift-version=">,
+  Group<f_clang_Group>, Flags<[CC1Option]>, MetaVarName<"<version>">,
+  HelpText<"Specify the Swift version to use when filtering API notes">;
+
 def fblocks : Flag<["-"], "fblocks">, Group<f_Group>, Flags<[CC1Option]>,
   HelpText<"Enable the 'blocks' language feature">;
 def fbootclasspath_EQ : Joined<["-"], "fbootclasspath=">, Group<f_Group>;
@@ -1669,6 +1691,8 @@ def help : Flag<["-", "--"], "help">, Flags<[CC1Option,CC1AsOption]>,
   HelpText<"Display available options">;
 def index_header_map : Flag<["-"], "index-header-map">, Flags<[CC1Option]>,
   HelpText<"Make the next included directory (-I or -F) an indexer header map">;
+def iapinotes_modules : JoinedOrSeparate<["-"], "iapinotes-modules">, Group<clang_i_Group>, Flags<[CC1Option]>,
+  HelpText<"Add directory to the API notes search path referenced by module name">, MetaVarName<"<directory>">;
 def idirafter : JoinedOrSeparate<["-"], "idirafter">, Group<clang_i_Group>, Flags<[CC1Option]>,
   HelpText<"Add directory to AFTER include search path">;
 def iframework : JoinedOrSeparate<["-"], "iframework">, Group<clang_i_Group>, Flags<[CC1Option]>,
diff --git a/include/clang/Edit/RefactoringFixits.h b/include/clang/Edit/RefactoringFixits.h
index e69de29bb2..bf8adb551e 100644
--- a/include/clang/Edit/RefactoringFixits.h
+++ b/include/clang/Edit/RefactoringFixits.h
@@ -0,0 +1,66 @@
+//===--- RefactoringFixits.h - Fixit producers for refactorings -*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_EDIT_REFACTORING_FIXITS_H
+#define LLVM_CLANG_EDIT_REFACTORING_FIXITS_H
+
+#include "clang/Basic/Diagnostic.h"
+#include "llvm/ADT/STLExtras.h"
+
+namespace clang {
+
+class ASTContext;
+class SwitchStmt;
+class EnumDecl;
+class ObjCContainerDecl;
+
+namespace edit {
+
+/**
+ * Generates the fix-its that perform the "add missing switch cases" refactoring
+ * operation.
+ */
+void fillInMissingSwitchEnumCases(
+    ASTContext &Context, const SwitchStmt *Switch, const EnumDecl *Enum,
+    const DeclContext *SwitchContext,
+    llvm::function_ref<void(const FixItHint &)> Consumer);
+
+/// Responsible for the fix-its that perform the
+/// "add missing protocol requirements" refactoring operation.
+namespace fillInMissingProtocolStubs {
+
+class FillInMissingProtocolStubsImpl;
+class FillInMissingProtocolStubs {
+  std::unique_ptr<FillInMissingProtocolStubsImpl> Impl;
+
+public:
+  FillInMissingProtocolStubs();
+  ~FillInMissingProtocolStubs();
+  FillInMissingProtocolStubs(FillInMissingProtocolStubs &&);
+  FillInMissingProtocolStubs &operator=(FillInMissingProtocolStubs &&);
+
+  /// Initiate the FillInMissingProtocolStubs edit.
+  ///
+  /// \returns true on Error.
+  bool initiate(ASTContext &Context, const ObjCContainerDecl *Container);
+  bool hasMissingRequiredMethodStubs();
+  void perform(ASTContext &Context,
+               llvm::function_ref<void(const FixItHint &)> Consumer);
+};
+
+void addMissingProtocolStubs(
+    ASTContext &Context, const ObjCContainerDecl *Container,
+    llvm::function_ref<void(const FixItHint &)> Consumer);
+
+} // end namespace fillInMissingProtocolStubs
+
+} // end namespace edit
+} // end namespace clang
+
+#endif // LLVM_CLANG_EDIT_REFACTORING_FIXITS_H
diff --git a/include/clang/Frontend/CompilerInstance.h b/include/clang/Frontend/CompilerInstance.h
index 90a9501475..cd3043d259 100644
--- a/include/clang/Frontend/CompilerInstance.h
+++ b/include/clang/Frontend/CompilerInstance.h
@@ -183,6 +183,12 @@ class CompilerInstance : public ModuleLoader {
   /// The list of active output files.
   std::list<OutputFile> OutputFiles;
 
+  /// \brief An optional callback function used to wrap all FrontendActions
+  /// produced to generate imported modules before they are executed.
+  std::function<std::unique_ptr<FrontendAction>
+    (const FrontendOptions &opts, std::unique_ptr<FrontendAction> action)>
+    GenModuleActionWrapper;
+
   CompilerInstance(const CompilerInstance &) = delete;
   void operator=(const CompilerInstance &) = delete;
 public:
@@ -303,6 +309,13 @@ public:
     return Invocation->getHeaderSearchOptsPtr();
   }
 
+  APINotesOptions &getAPINotesOpts() {
+    return Invocation->getAPINotesOpts();
+  }
+  const APINotesOptions &getAPINotesOpts() const {
+    return Invocation->getAPINotesOpts();
+  }
+
   LangOptions &getLangOpts() {
     return *Invocation->getLangOpts();
   }
@@ -796,6 +809,15 @@ public:
 
   bool lookupMissingImports(StringRef Name, SourceLocation TriggerLoc) override;
 
+  void setGenModuleActionWrapper(std::function<std::unique_ptr<FrontendAction>
+    (const FrontendOptions &Opts, std::unique_ptr<FrontendAction> Action)> Wrapper) {
+    GenModuleActionWrapper = Wrapper;
+  };
+
+  std::function<std::unique_ptr<FrontendAction>
+    (const FrontendOptions &Opts, std::unique_ptr<FrontendAction> Action)>
+  getGenModuleActionWrapper() const { return GenModuleActionWrapper; }
+
   void addDependencyCollector(std::shared_ptr<DependencyCollector> Listener) {
     DependencyCollectors.push_back(std::move(Listener));
   }
diff --git a/include/clang/Frontend/CompilerInvocation.h b/include/clang/Frontend/CompilerInvocation.h
index 8c4c932190..4d3449ff55 100644
--- a/include/clang/Frontend/CompilerInvocation.h
+++ b/include/clang/Frontend/CompilerInvocation.h
@@ -10,6 +10,7 @@
 #ifndef LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H_
 #define LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H_
 
+#include "clang/APINotes/APINotesOptions.h"
 #include "clang/Basic/DiagnosticOptions.h"
 #include "clang/Basic/FileSystemOptions.h"
 #include "clang/Basic/LangOptions.h"
@@ -113,6 +114,9 @@ class CompilerInvocation : public CompilerInvocationBase {
 
   MigratorOptions MigratorOpts;
   
+  /// Options controlling API notes.
+  APINotesOptions APINotesOpts;
+
   /// Options controlling IRgen and the backend.
   CodeGenOptions CodeGenOpts;
 
@@ -170,7 +174,7 @@ public:
   
   /// \brief Retrieve a module hash string that is suitable for uniquely 
   /// identifying the conditions under which the module was built.
-  std::string getModuleHash() const;
+  std::string getModuleHash(DiagnosticsEngine &Diags) const;
   
   /// @}
   /// @name Option Subgroups
@@ -184,6 +188,11 @@ public:
   const MigratorOptions &getMigratorOpts() const {
     return MigratorOpts;
   }
+
+  APINotesOptions &getAPINotesOpts() { return APINotesOpts; }
+  const APINotesOptions &getAPINotesOpts() const {
+    return APINotesOpts;
+  }
   
   CodeGenOptions &getCodeGenOpts() { return CodeGenOpts; }
   const CodeGenOptions &getCodeGenOpts() const {
diff --git a/include/clang/Frontend/FrontendOptions.h b/include/clang/Frontend/FrontendOptions.h
index 5192a3774c..c57db31018 100644
--- a/include/clang/Frontend/FrontendOptions.h
+++ b/include/clang/Frontend/FrontendOptions.h
@@ -259,6 +259,10 @@ public:
   std::string MTMigrateDir;
   std::string ARCMTMigrateReportOut;
 
+  std::string IndexStorePath;
+  unsigned IndexIgnoreSystemSymbols : 1;
+  unsigned IndexRecordCodegenName : 1;
+
   /// The input files and their types.
   std::vector<FrontendInputFile> Inputs;
 
@@ -336,8 +340,9 @@ public:
     SkipFunctionBodies(false), UseGlobalModuleIndex(true),
     GenerateGlobalModuleIndex(true), ASTDumpDecls(false), ASTDumpLookups(false),
     BuildingImplicitModule(false), ModulesEmbedAllFiles(false),
-    IncludeTimestamps(true), ARCMTAction(ARCMT_None),
-    ObjCMTAction(ObjCMT_None), ProgramAction(frontend::ParseSyntaxOnly)
+    IncludeTimestamps(true), ARCMTAction(ARCMT_None), ObjCMTAction(ObjCMT_None),
+    IndexIgnoreSystemSymbols(false), IndexRecordCodegenName(false),
+    ProgramAction(frontend::ParseSyntaxOnly)
   {}
 
   /// getInputKindForExtension - Return the appropriate input kind for a file
diff --git a/include/clang/Index/IndexDataStore.h b/include/clang/Index/IndexDataStore.h
index e69de29bb2..c6b3e40e39 100644
--- a/include/clang/Index/IndexDataStore.h
+++ b/include/clang/Index/IndexDataStore.h
@@ -0,0 +1,103 @@
+//===--- IndexDataStore.h - Index data store info -------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEX_INDEXDATASTORE_H
+#define LLVM_CLANG_INDEX_INDEXDATASTORE_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/Chrono.h"
+#include <functional>
+#include <memory>
+#include <string>
+#include <vector>
+
+namespace clang {
+namespace index {
+
+class AbstractDirectoryWatcher {
+public:
+  enum class EventKind {
+    /// A file was added.
+    Added,
+    /// A file was removed.
+    Removed,
+    /// A file was modified.
+    Modified,
+    /// The watched directory got deleted. No more events will follow.
+    DirectoryDeleted,
+  };
+
+  struct Event {
+    EventKind Kind;
+    std::string Filename;
+    llvm::sys::TimePoint<> ModTime;
+  };
+
+  typedef std::function<void(ArrayRef<Event> Events, bool isInitial)> EventReceiver;
+  typedef std::unique_ptr<AbstractDirectoryWatcher>(CreateFnTy)
+    (StringRef Path, EventReceiver Receiver, bool waitInitialSync, std::string &Error);
+
+  virtual ~AbstractDirectoryWatcher() {}
+};
+
+class IndexDataStore {
+public:
+  ~IndexDataStore();
+
+  static std::unique_ptr<IndexDataStore>
+    create(StringRef IndexStorePath, std::string &Error);
+
+  StringRef getFilePath() const;
+  bool foreachUnitName(bool sorted,
+                       llvm::function_ref<bool(StringRef unitName)> receiver);
+
+  static unsigned getFormatVersion();
+
+  enum class UnitEventKind {
+    Added,
+    Removed,
+    Modified,
+    /// The directory got deleted. No more events will follow.
+    DirectoryDeleted,
+  };
+  struct UnitEvent {
+    UnitEventKind Kind;
+    StringRef UnitName;
+    llvm::sys::TimePoint<> ModTime;
+  };
+  struct UnitEventNotification {
+    bool IsInitial;
+    ArrayRef<UnitEvent> Events;
+  };
+  typedef std::function<void(UnitEventNotification)> UnitEventHandler;
+
+  void setUnitEventHandler(UnitEventHandler Handler);
+  /// \returns true if an error occurred.
+  bool startEventListening(llvm::function_ref<AbstractDirectoryWatcher::CreateFnTy> createFn,
+                           bool waitInitialSync, std::string &Error);
+  void stopEventListening();
+
+  void discardUnit(StringRef UnitName);
+  void discardRecord(StringRef RecordName);
+
+  void purgeStaleData();
+
+private:
+  IndexDataStore(void *Impl) : Impl(Impl) {}
+
+  void *Impl; // An IndexDataStoreImpl.
+};
+
+} // namespace index
+} // namespace clang
+
+#endif
diff --git a/include/clang/Index/IndexDataStoreSymbolUtils.h b/include/clang/Index/IndexDataStoreSymbolUtils.h
index e69de29bb2..e1d982de09 100644
--- a/include/clang/Index/IndexDataStoreSymbolUtils.h
+++ b/include/clang/Index/IndexDataStoreSymbolUtils.h
@@ -0,0 +1,53 @@
+//===--- IndexDataStoreSymbolUtils.h - Utilities for indexstore symbols ---===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEX_INDEXDATASTORESYMBOLUTILS_H
+#define LLVM_CLANG_INDEX_INDEXDATASTORESYMBOLUTILS_H
+
+#include "indexstore/indexstore.h"
+#include "clang/Index/IndexSymbol.h"
+
+namespace clang {
+namespace index {
+
+/// Map an indexstore_symbol_kind_t to a SymbolKind, handling unknown values.
+SymbolKind getSymbolKind(indexstore_symbol_kind_t K);
+
+SymbolSubKind getSymbolSubKind(indexstore_symbol_subkind_t K);
+
+/// Map an indexstore_symbol_language_t to a SymbolLanguage, handling unknown
+/// values.
+SymbolLanguage getSymbolLanguage(indexstore_symbol_language_t L);
+
+/// Map an indexstore representation to a SymbolPropertySet, handling
+/// unknown values.
+SymbolPropertySet getSymbolProperties(uint64_t Props);
+
+/// Map an indexstore representation to a SymbolRoleSet, handling unknown
+/// values.
+SymbolRoleSet getSymbolRoles(uint64_t Roles);
+
+/// Map a SymbolLanguage to a indexstore_symbol_language_t.
+indexstore_symbol_kind_t getIndexStoreKind(SymbolKind K);
+
+indexstore_symbol_subkind_t getIndexStoreSubKind(SymbolSubKind K);
+
+/// Map a SymbolLanguage to a indexstore_symbol_language_t.
+indexstore_symbol_language_t getIndexStoreLang(SymbolLanguage L);
+
+/// Map a SymbolPropertySet to its indexstore representation.
+uint64_t getIndexStoreProperties(SymbolPropertySet Props);
+
+/// Map a SymbolRoleSet to its indexstore representation.
+uint64_t getIndexStoreRoles(SymbolRoleSet Roles);
+
+} // end namespace index
+} // end namespace clang
+
+#endif // LLVM_CLANG_INDEX_INDEXDATASTORESYMBOLUTILS_H
diff --git a/include/clang/Index/IndexRecordReader.h b/include/clang/Index/IndexRecordReader.h
index e69de29bb2..ef8edff2db 100644
--- a/include/clang/Index/IndexRecordReader.h
+++ b/include/clang/Index/IndexRecordReader.h
@@ -0,0 +1,109 @@
+//===--- IndexRecordReader.h - Index record deserialization ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEX_INDEXRECORDREADER_H
+#define LLVM_CLANG_INDEX_INDEXRECORDREADER_H
+
+#include "clang/Index/IndexSymbol.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
+#include <memory>
+
+namespace llvm {
+  class MemoryBuffer;
+}
+
+namespace clang {
+namespace index {
+
+struct IndexRecordDecl {
+  unsigned DeclID;
+  SymbolInfo SymInfo;
+  SymbolRoleSet Roles;
+  SymbolRoleSet RelatedRoles;
+  StringRef Name;
+  StringRef USR;
+  StringRef CodeGenName;
+};
+
+struct IndexRecordRelation {
+  SymbolRoleSet Roles;
+  const IndexRecordDecl *Dcl = nullptr;
+
+  IndexRecordRelation() = default;
+  IndexRecordRelation(SymbolRoleSet Roles, const IndexRecordDecl *Dcl)
+    : Roles(Roles), Dcl(Dcl) {}
+};
+
+struct IndexRecordOccurrence {
+  const IndexRecordDecl *Dcl;
+  SmallVector<IndexRecordRelation, 4> Relations;
+  SymbolRoleSet Roles;
+  unsigned Line;
+  unsigned Column;
+};
+
+class IndexRecordReader {
+  IndexRecordReader();
+
+public:
+  static std::unique_ptr<IndexRecordReader>
+    createWithRecordFilename(StringRef RecordFilename, StringRef StorePath,
+                             std::string &Error);
+  static std::unique_ptr<IndexRecordReader>
+    createWithFilePath(StringRef FilePath, std::string &Error);
+  static std::unique_ptr<IndexRecordReader>
+    createWithBuffer(std::unique_ptr<llvm::MemoryBuffer> Buffer,
+                     std::string &Error);
+
+  ~IndexRecordReader();
+
+  struct DeclSearchReturn {
+    bool AcceptDecl;
+    bool ContinueSearch;
+  };
+  typedef DeclSearchReturn(DeclSearchCheck)(const IndexRecordDecl &);
+
+  /// Goes through and passes record decls, after filtering using a \c Checker
+  /// function.
+  ///
+  /// Resulting decls can be used as filter for \c foreachOccurrence. This
+  /// allows allocating memory only for the record decls that the caller is
+  /// interested in.
+  bool searchDecls(llvm::function_ref<DeclSearchCheck> Checker,
+                   llvm::function_ref<void(const IndexRecordDecl *)> Receiver);
+
+  /// \param NoCache if true, avoids allocating memory for the decls.
+  /// Useful when the caller does not intend to keep \c IndexRecordReader
+  /// for more queries.
+  bool foreachDecl(bool NoCache,
+                   llvm::function_ref<bool(const IndexRecordDecl *)> Receiver);
+
+  /// \param DeclsFilter if non-empty indicates the list of decls that we want
+  /// to get occurrences for. An empty array indicates that we want occurrences
+  /// for all decls.
+  /// \param RelatedDeclsFilter Same as \c DeclsFilter but for related decls.
+  bool foreachOccurrence(ArrayRef<const IndexRecordDecl *> DeclsFilter,
+                         ArrayRef<const IndexRecordDecl *> RelatedDeclsFilter,
+              llvm::function_ref<bool(const IndexRecordOccurrence &)> Receiver);
+  bool foreachOccurrence(
+              llvm::function_ref<bool(const IndexRecordOccurrence &)> Receiver);
+
+  bool foreachOccurrenceInLineRange(unsigned lineStart, unsigned lineCount,
+              llvm::function_ref<bool(const IndexRecordOccurrence &)> Receiver);
+
+  struct Implementation;
+private:
+  Implementation &Impl;
+};
+
+} // namespace index
+} // namespace clang
+
+#endif
diff --git a/include/clang/Index/IndexRecordWriter.h b/include/clang/Index/IndexRecordWriter.h
index e69de29bb2..8a9720aa98 100644
--- a/include/clang/Index/IndexRecordWriter.h
+++ b/include/clang/Index/IndexRecordWriter.h
@@ -0,0 +1,102 @@
+//===--- IndexRecordWriter.h - Index record serialization -----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEX_INDEXRECORDWRITER_H
+#define LLVM_CLANG_INDEX_INDEXRECORDWRITER_H
+
+#include "clang/Index/IndexSymbol.h"
+#include "llvm/ADT/SmallString.h"
+
+namespace clang {
+namespace index {
+
+namespace writer {
+/// An opaque pointer to a declaration or other symbol used by the
+/// IndexRecordWriter to identify when two occurrences refer to the same symbol,
+/// and as a token for getting information about a symbol from the caller.
+typedef const void *OpaqueDecl;
+
+/// An indexer symbol suitable for serialization.
+///
+/// This includes all the information about the symbol that will be serialized
+/// except for roles, which are synthesized by looking at all the occurrences.
+///
+/// \seealso IndexRecordDecl
+/// \note this struct is generally accompanied by a buffer that owns the string
+/// storage.  It should not be stored permanently.
+struct Symbol {
+  SymbolInfo SymInfo;
+  StringRef Name;
+  StringRef USR;
+  StringRef CodeGenName;
+};
+
+/// An relation to an opaque symbol.
+/// \seealso IndexRecordRelation
+struct SymbolRelation {
+  OpaqueDecl RelatedSymbol;
+  SymbolRoleSet Roles;
+};
+
+typedef llvm::function_ref<Symbol(OpaqueDecl, SmallVectorImpl<char> &Scratch)>
+    SymbolWriterCallback;
+} // end namespace writer
+
+/// A language-independent utility for serializing index record files.
+///
+/// Internally, this class is a small state machine.  Users should first call
+/// beginRecord, and if the file does not already exist, then proceed to add
+/// all symbol occurrences (addOccurrence) and finally finish with endRecord.
+class IndexRecordWriter {
+  SmallString<64> RecordsPath; ///< The records directory path.
+  void *Record = nullptr;      ///< The state of the current record.
+public:
+  IndexRecordWriter(StringRef IndexPath);
+
+  enum class Result {
+    Success,
+    Failure,
+    AlreadyExists,
+  };
+
+  /// Begin writing a record for the file \p Filename with contents uniquely
+  /// identified by \p RecordHash.
+  ///
+  /// \param Filename the name of the file this is a record for.
+  /// \param RecordHash the unique hash of the record contents.
+  /// \param Error on failure, set to the error message.
+  /// \param RecordFile if non-null, this is set to the name of the record file.
+  ///
+  /// \returns Success if we should continue writing this record, AlreadyExists
+  /// if the record file has already been written, or Failure if there was an
+  /// error, in which case \p Error will be set.
+  Result beginRecord(StringRef Filename, llvm::hash_code RecordHash,
+                     std::string &Error, std::string *RecordFile = nullptr);
+
+  /// Finish writing the record file.
+  ///
+  /// \param Error on failure, set to the error message.
+  /// \param GetSymbolForDecl a callback mapping an writer::OpaqueDecl to its
+  /// writer::Symbol. This is how the language-specific symbol information is
+  /// provided to the IndexRecordWriter. The scratch parameter can be used for
+  /// any necessary storage.
+  ///
+  /// \return Success, or Failure and sets \p Error.
+  Result endRecord(std::string &Error,
+                   writer::SymbolWriterCallback GetSymbolForDecl);
+
+  /// Add an occurrence of the symbol \p D with the given \p Roles and location.
+  void addOccurrence(writer::OpaqueDecl D, SymbolRoleSet Roles, unsigned Line,
+                     unsigned Column, ArrayRef<writer::SymbolRelation> Related);
+};
+
+} // end namespace index
+} // end namespace clang
+
+#endif // LLVM_CLANG_INDEX_INDEXRECORDWRITER_H
diff --git a/include/clang/Index/IndexSymbol.h b/include/clang/Index/IndexSymbol.h
index 08f2839f37..ac9f6f5a41 100644
--- a/include/clang/Index/IndexSymbol.h
+++ b/include/clang/Index/IndexSymbol.h
@@ -54,6 +54,8 @@ enum class SymbolKind : uint8_t {
 
   Parameter,
   Using,
+
+  CommentTag,
 };
 
 enum class SymbolLanguage : uint8_t {
@@ -72,6 +74,26 @@ enum class SymbolSubKind : uint8_t {
   AccessorSetter,
   UsingTypename,
   UsingValue,
+
+  // Swift sub-kinds
+
+  SwiftAccessorWillSet,
+  SwiftAccessorDidSet,
+  SwiftAccessorAddressor,
+  SwiftAccessorMutableAddressor,
+
+  SwiftExtensionOfStruct,
+  SwiftExtensionOfClass,
+  SwiftExtensionOfEnum,
+  SwiftExtensionOfProtocol,
+
+  SwiftPrefixOperator,
+  SwiftPostfixOperator,
+  SwiftInfixOperator,
+
+  SwiftSubscript,
+  SwiftAssociatedType,
+  SwiftGenericTypeParam,
 };
 
 typedef uint8_t SymbolPropertySet;
diff --git a/include/clang/Index/IndexUnitReader.h b/include/clang/Index/IndexUnitReader.h
index e69de29bb2..ccd2dceb21 100644
--- a/include/clang/Index/IndexUnitReader.h
+++ b/include/clang/Index/IndexUnitReader.h
@@ -0,0 +1,85 @@
+//===--- IndexUnitReader.h - Index unit deserialization -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEX_INDEXUNITREADER_H
+#define LLVM_CLANG_INDEX_INDEXUNITREADER_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/Chrono.h"
+
+namespace clang {
+namespace index {
+
+class IndexUnitReader {
+public:
+  enum class DependencyKind {
+    Unit,
+    Record,
+    File,
+  };
+
+  ~IndexUnitReader();
+
+  static std::unique_ptr<IndexUnitReader>
+    createWithUnitFilename(StringRef UnitFilename, StringRef StorePath,
+                           std::string &Error);
+  static std::unique_ptr<IndexUnitReader>
+    createWithFilePath(StringRef FilePath, std::string &Error);
+
+  static Optional<llvm::sys::TimePoint<>>
+    getModificationTimeForUnit(StringRef UnitFilename, StringRef StorePath,
+                               std::string &Error);
+
+  StringRef getProviderIdentifier() const;
+  StringRef getProviderVersion() const;
+
+  llvm::sys::TimePoint<> getModificationTime() const;
+  StringRef getWorkingDirectory() const;
+  StringRef getOutputFile() const;
+  StringRef getSysrootPath() const;
+  StringRef getMainFilePath() const;
+  StringRef getModuleName() const;
+  StringRef getTarget() const;
+  bool hasMainFile() const;
+  bool isSystemUnit() const;
+  bool isModuleUnit() const;
+  bool isDebugCompilation() const;
+
+  struct DependencyInfo {
+    DependencyKind Kind;
+    bool IsSystem;
+    StringRef UnitOrRecordName;
+    StringRef FilePath;
+    StringRef ModuleName;
+    size_t FileSize;
+    time_t ModTime;
+  };
+  struct IncludeInfo {
+    StringRef SourcePath;
+    unsigned SourceLine;
+    StringRef TargetPath;
+  };
+  /// Unit dependencies are provided ahead of record ones, record ones
+  /// ahead of the file ones.
+  bool foreachDependency(llvm::function_ref<bool(const DependencyInfo &Info)> Receiver);
+
+  bool foreachInclude(llvm::function_ref<bool(const IncludeInfo &Info)> Receiver);
+
+private:
+  IndexUnitReader(void *Impl) : Impl(Impl) {}
+
+  void *Impl; // An IndexUnitReaderImpl.
+};
+
+} // namespace index
+} // namespace clang
+
+#endif
diff --git a/include/clang/Index/IndexUnitWriter.h b/include/clang/Index/IndexUnitWriter.h
index e69de29bb2..40d2c112ec 100644
--- a/include/clang/Index/IndexUnitWriter.h
+++ b/include/clang/Index/IndexUnitWriter.h
@@ -0,0 +1,140 @@
+//===--- IndexUnitWriter.h - Index unit serialization ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEX_INDEXUNITWRITER_H
+#define LLVM_CLANG_INDEX_INDEXUNITWRITER_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/DenseSet.h"
+#include "llvm/ADT/SmallString.h"
+#include <string>
+#include <vector>
+
+namespace llvm {
+  class BitstreamWriter;
+}
+
+namespace clang {
+  class FileEntry;
+  class FileManager;
+
+namespace index {
+
+namespace writer {
+/// An opaque pointer to a module used by the IndexUnitWriter to associate
+/// record and file dependencies with a module, and as a token for getting
+/// information about the module from the caller.
+typedef const void *OpaqueModule;
+
+/// Module info suitable for serialization.
+///
+/// This is used for top-level modules and sub-modules.
+struct ModuleInfo {
+  /// Full, dot-separate, module name.
+  StringRef Name;
+};
+
+typedef llvm::function_ref<ModuleInfo(OpaqueModule, SmallVectorImpl<char> &Scratch)>
+    ModuleInfoWriterCallback;
+} // end namespace writer
+
+class IndexUnitWriter {
+  FileManager &FileMgr;
+  SmallString<64> UnitsPath;
+  std::string ProviderIdentifier;
+  std::string ProviderVersion;
+  std::string OutputFile;
+  std::string ModuleName;
+  const FileEntry *MainFile;
+  bool IsSystemUnit;
+  bool IsModuleUnit;
+  bool IsDebugCompilation;
+  std::string TargetTriple;
+  std::string WorkDir;
+  std::string SysrootPath;
+  std::function<writer::ModuleInfo(writer::OpaqueModule,
+                            SmallVectorImpl<char> &Scratch)> GetInfoForModuleFn;
+  struct FileInclude {
+    int Index;
+    unsigned Line;
+  };
+  struct FileEntryData {
+    const FileEntry *File;
+    bool IsSystem;
+    int ModuleIndex;
+    std::vector<FileInclude> Includes;
+  };
+  std::vector<FileEntryData> Files;
+  std::vector<writer::OpaqueModule> Modules;
+  llvm::DenseMap<const FileEntry *, int> IndexByFile;
+  llvm::DenseMap<writer::OpaqueModule, int> IndexByModule;
+  llvm::DenseSet<const FileEntry *> SeenASTFiles;
+  struct RecordOrUnitData {
+    std::string Name;
+    int FileIndex;
+    int ModuleIndex;
+    bool IsSystem;
+  };
+  std::vector<RecordOrUnitData> Records;
+  std::vector<RecordOrUnitData> ASTFileUnits;
+
+public:
+  /// \param MainFile the main file for a compiled source file. This should be
+  /// null for PCH and module units.
+  /// \param IsSystem true for system module units, false otherwise.
+  IndexUnitWriter(FileManager &FileMgr,
+                  StringRef StorePath,
+                  StringRef ProviderIdentifier, StringRef ProviderVersion,
+                  StringRef OutputFile,
+                  StringRef ModuleName,
+                  const FileEntry *MainFile,
+                  bool IsSystem,
+                  bool IsModuleUnit,
+                  bool IsDebugCompilation,
+                  StringRef TargetTriple,
+                  StringRef SysrootPath,
+                  writer::ModuleInfoWriterCallback GetInfoForModule);
+  ~IndexUnitWriter();
+
+  int addFileDependency(const FileEntry *File, bool IsSystem,
+                        writer::OpaqueModule Mod);
+  void addRecordFile(StringRef RecordFile, const FileEntry *File, bool IsSystem,
+                     writer::OpaqueModule Mod);
+  void addASTFileDependency(const FileEntry *File, bool IsSystem,
+                            writer::OpaqueModule Mod, bool withoutUnitName = false);
+  void addUnitDependency(StringRef UnitFile, const FileEntry *File, bool IsSystem,
+                         writer::OpaqueModule Mod);
+  bool addInclude(const FileEntry *Source, unsigned Line, const FileEntry *Target);
+
+  bool write(std::string &Error);
+
+  void getUnitNameForOutputFile(StringRef FilePath, SmallVectorImpl<char> &Str);
+  void getUnitPathForOutputFile(StringRef FilePath, SmallVectorImpl<char> &Str);
+  /// If the unit file exists and \p timeCompareFilePath is provided, it will
+  /// return true if \p timeCompareFilePath is older than the unit file.
+  Optional<bool> isUnitUpToDateForOutputFile(StringRef FilePath,
+                                             Optional<StringRef> TimeCompareFilePath,
+                                             std::string &Error);
+  static void getUnitNameForAbsoluteOutputFile(StringRef FilePath, SmallVectorImpl<char> &Str);
+  static bool initIndexDirectory(StringRef StorePath, std::string &Error);
+
+private:
+  class PathStorage;
+  int addModule(writer::OpaqueModule Mod);
+  void writeUnitInfo(llvm::BitstreamWriter &Stream, PathStorage &PathStore);
+  void writeDependencies(llvm::BitstreamWriter &Stream, PathStorage &PathStore);
+  void writeIncludes(llvm::BitstreamWriter &Stream, PathStorage &PathStore);
+  void writePaths(llvm::BitstreamWriter &Stream, PathStorage &PathStore);
+  void writeModules(llvm::BitstreamWriter &Stream);
+};
+
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/include/clang/Index/IndexingAction.h b/include/clang/Index/IndexingAction.h
index fb703be4e5..6095e67a0b 100644
--- a/include/clang/Index/IndexingAction.h
+++ b/include/clang/Index/IndexingAction.h
@@ -13,13 +13,17 @@
 #include "clang/Basic/LLVM.h"
 #include "llvm/ADT/ArrayRef.h"
 #include <memory>
+#include <string>
 
 namespace clang {
   class ASTContext;
   class ASTReader;
   class ASTUnit;
+  class CompilerInstance;
   class Decl;
   class FrontendAction;
+  class FrontendOptions;
+  class Module;
 
 namespace serialization {
   class ModuleFile;
@@ -27,6 +31,7 @@ namespace serialization {
 
 namespace index {
   class IndexDataConsumer;
+  class IndexUnitWriter;
 
 struct IndexingOptions {
   enum class SystemSymbolFilterKind {
@@ -40,6 +45,19 @@ struct IndexingOptions {
   bool IndexFunctionLocals = false;
 };
 
+struct RecordingOptions {
+  enum class IncludesRecordingKind {
+    None,
+    UserOnly, // only record includes inside non-system files.
+    All,
+  };
+
+  std::string DataDirPath;
+  bool RecordSymbolCodeGenName = false;
+  bool RecordSystemDependencies = true;
+  IncludesRecordingKind RecordIncludes = IncludesRecordingKind::UserOnly;
+};
+
 /// \param WrappedAction another frontend action to wrap over or null.
 std::unique_ptr<FrontendAction>
 createIndexingAction(std::shared_ptr<IndexDataConsumer> DataConsumer,
@@ -58,6 +76,18 @@ void indexModuleFile(serialization::ModuleFile &Mod, ASTReader &Reader,
                      std::shared_ptr<IndexDataConsumer> DataConsumer,
                      IndexingOptions Opts);
 
+/// \param WrappedAction another frontend action to wrap over or null.
+std::unique_ptr<FrontendAction>
+createIndexDataRecordingAction(const FrontendOptions &FEOpts,
+                               std::unique_ptr<FrontendAction> WrappedAction);
+
+/// Checks if the unit file exists for the module file, if it doesn't it
+/// generates index data for it.
+///
+/// \returns true if the index data were generated, false otherwise.
+bool emitIndexDataForModuleFile(const Module *Mod, const CompilerInstance &CI,
+                                IndexUnitWriter &ParentUnitWriter);
+
 } // namespace index
 } // namespace clang
 
diff --git a/include/clang/Lex/Lexer.h b/include/clang/Lex/Lexer.h
index d58849654c..5c612ae449 100644
--- a/include/clang/Lex/Lexer.h
+++ b/include/clang/Lex/Lexer.h
@@ -174,15 +174,17 @@ public:
   /// from.  Currently this is only used by _Pragma handling.
   SourceLocation getFileLoc() const { return FileLoc; }
 
-private:
   /// Lex - Return the next token in the file.  If this is the end of file, it
   /// return the tok::eof token.  This implicitly involves the preprocessor.
   bool Lex(Token &Result);
 
-public:
   /// isPragmaLexer - Returns true if this Lexer is being used to lex a pragma.
   bool isPragmaLexer() const { return Is_PragmaLexer; }
 
+  /// Note that this Lexer is being used to lex a pragma, or something like it
+  /// that has simple end-of-file behavior.
+  void setIsPragmaLexer(bool value) { Is_PragmaLexer = value; }
+
 private:
   /// IndirectLex - An indirect call to 'Lex' that can be invoked via
   ///  the PreprocessorLexer interface.
@@ -507,6 +509,14 @@ public:
                                          const LangOptions &LangOpts,
                                          bool SkipTrailingWhitespaceAndNewLine);
 
+  /// \brief Returns the source location of the token that comes after the
+  /// token located at the given location \p Loc (excluding any comments and
+  /// whitespace). The returned source location will be invalid if the location
+  /// is inside a macro.
+  static SourceLocation
+  findNextTokenLocationAfterTokenAt(SourceLocation Loc, const SourceManager &SM,
+                                    const LangOptions &LangOpts);
+
   /// \brief Returns true if the given character could appear in an identifier.
   static bool isIdentifierBodyChar(char c, const LangOptions &LangOpts);
 
diff --git a/include/clang/Lex/ModuleMap.h b/include/clang/Lex/ModuleMap.h
index 41ed8e49b6..0c0b9dcb76 100644
--- a/include/clang/Lex/ModuleMap.h
+++ b/include/clang/Lex/ModuleMap.h
@@ -95,7 +95,7 @@ class ModuleMap {
   /// transferred if/when we create an enclosing module.
   std::unique_ptr<Module> PendingGlobalModule;
 
-  /// \brief The top-level modules that are known.
+  /// \brief The unshadowed top-level modules that are known.
   llvm::StringMap<Module *> Modules;
 
   /// \brief The number of modules we have created in total.
@@ -195,6 +195,15 @@ private:
   /// header.
   llvm::DenseMap<const DirectoryEntry *, Module *> UmbrellaDirs;
 
+  /// \brief A generation counter that is used to test whether modules of the
+  /// same name may shadow or are illegal redefintions.
+  ///
+  /// Modules from earlier scopes may shadow modules from later ones.
+  /// Modules from the same scope may not have the same name.
+  unsigned CurrentModuleScopeID = 0;
+
+  llvm::DenseMap<Module *, unsigned> ModuleScopeIDs;
+
   /// \brief The set of attributes that can be attached to a module.
   struct Attributes {
     /// \brief Whether this is a system module.
@@ -206,6 +215,9 @@ private:
     /// \brief Whether this is an exhaustive set of configuration macros.
     unsigned IsExhaustive : 1;
 
+    /// \brief Whether this is a module who has its swift_names inferred.
+    unsigned IsSwiftInferImportAsMember : 1;
+
     /// \brief Whether files in this module can only include non-modular headers
     /// and headers from used modules.
     unsigned NoUndeclaredIncludes : 1;
@@ -502,6 +514,24 @@ public:
   Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,
                                bool IsSystem, Module *Parent);
 
+  /// \brief Create a new top-level module that is shadowed by
+  /// \p ShadowingModule.
+  Module *createShadowedModule(StringRef Name, bool IsFramework,
+                               Module *ShadowingModule);
+
+  /// \brief Creates a new declaration scope for module names, allowing
+  /// previously defined modules to shadow definitions from the new scope.
+  ///
+  /// \note Module names from earlier scopes will shadow names from the new
+  /// scope, which is the opposite of how shadowing works for variables.
+  void finishModuleDeclarationScope() { CurrentModuleScopeID += 1; }
+
+  bool mayShadowNewModule(Module *ExistingModule) {
+    assert(!ExistingModule->Parent && "expected top-level module");
+    assert(ModuleScopeIDs.count(ExistingModule) && "unknown module");
+    return ModuleScopeIDs[ExistingModule] < CurrentModuleScopeID;
+  }
+
   /// \brief Retrieve the module map file containing the definition of the given
   /// module.
   ///
diff --git a/include/clang/Parse/Parser.h b/include/clang/Parse/Parser.h
index a606d78530..1f3e5e43ad 100644
--- a/include/clang/Parse/Parser.h
+++ b/include/clang/Parse/Parser.h
@@ -2388,6 +2388,14 @@ private:
                                         SourceLocation ScopeLoc,
                                         AttributeList::Syntax Syntax);
 
+  void ParseSwiftNewtypeAttribute(IdentifierInfo &SwiftNewtype,
+                                  SourceLocation SwiftNewtypeLoc,
+                                  ParsedAttributes &attrs,
+                                  SourceLocation *endLoc,
+                                  IdentifierInfo *ScopeName,
+                                  SourceLocation ScopeLoc,
+                                  AttributeList::Syntax Syntax);
+
   void ParseAttributeWithTypeArg(IdentifierInfo &AttrName,
                                  SourceLocation AttrNameLoc,
                                  ParsedAttributes &Attrs,
@@ -2814,7 +2822,19 @@ private:
   //===--------------------------------------------------------------------===//
   // C++11/G++: Type Traits [Type-Traits.html in the GCC manual]
   ExprResult ParseTypeTrait();
-  
+
+  /// Parse the given string as a type.
+  ///
+  /// This is a dangerous utility function currently employed only by API notes.
+  /// It is not a general entry-point for safely parsing types from strings.
+  ///
+  /// \param typeStr The string to be parsed as a type.
+  /// \param context The name of the context in which this string is being
+  /// parsed, which will be used in diagnostics.
+  /// \param includeLoc The location at which this parse was triggered.
+  TypeResult parseTypeFromString(StringRef typeStr, StringRef context,
+                                 SourceLocation includeLoc);
+
   //===--------------------------------------------------------------------===//
   // Embarcadero: Arary and Expression Traits
   ExprResult ParseArrayTypeTrait();
diff --git a/include/clang/Sema/Sema.h b/include/clang/Sema/Sema.h
index 055d14f2d0..d44de64e34 100644
--- a/include/clang/Sema/Sema.h
+++ b/include/clang/Sema/Sema.h
@@ -28,6 +28,7 @@
 #include "clang/AST/PrettyPrinter.h"
 #include "clang/AST/StmtCXX.h"
 #include "clang/AST/TypeLoc.h"
+#include "clang/APINotes/APINotesManager.h"
 #include "clang/AST/TypeOrdering.h"
 #include "clang/Basic/ExpressionTraits.h"
 #include "clang/Basic/LangOptions.h"
@@ -55,6 +56,7 @@
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/TinyPtrVector.h"
 #include <deque>
+#include <functional>
 #include <memory>
 #include <string>
 #include <vector>
@@ -317,6 +319,7 @@ public:
   ASTConsumer &Consumer;
   DiagnosticsEngine &Diags;
   SourceManager &SourceMgr;
+  api_notes::APINotesManager APINotes;
 
   /// \brief Flag indicating whether or not to collect detailed statistics.
   bool CollectStats;
@@ -639,6 +642,10 @@ public:
     OpaqueParser = P;
   }
 
+  /// \brief Callback to the parser to parse a type expressed as a string.
+  std::function<TypeResult(StringRef, StringRef, SourceLocation)>
+    ParseTypeFromStringCallback;
+
   class DelayedDiagnostics;
 
   class DelayedDiagnosticsState {
@@ -1528,6 +1535,24 @@ public:
     }
   };
 
+  /// Do a check to make sure \p Name looks like a legal swift_name
+  /// attribute for the decl \p D. Raise a diagnostic if the name is invalid
+  /// for the given declaration.
+  ///
+  /// For a function, this will validate a compound Swift name,
+  /// e.g. <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>,
+  /// and the function will output the number of parameter names, and whether
+  /// this is a single-arg initializer.
+  ///
+  /// For a type, enum constant, property, or variable declaration, this will
+  /// validate either a simple identifier, or a qualified
+  /// <code>context.identifier</code> name.
+  ///
+  /// \returns true if the name is a valid swift name for \p D, false otherwise.
+  bool DiagnoseSwiftName(Decl *D, StringRef Name,
+                         SourceLocation ArgLoc,
+                         IdentifierInfo *AttrName);
+
 private:
   bool RequireCompleteTypeImpl(SourceLocation Loc, QualType T,
                                TypeDiagnoser *Diagnoser);
@@ -1948,6 +1973,8 @@ public:
   ParmVarDecl *BuildParmVarDeclForTypedef(DeclContext *DC,
                                           SourceLocation Loc,
                                           QualType T);
+  QualType adjustParameterTypeForObjCAutoRefCount(QualType T,
+                                                  SourceLocation Loc);
   ParmVarDecl *CheckParameter(DeclContext *DC, SourceLocation StartLoc,
                               SourceLocation NameLoc, IdentifierInfo *Name,
                               QualType T, TypeSourceInfo *TSInfo,
@@ -2439,6 +2466,9 @@ public:
                                 unsigned AttrSpellingListIndex);
   OptimizeNoneAttr *mergeOptimizeNoneAttr(Decl *D, SourceRange Range,
                                           unsigned AttrSpellingListIndex);
+  SwiftNameAttr *mergeSwiftNameAttr(Decl *D, SourceRange Range,
+                                    StringRef Name, bool Override,
+                                    unsigned AttrSpellingListIndex);
   InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D, SourceRange Range,
                                                 IdentifierInfo *Ident,
                                                 unsigned AttrSpellingListIndex);
@@ -3316,6 +3346,12 @@ public:
 
   void checkUnusedDeclAttributes(Declarator &D);
 
+  /// Map any API notes provided for this declaration to attributes on the
+  /// declaration.
+  ///
+  /// Triggered by declaration-attribute processing.
+  void ProcessAPINotes(Decl *D);
+
   /// Determine if type T is a valid subject for a nonnull and similar
   /// attributes. By default, we look through references (the behavior used by
   /// nonnull), but if the second parameter is true, then we treat a reference
@@ -3371,11 +3407,16 @@ public:
   /// \param allowArrayTypes Whether to accept nullability specifiers on an
   /// array type (e.g., because it will decay to a pointer).
   ///
+  /// \param overrideExisting Whether to override an existing, locally-specified
+  /// nullability specifier rather than complaining about the conflict.
+  ///
   /// \returns true if nullability cannot be applied, false otherwise.
   bool checkNullabilityTypeSpecifier(QualType &type, NullabilityKind nullability,
                                      SourceLocation nullabilityLoc,
                                      bool isContextSensitive,
-                                     bool allowArrayTypes);
+                                     bool allowArrayTypes,
+                                     bool implicit,
+                                     bool overrideExisting = false);
 
   /// \brief Stmt attributes - this routine is the top level dispatcher.
   StmtResult ProcessStmtAttributes(Stmt *Stmt, AttributeList *Attrs,
@@ -8224,6 +8265,12 @@ public:
     RTC_Unknown
   };
 
+  /// Check whether the declared result type of the given Objective-C
+  /// method declaration is compatible with the method's class.
+  ResultTypeCompatibilityKind
+  checkRelatedResultTypeCompatibility(const ObjCMethodDecl *Method,
+                                      const ObjCInterfaceDecl *CurrentClass);
+
   void CheckObjCMethodOverrides(ObjCMethodDecl *ObjCMethod,
                                 ObjCInterfaceDecl *CurrentClass,
                                 ResultTypeCompatibilityKind RTC);
@@ -10509,6 +10556,7 @@ public:
 
   /// The struct behind the CFErrorRef pointer.
   RecordDecl *CFError = nullptr;
+  bool isCFError(RecordDecl *D);
 
   /// Retrieve the identifier "NSError".
   IdentifierInfo *getNSErrorIdent();
diff --git a/include/clang/Tooling/Refactor/IndexerQuery.h b/include/clang/Tooling/Refactor/IndexerQuery.h
index e69de29bb2..b90f6d7130 100644
--- a/include/clang/Tooling/Refactor/IndexerQuery.h
+++ b/include/clang/Tooling/Refactor/IndexerQuery.h
@@ -0,0 +1,312 @@
+//===--- IndexerQuery.h - A set of indexer query interfaces ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the base indexer queries that can be used with
+// refactoring continuations.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_INDEXER_QUERY_H
+#define LLVM_CLANG_TOOLING_REFACTOR_INDEXER_QUERY_H
+
+#include "clang/Tooling/Refactor/RefactoringOperationState.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/Error.h"
+#include <vector>
+
+namespace clang {
+namespace tooling {
+namespace indexer {
+
+/// Represents an abstract indexer query.
+class IndexerQuery {
+public:
+  const char *BaseUID;
+  const char *NameUID;
+
+  IndexerQuery(const char *BaseUID, const char *NameUID)
+      : BaseUID(BaseUID), NameUID(NameUID) {}
+  virtual ~IndexerQuery() {}
+
+  virtual void invalidateTUSpecificState() = 0;
+
+  /// Checks if this query was satisfied. Returns true if it wasn't and reports
+  /// appropriate errors.
+  virtual bool verify(ASTContext &) { return false; }
+
+  // Mainly used for testing.
+  static llvm::Error loadResultsFromYAML(StringRef Source,
+                                         ArrayRef<IndexerQuery *> Queries);
+
+  static bool classof(const IndexerQuery *) { return true; }
+};
+
+/// An abstract AST query that can produce an AST unit in which the refactoring
+/// continuation will run.
+class ASTProducerQuery : public IndexerQuery {
+  static const char *BaseUIDString;
+
+public:
+  /// Deriving AST producer queries can redefine this type to generate custom
+  /// results that are then passed into the refactoring continuations.
+  using ResultTy = void;
+
+  ASTProducerQuery(const char *NameUID)
+      : IndexerQuery(BaseUIDString, NameUID) {}
+
+  static bool classof(const IndexerQuery *Q) {
+    return Q->BaseUID == BaseUIDString;
+  }
+};
+
+/// A query that finds a file that contains/should contain the implementation of
+/// some declaration.
+class ASTUnitForImplementationOfDeclarationQuery final
+    : public ASTProducerQuery {
+  static const char *NameUIDString;
+
+  const Decl *D;
+  PersistentFileID Result;
+
+public:
+  ASTUnitForImplementationOfDeclarationQuery(const Decl *D)
+      : ASTProducerQuery(NameUIDString), D(D), Result("") {}
+
+  using ResultTy = FileID;
+
+  const Decl *getDecl() const { return D; }
+
+  void invalidateTUSpecificState() override { D = nullptr; }
+
+  void setResult(PersistentFileID File) { Result = std::move(File); }
+
+  bool verify(ASTContext &Context) override;
+
+  const PersistentFileID &getResult() const { return Result; }
+
+  static bool classof(const IndexerQuery *D) {
+    return D->NameUID == NameUIDString;
+  }
+};
+
+/// Returns an indexer query that will allow a refactoring continuation to run
+/// in an AST unit that contains a file that should contain the implementation
+/// of the given declaration \p D.
+///
+/// The continuation function will receive \c FileID that corresponds to the
+/// implementation file. The indexer can decide which file should be used as an
+/// implementation of a declaration based on a number of different heuristics.
+/// It does not guarantee that the file will actually have any declarations that
+/// correspond to the implementation of \p D yet, as the indexer may decide to
+/// point to a file that it thinks will have the implementation declarations in
+/// the future.
+std::unique_ptr<ASTUnitForImplementationOfDeclarationQuery>
+fileThatShouldContainImplementationOf(const Decl *D);
+
+/// A declaration predicate operates.
+struct DeclPredicate {
+  const char *Name;
+
+  DeclPredicate(const char *Name) : Name(Name) {}
+
+  bool operator==(const DeclPredicate &P) const {
+    return StringRef(Name) == P.Name;
+  }
+  bool operator!=(const DeclPredicate &P) const {
+    return StringRef(Name) != P.Name;
+  }
+};
+
+/// Represents a declaration predicate that will evaluate to either 'true' or
+/// 'false' in an indexer query.
+struct BoolDeclPredicate {
+  DeclPredicate Predicate;
+  bool IsInverted;
+
+  BoolDeclPredicate(DeclPredicate Predicate, bool IsInverted = false)
+      : Predicate(Predicate), IsInverted(IsInverted) {}
+
+  BoolDeclPredicate operator!() const {
+    return BoolDeclPredicate(Predicate, /*IsInverted=*/!IsInverted);
+  }
+};
+
+namespace detail {
+
+/// AST-like representation for decl predicates.
+class DeclPredicateNode {
+public:
+  const char *NameUID;
+  DeclPredicateNode(const char *NameUID) : NameUID(NameUID) {}
+
+  virtual ~DeclPredicateNode() { }
+
+  static std::unique_ptr<DeclPredicateNode>
+  create(const DeclPredicate &Predicate);
+  static std::unique_ptr<DeclPredicateNode>
+  create(const BoolDeclPredicate &Predicate);
+
+  static bool classof(const DeclPredicateNode *) { return true; }
+};
+
+class DeclPredicateNodePredicate : public DeclPredicateNode {
+  static const char *NameUIDString;
+
+  DeclPredicate Predicate;
+
+public:
+  DeclPredicateNodePredicate(const DeclPredicate &Predicate)
+      : DeclPredicateNode(NameUIDString), Predicate(Predicate) {}
+
+  const DeclPredicate &getPredicate() const { return Predicate; }
+
+  static bool classof(const DeclPredicateNode *P) {
+    return P->NameUID == NameUIDString;
+  }
+};
+
+class DeclPredicateNotPredicate : public DeclPredicateNode {
+  static const char *NameUIDString;
+
+  std::unique_ptr<DeclPredicateNode> Child;
+
+public:
+  DeclPredicateNotPredicate(std::unique_ptr<DeclPredicateNode> Child)
+      : DeclPredicateNode(NameUIDString), Child(std::move(Child)) {}
+
+  const DeclPredicateNode &getChild() const { return *Child; }
+
+  static bool classof(const DeclPredicateNode *P) {
+    return P->NameUID == NameUIDString;
+  }
+};
+
+} // end namespace detail
+
+enum class QueryBoolResult {
+  Unknown,
+  Yes,
+  No,
+};
+
+// FIXME: Check that 'T' is either a PersistentDeclRef<> or a Decl *.
+template <typename T> struct Indexed {
+  T Decl;
+  // FIXME: Generalize better in the new refactoring engine.
+  QueryBoolResult IsNotDefined;
+
+  Indexed(T Decl, QueryBoolResult IsNotDefined = QueryBoolResult::Unknown)
+      : Decl(Decl), IsNotDefined(IsNotDefined) {}
+
+  Indexed(Indexed<T> &&Other) = default;
+  Indexed &operator=(Indexed<T> &&Other) = default;
+  Indexed(const Indexed<T> &Other) = default;
+  Indexed &operator=(const Indexed<T> &Other) = default;
+
+  /// True iff the declaration is not defined in the entire project.
+  bool isNotDefined() const {
+    // FIXME: This is hack. Need a better system in the new engine.
+    return IsNotDefined == QueryBoolResult::Yes;
+  }
+};
+
+/// Transforms one set of declarations into another using some predicate.
+class DeclarationsQuery : public IndexerQuery {
+  static const char *BaseUIDString;
+
+  std::vector<const Decl *> Input;
+  std::unique_ptr<detail::DeclPredicateNode> Predicate;
+
+protected:
+  std::vector<Indexed<PersistentDeclRef<Decl>>> Output;
+
+public:
+  DeclarationsQuery(std::vector<const Decl *> Input,
+                    std::unique_ptr<detail::DeclPredicateNode> Predicate)
+      : IndexerQuery(BaseUIDString, nullptr), Input(std::move(Input)),
+        Predicate(std::move(Predicate)) {
+    assert(!this->Input.empty() && "empty declarations list!");
+  }
+
+  ArrayRef<const Decl *> getInputs() const { return Input; }
+
+  void invalidateTUSpecificState() override { Input.clear(); }
+
+  bool verify(ASTContext &Context) override;
+
+  void setOutput(std::vector<Indexed<PersistentDeclRef<Decl>>> Output) {
+    this->Output = Output;
+  }
+
+  const detail::DeclPredicateNode &getPredicateNode() const {
+    return *Predicate;
+  }
+
+  static bool classof(const IndexerQuery *Q) {
+    return Q->BaseUID == BaseUIDString;
+  }
+};
+
+/// The \c DeclEntity class acts as a proxy for the entity that represents a
+/// declaration in the indexer. It defines a set of declaration predicates that
+/// can be used in indexer queries.
+struct DeclEntity {
+  /// The indexer will evaluate this predicate to 'true' when a certain
+  /// declaration has a corresponding definition.
+  BoolDeclPredicate isDefined() const {
+    return BoolDeclPredicate("decl.isDefined");
+  }
+};
+
+template <typename T>
+class ManyToManyDeclarationsQuery final
+    : public std::enable_if<std::is_base_of<Decl, T>::value,
+                            DeclarationsQuery>::type {
+public:
+  ManyToManyDeclarationsQuery(
+      ArrayRef<const T *> Input,
+      std::unique_ptr<detail::DeclPredicateNode> Predicate)
+      : DeclarationsQuery(std::vector<const Decl *>(Input.begin(), Input.end()),
+                          std::move(Predicate)) {}
+
+  std::vector<Indexed<PersistentDeclRef<T>>> getOutput() const {
+    std::vector<Indexed<PersistentDeclRef<T>>> Results;
+    for (const auto &Ref : DeclarationsQuery::Output)
+      Results.push_back(Indexed<PersistentDeclRef<T>>(
+          PersistentDeclRef<T>(Ref.Decl.USR), Ref.IsNotDefined));
+    return Results;
+  }
+};
+
+/// Returns an indexer query that will pass a filtered list of declarations to
+/// a refactoring continuation.
+///
+/// The filtering is done based on predicates that are available on the \c
+/// DeclEntity types. For example, you can use the following invocation to
+/// find a set of declarations that are defined in the entire project:
+///
+/// \code
+/// filter({ MyDeclA, MyDeclB }, [] (const DeclEntity &D) { return D.isDefined()
+/// })
+/// \endcode
+template <typename T>
+std::unique_ptr<ManyToManyDeclarationsQuery<T>>
+filter(ArrayRef<const T *> Declarations,
+       BoolDeclPredicate (*Fn)(const DeclEntity &),
+       typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+           nullptr) {
+  return llvm::make_unique<ManyToManyDeclarationsQuery<T>>(
+      Declarations, detail::DeclPredicateNode::create(Fn(DeclEntity())));
+}
+
+} // end namespace indexer
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_INDEXER_QUERY_H
diff --git a/include/clang/Tooling/Refactor/RefactoringActionFinder.h b/include/clang/Tooling/Refactor/RefactoringActionFinder.h
index e69de29bb2..395d78c0f9 100644
--- a/include/clang/Tooling/Refactor/RefactoringActionFinder.h
+++ b/include/clang/Tooling/Refactor/RefactoringActionFinder.h
@@ -0,0 +1,60 @@
+//===--- RefactoringActionFinder.h - Clang refactoring library ------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Provides methods to find the refactoring actions that can be
+/// performed at specific locations / source ranges in a translation unit.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_ACTION_FINDER_H
+#define LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_ACTION_FINDER_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Tooling/Refactor/RefactoringActions.h"
+#include "llvm/ADT/StringSet.h"
+#include <vector>
+
+namespace clang {
+
+class NamedDecl;
+class ASTContext;
+
+namespace tooling {
+
+/// Contains a set of a refactoring actions.
+struct RefactoringActionSet {
+  /// A set of refactoring actions that can be performed at some specific
+  /// location in a source file.
+  ///
+  /// The actions in the action set are ordered by their priority: most
+  /// important actions are placed before the less important ones.
+  std::vector<RefactoringActionType> Actions;
+
+  RefactoringActionSet() {}
+
+  RefactoringActionSet(RefactoringActionSet &&) = default;
+  RefactoringActionSet &operator=(RefactoringActionSet &&) = default;
+};
+
+/// \brief Returns a \c RefactoringActionSet that contains the set of actions
+/// that can be performed at the given location.
+RefactoringActionSet findActionSetAt(SourceLocation Loc,
+                                     SourceRange SelectionRange,
+                                     ASTContext &Context);
+
+/// \brief Returns a set of USRs that correspond to the given declaration.
+llvm::StringSet<> findSymbolsUSRSet(const NamedDecl *FoundDecl,
+                                    ASTContext &Context);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_ACTION_FINDER_H
diff --git a/include/clang/Tooling/Refactor/RefactoringActions.def b/include/clang/Tooling/Refactor/RefactoringActions.def
index e69de29bb2..f5c2f668e0 100644
--- a/include/clang/Tooling/Refactor/RefactoringActions.def
+++ b/include/clang/Tooling/Refactor/RefactoringActions.def
@@ -0,0 +1,62 @@
+//===--- RefactoringActions.def - The list of refactoring actions  --------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef REFACTORING_ACTION
+#define REFACTORING_ACTION(Name, Spelling)
+#endif
+
+#ifndef REFACTORING_SUB_ACTION
+#define REFACTORING_SUB_ACTION(Name, Parent, Spelling) \
+  REFACTORING_ACTION(Parent##_##Name, Spelling)
+#endif
+
+#ifndef REFACTORING_OPERATION_ACTION
+#define REFACTORING_OPERATION_ACTION(Name, Spelling, Command)\
+  REFACTORING_ACTION(Name, Spelling)
+#endif
+
+#ifndef REFACTORING_OPERATION_SUB_ACTION
+#define REFACTORING_OPERATION_SUB_ACTION(Name, Parent, Spelling, Command)\
+  REFACTORING_SUB_ACTION(Name, Parent, Spelling)
+#endif
+
+REFACTORING_ACTION(Rename, "Rename")
+REFACTORING_SUB_ACTION(Local, Rename, "Rename")
+
+REFACTORING_OPERATION_ACTION(Extract, "Extract Function", "extract")
+REFACTORING_OPERATION_SUB_ACTION(Method, Extract, "Extract Method",
+                                 "extract-method")
+REFACTORING_OPERATION_SUB_ACTION(Expression, Extract, "Extract Expression",
+                                 "extract-expression")
+
+REFACTORING_OPERATION_ACTION(IfSwitchConversion, "Convert to Switch",
+                             "if-switch-conversion")
+REFACTORING_OPERATION_ACTION(FillInEnumSwitchCases, "Add Missing Switch Cases",
+                             "fill-in-enum-switch-cases")
+REFACTORING_OPERATION_ACTION(FillInMissingProtocolStubs,
+                             "Add Missing Protocol Requirements",
+                             "fill-in-missing-protocol-stubs")
+REFACTORING_OPERATION_ACTION(LocalizeObjCStringLiteral,
+                             "Wrap in NSLocalizedString",
+                             "localize-objc-string-literal")
+REFACTORING_OPERATION_ACTION(ExtractRepeatedExpressionIntoVariable,
+                             "Extract Repeated Expression",
+                             "extract-repeated-expr-into-var")
+REFACTORING_OPERATION_ACTION(FillInMissingMethodStubsFromAbstractClasses,
+                             "Add Missing Abstract Class Overrides",
+                             "fill-in-missing-abstract-methods")
+ // FIXME: For ObjC this should say 'Methods':
+REFACTORING_OPERATION_ACTION(ImplementDeclaredMethods,
+                             "Generate Missing Function Definitions",
+                             "implement-declared-methods")
+
+#undef REFACTORING_OPERATION_SUB_ACTION
+#undef REFACTORING_OPERATION_ACTION
+#undef REFACTORING_SUB_ACTION
+#undef REFACTORING_ACTION
diff --git a/include/clang/Tooling/Refactor/RefactoringActions.h b/include/clang/Tooling/Refactor/RefactoringActions.h
index e69de29bb2..f9d9c6c888 100644
--- a/include/clang/Tooling/Refactor/RefactoringActions.h
+++ b/include/clang/Tooling/Refactor/RefactoringActions.h
@@ -0,0 +1,34 @@
+//===--- RefactoringActions.h - Clang refactoring library -----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Contains a list of all the supported refactoring actions.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_ACTIONS_H
+#define LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_ACTIONS_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/StringRef.h"
+
+namespace clang {
+namespace tooling {
+
+enum class RefactoringActionType {
+#define REFACTORING_ACTION(Name, Spelling) Name,
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+};
+
+StringRef getRefactoringActionTypeName(RefactoringActionType Action);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_ACTIONS_H
diff --git a/include/clang/Tooling/Refactor/RefactoringOperation.h b/include/clang/Tooling/Refactor/RefactoringOperation.h
index e69de29bb2..3332178011 100644
--- a/include/clang/Tooling/Refactor/RefactoringOperation.h
+++ b/include/clang/Tooling/Refactor/RefactoringOperation.h
@@ -0,0 +1,160 @@
+//===--- RefactoringOperations.h - Defines a refactoring operation --------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPERATION_H
+#define LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPERATION_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Tooling/Refactor/RefactoringActions.h"
+#include "clang/Tooling/Refactor/RefactoringOptionSet.h"
+#include "clang/Tooling/Refactor/RefactoringReplacement.h"
+#include "clang/Tooling/Refactor/SymbolOperation.h"
+#include "llvm/ADT/None.h"
+#include "llvm/Support/Error.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+
+class ASTContext;
+class Decl;
+class Preprocessor;
+class Stmt;
+
+namespace tooling {
+
+class RefactoringContinuation;
+
+/// A refactoring result contains the source replacements produced by the
+/// refactoring operation and the optional refactoring continuation.
+struct RefactoringResult {
+  std::vector<RefactoringReplacement> Replacements;
+  std::vector<std::unique_ptr<RefactoringResultAssociatedSymbol>>
+      AssociatedSymbols;
+  std::unique_ptr<RefactoringContinuation> Continuation;
+
+  RefactoringResult(
+      std::vector<RefactoringReplacement> Replacements,
+      std::unique_ptr<RefactoringContinuation> Continuation = nullptr)
+      : Replacements(std::move(Replacements)),
+        Continuation(std::move(Continuation)) {}
+
+  RefactoringResult(std::unique_ptr<RefactoringContinuation> Continuation)
+      : Replacements(), Continuation(std::move(Continuation)) {}
+
+  RefactoringResult(RefactoringResult &&) = default;
+  RefactoringResult &operator=(RefactoringResult &&) = default;
+};
+
+namespace indexer {
+
+class IndexerQuery;
+class ASTProducerQuery;
+
+} // end namespace indexer
+
+/// Refactoring continuations allow refactoring operations to run in external
+/// AST units with some results that were obtained after querying the indexer.
+///
+/// The state of the refactoring operation is automatically managed by the
+/// refactoring engine:
+///   - Declaration references are converted to declaration references in
+///     an external translation unit.
+class RefactoringContinuation {
+public:
+  virtual ~RefactoringContinuation() {}
+
+  virtual indexer::ASTProducerQuery *getASTUnitIndexerQuery() = 0;
+
+  virtual std::vector<indexer::IndexerQuery *>
+  getAdditionalIndexerQueries() = 0;
+
+  /// Converts the TU-specific state in the continuation to a TU-independent
+  /// state.
+  ///
+  /// This function is called before the initiation AST unit is freed.
+  virtual void persistTUSpecificState() = 0;
+
+  /// Invokes the continuation with the indexer query results and the state
+  /// values in the context of another AST unit.
+  virtual llvm::Expected<RefactoringResult>
+  runInExternalASTUnit(ASTContext &Context) = 0;
+};
+
+// TODO: Remove in favour of diagnostics.
+class RefactoringOperationError
+    : public llvm::ErrorInfo<RefactoringOperationError> {
+public:
+  static char ID;
+  StringRef FailureReason;
+
+  RefactoringOperationError(StringRef FailureReason)
+      : FailureReason(FailureReason) {}
+
+  void log(raw_ostream &OS) const override;
+
+  std::error_code convertToErrorCode() const override;
+};
+
+/// Represents an abstract refactoring operation.
+class RefactoringOperation {
+public:
+  virtual ~RefactoringOperation() {}
+
+  virtual const Stmt *getTransformedStmt() const { return nullptr; }
+
+  virtual const Stmt *getLastTransformedStmt() const { return nullptr; }
+
+  virtual const Decl *getTransformedDecl() const { return nullptr; }
+
+  virtual const Decl *getLastTransformedDecl() const { return nullptr; }
+
+  virtual std::vector<std::string> getRefactoringCandidates() { return {}; }
+
+  virtual std::vector<RefactoringActionType> getAvailableSubActions() {
+    return {};
+  }
+
+  virtual llvm::Expected<RefactoringResult>
+  perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex = 0) = 0;
+};
+
+/// A wrapper around a unique pointer to a \c RefactoringOperation or \c
+/// SymbolOperation that determines if the operation was successfully initiated
+/// or not, even if the operation itself wasn't created.
+struct RefactoringOperationResult {
+  std::unique_ptr<RefactoringOperation> RefactoringOp;
+  std::unique_ptr<SymbolOperation> SymbolOp;
+  bool Initiated;
+  StringRef FailureReason;
+
+  RefactoringOperationResult() : Initiated(false) {}
+  RefactoringOperationResult(llvm::NoneType) : Initiated(false) {}
+  explicit RefactoringOperationResult(StringRef FailureReason)
+      : Initiated(false), FailureReason(FailureReason) {}
+};
+
+/// Initiate a specific refactoring operation.
+RefactoringOperationResult initiateRefactoringOperationAt(
+    SourceLocation Location, SourceRange SelectionRange, ASTContext &Context,
+    RefactoringActionType ActionType, bool CreateOperation = true);
+
+/// Initiate a specific refactoring operation on a declaration that corresponds
+/// to the given \p DeclUSR.
+RefactoringOperationResult
+initiateRefactoringOperationOnDecl(StringRef DeclUSR, ASTContext &Context,
+                                   RefactoringActionType ActionType);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPERATION_H
diff --git a/include/clang/Tooling/Refactor/RefactoringOperationState.h b/include/clang/Tooling/Refactor/RefactoringOperationState.h
index e69de29bb2..76ee7d4392 100644
--- a/include/clang/Tooling/Refactor/RefactoringOperationState.h
+++ b/include/clang/Tooling/Refactor/RefactoringOperationState.h
@@ -0,0 +1,66 @@
+//===--- RefactoringOperationState.h - Serializable operation state -------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the refactoring operation state types that represent the
+// TU-independent state that is used for refactoring continuations.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPERATION_STATE_H
+#define LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPERATION_STATE_H
+
+#include "clang/AST/Decl.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Tooling/Refactor/USRFinder.h"
+#include <string>
+#include <type_traits>
+
+namespace clang {
+namespace tooling {
+
+namespace detail {
+
+struct PersistentDeclRefBase {};
+
+} // end namespace detail
+
+/// Declaration references are persisted across translation units by using
+/// USRs.
+template <typename T>
+struct PersistentDeclRef : std::enable_if<std::is_base_of<Decl, T>::value,
+                                          detail::PersistentDeclRefBase>::type {
+  std::string USR;
+  // FIXME: We can improve the efficiency of conversion to Decl * by storing the
+  // decl kind.
+
+  PersistentDeclRef(std::string USR) : USR(std::move(USR)) {}
+  PersistentDeclRef(PersistentDeclRef &&Other) = default;
+  PersistentDeclRef &operator=(PersistentDeclRef &&Other) = default;
+  PersistentDeclRef(const PersistentDeclRef &Other) = default;
+  PersistentDeclRef &operator=(const PersistentDeclRef &Other) = default;
+
+  static PersistentDeclRef<T> create(const Decl *D) {
+    // FIXME: Move the getUSRForDecl method somewhere else.
+    return PersistentDeclRef<T>(rename::getUSRForDecl(D));
+  }
+};
+
+/// FileIDs are persisted across translation units by using filenames.
+struct PersistentFileID {
+  std::string Filename;
+
+  PersistentFileID(std::string Filename) : Filename(std::move(Filename)) {}
+  PersistentFileID(PersistentFileID &&Other) = default;
+  PersistentFileID &operator=(PersistentFileID &&Other) = default;
+};
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPERATION_STATE_H
diff --git a/include/clang/Tooling/Refactor/RefactoringOptionSet.h b/include/clang/Tooling/Refactor/RefactoringOptionSet.h
index e69de29bb2..0368122cbf 100644
--- a/include/clang/Tooling/Refactor/RefactoringOptionSet.h
+++ b/include/clang/Tooling/Refactor/RefactoringOptionSet.h
@@ -0,0 +1,80 @@
+//===--- RefactoringOptionSet.h - A container for the refactoring options -===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPTION_SET_H
+#define LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPTION_SET_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/Support/Allocator.h"
+#include "llvm/Support/Error.h"
+
+namespace llvm {
+namespace yaml {
+class IO;
+} // end namespace yaml
+} // end namespace llvm
+
+namespace clang {
+namespace tooling {
+
+struct OldRefactoringOption {
+  virtual ~OldRefactoringOption() = default;
+
+  struct SerializationContext {
+    llvm::yaml::IO &IO;
+
+    SerializationContext(llvm::yaml::IO &IO) : IO(IO) {}
+  };
+
+  virtual void serialize(const SerializationContext &Context);
+};
+
+/// \brief A set of refactoring options that can be given to a refactoring
+/// operation.
+class RefactoringOptionSet final {
+  llvm::StringMap<std::unique_ptr<OldRefactoringOption>> Options;
+
+public:
+  RefactoringOptionSet() {}
+  template <typename T> RefactoringOptionSet(const T &Option) { add(Option); }
+
+  RefactoringOptionSet(RefactoringOptionSet &&) = default;
+  RefactoringOptionSet &operator=(RefactoringOptionSet &&) = default;
+
+  RefactoringOptionSet(const RefactoringOptionSet &) = delete;
+  RefactoringOptionSet &operator=(const RefactoringOptionSet &) = delete;
+
+  template <typename T> void add(const T &Option) {
+    auto It = Options.try_emplace(StringRef(T::Name), nullptr);
+    if (It.second)
+      It.first->getValue().reset(new T(Option));
+  }
+
+  template <typename T> const T *get() const {
+    auto It = Options.find(StringRef(T::Name));
+    if (It == Options.end())
+      return nullptr;
+    return static_cast<const T *>(It->getValue().get());
+  }
+
+  template <typename T> const T &get(const T &Default) const {
+    const auto *Ptr = get<T>();
+    return Ptr ? *Ptr : Default;
+  }
+
+  void print(llvm::raw_ostream &OS) const;
+
+  static llvm::Expected<RefactoringOptionSet> parse(StringRef Source);
+};
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_OPTION_SET_H
diff --git a/include/clang/Tooling/Refactor/RefactoringOptions.h b/include/clang/Tooling/Refactor/RefactoringOptions.h
index e69de29bb2..60db7cc09b 100644
--- a/include/clang/Tooling/Refactor/RefactoringOptions.h
+++ b/include/clang/Tooling/Refactor/RefactoringOptions.h
@@ -0,0 +1,59 @@
+//===--- RefactoringOptions.h - A set of all the refactoring options ------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a set of all possible refactoring options that can be
+// given to the refactoring operations.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_OLD_REFACTORING_OPTIONS_H
+#define LLVM_CLANG_TOOLING_REFACTOR_OLD_REFACTORING_OPTIONS_H
+
+#include "clang/AST/DeclBase.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Tooling/Refactor/RefactoringOptionSet.h"
+
+namespace clang {
+namespace tooling {
+namespace option {
+
+namespace detail {
+
+struct BoolOptionBase : OldRefactoringOption {
+protected:
+  bool Value = false;
+  void serializeImpl(const SerializationContext &Context, const char *Name);
+
+public:
+  operator bool() const { return Value; }
+};
+
+template <typename Option> struct BoolOption : BoolOptionBase {
+  void serialize(const SerializationContext &Context) override {
+    serializeImpl(Context, Option::Name);
+  }
+
+  static Option getTrue() {
+    Option Result;
+    Result.Value = true;
+    return Result;
+  }
+};
+
+} // end namespace detail
+
+struct AvoidTextualMatches final : detail::BoolOption<AvoidTextualMatches> {
+  static constexpr const char *Name = "rename.avoid.textual.matches";
+};
+
+} // end namespace option
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_OLD_REFACTORING_OPTIONS_H
diff --git a/include/clang/Tooling/Refactor/RefactoringReplacement.h b/include/clang/Tooling/Refactor/RefactoringReplacement.h
index e69de29bb2..86dd2fbe8a 100644
--- a/include/clang/Tooling/Refactor/RefactoringReplacement.h
+++ b/include/clang/Tooling/Refactor/RefactoringReplacement.h
@@ -0,0 +1,86 @@
+//===--- RefactoringReplacement.h - ------------------------*- C++ -*------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_REPLACEMENT_H
+#define LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_REPLACEMENT_H
+
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Tooling/Refactor/SymbolName.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringSet.h"
+#include <string>
+
+namespace clang {
+namespace tooling {
+
+/// \brief Represent a symbol that can be used for an additional refactoring
+/// action that associated.
+class RefactoringResultAssociatedSymbol {
+  OldSymbolName Name;
+
+public:
+  RefactoringResultAssociatedSymbol(OldSymbolName Name)
+      : Name(std::move(Name)) {}
+
+  const OldSymbolName &getName() const { return Name; }
+};
+
+/// \brief A replacement range.
+class RefactoringReplacement {
+public:
+  SourceRange Range;
+  std::string ReplacementString;
+
+  /// \brief Represents a symbol that is contained in the replacement string
+  /// of this replacement.
+  struct AssociatedSymbolLocation {
+    /// These offsets point into the ReplacementString.
+    llvm::SmallVector<unsigned, 4> Offsets;
+    bool IsDeclaration;
+
+    AssociatedSymbolLocation(ArrayRef<unsigned> Offsets,
+                             bool IsDeclaration = false)
+        : Offsets(Offsets.begin(), Offsets.end()),
+          IsDeclaration(IsDeclaration) {}
+  };
+  llvm::SmallDenseMap<const RefactoringResultAssociatedSymbol *,
+                      AssociatedSymbolLocation>
+      SymbolLocations;
+
+  RefactoringReplacement(SourceRange Range) : Range(Range) {}
+
+  RefactoringReplacement(SourceRange Range, StringRef ReplacementString)
+      : Range(Range), ReplacementString(ReplacementString.str()) {}
+  RefactoringReplacement(SourceRange Range, std::string ReplacementString)
+      : Range(Range), ReplacementString(std::move(ReplacementString)) {}
+
+  RefactoringReplacement(SourceRange Range, StringRef ReplacementString,
+                         const RefactoringResultAssociatedSymbol *Symbol,
+                         const AssociatedSymbolLocation &Loc)
+      : Range(Range), ReplacementString(ReplacementString.str()) {
+    SymbolLocations.insert(std::make_pair(Symbol, Loc));
+  }
+
+  RefactoringReplacement(const FixItHint &Hint) {
+    Range = Hint.RemoveRange.getAsRange();
+    ReplacementString = Hint.CodeToInsert;
+  }
+
+  RefactoringReplacement(RefactoringReplacement &&) = default;
+  RefactoringReplacement &operator=(RefactoringReplacement &&) = default;
+};
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_REFACTORING_REPLACEMENT_H
diff --git a/include/clang/Tooling/Refactor/RenameIndexedFile.h b/include/clang/Tooling/Refactor/RenameIndexedFile.h
index e69de29bb2..51508618f4 100644
--- a/include/clang/Tooling/Refactor/RenameIndexedFile.h
+++ b/include/clang/Tooling/Refactor/RenameIndexedFile.h
@@ -0,0 +1,88 @@
+//===--- RenameIndexedFile.h - -----------------------------*- C++ -*------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_RENAME_INDEXED_FILE_H
+#define LLVM_CLANG_TOOLING_REFACTOR_RENAME_INDEXED_FILE_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Frontend/FrontendAction.h"
+#include "clang/Tooling/Refactor/RenamedSymbol.h"
+#include "clang/Tooling/Refactor/SymbolName.h"
+#include "llvm/ADT/ArrayRef.h"
+
+namespace clang {
+namespace tooling {
+
+class RefactoringOptionSet;
+
+namespace rename {
+
+/// An already known occurrence of the symbol that's being renamed.
+struct IndexedOccurrence {
+  /// The location of this occurrence in the indexed file.
+  unsigned Line, Column;
+  enum OccurrenceKind {
+    IndexedSymbol,
+    IndexedObjCMessageSend,
+    InclusionDirective
+  };
+  OccurrenceKind Kind;
+};
+
+struct IndexedSymbol {
+  OldSymbolName Name;
+  std::vector<IndexedOccurrence> IndexedOccurrences;
+  /// Whether this symbol is an Objective-C selector.
+  bool IsObjCSelector;
+  /// If true, indexed file renamer will look for matching textual occurrences
+  /// in string literal tokens.
+  bool SearchForStringLiteralOccurrences;
+
+  IndexedSymbol(OldSymbolName Name,
+                std::vector<IndexedOccurrence> IndexedOccurrences,
+                bool IsObjCSelector,
+                bool SearchForStringLiteralOccurrences = false)
+      : Name(std::move(Name)),
+        IndexedOccurrences(std::move(IndexedOccurrences)),
+        IsObjCSelector(IsObjCSelector),
+        SearchForStringLiteralOccurrences(SearchForStringLiteralOccurrences) {}
+  IndexedSymbol(IndexedSymbol &&Other) = default;
+  IndexedSymbol &operator=(IndexedSymbol &&Other) = default;
+};
+
+/// Consumes the \c SymbolOccurrences found by \c IndexedFileOccurrenceProducer.
+class IndexedFileOccurrenceConsumer {
+public:
+  virtual ~IndexedFileOccurrenceConsumer() {}
+  virtual void handleOccurrence(const OldSymbolOccurrence &Occurrence,
+                                SourceManager &SM,
+                                const LangOptions &LangOpts) = 0;
+};
+
+/// Finds the renamed \c SymbolOccurrences in an already indexed files.
+class IndexedFileOccurrenceProducer final : public PreprocessorFrontendAction {
+  bool IsMultiPiece;
+  ArrayRef<IndexedSymbol> Symbols;
+  IndexedFileOccurrenceConsumer &Consumer;
+  const RefactoringOptionSet *Options;
+
+public:
+  IndexedFileOccurrenceProducer(ArrayRef<IndexedSymbol> Symbols,
+                                IndexedFileOccurrenceConsumer &Consumer,
+                                const RefactoringOptionSet *Options = nullptr);
+
+private:
+  void ExecuteAction() override;
+};
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_RENAME_INDEXED_FILE_H
diff --git a/include/clang/Tooling/Refactor/RenamedSymbol.h b/include/clang/Tooling/Refactor/RenamedSymbol.h
index e69de29bb2..cf795334a5 100644
--- a/include/clang/Tooling/Refactor/RenamedSymbol.h
+++ b/include/clang/Tooling/Refactor/RenamedSymbol.h
@@ -0,0 +1,146 @@
+//===--- RenamedSymbol.h - ---------------------------------*- C++ -*------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_RENAMED_SYMBOL_H
+#define LLVM_CLANG_TOOLING_REFACTOR_RENAMED_SYMBOL_H
+
+#include "clang/Basic/IdentifierTable.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Tooling/Refactor/SymbolName.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringSet.h"
+
+namespace clang {
+
+class NamedDecl;
+
+namespace tooling {
+namespace rename {
+
+/// \brief A symbol that has to be renamed.
+class Symbol {
+public:
+  OldSymbolName Name;
+  /// The index of this symbol in a \c SymbolOperation.
+  unsigned SymbolIndex;
+  /// The declaration that was used to initiate a refactoring operation for this
+  /// symbol. May not be the most canonical declaration.
+  const NamedDecl *FoundDecl;
+  /// An optional Objective-C selector.
+  llvm::Optional<Selector> ObjCSelector;
+
+  Symbol(const NamedDecl *FoundDecl, unsigned SymbolIndex,
+         const LangOptions &LangOpts);
+
+  Symbol(Symbol &&) = default;
+  Symbol &operator=(Symbol &&) = default;
+};
+
+/// \brief An occurrence of a renamed symbol.
+///
+/// Provides information about an occurrence of symbol that helps renaming tools
+/// determine if they can rename this symbol automatically and which source
+/// ranges they have to replace.
+///
+/// A single occurrence of a symbol can span more than one source range to
+/// account for things like Objective-C selectors.
+// TODO: Rename
+class OldSymbolOccurrence {
+  /// The source locations that correspond to the occurence of the symbol.
+  SmallVector<SourceLocation, 4> Locations;
+
+public:
+  enum OccurrenceKind {
+    /// \brief This occurrence is an exact match and can be renamed
+    /// automatically.
+    MatchingSymbol,
+
+    /// \brief This is an occurrence of a matching selector. It can't be renamed
+    /// automatically unless the indexer proves that this selector refers only
+    /// to the declarations that correspond to the renamed symbol.
+    MatchingSelector,
+
+    /// \brief This is an occurrence of an implicit property that uses the
+    /// renamed method.
+    MatchingImplicitProperty,
+
+    /// \brief This is a textual occurrence of a symbol in a comment.
+    MatchingComment,
+
+    /// \brief This is a textual occurrence of a symbol in a doc comment.
+    MatchingDocComment,
+
+    /// \brief This is an occurrence of a symbol in an inclusion directive.
+    MatchingFilename,
+
+    /// \brief This is a textual occurrence of a symbol in a string literal.
+    MatchingStringLiteral
+  };
+
+  OccurrenceKind Kind;
+  /// Whether or not this occurrence is inside a macro. When this is true, the
+  /// locations of the occurrence contain just one location that points to
+  /// the location of the macro expansion.
+  bool IsMacroExpansion;
+  /// The index of the symbol stored in a \c SymbolOperation which matches this
+  /// occurrence.
+  unsigned SymbolIndex;
+
+  OldSymbolOccurrence()
+      : Kind(MatchingSymbol), IsMacroExpansion(false), SymbolIndex(0) {}
+
+  OldSymbolOccurrence(OccurrenceKind Kind, bool IsMacroExpansion,
+                      unsigned SymbolIndex, ArrayRef<SourceLocation> Locations)
+      : Locations(Locations.begin(), Locations.end()), Kind(Kind),
+        IsMacroExpansion(IsMacroExpansion), SymbolIndex(SymbolIndex) {
+    assert(!Locations.empty() && "Renamed occurence without locations!");
+  }
+
+  OldSymbolOccurrence(OldSymbolOccurrence &&) = default;
+  OldSymbolOccurrence &operator=(OldSymbolOccurrence &&) = default;
+
+  ArrayRef<SourceLocation> locations() const {
+    if (Kind == MatchingImplicitProperty && Locations.size() == 2)
+      return llvm::makeArrayRef(Locations).drop_back();
+    return Locations;
+  }
+
+  /// Return the source range that corresponds to an individual source location
+  /// in this occurrence.
+  SourceRange getLocationRange(SourceLocation Loc, size_t OldNameSize) const {
+    SourceLocation EndLoc;
+    // Implicit property references might store the end as the second location
+    // to take into account the match for 'prop' when the old name is 'setProp'.
+    if (Kind == MatchingImplicitProperty && Locations.size() == 2) {
+      assert(Loc == Locations[0] && "invalid loc");
+      EndLoc = Locations[1];
+    } else
+      EndLoc = IsMacroExpansion ? Loc : Loc.getLocWithOffset(OldNameSize);
+    return SourceRange(Loc, EndLoc);
+  }
+
+  friend bool operator<(const OldSymbolOccurrence &LHS,
+                        const OldSymbolOccurrence &RHS);
+  friend bool operator==(const OldSymbolOccurrence &LHS,
+                         const OldSymbolOccurrence &RHS);
+};
+
+/// \brief Less-than operator between the two renamed symbol occurrences.
+bool operator<(const OldSymbolOccurrence &LHS, const OldSymbolOccurrence &RHS);
+
+/// \brief Equal-to operator between the two renamed symbol occurrences.
+bool operator==(const OldSymbolOccurrence &LHS, const OldSymbolOccurrence &RHS);
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_RENAMED_SYMBOL_H
diff --git a/include/clang/Tooling/Refactor/RenamingOperation.h b/include/clang/Tooling/Refactor/RenamingOperation.h
index e69de29bb2..9a2883e647 100644
--- a/include/clang/Tooling/Refactor/RenamingOperation.h
+++ b/include/clang/Tooling/Refactor/RenamingOperation.h
@@ -0,0 +1,44 @@
+//===--- RenamingOperation.h - -----------------------------*- C++ -*------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_RENAMING_OPERATION_H
+#define LLVM_CLANG_TOOLING_REFACTOR_RENAMING_OPERATION_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Tooling/Refactor/SymbolName.h"
+#include "llvm/ADT/SmallVector.h"
+
+namespace clang {
+
+class IdentifierTable;
+
+namespace tooling {
+
+class SymbolOperation;
+
+namespace rename {
+
+/// Return true if the new name is a valid language identifier.
+bool isNewNameValid(const OldSymbolName &NewName, bool IsSymbolObjCSelector,
+                    IdentifierTable &IDs, const LangOptions &LangOpts);
+bool isNewNameValid(const OldSymbolName &NewName,
+                    const SymbolOperation &Operation, IdentifierTable &IDs,
+                    const LangOptions &LangOpts);
+
+/// \brief Finds the set of new names that apply to the symbols in the given
+/// \c SymbolOperation.
+void determineNewNames(OldSymbolName NewName, const SymbolOperation &Operation,
+                       SmallVectorImpl<OldSymbolName> &NewNames,
+                       const LangOptions &LangOpts);
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_RENAMING_OPERATION_H
diff --git a/include/clang/Tooling/Refactor/SymbolName.h b/include/clang/Tooling/Refactor/SymbolName.h
index e69de29bb2..fdb9f340b6 100644
--- a/include/clang/Tooling/Refactor/SymbolName.h
+++ b/include/clang/Tooling/Refactor/SymbolName.h
@@ -0,0 +1,74 @@
+//===--- SymbolName.h - Clang refactoring library ----------*- C++ -*------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_NAME_H
+#define LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_NAME_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringRef.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+
+class LangOptions;
+
+namespace tooling {
+
+/// \brief A name of a declaration that's used in the refactoring process.
+///
+/// Names can be composed of multiple string, to account for things like
+/// Objective-C selectors.
+class OldSymbolName {
+public:
+  OldSymbolName() {}
+
+  /// \brief Creates a \c SymbolName by decomposing the given \p Name using
+  /// language specific logic.
+  OldSymbolName(StringRef Name, const LangOptions &LangOpts);
+  OldSymbolName(StringRef Name, bool IsObjectiveCSelector);
+  explicit OldSymbolName(ArrayRef<StringRef> Name);
+
+  OldSymbolName(OldSymbolName &&) = default;
+  OldSymbolName &operator=(OldSymbolName &&) = default;
+
+  OldSymbolName(const OldSymbolName &) = default;
+  OldSymbolName &operator=(const OldSymbolName &) = default;
+
+  bool empty() const { return Strings.empty(); }
+
+  /// \brief Returns the number of the strings that make up the given name.
+  size_t size() const { return Strings.size(); }
+
+  /// \brief Returns the string at the given index.
+  StringRef operator[](size_t I) const { return Strings[I]; }
+
+  ArrayRef<std::string> strings() const { return Strings; }
+
+  bool containsEmptyPiece() const {
+    for (const auto &String : Strings) {
+      if (String.empty())
+        return true;
+    }
+    return false;
+  }
+
+  void print(raw_ostream &OS) const;
+
+private:
+  std::vector<std::string> Strings;
+};
+
+raw_ostream &operator<<(raw_ostream &OS, const OldSymbolName &N);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_NAME_H
diff --git a/include/clang/Tooling/Refactor/SymbolOccurrenceFinder.h b/include/clang/Tooling/Refactor/SymbolOccurrenceFinder.h
index e69de29bb2..d6f8e495e6 100644
--- a/include/clang/Tooling/Refactor/SymbolOccurrenceFinder.h
+++ b/include/clang/Tooling/Refactor/SymbolOccurrenceFinder.h
@@ -0,0 +1,37 @@
+//===--- SymbolOccurrenceFinder.h - Clang refactoring library -------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Provides functionality for finding all occurrences of a USR in a
+/// given AST.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_OCCURRENCE_FINDER_H
+#define LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_OCCURRENCE_FINDER_H
+
+#include "clang/AST/AST.h"
+#include "clang/Tooling/Refactor/SymbolOperation.h"
+#include "llvm/ADT/StringRef.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+namespace tooling {
+namespace rename {
+
+// FIXME: make this an AST matcher. Wouldn't that be awesome??? I agree!
+std::vector<OldSymbolOccurrence>
+findSymbolOccurrences(const SymbolOperation &Operation, Decl *Decl);
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_OCCURRENCE_FINDER_H
diff --git a/include/clang/Tooling/Refactor/SymbolOperation.h b/include/clang/Tooling/Refactor/SymbolOperation.h
index e69de29bb2..7616aa36ae 100644
--- a/include/clang/Tooling/Refactor/SymbolOperation.h
+++ b/include/clang/Tooling/Refactor/SymbolOperation.h
@@ -0,0 +1,91 @@
+//===--- SymbolOperation.h - -------------------------------*- C++ -*------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_OPERATION_H
+#define LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_OPERATION_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Tooling/Refactor/RenamedSymbol.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringMap.h"
+
+namespace clang {
+
+class ASTContext;
+class NamedDecl;
+
+namespace tooling {
+
+/// \brief A refactoring operation that deals with occurrences of symbols.
+class SymbolOperation {
+  /// Contains the symbols that are required for this operation.
+  SmallVector<rename::Symbol, 4> Symbols;
+
+  /// Maps from a USR to an index in the \c Symbol array.
+  /// Contains all of the USRs that correspond to the declarations which use
+  /// the symbols in this operation.
+  llvm::StringMap<unsigned> USRToSymbol;
+
+  /// True if all the symbols in this operation occur only in the translation
+  /// unit that defines them.
+  bool IsLocal;
+
+  /// The declaration whose implementation is needed for the correct initiation
+  /// of a symbol operation.
+  const NamedDecl *DeclThatRequiresImplementationTU;
+
+public:
+  SymbolOperation(const NamedDecl *FoundDecl, ASTContext &Context);
+
+  SymbolOperation(SymbolOperation &&) = default;
+  SymbolOperation &operator=(SymbolOperation &&) = default;
+
+  /// Return the symbol that corresponds to the given USR, or null if this USR
+  /// isn't interesting from the perspective of this operation.
+  const rename::Symbol *getSymbolForUSR(StringRef USR) const {
+    auto It = USRToSymbol.find(USR);
+    if (It != USRToSymbol.end())
+      return &Symbols[It->getValue()];
+    return nullptr;
+  }
+
+  /// The symbols that this operation is working on.
+  ///
+  /// Symbol operations, like rename, usually just work on just one symbol.
+  /// However, there are certain language constructs that require more than
+  /// one symbol in order for them to be renamed correctly. Property
+  /// declarations in Objective-C are the perfect example: in addition to the
+  /// actual property, renaming has to rename the corresponding getters and
+  /// setters, as well as the backing ivar.
+  ArrayRef<rename::Symbol> symbols() const { return Symbols; }
+
+  /// True if all the symbols in this operation occur only in the translation
+  /// unit that defines them.
+  bool isLocal() const { return IsLocal; }
+
+  /// True if the declaration that was found in the initial TU needs to be
+  /// examined in the TU that implemented it.
+  bool requiresImplementationTU() const {
+    return DeclThatRequiresImplementationTU;
+  }
+
+  /// Returns the declaration whose implementation is needed for the correct
+  /// initiation of a symbol operation.
+  const NamedDecl *declThatRequiresImplementationTU() const {
+    return DeclThatRequiresImplementationTU;
+  }
+};
+
+/// Return true if the given declaration corresponds to a local symbol.
+bool isLocalSymbol(const NamedDecl *D, const LangOptions &LangOpts);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_SYMBOL_OPERATION_H
diff --git a/include/clang/Tooling/Refactor/USRFinder.h b/include/clang/Tooling/Refactor/USRFinder.h
index e69de29bb2..0a83f3086d 100644
--- a/include/clang/Tooling/Refactor/USRFinder.h
+++ b/include/clang/Tooling/Refactor/USRFinder.h
@@ -0,0 +1,85 @@
+//===--- USRFinder.h - Clang refactoring library --------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Methods for determining the USR of a symbol at a location in source
+/// code.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLING_REFACTOR_USR_FINDER_H
+#define LLVM_CLANG_TOOLING_REFACTOR_USR_FINDER_H
+
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/ASTMatchers/ASTMatchFinder.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+
+class ASTContext;
+class Decl;
+class SourceLocation;
+class NamedDecl;
+
+namespace tooling {
+namespace rename {
+
+using llvm::StringRef;
+using namespace clang::ast_matchers;
+
+// Given an AST context and a point, returns a NamedDecl identifying the symbol
+// at the point. Returns null if nothing is found at the point.
+const NamedDecl *getNamedDeclAt(const ASTContext &Context,
+                                SourceLocation Point);
+
+/// Returns a \c NamedDecl that corresponds to the given \p USR in the given
+/// AST context. Returns null if there's no declaration that matches the given
+/// \p USR.
+const NamedDecl *getNamedDeclWithUSR(const ASTContext &Context, StringRef USR);
+
+// Converts a Decl into a USR.
+std::string getUSRForDecl(const Decl *Decl);
+
+// FIXME: Implement RecursiveASTVisitor<T>::VisitNestedNameSpecifier instead.
+class NestedNameSpecifierLocFinder : public MatchFinder::MatchCallback {
+public:
+  explicit NestedNameSpecifierLocFinder(ASTContext &Context)
+      : Context(Context) {}
+
+  ArrayRef<NestedNameSpecifierLoc> getNestedNameSpecifierLocations() {
+    addMatchers();
+    Finder.matchAST(Context);
+    return Locations;
+  }
+
+private:
+  void addMatchers() {
+    const auto NestedNameSpecifierLocMatcher =
+        nestedNameSpecifierLoc().bind("nestedNameSpecifierLoc");
+    Finder.addMatcher(NestedNameSpecifierLocMatcher, this);
+  }
+
+  void run(const MatchFinder::MatchResult &Result) override {
+    const auto *NNS = Result.Nodes.getNodeAs<NestedNameSpecifierLoc>(
+        "nestedNameSpecifierLoc");
+    Locations.push_back(*NNS);
+  }
+
+  ASTContext &Context;
+  std::vector<NestedNameSpecifierLoc> Locations;
+  MatchFinder Finder;
+};
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_TOOLING_REFACTOR_USR_FINDER_H
diff --git a/include/clang/module.modulemap b/include/clang/module.modulemap
index 4097ad2dc7..5f90780521 100644
--- a/include/clang/module.modulemap
+++ b/include/clang/module.modulemap
@@ -147,6 +147,9 @@ module Clang_Tooling {
   // importing the AST matchers library gives a link dependency on the AST
   // matchers (and thus the AST), which clang-format should not have.
   exclude header "Tooling/RefactoringCallbacks.h"
+  exclude header "Tooling/Refactor/USRFinder.h"
+
+  textual header "Tooling/Refactor/RefactoringActions.def"
 }
 
 module Clang_ToolingCore {
diff --git a/include/indexstore/IndexStoreCXX.h b/include/indexstore/IndexStoreCXX.h
index e69de29bb2..addaa86f13 100644
--- a/include/indexstore/IndexStoreCXX.h
+++ b/include/indexstore/IndexStoreCXX.h
@@ -0,0 +1,502 @@
+//===--- IndexStoreCXX.h - C++ wrapper for the Index Store C API. ---------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Header-only C++ wrapper for the Index Store C API.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_INDEXSTORE_INDEXSTORECXX_H
+#define LLVM_CLANG_INDEXSTORE_INDEXSTORECXX_H
+
+#include "indexstore/indexstore.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallString.h"
+#include <ctime>
+
+namespace indexstore {
+  using llvm::ArrayRef;
+  using llvm::Optional;
+  using llvm::StringRef;
+
+static inline StringRef stringFromIndexStoreStringRef(indexstore_string_ref_t str) {
+  return StringRef(str.data, str.length);
+}
+
+class IndexRecordSymbol {
+  indexstore_symbol_t obj;
+  friend class IndexRecordReader;
+
+public:
+  IndexRecordSymbol(indexstore_symbol_t obj) : obj(obj) {}
+
+  indexstore_symbol_language_t getLanguage() {
+    return indexstore_symbol_get_language(obj);
+  }
+  indexstore_symbol_kind_t getKind() { return indexstore_symbol_get_kind(obj); }
+  indexstore_symbol_subkind_t getSubKind() { return indexstore_symbol_get_subkind(obj); }
+  uint64_t getProperties() {
+    return indexstore_symbol_get_properties(obj);
+  }
+  uint64_t getRoles() { return indexstore_symbol_get_roles(obj); }
+  uint64_t getRelatedRoles() { return indexstore_symbol_get_related_roles(obj); }
+  StringRef getName() { return stringFromIndexStoreStringRef(indexstore_symbol_get_name(obj)); }
+  StringRef getUSR() { return stringFromIndexStoreStringRef(indexstore_symbol_get_usr(obj)); }
+  StringRef getCodegenName() { return stringFromIndexStoreStringRef(indexstore_symbol_get_codegen_name(obj)); }
+};
+
+class IndexSymbolRelation {
+  indexstore_symbol_relation_t obj;
+
+public:
+  IndexSymbolRelation(indexstore_symbol_relation_t obj) : obj(obj) {}
+
+  uint64_t getRoles() { return indexstore_symbol_relation_get_roles(obj); }
+  IndexRecordSymbol getSymbol() { return indexstore_symbol_relation_get_symbol(obj); }
+};
+
+class IndexRecordOccurrence {
+  indexstore_occurrence_t obj;
+
+public:
+  IndexRecordOccurrence(indexstore_occurrence_t obj) : obj(obj) {}
+
+  IndexRecordSymbol getSymbol() { return indexstore_occurrence_get_symbol(obj); }
+  uint64_t getRoles() { return indexstore_occurrence_get_roles(obj); }
+
+  bool foreachRelation(llvm::function_ref<bool(IndexSymbolRelation)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_occurrence_relations_apply(obj, ^bool(indexstore_symbol_relation_t sym_rel) {
+      return receiver(sym_rel);
+    });
+#else
+    return false;
+#endif
+  }
+
+  std::pair<unsigned, unsigned> getLineCol() {
+    unsigned line, col;
+    indexstore_occurrence_get_line_col(obj, &line, &col);
+    return std::make_pair(line, col);
+  }
+};
+
+class IndexStore;
+typedef std::shared_ptr<IndexStore> IndexStoreRef;
+
+class IndexStore {
+  indexstore_t obj;
+  friend class IndexRecordReader;
+  friend class IndexUnitReader;
+
+public:
+  IndexStore(StringRef path, std::string &error) {
+    llvm::SmallString<64> buf = path;
+    indexstore_error_t c_err = nullptr;
+    obj = indexstore_store_create(buf.c_str(), &c_err);
+    if (c_err) {
+      error = indexstore_error_get_description(c_err);
+      indexstore_error_dispose(c_err);
+    }
+  }
+
+  IndexStore(IndexStore &&other) : obj(other.obj) {
+    other.obj = nullptr;
+  }
+
+  ~IndexStore() {
+    indexstore_store_dispose(obj);
+  }
+
+  static IndexStoreRef create(StringRef path, std::string &error) {
+    auto storeRef = std::make_shared<IndexStore>(path, error);
+    if (storeRef->isInvalid())
+      return nullptr;
+    return storeRef;
+  }
+
+  static unsigned formatVersion() {
+    return indexstore_format_version();
+  }
+
+  bool isValid() const { return obj; }
+  bool isInvalid() const { return !isValid(); }
+  explicit operator bool() const { return isValid(); }
+
+  bool foreachUnit(bool sorted, llvm::function_ref<bool(StringRef unitName)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_store_units_apply(obj, sorted, ^bool(indexstore_string_ref_t unit_name) {
+      return receiver(stringFromIndexStoreStringRef(unit_name));
+    });
+#else
+    return false;
+#endif
+  }
+
+  class UnitEvent {
+    indexstore_unit_event_t obj;
+  public:
+    UnitEvent(indexstore_unit_event_t obj) : obj(obj) {}
+
+    enum class Kind {
+      Added,
+      Removed,
+      Modified,
+      DirectoryDeleted,
+    };
+    Kind getKind() const {
+      indexstore_unit_event_kind_t c_k = indexstore_unit_event_get_kind(obj);
+      Kind K;
+      switch (c_k) {
+      case INDEXSTORE_UNIT_EVENT_ADDED: K = Kind::Added; break;
+      case INDEXSTORE_UNIT_EVENT_REMOVED: K = Kind::Removed; break;
+      case INDEXSTORE_UNIT_EVENT_MODIFIED: K = Kind::Modified; break;
+      case INDEXSTORE_UNIT_EVENT_DIRECTORY_DELETED: K = Kind::DirectoryDeleted; break;
+      }
+      return K;
+    }
+
+    StringRef getUnitName() const {
+      return stringFromIndexStoreStringRef(indexstore_unit_event_get_unit_name(obj));
+    }
+
+    timespec getModificationTime() const { return indexstore_unit_event_get_modification_time(obj); }
+  };
+
+  class UnitEventNotification {
+    indexstore_unit_event_notification_t obj;
+  public:
+    UnitEventNotification(indexstore_unit_event_notification_t obj) : obj(obj) {}
+
+    bool isInitial() const { return indexstore_unit_event_notification_is_initial(obj); }
+    size_t getEventsCount() const { return indexstore_unit_event_notification_get_events_count(obj); }
+    UnitEvent getEvent(size_t index) const { return indexstore_unit_event_notification_get_event(obj, index); }
+  };
+
+  typedef std::function<void(UnitEventNotification)> UnitEventHandler;
+
+  void setUnitEventHandler(UnitEventHandler handler) {
+#if INDEXSTORE_HAS_BLOCKS
+    if (!handler) {
+      indexstore_store_set_unit_event_handler(obj, nullptr);
+      return;
+    }
+
+    indexstore_store_set_unit_event_handler(obj, ^(indexstore_unit_event_notification_t evt_note) {
+      handler(UnitEventNotification(evt_note));
+    });
+#endif
+  }
+
+  bool startEventListening(bool waitInitialSync, std::string &error) {
+    indexstore_unit_event_listen_options_t opts;
+    opts.wait_initial_sync = waitInitialSync;
+    indexstore_error_t c_err = nullptr;
+    bool ret = indexstore_store_start_unit_event_listening(obj, &opts, sizeof(opts), &c_err);
+    if (c_err) {
+      error = indexstore_error_get_description(c_err);
+      indexstore_error_dispose(c_err);
+    }
+    return ret;
+  }
+
+  void stopEventListening() {
+    return indexstore_store_stop_unit_event_listening(obj);
+  }
+
+  void discardUnit(StringRef UnitName) {
+    llvm::SmallString<64> buf = UnitName;
+    indexstore_store_discard_unit(obj, buf.c_str());
+  }
+
+  void discardRecord(StringRef RecordName) {
+    llvm::SmallString<64> buf = RecordName;
+    indexstore_store_discard_record(obj, buf.c_str());
+  }
+
+  void getUnitNameFromOutputPath(StringRef outputPath, llvm::SmallVectorImpl<char> &nameBuf) {
+    llvm::SmallString<256> buf = outputPath;
+    size_t nameLen = indexstore_store_get_unit_name_from_output_path(obj, buf.c_str(), nameBuf.data(), nameBuf.size());
+    if (nameLen+1 > nameBuf.size()) {
+      nameBuf.resize(nameLen+1);
+      indexstore_store_get_unit_name_from_output_path(obj, buf.c_str(), nameBuf.data(), nameBuf.size());
+    }
+  }
+
+  llvm::Optional<timespec>
+  getUnitModificationTime(StringRef unitName, std::string &error) {
+    llvm::SmallString<64> buf = unitName;
+    int64_t seconds, nanoseconds;
+    indexstore_error_t c_err = nullptr;
+    bool err = indexstore_store_get_unit_modification_time(obj, buf.c_str(),
+      &seconds, &nanoseconds, &c_err);
+    if (err && c_err) {
+      error = indexstore_error_get_description(c_err);
+      indexstore_error_dispose(c_err);
+      return llvm::None;
+    }
+    timespec ts;
+    ts.tv_sec = seconds;
+    ts.tv_nsec = nanoseconds;
+    return ts;
+  }
+
+  void purgeStaleData() {
+    indexstore_store_purge_stale_data(obj);
+  }
+};
+
+class IndexRecordReader {
+  indexstore_record_reader_t obj;
+
+public:
+  IndexRecordReader(IndexStore &store, StringRef recordName, std::string &error) {
+    llvm::SmallString<64> buf = recordName;
+    indexstore_error_t c_err = nullptr;
+    obj = indexstore_record_reader_create(store.obj, buf.c_str(), &c_err);
+    if (c_err) {
+      error = indexstore_error_get_description(c_err);
+      indexstore_error_dispose(c_err);
+    }
+  }
+
+  IndexRecordReader(IndexRecordReader &&other) : obj(other.obj) {
+    other.obj = nullptr;
+  }
+
+  ~IndexRecordReader() {
+    indexstore_record_reader_dispose(obj);
+  }
+
+  bool isValid() const { return obj; }
+  bool isInvalid() const { return !isValid(); }
+  explicit operator bool() const { return isValid(); }
+
+  /// Goes through and passes record decls, after filtering using a \c Checker
+  /// function.
+  ///
+  /// Resulting decls can be used as filter for \c foreachOccurrence. This
+  /// allows allocating memory only for the record decls that the caller is
+  /// interested in.
+  bool searchSymbols(llvm::function_ref<bool(IndexRecordSymbol, bool &stop)> filter,
+                     llvm::function_ref<void(IndexRecordSymbol)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_record_reader_search_symbols(obj, ^bool(indexstore_symbol_t symbol, bool *stop) {
+      return filter(symbol, *stop);
+    }, ^(indexstore_symbol_t symbol) {
+      receiver(symbol);
+    });
+#else
+    return false;
+#endif
+  }
+
+  bool foreachSymbol(bool noCache, llvm::function_ref<bool(IndexRecordSymbol)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_record_reader_symbols_apply(obj, noCache, ^bool(indexstore_symbol_t sym) {
+      return receiver(sym);
+    });
+#else
+    return false;
+#endif
+  }
+
+  /// \param DeclsFilter if non-empty indicates the list of decls that we want
+  /// to get occurrences for. An empty array indicates that we want occurrences
+  /// for all decls.
+  /// \param RelatedDeclsFilter Same as \c DeclsFilter but for related decls.
+  bool foreachOccurrence(ArrayRef<IndexRecordSymbol> symbolsFilter,
+                         ArrayRef<IndexRecordSymbol> relatedSymbolsFilter,
+              llvm::function_ref<bool(IndexRecordOccurrence)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    llvm::SmallVector<indexstore_symbol_t, 16> c_symbolsFilter;
+    c_symbolsFilter.reserve(symbolsFilter.size());
+    for (IndexRecordSymbol sym : symbolsFilter) {
+      c_symbolsFilter.push_back(sym.obj);
+    }
+    llvm::SmallVector<indexstore_symbol_t, 16> c_relatedSymbolsFilter;
+    c_relatedSymbolsFilter.reserve(relatedSymbolsFilter.size());
+    for (IndexRecordSymbol sym : relatedSymbolsFilter) {
+      c_relatedSymbolsFilter.push_back(sym.obj);
+    }
+    return indexstore_record_reader_occurrences_of_symbols_apply(obj,
+                                c_symbolsFilter.data(), c_symbolsFilter.size(),
+                                c_relatedSymbolsFilter.data(),
+                                c_relatedSymbolsFilter.size(),
+                                ^bool(indexstore_occurrence_t occur) {
+                                  return receiver(occur);
+                                });
+#else
+    return false;
+#endif
+  }
+
+  bool foreachOccurrence(
+              llvm::function_ref<bool(IndexRecordOccurrence)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_record_reader_occurrences_apply(obj, ^bool(indexstore_occurrence_t occur) {
+      return receiver(occur);
+    });
+#else
+    return false;
+#endif
+  }
+
+  bool foreachOccurrenceInLineRange(unsigned lineStart, unsigned lineEnd,
+              llvm::function_ref<bool(IndexRecordOccurrence)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_record_reader_occurrences_in_line_range_apply(obj,
+                                                                    lineStart,
+                                                                    lineEnd,
+                                          ^bool(indexstore_occurrence_t occur) {
+      return receiver(occur);
+    });
+#else
+    return false;
+#endif
+  }
+};
+
+class IndexUnitDependency {
+  indexstore_unit_dependency_t obj;
+  friend class IndexUnitReader;
+
+public:
+  IndexUnitDependency(indexstore_unit_dependency_t obj) : obj(obj) {}
+
+  enum class DependencyKind {
+    Unit,
+    Record,
+    File,
+  };
+  DependencyKind getKind() {
+    switch (indexstore_unit_dependency_get_kind(obj)) {
+    case INDEXSTORE_UNIT_DEPENDENCY_UNIT: return DependencyKind::Unit;
+    case INDEXSTORE_UNIT_DEPENDENCY_RECORD: return DependencyKind::Record;
+    case INDEXSTORE_UNIT_DEPENDENCY_FILE: return DependencyKind::File;
+    }
+  }
+  bool isSystem() { return indexstore_unit_dependency_is_system(obj); }
+  StringRef getName() { return stringFromIndexStoreStringRef(indexstore_unit_dependency_get_name(obj)); }
+  StringRef getFilePath() { return stringFromIndexStoreStringRef(indexstore_unit_dependency_get_filepath(obj)); }
+  StringRef getModuleName() { return stringFromIndexStoreStringRef(indexstore_unit_dependency_get_modulename(obj)); }
+  time_t getModificationTime() { return indexstore_unit_dependency_get_modification_time(obj); }
+  size_t getFileSize() { return indexstore_unit_dependency_get_file_size(obj); }
+
+};
+
+class IndexUnitInclude {
+  indexstore_unit_include_t obj;
+  friend class IndexUnitReader;
+
+public:
+  IndexUnitInclude(indexstore_unit_include_t obj) : obj(obj) {}
+
+  StringRef getSourcePath() {
+    return stringFromIndexStoreStringRef(indexstore_unit_include_get_source_path(obj));
+  }
+  StringRef getTargetPath() {
+    return stringFromIndexStoreStringRef(indexstore_unit_include_get_target_path(obj));
+  }
+  unsigned getSourceLine() {
+    return indexstore_unit_include_get_source_line(obj);
+  }
+};
+
+class IndexUnitReader {
+  indexstore_unit_reader_t obj;
+
+public:
+  IndexUnitReader(IndexStore &store, StringRef unitName, std::string &error) {
+    llvm::SmallString<64> buf = unitName;
+    indexstore_error_t c_err = nullptr;
+    obj = indexstore_unit_reader_create(store.obj, buf.c_str(), &c_err);
+    if (c_err) {
+      error = indexstore_error_get_description(c_err);
+      indexstore_error_dispose(c_err);
+    }
+  }
+
+  IndexUnitReader(IndexUnitReader &&other) : obj(other.obj) {
+    other.obj = nullptr;
+  }
+
+  ~IndexUnitReader() {
+    indexstore_unit_reader_dispose(obj);
+  }
+
+  bool isValid() const { return obj; }
+  bool isInvalid() const { return !isValid(); }
+  explicit operator bool() const { return isValid(); }
+
+  StringRef getProviderIdentifier() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_provider_identifier(obj));
+  }
+  StringRef getProviderVersion() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_provider_version(obj));
+  }
+
+  timespec getModificationTime() {
+    int64_t seconds, nanoseconds;
+    indexstore_unit_reader_get_modification_time(obj, &seconds, &nanoseconds);
+    timespec ts;
+    ts.tv_sec = seconds;
+    ts.tv_nsec = nanoseconds;
+    return ts;
+  }
+
+  bool isSystemUnit() { return indexstore_unit_reader_is_system_unit(obj); }
+  bool isModuleUnit() { return indexstore_unit_reader_is_module_unit(obj); }
+  bool isDebugCompilation() { return indexstore_unit_reader_is_debug_compilation(obj); }
+  bool hasMainFile() { return indexstore_unit_reader_has_main_file(obj); }
+
+  StringRef getMainFilePath() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_main_file(obj));
+  }
+  StringRef getModuleName() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_module_name(obj));
+  }
+  StringRef getWorkingDirectory() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_working_dir(obj));
+  }
+  StringRef getOutputFile() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_output_file(obj));
+  }
+  StringRef getSysrootPath() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_sysroot_path(obj));
+  }
+  StringRef getTarget() {
+    return stringFromIndexStoreStringRef(indexstore_unit_reader_get_target(obj));
+  }
+
+  bool foreachDependency(llvm::function_ref<bool(IndexUnitDependency)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_unit_reader_dependencies_apply(obj, ^bool(indexstore_unit_dependency_t dep) {
+      return receiver(dep);
+    });
+#else
+    return false;
+#endif
+  }
+
+  bool foreachInclude(llvm::function_ref<bool(IndexUnitInclude)> receiver) {
+#if INDEXSTORE_HAS_BLOCKS
+    return indexstore_unit_reader_includes_apply(obj, ^bool(indexstore_unit_include_t inc) {
+      return receiver(inc);
+    });
+#else
+    return false;
+#endif
+  }
+};
+
+} // namespace indexstore
+
+#endif
diff --git a/include/indexstore/indexstore.h b/include/indexstore/indexstore.h
index e69de29bb2..f4f41db002 100644
--- a/include/indexstore/indexstore.h
+++ b/include/indexstore/indexstore.h
@@ -0,0 +1,490 @@
+/*===-- indexstore/indexstore.h - Index Store C API ----------------- C -*-===*\
+|*                                                                            *|
+|*                     The LLVM Compiler Infrastructure                       *|
+|*                                                                            *|
+|* This file is distributed under the University of Illinois Open Source      *|
+|* License. See LICENSE.TXT for details.                                      *|
+|*                                                                            *|
+|*===----------------------------------------------------------------------===*|
+|*                                                                            *|
+|* This header provides a C API for the index store.                          *|
+|*                                                                            *|
+\*===----------------------------------------------------------------------===*/
+
+#ifndef LLVM_CLANG_C_INDEXSTORE_INDEXSTORE_H
+#define LLVM_CLANG_C_INDEXSTORE_INDEXSTORE_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <ctime>
+
+/**
+ * \brief The version constants for the Index Store C API.
+ * INDEXSTORE_VERSION_MINOR should increase when there are API additions.
+ * INDEXSTORE_VERSION_MAJOR is intended for "major" source/ABI breaking changes.
+ */
+#define INDEXSTORE_VERSION_MAJOR 0
+#define INDEXSTORE_VERSION_MINOR 9
+
+#define INDEXSTORE_VERSION_ENCODE(major, minor) ( \
+      ((major) * 10000)                           \
+    + ((minor) *     1))
+
+#define INDEXSTORE_VERSION INDEXSTORE_VERSION_ENCODE( \
+    INDEXSTORE_VERSION_MAJOR,                         \
+    INDEXSTORE_VERSION_MINOR )
+
+#define INDEXSTORE_VERSION_STRINGIZE_(major, minor)   \
+    #major"."#minor
+#define INDEXSTORE_VERSION_STRINGIZE(major, minor)    \
+    INDEXSTORE_VERSION_STRINGIZE_(major, minor)
+
+#define INDEXSTORE_VERSION_STRING INDEXSTORE_VERSION_STRINGIZE( \
+    INDEXSTORE_VERSION_MAJOR,                                   \
+    INDEXSTORE_VERSION_MINOR)
+
+#ifdef  __cplusplus
+# define INDEXSTORE_BEGIN_DECLS  extern "C" {
+# define INDEXSTORE_END_DECLS    }
+#else
+# define INDEXSTORE_BEGIN_DECLS
+# define INDEXSTORE_END_DECLS
+#endif
+
+#ifndef INDEXSTORE_PUBLIC
+# if defined (_MSC_VER)
+#  define INDEXSTORE_PUBLIC __declspec(dllimport)
+# else
+#  define INDEXSTORE_PUBLIC
+# endif
+#endif
+
+#ifndef __has_feature
+# define __has_feature(x) 0
+#endif
+
+#if __has_feature(blocks)
+# define INDEXSTORE_HAS_BLOCKS 1
+#else
+# define INDEXSTORE_HAS_BLOCKS 0
+#endif
+
+INDEXSTORE_BEGIN_DECLS
+
+typedef void *indexstore_error_t;
+
+INDEXSTORE_PUBLIC const char *
+indexstore_error_get_description(indexstore_error_t);
+
+INDEXSTORE_PUBLIC void
+indexstore_error_dispose(indexstore_error_t);
+
+typedef struct {
+  const char *data;
+  size_t length;
+} indexstore_string_ref_t;
+
+INDEXSTORE_PUBLIC unsigned
+indexstore_format_version(void);
+
+typedef void *indexstore_t;
+
+INDEXSTORE_PUBLIC indexstore_t
+indexstore_store_create(const char *store_path, indexstore_error_t *error);
+
+INDEXSTORE_PUBLIC void
+indexstore_store_dispose(indexstore_t);
+
+#if INDEXSTORE_HAS_BLOCKS
+INDEXSTORE_PUBLIC bool
+indexstore_store_units_apply(indexstore_t, unsigned sorted,
+                             bool(^applier)(indexstore_string_ref_t unit_name));
+#endif
+
+typedef void *indexstore_unit_event_notification_t;
+typedef void *indexstore_unit_event_t;
+
+INDEXSTORE_PUBLIC size_t
+indexstore_unit_event_notification_get_events_count(indexstore_unit_event_notification_t);
+
+INDEXSTORE_PUBLIC indexstore_unit_event_t
+indexstore_unit_event_notification_get_event(indexstore_unit_event_notification_t, size_t index);
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_event_notification_is_initial(indexstore_unit_event_notification_t);
+
+typedef enum {
+  INDEXSTORE_UNIT_EVENT_ADDED = 1,
+  INDEXSTORE_UNIT_EVENT_REMOVED = 2,
+  INDEXSTORE_UNIT_EVENT_MODIFIED = 3,
+  INDEXSTORE_UNIT_EVENT_DIRECTORY_DELETED = 4,
+} indexstore_unit_event_kind_t;
+
+INDEXSTORE_PUBLIC indexstore_unit_event_kind_t
+indexstore_unit_event_get_kind(indexstore_unit_event_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_event_get_unit_name(indexstore_unit_event_t);
+
+INDEXSTORE_PUBLIC timespec
+indexstore_unit_event_get_modification_time(indexstore_unit_event_t);
+
+#if INDEXSTORE_HAS_BLOCKS
+typedef void (^indexstore_unit_event_handler_t)(indexstore_unit_event_notification_t);
+
+INDEXSTORE_PUBLIC void
+indexstore_store_set_unit_event_handler(indexstore_t,
+                                        indexstore_unit_event_handler_t handler);
+#endif
+
+typedef struct {
+  /// If true, \c indexstore_store_start_unit_event_listening will block until
+  /// the initial set of units is passed to the unit event handler, otherwise
+  /// the function will return and the initial set will be passed asynchronously.
+  bool wait_initial_sync;
+} indexstore_unit_event_listen_options_t;
+
+INDEXSTORE_PUBLIC bool
+indexstore_store_start_unit_event_listening(indexstore_t,
+                                            indexstore_unit_event_listen_options_t *,
+                                            size_t listen_options_struct_size,
+                                            indexstore_error_t *error);
+
+INDEXSTORE_PUBLIC void
+indexstore_store_stop_unit_event_listening(indexstore_t);
+
+INDEXSTORE_PUBLIC void
+indexstore_store_discard_unit(indexstore_t, const char *unit_name);
+
+INDEXSTORE_PUBLIC void
+indexstore_store_discard_record(indexstore_t, const char *record_name);
+
+INDEXSTORE_PUBLIC void
+indexstore_store_purge_stale_data(indexstore_t);
+
+/// Determines the unit name from the \c output_path and writes it out in the
+/// \c name_buf buffer. It doesn't write more than \c buf_size.
+/// \returns the length of the name. If this is larger than \c buf_size, the
+/// caller should call the function again with a buffer of the appropriate size.
+INDEXSTORE_PUBLIC size_t
+indexstore_store_get_unit_name_from_output_path(indexstore_t store,
+                                                const char *output_path,
+                                                char *name_buf,
+                                                size_t buf_size);
+
+/// \returns true if an error occurred, false otherwise.
+INDEXSTORE_PUBLIC bool
+indexstore_store_get_unit_modification_time(indexstore_t store,
+                                            const char *unit_name,
+                                            int64_t *seconds,
+                                            int64_t *nanoseconds,
+                                            indexstore_error_t *error);
+
+typedef void *indexstore_symbol_t;
+
+typedef enum {
+  INDEXSTORE_SYMBOL_KIND_UNKNOWN = 0,
+  INDEXSTORE_SYMBOL_KIND_MODULE = 1,
+  INDEXSTORE_SYMBOL_KIND_NAMESPACE = 2,
+  INDEXSTORE_SYMBOL_KIND_NAMESPACEALIAS = 3,
+  INDEXSTORE_SYMBOL_KIND_MACRO = 4,
+  INDEXSTORE_SYMBOL_KIND_ENUM = 5,
+  INDEXSTORE_SYMBOL_KIND_STRUCT = 6,
+  INDEXSTORE_SYMBOL_KIND_CLASS = 7,
+  INDEXSTORE_SYMBOL_KIND_PROTOCOL = 8,
+  INDEXSTORE_SYMBOL_KIND_EXTENSION = 9,
+  INDEXSTORE_SYMBOL_KIND_UNION = 10,
+  INDEXSTORE_SYMBOL_KIND_TYPEALIAS = 11,
+  INDEXSTORE_SYMBOL_KIND_FUNCTION = 12,
+  INDEXSTORE_SYMBOL_KIND_VARIABLE = 13,
+  INDEXSTORE_SYMBOL_KIND_FIELD = 14,
+  INDEXSTORE_SYMBOL_KIND_ENUMCONSTANT = 15,
+  INDEXSTORE_SYMBOL_KIND_INSTANCEMETHOD = 16,
+  INDEXSTORE_SYMBOL_KIND_CLASSMETHOD = 17,
+  INDEXSTORE_SYMBOL_KIND_STATICMETHOD = 18,
+  INDEXSTORE_SYMBOL_KIND_INSTANCEPROPERTY = 19,
+  INDEXSTORE_SYMBOL_KIND_CLASSPROPERTY = 20,
+  INDEXSTORE_SYMBOL_KIND_STATICPROPERTY = 21,
+  INDEXSTORE_SYMBOL_KIND_CONSTRUCTOR = 22,
+  INDEXSTORE_SYMBOL_KIND_DESTRUCTOR = 23,
+  INDEXSTORE_SYMBOL_KIND_CONVERSIONFUNCTION = 24,
+  INDEXSTORE_SYMBOL_KIND_PARAMETER = 25,
+  INDEXSTORE_SYMBOL_KIND_USING = 26,
+
+  INDEXSTORE_SYMBOL_KIND_COMMENTTAG = 1000,
+} indexstore_symbol_kind_t;
+
+typedef enum {
+  INDEXSTORE_SYMBOL_SUBKIND_NONE = 0,
+  INDEXSTORE_SYMBOL_SUBKIND_CXXCOPYCONSTRUCTOR = 1,
+  INDEXSTORE_SYMBOL_SUBKIND_CXXMOVECONSTRUCTOR = 2,
+  INDEXSTORE_SYMBOL_SUBKIND_ACCESSORGETTER = 3,
+  INDEXSTORE_SYMBOL_SUBKIND_ACCESSORSETTER = 4,
+  INDEXSTORE_SYMBOL_SUBKIND_USINGTYPENAME = 5,
+  INDEXSTORE_SYMBOL_SUBKIND_USINGVALUE = 6,
+
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORWILLSET = 1000,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORDIDSET = 1001,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORADDRESSOR = 1002,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORMUTABLEADDRESSOR = 1003,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFSTRUCT = 1004,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFCLASS = 1005,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFENUM = 1006,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFPROTOCOL = 1007,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTPREFIXOPERATOR = 1008,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTPOSTFIXOPERATOR = 1009,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTINFIXOPERATOR = 1010,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTSUBSCRIPT = 1011,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTASSOCIATEDTYPE = 1012,
+  INDEXSTORE_SYMBOL_SUBKIND_SWIFTGENERICTYPEPARAM = 1013,
+} indexstore_symbol_subkind_t;
+
+typedef enum {
+  INDEXSTORE_SYMBOL_PROPERTY_GENERIC                          = 1 << 0,
+  INDEXSTORE_SYMBOL_PROPERTY_TEMPLATE_PARTIAL_SPECIALIZATION  = 1 << 1,
+  INDEXSTORE_SYMBOL_PROPERTY_TEMPLATE_SPECIALIZATION          = 1 << 2,
+  INDEXSTORE_SYMBOL_PROPERTY_UNITTEST                         = 1 << 3,
+  INDEXSTORE_SYMBOL_PROPERTY_IBANNOTATED                      = 1 << 4,
+  INDEXSTORE_SYMBOL_PROPERTY_IBOUTLETCOLLECTION               = 1 << 5,
+  INDEXSTORE_SYMBOL_PROPERTY_GKINSPECTABLE                    = 1 << 6,
+  INDEXSTORE_SYMBOL_PROPERTY_LOCAL                            = 1 << 7,
+} indexstore_symbol_property_t;
+
+typedef enum {
+  INDEXSTORE_SYMBOL_LANG_C = 0,
+  INDEXSTORE_SYMBOL_LANG_OBJC = 1,
+  INDEXSTORE_SYMBOL_LANG_CXX = 2,
+
+  INDEXSTORE_SYMBOL_LANG_SWIFT = 100,
+} indexstore_symbol_language_t;
+
+typedef enum {
+  INDEXSTORE_SYMBOL_ROLE_DECLARATION = 1 << 0,
+  INDEXSTORE_SYMBOL_ROLE_DEFINITION  = 1 << 1,
+  INDEXSTORE_SYMBOL_ROLE_REFERENCE   = 1 << 2,
+  INDEXSTORE_SYMBOL_ROLE_READ        = 1 << 3,
+  INDEXSTORE_SYMBOL_ROLE_WRITE       = 1 << 4,
+  INDEXSTORE_SYMBOL_ROLE_CALL        = 1 << 5,
+  INDEXSTORE_SYMBOL_ROLE_DYNAMIC     = 1 << 6,
+  INDEXSTORE_SYMBOL_ROLE_ADDRESSOF   = 1 << 7,
+  INDEXSTORE_SYMBOL_ROLE_IMPLICIT    = 1 << 8,
+
+  // Relation roles.
+  INDEXSTORE_SYMBOL_ROLE_REL_CHILDOF     = 1 << 9,
+  INDEXSTORE_SYMBOL_ROLE_REL_BASEOF      = 1 << 10,
+  INDEXSTORE_SYMBOL_ROLE_REL_OVERRIDEOF  = 1 << 11,
+  INDEXSTORE_SYMBOL_ROLE_REL_RECEIVEDBY  = 1 << 12,
+  INDEXSTORE_SYMBOL_ROLE_REL_CALLEDBY    = 1 << 13,
+  INDEXSTORE_SYMBOL_ROLE_REL_EXTENDEDBY  = 1 << 14,
+  INDEXSTORE_SYMBOL_ROLE_REL_ACCESSOROF  = 1 << 15,
+  INDEXSTORE_SYMBOL_ROLE_REL_CONTAINEDBY = 1 << 16,
+  INDEXSTORE_SYMBOL_ROLE_REL_IBTYPEOF    = 1 << 17,
+  INDEXSTORE_SYMBOL_ROLE_REL_SPECIALIZATIONOF = 1 << 18,
+} indexstore_symbol_role_t;
+
+INDEXSTORE_PUBLIC indexstore_symbol_language_t
+indexstore_symbol_get_language(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC indexstore_symbol_kind_t
+indexstore_symbol_get_kind(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC indexstore_symbol_subkind_t
+indexstore_symbol_get_subkind(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC uint64_t
+indexstore_symbol_get_properties(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC uint64_t
+indexstore_symbol_get_roles(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC uint64_t
+indexstore_symbol_get_related_roles(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_symbol_get_name(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_symbol_get_usr(indexstore_symbol_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_symbol_get_codegen_name(indexstore_symbol_t);
+
+typedef void *indexstore_symbol_relation_t;
+
+INDEXSTORE_PUBLIC uint64_t
+indexstore_symbol_relation_get_roles(indexstore_symbol_relation_t);
+
+INDEXSTORE_PUBLIC indexstore_symbol_t
+indexstore_symbol_relation_get_symbol(indexstore_symbol_relation_t);
+
+typedef void *indexstore_occurrence_t;
+
+INDEXSTORE_PUBLIC indexstore_symbol_t
+indexstore_occurrence_get_symbol(indexstore_occurrence_t);
+
+#if INDEXSTORE_HAS_BLOCKS
+INDEXSTORE_PUBLIC bool
+indexstore_occurrence_relations_apply(indexstore_occurrence_t,
+                      bool(^applier)(indexstore_symbol_relation_t symbol_rel));
+#endif
+
+INDEXSTORE_PUBLIC uint64_t
+indexstore_occurrence_get_roles(indexstore_occurrence_t);
+
+INDEXSTORE_PUBLIC void
+indexstore_occurrence_get_line_col(indexstore_occurrence_t,
+                              unsigned *line, unsigned *column);
+
+typedef void *indexstore_record_reader_t;
+
+INDEXSTORE_PUBLIC indexstore_record_reader_t
+indexstore_record_reader_create(indexstore_t store, const char *record_name,
+                                indexstore_error_t *error);
+
+INDEXSTORE_PUBLIC void
+indexstore_record_reader_dispose(indexstore_record_reader_t);
+
+#if INDEXSTORE_HAS_BLOCKS
+/// Goes through the symbol data and passes symbols to \c receiver, for the
+/// symbol data that \c filter returns true on.
+///
+/// This allows allocating memory only for the record symbols that the caller is
+/// interested in.
+INDEXSTORE_PUBLIC bool
+indexstore_record_reader_search_symbols(indexstore_record_reader_t,
+    bool(^filter)(indexstore_symbol_t symbol, bool *stop),
+    void(^receiver)(indexstore_symbol_t symbol));
+
+/// \param nocache if true, avoids allocating memory for the symbols.
+/// Useful when the caller does not intend to keep \c indexstore_record_reader_t
+/// for more queries.
+INDEXSTORE_PUBLIC bool
+indexstore_record_reader_symbols_apply(indexstore_record_reader_t,
+                                       bool nocache,
+                                    bool(^applier)(indexstore_symbol_t symbol));
+
+INDEXSTORE_PUBLIC bool
+indexstore_record_reader_occurrences_apply(indexstore_record_reader_t,
+                                 bool(^applier)(indexstore_occurrence_t occur));
+
+INDEXSTORE_PUBLIC bool
+indexstore_record_reader_occurrences_in_line_range_apply(indexstore_record_reader_t,
+                                                         unsigned line_start,
+                                                         unsigned line_count,
+                                 bool(^applier)(indexstore_occurrence_t occur));
+
+/// \param symbols if non-zero \c symbols_count, indicates the list of symbols
+/// that we want to get occurrences for. An empty array indicates that we want
+/// occurrences for all symbols.
+/// \param related_symbols Same as \c symbols but for related symbols.
+INDEXSTORE_PUBLIC bool
+indexstore_record_reader_occurrences_of_symbols_apply(indexstore_record_reader_t,
+        indexstore_symbol_t *symbols, size_t symbols_count,
+        indexstore_symbol_t *related_symbols, size_t related_symbols_count,
+        bool(^applier)(indexstore_occurrence_t occur));
+#endif
+
+
+typedef void *indexstore_unit_reader_t;
+
+INDEXSTORE_PUBLIC indexstore_unit_reader_t
+indexstore_unit_reader_create(indexstore_t store, const char *unit_name,
+                              indexstore_error_t *error);
+
+INDEXSTORE_PUBLIC void
+indexstore_unit_reader_dispose(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_provider_identifier(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_provider_version(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC void
+indexstore_unit_reader_get_modification_time(indexstore_unit_reader_t,
+                                             int64_t *seconds,
+                                             int64_t *nanoseconds);
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_reader_is_system_unit(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_reader_is_module_unit(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_reader_is_debug_compilation(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_reader_has_main_file(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_main_file(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_module_name(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_working_dir(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_output_file(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_sysroot_path(indexstore_unit_reader_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_reader_get_target(indexstore_unit_reader_t);
+
+typedef void *indexstore_unit_dependency_t;
+typedef void *indexstore_unit_include_t;
+
+typedef enum {
+  INDEXSTORE_UNIT_DEPENDENCY_UNIT = 1,
+  INDEXSTORE_UNIT_DEPENDENCY_RECORD = 2,
+  INDEXSTORE_UNIT_DEPENDENCY_FILE = 3,
+} indexstore_unit_dependency_kind_t;
+
+INDEXSTORE_PUBLIC indexstore_unit_dependency_kind_t
+indexstore_unit_dependency_get_kind(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_dependency_is_system(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_dependency_get_filepath(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_dependency_get_modulename(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_dependency_get_name(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC time_t
+indexstore_unit_dependency_get_modification_time(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC size_t
+indexstore_unit_dependency_get_file_size(indexstore_unit_dependency_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_include_get_source_path(indexstore_unit_include_t);
+
+INDEXSTORE_PUBLIC indexstore_string_ref_t
+indexstore_unit_include_get_target_path(indexstore_unit_include_t);
+
+INDEXSTORE_PUBLIC unsigned
+indexstore_unit_include_get_source_line(indexstore_unit_include_t);
+
+#if INDEXSTORE_HAS_BLOCKS
+INDEXSTORE_PUBLIC bool
+indexstore_unit_reader_dependencies_apply(indexstore_unit_reader_t,
+                             bool(^applier)(indexstore_unit_dependency_t));
+
+INDEXSTORE_PUBLIC bool
+indexstore_unit_reader_includes_apply(indexstore_unit_reader_t,
+                             bool(^applier)(indexstore_unit_include_t));
+
+#endif
+
+INDEXSTORE_END_DECLS
+
+#endif
diff --git a/lib/APINotes/APINotesFormat.h b/lib/APINotes/APINotesFormat.h
index e69de29bb2..3e1b2d56ec 100644
--- a/lib/APINotes/APINotesFormat.h
+++ b/lib/APINotes/APINotesFormat.h
@@ -0,0 +1,308 @@
+//===--- APINotesFormat.h - The internals of API notes files ----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Contains various constants and helper types to deal with API notes
+/// files.
+///
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_CLANG_API_NOTES_FORMAT_H
+#define LLVM_CLANG_API_NOTES_FORMAT_H
+
+#include "llvm/ADT/DenseMapInfo.h"
+#include "llvm/ADT/Hashing.h"
+#include "llvm/ADT/PointerEmbeddedInt.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/Bitcode/RecordLayout.h"
+
+namespace clang {
+namespace api_notes {
+
+using namespace llvm;
+
+/// Magic number for API notes files.
+const unsigned char API_NOTES_SIGNATURE[] = { 0xE2, 0x9C, 0xA8, 0x01 };
+
+/// API notes file major version number.
+///
+const uint16_t VERSION_MAJOR = 0;
+
+/// API notes file minor version number.
+///
+/// When the format changes IN ANY WAY, this number should be incremented.
+const uint16_t VERSION_MINOR = 24;  // EnumExtensibility+FlagEnum
+
+using IdentifierID = PointerEmbeddedInt<unsigned, 31>;
+using IdentifierIDField = BCVBR<16>;
+
+using SelectorID = PointerEmbeddedInt<unsigned, 31>;
+using SelectorIDField = BCVBR<16>;
+
+using StoredContextID = PointerEmbeddedInt<unsigned, 31>;
+
+/// The various types of blocks that can occur within a API notes file.
+///
+/// These IDs must \em not be renumbered or reordered without incrementing
+/// VERSION_MAJOR.
+enum BlockID {
+  /// The control block, which contains all of the information that needs to
+  /// be validated prior to committing to loading the API notes file.
+  ///
+  /// \sa control_block
+  CONTROL_BLOCK_ID = llvm::bitc::FIRST_APPLICATION_BLOCKID,
+
+  /// The identifier data block, which maps identifier strings to IDs.
+  IDENTIFIER_BLOCK_ID,
+
+  /// The Objective-C context data block, which contains information about
+  /// Objective-C classes and protocols.
+  OBJC_CONTEXT_BLOCK_ID,
+
+  /// The Objective-C property data block, which maps Objective-C
+  /// (class name, property name) pairs to information about the
+  /// property.
+  OBJC_PROPERTY_BLOCK_ID,
+
+  /// The Objective-C property data block, which maps Objective-C
+  /// (class name, selector, is_instance_method) tuples to information
+  /// about the method.
+  OBJC_METHOD_BLOCK_ID,
+
+  /// The Objective-C selector data block, which maps Objective-C
+  /// selector names (# of pieces, identifier IDs) to the selector ID
+  /// used in other tables.
+  OBJC_SELECTOR_BLOCK_ID,
+
+  /// The global variables data block, which maps global variable names to
+  /// information about the global variable.
+  GLOBAL_VARIABLE_BLOCK_ID,
+
+  /// The (global) functions data block, which maps global function names to
+  /// information about the global function.
+  GLOBAL_FUNCTION_BLOCK_ID,
+
+  /// The tag data block, which maps tag names to information about
+  /// the tags.
+  TAG_BLOCK_ID,
+
+  /// The typedef data block, which maps typedef names to information about
+  /// the typedefs.
+  TYPEDEF_BLOCK_ID,
+
+  /// The enum constant data block, which maps enumerator names to
+  /// information about the enumerators.
+  ENUM_CONSTANT_BLOCK_ID,
+};
+
+namespace control_block {
+  // These IDs must \em not be renumbered or reordered without incrementing
+  // VERSION_MAJOR.
+  enum {
+    METADATA = 1,
+    MODULE_NAME = 2,
+    MODULE_OPTIONS = 3,
+    SOURCE_FILE = 4,
+  };
+
+  using MetadataLayout = BCRecordLayout<
+    METADATA, // ID
+    BCFixed<16>, // Module format major version
+    BCFixed<16>  // Module format minor version
+  >;
+
+  using ModuleNameLayout = BCRecordLayout<
+    MODULE_NAME,
+    BCBlob       // Module name
+  >;
+
+  using ModuleOptionsLayout = BCRecordLayout<
+    MODULE_OPTIONS,
+    BCFixed<1> // SwiftInferImportAsMember
+  >;
+
+  using SourceFileLayout = BCRecordLayout<
+    SOURCE_FILE,
+    BCVBR<16>, // file size
+    BCVBR<16>  // creation time
+  >;
+}
+
+namespace identifier_block {
+  enum {
+    IDENTIFIER_DATA = 1,
+  };
+
+  using IdentifierDataLayout = BCRecordLayout<
+    IDENTIFIER_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from identifier strings to decl kinds / decl IDs
+  >;
+}
+
+namespace objc_context_block {
+  enum {
+    OBJC_CONTEXT_ID_DATA = 1,
+    OBJC_CONTEXT_INFO_DATA = 2,
+  };
+
+  using ObjCContextIDLayout = BCRecordLayout<
+    OBJC_CONTEXT_ID_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from ObjC class names/protocol (as IDs) to context IDs
+  >;
+
+  using ObjCContextInfoLayout = BCRecordLayout<
+    OBJC_CONTEXT_INFO_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob      // map from ObjC context IDs to context information.
+  >;
+}
+
+namespace objc_property_block {
+  enum {
+    OBJC_PROPERTY_DATA = 1,
+  };
+
+  using ObjCPropertyDataLayout = BCRecordLayout<
+    OBJC_PROPERTY_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from ObjC (class name, property name) pairs to ObjC
+            // property information
+  >;
+}
+
+namespace objc_method_block {
+  enum {
+    OBJC_METHOD_DATA = 1,
+  };
+
+  using ObjCMethodDataLayout = BCRecordLayout<
+    OBJC_METHOD_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from ObjC (class names, selector,
+            // is-instance-method) tuples to ObjC method information
+  >;
+}
+
+namespace objc_selector_block {
+  enum {
+    OBJC_SELECTOR_DATA = 1,
+  };
+
+  using ObjCSelectorDataLayout = BCRecordLayout<
+    OBJC_SELECTOR_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from (# pieces, identifier IDs) to Objective-C selector ID.
+  >;
+}
+
+namespace global_variable_block {
+  enum {
+    GLOBAL_VARIABLE_DATA = 1
+  };
+
+  using GlobalVariableDataLayout = BCRecordLayout<
+    GLOBAL_VARIABLE_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from name to global variable information
+  >;
+}
+
+namespace global_function_block {
+  enum {
+    GLOBAL_FUNCTION_DATA = 1
+  };
+
+  using GlobalFunctionDataLayout = BCRecordLayout<
+    GLOBAL_FUNCTION_DATA,  // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob  // map from name to global function information
+  >;
+}
+
+namespace tag_block {
+  enum {
+    TAG_DATA = 1
+  };
+
+  using TagDataLayout = BCRecordLayout<
+    TAG_DATA,   // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob      // map from name to tag information
+  >;
+};
+
+namespace typedef_block {
+  enum {
+    TYPEDEF_DATA = 1
+  };
+
+  using TypedefDataLayout = BCRecordLayout<
+    TYPEDEF_DATA,   // record ID
+    BCVBR<16>,  // table offset within the blob (see below)
+    BCBlob      // map from name to typedef information
+  >;
+};
+
+namespace enum_constant_block {
+  enum {
+    ENUM_CONSTANT_DATA = 1
+  };
+
+  using EnumConstantDataLayout = BCRecordLayout<
+    ENUM_CONSTANT_DATA,  // record ID
+    BCVBR<16>,           // table offset within the blob (see below)
+    BCBlob               // map from name to enumerator information
+  >;
+}
+
+/// A stored Objective-C selector.
+struct StoredObjCSelector {
+  unsigned NumPieces;
+  llvm::SmallVector<IdentifierID, 2> Identifiers;
+};
+
+} // end namespace api_notes
+} // end namespace clang
+
+namespace llvm {
+  template<>
+  struct DenseMapInfo<clang::api_notes::StoredObjCSelector> {
+    typedef DenseMapInfo<unsigned> UnsignedInfo;
+
+    static inline clang::api_notes::StoredObjCSelector getEmptyKey() {
+      return clang::api_notes::StoredObjCSelector{ 
+               UnsignedInfo::getEmptyKey(), { } };
+    }
+
+    static inline clang::api_notes::StoredObjCSelector getTombstoneKey() {
+      return clang::api_notes::StoredObjCSelector{ 
+               UnsignedInfo::getTombstoneKey(), { } };
+    }
+    
+    static unsigned getHashValue(
+                      const clang::api_notes::StoredObjCSelector& value) {
+      auto hash = llvm::hash_value(value.NumPieces);
+      hash = hash_combine(hash, value.Identifiers.size());
+      for (auto piece : value.Identifiers)
+        hash = hash_combine(hash, static_cast<unsigned>(piece));
+      // FIXME: Mix upper/lower 32-bit values together to produce
+      // unsigned rather than truncating.
+      return hash;
+    }
+
+    static bool isEqual(const clang::api_notes::StoredObjCSelector &lhs, 
+                        const clang::api_notes::StoredObjCSelector &rhs) {
+      return lhs.NumPieces == rhs.NumPieces && 
+             lhs.Identifiers == rhs.Identifiers;
+    }
+  };
+}
+
+#endif // LLVM_CLANG_API_NOTES_FORMAT_H
diff --git a/lib/APINotes/APINotesManager.cpp b/lib/APINotes/APINotesManager.cpp
index e69de29bb2..6fc0fda087 100644
--- a/lib/APINotes/APINotesManager.cpp
+++ b/lib/APINotes/APINotesManager.cpp
@@ -0,0 +1,426 @@
+//===--- APINotesManager.cpp - Manage API Notes Files ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//  This file implements the APINotesManager class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/APINotes/APINotesManager.h"
+#include "clang/APINotes/APINotesOptions.h"
+#include "clang/APINotes/APINotesReader.h"
+#include "clang/APINotes/APINotesYAMLCompiler.h"
+#include "clang/Basic/DiagnosticIDs.h"
+#include "clang/Basic/FileManager.h"
+#include "clang/Basic/LangOptions.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Basic/SourceMgrAdapter.h"
+#include "clang/Basic/Version.h"
+#include "llvm/ADT/APInt.h"
+#include "llvm/ADT/Hashing.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/ADT/SetVector.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/PrettyStackTrace.h"
+#include <sys/stat.h>
+
+using namespace clang;
+using namespace api_notes;
+
+#define DEBUG_TYPE "API Notes"
+STATISTIC(NumHeaderAPINotes,
+          "non-framework API notes files loaded");
+STATISTIC(NumPublicFrameworkAPINotes,
+          "framework public API notes loaded");
+STATISTIC(NumPrivateFrameworkAPINotes,
+          "framework private API notes loaded");
+STATISTIC(NumFrameworksSearched,
+          "frameworks searched");
+STATISTIC(NumDirectoriesSearched,
+          "header directories searched");
+STATISTIC(NumDirectoryCacheHits,
+          "directory cache hits");
+
+namespace {
+  /// Prints two successive strings, which much be kept alive as long as the
+  /// PrettyStackTrace entry.
+  class PrettyStackTraceDoubleString : public llvm::PrettyStackTraceEntry {
+    StringRef First, Second;
+  public:
+    PrettyStackTraceDoubleString(StringRef first, StringRef second)
+        : First(first), Second(second) {}
+    void print(raw_ostream &OS) const override {
+      OS << First << Second;
+    }
+  };
+}
+
+APINotesManager::APINotesManager(SourceManager &sourceMgr,
+                                 const LangOptions &langOpts)
+  : SourceMgr(sourceMgr), ImplicitAPINotes(langOpts.APINotes) { }
+
+APINotesManager::~APINotesManager() {
+  // Free the API notes readers.
+  for (const auto &entry : Readers) {
+    if (auto reader = entry.second.dyn_cast<APINotesReader *>()) {
+      delete reader;
+    }
+  }
+
+  delete CurrentModuleReaders[0];
+  delete CurrentModuleReaders[1];
+}
+
+std::unique_ptr<APINotesReader>
+APINotesManager::loadAPINotes(const FileEntry *apiNotesFile) {
+  PrettyStackTraceDoubleString trace("Loading API notes from ",
+                                     apiNotesFile->getName());
+
+  // If the API notes file is already in the binary form, load it directly.
+  StringRef apiNotesFileName = apiNotesFile->getName();
+  StringRef apiNotesFileExt = llvm::sys::path::extension(apiNotesFileName);
+  if (!apiNotesFileExt.empty() &&
+      apiNotesFileExt.substr(1) == BINARY_APINOTES_EXTENSION) {
+    auto compiledFileID = SourceMgr.createFileID(apiNotesFile, SourceLocation(), SrcMgr::C_User);
+
+    // Load the file.
+    auto buffer = SourceMgr.getBuffer(compiledFileID, SourceLocation());
+    if (!buffer) return nullptr;
+
+    // Load the binary form.
+    return APINotesReader::getUnmanaged(buffer, SwiftVersion);
+  }
+
+  // Open the source file.
+  auto sourceFileID = SourceMgr.createFileID(apiNotesFile, SourceLocation(), SrcMgr::C_User);
+  auto sourceBuffer = SourceMgr.getBuffer(sourceFileID, SourceLocation());
+  if (!sourceBuffer) return nullptr;
+
+  // Compile the API notes source into a buffer.
+  // FIXME: Either propagate OSType through or, better yet, improve the binary
+  // APINotes format to maintain complete availability information.
+  // FIXME: We don't even really need to go through the binary format at all;
+  // we're just going to immediately deserialize it again.
+  llvm::SmallVector<char, 1024> apiNotesBuffer;
+  std::unique_ptr<llvm::MemoryBuffer> compiledBuffer;
+  {
+    SourceMgrAdapter srcMgrAdapter(SourceMgr, SourceMgr.getDiagnostics(),
+                                   diag::err_apinotes_message,
+                                   diag::warn_apinotes_message,
+                                   diag::note_apinotes_message,
+                                   apiNotesFile);
+    llvm::raw_svector_ostream OS(apiNotesBuffer);
+    if (api_notes::compileAPINotes(sourceBuffer->getBuffer(),
+                                   SourceMgr.getFileEntryForID(sourceFileID),
+                                   OS,
+                                   api_notes::OSType::Absent,
+                                   srcMgrAdapter.getDiagHandler(),
+                                   srcMgrAdapter.getDiagContext()))
+      return nullptr;
+
+    // Make a copy of the compiled form into the buffer.
+    compiledBuffer = llvm::MemoryBuffer::getMemBufferCopy(
+               StringRef(apiNotesBuffer.data(), apiNotesBuffer.size()));
+  }
+
+  // Load the binary form we just compiled.
+  auto reader = APINotesReader::get(std::move(compiledBuffer), SwiftVersion);
+  assert(reader && "Could not load the API notes we just generated?");
+  return reader;
+}
+
+bool APINotesManager::loadAPINotes(const DirectoryEntry *HeaderDir,
+                                   const FileEntry *APINotesFile) {
+  assert(Readers.find(HeaderDir) == Readers.end());
+  if (auto reader = loadAPINotes(APINotesFile)) {
+    Readers[HeaderDir] = reader.release();
+    return false;
+  }
+
+  Readers[HeaderDir] = nullptr;
+  return true;
+}
+
+const FileEntry *APINotesManager::findAPINotesFile(const DirectoryEntry *directory,
+                                                   StringRef basename,
+                                                   bool wantPublic) {
+  FileManager &fileMgr = SourceMgr.getFileManager();
+
+  llvm::SmallString<128> path;
+  path += directory->getName();
+
+  unsigned pathLen = path.size();
+
+  StringRef basenameSuffix = "";
+  if (!wantPublic) basenameSuffix = "_private";
+
+  // Look for a binary API notes file.
+  llvm::sys::path::append(path, 
+    llvm::Twine(basename) + basenameSuffix + "." + BINARY_APINOTES_EXTENSION);
+  if (const FileEntry *binaryFile = fileMgr.getFile(path))
+    return binaryFile;
+
+  // Go back to the original path.
+  path.resize(pathLen);
+
+  // Look for the source API notes file.
+  llvm::sys::path::append(path, 
+    llvm::Twine(basename) + basenameSuffix + "." + SOURCE_APINOTES_EXTENSION);
+  return fileMgr.getFile(path);
+}
+
+const DirectoryEntry *APINotesManager::loadFrameworkAPINotes(
+                        llvm::StringRef FrameworkPath,
+                        llvm::StringRef FrameworkName,
+                        bool Public) {
+  FileManager &FileMgr = SourceMgr.getFileManager();
+  
+  llvm::SmallString<128> Path;
+  Path += FrameworkPath;
+  unsigned FrameworkNameLength = Path.size();
+
+  // Form the path to the APINotes file.
+  llvm::sys::path::append(Path, "APINotes");
+  if (Public)
+    llvm::sys::path::append(Path,
+                            (llvm::Twine(FrameworkName) + "."
+                              + SOURCE_APINOTES_EXTENSION));
+  else
+    llvm::sys::path::append(Path,
+                            (llvm::Twine(FrameworkName) + "_private."
+                              + SOURCE_APINOTES_EXTENSION));
+
+  // Try to open the APINotes file.
+  const FileEntry *APINotesFile = FileMgr.getFile(Path);
+  if (!APINotesFile)
+    return nullptr;
+
+  // Form the path to the corresponding header directory.
+  Path.resize(FrameworkNameLength);
+  if (Public)
+    llvm::sys::path::append(Path, "Headers");
+  else
+    llvm::sys::path::append(Path, "PrivateHeaders");
+
+  // Try to access the header directory.
+  const DirectoryEntry *HeaderDir = FileMgr.getDirectory(Path);
+  if (!HeaderDir)
+    return nullptr;
+
+  // Try to load the API notes.
+  if (loadAPINotes(HeaderDir, APINotesFile))
+    return nullptr;
+
+  // Success: return the header directory.
+  if (Public)
+    ++NumPublicFrameworkAPINotes;
+  else
+    ++NumPrivateFrameworkAPINotes;
+  return HeaderDir;
+}
+
+bool APINotesManager::loadCurrentModuleAPINotes(
+                   const Module *module,
+                   bool lookInModule,
+                   ArrayRef<std::string> searchPaths) {
+  assert(!CurrentModuleReaders[0] &&
+         "Already loaded API notes for the current module?");
+
+  FileManager &fileMgr = SourceMgr.getFileManager();
+  auto moduleName = module->getTopLevelModuleName();
+
+  // First, look relative to the module itself.
+  if (lookInModule) {
+    bool foundAny = false;
+    unsigned numReaders = 0;
+
+    // Local function to try loading an API notes file in the given directory.
+    auto tryAPINotes = [&](const DirectoryEntry *dir, bool wantPublic) {
+      if (auto file = findAPINotesFile(dir, moduleName, wantPublic)) {
+        foundAny = true;
+
+        // Try to load the API notes file.
+        CurrentModuleReaders[numReaders] = loadAPINotes(file).release();
+        if (CurrentModuleReaders[numReaders])
+          ++numReaders;
+      }
+    };
+
+    if (module->IsFramework) {
+      // For frameworks, we search in the "Headers" or "PrivateHeaders"
+      // subdirectory.
+      llvm::SmallString<128> path;
+      path += module->Directory->getName();
+      unsigned pathLen = path.size();
+
+      llvm::sys::path::append(path, "Headers");
+      if (auto apinotesDir = fileMgr.getDirectory(path))
+        tryAPINotes(apinotesDir, /*wantPublic=*/true);
+
+      path.resize(pathLen);
+      llvm::sys::path::append(path, "PrivateHeaders");
+      if (auto privateAPINotesDir = fileMgr.getDirectory(path))
+        tryAPINotes(privateAPINotesDir, /*wantPublic=*/false);
+    } else {
+      tryAPINotes(module->Directory, /*wantPublic=*/true);
+      tryAPINotes(module->Directory, /*wantPublic=*/false);
+    }
+
+    if (foundAny)
+      return numReaders > 0;
+  }
+
+  // Second, look for API notes for this module in the module API
+  // notes search paths.
+  for (const auto &searchPath : searchPaths) {
+    if (auto searchDir = fileMgr.getDirectory(searchPath)) {
+      if (auto file = findAPINotesFile(searchDir, moduleName)) {
+        CurrentModuleReaders[0] = loadAPINotes(file).release();
+        return !getCurrentModuleReaders().empty();
+      }
+    }
+  }
+
+  // Didn't find any API notes.
+  return false;
+}
+
+llvm::SmallVector<APINotesReader *, 2> APINotesManager::findAPINotes(SourceLocation Loc) {
+  llvm::SmallVector<APINotesReader *, 2> Results;
+
+  // If there are readers for the current module, return them.
+  if (!getCurrentModuleReaders().empty()) {
+    Results.append(getCurrentModuleReaders().begin(), getCurrentModuleReaders().end());
+    return Results;
+  }
+
+  // If we're not allowed to implicitly load API notes files, we're done.
+  if (!ImplicitAPINotes) return Results;
+
+  // If we don't have source location information, we're done.
+  if (Loc.isInvalid()) return Results;
+
+  // API notes are associated with the expansion location. Retrieve the
+  // file for this location.
+  SourceLocation ExpansionLoc = SourceMgr.getExpansionLoc(Loc);
+  FileID ID = SourceMgr.getFileID(ExpansionLoc);
+  if (ID.isInvalid()) return Results;
+  const FileEntry *File = SourceMgr.getFileEntryForID(ID);
+  if (!File) return Results;
+
+  // Look for API notes in the directory corresponding to this file, or one of
+  // its its parent directories.
+  const DirectoryEntry *Dir = File->getDir();
+  FileManager &FileMgr = SourceMgr.getFileManager();
+  llvm::SetVector<const DirectoryEntry *,
+                  SmallVector<const DirectoryEntry *, 4>,
+                  llvm::SmallPtrSet<const DirectoryEntry *, 4>> DirsVisited;
+  do {
+    // Look for an API notes reader for this header search directory.
+    auto Known = Readers.find(Dir);
+
+    // If we already know the answer, chase it.
+    if (Known != Readers.end()) {
+      ++NumDirectoryCacheHits;
+
+      // We've been redirected to another directory for answers. Follow it.
+      if (auto OtherDir = Known->second.dyn_cast<const DirectoryEntry *>()) {
+        DirsVisited.insert(Dir);
+        Dir = OtherDir;
+        continue;
+      }
+
+      // We have the answer.
+      if (auto Reader = Known->second.dyn_cast<APINotesReader *>())
+        Results.push_back(Reader);
+      break;
+    }
+
+    // Look for API notes corresponding to this directory.
+    StringRef Path = Dir->getName();
+    if (llvm::sys::path::extension(Path) == ".framework") {
+      // If this is a framework directory, check whether there are API notes
+      // in the APINotes subdirectory.
+      auto FrameworkName = llvm::sys::path::stem(Path);
+      ++NumFrameworksSearched;
+
+      // Look for API notes for both the public and private headers.
+      const DirectoryEntry *PublicDir
+        = loadFrameworkAPINotes(Path, FrameworkName, /*Public=*/true);
+      const DirectoryEntry *PrivateDir
+        = loadFrameworkAPINotes(Path, FrameworkName, /*Public=*/false);
+
+      if (PublicDir || PrivateDir) {
+        // We found API notes: don't ever look past the framework directory.
+        Readers[Dir] = nullptr;
+
+        // Pretend we found the result in the public or private directory,
+        // as appropriate. All headers should be in one of those two places,
+        // but be defensive here.
+        if (!DirsVisited.empty()) {
+          if (DirsVisited.back() == PublicDir) {
+            DirsVisited.pop_back();
+            Dir = PublicDir;
+          } else if (DirsVisited.back() == PrivateDir) {
+            DirsVisited.pop_back();
+            Dir = PrivateDir;
+          }
+        }
+
+        // Grab the result.
+        if (auto Reader = Readers[Dir].dyn_cast<APINotesReader *>())
+          Results.push_back(Reader);
+        break;
+      }
+    } else {
+      // Look for an APINotes file in this directory.
+      llvm::SmallString<128> APINotesPath;
+      APINotesPath += Dir->getName();
+      llvm::sys::path::append(APINotesPath,
+                              (llvm::Twine("APINotes.")
+                                 + SOURCE_APINOTES_EXTENSION));
+
+      // If there is an API notes file here, try to load it.
+      ++NumDirectoriesSearched;
+      if (const FileEntry *APINotesFile = FileMgr.getFile(APINotesPath)) {
+        if (!loadAPINotes(Dir, APINotesFile)) {
+          ++NumHeaderAPINotes;
+          if (auto Reader = Readers[Dir].dyn_cast<APINotesReader *>())
+            Results.push_back(Reader);
+          break;
+        }
+      }
+    }
+
+    // We didn't find anything. Look at the parent directory.
+    if (!DirsVisited.insert(Dir)) {
+      Dir = 0;
+      break;
+    }
+
+    StringRef ParentPath = llvm::sys::path::parent_path(Path);
+    while (llvm::sys::path::stem(ParentPath) == "..") {
+      ParentPath = llvm::sys::path::parent_path(ParentPath);
+    }
+    if (ParentPath.empty()) {
+      Dir = nullptr;
+    } else {
+      Dir = FileMgr.getDirectory(ParentPath);
+    }
+  } while (Dir);
+
+  // Path compression for all of the directories we visited, redirecting
+  // them to the directory we ended on. If no API notes were found, the
+  // resulting directory will be NULL, indicating no API notes.
+  for (const auto Visited : DirsVisited) {
+    Readers[Visited] = Dir;
+  }
+
+  return Results;
+}
diff --git a/lib/APINotes/APINotesReader.cpp b/lib/APINotes/APINotesReader.cpp
index e69de29bb2..64b36e6a69 100644
--- a/lib/APINotes/APINotesReader.cpp
+++ b/lib/APINotes/APINotesReader.cpp
@@ -0,0 +1,1892 @@
+//===--- APINotesReader.cpp - Side Car Reader --------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the \c APINotesReader class that reads source
+// API notes data providing additional information about source code as
+// a separate input, such as the non-nil/nilable annotations for
+// method parameters.
+//
+//===----------------------------------------------------------------------===//
+#include "clang/APINotes/APINotesReader.h"
+#include "APINotesFormat.h"
+#include "llvm/Bitcode/BitstreamReader.h"
+#include "llvm/Support/EndianStream.h"
+#include "llvm/Support/OnDiskHashTable.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/Hashing.h"
+#include "llvm/ADT/StringExtras.h"
+
+using namespace clang;
+using namespace api_notes;
+using namespace llvm::support;
+using namespace llvm;
+
+namespace {
+  /// Deserialize a version tuple.
+  VersionTuple readVersionTuple(const uint8_t *&data) {
+    uint8_t numVersions = (*data++) & 0x03;
+
+    unsigned major = endian::readNext<uint32_t, little, unaligned>(data);
+    if (numVersions == 0)
+      return VersionTuple(major);
+
+    unsigned minor = endian::readNext<uint32_t, little, unaligned>(data);
+    if (numVersions == 1)
+      return VersionTuple(major, minor);
+
+    unsigned subminor = endian::readNext<uint32_t, little, unaligned>(data);
+    if (numVersions == 2)
+      return VersionTuple(major, minor, subminor);
+
+    unsigned build = endian::readNext<uint32_t, little, unaligned>(data);
+    return VersionTuple(major, minor, subminor, build);
+  }
+
+  /// An on-disk hash table whose data is versioned based on the Swift version.
+  template<typename Derived, typename KeyType, typename UnversionedDataType>
+  class VersionedTableInfo {
+  public:
+    using internal_key_type = KeyType;
+    using external_key_type = KeyType;
+    using data_type = SmallVector<std::pair<VersionTuple, UnversionedDataType>, 1>;
+    using hash_value_type = size_t;
+    using offset_type = unsigned;
+
+    internal_key_type GetInternalKey(external_key_type key) {
+      return key;
+    }
+
+    external_key_type GetExternalKey(internal_key_type key) {
+      return key;
+    }
+
+    hash_value_type ComputeHash(internal_key_type key) {
+      return static_cast<size_t>(llvm::hash_value(key));
+    }
+
+    static bool EqualKey(internal_key_type lhs, internal_key_type rhs) {
+      return lhs == rhs;
+    }
+
+    static std::pair<unsigned, unsigned>
+    ReadKeyDataLength(const uint8_t *&data) {
+      unsigned keyLength = endian::readNext<uint16_t, little, unaligned>(data);
+      unsigned dataLength = endian::readNext<uint16_t, little, unaligned>(data);
+      return { keyLength, dataLength };
+    }
+
+    static data_type ReadData(internal_key_type key, const uint8_t *data,
+                              unsigned length) {
+      unsigned numElements = endian::readNext<uint16_t, little, unaligned>(data);
+      data_type result;
+      result.reserve(numElements);
+      for (unsigned i = 0; i != numElements; ++i) {
+        auto version = readVersionTuple(data);
+        auto dataBefore = data; (void)dataBefore;
+        auto unversionedData = Derived::readUnversioned(key, data);
+        assert(data != dataBefore
+               && "Unversioned data reader didn't move pointer");
+        result.push_back({version, unversionedData});
+      }
+      return result;
+    }
+  };
+
+
+  /// Read serialized CommonEntityInfo.
+  void readCommonEntityInfo(const uint8_t *&data, CommonEntityInfo &info) {
+    uint8_t unavailableBits = *data++;
+    info.Unavailable = (unavailableBits >> 1) & 0x01;
+    info.UnavailableInSwift = unavailableBits & 0x01;
+    if ((unavailableBits >> 2) & 0x01)
+      info.setSwiftPrivate(static_cast<bool>((unavailableBits >> 3) & 0x01));
+
+    unsigned msgLength = endian::readNext<uint16_t, little, unaligned>(data);
+    info.UnavailableMsg
+      = std::string(reinterpret_cast<const char *>(data),
+                    reinterpret_cast<const char *>(data) + msgLength);
+    data += msgLength;
+
+    unsigned swiftNameLength
+      = endian::readNext<uint16_t, little, unaligned>(data);
+    info.SwiftName
+      = std::string(reinterpret_cast<const char *>(data),
+                    reinterpret_cast<const char *>(data) + swiftNameLength);
+    data += swiftNameLength;
+  }
+
+  /// Read serialized CommonTypeInfo.
+  void readCommonTypeInfo(const uint8_t *&data, CommonTypeInfo &info) {
+    readCommonEntityInfo(data, info);
+
+    unsigned swiftBridgeLength =
+        endian::readNext<uint16_t, little, unaligned>(data);
+    if (swiftBridgeLength > 0) {
+      info.setSwiftBridge(
+        std::string(reinterpret_cast<const char *>(data), swiftBridgeLength-1));
+      data += swiftBridgeLength-1;
+    }
+
+    unsigned errorDomainLength =
+      endian::readNext<uint16_t, little, unaligned>(data);
+    if (errorDomainLength > 0) {
+      info.setNSErrorDomain(
+        std::string(reinterpret_cast<const char *>(data), errorDomainLength-1));
+      data += errorDomainLength-1;
+    }
+  }
+
+  /// Used to deserialize the on-disk identifier table.
+  class IdentifierTableInfo {
+  public:
+    using internal_key_type = StringRef;
+    using external_key_type = StringRef;
+    using data_type = IdentifierID;
+    using hash_value_type = uint32_t;
+    using offset_type = unsigned;
+
+    internal_key_type GetInternalKey(external_key_type key) {
+      return key;
+    }
+
+    external_key_type GetExternalKey(internal_key_type key) {
+      return key;
+    }
+
+    hash_value_type ComputeHash(internal_key_type key) {
+      return llvm::HashString(key);
+    }
+    
+    static bool EqualKey(internal_key_type lhs, internal_key_type rhs) {
+      return lhs == rhs;
+    }
+    
+    static std::pair<unsigned, unsigned> 
+    ReadKeyDataLength(const uint8_t *&data) {
+      unsigned keyLength = endian::readNext<uint16_t, little, unaligned>(data);
+      unsigned dataLength = endian::readNext<uint16_t, little, unaligned>(data);
+      return { keyLength, dataLength };
+    }
+    
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      return StringRef(reinterpret_cast<const char *>(data), length);
+    }
+    
+    static data_type ReadData(internal_key_type key, const uint8_t *data,
+                              unsigned length) {
+      return endian::readNext<uint32_t, little, unaligned>(data);
+    }
+  };
+
+  /// Used to deserialize the on-disk Objective-C class table.
+  class ObjCContextIDTableInfo {
+  public:
+    // identifier ID, is-protocol
+    using internal_key_type = std::pair<unsigned, char>;
+    using external_key_type = internal_key_type;
+    using data_type = unsigned;
+    using hash_value_type = size_t;
+    using offset_type = unsigned;
+
+    internal_key_type GetInternalKey(external_key_type key) {
+      return key;
+    }
+
+    external_key_type GetExternalKey(internal_key_type key) {
+      return key;
+    }
+
+    hash_value_type ComputeHash(internal_key_type key) {
+      return static_cast<size_t>(llvm::hash_value(key));
+    }
+    
+    static bool EqualKey(internal_key_type lhs, internal_key_type rhs) {
+      return lhs == rhs;
+    }
+    
+    static std::pair<unsigned, unsigned> 
+    ReadKeyDataLength(const uint8_t *&data) {
+      unsigned keyLength = endian::readNext<uint16_t, little, unaligned>(data);
+      unsigned dataLength = endian::readNext<uint16_t, little, unaligned>(data);
+      return { keyLength, dataLength };
+    }
+    
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto nameID
+        = endian::readNext<uint32_t, little, unaligned>(data);
+      auto isProtocol = endian::readNext<uint8_t, little, unaligned>(data);
+      return { nameID, isProtocol };
+    }
+    
+    static data_type ReadData(internal_key_type key, const uint8_t *data,
+                              unsigned length) {
+      return endian::readNext<uint32_t, little, unaligned>(data);
+    }
+  };
+
+  /// Used to deserialize the on-disk Objective-C property table.
+  class ObjCContextInfoTableInfo
+    : public VersionedTableInfo<ObjCContextInfoTableInfo,
+                                unsigned,
+                                ObjCContextInfo>
+  {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      return endian::readNext<uint32_t, little, unaligned>(data);
+    }
+    
+    static ObjCContextInfo readUnversioned(internal_key_type key,
+                                           const uint8_t *&data) {
+      ObjCContextInfo info;
+      readCommonTypeInfo(data, info);
+      uint8_t payload = *data++;
+
+      if (payload & 0x01)
+        info.setHasDesignatedInits(true);
+      payload = payload >> 1;
+
+      if (payload & 0x4)
+        info.setDefaultNullability(static_cast<NullabilityKind>(payload&0x03));
+      payload >>= 3;
+
+      if (payload & (1 << 1))
+        info.setSwiftObjCMembers(payload & 1);
+      payload >>= 2;
+
+      if (payload & (1 << 1))
+        info.setSwiftImportAsNonGeneric(payload & 1);
+
+      return info;
+    }
+  };
+
+  /// Read serialized VariableInfo.
+  void readVariableInfo(const uint8_t *&data, VariableInfo &info) {
+    readCommonEntityInfo(data, info);
+    if (*data++) {
+      info.setNullabilityAudited(static_cast<NullabilityKind>(*data));
+    }
+    ++data;
+
+    auto typeLen
+      = endian::readNext<uint16_t, little, unaligned>(data);
+    info.setType(std::string(data, data + typeLen));
+    data += typeLen;
+  }
+
+  /// Used to deserialize the on-disk Objective-C property table.
+  class ObjCPropertyTableInfo
+    : public VersionedTableInfo<ObjCPropertyTableInfo,
+                                std::tuple<unsigned, unsigned, char>,
+                                ObjCPropertyInfo>
+  {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto classID = endian::readNext<uint32_t, little, unaligned>(data);
+      auto nameID = endian::readNext<uint32_t, little, unaligned>(data);
+      char isInstance = endian::readNext<uint8_t, little, unaligned>(data);
+      return std::make_tuple(classID, nameID, isInstance);
+    }
+    
+    static ObjCPropertyInfo readUnversioned(internal_key_type key,
+                                            const uint8_t *&data) {
+      ObjCPropertyInfo info;
+      readVariableInfo(data, info);
+      uint8_t flags = *data++;
+      if (flags & (1 << 0))
+        info.setSwiftImportAsAccessors(flags & (1 << 1));
+      return info;
+    }
+  };
+
+  /// Read serialized ParamInfo.
+  void readParamInfo(const uint8_t *&data, ParamInfo &info) {
+    readVariableInfo(data, info);
+
+    uint8_t payload = endian::readNext<uint8_t, little, unaligned>(data);
+    if (auto rawConvention = payload & 0x7) {
+      auto convention = static_cast<RetainCountConventionKind>(rawConvention-1);
+      info.setRetainCountConvention(convention);
+    }
+    payload >>= 3;
+    if (payload & 0x01) {
+      info.setNoEscape(payload & 0x02);
+    }
+    payload >>= 2; assert(payload == 0 && "Bad API notes");
+  }
+
+  /// Read serialized FunctionInfo.
+  void readFunctionInfo(const uint8_t *&data, FunctionInfo &info) {
+    readCommonEntityInfo(data, info);
+
+    uint8_t payload = endian::readNext<uint8_t, little, unaligned>(data);
+    if (auto rawConvention = payload & 0x7) {
+      auto convention = static_cast<RetainCountConventionKind>(rawConvention-1);
+      info.setRetainCountConvention(convention);
+    }
+    payload >>= 3;
+    info.NullabilityAudited = payload & 0x1;
+    payload >>= 1; assert(payload == 0 && "Bad API notes");
+
+    info.NumAdjustedNullable
+      = endian::readNext<uint8_t, little, unaligned>(data);
+    info.NullabilityPayload
+      = endian::readNext<uint64_t, little, unaligned>(data);
+
+    unsigned numParams = endian::readNext<uint16_t, little, unaligned>(data);
+    while (numParams > 0) {
+      ParamInfo pi;
+      readParamInfo(data, pi);
+      info.Params.push_back(pi);
+      --numParams;
+    }
+
+    unsigned resultTypeLen
+      = endian::readNext<uint16_t, little, unaligned>(data);
+    info.ResultType = std::string(data, data + resultTypeLen);
+    data += resultTypeLen;
+  }
+
+  /// Used to deserialize the on-disk Objective-C method table.
+  class ObjCMethodTableInfo
+    : public VersionedTableInfo<ObjCMethodTableInfo,
+                                std::tuple<unsigned, unsigned, char>,
+                                ObjCMethodInfo> {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto classID = endian::readNext<uint32_t, little, unaligned>(data);
+      auto selectorID = endian::readNext<uint32_t, little, unaligned>(data);
+      auto isInstance = endian::readNext<uint8_t, little, unaligned>(data);
+      return internal_key_type{ classID, selectorID, isInstance };
+    }
+    
+    static ObjCMethodInfo readUnversioned(internal_key_type key,
+                                          const uint8_t *&data) {
+      ObjCMethodInfo info;
+      uint8_t payload = *data++;
+      info.Required = payload & 0x01;
+      payload >>= 1;
+      info.DesignatedInit = payload & 0x01;
+      payload >>= 1;
+
+      readFunctionInfo(data, info);
+      return info;
+    }
+  };
+
+  /// Used to deserialize the on-disk Objective-C selector table.
+  class ObjCSelectorTableInfo {
+  public:
+    using internal_key_type = StoredObjCSelector; 
+    using external_key_type = internal_key_type;
+    using data_type = SelectorID;
+    using hash_value_type = unsigned;
+    using offset_type = unsigned;
+
+    internal_key_type GetInternalKey(external_key_type key) {
+      return key;
+    }
+
+    external_key_type GetExternalKey(internal_key_type key) {
+      return key;
+    }
+
+    hash_value_type ComputeHash(internal_key_type key) {
+      return llvm::DenseMapInfo<StoredObjCSelector>::getHashValue(key);
+    }
+    
+    static bool EqualKey(internal_key_type lhs, internal_key_type rhs) {
+      return llvm::DenseMapInfo<StoredObjCSelector>::isEqual(lhs, rhs);
+    }
+    
+    static std::pair<unsigned, unsigned> 
+    ReadKeyDataLength(const uint8_t *&data) {
+      unsigned keyLength = endian::readNext<uint16_t, little, unaligned>(data);
+      unsigned dataLength = endian::readNext<uint16_t, little, unaligned>(data);
+      return { keyLength, dataLength };
+    }
+    
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      internal_key_type key;
+      key.NumPieces = endian::readNext<uint16_t, little, unaligned>(data);
+      unsigned numIdents = (length - sizeof(uint16_t)) / sizeof(uint32_t);
+      for (unsigned i = 0; i != numIdents; ++i) {
+        key.Identifiers.push_back(
+          endian::readNext<uint32_t, little, unaligned>(data));
+      }
+      return key;
+    }
+    
+    static data_type ReadData(internal_key_type key, const uint8_t *data,
+                              unsigned length) {
+      return endian::readNext<uint32_t, little, unaligned>(data);
+    }
+  };
+
+  /// Used to deserialize the on-disk global variable table.
+  class GlobalVariableTableInfo
+    : public VersionedTableInfo<GlobalVariableTableInfo, unsigned,
+                                GlobalVariableInfo> {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto nameID = endian::readNext<uint32_t, little, unaligned>(data);
+      return nameID;
+    }
+
+    static GlobalVariableInfo readUnversioned(internal_key_type key,
+                                              const uint8_t *&data) {
+      GlobalVariableInfo info;
+      readVariableInfo(data, info);
+      return info;
+    }
+  };
+
+  /// Used to deserialize the on-disk global function table.
+  class GlobalFunctionTableInfo
+    : public VersionedTableInfo<GlobalFunctionTableInfo, unsigned,
+                                GlobalFunctionInfo> {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto nameID = endian::readNext<uint32_t, little, unaligned>(data);
+      return nameID;
+    }
+    
+    static GlobalFunctionInfo readUnversioned(internal_key_type key,
+                                              const uint8_t *&data) {
+      GlobalFunctionInfo info;
+      readFunctionInfo(data, info);
+      return info;
+    }
+  };
+
+  /// Used to deserialize the on-disk enumerator table.
+  class EnumConstantTableInfo
+    : public VersionedTableInfo<EnumConstantTableInfo, unsigned,
+                                EnumConstantInfo> {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto nameID = endian::readNext<uint32_t, little, unaligned>(data);
+      return nameID;
+    }
+    
+    static EnumConstantInfo readUnversioned(internal_key_type key,
+                                            const uint8_t *&data) {
+      EnumConstantInfo info;
+      readCommonEntityInfo(data, info);
+      return info;
+    }
+  };
+
+  /// Used to deserialize the on-disk tag table.
+  class TagTableInfo
+    : public VersionedTableInfo<TagTableInfo, unsigned, TagInfo> {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto nameID = endian::readNext<IdentifierID, little, unaligned>(data);
+      return nameID;
+    }
+    
+    static TagInfo readUnversioned(internal_key_type key,
+                                   const uint8_t *&data) {
+      TagInfo info;
+
+      uint8_t payload = *data++;
+      if (payload & 1) {
+        info.setFlagEnum(payload & 2);
+      }
+      payload >>= 2;
+      if (payload > 0) {
+        info.EnumExtensibility =
+            static_cast<EnumExtensibilityKind>((payload & 0x3) - 1);
+      }
+
+      readCommonTypeInfo(data, info);
+      return info;
+    }
+  };
+
+  /// Used to deserialize the on-disk typedef table.
+  class TypedefTableInfo
+    : public VersionedTableInfo<TypedefTableInfo, unsigned, TypedefInfo> {
+  public:
+    static internal_key_type ReadKey(const uint8_t *data, unsigned length) {
+      auto nameID = endian::readNext<IdentifierID, little, unaligned>(data);
+      return nameID;
+    }
+
+    static TypedefInfo readUnversioned(internal_key_type key,
+                                       const uint8_t *&data) {
+      TypedefInfo info;
+
+      uint8_t payload = *data++;
+      if (payload > 0) {
+        info.SwiftWrapper = static_cast<SwiftWrapperKind>((payload & 0x3) - 1);
+      }
+
+      readCommonTypeInfo(data, info);
+      return info;
+    }
+  };
+} // end anonymous namespace
+
+class APINotesReader::Implementation {
+public:
+  /// The input buffer for the API notes data.
+  llvm::MemoryBuffer *InputBuffer;
+
+  /// Whether we own the input buffer.
+  bool OwnsInputBuffer;
+
+  /// The Swift version to use for filtering.
+  VersionTuple SwiftVersion;
+
+  /// The name of the module that we read from the control block.
+  std::string ModuleName;
+
+  // The size and modification time of the source file from
+  // which this API notes file was created, if known.
+  Optional<std::pair<off_t, time_t>> SourceFileSizeAndModTime;
+
+  /// Various options and attributes for the module
+  ModuleOptions ModuleOpts;
+
+  using SerializedIdentifierTable =
+      llvm::OnDiskIterableChainedHashTable<IdentifierTableInfo>;
+
+  /// The identifier table.
+  std::unique_ptr<SerializedIdentifierTable> IdentifierTable;
+
+  using SerializedObjCContextIDTable =
+      llvm::OnDiskIterableChainedHashTable<ObjCContextIDTableInfo>;
+
+  /// The Objective-C context ID table.
+  std::unique_ptr<SerializedObjCContextIDTable> ObjCContextIDTable;
+
+  using SerializedObjCContextInfoTable =
+    llvm::OnDiskIterableChainedHashTable<ObjCContextInfoTableInfo>;
+
+  /// The Objective-C context info table.
+  std::unique_ptr<SerializedObjCContextInfoTable> ObjCContextInfoTable;
+
+  using SerializedObjCPropertyTable =
+      llvm::OnDiskIterableChainedHashTable<ObjCPropertyTableInfo>;
+
+  /// The Objective-C property table.
+  std::unique_ptr<SerializedObjCPropertyTable> ObjCPropertyTable;
+
+  using SerializedObjCMethodTable =
+      llvm::OnDiskIterableChainedHashTable<ObjCMethodTableInfo>;
+
+  /// The Objective-C method table.
+  std::unique_ptr<SerializedObjCMethodTable> ObjCMethodTable;
+
+  using SerializedObjCSelectorTable =
+      llvm::OnDiskIterableChainedHashTable<ObjCSelectorTableInfo>;
+
+  /// The Objective-C selector table.
+  std::unique_ptr<SerializedObjCSelectorTable> ObjCSelectorTable;
+
+  using SerializedGlobalVariableTable =
+      llvm::OnDiskIterableChainedHashTable<GlobalVariableTableInfo>;
+
+  /// The global variable table.
+  std::unique_ptr<SerializedGlobalVariableTable> GlobalVariableTable;
+
+  using SerializedGlobalFunctionTable =
+      llvm::OnDiskIterableChainedHashTable<GlobalFunctionTableInfo>;
+
+  /// The global function table.
+  std::unique_ptr<SerializedGlobalFunctionTable> GlobalFunctionTable;
+
+  using SerializedEnumConstantTable =
+      llvm::OnDiskIterableChainedHashTable<EnumConstantTableInfo>;
+
+  /// The enumerator table.
+  std::unique_ptr<SerializedEnumConstantTable> EnumConstantTable;
+
+  using SerializedTagTable =
+      llvm::OnDiskIterableChainedHashTable<TagTableInfo>;
+
+  /// The tag table.
+  std::unique_ptr<SerializedTagTable> TagTable;
+
+  using SerializedTypedefTable =
+      llvm::OnDiskIterableChainedHashTable<TypedefTableInfo>;
+
+  /// The typedef table.
+  std::unique_ptr<SerializedTypedefTable> TypedefTable;
+
+  /// Retrieve the identifier ID for the given string, or an empty
+  /// optional if the string is unknown.
+  Optional<IdentifierID> getIdentifier(StringRef str);
+
+  /// Retrieve the selector ID for the given selector, or an empty
+  /// optional if the string is unknown.
+  Optional<SelectorID> getSelector(ObjCSelectorRef selector);
+
+  bool readControlBlock(llvm::BitstreamCursor &cursor, 
+                        SmallVectorImpl<uint64_t> &scratch);
+  bool readIdentifierBlock(llvm::BitstreamCursor &cursor,
+                           SmallVectorImpl<uint64_t> &scratch);
+  bool readObjCContextBlock(llvm::BitstreamCursor &cursor,
+                            SmallVectorImpl<uint64_t> &scratch);
+  bool readObjCPropertyBlock(llvm::BitstreamCursor &cursor, 
+                             SmallVectorImpl<uint64_t> &scratch);
+  bool readObjCMethodBlock(llvm::BitstreamCursor &cursor, 
+                             SmallVectorImpl<uint64_t> &scratch);
+  bool readObjCSelectorBlock(llvm::BitstreamCursor &cursor, 
+                             SmallVectorImpl<uint64_t> &scratch);
+  bool readGlobalVariableBlock(llvm::BitstreamCursor &cursor,
+                               SmallVectorImpl<uint64_t> &scratch);
+  bool readGlobalFunctionBlock(llvm::BitstreamCursor &cursor,
+                               SmallVectorImpl<uint64_t> &scratch);
+  bool readEnumConstantBlock(llvm::BitstreamCursor &cursor,
+                             SmallVectorImpl<uint64_t> &scratch);
+  bool readTagBlock(llvm::BitstreamCursor &cursor,
+                    SmallVectorImpl<uint64_t> &scratch);
+  bool readTypedefBlock(llvm::BitstreamCursor &cursor,
+                        SmallVectorImpl<uint64_t> &scratch);
+};
+
+Optional<IdentifierID> APINotesReader::Implementation::getIdentifier(
+                         StringRef str) {
+  if (!IdentifierTable)
+    return None;
+
+  if (str.empty())
+    return IdentifierID(0);
+
+  auto known = IdentifierTable->find(str);
+  if (known == IdentifierTable->end())
+    return None;
+
+  return *known;
+}
+
+Optional<SelectorID> APINotesReader::Implementation::getSelector(
+                       ObjCSelectorRef selector) {
+  if (!ObjCSelectorTable || !IdentifierTable)
+    return None;
+
+  // Translate the identifiers.
+  StoredObjCSelector key;
+  key.NumPieces = selector.NumPieces;
+  for (auto ident : selector.Identifiers) {
+    if (auto identID = getIdentifier(ident)) {
+      key.Identifiers.push_back(*identID);
+    } else {
+      return None;
+    }
+  }
+
+  auto known = ObjCSelectorTable->find(key);
+  if (known == ObjCSelectorTable->end())
+    return None;
+
+  return *known;
+
+}
+
+bool APINotesReader::Implementation::readControlBlock(
+       llvm::BitstreamCursor &cursor,
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(CONTROL_BLOCK_ID))
+    return true;
+
+  bool sawMetadata = false;
+  
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown metadata sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case control_block::METADATA:
+      // Already saw metadata.
+      if (sawMetadata)
+        return true;
+
+      if (scratch[0] != VERSION_MAJOR || scratch[1] != VERSION_MINOR)
+        return true;
+
+      sawMetadata = true;
+      break;
+
+    case control_block::MODULE_NAME:
+      ModuleName = blobData.str();
+      break;
+
+    case control_block::MODULE_OPTIONS:
+      ModuleOpts.SwiftInferImportAsMember = (scratch.front() & 1) != 0;
+      break;
+
+    case control_block::SOURCE_FILE:
+      SourceFileSizeAndModTime = { scratch[0], scratch[1] };
+      break;
+
+    default:
+      // Unknown metadata record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return !sawMetadata;
+}
+
+bool APINotesReader::Implementation::readIdentifierBlock(
+       llvm::BitstreamCursor &cursor,
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(IDENTIFIER_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case identifier_block::IDENTIFIER_DATA: {
+      // Already saw identifier table.
+      if (IdentifierTable)
+        return true;
+
+      uint32_t tableOffset;
+      identifier_block::IdentifierDataLayout::readRecord(scratch, tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      IdentifierTable.reset(
+        SerializedIdentifierTable::Create(base + tableOffset,
+                                          base + sizeof(uint32_t),
+                                          base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readObjCContextBlock(
+       llvm::BitstreamCursor &cursor,
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(OBJC_CONTEXT_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case objc_context_block::OBJC_CONTEXT_ID_DATA: {
+      // Already saw Objective-C context ID table.
+      if (ObjCContextIDTable)
+        return true;
+
+      uint32_t tableOffset;
+      objc_context_block::ObjCContextIDLayout::readRecord(scratch, tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      ObjCContextIDTable.reset(
+        SerializedObjCContextIDTable::Create(base + tableOffset,
+                                             base + sizeof(uint32_t),
+                                             base));
+      break;
+    }
+
+    case objc_context_block::OBJC_CONTEXT_INFO_DATA: {
+      // Already saw Objective-C context info table.
+      if (ObjCContextInfoTable)
+        return true;
+
+      uint32_t tableOffset;
+      objc_context_block::ObjCContextInfoLayout::readRecord(scratch,
+                                                            tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      ObjCContextInfoTable.reset(
+        SerializedObjCContextInfoTable::Create(base + tableOffset,
+                                               base + sizeof(uint32_t),
+                                               base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readObjCPropertyBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(OBJC_PROPERTY_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case objc_property_block::OBJC_PROPERTY_DATA: {
+      // Already saw Objective-C property table.
+      if (ObjCPropertyTable)
+        return true;
+
+      uint32_t tableOffset;
+      objc_property_block::ObjCPropertyDataLayout::readRecord(scratch, 
+                                                              tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      ObjCPropertyTable.reset(
+        SerializedObjCPropertyTable::Create(base + tableOffset,
+                                            base + sizeof(uint32_t),
+                                            base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readObjCMethodBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(OBJC_METHOD_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case objc_method_block::OBJC_METHOD_DATA: {
+      // Already saw Objective-C method table.
+      if (ObjCMethodTable)
+        return true;
+
+      uint32_t tableOffset;
+      objc_method_block::ObjCMethodDataLayout::readRecord(scratch, tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      ObjCMethodTable.reset(
+        SerializedObjCMethodTable::Create(base + tableOffset,
+                                          base + sizeof(uint32_t),
+                                          base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readObjCSelectorBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(OBJC_SELECTOR_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case objc_selector_block::OBJC_SELECTOR_DATA: {
+      // Already saw Objective-C selector table.
+      if (ObjCSelectorTable)
+        return true;
+
+      uint32_t tableOffset;
+      objc_selector_block::ObjCSelectorDataLayout::readRecord(scratch, 
+                                                              tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      ObjCSelectorTable.reset(
+        SerializedObjCSelectorTable::Create(base + tableOffset,
+                                          base + sizeof(uint32_t),
+                                          base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readGlobalVariableBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(GLOBAL_VARIABLE_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case global_variable_block::GLOBAL_VARIABLE_DATA: {
+      // Already saw global variable table.
+      if (GlobalVariableTable)
+        return true;
+
+      uint32_t tableOffset;
+      global_variable_block::GlobalVariableDataLayout::readRecord(scratch,
+                                                                  tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      GlobalVariableTable.reset(
+        SerializedGlobalVariableTable::Create(base + tableOffset,
+                                              base + sizeof(uint32_t),
+                                              base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readGlobalFunctionBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(GLOBAL_FUNCTION_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case global_function_block::GLOBAL_FUNCTION_DATA: {
+      // Already saw global function table.
+      if (GlobalFunctionTable)
+        return true;
+
+      uint32_t tableOffset;
+      global_function_block::GlobalFunctionDataLayout::readRecord(scratch,
+                                                                  tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      GlobalFunctionTable.reset(
+        SerializedGlobalFunctionTable::Create(base + tableOffset,
+                                              base + sizeof(uint32_t),
+                                              base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readEnumConstantBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(ENUM_CONSTANT_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case enum_constant_block::ENUM_CONSTANT_DATA: {
+      // Already saw enumerator table.
+      if (EnumConstantTable)
+        return true;
+
+      uint32_t tableOffset;
+      enum_constant_block::EnumConstantDataLayout::readRecord(scratch,
+                                                              tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      EnumConstantTable.reset(
+        SerializedEnumConstantTable::Create(base + tableOffset,
+                                            base + sizeof(uint32_t),
+                                            base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readTagBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(TAG_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case tag_block::TAG_DATA: {
+      // Already saw tag table.
+      if (TagTable)
+        return true;
+
+      uint32_t tableOffset;
+      tag_block::TagDataLayout::readRecord(scratch, tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      TagTable.reset(
+        SerializedTagTable::Create(base + tableOffset,
+                                   base + sizeof(uint32_t),
+                                   base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+bool APINotesReader::Implementation::readTypedefBlock(
+       llvm::BitstreamCursor &cursor, 
+       SmallVectorImpl<uint64_t> &scratch) {
+  if (cursor.EnterSubBlock(TYPEDEF_BLOCK_ID))
+    return true;
+
+  auto next = cursor.advance();
+  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
+    if (next.Kind == llvm::BitstreamEntry::Error)
+      return true;
+
+    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+      // Unknown sub-block, possibly for use by a future version of the
+      // API notes format.
+      if (cursor.SkipBlock())
+        return true;
+      
+      next = cursor.advance();
+      continue;
+    }
+
+    scratch.clear();
+    StringRef blobData;
+    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    switch (kind) {
+    case typedef_block::TYPEDEF_DATA: {
+      // Already saw typedef table.
+      if (TypedefTable)
+        return true;
+
+      uint32_t tableOffset;
+      typedef_block::TypedefDataLayout::readRecord(scratch, tableOffset);
+      auto base = reinterpret_cast<const uint8_t *>(blobData.data());
+
+      TypedefTable.reset(
+        SerializedTypedefTable::Create(base + tableOffset,
+                                       base + sizeof(uint32_t),
+                                       base));
+      break;
+    }
+
+    default:
+      // Unknown record, possibly for use by a future version of the
+      // module format.
+      break;
+    }
+
+    next = cursor.advance();
+  }
+
+  return false;
+}
+
+APINotesReader::APINotesReader(llvm::MemoryBuffer *inputBuffer, 
+                               bool ownsInputBuffer,
+                               VersionTuple swiftVersion,
+                               bool &failed) 
+  : Impl(*new Implementation)
+{
+  failed = false;
+
+  // Initialize the input buffer.
+  Impl.InputBuffer = inputBuffer;
+  Impl.OwnsInputBuffer = ownsInputBuffer;
+  Impl.SwiftVersion = swiftVersion;
+  llvm::BitstreamCursor cursor(*Impl.InputBuffer);
+
+  // Validate signature.
+  for (auto byte : API_NOTES_SIGNATURE) {
+    if (cursor.AtEndOfStream() || cursor.Read(8) != byte) {
+      failed = true;
+      return;
+    }
+  }
+
+  // Look at all of the blocks.
+  bool hasValidControlBlock = false;
+  SmallVector<uint64_t, 64> scratch;
+  while (!cursor.AtEndOfStream()) {
+    auto topLevelEntry = cursor.advance();
+    if (topLevelEntry.Kind != llvm::BitstreamEntry::SubBlock)
+      break;
+
+    switch (topLevelEntry.ID) {
+    case llvm::bitc::BLOCKINFO_BLOCK_ID:
+      if (!cursor.ReadBlockInfoBlock()) {
+        failed = true;
+        break;
+      }
+      break;
+
+    case CONTROL_BLOCK_ID:
+      // Only allow a single control block.
+      if (hasValidControlBlock || Impl.readControlBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+
+      hasValidControlBlock = true;
+      break;
+
+    case IDENTIFIER_BLOCK_ID:
+      if (!hasValidControlBlock || Impl.readIdentifierBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case OBJC_CONTEXT_BLOCK_ID:
+      if (!hasValidControlBlock || Impl.readObjCContextBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+
+      break;
+
+    case OBJC_PROPERTY_BLOCK_ID:
+      if (!hasValidControlBlock || 
+          Impl.readObjCPropertyBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case OBJC_METHOD_BLOCK_ID:
+      if (!hasValidControlBlock || Impl.readObjCMethodBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case OBJC_SELECTOR_BLOCK_ID:
+      if (!hasValidControlBlock || 
+          Impl.readObjCSelectorBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case GLOBAL_VARIABLE_BLOCK_ID:
+      if (!hasValidControlBlock || 
+          Impl.readGlobalVariableBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case GLOBAL_FUNCTION_BLOCK_ID:
+      if (!hasValidControlBlock || 
+          Impl.readGlobalFunctionBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case ENUM_CONSTANT_BLOCK_ID:
+      if (!hasValidControlBlock || 
+          Impl.readEnumConstantBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case TAG_BLOCK_ID:
+      if (!hasValidControlBlock || Impl.readTagBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    case TYPEDEF_BLOCK_ID:
+      if (!hasValidControlBlock || Impl.readTypedefBlock(cursor, scratch)) {
+        failed = true;
+        return;
+      }
+      break;
+
+    default:
+      // Unknown top-level block, possibly for use by a future version of the
+      // module format.
+      if (cursor.SkipBlock()) {
+        failed = true;
+        return;
+      }
+      break;
+    }
+  }
+
+  if (!cursor.AtEndOfStream()) {
+    failed = true;
+    return;
+  }
+}
+
+APINotesReader::~APINotesReader() {
+  if (Impl.OwnsInputBuffer)
+    delete Impl.InputBuffer;
+
+  delete &Impl;
+}
+
+std::unique_ptr<APINotesReader> 
+APINotesReader::get(std::unique_ptr<llvm::MemoryBuffer> inputBuffer,
+                    VersionTuple swiftVersion) {
+  bool failed = false;
+  std::unique_ptr<APINotesReader> 
+    reader(new APINotesReader(inputBuffer.release(), /*ownsInputBuffer=*/true,
+                              swiftVersion, failed));
+  if (failed)
+    return nullptr;
+
+  return reader;
+}
+
+std::unique_ptr<APINotesReader> 
+APINotesReader::getUnmanaged(llvm::MemoryBuffer *inputBuffer,
+                             VersionTuple swiftVersion) {
+  bool failed = false;
+  std::unique_ptr<APINotesReader> 
+    reader(new APINotesReader(inputBuffer, /*ownsInputBuffer=*/false,
+                              swiftVersion, failed));
+  if (failed)
+    return nullptr;
+
+  return reader;
+}
+
+StringRef APINotesReader::getModuleName() const {
+  return Impl.ModuleName;
+}
+
+Optional<std::pair<off_t, time_t>>
+APINotesReader::getSourceFileSizeAndModTime() const {
+  return Impl.SourceFileSizeAndModTime;
+}
+
+ModuleOptions APINotesReader::getModuleOptions() const {
+  return Impl.ModuleOpts;
+}
+
+template<typename T>
+APINotesReader::VersionedInfo<T>::VersionedInfo(
+    VersionTuple version,
+    SmallVector<std::pair<VersionTuple, T>, 1> results)
+  : Results(std::move(results)) {
+
+  assert(!Results.empty());
+  assert(std::is_sorted(Results.begin(), Results.end(),
+                        [](const std::pair<VersionTuple, T> &left,
+                           const std::pair<VersionTuple, T> &right) -> bool {
+    assert(left.first != right.first && "two entries for the same version");
+    return left.first < right.first;
+  }));
+
+  Selected = Results.size();
+  for (unsigned i = 0, n = Results.size(); i != n; ++i) {
+    if (version && Results[i].first >= version) {
+      // If the current version is "4", then entries for 4 are better than
+      // entries for 5, but both are valid. Because entries are sorted, we get
+      // that behavior by picking the first match.
+      Selected = i;
+      break;
+    }
+  }
+
+  // If we didn't find a match but we have an unversioned result, use the
+  // unversioned result. This will always be the first entry because we encode
+  // it as version 0.
+  if (Selected == Results.size() && Results[0].first.empty())
+    Selected = 0;
+}
+
+auto APINotesReader::lookupObjCClassID(StringRef name) -> Optional<ContextID> {
+  if (!Impl.ObjCContextIDTable)
+    return None;
+
+  Optional<IdentifierID> classID = Impl.getIdentifier(name);
+  if (!classID)
+    return None;
+
+  auto knownID = Impl.ObjCContextIDTable->find({*classID, '\0'});
+  if (knownID == Impl.ObjCContextIDTable->end())
+    return None;
+
+  return ContextID(*knownID);
+}
+
+auto APINotesReader::lookupObjCClassInfo(StringRef name)
+       -> VersionedInfo<ObjCContextInfo> {
+  if (!Impl.ObjCContextInfoTable)
+    return None;
+
+  Optional<ContextID> contextID = lookupObjCClassID(name);
+  if (!contextID)
+    return None;
+
+  auto knownInfo = Impl.ObjCContextInfoTable->find(contextID->Value);
+  if (knownInfo == Impl.ObjCContextInfoTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *knownInfo };
+}
+
+auto APINotesReader::lookupObjCProtocolID(StringRef name)
+       -> Optional<ContextID> {
+   if (!Impl.ObjCContextIDTable)
+     return None;
+
+   Optional<IdentifierID> classID = Impl.getIdentifier(name);
+   if (!classID)
+     return None;
+
+   auto knownID = Impl.ObjCContextIDTable->find({*classID, '\1'});
+   if (knownID == Impl.ObjCContextIDTable->end())
+     return None;
+
+   return ContextID(*knownID);
+}
+
+auto APINotesReader::lookupObjCProtocolInfo(StringRef name)
+       -> VersionedInfo<ObjCContextInfo> {
+   if (!Impl.ObjCContextInfoTable)
+     return None;
+
+   Optional<ContextID> contextID = lookupObjCProtocolID(name);
+   if (!contextID)
+     return None;
+
+   auto knownInfo = Impl.ObjCContextInfoTable->find(contextID->Value);
+   if (knownInfo == Impl.ObjCContextInfoTable->end())
+     return None;
+   
+   return { Impl.SwiftVersion, *knownInfo };
+}
+
+
+auto APINotesReader::lookupObjCProperty(ContextID contextID,
+                                        StringRef name,
+                                        bool isInstance)
+    -> VersionedInfo<ObjCPropertyInfo> {
+  if (!Impl.ObjCPropertyTable)
+    return None;
+
+  Optional<IdentifierID> propertyID = Impl.getIdentifier(name);
+  if (!propertyID)
+    return None;
+
+  auto known = Impl.ObjCPropertyTable->find(std::make_tuple(contextID.Value,
+                                                            *propertyID,
+                                                            (char)isInstance));
+  if (known == Impl.ObjCPropertyTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+auto APINotesReader::lookupObjCMethod(
+                                      ContextID contextID,
+                                      ObjCSelectorRef selector,
+                                      bool isInstanceMethod)
+    -> VersionedInfo<ObjCMethodInfo> {
+  if (!Impl.ObjCMethodTable)
+    return None;
+
+  Optional<SelectorID> selectorID = Impl.getSelector(selector);
+  if (!selectorID)
+    return None;
+
+  auto known = Impl.ObjCMethodTable->find(
+      ObjCMethodTableInfo::internal_key_type{
+          contextID.Value, *selectorID, isInstanceMethod});
+  if (known == Impl.ObjCMethodTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+auto APINotesReader::lookupGlobalVariable(
+                                          StringRef name)
+    -> VersionedInfo<GlobalVariableInfo> {
+  if (!Impl.GlobalVariableTable)
+    return None;
+
+  Optional<IdentifierID> nameID = Impl.getIdentifier(name);
+  if (!nameID)
+    return None;
+
+  auto known = Impl.GlobalVariableTable->find(*nameID);
+  if (known == Impl.GlobalVariableTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+auto APINotesReader::lookupGlobalFunction(StringRef name)
+    -> VersionedInfo<GlobalFunctionInfo> {
+  if (!Impl.GlobalFunctionTable)
+    return None;
+
+  Optional<IdentifierID> nameID = Impl.getIdentifier(name);
+  if (!nameID)
+    return None;
+
+  auto known = Impl.GlobalFunctionTable->find(*nameID);
+  if (known == Impl.GlobalFunctionTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+auto APINotesReader::lookupEnumConstant(StringRef name)
+    -> VersionedInfo<EnumConstantInfo> {
+  if (!Impl.EnumConstantTable)
+    return None;
+
+  Optional<IdentifierID> nameID = Impl.getIdentifier(name);
+  if (!nameID)
+    return None;
+
+  auto known = Impl.EnumConstantTable->find(*nameID);
+  if (known == Impl.EnumConstantTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+auto APINotesReader::lookupTag(StringRef name) -> VersionedInfo<TagInfo> {
+  if (!Impl.TagTable)
+    return None;
+
+  Optional<IdentifierID> nameID = Impl.getIdentifier(name);
+  if (!nameID)
+    return None;
+
+  auto known = Impl.TagTable->find(*nameID);
+  if (known == Impl.TagTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+auto APINotesReader::lookupTypedef(StringRef name)
+    -> VersionedInfo<TypedefInfo> {
+  if (!Impl.TypedefTable)
+    return None;
+
+  Optional<IdentifierID> nameID = Impl.getIdentifier(name);
+  if (!nameID)
+    return None;
+
+  auto known = Impl.TypedefTable->find(*nameID);
+  if (known == Impl.TypedefTable->end())
+    return None;
+
+  return { Impl.SwiftVersion, *known };
+}
+
+APINotesReader::Visitor::~Visitor() { }
+
+void APINotesReader::Visitor::visitObjCClass(
+       ContextID contextID,
+       StringRef name,
+       const ObjCContextInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitObjCProtocol(
+       ContextID contextID,
+       StringRef name,
+       const ObjCContextInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitObjCMethod(
+       ContextID contextID,
+       StringRef selector,
+       bool isInstanceMethod,
+       const ObjCMethodInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitObjCProperty(
+       ContextID contextID,
+       StringRef name,
+       bool isInstance,
+       const ObjCPropertyInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitGlobalVariable(
+       StringRef name,
+       const GlobalVariableInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitGlobalFunction(
+       StringRef name,
+       const GlobalFunctionInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitEnumConstant(
+       StringRef name,
+       const EnumConstantInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitTag(
+       StringRef name,
+       const TagInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::Visitor::visitTypedef(
+       StringRef name,
+       const TypedefInfo &info,
+       VersionTuple swiftVersion) { }
+
+void APINotesReader::visit(Visitor &visitor) {
+  // FIXME: All of these iterations would be significantly more efficient if we
+  // could get the keys and data together, but OnDiskIterableHashTable doesn't
+  // support that.
+
+  // Build an identifier ID -> string mapping, which we'll need when visiting
+  // any of the tables.
+  llvm::DenseMap<unsigned, StringRef> identifiers;
+  if (Impl.IdentifierTable) {
+    for (auto key : Impl.IdentifierTable->keys()) {
+      unsigned ID = *Impl.IdentifierTable->find(key);
+      assert(identifiers.count(ID) == 0);
+      identifiers[ID] = key;
+    }
+  }
+
+  // Visit classes and protocols.
+  if (Impl.ObjCContextIDTable && Impl.ObjCContextInfoTable) {
+    for (auto key : Impl.ObjCContextIDTable->keys()) {
+      auto name = identifiers[key.first];
+      auto contextID = *Impl.ObjCContextIDTable->find(key);
+
+      auto knownInfo = Impl.ObjCContextInfoTable->find(contextID);
+      if (knownInfo == Impl.ObjCContextInfoTable->end()) continue;
+
+      for (const auto &versioned : *knownInfo) {
+        if (key.second)
+          visitor.visitObjCProtocol(ContextID(contextID), name,
+                                    versioned.second, versioned.first);
+        else
+          visitor.visitObjCClass(ContextID(contextID), name, versioned.second,
+                                 versioned.first);
+      }
+    }
+  }
+
+  // Build a selector ID -> stored Objective-C selector mapping, which we need
+  // when visiting the method tables.
+  llvm::DenseMap<unsigned, std::string> selectors;
+  if (Impl.ObjCSelectorTable) {
+    for (auto key : Impl.ObjCSelectorTable->keys()) {
+      std::string selector;
+      if (key.NumPieces == 0)
+        selector = identifiers[key.Identifiers[0]];
+      else {
+        for (auto identID : key.Identifiers) {
+          selector += identifiers[identID];
+          selector += ':';
+        }
+      }
+
+      unsigned selectorID = *Impl.ObjCSelectorTable->find(key);
+      selectors[selectorID] = selector;
+    }
+  }
+
+  // Visit methods.
+  if (Impl.ObjCMethodTable) {
+    for (auto key : Impl.ObjCMethodTable->keys()) {
+      ContextID contextID(std::get<0>(key));
+      const auto &selector = selectors[std::get<1>(key)];
+      for (const auto &versioned : *Impl.ObjCMethodTable->find(key))
+        visitor.visitObjCMethod(contextID, selector, std::get<2>(key),
+                                versioned.second, versioned.first);
+    }
+  }
+
+  // Visit properties.
+  if (Impl.ObjCPropertyTable) {
+    for (auto key : Impl.ObjCPropertyTable->keys()) {
+      ContextID contextID(std::get<0>(key));
+      auto name = identifiers[std::get<1>(key)];
+      char isInstance = std::get<2>(key);
+      for (const auto &versioned : *Impl.ObjCPropertyTable->find(key)) {
+        visitor.visitObjCProperty(contextID, name, isInstance, versioned.second,
+                                  versioned.first);
+      }
+    }
+  }
+
+  // Visit global functions.
+  if (Impl.GlobalFunctionTable) {
+    for (auto key : Impl.GlobalFunctionTable->keys()) {
+      auto name = identifiers[key];
+      for (const auto &versioned : *Impl.GlobalFunctionTable->find(key))
+        visitor.visitGlobalFunction(name, versioned.second, versioned.first);
+    }
+  }
+
+  // Visit global variables.
+  if (Impl.GlobalVariableTable) {
+    for (auto key : Impl.GlobalVariableTable->keys()) {
+      auto name = identifiers[key];
+      for (const auto &versioned : *Impl.GlobalVariableTable->find(key))
+        visitor.visitGlobalVariable(name, versioned.second, versioned.first);
+    }
+  }
+
+  // Visit global variables.
+  if (Impl.EnumConstantTable) {
+    for (auto key : Impl.EnumConstantTable->keys()) {
+      auto name = identifiers[key];
+      for (const auto &versioned : *Impl.EnumConstantTable->find(key))
+        visitor.visitEnumConstant(name, versioned.second, versioned.first);
+    }
+  }
+
+  // Visit tags.
+  if (Impl.TagTable) {
+    for (auto key : Impl.TagTable->keys()) {
+      auto name = identifiers[key];
+      for (const auto &versioned : *Impl.TagTable->find(key))
+        visitor.visitTag(name, versioned.second, versioned.first);
+    }
+  }
+
+  // Visit typedefs.
+  if (Impl.TypedefTable) {
+    for (auto key : Impl.TypedefTable->keys()) {
+      auto name = identifiers[key];
+      for (const auto &versioned : *Impl.TypedefTable->find(key))
+        visitor.visitTypedef(name, versioned.second, versioned.first);
+    }
+  }
+}
+
diff --git a/lib/APINotes/APINotesWriter.cpp b/lib/APINotes/APINotesWriter.cpp
index e69de29bb2..e0b6fafd6d 100644
--- a/lib/APINotes/APINotesWriter.cpp
+++ b/lib/APINotes/APINotesWriter.cpp
@@ -0,0 +1,1340 @@
+//===--- APINotesWriter.cpp - API Notes Writer --------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the \c APINotesWriter class that writes out
+// source API notes data providing additional information about source
+// code as a separate input, such as the non-nil/nilable annotations
+// for method parameters.
+//
+//===----------------------------------------------------------------------===//
+#include "clang/APINotes/APINotesWriter.h"
+#include "APINotesFormat.h"
+#include "clang/Basic/FileManager.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/Hashing.h"
+#include "llvm/ADT/SmallString.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/Support/EndianStream.h"
+#include "llvm/Support/OnDiskHashTable.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/DataTypes.h"
+#include <tuple>
+#include <vector>
+using namespace clang;
+using namespace api_notes;
+using namespace llvm::support;
+
+namespace {
+  template<typename T> using VersionedSmallVector =
+    SmallVector<std::pair<VersionTuple, T>, 1>;
+}
+
+class APINotesWriter::Implementation {
+  /// Mapping from strings to identifier IDs.
+  llvm::StringMap<IdentifierID> IdentifierIDs;
+
+  /// Mapping from selectors to selector ID.
+  llvm::DenseMap<StoredObjCSelector, SelectorID> SelectorIDs;
+
+  /// Scratch space for bitstream writing.
+  SmallVector<uint64_t, 64> ScratchRecord;
+
+public:
+  /// The name of the module
+  std::string ModuleName;
+
+  /// The source file from which this binary representation was
+  /// created, if known.
+  const FileEntry *SourceFile;
+
+  bool SwiftInferImportAsMember = false;
+
+  /// Information about Objective-C contexts (classes or protocols).
+  ///
+  /// Indexed by the identifier ID and a bit indication whether we're looking
+  /// for a class (0) or protocol (1) and provides both the context ID and
+  /// information describing the context within that module.
+  llvm::DenseMap<std::pair<unsigned, char>,
+                 std::pair<unsigned, VersionedSmallVector<ObjCContextInfo>>>
+    ObjCContexts;
+
+  /// Mapping from context IDs to the identifier ID holding the name.
+  llvm::DenseMap<unsigned, unsigned> ObjCContextNames;
+
+  /// Information about Objective-C properties.
+  ///
+  /// Indexed by the context ID, property name, and whether this is an
+  /// instance property.
+  llvm::DenseMap<std::tuple<unsigned, unsigned, char>,
+                 llvm::SmallVector<std::pair<VersionTuple, ObjCPropertyInfo>,
+                 1>>
+    ObjCProperties;
+
+  /// Information about Objective-C methods.
+  ///
+  /// Indexed by the context ID, selector ID, and Boolean (stored as a
+  /// char) indicating whether this is a class or instance method.
+  llvm::DenseMap<std::tuple<unsigned, unsigned, char>,
+                 llvm::SmallVector<std::pair<VersionTuple, ObjCMethodInfo>, 1>>
+    ObjCMethods;
+
+  /// Information about global variables.
+  ///
+  /// Indexed by the identifier ID.
+  llvm::DenseMap<unsigned,
+                 llvm::SmallVector<std::pair<VersionTuple, GlobalVariableInfo>,
+                                   1>>
+    GlobalVariables;
+
+  /// Information about global functions.
+  ///
+  /// Indexed by the identifier ID.
+  llvm::DenseMap<unsigned,
+                 llvm::SmallVector<std::pair<VersionTuple, GlobalFunctionInfo>,
+                                   1>>
+    GlobalFunctions;
+
+  /// Information about enumerators.
+  ///
+  /// Indexed by the identifier ID.
+  llvm::DenseMap<unsigned,
+                 llvm::SmallVector<std::pair<VersionTuple, EnumConstantInfo>,
+                                   1>>
+    EnumConstants;
+
+  /// Information about tags.
+  ///
+  /// Indexed by the identifier ID.
+  llvm::DenseMap<unsigned,
+                 llvm::SmallVector<std::pair<VersionTuple, TagInfo>, 1>>
+    Tags;
+
+  /// Information about typedefs.
+  ///
+  /// Indexed by the identifier ID.
+  llvm::DenseMap<unsigned,
+                 llvm::SmallVector<std::pair<VersionTuple, TypedefInfo>, 1>>
+    Typedefs;
+
+  /// Retrieve the ID for the given identifier.
+  IdentifierID getIdentifier(StringRef identifier) {
+    if (identifier.empty())
+      return 0;
+
+    auto known = IdentifierIDs.find(identifier);
+    if (known != IdentifierIDs.end())
+      return known->second;
+
+    // Add to the identifier table.
+    known = IdentifierIDs.insert({identifier, IdentifierIDs.size() + 1}).first;
+    return known->second;
+  }
+
+  /// Retrieve the ID for the given selector.
+  SelectorID getSelector(ObjCSelectorRef selectorRef) {
+    // Translate the selector reference into a stored selector.
+    StoredObjCSelector selector;
+    selector.NumPieces = selectorRef.NumPieces;
+    selector.Identifiers.reserve(selectorRef.Identifiers.size());
+    for (auto piece : selectorRef.Identifiers) {
+      selector.Identifiers.push_back(getIdentifier(piece));
+    }
+
+    // Look for the stored selector.
+    auto known = SelectorIDs.find(selector);
+    if (known != SelectorIDs.end())
+      return known->second;
+
+    // Add to the selector table.
+    known = SelectorIDs.insert({selector, SelectorIDs.size()}).first;
+    return known->second;
+  }
+
+  void writeToStream(llvm::raw_ostream &os);
+
+private:
+  void writeBlockInfoBlock(llvm::BitstreamWriter &writer);
+  void writeControlBlock(llvm::BitstreamWriter &writer);
+  void writeIdentifierBlock(llvm::BitstreamWriter &writer);
+  void writeObjCContextBlock(llvm::BitstreamWriter &writer);
+  void writeObjCPropertyBlock(llvm::BitstreamWriter &writer);
+  void writeObjCMethodBlock(llvm::BitstreamWriter &writer);
+  void writeObjCSelectorBlock(llvm::BitstreamWriter &writer);
+  void writeGlobalVariableBlock(llvm::BitstreamWriter &writer);
+  void writeGlobalFunctionBlock(llvm::BitstreamWriter &writer);
+  void writeEnumConstantBlock(llvm::BitstreamWriter &writer);
+  void writeTagBlock(llvm::BitstreamWriter &writer);
+  void writeTypedefBlock(llvm::BitstreamWriter &writer);
+};
+
+/// Record the name of a block.
+static void emitBlockID(llvm::BitstreamWriter &out, unsigned ID,
+                        StringRef name,
+                        SmallVectorImpl<unsigned char> &nameBuffer) {
+  SmallVector<unsigned, 1> idBuffer;
+  idBuffer.push_back(ID);
+  out.EmitRecord(llvm::bitc::BLOCKINFO_CODE_SETBID, idBuffer);
+
+  // Emit the block name if present.
+  if (name.empty())
+    return;
+  nameBuffer.resize(name.size());
+  memcpy(nameBuffer.data(), name.data(), name.size());
+  out.EmitRecord(llvm::bitc::BLOCKINFO_CODE_BLOCKNAME, nameBuffer);
+}
+
+/// Record the name of a record within a block.
+static void emitRecordID(llvm::BitstreamWriter &out, unsigned ID,
+                         StringRef name,
+                         SmallVectorImpl<unsigned char> &nameBuffer) {
+  assert(ID < 256 && "can't fit record ID in next to name");
+  nameBuffer.resize(name.size()+1);
+  nameBuffer[0] = ID;
+  memcpy(nameBuffer.data()+1, name.data(), name.size());
+  out.EmitRecord(llvm::bitc::BLOCKINFO_CODE_SETRECORDNAME, nameBuffer);
+}
+
+void APINotesWriter::Implementation::writeBlockInfoBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, llvm::bitc::BLOCKINFO_BLOCK_ID, 2);  
+
+  SmallVector<unsigned char, 64> nameBuffer;
+#define BLOCK(X) emitBlockID(writer, X ## _ID, #X, nameBuffer)
+#define BLOCK_RECORD(K, X) emitRecordID(writer, K::X, #X, nameBuffer)
+
+  BLOCK(CONTROL_BLOCK);
+  BLOCK_RECORD(control_block, METADATA);
+  BLOCK_RECORD(control_block, MODULE_NAME);
+
+  BLOCK(IDENTIFIER_BLOCK);
+  BLOCK_RECORD(identifier_block, IDENTIFIER_DATA);
+
+  BLOCK(OBJC_CONTEXT_BLOCK);
+  BLOCK_RECORD(objc_context_block, OBJC_CONTEXT_ID_DATA);
+
+  BLOCK(OBJC_PROPERTY_BLOCK);
+  BLOCK_RECORD(objc_property_block, OBJC_PROPERTY_DATA);
+
+  BLOCK(OBJC_METHOD_BLOCK);
+  BLOCK_RECORD(objc_method_block, OBJC_METHOD_DATA);
+
+  BLOCK(OBJC_SELECTOR_BLOCK);
+  BLOCK_RECORD(objc_selector_block, OBJC_SELECTOR_DATA);
+
+  BLOCK(GLOBAL_VARIABLE_BLOCK);
+  BLOCK_RECORD(global_variable_block, GLOBAL_VARIABLE_DATA);
+
+  BLOCK(GLOBAL_FUNCTION_BLOCK);
+  BLOCK_RECORD(global_function_block, GLOBAL_FUNCTION_DATA);
+#undef BLOCK
+#undef BLOCK_RECORD
+}
+
+void APINotesWriter::Implementation::writeControlBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, CONTROL_BLOCK_ID, 3);
+  control_block::MetadataLayout metadata(writer);
+  metadata.emit(ScratchRecord, VERSION_MAJOR, VERSION_MINOR);
+
+  control_block::ModuleNameLayout moduleName(writer);
+  moduleName.emit(ScratchRecord, ModuleName);
+
+  if (SwiftInferImportAsMember) {
+    control_block::ModuleOptionsLayout moduleOptions(writer);
+    moduleOptions.emit(ScratchRecord, SwiftInferImportAsMember);
+  }
+
+  if (SourceFile) {
+    control_block::SourceFileLayout sourceFile(writer);
+    sourceFile.emit(ScratchRecord, SourceFile->getSize(),
+                    SourceFile->getModificationTime());
+  }
+}
+
+namespace {
+  /// Used to serialize the on-disk identifier table.
+  class IdentifierTableInfo {
+  public:
+    using key_type = StringRef;
+    using key_type_ref = key_type;
+    using data_type = IdentifierID;
+    using data_type_ref = const data_type &;
+    using hash_value_type = uint32_t;
+    using offset_type = unsigned;
+
+    hash_value_type ComputeHash(key_type_ref key) {
+      return llvm::HashString(key);
+    }
+
+    std::pair<unsigned, unsigned> EmitKeyDataLength(raw_ostream &out,
+                                                    key_type_ref key,
+                                                    data_type_ref data) {
+      uint32_t keyLength = key.size();
+      uint32_t dataLength = sizeof(uint32_t);
+      endian::Writer<little> writer(out);
+      writer.write<uint16_t>(keyLength);
+      writer.write<uint16_t>(dataLength);
+      return { keyLength, dataLength };
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      out << key;
+    }
+
+    void EmitData(raw_ostream &out, key_type_ref key, data_type_ref data,
+                  unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(data);
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeIdentifierBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, IDENTIFIER_BLOCK_ID, 3);
+
+  if (IdentifierIDs.empty())
+    return;
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<IdentifierTableInfo> generator;
+    for (auto &entry : IdentifierIDs)
+      generator.insert(entry.first(), entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  identifier_block::IdentifierDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  /// Retrieve the serialized size of the given CommonEntityInfo, for use in
+  /// on-disk hash tables.
+  static unsigned getCommonEntityInfoSize(const CommonEntityInfo &info) {
+    return 5 + info.UnavailableMsg.size() + info.SwiftName.size();
+  }
+
+  /// Emit a serialized representation of the common entity information.
+  static void emitCommonEntityInfo(raw_ostream &out,
+                                   const CommonEntityInfo &info) {
+    endian::Writer<little> writer(out);
+    uint8_t payload = 0;
+    if (auto swiftPrivate = info.isSwiftPrivate()) {
+      payload |= 0x01;
+      if (*swiftPrivate) payload |= 0x02;
+    }
+    payload <<= 1;
+    payload |= info.Unavailable;
+    payload <<= 1;
+    payload |= info.UnavailableInSwift;
+
+    writer.write<uint8_t>(payload);
+
+    writer.write<uint16_t>(info.UnavailableMsg.size());
+    out.write(info.UnavailableMsg.c_str(), info.UnavailableMsg.size());
+    writer.write<uint16_t>(info.SwiftName.size());
+    out.write(info.SwiftName.c_str(), info.SwiftName.size());
+  }
+
+  // Retrieve the serialized size of the given CommonTypeInfo, for use
+  // in on-disk hash tables.
+  static unsigned getCommonTypeInfoSize(const CommonTypeInfo &info) {
+    return 2 + (info.getSwiftBridge() ? info.getSwiftBridge()->size() : 0) +
+           2 + (info.getNSErrorDomain() ? info.getNSErrorDomain()->size() : 0) +
+           getCommonEntityInfoSize(info);
+  }
+
+  /// Emit a serialized representation of the common type information.
+  static void emitCommonTypeInfo(raw_ostream &out, const CommonTypeInfo &info) {
+    emitCommonEntityInfo(out, info);
+    endian::Writer<little> writer(out);
+    if (auto swiftBridge = info.getSwiftBridge()) {
+      writer.write<uint16_t>(swiftBridge->size() + 1);
+      out.write(swiftBridge->c_str(), swiftBridge->size());
+    } else {
+      writer.write<uint16_t>(0);
+    }
+    if (auto nsErrorDomain = info.getNSErrorDomain()) {
+      writer.write<uint16_t>(nsErrorDomain->size() + 1);
+      out.write(nsErrorDomain->c_str(), info.getNSErrorDomain()->size());
+    } else {
+      writer.write<uint16_t>(0);
+    }
+  }
+
+  /// Used to serialize the on-disk Objective-C context table.
+  class ObjCContextIDTableInfo {
+  public:
+    using key_type = std::pair<unsigned, char>; // identifier ID, is-protocol
+    using key_type_ref = key_type;
+    using data_type = unsigned;
+    using data_type_ref = const data_type &;
+    using hash_value_type = size_t;
+    using offset_type = unsigned;
+
+    hash_value_type ComputeHash(key_type_ref key) {
+      return static_cast<size_t>(llvm::hash_value(key));
+    }
+
+    std::pair<unsigned, unsigned> EmitKeyDataLength(raw_ostream &out,
+                                                    key_type_ref key,
+                                                    data_type_ref data) {
+      uint32_t keyLength = sizeof(uint32_t) + 1;
+      uint32_t dataLength = sizeof(uint32_t);
+      endian::Writer<little> writer(out);
+      writer.write<uint16_t>(keyLength);
+      writer.write<uint16_t>(dataLength);
+      return { keyLength, dataLength };
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(key.first);
+      writer.write<uint8_t>(key.second);
+    }
+
+    void EmitData(raw_ostream &out, key_type_ref key, data_type_ref data,
+                  unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(data);
+    }
+  };
+} // end anonymous namespace
+
+namespace {
+  /// Retrieve the serialized size of the given VersionTuple, for use in
+  /// on-disk hash tables.
+  unsigned getVersionTupleSize(const VersionTuple &version) {
+    unsigned size = sizeof(uint8_t) + /*major*/sizeof(uint32_t);
+    if (version.getMinor()) size += sizeof(uint32_t);
+    if (version.getSubminor()) size += sizeof(uint32_t);
+    if (version.getBuild()) size += sizeof(uint32_t);
+    return size;
+  }
+
+  /// Emit a serialized representation of a version tuple.
+  void emitVersionTuple(raw_ostream &out, const VersionTuple &version) {
+    endian::Writer<little> writer(out);
+
+    // First byte contains the number of components beyond the 'major'
+    // component.
+    uint8_t descriptor;
+    if (version.getBuild()) descriptor = 3;
+    else if (version.getSubminor()) descriptor = 2;
+    else if (version.getMinor()) descriptor = 1;
+    else descriptor = 0;
+    assert(!version.usesUnderscores() && "Not a serializable version");
+    writer.write<uint8_t>(descriptor);
+
+    // Write the components.
+    writer.write<uint32_t>(version.getMajor());
+    if (auto minor = version.getMinor())
+      writer.write<uint32_t>(*minor);
+    if (auto subminor = version.getSubminor())
+      writer.write<uint32_t>(*subminor);
+    if (auto build = version.getBuild())
+      writer.write<uint32_t>(*build);
+  }
+
+  /// Localized helper to make a type dependent, thwarting template argument
+  /// deduction.
+  template<typename T>
+  struct MakeDependent {
+    typedef T Type;
+  };
+
+  /// Determine the size of an array of versioned information,
+  template<typename T>
+  unsigned getVersionedInfoSize(
+             const SmallVectorImpl<std::pair<VersionTuple, T>> &infoArray,
+            llvm::function_ref<unsigned(const typename MakeDependent<T>::Type&)>
+              getInfoSize) {
+    unsigned result = sizeof(uint16_t); // # of elements
+    for (const auto &element : infoArray) {
+      result += getVersionTupleSize(element.first);
+      result += getInfoSize(element.second);
+    }
+
+    return result;
+  }
+
+  /// Emit versioned information.
+  template<typename T>
+  void emitVersionedInfo(
+         raw_ostream &out,
+         SmallVectorImpl<std::pair<VersionTuple, T>> &infoArray,
+         llvm::function_ref<void(raw_ostream &out,
+                                 const typename MakeDependent<T>::Type& info)>
+           emitInfo) {
+    std::sort(infoArray.begin(), infoArray.end(),
+              [](const std::pair<VersionTuple, T> &left,
+                 const std::pair<VersionTuple, T> &right) -> bool {
+      assert(left.first != right.first && "two entries for the same version");
+      return left.first < right.first;
+    });
+    endian::Writer<little> writer(out);
+    writer.write<uint16_t>(infoArray.size());
+    for (const auto &element : infoArray) {
+      emitVersionTuple(out, element.first);
+      emitInfo(out, element.second);
+    }
+  }
+
+  /// Retrieve the serialized size of the given VariableInfo, for use in
+  /// on-disk hash tables.
+  unsigned getVariableInfoSize(const VariableInfo &info) {
+    return 2 + getCommonEntityInfoSize(info) + 2 + info.getType().size();
+  }
+
+  /// Emit a serialized representation of the variable information.
+  void emitVariableInfo(raw_ostream &out, const VariableInfo &info) {
+    emitCommonEntityInfo(out, info);
+
+    uint8_t bytes[2] = { 0, 0 };
+    if (auto nullable = info.getNullability()) {
+      bytes[0] = 1;
+      bytes[1] = static_cast<uint8_t>(*nullable);
+    } else {
+      // Nothing to do.
+    }
+
+    out.write(reinterpret_cast<const char *>(bytes), 2);
+
+    endian::Writer<little> writer(out);
+    writer.write<uint16_t>(info.getType().size());
+    out.write(info.getType().data(), info.getType().size());
+  }
+
+  /// On-dish hash table info key base for handling versioned data.
+  template<typename Derived, typename KeyType, typename UnversionedDataType>
+  class VersionedTableInfo {
+    Derived &asDerived() {
+      return *static_cast<Derived *>(this);
+    }
+
+    const Derived &asDerived() const {
+      return *static_cast<const Derived *>(this);
+    }
+
+  public:
+    using key_type = KeyType;
+    using key_type_ref = key_type;
+    using data_type =
+      SmallVector<std::pair<VersionTuple, UnversionedDataType>, 1>;
+    using data_type_ref = data_type &;
+    using hash_value_type = size_t;
+    using offset_type = unsigned;
+
+    hash_value_type ComputeHash(key_type_ref key) {
+      return llvm::hash_value(key);
+    }
+
+    std::pair<unsigned, unsigned> EmitKeyDataLength(raw_ostream &out,
+                                                    key_type_ref key,
+                                                    data_type_ref data) {
+      uint32_t keyLength = asDerived().getKeyLength(key);
+      uint32_t dataLength = getVersionedInfoSize(data,
+        [this](const UnversionedDataType &unversionedInfo) {
+          return asDerived().getUnversionedInfoSize(unversionedInfo);
+      });
+
+      endian::Writer<little> writer(out);
+      writer.write<uint16_t>(keyLength);
+      writer.write<uint16_t>(dataLength);
+      return { keyLength, dataLength };
+    }
+
+    void EmitData(raw_ostream &out, key_type_ref key, data_type_ref data,
+                  unsigned len) {
+      emitVersionedInfo(out, data,
+        [this](llvm::raw_ostream &out,
+               const UnversionedDataType &unversionedInfo) {
+          asDerived().emitUnversionedInfo(out, unversionedInfo);
+      });
+    }
+  };
+
+  /// Used to serialize the on-disk Objective-C property table.
+  class ObjCContextInfoTableInfo
+    : public VersionedTableInfo<ObjCContextInfoTableInfo,
+                                unsigned,
+                                ObjCContextInfo> {
+  public:
+    unsigned getKeyLength(key_type_ref) {
+      return sizeof(uint32_t);
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(key);
+    }
+
+    unsigned getUnversionedInfoSize(const ObjCContextInfo &info) {
+      return getCommonTypeInfoSize(info) + 1;
+    }
+
+    void emitUnversionedInfo(raw_ostream &out, const ObjCContextInfo &info) {
+      emitCommonTypeInfo(out, info);
+
+      uint8_t payload = 0;
+      if (auto swiftImportAsNonGeneric = info.getSwiftImportAsNonGeneric()) {
+        payload |= (0x01 << 1) | swiftImportAsNonGeneric.getValue();
+      }
+      payload <<= 2;
+      if (auto swiftObjCMembers = info.getSwiftObjCMembers()) {
+        payload |= (0x01 << 1) | swiftObjCMembers.getValue();
+      }
+      payload <<= 3;
+      if (auto nullable = info.getDefaultNullability()) {
+        payload |= (0x01 << 2) | static_cast<uint8_t>(*nullable);
+      }
+      payload = (payload << 1) | (info.hasDesignatedInits() ? 1 : 0);
+      out << payload;
+    }
+  };
+
+  /// Used to serialize the on-disk Objective-C property table.
+  class ObjCPropertyTableInfo
+    : public VersionedTableInfo<ObjCPropertyTableInfo,
+                                std::tuple<unsigned, unsigned, char>,
+                                ObjCPropertyInfo> {
+  public:
+    unsigned getKeyLength(key_type_ref) {
+      return sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint8_t);
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(std::get<0>(key));
+      writer.write<uint32_t>(std::get<1>(key));
+      writer.write<uint8_t>(std::get<2>(key));
+    }
+
+    unsigned getUnversionedInfoSize(const ObjCPropertyInfo &info) {
+      return getVariableInfoSize(info) + 1;
+    }
+
+    void emitUnversionedInfo(raw_ostream &out, const ObjCPropertyInfo &info) {
+      emitVariableInfo(out, info);
+      uint8_t flags = 0;
+      if (Optional<bool> value = info.getSwiftImportAsAccessors()) {
+        flags |= 1 << 0;
+        flags |= value.getValue() << 1;
+      }
+      out << flags;
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeObjCContextBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, OBJC_CONTEXT_BLOCK_ID, 3);
+
+  if (ObjCContexts.empty())
+    return;  
+
+  {
+    llvm::SmallString<4096> hashTableBlob;
+    uint32_t tableOffset;
+    {
+      llvm::OnDiskChainedHashTableGenerator<ObjCContextIDTableInfo> generator;
+      for (auto &entry : ObjCContexts)
+        generator.insert(entry.first, entry.second.first);
+
+      llvm::raw_svector_ostream blobStream(hashTableBlob);
+      // Make sure that no bucket is at offset 0
+      endian::Writer<little>(blobStream).write<uint32_t>(0);
+      tableOffset = generator.Emit(blobStream);
+    }
+
+    objc_context_block::ObjCContextIDLayout layout(writer);
+    layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+  }
+
+  {
+    llvm::SmallString<4096> hashTableBlob;
+    uint32_t tableOffset;
+    {
+      llvm::OnDiskChainedHashTableGenerator<ObjCContextInfoTableInfo>
+        generator;
+      for (auto &entry : ObjCContexts)
+        generator.insert(entry.second.first, entry.second.second);
+
+      llvm::raw_svector_ostream blobStream(hashTableBlob);
+      // Make sure that no bucket is at offset 0
+      endian::Writer<little>(blobStream).write<uint32_t>(0);
+      tableOffset = generator.Emit(blobStream);
+    }
+
+    objc_context_block::ObjCContextInfoLayout layout(writer);
+    layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+  }
+}
+
+void APINotesWriter::Implementation::writeObjCPropertyBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, OBJC_PROPERTY_BLOCK_ID, 3);
+
+  if (ObjCProperties.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<ObjCPropertyTableInfo> generator;
+    for (auto &entry : ObjCProperties)
+      generator.insert(entry.first, entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  objc_property_block::ObjCPropertyDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  static unsigned getParamInfoSize(const ParamInfo &info) {
+    return getVariableInfoSize(info) + 1;
+  }
+
+  static void emitParamInfo(raw_ostream &out, const ParamInfo &info) {
+    emitVariableInfo(out, info);
+
+    endian::Writer<little> writer(out);
+
+    uint8_t payload = 0;
+    if (auto noescape = info.isNoEscape()) {
+      payload |= 0x01;
+      if (*noescape)
+        payload |= 0x02;
+    }
+    payload <<= 3;
+    if (auto retainCountConvention = info.getRetainCountConvention()) {
+      payload |= static_cast<uint8_t>(retainCountConvention.getValue()) + 1;
+    }
+    writer.write<uint8_t>(payload);
+  }
+
+  /// Retrieve the serialized size of the given FunctionInfo, for use in
+  /// on-disk hash tables.
+  static unsigned getFunctionInfoSize(const FunctionInfo &info) {
+    unsigned size = 2 + sizeof(uint64_t) + getCommonEntityInfoSize(info) + 2;
+
+    for (const auto &param : info.Params)
+      size += getParamInfoSize(param);
+
+    size += 2 + info.ResultType.size();
+    return size;
+  }
+
+  /// Emit a serialized representation of the function information.
+  static void emitFunctionInfo(raw_ostream &out, const FunctionInfo &info) {
+    emitCommonEntityInfo(out, info);
+
+    endian::Writer<little> writer(out);
+
+    uint8_t payload = 0;
+    payload |= info.NullabilityAudited;
+    payload <<= 3;
+    if (auto retainCountConvention = info.getRetainCountConvention()) {
+      payload |= static_cast<uint8_t>(retainCountConvention.getValue()) + 1;
+    }
+    writer.write<uint8_t>(payload);
+
+    writer.write<uint8_t>(info.NumAdjustedNullable);
+    writer.write<uint64_t>(info.NullabilityPayload);
+
+    // Parameters.
+    writer.write<uint16_t>(info.Params.size());
+    for (const auto &pi : info.Params)
+      emitParamInfo(out, pi);
+
+    // Result type.
+    writer.write<uint16_t>(info.ResultType.size());
+    out.write(info.ResultType.data(), info.ResultType.size());
+  }
+
+  /// Used to serialize the on-disk Objective-C method table.
+  class ObjCMethodTableInfo
+    : public VersionedTableInfo<ObjCMethodTableInfo,
+                                std::tuple<unsigned, unsigned, char>,
+                                ObjCMethodInfo> {
+  public:
+    unsigned getKeyLength(key_type_ref) {
+      return sizeof(uint32_t) + sizeof(uint32_t) + 1;
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(std::get<0>(key));
+      writer.write<uint32_t>(std::get<1>(key));
+      writer.write<uint8_t>(std::get<2>(key));
+    }
+
+    unsigned getUnversionedInfoSize(const ObjCMethodInfo &info) {
+      return 1 + getFunctionInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out, const ObjCMethodInfo &info) {
+      uint8_t payload = 0;
+      payload = (payload << 1) | info.DesignatedInit;
+      payload = (payload << 1) | info.Required;
+      endian::Writer<little> writer(out);
+      writer.write<uint8_t>(payload);
+
+      emitFunctionInfo(out, info);
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeObjCMethodBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, OBJC_METHOD_BLOCK_ID, 3);
+
+  if (ObjCMethods.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<ObjCMethodTableInfo> generator;
+    for (auto &entry : ObjCMethods) {
+      generator.insert(entry.first, entry.second);
+    }
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  objc_method_block::ObjCMethodDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  /// Used to serialize the on-disk Objective-C selector table.
+  class ObjCSelectorTableInfo {
+  public:
+    using key_type = StoredObjCSelector;
+    using key_type_ref = const key_type &;
+    using data_type = SelectorID;
+    using data_type_ref = data_type;
+    using hash_value_type = unsigned;
+    using offset_type = unsigned;
+
+    hash_value_type ComputeHash(key_type_ref key) {
+      return llvm::DenseMapInfo<StoredObjCSelector>::getHashValue(key);
+    }
+
+    std::pair<unsigned, unsigned> EmitKeyDataLength(raw_ostream &out,
+                                                    key_type_ref key,
+                                                    data_type_ref data) {
+      uint32_t keyLength = sizeof(uint16_t) 
+                         + sizeof(uint32_t) * key.Identifiers.size();
+      uint32_t dataLength = sizeof(uint32_t);
+      endian::Writer<little> writer(out);
+      writer.write<uint16_t>(keyLength);
+      writer.write<uint16_t>(dataLength);
+      return { keyLength, dataLength };
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint16_t>(key.NumPieces);
+      for (auto piece : key.Identifiers) {
+        writer.write<uint32_t>(piece);
+      }
+    }
+
+    void EmitData(raw_ostream &out, key_type_ref key, data_type_ref data,
+                  unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(data);
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeObjCSelectorBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, OBJC_SELECTOR_BLOCK_ID, 3);
+
+  if (SelectorIDs.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<ObjCSelectorTableInfo> generator;
+    for (auto &entry : SelectorIDs)
+      generator.insert(entry.first, entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  objc_selector_block::ObjCSelectorDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  /// Used to serialize the on-disk global variable table.
+  class GlobalVariableTableInfo
+    : public VersionedTableInfo<GlobalVariableTableInfo,
+                                unsigned,
+                                GlobalVariableInfo> {
+  public:
+    unsigned getKeyLength(key_type_ref key) {
+      return sizeof(uint32_t);
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(key);
+    }
+
+    unsigned getUnversionedInfoSize(const GlobalVariableInfo &info) {
+      return getVariableInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out,
+                             const GlobalVariableInfo &info) {
+      emitVariableInfo(out, info);
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeGlobalVariableBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, GLOBAL_VARIABLE_BLOCK_ID, 3);
+
+  if (GlobalVariables.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<GlobalVariableTableInfo> generator;
+    for (auto &entry : GlobalVariables)
+      generator.insert(entry.first, entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  global_variable_block::GlobalVariableDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  /// Used to serialize the on-disk global function table.
+  class GlobalFunctionTableInfo
+    : public VersionedTableInfo<GlobalFunctionTableInfo,
+                                unsigned,
+                                GlobalFunctionInfo> {
+  public:
+    unsigned getKeyLength(key_type_ref) {
+      return sizeof(uint32_t);
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(key);
+    }
+
+    unsigned getUnversionedInfoSize(const GlobalFunctionInfo &info) {
+      return getFunctionInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out,
+                             const GlobalFunctionInfo &info) {
+      emitFunctionInfo(out, info);
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeGlobalFunctionBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, GLOBAL_FUNCTION_BLOCK_ID, 3);
+
+  if (GlobalFunctions.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<GlobalFunctionTableInfo> generator;
+    for (auto &entry : GlobalFunctions) {
+      generator.insert(entry.first, entry.second);
+    }
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  global_function_block::GlobalFunctionDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  /// Used to serialize the on-disk global enum constant.
+  class EnumConstantTableInfo
+    : public VersionedTableInfo<EnumConstantTableInfo,
+                                unsigned,
+                                EnumConstantInfo> {
+  public:
+    unsigned getKeyLength(key_type_ref) {
+      return sizeof(uint32_t);
+    }
+
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<uint32_t>(key);
+    }
+
+    unsigned getUnversionedInfoSize(const EnumConstantInfo &info) {
+      return getCommonEntityInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out, const EnumConstantInfo &info) {
+      emitCommonEntityInfo(out, info);
+    }
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeEnumConstantBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, ENUM_CONSTANT_BLOCK_ID, 3);
+
+  if (EnumConstants.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<EnumConstantTableInfo> generator;
+    for (auto &entry : EnumConstants)
+      generator.insert(entry.first, entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  enum_constant_block::EnumConstantDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  template<typename Derived, typename UnversionedDataType>
+  class CommonTypeTableInfo
+    : public VersionedTableInfo<Derived, unsigned, UnversionedDataType> {
+  public:
+    using key_type_ref = typename CommonTypeTableInfo::key_type_ref;
+
+    unsigned getKeyLength(key_type_ref) {
+      return sizeof(IdentifierID);
+    }
+    void EmitKey(raw_ostream &out, key_type_ref key, unsigned len) {
+      endian::Writer<little> writer(out);
+      writer.write<IdentifierID>(key);
+    }
+
+    unsigned getUnversionedInfoSize(const UnversionedDataType &info) {
+      return getCommonTypeInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out,
+                             const UnversionedDataType &info) {
+      emitCommonTypeInfo(out, info);
+    }
+  };
+
+  /// Used to serialize the on-disk tag table.
+  class TagTableInfo : public CommonTypeTableInfo<TagTableInfo, TagInfo> {
+  public:
+    unsigned getUnversionedInfoSize(const TagInfo &info) {
+      return 1 + getCommonTypeInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out, const TagInfo &info) {
+      endian::Writer<little> writer(out);
+
+      uint8_t payload = 0;
+      if (auto enumExtensibility = info.EnumExtensibility) {
+        payload |= static_cast<uint8_t>(enumExtensibility.getValue()) + 1;
+        assert((payload < (1 << 2)) && "must fit in two bits");
+      }
+
+      payload <<= 2;
+      if (Optional<bool> value = info.isFlagEnum()) {
+        payload |= 1 << 0;
+        payload |= value.getValue() << 1;
+      }
+
+      writer.write<uint8_t>(payload);
+
+      emitCommonTypeInfo(out, info);
+    }
+  };
+
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeTagBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, TAG_BLOCK_ID, 3);
+
+  if (Tags.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<TagTableInfo> generator;
+    for (auto &entry : Tags)
+      generator.insert(entry.first, entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  tag_block::TagDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+namespace {
+  /// Used to serialize the on-disk typedef table.
+  class TypedefTableInfo
+    : public CommonTypeTableInfo<TypedefTableInfo, TypedefInfo> {
+
+  public:
+    unsigned getUnversionedInfoSize(const TypedefInfo &info) {
+      return 1 + getCommonTypeInfoSize(info);
+    }
+
+    void emitUnversionedInfo(raw_ostream &out, const TypedefInfo &info) {
+      endian::Writer<little> writer(out);
+
+      uint8_t payload = 0;
+      if (auto swiftWrapper = info.SwiftWrapper) {
+        payload |= static_cast<uint8_t>(*swiftWrapper) + 1;
+      }
+
+      writer.write<uint8_t>(payload);
+
+      emitCommonTypeInfo(out, info);
+    }
+
+  };
+} // end anonymous namespace
+
+void APINotesWriter::Implementation::writeTypedefBlock(
+       llvm::BitstreamWriter &writer) {
+  BCBlockRAII restoreBlock(writer, TYPEDEF_BLOCK_ID, 3);
+
+  if (Typedefs.empty())
+    return;  
+
+  llvm::SmallString<4096> hashTableBlob;
+  uint32_t tableOffset;
+  {
+    llvm::OnDiskChainedHashTableGenerator<TypedefTableInfo> generator;
+    for (auto &entry : Typedefs)
+      generator.insert(entry.first, entry.second);
+
+    llvm::raw_svector_ostream blobStream(hashTableBlob);
+    // Make sure that no bucket is at offset 0
+    endian::Writer<little>(blobStream).write<uint32_t>(0);
+    tableOffset = generator.Emit(blobStream);
+  }
+
+  typedef_block::TypedefDataLayout layout(writer);
+  layout.emit(ScratchRecord, tableOffset, hashTableBlob);
+}
+
+void APINotesWriter::Implementation::writeToStream(llvm::raw_ostream &os) {
+  // Write the API notes file into a buffer.
+  SmallVector<char, 0> buffer;
+  {
+    llvm::BitstreamWriter writer(buffer);
+
+    // Emit the signature.
+    for (unsigned char byte : API_NOTES_SIGNATURE)
+      writer.Emit(byte, 8);
+
+    // Emit the blocks.
+    writeBlockInfoBlock(writer);
+    writeControlBlock(writer);
+    writeIdentifierBlock(writer);
+    writeObjCContextBlock(writer);
+    writeObjCPropertyBlock(writer);
+    writeObjCMethodBlock(writer);
+    writeObjCSelectorBlock(writer);
+    writeGlobalVariableBlock(writer);
+    writeGlobalFunctionBlock(writer);
+    writeEnumConstantBlock(writer);
+    writeTagBlock(writer);
+    writeTypedefBlock(writer);
+  }
+
+  // Write the buffer to the stream.
+  os.write(buffer.data(), buffer.size());
+  os.flush();
+}
+
+APINotesWriter::APINotesWriter(StringRef moduleName, const FileEntry *sourceFile)
+  : Impl(*new Implementation)
+{
+  Impl.ModuleName = moduleName;
+  Impl.SourceFile = sourceFile;
+}
+
+APINotesWriter::~APINotesWriter() {
+  delete &Impl;
+}
+
+
+void APINotesWriter::writeToStream(raw_ostream &os) {
+  Impl.writeToStream(os);
+}
+
+ContextID APINotesWriter::addObjCContext(StringRef name, bool isClass,
+                                         const ObjCContextInfo &info,
+                                         VersionTuple swiftVersion) {
+  IdentifierID nameID = Impl.getIdentifier(name);
+
+  std::pair<unsigned, char> key(nameID, isClass ? 0 : 1);
+  auto known = Impl.ObjCContexts.find(key);
+  if (known == Impl.ObjCContexts.end()) {
+    unsigned nextID = Impl.ObjCContexts.size() + 1;
+
+    VersionedSmallVector<ObjCContextInfo> emptyVersionedInfo;
+    known = Impl.ObjCContexts.insert(
+              std::make_pair(key, std::make_pair(nextID, emptyVersionedInfo)))
+              .first;
+
+    Impl.ObjCContextNames[nextID] = nameID;
+  }
+
+  // Add this version information.
+  auto &versionedVec = known->second.second;
+  bool found = false;
+  for (auto &versioned : versionedVec){
+    if (versioned.first == swiftVersion) {
+      versioned.second |= info;
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+    versionedVec.push_back({swiftVersion, info});
+
+  return ContextID(known->second.first);
+}
+
+void APINotesWriter::addObjCProperty(ContextID contextID, StringRef name,
+                                     bool isInstance,
+                                     const ObjCPropertyInfo &info,
+                                     VersionTuple swiftVersion) {
+  IdentifierID nameID = Impl.getIdentifier(name);
+  Impl.ObjCProperties[std::make_tuple(contextID.Value, nameID, isInstance)]
+    .push_back({swiftVersion, info});
+}
+
+void APINotesWriter::addObjCMethod(ContextID contextID,
+                                   ObjCSelectorRef selector,
+                                   bool isInstanceMethod,
+                                   const ObjCMethodInfo &info,
+                                   VersionTuple swiftVersion) {
+  SelectorID selectorID = Impl.getSelector(selector);
+  auto key = std::tuple<unsigned, unsigned, char>{
+      contextID.Value, selectorID, isInstanceMethod};
+  Impl.ObjCMethods[key].push_back({swiftVersion, info});
+
+  // If this method is a designated initializer, update the class to note that
+  // it has designated initializers.
+  if (info.DesignatedInit) {
+    assert(Impl.ObjCContexts.count({Impl.ObjCContextNames[contextID.Value],
+                                    (char)0}));
+    auto &versionedVec =
+      Impl.ObjCContexts[{Impl.ObjCContextNames[contextID.Value], (char)0}]
+        .second;
+    bool found = false;
+    for (auto &versioned : versionedVec) {
+      if (versioned.first == swiftVersion) {
+        versioned.second.setHasDesignatedInits(true);
+        found = true;
+        break;
+      }
+    }
+
+    if (!found) {
+      versionedVec.push_back({swiftVersion, ObjCContextInfo()});
+      versionedVec.back().second.setHasDesignatedInits(true);
+    }
+  }
+}
+
+void APINotesWriter::addGlobalVariable(llvm::StringRef name,
+                                       const GlobalVariableInfo &info,
+                                       VersionTuple swiftVersion) {
+  IdentifierID variableID = Impl.getIdentifier(name);
+  Impl.GlobalVariables[variableID].push_back({swiftVersion, info});
+}
+
+void APINotesWriter::addGlobalFunction(llvm::StringRef name,
+                                       const GlobalFunctionInfo &info,
+                                       VersionTuple swiftVersion) {
+  IdentifierID nameID = Impl.getIdentifier(name);
+  Impl.GlobalFunctions[nameID].push_back({swiftVersion, info});
+}
+
+void APINotesWriter::addEnumConstant(llvm::StringRef name,
+                                     const EnumConstantInfo &info,
+                                     VersionTuple swiftVersion) {
+  IdentifierID enumConstantID = Impl.getIdentifier(name);
+  Impl.EnumConstants[enumConstantID].push_back({swiftVersion, info});
+}
+
+void APINotesWriter::addTag(llvm::StringRef name, const TagInfo &info,
+                            VersionTuple swiftVersion) {
+  IdentifierID tagID = Impl.getIdentifier(name);
+  Impl.Tags[tagID].push_back({swiftVersion, info});
+}
+
+void APINotesWriter::addTypedef(llvm::StringRef name, const TypedefInfo &info,
+                                VersionTuple swiftVersion) {
+  IdentifierID typedefID = Impl.getIdentifier(name);
+  Impl.Typedefs[typedefID].push_back({swiftVersion, info});
+}
+
+void APINotesWriter::addModuleOptions(ModuleOptions opts) {
+  Impl.SwiftInferImportAsMember = opts.SwiftInferImportAsMember;
+}
+
diff --git a/lib/APINotes/APINotesYAMLCompiler.cpp b/lib/APINotes/APINotesYAMLCompiler.cpp
index e69de29bb2..bccb72f4de 100644
--- a/lib/APINotes/APINotesYAMLCompiler.cpp
+++ b/lib/APINotes/APINotesYAMLCompiler.cpp
@@ -0,0 +1,1533 @@
+//===--- APINotesYAMLCompiler.cpp - API Notes YAML format reader *- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file reads API notes specified in YAML format.
+//
+//===----------------------------------------------------------------------===//
+#include "clang/APINotes/APINotesYAMLCompiler.h"
+#include "clang/APINotes/APINotesReader.h"
+#include "clang/APINotes/Types.h"
+#include "clang/APINotes/APINotesWriter.h"
+#include "clang/Basic/VersionTuple.h"
+#include "llvm/ADT/DenseSet.h"
+#include "llvm/ADT/StringSet.h"
+#include "llvm/Support/SourceMgr.h"
+#include "llvm/Support/YAMLParser.h"
+#include "llvm/Support/YAMLTraits.h"
+#include <algorithm>
+
+/*
+ 
+ YAML Format specification.
+
+ Nullability should be expressed using one of the following values:
+   O - Optional (or Nullable)
+   N - Not Optional
+   S - Scalar
+   U - Unknown
+ Note, the API is considered 'audited' when at least the return value or a
+ parameter has a nullability value. For 'audited' APIs, we assume the default
+ nullability for any underspecified type.
+
+---
+ Name: AppKit             # The name of the framework
+
+ Availability: OSX        # Optional: Specifies which platform the API is
+                          # available on. [OSX / iOS / none/
+                          #                available / nonswift]
+
+ AvailabilityMsg: ""  # Optional: Custom availability message to display to
+                          # the user, when API is not available.
+
+ Classes:                 # List of classes
+ ...
+ Protocols:               # List of protocols
+ ...
+ Functions:               # List of functions
+ ...
+ Globals:                 # List of globals
+ ...
+ Enumerators:             # List of enumerators
+ ...
+ Tags:                    # List of tags (struct/union/enum/C++ class)
+ ...
+ Typedefs:                # List of typedef-names and C++11 type aliases
+ ...
+
+ Each class and protocol is defined as following:
+
+ - Name: NSView                       # The name of the class
+ 
+   AuditedForNullability: false       # Optional: Specifies if the whole class
+                                      # has been audited for nullability.
+                                      # If yes, we assume all the methods and
+                                      # properties of the class have default
+                                      # nullability unless it is overwritten by
+                                      # a method/property specific info below.
+                                      # This applies to all classes, extensions,
+                                      # and categories of the class defined in
+                                      # the current framework/module.
+                                      # (false/true)
+
+   Availability: OSX
+
+   AvailabilityMsg: ""
+
+   Methods:
+     - Selector: "setSubviews:"       # Full name
+
+       MethodKind: Instance           # [Class/Instance]
+
+       Nullability: [N, N, O, S]      # The nullability of parameters in
+                                      # the signature.
+
+       NullabilityOfRet: O            # The nullability of the return value.
+
+       Availability: OSX
+
+       AvailabilityMsg: ""
+
+       DesignatedInit: false          # Optional: Specifies if this method is a
+                                      # designated initializer (false/true)
+
+       Required: false                # Optional: Specifies if this method is a
+                                      # required initializer (false/true)
+
+   Properties:
+     - Name: window
+
+       Nullability: O
+
+       Availability: OSX
+
+       AvailabilityMsg: ""
+
+ The protocol definition format is the same as the class definition.
+
+ Each function definition is of the following form:
+
+ - Name: "myGlobalFunction"           # Full name
+
+   Nullability: [N, N, O, S]          # The nullability of parameters in
+                                      # the signature.
+
+   NullabilityOfRet: O                # The nullability of the return value.
+
+   Availability: OSX
+
+   AvailabilityMsg: ""
+
+Each global variable definition is of the following form:
+
+ - Name: MyGlobalVar
+
+   Nullability: O
+
+   Availability: OSX
+
+   AvailabilityMsg: ""
+
+*/
+
+using llvm::StringRef;
+using namespace clang;
+namespace {
+  enum class APIAvailability {
+    Available = 0,
+    OSX,
+    IOS,
+    None,
+    NonSwift,
+  };
+
+  enum class MethodKind {
+    Class,
+    Instance,
+  };
+
+  /// Old attribute deprecated in favor of SwiftName.
+  enum class FactoryAsInitKind {
+    /// Infer based on name and type (the default).
+    Infer,
+    /// Treat as a class method.
+    AsClassMethod,
+    /// Treat as an initializer.
+    AsInitializer
+  };
+  
+  /// Syntactic sugar for EnumExtensibility and FlagEnum
+  enum class EnumConvenienceAliasKind {
+    /// EnumExtensibility: none, FlagEnum: false
+    None,
+    /// EnumExtensibility: open, FlagEnum: false
+    CFEnum,
+    /// EnumExtensibility: open, FlagEnum: true
+    CFOptions,
+    /// EnumExtensibility: closed, FlagEnum: false
+    CFClosedEnum
+  };
+
+  struct AvailabilityItem {
+    APIAvailability Mode = APIAvailability::Available;
+    StringRef Msg;
+    AvailabilityItem() : Mode(APIAvailability::Available), Msg("") {}
+  };
+
+  static llvm::Optional<NullabilityKind> AbsentNullability = llvm::None;
+  static llvm::Optional<NullabilityKind> DefaultNullability =
+    NullabilityKind::NonNull;
+  typedef std::vector<clang::NullabilityKind> NullabilitySeq;
+
+  struct Param {
+    unsigned Position;
+    Optional<bool> NoEscape = false;
+    Optional<NullabilityKind> Nullability;
+    Optional<api_notes::RetainCountConventionKind> RetainCountConvention;
+    StringRef Type;
+  };
+  typedef std::vector<Param> ParamsSeq;
+
+  struct Method {
+    StringRef Selector;
+    MethodKind Kind;
+    ParamsSeq Params;
+    NullabilitySeq Nullability;
+    Optional<NullabilityKind> NullabilityOfRet;
+    Optional<api_notes::RetainCountConventionKind> RetainCountConvention;
+    AvailabilityItem Availability;
+    Optional<bool> SwiftPrivate;
+    StringRef SwiftName;
+    FactoryAsInitKind FactoryAsInit = FactoryAsInitKind::Infer;
+    bool DesignatedInit = false;
+    bool Required = false;
+    StringRef ResultType;
+  };
+  typedef std::vector<Method> MethodsSeq;
+
+  struct Property {
+    StringRef Name;
+    llvm::Optional<MethodKind> Kind;
+    llvm::Optional<NullabilityKind> Nullability;
+    AvailabilityItem Availability;
+    Optional<bool> SwiftPrivate;
+    StringRef SwiftName;
+    Optional<bool> SwiftImportAsAccessors;
+    StringRef Type;
+  };
+  typedef std::vector<Property> PropertiesSeq;
+
+  struct Class {
+    StringRef Name;
+    bool AuditedForNullability = false;
+    AvailabilityItem Availability;
+    Optional<bool> SwiftPrivate;
+    StringRef SwiftName;
+    Optional<StringRef> SwiftBridge;
+    Optional<StringRef> NSErrorDomain;
+    Optional<bool> SwiftImportAsNonGeneric;
+    Optional<bool> SwiftObjCMembers;
+    MethodsSeq Methods;
+    PropertiesSeq Properties;
+  };
+  typedef std::vector<Class> ClassesSeq;
+
+  struct Function {
+    StringRef Name;
+    ParamsSeq Params;
+    NullabilitySeq Nullability;
+    Optional<NullabilityKind> NullabilityOfRet;
+    Optional<api_notes::RetainCountConventionKind> RetainCountConvention;
+    AvailabilityItem Availability;
+    Optional<bool> SwiftPrivate;
+    StringRef SwiftName;
+    StringRef Type;
+    StringRef ResultType;
+  };
+  typedef std::vector<Function> FunctionsSeq;
+
+  struct GlobalVariable {
+    StringRef Name;
+    llvm::Optional<NullabilityKind> Nullability;
+    AvailabilityItem Availability;
+    Optional<bool> SwiftPrivate;
+    StringRef SwiftName;
+    StringRef Type;
+  };
+  typedef std::vector<GlobalVariable> GlobalVariablesSeq;
+
+  struct EnumConstant {
+    StringRef Name;
+    AvailabilityItem Availability;
+    Optional<bool> SwiftPrivate;
+    StringRef SwiftName;
+  };
+  typedef std::vector<EnumConstant> EnumConstantsSeq;
+
+  struct Tag {
+    StringRef Name;
+    AvailabilityItem Availability;
+    StringRef SwiftName;
+    Optional<bool> SwiftPrivate;
+    Optional<StringRef> SwiftBridge;
+    Optional<StringRef> NSErrorDomain;
+    Optional<api_notes::EnumExtensibilityKind> EnumExtensibility;
+    Optional<bool> FlagEnum;
+    Optional<EnumConvenienceAliasKind> EnumConvenienceKind;
+  };
+  typedef std::vector<Tag> TagsSeq;
+
+  struct Typedef {
+    StringRef Name;
+    AvailabilityItem Availability;
+    StringRef SwiftName;
+    Optional<bool> SwiftPrivate;
+    Optional<StringRef> SwiftBridge;
+    Optional<StringRef> NSErrorDomain;
+    Optional<api_notes::SwiftWrapperKind> SwiftWrapper;
+  };
+  typedef std::vector<Typedef> TypedefsSeq;
+
+  struct TopLevelItems {
+    ClassesSeq Classes;
+    ClassesSeq Protocols;
+    FunctionsSeq Functions;
+    GlobalVariablesSeq Globals;
+    EnumConstantsSeq EnumConstants;
+    TagsSeq Tags;
+    TypedefsSeq Typedefs;
+  };
+
+  struct Versioned {
+    VersionTuple Version;
+    TopLevelItems Items;
+  };
+
+  typedef std::vector<Versioned> VersionedSeq;
+
+  struct Module {
+    StringRef Name;
+    AvailabilityItem Availability;
+    TopLevelItems TopLevel;
+    VersionedSeq SwiftVersions;
+
+    llvm::Optional<bool> SwiftInferImportAsMember = {llvm::None};
+
+    LLVM_ATTRIBUTE_DEPRECATED(
+      void dump() LLVM_ATTRIBUTE_USED,
+      "only for use within the debugger");
+  };
+}
+
+LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(clang::NullabilityKind)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Method)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Property)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Param)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Class)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Function)
+LLVM_YAML_IS_SEQUENCE_VECTOR(GlobalVariable)
+LLVM_YAML_IS_SEQUENCE_VECTOR(EnumConstant)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Tag)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Typedef)
+LLVM_YAML_IS_SEQUENCE_VECTOR(Versioned)
+
+namespace llvm {
+  namespace yaml {
+
+    template <>
+    struct ScalarEnumerationTraits<NullabilityKind > {
+      static void enumeration(IO &io, NullabilityKind  &value) {
+        io.enumCase(value, "N", NullabilityKind::NonNull);
+        io.enumCase(value, "O", NullabilityKind::Nullable);
+        io.enumCase(value, "U", NullabilityKind::Unspecified);
+        // TODO: Mapping this to it's own value would allow for better cross
+        // checking. Also the default should be Unknown.
+        io.enumCase(value, "S", NullabilityKind::Unspecified);
+      }
+    };
+
+    template <>
+    struct ScalarEnumerationTraits<FactoryAsInitKind> {
+      static void enumeration(IO &io, FactoryAsInitKind  &value) {
+        io.enumCase(value, "A", FactoryAsInitKind::Infer);
+        io.enumCase(value, "C", FactoryAsInitKind::AsClassMethod);
+        io.enumCase(value, "I", FactoryAsInitKind::AsInitializer);
+      }
+    };
+
+    template <>
+    struct ScalarEnumerationTraits<MethodKind> {
+      static void enumeration(IO &io, MethodKind &value) {
+        io.enumCase(value, "Class",    MethodKind::Class);
+        io.enumCase(value, "Instance", MethodKind::Instance);
+      }
+    };
+
+    template <>
+    struct ScalarEnumerationTraits<APIAvailability> {
+      static void enumeration(IO &io, APIAvailability &value) {
+        io.enumCase(value, "OSX",       APIAvailability::OSX);
+        io.enumCase(value, "iOS",       APIAvailability::IOS);
+        io.enumCase(value, "none",      APIAvailability::None);
+        io.enumCase(value, "nonswift",  APIAvailability::NonSwift);
+        io.enumCase(value, "available", APIAvailability::Available);
+      }
+    };
+
+    template<>
+    struct ScalarEnumerationTraits<api_notes::SwiftWrapperKind> {
+      static void enumeration(IO &io, api_notes::SwiftWrapperKind &value) {
+        io.enumCase(value, "none",      api_notes::SwiftWrapperKind::None);
+        io.enumCase(value, "struct",    api_notes::SwiftWrapperKind::Struct);
+        io.enumCase(value, "enum",      api_notes::SwiftWrapperKind::Enum);
+      }
+    };
+
+    template<>
+    struct ScalarEnumerationTraits<api_notes::EnumExtensibilityKind> {
+      static void enumeration(IO &io, api_notes::EnumExtensibilityKind &value) {
+        io.enumCase(value, "none",   api_notes::EnumExtensibilityKind::None);
+        io.enumCase(value, "open",   api_notes::EnumExtensibilityKind::Open);
+        io.enumCase(value, "closed", api_notes::EnumExtensibilityKind::Closed);
+      }
+    };
+
+    template<>
+    struct ScalarEnumerationTraits<EnumConvenienceAliasKind> {
+      static void enumeration(IO &io, EnumConvenienceAliasKind &value) {
+        io.enumCase(value, "none",      EnumConvenienceAliasKind::None);
+        io.enumCase(value, "CFEnum",    EnumConvenienceAliasKind::CFEnum);
+        io.enumCase(value, "NSEnum",    EnumConvenienceAliasKind::CFEnum);
+        io.enumCase(value, "CFOptions", EnumConvenienceAliasKind::CFOptions);
+        io.enumCase(value, "NSOptions", EnumConvenienceAliasKind::CFOptions);
+        io.enumCase(value, "CFClosedEnum",
+                    EnumConvenienceAliasKind::CFClosedEnum);
+        io.enumCase(value, "NSClosedEnum",
+                    EnumConvenienceAliasKind::CFClosedEnum);
+      }
+    };
+
+    template<>
+    struct ScalarEnumerationTraits<api_notes::RetainCountConventionKind> {
+      static void enumeration(IO &io,
+                              api_notes::RetainCountConventionKind &value) {
+        using api_notes::RetainCountConventionKind;
+        io.enumCase(value, "none", RetainCountConventionKind::None);
+        io.enumCase(value, "CFReturnsRetained",
+                    RetainCountConventionKind::CFReturnsRetained);
+        io.enumCase(value, "CFReturnsNotRetained",
+                    RetainCountConventionKind::CFReturnsNotRetained);
+        io.enumCase(value, "NSReturnsRetained",
+                    RetainCountConventionKind::NSReturnsRetained);
+        io.enumCase(value, "NSReturnsNotRetained",
+                    RetainCountConventionKind::NSReturnsNotRetained);
+      }
+    };
+
+    template <>
+    struct ScalarTraits<VersionTuple> {
+      static void output(const VersionTuple &value, void*,
+                         llvm::raw_ostream &out) {
+        out << value;
+      }
+      static StringRef input(StringRef scalar, void*, VersionTuple &value) {
+        if (value.tryParse(scalar))
+          return "not a version number in the form XX.YY";
+
+        // Canonicalize on '.' as a separator.
+        value.UseDotAsSeparator();
+        return StringRef();
+      }
+
+      static QuotingType mustQuote(StringRef) { return QuotingType::None; }
+    };
+
+    template <>
+    struct MappingTraits<Param> {
+      static void mapping(IO &io, Param& p) {
+        io.mapRequired("Position",              p.Position);
+        io.mapOptional("Nullability",           p.Nullability, 
+                                                AbsentNullability);
+        io.mapOptional("RetainCountConvention", p.RetainCountConvention);
+        io.mapOptional("NoEscape",              p.NoEscape);
+        io.mapOptional("Type",                  p.Type, StringRef(""));
+      }
+    };
+
+    template <>
+    struct MappingTraits<Property> {
+      static void mapping(IO &io, Property& p) {
+        io.mapRequired("Name",            p.Name);
+        io.mapOptional("PropertyKind",    p.Kind);
+        io.mapOptional("Nullability",     p.Nullability, 
+                                          AbsentNullability);
+        io.mapOptional("Availability",    p.Availability.Mode);
+        io.mapOptional("AvailabilityMsg", p.Availability.Msg);
+        io.mapOptional("SwiftPrivate",    p.SwiftPrivate);
+        io.mapOptional("SwiftName",       p.SwiftName);
+        io.mapOptional("SwiftImportAsAccessors", p.SwiftImportAsAccessors);
+        io.mapOptional("Type",            p.Type, StringRef(""));
+      }
+    };
+
+    template <>
+    struct MappingTraits<Method> {
+      static void mapping(IO &io, Method& m) {
+        io.mapRequired("Selector",              m.Selector);
+        io.mapRequired("MethodKind",            m.Kind);
+        io.mapOptional("Parameters",            m.Params);
+        io.mapOptional("Nullability",           m.Nullability);
+        io.mapOptional("NullabilityOfRet",      m.NullabilityOfRet,
+                                                AbsentNullability);
+        io.mapOptional("RetainCountConvention", m.RetainCountConvention);
+        io.mapOptional("Availability",          m.Availability.Mode);
+        io.mapOptional("AvailabilityMsg",       m.Availability.Msg);
+        io.mapOptional("SwiftPrivate",          m.SwiftPrivate);
+        io.mapOptional("SwiftName",             m.SwiftName);
+        io.mapOptional("FactoryAsInit",         m.FactoryAsInit,
+                                                FactoryAsInitKind::Infer);
+        io.mapOptional("DesignatedInit",        m.DesignatedInit, false);
+        io.mapOptional("Required",              m.Required, false);
+        io.mapOptional("ResultType",            m.ResultType, StringRef(""));
+      }
+    };
+
+    template <>
+    struct MappingTraits<Class> {
+      static void mapping(IO &io, Class& c) {
+        io.mapRequired("Name",                  c.Name);
+        io.mapOptional("AuditedForNullability", c.AuditedForNullability, false);
+        io.mapOptional("Availability",          c.Availability.Mode);
+        io.mapOptional("AvailabilityMsg",       c.Availability.Msg);
+        io.mapOptional("SwiftPrivate",          c.SwiftPrivate);
+        io.mapOptional("SwiftName",             c.SwiftName);
+        io.mapOptional("SwiftBridge",           c.SwiftBridge);
+        io.mapOptional("NSErrorDomain",         c.NSErrorDomain);
+        io.mapOptional("SwiftImportAsNonGeneric", c.SwiftImportAsNonGeneric);
+        io.mapOptional("SwiftObjCMembers",      c.SwiftObjCMembers);
+        io.mapOptional("Methods",               c.Methods);
+        io.mapOptional("Properties",            c.Properties);
+      }
+    };
+
+    template <>
+    struct MappingTraits<Function> {
+      static void mapping(IO &io, Function& f) {
+        io.mapRequired("Name",                  f.Name);
+        io.mapOptional("Parameters",            f.Params);
+        io.mapOptional("Nullability",           f.Nullability);
+        io.mapOptional("NullabilityOfRet",      f.NullabilityOfRet,
+                                                AbsentNullability);
+        io.mapOptional("RetainCountConvention", f.RetainCountConvention);
+        io.mapOptional("Availability",          f.Availability.Mode);
+        io.mapOptional("AvailabilityMsg",       f.Availability.Msg);
+        io.mapOptional("SwiftPrivate",          f.SwiftPrivate);
+        io.mapOptional("SwiftName",             f.SwiftName);
+        io.mapOptional("ResultType",            f.ResultType, StringRef(""));
+      }
+    };
+
+    template <>
+    struct MappingTraits<GlobalVariable> {
+      static void mapping(IO &io, GlobalVariable& v) {
+        io.mapRequired("Name",            v.Name);
+        io.mapOptional("Nullability",     v.Nullability,
+                                          AbsentNullability);
+        io.mapOptional("Availability",    v.Availability.Mode);
+        io.mapOptional("AvailabilityMsg", v.Availability.Msg);
+        io.mapOptional("SwiftPrivate",    v.SwiftPrivate);
+        io.mapOptional("SwiftName",       v.SwiftName);
+        io.mapOptional("Type",            v.Type, StringRef(""));
+      }
+    };
+
+    template <>
+    struct MappingTraits<EnumConstant> {
+      static void mapping(IO &io, EnumConstant& v) {
+        io.mapRequired("Name",            v.Name);
+        io.mapOptional("Availability",    v.Availability.Mode);
+        io.mapOptional("AvailabilityMsg", v.Availability.Msg);
+        io.mapOptional("SwiftPrivate",    v.SwiftPrivate);
+        io.mapOptional("SwiftName",       v.SwiftName);
+      }
+    };
+
+    template <>
+    struct MappingTraits<Tag> {
+      static void mapping(IO &io, Tag& t) {
+        io.mapRequired("Name",                  t.Name);
+        io.mapOptional("Availability",          t.Availability.Mode);
+        io.mapOptional("AvailabilityMsg",       t.Availability.Msg);
+        io.mapOptional("SwiftPrivate",          t.SwiftPrivate);
+        io.mapOptional("SwiftName",             t.SwiftName);
+        io.mapOptional("SwiftBridge",           t.SwiftBridge);
+        io.mapOptional("NSErrorDomain",         t.NSErrorDomain);
+        io.mapOptional("EnumExtensibility",     t.EnumExtensibility);
+        io.mapOptional("FlagEnum",              t.FlagEnum);
+        io.mapOptional("EnumKind",              t.EnumConvenienceKind);
+      }
+    };
+
+    template <>
+    struct MappingTraits<Typedef> {
+      static void mapping(IO &io, Typedef& t) {
+        io.mapRequired("Name",                  t.Name);
+        io.mapOptional("Availability",          t.Availability.Mode);
+        io.mapOptional("AvailabilityMsg",       t.Availability.Msg);
+        io.mapOptional("SwiftPrivate",          t.SwiftPrivate);
+        io.mapOptional("SwiftName",             t.SwiftName);
+        io.mapOptional("SwiftBridge",           t.SwiftBridge);
+        io.mapOptional("NSErrorDomain",         t.NSErrorDomain);
+        io.mapOptional("SwiftWrapper",         t.SwiftWrapper);
+      }
+    };
+
+    static void mapTopLevelItems(IO &io, TopLevelItems &i) {
+      io.mapOptional("Classes",         i.Classes);
+      io.mapOptional("Protocols",       i.Protocols);
+      io.mapOptional("Functions",       i.Functions);
+      io.mapOptional("Globals",         i.Globals);
+      io.mapOptional("Enumerators",     i.EnumConstants);
+      io.mapOptional("Tags",            i.Tags);
+      io.mapOptional("Typedefs",        i.Typedefs);
+    }
+
+    template <>
+    struct MappingTraits<Versioned> {
+      static void mapping(IO &io, Versioned& v) {
+        io.mapRequired("Version", v.Version);
+        mapTopLevelItems(io, v.Items);
+      }
+    };
+
+    template <>
+    struct MappingTraits<Module> {
+      static void mapping(IO &io, Module& m) {
+        io.mapRequired("Name",            m.Name);
+        io.mapOptional("Availability",    m.Availability.Mode);
+        io.mapOptional("AvailabilityMsg", m.Availability.Msg);
+        io.mapOptional("SwiftInferImportAsMember", m.SwiftInferImportAsMember);
+
+        mapTopLevelItems(io, m.TopLevel);
+
+        io.mapOptional("SwiftVersions",  m.SwiftVersions);
+      }
+    };
+  }
+}
+
+using llvm::yaml::Input;
+using llvm::yaml::Output;
+
+void Module::dump() {
+  Output yout(llvm::errs());
+  yout << *this;
+}
+
+static bool parseAPINotes(StringRef yamlInput, Module &module,
+                          llvm::SourceMgr::DiagHandlerTy diagHandler,
+                          void *diagHandlerCtxt) {
+  Input yin(yamlInput, nullptr, diagHandler, diagHandlerCtxt);
+  yin >> module;
+
+  return static_cast<bool>(yin.error());
+}
+
+namespace {
+  using namespace api_notes;
+
+  class YAMLConverter {
+    const Module &TheModule;
+    const FileEntry *SourceFile;
+    APINotesWriter *Writer;
+    OSType TargetOS;
+    llvm::raw_ostream &OS;
+    llvm::SourceMgr::DiagHandlerTy DiagHandler;
+    void *DiagHandlerCtxt;
+    bool ErrorOccured;
+
+    /// Emit a diagnostic
+    bool emitError(llvm::Twine message) {
+      DiagHandler(llvm::SMDiagnostic("", llvm::SourceMgr::DK_Error,
+                                     message.str()),
+                  DiagHandlerCtxt);
+      ErrorOccured = true;
+      return true;
+    }
+
+  public:
+    YAMLConverter(const Module &module,
+                  const FileEntry *sourceFile,
+                  OSType targetOS,
+                  llvm::raw_ostream &os,
+                  llvm::SourceMgr::DiagHandlerTy diagHandler,
+                  void *diagHandlerCtxt) :
+      TheModule(module), SourceFile(sourceFile), Writer(0), TargetOS(targetOS), OS(os),
+      DiagHandler(diagHandler), DiagHandlerCtxt(diagHandlerCtxt),
+      ErrorOccured(false) {}
+
+    bool isAvailable(const AvailabilityItem &in) {
+      // Check if the API is available on the OS for which we are building.
+      if (in.Mode == APIAvailability::OSX && TargetOS != OSType::OSX)
+        return false;
+      if (in.Mode == APIAvailability::IOS && TargetOS != OSType::IOS)
+        return false;
+      return true;
+    }
+
+    bool convertAvailability(const AvailabilityItem &in,
+                             CommonEntityInfo &outInfo,
+                             llvm::StringRef apiName) {
+      // Populate the unavailability information.
+      outInfo.Unavailable = (in.Mode == APIAvailability::None);
+      outInfo.UnavailableInSwift = (in.Mode == APIAvailability::NonSwift);
+      if (outInfo.Unavailable || outInfo.UnavailableInSwift) {
+        outInfo.UnavailableMsg = in.Msg;
+      } else {
+        if (!in.Msg.empty()) {
+          emitError("availability message for available API '" +
+                    apiName + "' will not be used");
+        }
+      }
+      return false;
+    }
+
+    void convertParams(const ParamsSeq &params, FunctionInfo &outInfo) {
+      for (const auto &p : params) {
+        ParamInfo pi;
+        if (p.Nullability)
+          pi.setNullabilityAudited(*p.Nullability);
+        pi.setNoEscape(p.NoEscape);
+        pi.setType(p.Type);
+        pi.setRetainCountConvention(p.RetainCountConvention);
+        while (outInfo.Params.size() <= p.Position) {
+          outInfo.Params.push_back(ParamInfo());
+        }
+        outInfo.Params[p.Position] |= pi;
+      }
+    }
+
+    void convertNullability(const NullabilitySeq &nullability,
+                            Optional<NullabilityKind> nullabilityOfRet,
+                            FunctionInfo &outInfo,
+                            llvm::StringRef apiName) {
+      if (nullability.size() > FunctionInfo::getMaxNullabilityIndex()) {
+        emitError("nullability info for " + apiName + " does not fit");
+        return;
+      }
+
+      bool audited = false;
+      unsigned int idx = 1;
+      for (auto i = nullability.begin(),
+                e = nullability.end(); i != e; ++i, ++idx){
+        outInfo.addTypeInfo(idx, *i);
+        audited = true;
+      }
+      if (nullabilityOfRet) {
+        outInfo.addTypeInfo(0, *nullabilityOfRet);
+        audited = true;
+      } else if (audited) {
+        outInfo.addTypeInfo(0, *DefaultNullability);
+      }
+      if (audited) {
+        outInfo.NullabilityAudited = audited;
+        outInfo.NumAdjustedNullable = idx;
+      }
+    }
+
+    /// Convert the common parts of an entity from YAML.
+    template<typename T>
+    bool convertCommon(const T& common, CommonEntityInfo &info,
+                       StringRef apiName) {
+      if (!isAvailable(common.Availability))
+        return true;
+
+      convertAvailability(common.Availability, info, apiName);
+      info.setSwiftPrivate(common.SwiftPrivate);
+      info.SwiftName = common.SwiftName;
+      return false;
+    }
+    
+    /// Convert the common parts of a type entity from YAML.
+    template<typename T>
+    bool convertCommonType(const T& common, CommonTypeInfo &info,
+                           StringRef apiName) {
+      if (convertCommon(common, info, apiName))
+        return true;
+
+      info.setSwiftBridge(common.SwiftBridge);
+      info.setNSErrorDomain(common.NSErrorDomain);
+      return false;
+    }
+
+    // Translate from Method into ObjCMethodInfo and write it out.
+    void convertMethod(const Method &meth,
+                       ContextID classID, StringRef className,
+                       VersionTuple swiftVersion) {
+      ObjCMethodInfo mInfo;
+
+      if (convertCommon(meth, mInfo, meth.Selector))
+        return;
+
+      // Check if the selector ends with ':' to determine if it takes arguments.
+      bool takesArguments = meth.Selector.endswith(":");
+
+      // Split the selector into pieces.
+      llvm::SmallVector<StringRef, 4> a;
+      meth.Selector.split(a, ":", /*MaxSplit*/ -1, /*KeepEmpty*/ false);
+      if (!takesArguments && a.size() > 1 ) {
+        emitError("selector " + meth.Selector + "is missing a ':' at the end");
+        return;
+      }
+
+      // Construct ObjCSelectorRef.
+      api_notes::ObjCSelectorRef selectorRef;
+      selectorRef.NumPieces = !takesArguments ? 0 : a.size();
+      selectorRef.Identifiers = a;
+
+      // Translate the initializer info.
+      mInfo.DesignatedInit = meth.DesignatedInit;
+      mInfo.Required = meth.Required;
+      if (meth.FactoryAsInit != FactoryAsInitKind::Infer) {
+        emitError("'FactoryAsInit' is no longer valid; "
+                  "use 'SwiftName' instead");
+      }
+      mInfo.ResultType = meth.ResultType;
+
+      // Translate parameter information.
+      convertParams(meth.Params, mInfo);
+
+      // Translate nullability info.
+      convertNullability(meth.Nullability, meth.NullabilityOfRet,
+                         mInfo, meth.Selector);
+
+      mInfo.setRetainCountConvention(meth.RetainCountConvention);
+
+      // Write it.
+      Writer->addObjCMethod(classID, selectorRef,
+                            meth.Kind == MethodKind::Instance,
+                            mInfo, swiftVersion);
+    }
+
+    void convertContext(const Class &cl, bool isClass,
+                        VersionTuple swiftVersion) {
+      // Write the class.
+      ObjCContextInfo cInfo;
+
+      if (convertCommonType(cl, cInfo, cl.Name))
+        return;
+
+      if (cl.AuditedForNullability)
+        cInfo.setDefaultNullability(*DefaultNullability);
+      if (cl.SwiftImportAsNonGeneric)
+        cInfo.setSwiftImportAsNonGeneric(*cl.SwiftImportAsNonGeneric);
+      if (cl.SwiftObjCMembers)
+        cInfo.setSwiftObjCMembers(*cl.SwiftObjCMembers);
+
+      ContextID clID = Writer->addObjCContext(cl.Name, isClass, cInfo,
+                                              swiftVersion);
+
+      // Write all methods.
+      llvm::StringMap<std::pair<bool, bool>> knownMethods;
+      for (const auto &method : cl.Methods) {
+        // Check for duplicate method definitions.
+        bool isInstanceMethod = method.Kind == MethodKind::Instance;
+        bool &known = isInstanceMethod ? knownMethods[method.Selector].first
+                                       : knownMethods[method.Selector].second;
+        if (known) {
+          emitError(llvm::Twine("duplicate definition of method '") +
+                    (isInstanceMethod? "-" : "+") + "[" + cl.Name + " " +
+                    method.Selector + "]'");
+          continue;
+        }
+        known = true;
+
+        convertMethod(method, clID, cl.Name, swiftVersion);
+      }
+
+      // Write all properties.
+      llvm::StringSet<> knownInstanceProperties;
+      llvm::StringSet<> knownClassProperties;
+      for (const auto &prop : cl.Properties) {
+        // Check for duplicate property definitions.
+        if ((!prop.Kind || *prop.Kind == MethodKind::Instance) &&
+            !knownInstanceProperties.insert(prop.Name).second) {
+          emitError("duplicate definition of instance property '" + cl.Name +
+                    "." + prop.Name + "'");
+          continue;
+        }
+
+        if ((!prop.Kind || *prop.Kind == MethodKind::Class) &&
+            !knownClassProperties.insert(prop.Name).second) {
+          emitError("duplicate definition of class property '" + cl.Name + "." +
+                    prop.Name + "'");
+          continue;
+        }
+
+        // Translate from Property into ObjCPropertyInfo.
+        ObjCPropertyInfo pInfo;
+        if (!isAvailable(prop.Availability))
+          continue;
+        convertAvailability(prop.Availability, pInfo, prop.Name);
+        pInfo.setSwiftPrivate(prop.SwiftPrivate);
+        pInfo.SwiftName = prop.SwiftName;
+        if (prop.Nullability)
+          pInfo.setNullabilityAudited(*prop.Nullability);
+        if (prop.SwiftImportAsAccessors)
+          pInfo.setSwiftImportAsAccessors(*prop.SwiftImportAsAccessors);
+        pInfo.setType(prop.Type);
+        if (prop.Kind) {
+          Writer->addObjCProperty(clID, prop.Name,
+                                  *prop.Kind == MethodKind::Instance, pInfo,
+                                  swiftVersion);
+        } else {
+          // Add both instance and class properties with this name.
+          Writer->addObjCProperty(clID, prop.Name, true, pInfo, swiftVersion);
+          Writer->addObjCProperty(clID, prop.Name, false, pInfo, swiftVersion);
+        }
+      }
+    }
+
+    void convertTopLevelItems(const TopLevelItems &items,
+                              VersionTuple swiftVersion) {
+      // Write all classes.
+      llvm::StringSet<> knownClasses;
+      for (const auto &cl : items.Classes) {
+        // Check for duplicate class definitions.
+        if (!knownClasses.insert(cl.Name).second) {
+          emitError("multiple definitions of class '" + cl.Name + "'");
+          continue;
+        }
+
+        convertContext(cl, /*isClass*/ true, swiftVersion);
+      }
+
+      // Write all protocols.
+      llvm::StringSet<> knownProtocols;
+      for (const auto &pr : items.Protocols) {
+        // Check for duplicate protocol definitions.
+        if (!knownProtocols.insert(pr.Name).second) {
+          emitError("multiple definitions of protocol '" + pr.Name + "'");
+          continue;
+        }
+
+        convertContext(pr, /*isClass*/ false, swiftVersion);
+      }
+
+      // Write all global variables.
+      llvm::StringSet<> knownGlobals;
+      for (const auto &global : items.Globals) {
+        // Check for duplicate global variables.
+        if (!knownGlobals.insert(global.Name).second) {
+          emitError("multiple definitions of global variable '" +
+                    global.Name + "'");
+          continue;
+        }
+
+        GlobalVariableInfo info;
+        if (!isAvailable(global.Availability))
+          continue;
+        convertAvailability(global.Availability, info, global.Name);
+        info.setSwiftPrivate(global.SwiftPrivate);
+        info.SwiftName = global.SwiftName;
+        if (global.Nullability)
+          info.setNullabilityAudited(*global.Nullability);
+        info.setType(global.Type);
+        Writer->addGlobalVariable(global.Name, info, swiftVersion);
+      }
+
+      // Write all global functions.
+      llvm::StringSet<> knownFunctions;
+      for (const auto &function : items.Functions) {
+        // Check for duplicate global functions.
+        if (!knownFunctions.insert(function.Name).second) {
+          emitError("multiple definitions of global function '" +
+                    function.Name + "'");
+          continue;
+        }
+
+        GlobalFunctionInfo info;
+        if (!isAvailable(function.Availability))
+          continue;
+        convertAvailability(function.Availability, info, function.Name);
+        info.setSwiftPrivate(function.SwiftPrivate);
+        info.SwiftName = function.SwiftName;
+        convertParams(function.Params, info);
+        convertNullability(function.Nullability,
+                           function.NullabilityOfRet,
+                           info, function.Name);
+        info.ResultType = function.ResultType;
+        info.setRetainCountConvention(function.RetainCountConvention);
+        Writer->addGlobalFunction(function.Name, info, swiftVersion);
+      }
+
+      // Write all enumerators.
+      llvm::StringSet<> knownEnumConstants;
+      for (const auto &enumConstant : items.EnumConstants) {
+        // Check for duplicate enumerators
+        if (!knownEnumConstants.insert(enumConstant.Name).second) {
+          emitError("multiple definitions of enumerator '" +
+                    enumConstant.Name + "'");
+          continue;
+        }
+
+        EnumConstantInfo info;
+        if (!isAvailable(enumConstant.Availability))
+          continue;
+        convertAvailability(enumConstant.Availability, info, enumConstant.Name);
+        info.setSwiftPrivate(enumConstant.SwiftPrivate);
+        info.SwiftName = enumConstant.SwiftName;
+        Writer->addEnumConstant(enumConstant.Name, info, swiftVersion);
+      }
+
+      // Write all tags.
+      llvm::StringSet<> knownTags;
+      for (const auto &t : items.Tags) {
+        // Check for duplicate tag definitions.
+        if (!knownTags.insert(t.Name).second) {
+          emitError("multiple definitions Of tag '" + t.Name + "'");
+          continue;
+        }
+
+        TagInfo tagInfo;
+        if (convertCommonType(t, tagInfo, t.Name))
+          continue;
+
+        if (t.EnumConvenienceKind) {
+          if (t.EnumExtensibility) {
+            emitError(llvm::Twine(
+                "cannot mix EnumKind and EnumExtensibility (for ") + t.Name +
+                ")");
+            continue;
+          }
+          if (t.FlagEnum) {
+            emitError(llvm::Twine("cannot mix EnumKind and FlagEnum (for ") +
+                t.Name + ")");
+            continue;
+          }
+          switch (t.EnumConvenienceKind.getValue()) {
+          case EnumConvenienceAliasKind::None:
+            tagInfo.EnumExtensibility = EnumExtensibilityKind::None;
+            tagInfo.setFlagEnum(false);
+            break;
+          case EnumConvenienceAliasKind::CFEnum:
+            tagInfo.EnumExtensibility = EnumExtensibilityKind::Open;
+            tagInfo.setFlagEnum(false);
+            break;
+          case EnumConvenienceAliasKind::CFOptions:
+            tagInfo.EnumExtensibility = EnumExtensibilityKind::Open;
+            tagInfo.setFlagEnum(true);
+            break;
+          case EnumConvenienceAliasKind::CFClosedEnum:
+            tagInfo.EnumExtensibility = EnumExtensibilityKind::Closed;
+            tagInfo.setFlagEnum(false);
+            break;
+          }
+        } else {
+          tagInfo.EnumExtensibility = t.EnumExtensibility;
+          tagInfo.setFlagEnum(t.FlagEnum);          
+        }
+
+        Writer->addTag(t.Name, tagInfo, swiftVersion);
+      }
+
+      // Write all typedefs.
+      llvm::StringSet<> knownTypedefs;
+      for (const auto &t : items.Typedefs) {
+        // Check for duplicate typedef definitions.
+        if (!knownTypedefs.insert(t.Name).second) {
+          emitError("multiple definitions of typedef '" + t.Name + "'");
+          continue;
+        }
+
+        TypedefInfo typedefInfo;
+        if (convertCommonType(t, typedefInfo, t.Name))
+          continue;
+        typedefInfo.SwiftWrapper = t.SwiftWrapper;
+
+        Writer->addTypedef(t.Name, typedefInfo, swiftVersion);
+      }
+    }
+
+    bool convertModule() {
+      if (!isAvailable(TheModule.Availability))
+        return false;
+
+      // Set up the writer.
+      // FIXME: This is kindof ugly.
+      APINotesWriter writer(TheModule.Name, SourceFile);
+      Writer = &writer;
+
+      // Write the top-level items.
+      convertTopLevelItems(TheModule.TopLevel, VersionTuple());
+
+      if (TheModule.SwiftInferImportAsMember) {
+        ModuleOptions opts;
+        opts.SwiftInferImportAsMember = true;
+        Writer->addModuleOptions(opts);
+      }
+
+      // Convert the versioned information.
+      for (const auto &versioned : TheModule.SwiftVersions) {
+        convertTopLevelItems(versioned.Items, versioned.Version);
+      }
+
+      if (!ErrorOccured)
+        Writer->writeToStream(OS);
+
+      return ErrorOccured;
+    }
+  };
+}
+
+static bool compile(const Module &module,
+                    const FileEntry *sourceFile,
+                    llvm::raw_ostream &os,
+                    api_notes::OSType targetOS,
+                    llvm::SourceMgr::DiagHandlerTy diagHandler,
+                    void *diagHandlerCtxt){
+  using namespace api_notes;
+
+  YAMLConverter c(module, sourceFile, targetOS, os, diagHandler, diagHandlerCtxt);
+  return c.convertModule();
+}
+
+bool api_notes::parseAndDumpAPINotes(StringRef yamlInput)  {
+  Module module;
+
+  if (parseAPINotes(yamlInput, module, nullptr, nullptr))
+    return true;
+
+  Output yout(llvm::outs());
+  yout << module;
+
+  return false;
+}
+
+/// Simple diagnostic handler that prints diagnostics to standard error.
+static void printDiagnostic(const llvm::SMDiagnostic &diag, void *context) {
+  diag.print(nullptr, llvm::errs());
+}
+
+bool api_notes::compileAPINotes(StringRef yamlInput,
+                                const FileEntry *sourceFile,
+                                llvm::raw_ostream &os,
+                                OSType targetOS,
+                                llvm::SourceMgr::DiagHandlerTy diagHandler,
+                                void *diagHandlerCtxt) {
+  Module module;
+
+  if (!diagHandler) {
+    diagHandler = &printDiagnostic;
+  }
+
+  if (parseAPINotes(yamlInput, module, diagHandler, diagHandlerCtxt))
+    return true;
+
+  return compile(module, sourceFile, os, targetOS, diagHandler, diagHandlerCtxt);
+}
+
+namespace {
+  // Deserialize the API notes file into a module.
+  class DecompileVisitor : public APINotesReader::Visitor {
+    /// Allocator used to clone those strings that need it.
+    llvm::BumpPtrAllocator Allocator;
+
+    /// The module we're building.
+    Module TheModule;
+
+    /// A known context, which tracks what we know about a context ID.
+    struct KnownContext {
+      /// Whether this is a protocol (vs. a class).
+      bool isProtocol;
+
+      /// The indices into the top-level items for this context at each
+      /// Swift version.
+      SmallVector<std::pair<VersionTuple, unsigned>, 1> indices;
+
+      Class &getContext(const VersionTuple &swiftVersion,
+                        TopLevelItems &items) {
+        ClassesSeq &seq = isProtocol ? items.Protocols : items.Classes;
+
+        for (auto &index : indices) {
+          if (index.first == swiftVersion)
+            return seq[index.second];
+        }
+
+        indices.push_back({swiftVersion, seq.size()});
+        seq.push_back(Class());
+        return seq.back();
+      }
+    };
+
+    /// A mapping from context ID to a pair (index, is-protocol) that indicates
+    /// the index of that class or protocol in the global "classes" or
+    /// "protocols" list.
+    llvm::DenseMap<unsigned, KnownContext> knownContexts;
+
+    /// Copy a string into allocated memory so it does disappear on us.
+    StringRef copyString(StringRef string) {
+      if (string.empty()) return StringRef();
+
+      void *ptr = Allocator.Allocate(string.size(), 1);
+      memcpy(ptr, string.data(), string.size());
+      return StringRef(reinterpret_cast<const char *>(ptr), string.size());
+    }
+
+    /// Copy an optional string into allocated memory so it does disappear on us.
+    Optional<StringRef> maybeCopyString(Optional<StringRef> string) {
+      if (!string) return None;
+
+      return copyString(*string);
+    }
+
+    /// Copy an optional string into allocated memory so it does disappear on us.
+    Optional<StringRef> maybeCopyString(Optional<std::string> string) {
+      if (!string) return None;
+
+      return copyString(*string);
+    }
+
+    template<typename T>
+    void handleCommon(T &record, const CommonEntityInfo &info) {
+      handleAvailability(record.Availability, info);
+      record.SwiftPrivate = info.isSwiftPrivate();
+      record.SwiftName = copyString(info.SwiftName);
+    }
+
+    template<typename T>
+    void handleCommonType(T &record, const CommonTypeInfo &info) {
+      handleCommon(record, info);
+      record.SwiftBridge = maybeCopyString(info.getSwiftBridge());
+      record.NSErrorDomain = maybeCopyString(info.getNSErrorDomain());
+    }
+
+    /// Map Objective-C context info.
+    void handleObjCContext(Class &record, StringRef name,
+                           const ObjCContextInfo &info) {
+      record.Name = name;
+
+      handleCommonType(record, info);
+      record.SwiftImportAsNonGeneric = info.getSwiftImportAsNonGeneric();
+      record.SwiftObjCMembers = info.getSwiftObjCMembers();
+
+      if (info.getDefaultNullability()) {
+        record.AuditedForNullability = true;
+      }
+    }
+
+    /// Map availability information, if present.
+    void handleAvailability(AvailabilityItem &availability,
+                            const CommonEntityInfo &info) {
+      if (info.Unavailable) {
+        availability.Mode = APIAvailability::None;
+        availability.Msg = copyString(info.UnavailableMsg);
+      }
+
+      if (info.UnavailableInSwift) {
+        availability.Mode = APIAvailability::NonSwift;
+        availability.Msg = copyString(info.UnavailableMsg);
+      }
+    }
+
+    /// Map parameter information for a function.
+    void handleParameters(ParamsSeq &params,
+                          const FunctionInfo &info) {
+      unsigned position = 0;
+      for (const auto &pi: info.Params) {
+        Param p;
+        p.Position = position++;
+        p.Nullability = pi.getNullability();
+        p.NoEscape = pi.isNoEscape();
+        p.Type = copyString(pi.getType());
+        p.RetainCountConvention = pi.getRetainCountConvention();
+        params.push_back(p);
+      }
+    }
+
+    /// Map nullability information for a function.
+    void handleNullability(NullabilitySeq &nullability,
+                           llvm::Optional<NullabilityKind> &nullabilityOfRet,
+                           const FunctionInfo &info,
+                           unsigned numParams) {
+      if (info.NullabilityAudited) {
+        nullabilityOfRet = info.getReturnTypeInfo();
+
+        // Figure out the number of parameters from the selector.
+        for (unsigned i = 0; i != numParams; ++i)
+          nullability.push_back(info.getParamTypeInfo(i));
+      }
+    }
+
+    TopLevelItems &getTopLevelItems(VersionTuple swiftVersion) {
+      if (!swiftVersion) return TheModule.TopLevel;
+
+      for (auto &versioned : TheModule.SwiftVersions) {
+        if (versioned.Version == swiftVersion)
+          return versioned.Items;
+      }
+
+      TheModule.SwiftVersions.push_back(Versioned());
+      TheModule.SwiftVersions.back().Version = swiftVersion;
+      return TheModule.SwiftVersions.back().Items;
+    }
+
+  public:
+    virtual void visitObjCClass(ContextID contextID, StringRef name,
+                                const ObjCContextInfo &info,
+                                VersionTuple swiftVersion) {
+      // Record this known context.
+      auto &items = getTopLevelItems(swiftVersion);
+      auto &known = knownContexts[contextID.Value];
+      known.isProtocol = false;
+
+      handleObjCContext(known.getContext(swiftVersion, items), name, info);
+    }
+
+    virtual void visitObjCProtocol(ContextID contextID, StringRef name,
+                                   const ObjCContextInfo &info,
+                                   VersionTuple swiftVersion) {
+      // Record this known context.
+      auto &items = getTopLevelItems(swiftVersion);
+      auto &known = knownContexts[contextID.Value];
+      known.isProtocol = true;
+
+      handleObjCContext(known.getContext(swiftVersion, items), name, info);
+    }
+
+    virtual void visitObjCMethod(ContextID contextID, StringRef selector,
+                                 bool isInstanceMethod,
+                                 const ObjCMethodInfo &info,
+                                 VersionTuple swiftVersion) {
+      Method method;
+      method.Selector = copyString(selector);
+      method.Kind = isInstanceMethod ? MethodKind::Instance : MethodKind::Class;
+
+      handleCommon(method, info);
+      handleParameters(method.Params, info);
+      handleNullability(method.Nullability, method.NullabilityOfRet, info,
+                        selector.count(':'));
+      method.DesignatedInit = info.DesignatedInit;
+      method.Required = info.Required;
+      method.ResultType = copyString(info.ResultType);
+      method.RetainCountConvention = info.getRetainCountConvention();
+      auto &items = getTopLevelItems(swiftVersion);
+      knownContexts[contextID.Value].getContext(swiftVersion, items)
+        .Methods.push_back(method);
+    }
+
+    virtual void visitObjCProperty(ContextID contextID, StringRef name,
+                                   bool isInstance,
+                                   const ObjCPropertyInfo &info,
+                                   VersionTuple swiftVersion) {
+      Property property;
+      property.Name = name;
+      property.Kind = isInstance ? MethodKind::Instance : MethodKind::Class;
+      handleCommon(property, info);
+
+      // FIXME: No way to represent "not audited for nullability".
+      if (auto nullability = info.getNullability()) {
+        property.Nullability = *nullability;
+      }
+
+      property.SwiftImportAsAccessors = info.getSwiftImportAsAccessors();
+
+      property.Type = copyString(info.getType());
+
+      auto &items = getTopLevelItems(swiftVersion);
+      knownContexts[contextID.Value].getContext(swiftVersion, items)
+        .Properties.push_back(property);
+    }
+
+    virtual void visitGlobalFunction(StringRef name,
+                                     const GlobalFunctionInfo &info,
+                                     VersionTuple swiftVersion) {
+      Function function;
+      function.Name = name;
+      handleCommon(function, info);
+      handleParameters(function.Params, info);
+      if (info.NumAdjustedNullable > 0)
+        handleNullability(function.Nullability, function.NullabilityOfRet,
+                          info, info.NumAdjustedNullable-1);
+      function.ResultType = copyString(info.ResultType);
+      function.RetainCountConvention = info.getRetainCountConvention();
+      auto &items = getTopLevelItems(swiftVersion);
+      items.Functions.push_back(function);
+    }
+
+    virtual void visitGlobalVariable(StringRef name,
+                                     const GlobalVariableInfo &info,
+                                     VersionTuple swiftVersion) {
+      GlobalVariable global;
+      global.Name = name;
+      handleCommon(global, info);
+
+      // FIXME: No way to represent "not audited for nullability".
+      if (auto nullability = info.getNullability()) {
+        global.Nullability = *nullability;
+      }
+      global.Type = copyString(info.getType());
+
+      auto &items = getTopLevelItems(swiftVersion);
+      items.Globals.push_back(global);
+    }
+
+    virtual void visitEnumConstant(StringRef name,
+                                   const EnumConstantInfo &info,
+                                   VersionTuple swiftVersion) {
+      EnumConstant enumConstant;
+      enumConstant.Name = name;
+      handleCommon(enumConstant, info);
+
+      auto &items = getTopLevelItems(swiftVersion);
+      items.EnumConstants.push_back(enumConstant);
+    }
+
+    virtual void visitTag(StringRef name, const TagInfo &info,
+                          VersionTuple swiftVersion) {
+      Tag tag;
+      tag.Name = name;
+      handleCommonType(tag, info);
+      tag.EnumExtensibility = info.EnumExtensibility;
+      tag.FlagEnum = info.isFlagEnum();
+      auto &items = getTopLevelItems(swiftVersion);
+      items.Tags.push_back(tag);
+    }
+
+    virtual void visitTypedef(StringRef name, const TypedefInfo &info,
+                              VersionTuple swiftVersion) {
+      Typedef td;
+      td.Name = name;
+      handleCommonType(td, info);
+      td.SwiftWrapper = info.SwiftWrapper;
+      auto &items = getTopLevelItems(swiftVersion);
+      items.Typedefs.push_back(td);
+    }
+
+    /// Retrieve the module.
+    Module &getModule() { return TheModule; }
+  };
+}
+
+/// Produce a flattened, numeric value for optional method/property kinds.
+static unsigned flattenPropertyKind(llvm::Optional<MethodKind> kind) {
+  return kind ? (*kind == MethodKind::Instance ? 2 : 1) : 0;
+}
+
+/// Sort the items in the given block of "top-level" items.
+static void sortTopLevelItems(TopLevelItems &items) {
+  // Sort classes.
+  std::sort(items.Classes.begin(), items.Classes.end(),
+            [](const Class &lhs, const Class &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+
+  // Sort protocols.
+  std::sort(items.Protocols.begin(), items.Protocols.end(),
+            [](const Class &lhs, const Class &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+
+  // Sort methods and properties within each class and protocol.
+  auto sortMembers = [](Class &record) {
+    // Sort properties.
+    std::sort(record.Properties.begin(), record.Properties.end(),
+              [](const Property &lhs, const Property &rhs) -> bool {
+                return lhs.Name < rhs.Name ||
+                (lhs.Name == rhs.Name &&
+                 flattenPropertyKind(lhs.Kind) <
+                 flattenPropertyKind(rhs.Kind));
+              });
+
+    // Sort methods.
+    std::sort(record.Methods.begin(), record.Methods.end(),
+              [](const Method &lhs, const Method &rhs) -> bool {
+                return lhs.Selector < rhs.Selector ||
+                (lhs.Selector == rhs.Selector &&
+                 static_cast<unsigned>(lhs.Kind)
+                 < static_cast<unsigned>(rhs.Kind));
+              });
+  };
+  std::for_each(items.Classes.begin(), items.Classes.end(), sortMembers);
+  std::for_each(items.Protocols.begin(), items.Protocols.end(), sortMembers);
+
+  // Sort functions.
+  std::sort(items.Functions.begin(), items.Functions.end(),
+            [](const Function &lhs, const Function &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+
+  // Sort global variables.
+  std::sort(items.Globals.begin(), items.Globals.end(),
+            [](const GlobalVariable &lhs, const GlobalVariable &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+
+  // Sort enum constants.
+  std::sort(items.EnumConstants.begin(), items.EnumConstants.end(),
+            [](const EnumConstant &lhs, const EnumConstant &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+
+  // Sort tags.
+  std::sort(items.Tags.begin(), items.Tags.end(),
+            [](const Tag &lhs, const Tag &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+
+  // Sort typedefs.
+  std::sort(items.Typedefs.begin(), items.Typedefs.end(),
+            [](const Typedef &lhs, const Typedef &rhs) -> bool {
+              return lhs.Name < rhs.Name;
+            });
+}
+
+bool api_notes::decompileAPINotes(std::unique_ptr<llvm::MemoryBuffer> input,
+                                  llvm::raw_ostream &os) {
+  // Try to read the file.
+  auto reader = APINotesReader::get(std::move(input), VersionTuple());
+  if (!reader) {
+    llvm::errs() << "not a well-formed API notes binary file\n";
+    return true;
+  }
+
+  DecompileVisitor decompileVisitor;
+  reader->visit(decompileVisitor);
+
+  // Sort the data in the module, because the API notes reader doesn't preserve
+  // order.
+  auto &module = decompileVisitor.getModule();
+
+  // Set module name.
+  module.Name = reader->getModuleName();
+
+  // Set module options
+  auto opts = reader->getModuleOptions();
+  if (opts.SwiftInferImportAsMember)
+    module.SwiftInferImportAsMember = true;
+
+  // Sort the top-level items.
+  sortTopLevelItems(module.TopLevel);
+
+  // Sort the Swift versions.
+  std::sort(module.SwiftVersions.begin(), module.SwiftVersions.end(),
+            [](const Versioned &lhs, const Versioned &rhs) -> bool {
+              return lhs.Version < rhs.Version;
+            });
+
+  // Sort the top-level items within each Swift version.
+  for (auto &versioned : module.SwiftVersions)
+    sortTopLevelItems(versioned.Items);
+
+  // Output the YAML representation.
+  Output yout(os);
+  yout << module;
+
+  return false;
+}
+
diff --git a/lib/APINotes/CMakeLists.txt b/lib/APINotes/CMakeLists.txt
index e69de29bb2..da9d0d1e55 100644
--- a/lib/APINotes/CMakeLists.txt
+++ b/lib/APINotes/CMakeLists.txt
@@ -0,0 +1,15 @@
+set(LLVM_LINK_COMPONENTS
+  BitReader
+  Support
+  )
+
+add_clang_library(clangAPINotes
+  APINotesManager.cpp
+  APINotesWriter.cpp
+  APINotesReader.cpp
+  APINotesYAMLCompiler.cpp
+  Types.cpp
+
+  LINK_LIBS
+  clangBasic
+)
diff --git a/lib/APINotes/Types.cpp b/lib/APINotes/Types.cpp
index e69de29bb2..4bbb4a8685 100644
--- a/lib/APINotes/Types.cpp
+++ b/lib/APINotes/Types.cpp
@@ -0,0 +1,55 @@
+//===--- Types.cpp - API Notes Data Types ----------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines data types used in the representation of API notes data.
+//
+//===----------------------------------------------------------------------===//
+#include "clang/APINotes/Types.h"
+#include "llvm/Support/raw_ostream.h"
+
+void clang::api_notes::ObjCMethodInfo::dump(llvm::raw_ostream &os) {
+    os << DesignatedInit << " " << Unavailable << " "
+       << NullabilityAudited << " " << NumAdjustedNullable << " "
+       << NullabilityPayload << " " << UnavailableMsg << "\n";
+}
+
+void clang::api_notes::ObjCContextInfo::dump(llvm::raw_ostream &os) {
+  os << HasDefaultNullability << " " << DefaultNullability << " "
+     << HasDesignatedInits << "\n";
+}
+
+void clang::api_notes::ObjCMethodInfo::mergePropInfoIntoSetter(
+      const ObjCPropertyInfo &pInfo) {
+  // Set the type of the first argument of the the setter or check that the
+  // value we have is consistent with the property.
+  // TODO: Can we provide proper error handling here?
+  if (auto pNullability = pInfo.getNullability()) {
+    if (!NullabilityAudited) {
+      addParamTypeInfo(0, *pNullability);
+      assert(NumAdjustedNullable == 2);
+    } else {
+      assert(getParamTypeInfo(0) == *pNullability);
+    }
+  }
+}
+
+void clang::api_notes::ObjCMethodInfo::mergePropInfoIntoGetter(
+      const ObjCPropertyInfo &pInfo) {
+  // Set the return type of the getter or check that the value we have is
+  // consistent with the property.
+  // TODO: Can we provide proper error handling here?
+  if (auto pNullability = pInfo.getNullability()) {
+    if (!NullabilityAudited) {
+      addReturnTypeInfo(*pNullability);
+      assert(NumAdjustedNullable == 1);
+    } else {
+      assert(getReturnTypeInfo() == *pNullability);
+    }
+  }
+}
diff --git a/lib/AST/ASTContext.cpp b/lib/AST/ASTContext.cpp
index c73ae9efe1..b41c222061 100644
--- a/lib/AST/ASTContext.cpp
+++ b/lib/AST/ASTContext.cpp
@@ -4331,11 +4331,6 @@ ASTContext::applyObjCProtocolQualifiers(QualType type,
                   bool allowOnPointerType) const {
   hasError = false;
 
-  if (const ObjCTypeParamType *objT =
-      dyn_cast<ObjCTypeParamType>(type.getTypePtr())) {
-    return getObjCTypeParamType(objT->getDecl(), protocols);
-  }
-
   // Apply protocol qualifiers to ObjCObjectPointerType.
   if (allowOnPointerType) {
     if (const ObjCObjectPointerType *objPtr =
diff --git a/lib/AST/ASTDumper.cpp b/lib/AST/ASTDumper.cpp
index 92be6d95e8..06843401c4 100644
--- a/lib/AST/ASTDumper.cpp
+++ b/lib/AST/ASTDumper.cpp
@@ -1854,6 +1854,8 @@ void ASTDumper::VisitObjCImplementationDecl(const ObjCImplementationDecl *D) {
 void ASTDumper::VisitObjCCompatibleAliasDecl(const ObjCCompatibleAliasDecl *D) {
   dumpName(D);
   dumpDeclRef(D->getClassInterface());
+  OS << " ";
+  dumpLocation(D->getClassInterfaceLoc());
 }
 
 void ASTDumper::VisitObjCPropertyDecl(const ObjCPropertyDecl *D) {
diff --git a/lib/AST/DeclObjC.cpp b/lib/AST/DeclObjC.cpp
index f95d5def47..7b456ab7ec 100644
--- a/lib/AST/DeclObjC.cpp
+++ b/lib/AST/DeclObjC.cpp
@@ -1351,12 +1351,8 @@ ObjCTypeParamDecl *ObjCTypeParamDecl::Create(ASTContext &ctx, DeclContext *dc,
                                              IdentifierInfo *name,
                                              SourceLocation colonLoc,
                                              TypeSourceInfo *boundInfo) {
-  auto *TPDecl =
-    new (ctx, dc) ObjCTypeParamDecl(ctx, dc, variance, varianceLoc, index,
-                                    nameLoc, name, colonLoc, boundInfo);
-  QualType TPType = ctx.getObjCTypeParamType(TPDecl, {});
-  TPDecl->setTypeForDecl(TPType.getTypePtr());
-  return TPDecl;
+  return new (ctx, dc) ObjCTypeParamDecl(ctx, dc, variance, varianceLoc, index,
+                                         nameLoc, name, colonLoc, boundInfo);
 }
 
 ObjCTypeParamDecl *ObjCTypeParamDecl::CreateDeserialized(ASTContext &ctx,
@@ -2164,18 +2160,19 @@ raw_ostream &clang::operator<<(raw_ostream &OS,
 
 void ObjCCompatibleAliasDecl::anchor() {}
 
-ObjCCompatibleAliasDecl *
-ObjCCompatibleAliasDecl::Create(ASTContext &C, DeclContext *DC,
-                                SourceLocation L,
-                                IdentifierInfo *Id,
-                                ObjCInterfaceDecl* AliasedClass) {
-  return new (C, DC) ObjCCompatibleAliasDecl(DC, L, Id, AliasedClass);
+ObjCCompatibleAliasDecl *ObjCCompatibleAliasDecl::Create(
+    ASTContext &C, DeclContext *DC, SourceLocation NameLoc, IdentifierInfo *Id,
+    ObjCInterfaceDecl *AliasedClass, SourceLocation AliasedClassLoc,
+    SourceLocation AtLoc) {
+  return new (C, DC) ObjCCompatibleAliasDecl(DC, NameLoc, Id, AliasedClass,
+                                             AliasedClassLoc, AtLoc);
 }
 
 ObjCCompatibleAliasDecl *
 ObjCCompatibleAliasDecl::CreateDeserialized(ASTContext &C, unsigned ID) {
-  return new (C, ID) ObjCCompatibleAliasDecl(nullptr, SourceLocation(),
-                                             nullptr, nullptr);
+  return new (C, ID)
+      ObjCCompatibleAliasDecl(nullptr, SourceLocation(), nullptr, nullptr,
+                              SourceLocation(), SourceLocation());
 }
 
 //===----------------------------------------------------------------------===//
diff --git a/lib/AST/DeclPrinter.cpp b/lib/AST/DeclPrinter.cpp
index b792c5920a..75abc6776c 100644
--- a/lib/AST/DeclPrinter.cpp
+++ b/lib/AST/DeclPrinter.cpp
@@ -124,6 +124,14 @@ void Decl::print(raw_ostream &Out, const PrintingPolicy &Policy,
   Printer.Visit(const_cast<Decl*>(this));
 }
 
+void TemplateParameterList::print(raw_ostream &Out,
+                                  const PrintingPolicy &Policy,
+                                  const ASTContext &Context,
+                                  unsigned Indentation) const {
+  DeclPrinter Printer(Out, Policy, Context, Indentation);
+  Printer.printTemplateParameters(this);
+}
+
 static QualType GetBaseType(QualType T) {
   // FIXME: This should be on the Type class!
   QualType BaseType = T;
@@ -558,13 +566,15 @@ void DeclPrinter::VisitFunctionDecl(FunctionDecl *D) {
   CXXConversionDecl *ConversionDecl = dyn_cast<CXXConversionDecl>(D);
   CXXDeductionGuideDecl *GuideDecl = dyn_cast<CXXDeductionGuideDecl>(D);
   if (!Policy.SuppressSpecifiers) {
-    switch (D->getStorageClass()) {
-    case SC_None: break;
-    case SC_Extern: Out << "extern "; break;
-    case SC_Static: Out << "static "; break;
-    case SC_PrivateExtern: Out << "__private_extern__ "; break;
-    case SC_Auto: case SC_Register:
-      llvm_unreachable("invalid for functions");
+    if (!Policy.SupressStorageClassSpecifiers) {
+      switch (D->getStorageClass()) {
+      case SC_None: break;
+      case SC_Extern: Out << "extern "; break;
+      case SC_Static: Out << "static "; break;
+      case SC_PrivateExtern: Out << "__private_extern__ "; break;
+      case SC_Auto: case SC_Register:
+        llvm_unreachable("invalid for functions");
+      }
     }
 
     if (D->isInlineSpecified())  Out << "inline ";
@@ -1278,6 +1288,9 @@ void DeclPrinter::VisitObjCInterfaceDecl(ObjCInterfaceDecl *OID) {
     return;
   }
   bool eolnOut = false;
+  prettyPrintAttributes(OID);
+  if (OID->hasAttrs()) Out << "\n";
+
   Out << "@interface " << I;
 
   if (auto TypeParams = OID->getTypeParamListAsWritten()) {
diff --git a/lib/AST/NestedNameSpecifier.cpp b/lib/AST/NestedNameSpecifier.cpp
index 889f8308a9..86fc8fd28a 100644
--- a/lib/AST/NestedNameSpecifier.cpp
+++ b/lib/AST/NestedNameSpecifier.cpp
@@ -697,3 +697,34 @@ NestedNameSpecifierLocBuilder::getWithLocInContext(ASTContext &Context) const {
   memcpy(Mem, Buffer, BufferSize);
   return NestedNameSpecifierLoc(Representation, Mem);
 }
+
+NestedNameSpecifier *NestedNameSpecifier::getRequiredQualification(
+    ASTContext &Context, const DeclContext *CurContext,
+    const DeclContext *TargetContext) {
+  SmallVector<const DeclContext *, 4> TargetParents;
+
+  for (const DeclContext *CommonAncestor = TargetContext;
+       CommonAncestor && !CommonAncestor->Encloses(CurContext);
+       CommonAncestor = CommonAncestor->getLookupParent()) {
+    if (CommonAncestor->isTransparentContext() ||
+        CommonAncestor->isFunctionOrMethod())
+      continue;
+
+    TargetParents.push_back(CommonAncestor);
+  }
+
+  NestedNameSpecifier *Result = nullptr;
+  while (!TargetParents.empty()) {
+    const DeclContext *Parent = TargetParents.pop_back_val();
+
+    if (const NamespaceDecl *Namespace = dyn_cast<NamespaceDecl>(Parent)) {
+      if (!Namespace->getIdentifier())
+        continue;
+
+      Result = NestedNameSpecifier::Create(Context, Result, Namespace);
+    } else if (const TagDecl *TD = dyn_cast<TagDecl>(Parent))
+      Result = NestedNameSpecifier::Create(
+          Context, Result, false, Context.getTypeDeclType(TD).getTypePtr());
+  }
+  return Result;
+}
diff --git a/lib/AST/Type.cpp b/lib/AST/Type.cpp
index 38f2a16fa1..7e225c36b1 100644
--- a/lib/AST/Type.cpp
+++ b/lib/AST/Type.cpp
@@ -1122,24 +1122,13 @@ QualType QualType::substObjCTypeArgs(
 
     // Replace an Objective-C type parameter reference with the corresponding
     // type argument.
-    if (const auto *OTPTy = dyn_cast<ObjCTypeParamType>(splitType.Ty)) {
-      if (auto *typeParam = dyn_cast<ObjCTypeParamDecl>(OTPTy->getDecl())) {
+    if (const auto *typedefTy = dyn_cast<TypedefType>(splitType.Ty)) {
+      if (auto *typeParam = dyn_cast<ObjCTypeParamDecl>(typedefTy->getDecl())) {
         // If we have type arguments, use them.
         if (!typeArgs.empty()) {
+          // FIXME: Introduce SubstObjCTypeParamType ?
           QualType argType = typeArgs[typeParam->getIndex()];
-          if (OTPTy->qual_empty())
-            return ctx.getQualifiedType(argType, splitType.Quals);
-
-          // Apply protocol lists if exists.
-          bool hasError;
-          SmallVector<ObjCProtocolDecl*, 8> protocolsVec;
-          protocolsVec.append(OTPTy->qual_begin(),
-                              OTPTy->qual_end());
-          ArrayRef<ObjCProtocolDecl *> protocolsToApply = protocolsVec;
-          QualType resultTy = ctx.applyObjCProtocolQualifiers(argType,
-              protocolsToApply, hasError, true/*allowOnPointerType*/);
-
-          return ctx.getQualifiedType(resultTy, splitType.Quals);
+          return ctx.getQualifiedType(argType, splitType.Quals);
         }
 
         switch (context) {
diff --git a/lib/AST/TypePrinter.cpp b/lib/AST/TypePrinter.cpp
index c28ada7dcb..68173396ab 100644
--- a/lib/AST/TypePrinter.cpp
+++ b/lib/AST/TypePrinter.cpp
@@ -84,11 +84,12 @@ namespace {
     unsigned Indentation;
     bool HasEmptyPlaceHolder;
     bool InsideCCAttribute;
+    bool IgnoreFunctionProtoTypeConstQual;
 
   public:
     explicit TypePrinter(const PrintingPolicy &Policy, unsigned Indentation = 0)
-      : Policy(Policy), Indentation(Indentation),
-        HasEmptyPlaceHolder(false), InsideCCAttribute(false) { }
+        : Policy(Policy), Indentation(Indentation), HasEmptyPlaceHolder(false),
+          InsideCCAttribute(false), IgnoreFunctionProtoTypeConstQual(false) {}
 
     void print(const Type *ty, Qualifiers qs, raw_ostream &OS,
                StringRef PlaceHolder);
@@ -705,8 +706,12 @@ void TypePrinter::printFunctionProtoAfter(const FunctionProtoType *T,
   printFunctionAfter(Info, OS);
 
   if (unsigned quals = T->getTypeQuals()) {
-    OS << ' ';
-    AppendTypeQualList(OS, quals, Policy.Restrict);
+    if (IgnoreFunctionProtoTypeConstQual)
+      quals &= ~unsigned(Qualifiers::Const);
+    if (quals) {
+      OS << ' ';
+      AppendTypeQualList(OS, quals, Policy.Restrict);
+    }
   }
 
   switch (T->getRefQualifier()) {
@@ -1024,6 +1029,13 @@ void TypePrinter::printTag(TagDecl *D, raw_ostream &OS) {
   else if (TypedefNameDecl *Typedef = D->getTypedefNameForAnonDecl()) {
     assert(Typedef->getIdentifier() && "Typedef without identifier?");
     OS << Typedef->getIdentifier()->getName();
+  } else if (Policy.UseStdFunctionForLambda && isa<CXXRecordDecl>(D) &&
+             cast<CXXRecordDecl>(D)->isLambda()) {
+    OS << "std::function<";
+    QualType T = cast<CXXRecordDecl>(D)->getLambdaCallOperator()->getType();
+    SaveAndRestore<bool> NoConst(IgnoreFunctionProtoTypeConstQual, true);
+    print(T, OS, "");
+    OS << '>';
   } else {
     // Make an unambiguous representation for anonymous types, e.g.
     //   (anonymous enum at /usr/include/string.h:120:9)
diff --git a/lib/Basic/CMakeLists.txt b/lib/Basic/CMakeLists.txt
index d0c9b902f6..f0dfe712e5 100644
--- a/lib/Basic/CMakeLists.txt
+++ b/lib/Basic/CMakeLists.txt
@@ -66,6 +66,7 @@ add_clang_library(clangBasic
   Sanitizers.cpp
   SourceLocation.cpp
   SourceManager.cpp
+  SourceMgrAdapter.cpp
   TargetInfo.cpp
   Targets.cpp
   Targets/AArch64.cpp
diff --git a/lib/Basic/Module.cpp b/lib/Basic/Module.cpp
index 7124184865..bacbbbd345 100644
--- a/lib/Basic/Module.cpp
+++ b/lib/Basic/Module.cpp
@@ -37,11 +37,12 @@ using namespace clang;
 
 Module::Module(StringRef Name, SourceLocation DefinitionLoc, Module *Parent,
                bool IsFramework, bool IsExplicit, unsigned VisibilityID)
-    : Name(Name), DefinitionLoc(DefinitionLoc), Parent(Parent),
-      VisibilityID(VisibilityID), IsMissingRequirement(false),
-      HasIncompatibleModuleFile(false), IsAvailable(true),
-      IsFromModuleFile(false), IsFramework(IsFramework), IsExplicit(IsExplicit),
-      IsSystem(false), IsExternC(false), IsInferred(false),
+    : Name(Name), DefinitionLoc(DefinitionLoc), Parent(Parent), Directory(),
+      Umbrella(), ASTFile(nullptr), VisibilityID(VisibilityID),
+      IsMissingRequirement(false), HasIncompatibleModuleFile(false),
+      IsAvailable(true), IsFromModuleFile(false), IsFramework(IsFramework),
+      IsExplicit(IsExplicit), IsSystem(false), IsExternC(false),
+      IsInferred(false), IsSwiftInferImportAsMember(false),
       InferSubmodules(false), InferExplicitSubmodules(false),
       InferExportWildcard(false), ConfigMacrosExhaustive(false),
       NoUndeclaredIncludes(false), NameVisibility(Hidden) {
@@ -95,11 +96,16 @@ static bool hasFeature(StringRef Feature, const LangOptions &LangOpts,
 
 bool Module::isAvailable(const LangOptions &LangOpts, const TargetInfo &Target,
                          Requirement &Req,
-                         UnresolvedHeaderDirective &MissingHeader) const {
+                         UnresolvedHeaderDirective &MissingHeader,
+                         Module *&ShadowingModule) const {
   if (IsAvailable)
     return true;
 
   for (const Module *Current = this; Current; Current = Current->Parent) {
+    if (Current->ShadowingModule) {
+      ShadowingModule = Current->ShadowingModule;
+      return false;
+    }
     for (unsigned I = 0, N = Current->Requirements.size(); I != N; ++I) {
       if (hasFeature(Current->Requirements[I].first, LangOpts, Target) !=
               Current->Requirements[I].second) {
@@ -372,6 +378,8 @@ void Module::print(raw_ostream &OS, unsigned Indent) const {
       OS << " [system]";
     if (IsExternC)
       OS << " [extern_c]";
+    if (IsSwiftInferImportAsMember)
+      OS << " [swift_infer_import_as_member]";
   }
 
   OS << " {\n";
diff --git a/lib/Basic/SourceMgrAdapter.cpp b/lib/Basic/SourceMgrAdapter.cpp
index e69de29bb2..c80112e0db 100644
--- a/lib/Basic/SourceMgrAdapter.cpp
+++ b/lib/Basic/SourceMgrAdapter.cpp
@@ -0,0 +1,140 @@
+//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the adapter that maps diagnostics from llvm::SourceMgr
+// to Clang's SourceManager.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Basic/SourceMgrAdapter.h"
+#include "clang/Basic/Diagnostic.h"
+
+using namespace clang;
+
+void SourceMgrAdapter::handleDiag(const llvm::SMDiagnostic &diag,
+                                  void *context) {
+  static_cast<SourceMgrAdapter *>(context)->handleDiag(diag);
+}
+
+SourceMgrAdapter::SourceMgrAdapter(SourceManager &srcMgr,
+                                   DiagnosticsEngine &diag,
+                                   unsigned errorDiagID,
+                                   unsigned warningDiagID,
+                                   unsigned noteDiagID,
+                                   const FileEntry *defaultFile)
+  : SrcMgr(srcMgr), Diag(diag), ErrorDiagID(errorDiagID),
+    WarningDiagID(warningDiagID), NoteDiagID(noteDiagID),
+    DefaultFile(defaultFile) { }
+
+SourceMgrAdapter::~SourceMgrAdapter() { }
+
+SourceLocation SourceMgrAdapter::mapLocation(const llvm::SourceMgr &llvmSrcMgr,
+                                             llvm::SMLoc loc) {
+  // Map invalid locations.
+  if (!loc.isValid())
+    return SourceLocation();
+
+  // Find the buffer containing the location.
+  unsigned bufferID = llvmSrcMgr.FindBufferContainingLoc(loc);
+  if (!bufferID)
+    return SourceLocation();
+
+
+  // If we haven't seen this buffer before, copy it over.
+  auto buffer = llvmSrcMgr.getMemoryBuffer(bufferID);
+  auto knownBuffer = FileIDMapping.find(std::make_pair(&llvmSrcMgr, bufferID));
+  if (knownBuffer == FileIDMapping.end()) {
+    FileID fileID;
+    if (DefaultFile) {
+      // Map to the default file.
+      fileID = SrcMgr.createFileID(DefaultFile, SourceLocation(),
+                                   SrcMgr::C_User);
+
+      // Only do this once.
+      DefaultFile = nullptr;
+    } else {
+      // Make a copy of the memory buffer.
+      StringRef bufferName = buffer->getBufferIdentifier();
+      auto bufferCopy
+        = std::unique_ptr<llvm::MemoryBuffer>(
+            llvm::MemoryBuffer::getMemBufferCopy(buffer->getBuffer(),
+                                                 bufferName));
+
+      // Add this memory buffer to the Clang source manager.
+      fileID = SrcMgr.createFileID(std::move(bufferCopy));
+    }
+
+    // Save the mapping.
+    knownBuffer = FileIDMapping.insert(
+                    std::make_pair(std::make_pair(&llvmSrcMgr, bufferID),
+                                   fileID)).first;
+  }
+
+  // Translate the offset into the file.
+  unsigned offset = loc.getPointer() - buffer->getBufferStart();
+  return SrcMgr.getLocForStartOfFile(knownBuffer->second)
+           .getLocWithOffset(offset);
+}
+
+SourceRange SourceMgrAdapter::mapRange(const llvm::SourceMgr &llvmSrcMgr,
+                                       llvm::SMRange range) {
+  if (!range.isValid())
+    return SourceRange();
+
+  SourceLocation start = mapLocation(llvmSrcMgr, range.Start);
+  SourceLocation end = mapLocation(llvmSrcMgr, range.End);
+  return SourceRange(start, end);
+}
+
+void SourceMgrAdapter::handleDiag(const llvm::SMDiagnostic &diag) {
+  // Map the location.
+  SourceLocation loc;
+  if (auto *llvmSrcMgr = diag.getSourceMgr())
+    loc = mapLocation(*llvmSrcMgr, diag.getLoc());
+
+  // Extract the message.
+  StringRef message = diag.getMessage();
+
+  // Map the diagnostic kind.
+  unsigned diagID;
+  switch (diag.getKind()) {
+  case llvm::SourceMgr::DK_Error:
+    diagID = ErrorDiagID;
+    break;
+
+  case llvm::SourceMgr::DK_Warning:
+    diagID = WarningDiagID;
+    break;
+
+  case llvm::SourceMgr::DK_Remark:
+    llvm_unreachable("remarks not implemented");
+
+  case llvm::SourceMgr::DK_Note:
+    diagID = NoteDiagID;
+    break;
+  }
+
+  // Report the diagnostic.
+  DiagnosticBuilder builder = Diag.Report(loc, diagID) << message;
+
+  if (auto *llvmSrcMgr = diag.getSourceMgr()) {
+    // Translate ranges.
+    SourceLocation startOfLine = loc.getLocWithOffset(-diag.getColumnNo());
+    for (auto range : diag.getRanges()) {
+      builder << SourceRange(startOfLine.getLocWithOffset(range.first),
+                             startOfLine.getLocWithOffset(range.second));
+    }
+
+    // Translate Fix-Its.
+    for (const llvm::SMFixIt &fixIt : diag.getFixIts()) {
+      CharSourceRange range(mapRange(*llvmSrcMgr, fixIt.getRange()), false);
+      builder << FixItHint::CreateReplacement(range, fixIt.getText());
+    }
+  }
+}
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index b3fa93555b..6fccc2dac6 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -1,5 +1,6 @@
 add_subdirectory(Headers)
 add_subdirectory(Basic)
+add_subdirectory(APINotes)
 add_subdirectory(Lex)
 add_subdirectory(Parse)
 add_subdirectory(AST)
@@ -19,6 +20,7 @@ add_subdirectory(Frontend)
 add_subdirectory(FrontendTool)
 add_subdirectory(Tooling)
 add_subdirectory(Index)
+add_subdirectory(DirectoryWatcher)
 if(CLANG_ENABLE_STATIC_ANALYZER)
   add_subdirectory(StaticAnalyzer)
 endif()
diff --git a/lib/CodeGen/CGObjCMac.cpp b/lib/CodeGen/CGObjCMac.cpp
index ef4e6cd4f0..1ad86ab741 100644
--- a/lib/CodeGen/CGObjCMac.cpp
+++ b/lib/CodeGen/CGObjCMac.cpp
@@ -7148,7 +7148,12 @@ CGObjCNonFragileABIMac::GetClassGlobal(StringRef Name,
   }
 
   assert(GV->getLinkage() == L);
-  return GV;
+
+  if (IsForDefinition ||
+      GV->getValueType() == ObjCTypes.ClassnfABITy)
+    return GV;
+
+  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.ClassnfABIPtrTy);
 }
 
 llvm::Value *
diff --git a/lib/DirectoryWatcher/CMakeLists.txt b/lib/DirectoryWatcher/CMakeLists.txt
index e69de29bb2..b70e925265 100644
--- a/lib/DirectoryWatcher/CMakeLists.txt
+++ b/lib/DirectoryWatcher/CMakeLists.txt
@@ -0,0 +1,21 @@
+include(CheckIncludeFiles)
+
+set(LLVM_LINK_COMPONENTS support)
+
+add_clang_library(clangDirectoryWatcher
+  DirectoryWatcher.cpp
+
+  LINK_LIBS
+  clangBasic
+  )
+
+if(BUILD_SHARED_LIBS)
+  if(APPLE)
+    check_include_files("CoreServices/CoreServices.h" HAVE_CORESERVICES_H)
+    if(HAVE_CORESERVICES_H)
+      set(DIRECTORY_WATCHER_FLAGS "${DIRECTORY_WATCHER_FLAGS} -framework CoreServices")
+    endif()
+    set_property(TARGET clangDirectoryWatcher APPEND_STRING PROPERTY
+                 LINK_FLAGS ${DIRECTORY_WATCHER_FLAGS})
+  endif()
+endif()
diff --git a/lib/DirectoryWatcher/DirectoryWatcher.cpp b/lib/DirectoryWatcher/DirectoryWatcher.cpp
index e69de29bb2..b543447650 100644
--- a/lib/DirectoryWatcher/DirectoryWatcher.cpp
+++ b/lib/DirectoryWatcher/DirectoryWatcher.cpp
@@ -0,0 +1,263 @@
+//===- DirectoryWatcher.cpp - Listens for directory file changes ----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+/// \file
+/// \brief Utility class for listening for file system changes in a directory.
+//===----------------------------------------------------------------------===//
+
+#include "clang/DirectoryWatcher/DirectoryWatcher.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/raw_ostream.h"
+
+#define HAVE_CORESERVICES 0
+
+#if defined(__has_include)
+#if __has_include(<CoreServices/CoreServices.h>)
+
+#include <CoreServices/CoreServices.h>
+#undef HAVE_CORESERVICES
+#define HAVE_CORESERVICES 1
+
+#endif
+#endif
+
+using namespace clang;
+using namespace llvm;
+
+static Optional<llvm::sys::TimePoint<>> getModTime(StringRef path) {
+  sys::fs::file_status Status;
+  std::error_code EC = status(path, Status);
+  if (EC)
+    return None;
+  return Status.getLastModificationTime();
+}
+
+struct DirectoryWatcher::Implementation {
+#if HAVE_CORESERVICES
+  FSEventStreamRef EventStream = nullptr;
+
+  bool setupFSEventStream(StringRef path, EventReceiver receiver,
+                          dispatch_queue_t queue);
+  void stopFSEventStream();
+
+  ~Implementation() {
+    stopFSEventStream();
+  };
+#endif
+};
+
+#if HAVE_CORESERVICES
+namespace {
+struct EventStreamContextData {
+  std::string WatchedPath;
+  DirectoryWatcher::EventReceiver Receiver;
+
+  EventStreamContextData(std::string watchedPath, DirectoryWatcher::EventReceiver receiver)
+  : WatchedPath(std::move(watchedPath)), Receiver(std::move(receiver)) {
+  }
+
+  static void dispose(const void *ctx) {
+    delete static_cast<const EventStreamContextData*>(ctx);
+  }
+};
+}
+
+static void eventStreamCallback(
+                       ConstFSEventStreamRef stream,
+                       void *clientCallBackInfo,
+                       size_t numEvents,
+                       void *eventPaths,
+                       const FSEventStreamEventFlags eventFlags[],
+                       const FSEventStreamEventId eventIds[]) {
+  auto *ctx = static_cast<EventStreamContextData*>(clientCallBackInfo);
+
+  std::vector<DirectoryWatcher::Event> Events;
+  for (size_t i = 0; i < numEvents; ++i) {
+    StringRef path = ((const char **)eventPaths)[i];
+    const FSEventStreamEventFlags flags = eventFlags[i];
+    if (!(flags & kFSEventStreamEventFlagItemIsFile)) {
+      if ((flags & kFSEventStreamEventFlagItemRemoved) && path == ctx->WatchedPath) {
+        DirectoryWatcher::Event Evt{DirectoryWatcher::EventKind::DirectoryDeleted, path, llvm::sys::TimePoint<>{} };
+        Events.push_back(Evt);
+        break;
+      }
+      continue;
+    }
+    DirectoryWatcher::EventKind K = DirectoryWatcher::EventKind::Modified;
+    if ((flags & kFSEventStreamEventFlagItemCreated) ||
+        (flags & kFSEventStreamEventFlagItemRenamed))
+      K = DirectoryWatcher::EventKind::Added;
+    if (flags & kFSEventStreamEventFlagItemRemoved)
+      K = DirectoryWatcher::EventKind::Removed;
+    llvm::sys::TimePoint<> modTime{};
+    if (K != DirectoryWatcher::EventKind::Removed) {
+      auto modTimeOpt = getModTime(path);
+      if (!modTimeOpt.hasValue())
+        continue;
+      modTime = modTimeOpt.getValue();
+    }
+    DirectoryWatcher::Event Evt{K, path, modTime};
+    Events.push_back(Evt);
+  }
+
+  ctx->Receiver(Events, /*isInitial=*/false);
+}
+
+bool DirectoryWatcher::Implementation::setupFSEventStream(StringRef path,
+                                                          EventReceiver receiver,
+                                                          dispatch_queue_t queue) {
+  if (path.empty())
+    return true;
+
+  CFMutableArrayRef pathsToWatch = CFArrayCreateMutable(nullptr, 0, &kCFTypeArrayCallBacks);
+  CFStringRef cfPathStr = CFStringCreateWithBytes(nullptr, (const UInt8 *)path.data(), path.size(), kCFStringEncodingUTF8, false);
+  CFArrayAppendValue(pathsToWatch, cfPathStr);
+  CFRelease(cfPathStr);
+  CFAbsoluteTime latency = 0.2; // Latency in seconds.
+
+  std::string realPath;
+  {
+    SmallString<128> Storage;
+    StringRef P = llvm::Twine(path).toNullTerminatedStringRef(Storage);
+    char Buffer[PATH_MAX];
+    // Use ::realpath to get the real path name
+    if (::realpath(P.begin(), Buffer) != nullptr)
+      realPath = Buffer;
+    else
+      realPath = path;
+  }
+
+  EventStreamContextData *ctxData = new EventStreamContextData(std::move(realPath), std::move(receiver));
+  FSEventStreamContext context;
+  context.version = 0;
+  context.info = ctxData;
+  context.retain = nullptr;
+  context.release = EventStreamContextData::dispose;
+  context.copyDescription = nullptr;
+
+  EventStream = FSEventStreamCreate(nullptr,
+                                    eventStreamCallback,
+                                    &context,
+                                    pathsToWatch,
+                                    kFSEventStreamEventIdSinceNow,
+                                    latency,
+                                    kFSEventStreamCreateFlagFileEvents |
+                                    kFSEventStreamCreateFlagNoDefer);
+  CFRelease(pathsToWatch);
+  if (!EventStream) {
+    return true;
+  }
+  FSEventStreamSetDispatchQueue(EventStream, queue);
+  FSEventStreamStart(EventStream);
+  return false;
+}
+
+void DirectoryWatcher::Implementation::stopFSEventStream() {
+  if (!EventStream)
+    return;
+  FSEventStreamStop(EventStream);
+  FSEventStreamInvalidate(EventStream);
+  FSEventStreamRelease(EventStream);
+  EventStream = nullptr;
+}
+#endif
+
+DirectoryWatcher::DirectoryWatcher()
+  : Impl(*new Implementation()) {}
+
+DirectoryWatcher::~DirectoryWatcher() {
+  delete &Impl;
+}
+
+#if HAVE_CORESERVICES
+static std::vector<DirectoryWatcher::Event> scanDirectory(StringRef Path) {
+  using namespace llvm::sys;
+
+  std::vector<DirectoryWatcher::Event> Events;
+  std::error_code EC;
+  for (auto It = fs::directory_iterator(Path, EC), End = fs::directory_iterator();
+         !EC && It != End; It.increment(EC)) {
+    auto modTime = getModTime(It->path());
+    if (!modTime.hasValue())
+      continue;
+    DirectoryWatcher::Event Event{DirectoryWatcher::EventKind::Added, It->path(), modTime.getValue()};
+    Events.push_back(std::move(Event));
+  }
+  return Events;
+}
+#endif
+
+std::unique_ptr<DirectoryWatcher> DirectoryWatcher::create(StringRef Path,
+        EventReceiver Receiver, bool waitInitialSync, std::string &Error) {
+#if HAVE_CORESERVICES
+
+  using namespace llvm::sys;
+
+  if (!fs::exists(Path)) {
+    std::error_code EC = fs::create_directories(Path);
+    if (EC) {
+      Error = EC.message();
+      return nullptr;
+    }
+  }
+
+  bool IsDir;
+  std::error_code EC = fs::is_directory(Path, IsDir);
+  if (EC) {
+    Error = EC.message();
+    return nullptr;
+  }
+  if (!IsDir) {
+    Error = "path is not a directory: ";
+    Error += Path;
+    return nullptr;
+  }
+
+  std::unique_ptr<DirectoryWatcher> DirWatch;
+  DirWatch.reset(new DirectoryWatcher());
+  auto &Impl = DirWatch->Impl;
+
+  dispatch_queue_t queue = dispatch_queue_create("DirectoryWatcher", DISPATCH_QUEUE_SERIAL);
+  dispatch_semaphore_t initScanSema = dispatch_semaphore_create(0);
+  dispatch_semaphore_t setupFSEventsSema = dispatch_semaphore_create(0);
+
+  std::string copiedPath = Path;
+  dispatch_retain(initScanSema);
+  dispatch_retain(setupFSEventsSema);
+  dispatch_async(queue, ^{
+    // Wait for the event stream to be setup before doing the initial scan,
+    // to make sure we won't miss any events.
+    dispatch_semaphore_wait(setupFSEventsSema, DISPATCH_TIME_FOREVER);
+    auto events = scanDirectory(copiedPath);
+    Receiver(events, /*isInitial=*/true);
+    dispatch_semaphore_signal(initScanSema);
+    dispatch_release(setupFSEventsSema);
+    dispatch_release(initScanSema);
+  });
+  bool fsErr = Impl.setupFSEventStream(Path, Receiver, queue);
+  dispatch_semaphore_signal(setupFSEventsSema);
+
+  if (waitInitialSync) {
+    dispatch_semaphore_wait(initScanSema, DISPATCH_TIME_FOREVER);
+  }
+  dispatch_release(setupFSEventsSema);
+  dispatch_release(initScanSema);
+  dispatch_release(queue);
+
+  if (fsErr) {
+    raw_string_ostream(Error) << "failed to setup FSEvents stream for path: " << Path;
+    return nullptr;
+  }
+
+  return DirWatch;
+#else
+  return nullptr;
+#endif
+}
diff --git a/lib/Driver/Driver.cpp b/lib/Driver/Driver.cpp
index 325b233ac5..86d452711b 100644
--- a/lib/Driver/Driver.cpp
+++ b/lib/Driver/Driver.cpp
@@ -1234,7 +1234,9 @@ void Driver::generateCompilationDiagnostics(Compilation &C,
   }
 
   // Assume associated files are based off of the first temporary file.
-  CrashReportInfo CrashInfo(TempFiles[0], VFS);
+  CrashReportInfo CrashInfo(
+      TempFiles[0], VFS,
+      C.getArgs().getLastArgValue(options::OPT_index_store_path));
 
   std::string Script = CrashInfo.Filename.rsplit('.').first.str() + ".sh";
   std::error_code EC;
diff --git a/lib/Driver/Job.cpp b/lib/Driver/Job.cpp
index 765c05752d..ab3ebfcbdb 100644
--- a/lib/Driver/Job.cpp
+++ b/lib/Driver/Job.cpp
@@ -68,6 +68,8 @@ static bool skipArgs(const char *Flag, bool HaveCrashVFS, int &SkipNum,
     .Default(false);
   if (IsInclude)
     return HaveCrashVFS ? false : true;
+  if (StringRef(Flag).startswith("-index-store-path"))
+    return true;
 
   // The remaining flags are treated as a single argument.
 
@@ -89,6 +91,8 @@ static bool skipArgs(const char *Flag, bool HaveCrashVFS, int &SkipNum,
     return HaveCrashVFS ? false : true;
   if (FlagRef.startswith("-fmodules-cache-path="))
     return true;
+  if (FlagRef.startswith("-fapinotes-cache-path="))
+    return true;
 
   SkipNum = 0;
   return false;
@@ -220,6 +224,7 @@ void Command::Print(raw_ostream &OS, const char *Terminator, bool Quote,
   }
 
   bool HaveCrashVFS = CrashInfo && !CrashInfo->VFSPath.empty();
+  bool HaveIndexStorePath = CrashInfo && !CrashInfo->IndexStorePath.empty();
   for (size_t i = 0, e = Args.size(); i < e; ++i) {
     const char *const Arg = Args[i];
 
@@ -283,6 +288,24 @@ void Command::Print(raw_ostream &OS, const char *Terminator, bool Quote,
     printArg(OS, ModCachePath, Quote);
   }
 
+  if (CrashInfo && HaveIndexStorePath) {
+    SmallString<128> IndexStoreDir;
+
+    if (HaveCrashVFS) {
+      IndexStoreDir = llvm::sys::path::parent_path(
+          llvm::sys::path::parent_path(CrashInfo->VFSPath));
+      llvm::sys::path::append(IndexStoreDir, "index-store");
+    } else {
+      IndexStoreDir = "index-store";
+    }
+
+    OS << ' ';
+    printArg(OS, "-index-store-path", Quote);
+    OS << ' ';
+    printArg(OS, IndexStoreDir.c_str(), Quote);
+  }
+
+
   if (ResponseFile != nullptr) {
     OS << "\n Arguments passed via response file:\n";
     writeResponseFile(OS);
diff --git a/lib/Driver/ToolChains/Clang.cpp b/lib/Driver/ToolChains/Clang.cpp
index 484df52001..76e2564ac8 100644
--- a/lib/Driver/ToolChains/Clang.cpp
+++ b/lib/Driver/ToolChains/Clang.cpp
@@ -3611,6 +3611,26 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
 
   RenderARCMigrateToolOptions(D, Args, CmdArgs);
 
+  if (Args.hasArg(options::OPT_index_store_path)) {
+    Args.AddLastArg(CmdArgs, options::OPT_index_store_path);
+    Args.AddLastArg(CmdArgs, options::OPT_index_ignore_system_symbols);
+    Args.AddLastArg(CmdArgs, options::OPT_index_record_codegen_name);
+
+    // If '-o' is passed along with '-fsyntax-only' pass it along the cc1
+    // invocation so that the index action knows what the out file is.
+    if (isa<CompileJobAction>(JA) && JA.getType() == types::TY_Nothing) {
+      Args.AddLastArg(CmdArgs, options::OPT_o);
+    }
+  }
+
+  if (const char *IdxStorePath = ::getenv("CLANG_PROJECT_INDEX_PATH")) {
+    CmdArgs.push_back("-index-store-path");
+    CmdArgs.push_back(IdxStorePath);
+    CmdArgs.push_back("-index-ignore-system-symbols");
+    CmdArgs.push_back("-index-record-codegen-name");
+  }
+
+
   // Add preprocessing options like -I, -D, etc. if we are using the
   // preprocessor.
   //
@@ -4020,6 +4040,19 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
                     options::OPT_fno_assume_sane_operator_new))
     CmdArgs.push_back("-fno-assume-sane-operator-new");
 
+  if (Args.hasFlag(options::OPT_fapinotes, options::OPT_fno_apinotes, false) ||
+      Args.hasFlag(options::OPT_fapinotes_modules,
+                   options::OPT_fno_apinotes_modules, false) ||
+      Args.hasArg(options::OPT_iapinotes_modules)) {
+    if (Args.hasFlag(options::OPT_fapinotes, options::OPT_fno_apinotes, false))
+      CmdArgs.push_back("-fapinotes");
+    if (Args.hasFlag(options::OPT_fapinotes_modules,
+                     options::OPT_fno_apinotes_modules, false))
+      CmdArgs.push_back("-fapinotes-modules");
+
+    Args.AddLastArg(CmdArgs, options::OPT_fapinotes_swift_version);
+  }
+
   // -fblocks=0 is default.
   if (Args.hasFlag(options::OPT_fblocks, options::OPT_fno_blocks,
                    getToolChain().IsBlocksDefault()) ||
diff --git a/lib/Driver/ToolChains/Darwin.cpp b/lib/Driver/ToolChains/Darwin.cpp
index 802b89b070..6434593390 100644
--- a/lib/Driver/ToolChains/Darwin.cpp
+++ b/lib/Driver/ToolChains/Darwin.cpp
@@ -436,6 +436,10 @@ void darwin::Linker::ConstructJob(Compilation &C, const JobAction &JA,
   // more information.
   ArgStringList CmdArgs;
 
+  Args.ClaimAllArgs(options::OPT_index_store_path);
+  Args.ClaimAllArgs(options::OPT_index_ignore_system_symbols);
+  Args.ClaimAllArgs(options::OPT_index_record_codegen_name);
+
   /// Hack(tm) to ignore linking errors when we are doing ARC migration.
   if (Args.hasArg(options::OPT_ccc_arcmt_check,
                   options::OPT_ccc_arcmt_migrate)) {
diff --git a/lib/Edit/CMakeLists.txt b/lib/Edit/CMakeLists.txt
index a7fa9c28e1..99aff3c3ae 100644
--- a/lib/Edit/CMakeLists.txt
+++ b/lib/Edit/CMakeLists.txt
@@ -5,6 +5,8 @@ set(LLVM_LINK_COMPONENTS
 add_clang_library(clangEdit
   Commit.cpp
   EditedSource.cpp
+  FillInMissingProtocolStubs.cpp
+  FillInMissingSwitchEnumCases.cpp
   RewriteObjCFoundationAPI.cpp
 
   LINK_LIBS
diff --git a/lib/Edit/FillInMissingProtocolStubs.cpp b/lib/Edit/FillInMissingProtocolStubs.cpp
index e69de29bb2..64843e508b 100644
--- a/lib/Edit/FillInMissingProtocolStubs.cpp
+++ b/lib/Edit/FillInMissingProtocolStubs.cpp
@@ -0,0 +1,466 @@
+//===--- FillInMissingProtocolStubs.cpp -  --------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Add methods from protocol(s)" refactoring operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/NSAPI.h"
+#include "clang/Edit/RefactoringFixits.h"
+#include "clang/Lex/Lexer.h"
+#include "llvm/ADT/DenseSet.h"
+#include <algorithm>
+
+using namespace clang;
+using namespace edit;
+using namespace fillInMissingProtocolStubs;
+
+// FIXME: This is duplicated with the refactoring lib.
+static bool areOnSameLine(SourceLocation Loc1, SourceLocation Loc2,
+                          const SourceManager &SM) {
+  return !Loc1.isMacroID() && !Loc2.isMacroID() &&
+         SM.getSpellingLineNumber(Loc1) == SM.getSpellingLineNumber(Loc2);
+}
+
+static bool isSemicolonAtLocation(SourceLocation TokenLoc,
+                                  const SourceManager &SM,
+                                  const LangOptions &LangOpts) {
+  return Lexer::getSourceText(
+             CharSourceRange::getTokenRange(TokenLoc, TokenLoc), SM,
+             LangOpts) == ";";
+}
+
+static SourceLocation getLocationOfPrecedingToken(SourceLocation Loc,
+                                                  const SourceManager &SM,
+                                                  const LangOptions &LangOpts) {
+  SourceLocation Result = Loc;
+  if (Result.isMacroID())
+    Result = SM.getExpansionLoc(Result);
+  FileID FID = SM.getFileID(Result);
+  SourceLocation StartOfFile = SM.getLocForStartOfFile(FID);
+  if (Loc == StartOfFile)
+    return SourceLocation();
+  return Lexer::GetBeginningOfToken(Result.getLocWithOffset(-1), SM, LangOpts);
+}
+
+static SourceLocation
+getLastLineLocationUnlessItHasOtherTokens(SourceLocation SpellingLoc,
+                                          const SourceManager &SM,
+                                          const LangOptions &LangOpts) {
+  assert(!SpellingLoc.isMacroID() && "Expecting a spelling location");
+  SourceLocation NextTokenLoc =
+      Lexer::findNextTokenLocationAfterTokenAt(SpellingLoc, SM, LangOpts);
+  if (NextTokenLoc.isValid()) {
+    bool IsSameLine = areOnSameLine(SpellingLoc, NextTokenLoc, SM);
+    if (IsSameLine) {
+      // Could be a ';' on the same line, so try looking after the ';'
+      if (isSemicolonAtLocation(NextTokenLoc, SM, LangOpts))
+        return getLastLineLocationUnlessItHasOtherTokens(NextTokenLoc, SM,
+                                                         LangOpts);
+    } else {
+      SourceLocation LastLoc = SM.translateLineCol(
+          SM.getFileID(SpellingLoc), SM.getSpellingLineNumber(SpellingLoc),
+          std::numeric_limits<unsigned>::max());
+      if (LastLoc.isValid())
+        return LastLoc;
+    }
+  }
+  return Lexer::getLocForEndOfToken(SpellingLoc, 0, SM, LangOpts);
+}
+
+namespace {
+
+struct ProtocolInfo {
+  /// The lower the priority, the more important this protocol is considered to
+  /// be. Typically protocols from the class have lower priority than protocols
+  /// from superclasses.
+  int Priority;
+};
+
+using ProtocolMapTy = llvm::DenseMap<const ObjCProtocolDecl *, ProtocolInfo>;
+
+/// Contains the set of methods from all the protocols that the class conforms
+/// to.
+class MethodSet {
+public:
+  struct MethodInfo {
+    const ObjCMethodDecl *M;
+    const ObjCProtocolDecl *P;
+    int ProtocolPriority;
+    enum MethodPresenceKind { IsDeclared = 0x1, IsImplemented = 0x2 };
+    unsigned PresenceKind = 0;
+    const ObjCMethodDecl *DeclaredOrImplementedMethod = nullptr;
+
+    MethodInfo(const ObjCMethodDecl *M, const ObjCProtocolDecl *P,
+               int ProtocolPriority)
+        : M(M), P(P), ProtocolPriority(ProtocolPriority) {}
+
+    bool isRequired() const {
+      return M->getImplementationControl() == ObjCMethodDecl::Required;
+    }
+    void markAs(MethodPresenceKind Kind) { PresenceKind |= Kind; }
+    bool is(MethodPresenceKind Kind) const {
+      return (PresenceKind & Kind) == Kind;
+    }
+  };
+
+private:
+  llvm::DenseMap<Selector, MethodInfo> InstanceMethods;
+  llvm::DenseMap<Selector, MethodInfo> ClassMethods;
+
+  void markMethodsFrom(const ObjCContainerDecl *Container,
+                       MethodInfo::MethodPresenceKind Kind) {
+    for (const ObjCMethodDecl *M : Container->methods()) {
+      auto &Map = M->isInstanceMethod() ? InstanceMethods : ClassMethods;
+      auto It = Map.find(M->getSelector());
+      if (It != Map.end()) {
+        It->second.markAs(Kind);
+        if (!It->second.DeclaredOrImplementedMethod)
+          It->second.DeclaredOrImplementedMethod = M;
+      }
+    }
+  }
+
+public:
+  MethodSet() {}
+  MethodSet(MethodSet &&Other) = default;
+  MethodSet &operator=(MethodSet &&Other) = default;
+
+  void gatherMethodsFrom(const ObjCProtocolDecl *P, int Priority) {
+    for (const ObjCMethodDecl *M : P->methods()) {
+      if (M->isImplicit())
+        continue;
+      AvailabilityResult Availability = M->getAvailability();
+      // Methods that are unavailable or not yet introduced are not considered
+      // to be required.
+      if (Availability == AR_NotYetIntroduced || Availability == AR_Unavailable)
+        continue;
+      auto &Map = M->isInstanceMethod() ? InstanceMethods : ClassMethods;
+      Map.insert(std::make_pair(M->getSelector(), MethodInfo(M, P, Priority)));
+    }
+  }
+
+  void markImplementedMethods(const ObjCContainerDecl *Container) {
+    assert(isa<ObjCImplDecl>(Container) && "Not an implementation container");
+    markMethodsFrom(Container, MethodInfo::IsImplemented);
+    if (const auto *ID = dyn_cast<ObjCImplementationDecl>(Container)) {
+      const auto *I = ID->getClassInterface();
+      // Mark declarations from super-classes as implemented to prevent
+      // redundant implementations.
+      while ((I = I->getSuperClass()))
+        markMethodsFrom(I, MethodInfo::IsImplemented);
+    }
+  }
+
+  void markDeclaredMethods(const ObjCContainerDecl *Container) {
+    assert(!isa<ObjCImplDecl>(Container) && "Not an interface container");
+    markMethodsFrom(Container, MethodInfo::IsDeclared);
+    // Mark declarations from super-classes as declared to prevent redundant
+    // declarations.
+    if (const auto *I = dyn_cast<ObjCInterfaceDecl>(Container)) {
+      while ((I = I->getSuperClass()))
+        markMethodsFrom(I, MethodInfo::IsDeclared);
+    }
+  }
+
+  /// Returns true if the given container has missing @required method stubs.
+  ///
+  /// For @interfaces, this method returns true when the interface is missing
+  /// a declaration for any @required method in all of the protocols.
+  /// For @implementations, this method returns true when the implementation is
+  /// missing an implementation of any @required method in all of the protocols.
+  bool hasMissingRequiredMethodStubs(const ObjCContainerDecl *Container) {
+    MethodInfo::MethodPresenceKind Kind = isa<ObjCImplDecl>(Container)
+                                              ? MethodInfo::IsImplemented
+                                              : MethodInfo::IsDeclared;
+    for (const auto &I : InstanceMethods) {
+      if (!I.second.isRequired())
+        continue;
+      if (!I.second.is(Kind))
+        return true;
+    }
+    for (const auto &I : ClassMethods) {
+      if (!I.second.isRequired())
+        continue;
+      if (!I.second.is(Kind))
+        return true;
+    }
+    return false;
+  }
+
+  std::vector<MethodInfo>
+  getMissingRequiredMethods(const ObjCContainerDecl *Container) {
+    MethodInfo::MethodPresenceKind Kind = isa<ObjCImplDecl>(Container)
+                                              ? MethodInfo::IsImplemented
+                                              : MethodInfo::IsDeclared;
+    std::vector<MethodInfo> Results;
+    for (const auto &I : InstanceMethods) {
+      if (!I.second.isRequired())
+        continue;
+      if (!I.second.is(Kind))
+        Results.push_back(I.second);
+    }
+    for (const auto &I : ClassMethods) {
+      if (!I.second.isRequired())
+        continue;
+      if (!I.second.is(Kind))
+        Results.push_back(I.second);
+    }
+    return Results;
+  }
+
+  SourceLocation findLocationForInsertionForMethodsFromProtocol(
+      const ObjCProtocolDecl *P, const ObjCContainerDecl *Container,
+      const SourceManager &SM, const LangOptions &LangOpts) {
+    MethodInfo::MethodPresenceKind Kind = isa<ObjCImplDecl>(Container)
+                                              ? MethodInfo::IsImplemented
+                                              : MethodInfo::IsDeclared;
+    llvm::SmallVector<const ObjCMethodDecl *, 4> MethodsFromProtocolInContainer;
+    for (const ObjCMethodDecl *M : P->methods()) {
+      if (M->isImplicit())
+        continue;
+      const auto &Map = M->isInstanceMethod() ? InstanceMethods : ClassMethods;
+      auto It = Map.find(M->getSelector());
+      if (It == Map.end())
+        continue;
+      if (!It->second.is(Kind))
+        continue;
+      const ObjCMethodDecl *ContainerMethod =
+          It->second.DeclaredOrImplementedMethod;
+      // Ignore method declarations from superclasses.
+      if (ContainerMethod->getLexicalDeclContext() != Container)
+        continue;
+      // This is a method from the given protocol that either declared or
+      // implemented in the container.
+      MethodsFromProtocolInContainer.push_back(ContainerMethod);
+    }
+    // Find the appropriate source locations by looking
+    if (MethodsFromProtocolInContainer.empty())
+      return SourceLocation();
+    SourceLocation Loc = MethodsFromProtocolInContainer[0]->getLocEnd();
+    if (Loc.isMacroID())
+      Loc = SM.getExpansionRange(Loc).second;
+    for (const ObjCMethodDecl *M :
+         makeArrayRef(MethodsFromProtocolInContainer).drop_front()) {
+      SourceLocation EndLoc = M->getLocEnd();
+      if (EndLoc.isMacroID())
+        EndLoc = SM.getExpansionRange(EndLoc).second;
+      if (SM.isBeforeInTranslationUnit(Loc, EndLoc))
+        Loc = EndLoc;
+    }
+    return getLastLineLocationUnlessItHasOtherTokens(Loc, SM, LangOpts);
+  }
+};
+
+} // end anonymous namespace
+
+namespace clang {
+namespace edit {
+namespace fillInMissingProtocolStubs {
+
+class FillInMissingProtocolStubsImpl {
+public:
+  const ObjCContainerDecl *Container;
+  MethodSet Methods;
+};
+
+} // end namespace fillInMissingProtocolStubsImpl
+} // end namespace edit
+} // end namespace clang
+
+static void gatherProtocols(
+    llvm::iterator_range<ObjCList<ObjCProtocolDecl>::iterator> Protocols,
+    NSAPI &API, ProtocolMapTy &Result, int &Priority) {
+  for (const ObjCProtocolDecl *P : Protocols) {
+    // Ignore the 'NSObject' protocol.
+    if (API.getNSClassId(NSAPI::ClassId_NSObject) == P->getIdentifier())
+      continue;
+    gatherProtocols(P->protocols(), API, Result, Priority);
+    Result.insert(std::make_pair(P, ProtocolInfo{Priority++}));
+  }
+}
+
+static ProtocolMapTy
+gatherSuitableClassProtocols(const ObjCInterfaceDecl *I,
+                             const ObjCContainerDecl *Container, NSAPI &API) {
+  ProtocolMapTy Result;
+  // The class of interest should use the protocols from extensions when the
+  // operation is initiated from the @implementation / extension.
+  auto ClassProtocols =
+      Container == I ? I->protocols() : I->all_referenced_protocols();
+  int Priority = 0;
+  gatherProtocols(ClassProtocols, API, Result, Priority);
+  while ((I = I->getSuperClass()))
+    gatherProtocols(I->protocols(), API, Result, Priority);
+  return Result;
+}
+
+static const ObjCContainerDecl *
+getInterfaceOrCategory(const ObjCContainerDecl *Container) {
+  if (const auto *Impl = dyn_cast<ObjCImplementationDecl>(Container))
+    return Impl->getClassInterface();
+  if (const auto *CategoryImpl = dyn_cast<ObjCCategoryImplDecl>(Container))
+    return CategoryImpl->getCategoryDecl();
+  return Container;
+}
+
+static bool initiate(FillInMissingProtocolStubsImpl &Dest, ASTContext &Context,
+                     const ObjCContainerDecl *Container) {
+  const ObjCContainerDecl *ContainerProtocolSource =
+      getInterfaceOrCategory(Container);
+  if (!ContainerProtocolSource)
+    return false;
+
+  // The protocols that are specified in the @interface and/or in the
+  // superclasses.
+  ProtocolMapTy Protocols;
+  NSAPI API(Context);
+  if (const auto *I = dyn_cast<ObjCInterfaceDecl>(ContainerProtocolSource)) {
+    if (!I->hasDefinition())
+      return false;
+    Protocols = gatherSuitableClassProtocols(I, Container, API);
+    if (Protocols.empty())
+      return false;
+  } else if (const auto *I =
+                 dyn_cast<ObjCCategoryDecl>(ContainerProtocolSource)) {
+    int Priority = 0;
+    gatherProtocols(I->protocols(), API, Protocols, Priority);
+    if (Protocols.empty())
+      return false;
+  }
+
+  // Check if there are missing @required methods.
+  for (const auto &P : Protocols)
+    Dest.Methods.gatherMethodsFrom(P.first, P.second.Priority);
+  if (isa<ObjCImplDecl>(Container))
+    Dest.Methods.markImplementedMethods(Container);
+  else
+    Dest.Methods.markDeclaredMethods(Container);
+
+  Dest.Container = Container;
+  return true;
+}
+
+FillInMissingProtocolStubs::FillInMissingProtocolStubs() {}
+FillInMissingProtocolStubs::~FillInMissingProtocolStubs() {}
+FillInMissingProtocolStubs::FillInMissingProtocolStubs(
+    FillInMissingProtocolStubs &&Other)
+    : Impl(std::move(Other.Impl)) {}
+FillInMissingProtocolStubs &FillInMissingProtocolStubs::
+operator=(FillInMissingProtocolStubs &&Other) {
+  Impl = std::move(Other.Impl);
+  return *this;
+}
+
+bool FillInMissingProtocolStubs::initiate(ASTContext &Context,
+                                          const ObjCContainerDecl *Container) {
+  Impl = llvm::make_unique<FillInMissingProtocolStubsImpl>();
+  if (!::initiate(*Impl, Context, Container))
+    return true;
+  return false;
+}
+
+bool FillInMissingProtocolStubs::hasMissingRequiredMethodStubs() {
+  return Impl->Methods.hasMissingRequiredMethodStubs(Impl->Container);
+}
+
+static void perform(MethodSet &Methods, const ObjCContainerDecl *Container,
+                    ASTContext &Context,
+                    llvm::function_ref<void(const FixItHint &)> Consumer) {
+  auto MissingMethods = Methods.getMissingRequiredMethods(Container);
+  // Sort the methods by grouping them into protocol clusters and then sorting
+  // them alphabetically within the same protocol.
+  std::sort(MissingMethods.begin(), MissingMethods.end(),
+            [](const MethodSet::MethodInfo &A, const MethodSet::MethodInfo &B) {
+              if (A.ProtocolPriority == B.ProtocolPriority)
+                return A.M->getSelector().getAsString() <
+                       B.M->getSelector().getAsString();
+              assert(A.P != B.P && "Same protocols should have same priority");
+              return A.ProtocolPriority < B.ProtocolPriority;
+            });
+
+  SourceLocation InsertionLoc =
+      isa<ObjCImplDecl>(Container)
+          ? Container->getLocEnd()
+          : getLocationOfPrecedingToken(Container->getLocEnd(),
+                                        Context.getSourceManager(),
+                                        Context.getLangOpts());
+  if (InsertionLoc.isInvalid())
+    InsertionLoc = Container->getLocEnd();
+
+  PrintingPolicy PP = Context.getPrintingPolicy();
+  PP.PolishForDeclaration = true;
+  PP.SuppressStrongLifetime = true;
+  PP.SuppressLifetimeQualifiers = true;
+  PP.SuppressUnwrittenScope = true;
+
+  std::string EndInsertionOSStr;
+  llvm::raw_string_ostream EndInsertionOS(EndInsertionOSStr);
+
+  std::string InsertionGroupStr;
+  llvm::raw_string_ostream InsertionGroupOS(InsertionGroupStr);
+
+  const ObjCProtocolDecl *CurrentProtocol = nullptr;
+  SourceLocation CurrentProtocolInsertionLoc;
+  bool IsImplementation = isa<ObjCImplDecl>(Container);
+  for (const auto &Method : MissingMethods) {
+    const ObjCProtocolDecl *P = Method.P;
+    if (CurrentProtocol != P) {
+      if (!InsertionGroupOS.str().empty()) {
+        assert(CurrentProtocolInsertionLoc.isValid());
+        Consumer(FixItHint::CreateInsertion(CurrentProtocolInsertionLoc,
+                                            InsertionGroupOS.str()));
+      }
+      InsertionGroupStr.clear();
+      CurrentProtocol = P;
+      CurrentProtocolInsertionLoc =
+          Methods.findLocationForInsertionForMethodsFromProtocol(
+              P, Container, Context.getSourceManager(), Context.getLangOpts());
+    }
+    bool IsInsertingAfterRelatedMethods = CurrentProtocolInsertionLoc.isValid();
+    raw_ostream &OS =
+        IsInsertingAfterRelatedMethods ? InsertionGroupOS : EndInsertionOS;
+
+    std::string MethodDeclStr;
+    llvm::raw_string_ostream MethodOS(MethodDeclStr);
+    Method.M->print(MethodOS, PP);
+    if (IsInsertingAfterRelatedMethods)
+      OS << "\n\n";
+    OS << StringRef(MethodOS.str()).drop_back(); // Drop the ';'
+    if (IsImplementation)
+      OS << " { \n  <#code#>\n}\n";
+    else
+      OS << ";\n";
+    if (!IsInsertingAfterRelatedMethods)
+      OS << "\n";
+  }
+  if (!InsertionGroupOS.str().empty()) {
+    assert(CurrentProtocolInsertionLoc.isValid());
+    Consumer(FixItHint::CreateInsertion(CurrentProtocolInsertionLoc,
+                                        InsertionGroupOS.str()));
+  }
+  if (!EndInsertionOS.str().empty())
+    Consumer(FixItHint::CreateInsertion(InsertionLoc, EndInsertionOS.str()));
+}
+
+void FillInMissingProtocolStubs::perform(
+    ASTContext &Context, llvm::function_ref<void(const FixItHint &)> Consumer) {
+  ::perform(Impl->Methods, Impl->Container, Context, Consumer);
+}
+
+void fillInMissingProtocolStubs::addMissingProtocolStubs(
+    ASTContext &Context, const ObjCContainerDecl *Container,
+    llvm::function_ref<void(const FixItHint &)> Consumer) {
+  FillInMissingProtocolStubsImpl Impl;
+  if (initiate(Impl, Context, Container))
+    perform(Impl.Methods, Impl.Container, Context, Consumer);
+}
diff --git a/lib/Edit/FillInMissingSwitchEnumCases.cpp b/lib/Edit/FillInMissingSwitchEnumCases.cpp
index e69de29bb2..c6d59340d3 100644
--- a/lib/Edit/FillInMissingSwitchEnumCases.cpp
+++ b/lib/Edit/FillInMissingSwitchEnumCases.cpp
@@ -0,0 +1,192 @@
+//===--- FillInMissingSwitchEnumCases.cpp -  ------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/NestedNameSpecifier.h"
+#include "clang/Edit/RefactoringFixits.h"
+#include <unordered_map>
+
+using namespace clang;
+
+namespace {
+
+struct CaseInfo {
+  const SwitchCase *Case, *NextCase;
+  unsigned Index;
+};
+typedef std::unordered_map<int64_t, CaseInfo> CoveredEnumCasesInfoType;
+
+/// Return true if the ordering of the covered enum cases is similar to the
+/// order of the enum case constants that are defined in the enum.
+bool useCaseBasedOrdering(const ArrayRef<int64_t> &CoveredEnumCaseValues,
+                          const CoveredEnumCasesInfoType &CoveredEnumCases) {
+  if (CoveredEnumCaseValues.empty())
+    return false;
+  for (const auto &I : llvm::enumerate(CoveredEnumCaseValues)) {
+    auto It = CoveredEnumCases.find(I.value());
+    if (It == CoveredEnumCases.end())
+      return false;
+    const CaseInfo &Case = It->second;
+    if (Case.Index != I.index())
+      return false;
+  }
+  return true;
+}
+
+/// Determine if the inserted cases should be wrapped in braces using a simple
+/// heuristic:
+///   Wrap only if at least 90% of existing cases use braces.
+bool useBraces(const SwitchStmt *S) {
+  unsigned CaseCount = 0, CompoundCasesCount = 0;
+  for (const SwitchCase *Case = S->getSwitchCaseList(); Case;
+       Case = Case->getNextSwitchCase(), ++CaseCount) {
+    if (!Case->getSubStmt())
+      continue;
+    if (isa<CompoundStmt>(Case->getSubStmt()))
+      ++CompoundCasesCount;
+  }
+  return CaseCount && float(CompoundCasesCount) / float(CaseCount) >= 0.9;
+}
+
+} // end anonymous namespace
+
+void edit::fillInMissingSwitchEnumCases(
+    ASTContext &Context, const SwitchStmt *Switch, const EnumDecl *Enum,
+    const DeclContext *SwitchContext,
+    llvm::function_ref<void(const FixItHint &)> Consumer) {
+  // Compute the number of cases in the switch.
+  unsigned CaseCount = 0;
+  for (const SwitchCase *Case = Switch->getSwitchCaseList(); Case;
+       Case = Case->getNextSwitchCase())
+    ++CaseCount;
+
+  // Compute the set of enum values that are covered by the switch.
+  CoveredEnumCasesInfoType CoveredEnumCases;
+  const SwitchCase *DefaultCase = nullptr;
+  const SwitchCase *FirstCoveredEnumCase = nullptr;
+  const SwitchCase *NextCase = nullptr;
+  unsigned CaseIndex = CaseCount;
+  for (const SwitchCase *Case = Switch->getSwitchCaseList(); Case;
+       NextCase = Case, Case = Case->getNextSwitchCase()) {
+    // The cases in the switch are ordered back to front, so the index has
+    // to be reversed.
+    --CaseIndex;
+    if (isa<DefaultStmt>(Case)) {
+      DefaultCase = Case;
+      continue;
+    }
+    const auto *CS = cast<CaseStmt>(Case);
+    if (const auto *LHS = CS->getLHS()) {
+      llvm::APSInt Value;
+      if (!LHS->EvaluateAsInt(Value, Context))
+        continue;
+      // Only allow constant that fix into 64 bits.
+      if (Value.getMinSignedBits() > 64)
+        continue;
+      CoveredEnumCases[Value.getSExtValue()] =
+          CaseInfo{Case, NextCase, CaseIndex};
+      // The cases in the switch are ordered back to front, so the last
+      //  case is actually the first enum case in the switch.
+      FirstCoveredEnumCase = Case;
+    }
+  }
+
+  // Wrap the inserted cases in braces using a simple heuristic:
+  //   Wrap only if at least 90% of existing cases use braces.
+  bool WrapInBraces = useBraces(Switch);
+  auto CreateReplacementForMissingCaseGroup =
+      [&](ArrayRef<const EnumConstantDecl *> UncoveredEnumCases,
+          SourceLocation InsertionLoc = SourceLocation()) {
+        if (UncoveredEnumCases.empty())
+          return;
+        std::string Result;
+        llvm::raw_string_ostream OS(Result);
+        for (const auto *EnumCase : UncoveredEnumCases) {
+          OS << "case ";
+          if (SwitchContext) {
+            const auto *NS = NestedNameSpecifier::getRequiredQualification(
+                Context, SwitchContext, Enum->getLexicalDeclContext());
+            if (NS)
+              NS->print(OS, Context.getPrintingPolicy());
+          }
+          if (Enum->isScoped())
+            OS << Enum->getName() << "::";
+          OS << EnumCase->getName() << ":";
+          if (WrapInBraces)
+            OS << " {";
+          OS << "\n<#code#>\nbreak;\n";
+          if (WrapInBraces)
+            OS << "}\n";
+        }
+
+        if (InsertionLoc.isInvalid()) {
+          // Insert the cases before the 'default' if it's the last case in the
+          // switch.
+          // Note: Switch cases are ordered back to front, so the last default
+          // case would be the first case in the switch statement.
+          if (DefaultCase && DefaultCase == Switch->getSwitchCaseList())
+            InsertionLoc = DefaultCase->getLocStart();
+          else
+            InsertionLoc = Switch->getBody()->getLocEnd();
+        }
+        Consumer(FixItHint::CreateInsertion(
+            Context.getSourceManager().getSpellingLoc(InsertionLoc), OS.str()));
+      };
+
+  // Determine which enum cases are uncovered.
+
+  llvm::SmallVector<std::pair<const EnumConstantDecl *, int64_t>, 8> EnumCases;
+  llvm::SmallVector<int64_t, 8> CoveredEnumCaseValues;
+  for (const auto *EnumCase : Enum->enumerators()) {
+    if (EnumCase->getInitVal().getMinSignedBits() > 64)
+      continue;
+    int64_t Value = EnumCase->getInitVal().getSExtValue();
+    EnumCases.push_back(std::make_pair(EnumCase, Value));
+    if (CoveredEnumCases.count(Value))
+      CoveredEnumCaseValues.push_back(Value);
+  }
+
+  llvm::SmallVector<const EnumConstantDecl *, 8> UncoveredEnumCases;
+  // Figure out if the ordering of the covered enum cases is similar to the
+  // order of enum case values defined in the enum.
+  if (useCaseBasedOrdering(CoveredEnumCaseValues, CoveredEnumCases)) {
+    // Start inserting before the first covered case.
+    SourceLocation InsertionLoc = FirstCoveredEnumCase->getLocStart();
+
+    for (const auto &EnumCase : EnumCases) {
+      if (!CoveredEnumCases.count(EnumCase.second)) {
+        UncoveredEnumCases.push_back(EnumCase.first);
+        continue;
+      }
+      // Create the insertion source replacement for this set of uncovered
+      // cases.
+      CreateReplacementForMissingCaseGroup(UncoveredEnumCases, InsertionLoc);
+      UncoveredEnumCases.clear();
+      // Find the insertion location for the next set of uncovered cases.
+      auto It = CoveredEnumCases.find(EnumCase.second);
+      assert(It != CoveredEnumCases.end() && "Missing enum case");
+      const CaseInfo &Case = It->second;
+      InsertionLoc = Case.NextCase ? Case.NextCase->getLocStart()
+                                   : /*Insert before end*/ SourceLocation();
+    }
+    CreateReplacementForMissingCaseGroup(UncoveredEnumCases, InsertionLoc);
+  } else {
+    // Gather all of the uncovered enum cases.
+    for (const auto &EnumCase : EnumCases) {
+      if (!CoveredEnumCases.count(EnumCase.second))
+        UncoveredEnumCases.push_back(EnumCase.first);
+    }
+    assert(!UncoveredEnumCases.empty() &&
+           "Can't fill-in enum cases in a full switch");
+    CreateReplacementForMissingCaseGroup(UncoveredEnumCases);
+  }
+}
diff --git a/lib/Frontend/ASTUnit.cpp b/lib/Frontend/ASTUnit.cpp
index 1160df15a9..334c6055af 100644
--- a/lib/Frontend/ASTUnit.cpp
+++ b/lib/Frontend/ASTUnit.cpp
@@ -1442,7 +1442,7 @@ ASTUnit *ASTUnit::LoadFromCompilerInvocationAction(
     if (!AST)
       return nullptr;
   }
-  
+
   if (!ResourceFilesPath.empty()) {
     // Override the resources path.
     CI->getHeaderSearchOpts().ResourceDir = ResourceFilesPath;
@@ -1685,6 +1685,9 @@ ASTUnit *ASTUnit::LoadFromCommandLine(
   if (ModuleFormat)
     CI->getHeaderSearchOpts().ModuleFormat = ModuleFormat.getValue();
 
+  if (ForSerialization)
+    CI->getLangOpts()->NeededByPCHOrCompilationUsesPCH = true;
+
   // Create the AST unit.
   std::unique_ptr<ASTUnit> AST;
   AST.reset(new ASTUnit(false));
diff --git a/lib/Frontend/CMakeLists.txt b/lib/Frontend/CMakeLists.txt
index ba3bd7d28c..da6a161600 100644
--- a/lib/Frontend/CMakeLists.txt
+++ b/lib/Frontend/CMakeLists.txt
@@ -53,6 +53,7 @@ add_clang_library(clangFrontend
   ${optional_deps}
 
   LINK_LIBS
+  clangAPINotes
   clangAST
   clangBasic
   clangDriver
diff --git a/lib/Frontend/CompilerInstance.cpp b/lib/Frontend/CompilerInstance.cpp
index 7208177aa0..a54dd1ceb6 100644
--- a/lib/Frontend/CompilerInstance.cpp
+++ b/lib/Frontend/CompilerInstance.cpp
@@ -8,6 +8,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "clang/Frontend/CompilerInstance.h"
+#include "clang/APINotes/APINotesReader.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
@@ -28,6 +29,7 @@
 #include "clang/Frontend/TextDiagnosticPrinter.h"
 #include "clang/Frontend/Utils.h"
 #include "clang/Frontend/VerifyDiagnosticConsumer.h"
+#include "clang/Index/IndexingAction.h"
 #include "clang/Lex/HeaderSearch.h"
 #include "clang/Lex/PTHManager.h"
 #include "clang/Lex/Preprocessor.h"
@@ -477,7 +479,7 @@ std::string CompilerInstance::getSpecificModuleCachePath() {
   SmallString<256> SpecificModuleCache(getHeaderSearchOpts().ModuleCachePath);
   if (!SpecificModuleCache.empty() && !getHeaderSearchOpts().DisableModuleHash)
     llvm::sys::path::append(SpecificModuleCache,
-                            getInvocation().getModuleHash());
+                            getInvocation().getModuleHash(getDiagnostics()));
   return SpecificModuleCache.str();
 }
 
@@ -637,6 +639,27 @@ void CompilerInstance::createSema(TranslationUnitKind TUKind,
                                   CodeCompleteConsumer *CompletionConsumer) {
   TheSema.reset(new Sema(getPreprocessor(), getASTContext(), getASTConsumer(),
                          TUKind, CompletionConsumer));
+
+  // Set up API notes.
+  TheSema->APINotes.setSwiftVersion(getAPINotesOpts().SwiftVersion);
+
+  // If we're building a module and are supposed to load API notes,
+  // notify the API notes manager.
+  if (auto currentModule = getPreprocessor().getCurrentModule()) {
+    (void)TheSema->APINotes.loadCurrentModuleAPINotes(
+            currentModule,
+            getLangOpts().APINotesModules,
+            getAPINotesOpts().ModuleSearchPaths);
+    // Check for any attributes we should add to the module
+    for (auto reader : TheSema->APINotes.getCurrentModuleReaders()) {
+      // swift_infer_import_as_member
+      if (reader->getModuleOptions().SwiftInferImportAsMember) {
+        currentModule->IsSwiftInferImportAsMember = true;
+        break;
+      }
+    }
+  }
+
   // Attach the external sema source if there is any.
   if (ExternalSemaSrc) {
     TheSema->addExternalSource(ExternalSemaSrc.get());
@@ -1120,9 +1143,11 @@ compileModuleImpl(CompilerInstance &ImportingInstance, SourceLocation ImportLoc,
   PPOpts.RetainRemappedFileBuffers = true;
     
   Invocation->getDiagnosticOpts().VerifyDiagnostics = 0;
-  assert(ImportingInstance.getInvocation().getModuleHash() ==
-         Invocation->getModuleHash() && "Module hash mismatch!");
-  
+  assert(ImportingInstance.getInvocation().getModuleHash(
+             ImportingInstance.getDiagnostics()) ==
+             Invocation->getModuleHash(ImportingInstance.getDiagnostics()) &&
+         "Module hash mismatch!");
+
   // Construct a compiler instance that will be used to actually create the
   // module.  Since we're sharing a PCMCache,
   // CompilerInstance::CompilerInstance is responsible for finalizing the
@@ -1148,6 +1173,10 @@ compileModuleImpl(CompilerInstance &ImportingInstance, SourceLocation ImportLoc,
   SourceMgr.pushModuleBuildStack(ModuleName,
     FullSourceLoc(ImportLoc, ImportingInstance.getSourceManager()));
 
+  // Pass along the GenModuleActionWrapper callback
+  auto wrapGenModuleAction = ImportingInstance.getGenModuleActionWrapper();
+  Instance.setGenModuleActionWrapper(wrapGenModuleAction);
+
   // If we're collecting module dependencies, we need to share a collector
   // between all of the module CompilerInstances. Other than that, we don't
   // want to produce any dependency output from the module build.
@@ -1166,8 +1195,14 @@ compileModuleImpl(CompilerInstance &ImportingInstance, SourceLocation ImportLoc,
   llvm::CrashRecoveryContext CRC;
   CRC.RunSafelyOnThread(
       [&]() {
-        GenerateModuleFromModuleMapAction Action;
-        Instance.ExecuteAction(Action);
+        // FIXME: I have no idea what the best way to do this is, but it's
+        // probably not this. Interfaces changed upstream.
+        std::unique_ptr<FrontendAction> Action(
+            new GenerateModuleFromModuleMapAction);
+        if (wrapGenModuleAction) {
+          Action = wrapGenModuleAction(FrontendOpts, std::move(Action));
+        }
+        Instance.ExecuteAction(*Action);
       },
       ThreadStackSize);
 
diff --git a/lib/Frontend/CompilerInvocation.cpp b/lib/Frontend/CompilerInvocation.cpp
index 6ce719aac6..b828d4d30a 100644
--- a/lib/Frontend/CompilerInvocation.cpp
+++ b/lib/Frontend/CompilerInvocation.cpp
@@ -1486,6 +1486,10 @@ static InputKind ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,
       << "ARC migration" << "ObjC migration";
   }
 
+  Opts.IndexStorePath = Args.getLastArgValue(OPT_index_store_path);
+  Opts.IndexIgnoreSystemSymbols = Args.hasArg(OPT_index_ignore_system_symbols);
+  Opts.IndexRecordCodegenName = Args.hasArg(OPT_index_record_codegen_name);
+
   InputKind DashX(InputKind::Unknown);
   if (const Arg *A = Args.getLastArg(OPT_x)) {
     StringRef XValue = A->getValue();
@@ -1723,6 +1727,18 @@ static void ParseHeaderSearchArgs(HeaderSearchOptions &Opts, ArgList &Args,
     Opts.AddVFSOverlayFile(A->getValue());
 }
 
+static void ParseAPINotesArgs(APINotesOptions &Opts, ArgList &Args,
+                              DiagnosticsEngine &diags) {
+  using namespace options;
+  if (const Arg *A = Args.getLastArg(OPT_fapinotes_swift_version)) {
+    if (Opts.SwiftVersion.tryParse(A->getValue()))
+      diags.Report(diag::err_drv_invalid_value)
+        << A->getAsString(Args) << A->getValue();
+  }
+  for (const Arg *A : Args.filtered(OPT_iapinotes_modules))
+    Opts.ModuleSearchPaths.push_back(A->getValue());
+}
+
 void CompilerInvocation::setLangDefaults(LangOptions &Opts, InputKind IK,
                                          const llvm::Triple &T,
                                          PreprocessorOptions &PPOpts,
@@ -2212,6 +2228,7 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
       Args.hasArg(OPT_fmodules_local_submodule_visibility) || Opts.ModulesTS;
   Opts.ModulesCodegen = Args.hasArg(OPT_fmodules_codegen);
   Opts.ModulesDebugInfo = Args.hasArg(OPT_fmodules_debuginfo);
+  Opts.ModulesHashErrorDiags = Args.hasArg(OPT_fmodules_hash_error_diagnostics);
   Opts.ModulesSearchAll = Opts.Modules &&
     !Args.hasArg(OPT_fno_modules_search_all) &&
     Args.hasArg(OPT_fmodules_search_all);
@@ -2307,6 +2324,8 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
   // is enabled.
   Opts.HalfArgsAndReturns = Args.hasArg(OPT_fallow_half_arguments_and_returns)
                             | Opts.NativeHalfArgsAndReturns;
+  Opts.APINotes = Args.hasArg(OPT_fapinotes);
+  Opts.APINotesModules = Args.hasArg(OPT_fapinotes_modules);
   Opts.GNUAsm = !Args.hasArg(OPT_fno_gnu_inline_asm);
 
   // __declspec is enabled by default for the PS4 by the driver, and also
@@ -2777,6 +2796,7 @@ bool CompilerInvocation::CreateFromArgs(CompilerInvocation &Res,
                               Res.getTargetOpts());
   ParseHeaderSearchArgs(Res.getHeaderSearchOpts(), Args,
                         Res.getFileSystemOpts().WorkingDir);
+  ParseAPINotesArgs(Res.getAPINotesOpts(), Args, Diags);
   if (DashX.getFormat() == InputKind::Precompiled ||
       DashX.getLanguage() == InputKind::LLVM_IR) {
     // ObjCAAutoRefCount and Sanitize LangOpts are used to setup the
@@ -2827,6 +2847,10 @@ bool CompilerInvocation::CreateFromArgs(CompilerInvocation &Res,
   ParsePreprocessorOutputArgs(Res.getPreprocessorOutputOpts(), Args,
                               Res.getFrontendOpts().ProgramAction);
 
+  if (!Res.getPreprocessorOpts().ImplicitPCHInclude.empty() ||
+      Res.getFrontendOpts().ProgramAction == frontend::GeneratePCH)
+    LangOpts.NeededByPCHOrCompilationUsesPCH = true;
+
   // Turn on -Wspir-compat for SPIR target.
   llvm::Triple T(Res.getTargetOpts().Triple);
   auto Arch = T.getArch();
@@ -2843,7 +2867,16 @@ bool CompilerInvocation::CreateFromArgs(CompilerInvocation &Res,
   return Success;
 }
 
-std::string CompilerInvocation::getModuleHash() const {
+// Some extension diagnostics aren't explicitly mapped and require custom
+// logic in the dianognostic engine to be used, track -pedantic-errors
+static bool isExtHandlingFromDiagsError(DiagnosticsEngine &Diags) {
+  diag::Severity Ext = Diags.getExtensionHandlingBehavior();
+  if (Ext == diag::Severity::Warning && Diags.getWarningsAsErrors())
+    return true;
+  return Ext >= diag::Severity::Error;
+}
+
+std::string CompilerInvocation::getModuleHash(DiagnosticsEngine &Diags) const {
   // Note: For QoI reasons, the things we use as a hash here should all be
   // dumped via the -module-info flag.
   using llvm::hash_code;
@@ -2912,7 +2945,19 @@ std::string CompilerInvocation::getModuleHash() const {
   // Extend the signature with the module file extensions.
   const FrontendOptions &frontendOpts = getFrontendOpts();
   for (const auto &ext : frontendOpts.ModuleFileExtensions) {
-    code = ext->hashExtension(code);
+    code = hash_combine(code, ext->hashExtension(code));
+  }
+
+  // Extend the signature with the SWift version for API notes.
+  const APINotesOptions &apiNotesOpts = getAPINotesOpts();
+  if (apiNotesOpts.SwiftVersion) {
+    code = hash_combine(code, apiNotesOpts.SwiftVersion.getMajor());
+    if (auto minor = apiNotesOpts.SwiftVersion.getMinor())
+      code = hash_combine(code, *minor);
+    if (auto subminor = apiNotesOpts.SwiftVersion.getSubminor())
+      code = hash_combine(code, *subminor);
+    if (auto build = apiNotesOpts.SwiftVersion.getBuild())
+      code = hash_combine(code, *build);
   }
 
   // Extend the signature with the enabled sanitizers, if at least one is
@@ -2922,6 +2967,24 @@ std::string CompilerInvocation::getModuleHash() const {
   if (!SanHash.empty())
     code = hash_combine(code, SanHash.Mask);
 
+  // Check for a couple things (see checkDiagnosticMappings in ASTReader.cpp):
+  //  -Werror: consider all warnings into the hash
+  //  -Werror=something: consider only the specified into the hash
+  //  -pedantic-error
+  if (getLangOpts()->ModulesHashErrorDiags) {
+    bool ConsiderAllWarningsAsErrors = Diags.getWarningsAsErrors();
+    code = hash_combine(code, isExtHandlingFromDiagsError(Diags));
+    for (auto DiagIDMappingPair : Diags.getDiagnosticMappings()) {
+      diag::kind DiagID = DiagIDMappingPair.first;
+      auto CurLevel = Diags.getDiagnosticLevel(DiagID, SourceLocation());
+      if (CurLevel < DiagnosticsEngine::Error && !ConsiderAllWarningsAsErrors)
+        continue; // not significant
+      code = hash_combine(
+          code,
+          Diags.getDiagnosticIDs()->getWarningOptionForDiag(DiagID).str());
+    }
+  }
+
   return llvm::APInt(64, code).toString(36, /*Signed=*/false);
 }
 
diff --git a/lib/Frontend/FrontendAction.cpp b/lib/Frontend/FrontendAction.cpp
index 12226b2314..2ff5ea46f2 100644
--- a/lib/Frontend/FrontendAction.cpp
+++ b/lib/Frontend/FrontendAction.cpp
@@ -694,6 +694,7 @@ bool FrontendAction::BeginSourceFile(CompilerInstance &CI,
                 CI.getLangOpts(), CI.getTargetOpts(), CI.getPreprocessorOpts(),
                 SpecificModuleCachePath)) {
           PPOpts.ImplicitPCHInclude = Dir->getName();
+          CI.getLangOpts().NeededByPCHOrCompilationUsesPCH = true;
           Found = true;
           break;
         }
@@ -858,6 +859,13 @@ bool FrontendAction::BeginSourceFile(CompilerInstance &CI,
       CI.getDiagnostics().Report(diag::err_module_map_not_found) << Filename;
   }
 
+  // Add a module declaration scope so that modules from -fmodule-map-file
+  // arguments may shadow modules found implicitly in search paths.
+  CI.getPreprocessor()
+      .getHeaderSearchInfo()
+      .getModuleMap()
+      .finishModuleDeclarationScope();
+
   // If we were asked to load any module files, do so now.
   for (const auto &ModuleFile : CI.getFrontendOpts().ModuleFiles)
     if (!CI.loadModuleFile(ModuleFile))
diff --git a/lib/FrontendTool/CMakeLists.txt b/lib/FrontendTool/CMakeLists.txt
index 7e11be0ce4..4a713e5902 100644
--- a/lib/FrontendTool/CMakeLists.txt
+++ b/lib/FrontendTool/CMakeLists.txt
@@ -8,6 +8,7 @@ set(link_libs
   clangCodeGen
   clangDriver
   clangFrontend
+  clangIndex
   clangRewriteFrontend
   )
 
diff --git a/lib/FrontendTool/ExecuteCompilerInvocation.cpp b/lib/FrontendTool/ExecuteCompilerInvocation.cpp
index 4167e1fe20..ae4814e3ae 100644
--- a/lib/FrontendTool/ExecuteCompilerInvocation.cpp
+++ b/lib/FrontendTool/ExecuteCompilerInvocation.cpp
@@ -23,6 +23,7 @@
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Frontend/FrontendPluginRegistry.h"
 #include "clang/Frontend/Utils.h"
+#include "clang/Index/IndexingAction.h"
 #include "clang/Rewrite/Frontend/FrontendActions.h"
 #include "clang/StaticAnalyzer/Frontend/FrontendActions.h"
 #include "llvm/Option/OptTable.h"
@@ -164,6 +165,11 @@ CreateFrontendAction(CompilerInstance &CI) {
   }
 #endif
 
+  if (!FEOpts.IndexStorePath.empty()) {
+    Act = index::createIndexDataRecordingAction(FEOpts, std::move(Act));
+    CI.setGenModuleActionWrapper(&index::createIndexDataRecordingAction);
+  }
+
   // If there are any AST files to merge, create a frontend action
   // adaptor to perform the merge.
   if (!FEOpts.ASTMergeFiles.empty())
diff --git a/lib/Index/BitstreamVisitor.h b/lib/Index/BitstreamVisitor.h
index e69de29bb2..d324f1a4fd 100644
--- a/lib/Index/BitstreamVisitor.h
+++ b/lib/Index/BitstreamVisitor.h
@@ -0,0 +1,163 @@
+//===--- BitstreamVisitor.h - Helper for reading a bitstream --------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_INDEX_BITSTREAMVISITOR_H
+#define LLVM_CLANG_LIB_INDEX_BITSTREAMVISITOR_H
+
+#include "llvm/Bitcode/BitstreamReader.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Serialization/ASTReader.h"
+#include <string>
+
+namespace clang {
+namespace index {
+namespace store {
+
+/// Helper class that saves the current stream position and
+/// then restores it when destroyed.
+struct SavedStreamPosition {
+  explicit SavedStreamPosition(llvm::BitstreamCursor &Cursor)
+    : Cursor(Cursor), Offset(Cursor.GetCurrentBitNo()) { }
+
+  ~SavedStreamPosition() {
+    Cursor.JumpToBit(Offset);
+  }
+
+private:
+  llvm::BitstreamCursor &Cursor;
+  uint64_t Offset;
+};
+
+enum class StreamVisit {
+  Continue,
+  Skip,
+  Abort
+};
+
+template <typename ImplClass>
+class BitstreamVisitor {
+  SmallVector<unsigned, 4> BlockStack;
+
+protected:
+  llvm::BitstreamCursor &Stream;
+  Optional<llvm::BitstreamBlockInfo> BlockInfo;
+  std::string *Error;
+
+public:
+  BitstreamVisitor(llvm::BitstreamCursor &Stream)
+    : Stream(Stream) {}
+
+  StreamVisit visitBlock(unsigned ID) {
+    return StreamVisit::Continue;
+  }
+
+  bool visit(std::string &Error) {
+    this->Error = &Error;
+
+    ASTReader::RecordData Record;
+    while (1) {
+      llvm::BitstreamEntry Entry = Stream.advance(llvm::BitstreamCursor::AF_DontPopBlockAtEnd);
+
+      switch (Entry.Kind) {
+      case llvm::BitstreamEntry::Error:
+        Error = "malformed serialization";
+        return false;
+
+      case llvm::BitstreamEntry::EndBlock:
+        if (BlockStack.empty())
+          return true;
+        BlockStack.pop_back();
+        if (Stream.ReadBlockEnd()) {
+          Error = "malformed serialization";
+          return false;
+        }
+        if (Stream.AtEndOfStream())
+          return true;
+        break;
+
+      case llvm::BitstreamEntry::SubBlock: {
+        if (Entry.ID == llvm::bitc::BLOCKINFO_BLOCK_ID) {
+          BlockInfo = Stream.ReadBlockInfoBlock();
+          if (!BlockInfo) {
+            Error = "malformed BlockInfoBlock";
+            return false;
+          }
+          Stream.setBlockInfo(&*BlockInfo);
+          break;
+        }
+
+        StreamVisit Ret = static_cast<ImplClass*>(this)->visitBlock(Entry.ID);
+        switch (Ret) {
+        case StreamVisit::Continue:
+          if (Stream.EnterSubBlock(Entry.ID)) {
+            Error = "malformed block record";
+            return false;
+          }
+          readBlockAbbrevs(Stream);
+          BlockStack.push_back(Entry.ID);
+          break;
+
+        case StreamVisit::Skip: 
+          if (Stream.SkipBlock()) {
+            Error = "malformed serialization";
+            return false;
+          }
+          if (Stream.AtEndOfStream())
+            return true;
+          break;
+
+        case StreamVisit::Abort:
+          return false;
+        }
+        break;
+      }
+
+      case llvm::BitstreamEntry::Record: {
+        Record.clear();
+        StringRef Blob;
+        unsigned RecID = Stream.readRecord(Entry.ID, Record, &Blob);
+        unsigned BlockID = BlockStack.empty() ? 0 : BlockStack.back();
+        StreamVisit Ret = static_cast<ImplClass*>(this)->visitRecord(BlockID, RecID, Record, Blob);
+        switch (Ret) {
+        case StreamVisit::Continue:
+          break;
+
+        case StreamVisit::Skip: 
+          Stream.skipRecord(Entry.ID);
+          break;
+
+        case StreamVisit::Abort:
+          return false;
+        }
+        break;
+      }
+      }
+    }
+  }
+
+  static void readBlockAbbrevs(llvm::BitstreamCursor &Cursor) {
+    while (true) {
+      uint64_t Offset = Cursor.GetCurrentBitNo();
+      unsigned Code = Cursor.ReadCode();
+
+      // We expect all abbrevs to be at the start of the block.
+      if (Code != llvm::bitc::DEFINE_ABBREV) {
+        Cursor.JumpToBit(Offset);
+        return;
+      }
+      Cursor.ReadAbbrevRecord();
+    }
+  }
+};
+
+} // end namespace store
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/lib/Index/CMakeLists.txt b/lib/Index/CMakeLists.txt
index c9fbfafcf9..bb17d15b55 100644
--- a/lib/Index/CMakeLists.txt
+++ b/lib/Index/CMakeLists.txt
@@ -1,17 +1,27 @@
 set(LLVM_LINK_COMPONENTS
+  BitReader
   Core
   Support
   )
 
 add_clang_library(clangIndex
+  ClangIndexRecordWriter.cpp
   CodegenNameGenerator.cpp
   CommentToXML.cpp
+  FileIndexRecord.cpp
   IndexBody.cpp
+  IndexDataStore.cpp
+  IndexDataStoreUtils.cpp
   IndexDecl.cpp
   IndexingAction.cpp
   IndexingContext.cpp
+  IndexRecordHasher.cpp
+  IndexRecordReader.cpp
+  IndexRecordWriter.cpp
   IndexSymbol.cpp
   IndexTypeSourceInfo.cpp
+  IndexUnitReader.cpp
+  IndexUnitWriter.cpp
   USRGeneration.cpp
 
   ADDITIONAL_HEADERS
@@ -23,6 +33,7 @@ add_clang_library(clangIndex
   clangBasic
   clangFormat
   clangFrontend
+  clangLex
   clangRewrite
   clangSerialization
   clangToolingCore
diff --git a/lib/Index/ClangIndexRecordWriter.cpp b/lib/Index/ClangIndexRecordWriter.cpp
index e69de29bb2..612ef1b5b4 100644
--- a/lib/Index/ClangIndexRecordWriter.cpp
+++ b/lib/Index/ClangIndexRecordWriter.cpp
@@ -0,0 +1,128 @@
+//===--- ClangIndexRecordWriter.cpp - Index record serialization ----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "ClangIndexRecordWriter.h"
+#include "FileIndexRecord.h"
+#include "clang/Index/IndexSymbol.h"
+#include "clang/Index/IndexRecordReader.h"
+#include "clang/Index/USRGeneration.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/DeclObjC.h"
+
+using namespace clang;
+using namespace clang::index;
+
+StringRef ClangIndexRecordWriter::getUSR(const Decl *D) {
+  assert(D->isCanonicalDecl());
+  auto Insert = USRByDecl.insert(std::make_pair(D, StringRef()));
+  if (Insert.second) {
+    Insert.first->second = getUSRNonCached(D);
+  }
+  return Insert.first->second;
+}
+
+StringRef ClangIndexRecordWriter::getUSRNonCached(const Decl *D) {
+  SmallString<256> Buf;
+  bool Ignore = generateUSRForDecl(D, Buf);
+  if (Ignore)
+    return StringRef();
+  StringRef USR = Buf.str();
+  char *Ptr = Allocator.Allocate<char>(USR.size());
+  std::copy(USR.begin(), USR.end(), Ptr);
+  return StringRef(Ptr, USR.size());
+}
+
+ClangIndexRecordWriter::ClangIndexRecordWriter(ASTContext &Ctx,
+                                               RecordingOptions Opts)
+    : Impl(Opts.DataDirPath), Ctx(Ctx), RecordOpts(std::move(Opts)),
+      Hasher(Ctx) {
+  if (Opts.RecordSymbolCodeGenName)
+    CGNameGen.reset(new CodegenNameGenerator(Ctx));
+}
+
+ClangIndexRecordWriter::~ClangIndexRecordWriter() {}
+
+bool ClangIndexRecordWriter::writeRecord(StringRef Filename,
+                                         const FileIndexRecord &IdxRecord,
+                                         std::string &Error,
+                                         std::string *OutRecordFile) {
+
+  auto RecordHash = Hasher.hashRecord(IdxRecord);
+
+  switch (Impl.beginRecord(Filename, RecordHash, Error, OutRecordFile)) {
+  case IndexRecordWriter::Result::Success:
+    break; // Continue writing.
+  case IndexRecordWriter::Result::Failure:
+    return true;
+  case IndexRecordWriter::Result::AlreadyExists:
+    return false;
+  }
+
+  ASTContext &Ctx = getASTContext();
+  SourceManager &SM = Ctx.getSourceManager();
+  FileID FID = IdxRecord.getFileID();
+  auto getLineCol = [&](unsigned Offset) -> std::pair<unsigned, unsigned> {
+    unsigned LineNo = SM.getLineNumber(FID, Offset);
+    unsigned ColNo = SM.getColumnNumber(FID, Offset);
+    return std::make_pair(LineNo, ColNo);
+  };
+
+  for (auto &Occur : IdxRecord.getDeclOccurrences()) {
+    unsigned Line, Col;
+    std::tie(Line, Col) = getLineCol(Occur.Offset);
+    SmallVector<writer::SymbolRelation, 3> Related;
+    Related.reserve(Occur.Relations.size());
+    for (auto &Rel : Occur.Relations)
+      Related.push_back(writer::SymbolRelation{Rel.RelatedSymbol, Rel.Roles});
+
+    Impl.addOccurrence(Occur.Dcl, Occur.Roles, Line, Col, Related);
+  }
+
+  PrintingPolicy Policy(Ctx.getLangOpts());
+  Policy.SuppressTemplateArgsInCXXConstructors = true;
+
+  auto Result = Impl.endRecord(Error,
+      [&](writer::OpaqueDecl OD, SmallVectorImpl<char> &Scratch) {
+    const Decl *D = static_cast<const Decl *>(OD);
+    auto Info = getSymbolInfo(D);
+
+    writer::Symbol Sym;
+    Sym.SymInfo = Info;
+
+    auto *ND = dyn_cast<NamedDecl>(D);
+    if (ND) {
+      llvm::raw_svector_ostream OS(Scratch);
+      DeclarationName DeclName = ND->getDeclName();
+      if (!DeclName.isEmpty())
+        DeclName.print(OS, Policy);
+    }
+    unsigned NameLen = Scratch.size();
+    Sym.Name = StringRef(Scratch.data(), NameLen);
+
+    Sym.USR = getUSR(D);
+    assert(!Sym.USR.empty() && "Recorded decl without USR!");
+
+    if (CGNameGen && ND) {
+      llvm::raw_svector_ostream OS(Scratch);
+      CGNameGen->writeName(ND, OS);
+    }
+    unsigned CGNameLen = Scratch.size() - NameLen;
+    Sym.CodeGenName = StringRef(Scratch.data() + NameLen, CGNameLen);
+    return Sym;
+  });
+
+  switch (Result) {
+  case IndexRecordWriter::Result::Success:
+  case IndexRecordWriter::Result::AlreadyExists:
+    return false;
+  case IndexRecordWriter::Result::Failure:
+    return true;
+  }
+}
diff --git a/lib/Index/ClangIndexRecordWriter.h b/lib/Index/ClangIndexRecordWriter.h
index e69de29bb2..b68f9875fb 100644
--- a/lib/Index/ClangIndexRecordWriter.h
+++ b/lib/Index/ClangIndexRecordWriter.h
@@ -0,0 +1,55 @@
+//===--- ClangIndexRecordWriter.h - Index record serialization ------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_INDEX_CLANGINDEXRECORDWRITER_H
+#define LLVM_CLANG_LIB_INDEX_CLANGINDEXRECORDWRITER_H
+
+#include "IndexRecordHasher.h"
+#include "clang/Index/IndexRecordWriter.h"
+#include "clang/Index/IndexingAction.h"
+#include "clang/Index/CodegenNameGenerator.h"
+#include "llvm/ADT/SmallString.h"
+
+namespace clang {
+  class ASTContext;
+  class Decl;
+
+namespace index {
+  class FileIndexRecord;
+
+class ClangIndexRecordWriter {
+  IndexRecordWriter Impl;
+
+  ASTContext &Ctx;
+  RecordingOptions RecordOpts;
+
+  std::unique_ptr<CodegenNameGenerator> CGNameGen;
+  llvm::BumpPtrAllocator Allocator;
+  llvm::DenseMap<const Decl *, StringRef> USRByDecl;
+  IndexRecordHasher Hasher;
+
+public:
+  ClangIndexRecordWriter(ASTContext &Ctx, RecordingOptions Opts);
+  ~ClangIndexRecordWriter();
+
+  ASTContext &getASTContext() { return Ctx; }
+  CodegenNameGenerator *getCGNameGen() { return CGNameGen.get(); }
+
+  bool writeRecord(StringRef Filename, const FileIndexRecord &Record,
+                   std::string &Error, std::string *RecordFile = nullptr);
+  StringRef getUSR(const Decl *D);
+
+private:
+  StringRef getUSRNonCached(const Decl *D);
+};
+
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/lib/Index/FileIndexRecord.cpp b/lib/Index/FileIndexRecord.cpp
index e69de29bb2..98d66b67c0 100644
--- a/lib/Index/FileIndexRecord.cpp
+++ b/lib/Index/FileIndexRecord.cpp
@@ -0,0 +1,59 @@
+//===--- FileIndexRecord.cpp - Index data per file ------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "FileIndexRecord.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DeclTemplate.h"
+#include "llvm/ADT/SmallString.h"
+#include "llvm/Support/Path.h"
+
+using namespace clang;
+using namespace clang::index;
+
+void FileIndexRecord::addDeclOccurence(SymbolRoleSet Roles,
+                                       unsigned Offset,
+                                       const Decl *D,
+                                       ArrayRef<SymbolRelation> Relations) {
+  assert(D->isCanonicalDecl());
+
+  auto IsNextOccurence = [&]()->bool {
+    if (Decls.empty())
+      return true;
+    auto &Last = Decls.back();
+    return Last.Offset < Offset;
+  };
+
+  if (IsNextOccurence()) {
+    Decls.emplace_back(Roles, Offset, D, Relations);
+    return;
+  }
+
+  DeclOccurrence NewInfo(Roles, Offset, D, Relations);
+  auto It = std::upper_bound(Decls.begin(), Decls.end(), NewInfo);
+  Decls.insert(It, std::move(NewInfo));
+}
+
+void FileIndexRecord::print(llvm::raw_ostream &OS) {
+  OS << "DECLS BEGIN ---\n";
+  for (auto &DclInfo : Decls) {
+    auto D = DclInfo.Dcl;
+    SourceManager &SM = D->getASTContext().getSourceManager();
+    SourceLocation Loc = SM.getFileLoc(D->getLocation());
+    PresumedLoc PLoc = SM.getPresumedLoc(Loc);
+    OS << llvm::sys::path::filename(PLoc.getFilename()) << ':' << PLoc.getLine()
+       << ':' << PLoc.getColumn();
+
+    if (auto ND = dyn_cast<NamedDecl>(D)) {
+      OS << ' ' << ND->getNameAsString();
+    }
+
+    OS << '\n';
+  }
+  OS << "DECLS END ---\n";
+}
diff --git a/lib/Index/FileIndexRecord.h b/lib/Index/FileIndexRecord.h
index e69de29bb2..a663173c7d 100644
--- a/lib/Index/FileIndexRecord.h
+++ b/lib/Index/FileIndexRecord.h
@@ -0,0 +1,69 @@
+//===--- FileIndexRecord.h - Index data per file --------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_INDEX_FILEINDEXRECORD_H
+#define LLVM_CLANG_LIB_INDEX_FILEINDEXRECORD_H
+
+#include "clang/Index/IndexSymbol.h"
+#include "clang/Basic/SourceLocation.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/SmallVector.h"
+#include <vector>
+
+namespace clang {
+  class IdentifierInfo;
+
+namespace index {
+
+class FileIndexRecord {
+public:
+  struct DeclOccurrence {
+    SymbolRoleSet Roles;
+    unsigned Offset;
+    const Decl *Dcl;
+    SmallVector<SymbolRelation, 3> Relations;
+
+    DeclOccurrence(SymbolRoleSet R,
+                   unsigned Offset,
+                   const Decl *D,
+                   ArrayRef<SymbolRelation> Relations)
+      : Roles(R),
+        Offset(Offset),
+        Dcl(D),
+        Relations(Relations.begin(), Relations.end()) {}
+
+    friend bool operator <(const DeclOccurrence &LHS, const DeclOccurrence &RHS) {
+      return LHS.Offset < RHS.Offset;
+    }
+  };
+
+private:
+  FileID FID;
+  bool IsSystem;
+  std::vector<DeclOccurrence> Decls;
+
+public:
+  FileIndexRecord(FileID FID, bool isSystem) : FID(FID), IsSystem(isSystem) {}
+
+  ArrayRef<DeclOccurrence> getDeclOccurrences() const { return Decls; }
+
+  FileID getFileID() const { return FID; }
+  bool isSystem() const { return IsSystem; }
+
+  void addDeclOccurence(SymbolRoleSet Roles,
+                        unsigned Offset,
+                        const Decl *D,
+                        ArrayRef<SymbolRelation> Relations);
+  void print(llvm::raw_ostream &OS);
+};
+
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/lib/Index/IndexDataStore.cpp b/lib/Index/IndexDataStore.cpp
index e69de29bb2..4140392dfc 100644
--- a/lib/Index/IndexDataStore.cpp
+++ b/lib/Index/IndexDataStore.cpp
@@ -0,0 +1,259 @@
+//===--- IndexDataStore.cpp - Index data store info -----------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Index/IndexDataStore.h"
+#include "IndexDataStoreUtils.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Mutex.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace clang::index::store;
+using namespace llvm;
+
+static void appendSubDir(StringRef subdir, SmallVectorImpl<char> &StorePathBuf) {
+  SmallString<10> VersionPath;
+  raw_svector_ostream(VersionPath) << 'v' << STORE_FORMAT_VERSION;
+
+  sys::path::append(StorePathBuf, VersionPath);
+  sys::path::append(StorePathBuf, subdir);
+}
+
+void store::appendInteriorUnitPath(StringRef UnitName,
+                                   SmallVectorImpl<char> &PathBuf) {
+  sys::path::append(PathBuf, UnitName);
+}
+
+void store::appendUnitSubDir(SmallVectorImpl<char> &StorePathBuf) {
+  return appendSubDir("units", StorePathBuf);
+}
+
+void store::appendRecordSubDir(SmallVectorImpl<char> &StorePathBuf) {
+  return appendSubDir("records", StorePathBuf);
+}
+
+void store::appendInteriorRecordPath(StringRef RecordName,
+                                     SmallVectorImpl<char> &PathBuf) {
+  // To avoid putting a huge number of files into the records directory, create
+  // subdirectories based on the last 2 characters from the hash.
+  StringRef hash2chars = RecordName.substr(RecordName.size()-2);
+  sys::path::append(PathBuf, hash2chars);
+  sys::path::append(PathBuf, RecordName);
+}
+
+//===----------------------------------------------------------------------===//
+// IndexDataStore
+//===----------------------------------------------------------------------===//
+
+namespace {
+
+class UnitEventHandlerData {
+  mutable sys::Mutex Mtx;
+  IndexDataStore::UnitEventHandler Handler;
+
+public:
+  void setHandler(IndexDataStore::UnitEventHandler handler) {
+    sys::ScopedLock L(Mtx);
+    Handler = std::move(handler);
+  }
+  IndexDataStore::UnitEventHandler getHandler() const {
+    sys::ScopedLock L(Mtx);
+    return Handler;
+  }
+};
+
+class IndexDataStoreImpl {
+  std::string FilePath;
+  std::shared_ptr<UnitEventHandlerData> TheUnitEventHandlerData;
+  std::unique_ptr<AbstractDirectoryWatcher> DirWatcher;
+
+public:
+  explicit IndexDataStoreImpl(StringRef indexStorePath)
+    : FilePath(indexStorePath) {
+    TheUnitEventHandlerData = std::make_shared<UnitEventHandlerData>();
+  }
+
+  StringRef getFilePath() const { return FilePath; }
+  bool foreachUnitName(bool sorted,
+                       llvm::function_ref<bool(StringRef unitName)> receiver);
+  void setUnitEventHandler(IndexDataStore::UnitEventHandler Handler);
+  bool startEventListening(llvm::function_ref<AbstractDirectoryWatcher::CreateFnTy> createFn,
+                           bool waitInitialSync, std::string &Error);
+  void stopEventListening();
+  void discardUnit(StringRef UnitName);
+  void discardRecord(StringRef RecordName);
+  void purgeStaleData();
+};
+
+} // anonymous namespace
+
+bool IndexDataStoreImpl::foreachUnitName(bool sorted,
+                        llvm::function_ref<bool(StringRef unitName)> receiver) {
+  SmallString<128> UnitPath;
+  UnitPath = FilePath;
+  appendUnitSubDir(UnitPath);
+
+  std::vector<std::string> filenames;
+
+  std::error_code EC;
+  for (auto It = sys::fs::directory_iterator(UnitPath, EC),
+           End = sys::fs::directory_iterator();
+       !EC && It != End; It.increment(EC)) {
+    StringRef unitName = sys::path::filename(It->path());
+    if (!sorted) {
+      if (!receiver(unitName))
+        return false;
+    } else {
+      filenames.push_back(unitName);
+    }
+  }
+
+  if (sorted) {
+    llvm::array_pod_sort(filenames.begin(), filenames.end());
+    for (auto &fname : filenames)
+      if (!receiver(fname))
+        return false;
+  }
+  return true;
+}
+
+void IndexDataStoreImpl::setUnitEventHandler(IndexDataStore::UnitEventHandler handler) {
+  TheUnitEventHandlerData->setHandler(std::move(handler));
+}
+
+bool IndexDataStoreImpl::startEventListening(llvm::function_ref<AbstractDirectoryWatcher::CreateFnTy> createFn,
+                                             bool waitInitialSync, std::string &Error) {
+  if (DirWatcher) {
+    Error = "event listener already active";
+    return true;
+  }
+
+  SmallString<128> UnitPath;
+  UnitPath = FilePath;
+  appendUnitSubDir(UnitPath);
+
+  auto localUnitEventHandlerData = TheUnitEventHandlerData;
+  auto OnUnitsChange = [localUnitEventHandlerData](ArrayRef<AbstractDirectoryWatcher::Event> Events, bool isInitial) {
+    SmallVector<IndexDataStore::UnitEvent, 16> UnitEvents;
+    UnitEvents.reserve(Events.size());
+    for (const AbstractDirectoryWatcher::Event &evt : Events) {
+      IndexDataStore::UnitEventKind K;
+      StringRef UnitName = sys::path::filename(evt.Filename);
+      switch (evt.Kind) {
+      case AbstractDirectoryWatcher::EventKind::Added:
+        K = IndexDataStore::UnitEventKind::Added; break;
+      case AbstractDirectoryWatcher::EventKind::Removed:
+        K = IndexDataStore::UnitEventKind::Removed; break;
+      case AbstractDirectoryWatcher::EventKind::Modified:
+        K = IndexDataStore::UnitEventKind::Modified; break;
+      case AbstractDirectoryWatcher::EventKind::DirectoryDeleted:
+        K = IndexDataStore::UnitEventKind::DirectoryDeleted;
+        UnitName = StringRef();
+        break;
+      }
+      UnitEvents.push_back(IndexDataStore::UnitEvent{K, UnitName, evt.ModTime});
+    }
+
+    if (auto handler = localUnitEventHandlerData->getHandler()) {
+      IndexDataStore::UnitEventNotification EventNote{isInitial, UnitEvents};
+      handler(EventNote);
+    }
+  };
+
+  DirWatcher = createFn(UnitPath.str(), OnUnitsChange, waitInitialSync, Error);
+  if (!DirWatcher)
+    return true;
+
+  return false;
+}
+
+void IndexDataStoreImpl::stopEventListening() {
+  DirWatcher.reset();
+}
+
+void IndexDataStoreImpl::discardUnit(StringRef UnitName) {
+  SmallString<128> UnitPath;
+  UnitPath = FilePath;
+  appendUnitSubDir(UnitPath);
+  appendInteriorUnitPath(UnitName, UnitPath);
+  sys::fs::remove(UnitPath);
+}
+
+void IndexDataStoreImpl::discardRecord(StringRef RecordName) {
+  SmallString<128> RecordPath;
+  RecordPath = FilePath;
+  appendRecordSubDir(RecordPath);
+  appendInteriorRecordPath(RecordName, RecordPath);
+  sys::fs::remove(RecordPath);
+}
+
+void IndexDataStoreImpl::purgeStaleData() {
+  // FIXME: Implement.
+}
+
+
+std::unique_ptr<IndexDataStore>
+IndexDataStore::create(StringRef IndexStorePath, std::string &Error) {
+  if (!sys::fs::exists(IndexStorePath)) {
+    raw_string_ostream OS(Error);
+    OS << "index store path does not exist: " << IndexStorePath;
+    return nullptr;
+  }
+
+  return std::unique_ptr<IndexDataStore>(
+    new IndexDataStore(new IndexDataStoreImpl(IndexStorePath)));
+}
+
+#define IMPL static_cast<IndexDataStoreImpl*>(Impl)
+
+IndexDataStore::~IndexDataStore() {
+  delete IMPL;
+}
+
+StringRef IndexDataStore::getFilePath() const {
+  return IMPL->getFilePath();
+}
+
+bool IndexDataStore::foreachUnitName(bool sorted,
+                     llvm::function_ref<bool(StringRef unitName)> receiver) {
+  return IMPL->foreachUnitName(sorted, std::move(receiver));
+}
+
+unsigned IndexDataStore::getFormatVersion() {
+  return STORE_FORMAT_VERSION;
+}
+
+void IndexDataStore::setUnitEventHandler(UnitEventHandler Handler) {
+  return IMPL->setUnitEventHandler(std::move(Handler));
+}
+
+bool IndexDataStore::startEventListening(llvm::function_ref<AbstractDirectoryWatcher::CreateFnTy> createFn,
+                                         bool waitInitialSync, std::string &Error) {
+  return IMPL->startEventListening(std::move(createFn), waitInitialSync, Error);
+}
+
+void IndexDataStore::stopEventListening() {
+  return IMPL->stopEventListening();
+}
+
+void IndexDataStore::discardUnit(StringRef UnitName) {
+  IMPL->discardUnit(UnitName);
+}
+
+void IndexDataStore::discardRecord(StringRef RecordName) {
+  IMPL->discardRecord(RecordName);
+}
+
+void IndexDataStore::purgeStaleData() {
+  IMPL->purgeStaleData();
+}
diff --git a/lib/Index/IndexDataStoreUtils.cpp b/lib/Index/IndexDataStoreUtils.cpp
index e69de29bb2..3efaec95e2 100644
--- a/lib/Index/IndexDataStoreUtils.cpp
+++ b/lib/Index/IndexDataStoreUtils.cpp
@@ -0,0 +1,410 @@
+//===--- IndexDataStoreUtils.cpp - Functions/constants for the data store -===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Index/IndexDataStoreSymbolUtils.h"
+#include "IndexDataStoreUtils.h"
+#include "llvm/Bitcode/BitstreamWriter.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace clang::index::store;
+using namespace llvm;
+
+void store::emitBlockID(unsigned ID, const char *Name,
+                        BitstreamWriter &Stream, RecordDataImpl &Record) {
+  Record.clear();
+  Record.push_back(ID);
+  Stream.EmitRecord(bitc::BLOCKINFO_CODE_SETBID, Record);
+
+  // Emit the block name if present.
+  if (!Name || Name[0] == 0)
+    return;
+  Record.clear();
+  while (*Name)
+    Record.push_back(*Name++);
+  Stream.EmitRecord(bitc::BLOCKINFO_CODE_BLOCKNAME, Record);
+}
+
+void store::emitRecordID(unsigned ID, const char *Name,
+                         BitstreamWriter &Stream,
+                         RecordDataImpl &Record) {
+  Record.clear();
+  Record.push_back(ID);
+  while (*Name)
+    Record.push_back(*Name++);
+  Stream.EmitRecord(bitc::BLOCKINFO_CODE_SETRECORDNAME, Record);
+}
+
+/// Map an indexstore_symbol_kind_t to a SymbolKind, handling unknown values.
+SymbolKind index::getSymbolKind(indexstore_symbol_kind_t K) {
+  switch ((uint64_t)K) {
+  default:
+  case INDEXSTORE_SYMBOL_KIND_UNKNOWN:
+    return SymbolKind::Unknown;
+  case INDEXSTORE_SYMBOL_KIND_MODULE:
+    return SymbolKind::Module;
+  case INDEXSTORE_SYMBOL_KIND_NAMESPACE:
+    return SymbolKind::Namespace;
+  case INDEXSTORE_SYMBOL_KIND_NAMESPACEALIAS:
+    return SymbolKind::NamespaceAlias;
+  case INDEXSTORE_SYMBOL_KIND_MACRO:
+    return SymbolKind::Macro;
+  case INDEXSTORE_SYMBOL_KIND_ENUM:
+    return SymbolKind::Enum;
+  case INDEXSTORE_SYMBOL_KIND_STRUCT:
+    return SymbolKind::Struct;
+  case INDEXSTORE_SYMBOL_KIND_CLASS:
+    return SymbolKind::Class;
+  case INDEXSTORE_SYMBOL_KIND_PROTOCOL:
+    return SymbolKind::Protocol;
+  case INDEXSTORE_SYMBOL_KIND_EXTENSION:
+    return SymbolKind::Extension;
+  case INDEXSTORE_SYMBOL_KIND_UNION:
+    return SymbolKind::Union;
+  case INDEXSTORE_SYMBOL_KIND_TYPEALIAS:
+    return SymbolKind::TypeAlias;
+  case INDEXSTORE_SYMBOL_KIND_FUNCTION:
+    return SymbolKind::Function;
+  case INDEXSTORE_SYMBOL_KIND_VARIABLE:
+    return SymbolKind::Variable;
+  case INDEXSTORE_SYMBOL_KIND_FIELD:
+    return SymbolKind::Field;
+  case INDEXSTORE_SYMBOL_KIND_ENUMCONSTANT:
+    return SymbolKind::EnumConstant;
+  case INDEXSTORE_SYMBOL_KIND_INSTANCEMETHOD:
+    return SymbolKind::InstanceMethod;
+  case INDEXSTORE_SYMBOL_KIND_CLASSMETHOD:
+    return SymbolKind::ClassMethod;
+  case INDEXSTORE_SYMBOL_KIND_STATICMETHOD:
+    return SymbolKind::StaticMethod;
+  case INDEXSTORE_SYMBOL_KIND_INSTANCEPROPERTY:
+    return SymbolKind::InstanceProperty;
+  case INDEXSTORE_SYMBOL_KIND_CLASSPROPERTY:
+    return SymbolKind::ClassProperty;
+  case INDEXSTORE_SYMBOL_KIND_STATICPROPERTY:
+    return SymbolKind::StaticProperty;
+  case INDEXSTORE_SYMBOL_KIND_CONSTRUCTOR:
+    return SymbolKind::Constructor;
+  case INDEXSTORE_SYMBOL_KIND_DESTRUCTOR:
+    return SymbolKind::Destructor;
+  case INDEXSTORE_SYMBOL_KIND_CONVERSIONFUNCTION:
+    return SymbolKind::ConversionFunction;
+  case INDEXSTORE_SYMBOL_KIND_PARAMETER:
+    return SymbolKind::Parameter;
+  case INDEXSTORE_SYMBOL_KIND_USING:
+    return SymbolKind::Using;
+  case INDEXSTORE_SYMBOL_KIND_COMMENTTAG:
+    return SymbolKind::CommentTag;
+  }
+}
+
+SymbolSubKind index::getSymbolSubKind(indexstore_symbol_subkind_t K) {
+  switch ((uint64_t)K) {
+  default:
+  case INDEXSTORE_SYMBOL_SUBKIND_NONE:
+    return SymbolSubKind::None;
+  case INDEXSTORE_SYMBOL_SUBKIND_CXXCOPYCONSTRUCTOR:
+    return SymbolSubKind::CXXCopyConstructor;
+  case INDEXSTORE_SYMBOL_SUBKIND_CXXMOVECONSTRUCTOR:
+    return SymbolSubKind::CXXMoveConstructor;
+  case INDEXSTORE_SYMBOL_SUBKIND_ACCESSORGETTER:
+      return SymbolSubKind::AccessorGetter;
+  case INDEXSTORE_SYMBOL_SUBKIND_ACCESSORSETTER:
+      return SymbolSubKind::AccessorSetter;
+  case INDEXSTORE_SYMBOL_SUBKIND_USINGTYPENAME:
+      return SymbolSubKind::UsingTypename;
+  case INDEXSTORE_SYMBOL_SUBKIND_USINGVALUE:
+      return SymbolSubKind::UsingValue;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORWILLSET:
+    return SymbolSubKind::SwiftAccessorWillSet;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORDIDSET:
+    return SymbolSubKind::SwiftAccessorDidSet;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORADDRESSOR:
+    return SymbolSubKind::SwiftAccessorAddressor;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORMUTABLEADDRESSOR:
+    return SymbolSubKind::SwiftAccessorMutableAddressor;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFSTRUCT:
+    return SymbolSubKind::SwiftExtensionOfStruct;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFCLASS:
+    return SymbolSubKind::SwiftExtensionOfClass;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFENUM:
+    return SymbolSubKind::SwiftExtensionOfEnum;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFPROTOCOL:
+    return SymbolSubKind::SwiftExtensionOfProtocol;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTPREFIXOPERATOR:
+    return SymbolSubKind::SwiftPrefixOperator;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTPOSTFIXOPERATOR:
+    return SymbolSubKind::SwiftPostfixOperator;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTINFIXOPERATOR:
+    return SymbolSubKind::SwiftInfixOperator;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTSUBSCRIPT:
+    return SymbolSubKind::SwiftSubscript;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTASSOCIATEDTYPE:
+    return SymbolSubKind::SwiftAssociatedType;
+  case INDEXSTORE_SYMBOL_SUBKIND_SWIFTGENERICTYPEPARAM:
+    return SymbolSubKind::SwiftGenericTypeParam;
+  }
+}
+
+/// Map an indexstore_symbol_language_t to a SymbolLanguage, handling unknown
+/// values.
+SymbolLanguage index::getSymbolLanguage(indexstore_symbol_language_t L) {
+  switch ((uint64_t)L) {
+  default: // FIXME: add an unknown language?
+  case INDEXSTORE_SYMBOL_LANG_C:
+    return SymbolLanguage::C;
+  case INDEXSTORE_SYMBOL_LANG_OBJC:
+    return SymbolLanguage::ObjC;
+  case INDEXSTORE_SYMBOL_LANG_CXX:
+    return SymbolLanguage::CXX;
+  case INDEXSTORE_SYMBOL_LANG_SWIFT:
+    return SymbolLanguage::Swift;
+  }
+}
+
+/// Map an indexstore representation to a SymbolPropertySet, handling
+/// unknown values.
+SymbolPropertySet index::getSymbolProperties(uint64_t Props) {
+  // FIXME: currently these enums must be kept in sync.
+  return (uint64_t)Props;
+}
+
+/// Map an indexstore representation to a SymbolRoleSet, handling unknown
+/// values.
+SymbolRoleSet index::getSymbolRoles(uint64_t Roles) {
+  // FIXME: currently these enums must be kept in sync.
+  return (uint64_t)Roles;
+}
+
+/// Map a SymbolLanguage to a indexstore_symbol_language_t.
+indexstore_symbol_kind_t index::getIndexStoreKind(SymbolKind K) {
+  switch (K) {
+  case SymbolKind::Unknown:
+    return INDEXSTORE_SYMBOL_KIND_UNKNOWN;
+  case SymbolKind::Module:
+    return INDEXSTORE_SYMBOL_KIND_MODULE;
+  case SymbolKind::Namespace:
+    return INDEXSTORE_SYMBOL_KIND_NAMESPACE;
+  case SymbolKind::NamespaceAlias:
+    return INDEXSTORE_SYMBOL_KIND_NAMESPACEALIAS;
+  case SymbolKind::Macro:
+    return INDEXSTORE_SYMBOL_KIND_MACRO;
+  case SymbolKind::Enum:
+    return INDEXSTORE_SYMBOL_KIND_ENUM;
+  case SymbolKind::Struct:
+    return INDEXSTORE_SYMBOL_KIND_STRUCT;
+  case SymbolKind::Class:
+    return INDEXSTORE_SYMBOL_KIND_CLASS;
+  case SymbolKind::Protocol:
+    return INDEXSTORE_SYMBOL_KIND_PROTOCOL;
+  case SymbolKind::Extension:
+    return INDEXSTORE_SYMBOL_KIND_EXTENSION;
+  case SymbolKind::Union:
+    return INDEXSTORE_SYMBOL_KIND_UNION;
+  case SymbolKind::TypeAlias:
+    return INDEXSTORE_SYMBOL_KIND_TYPEALIAS;
+  case SymbolKind::Function:
+    return INDEXSTORE_SYMBOL_KIND_FUNCTION;
+  case SymbolKind::Variable:
+    return INDEXSTORE_SYMBOL_KIND_VARIABLE;
+  case SymbolKind::Field:
+    return INDEXSTORE_SYMBOL_KIND_FIELD;
+  case SymbolKind::EnumConstant:
+    return INDEXSTORE_SYMBOL_KIND_ENUMCONSTANT;
+  case SymbolKind::InstanceMethod:
+    return INDEXSTORE_SYMBOL_KIND_INSTANCEMETHOD;
+  case SymbolKind::ClassMethod:
+    return INDEXSTORE_SYMBOL_KIND_CLASSMETHOD;
+  case SymbolKind::StaticMethod:
+    return INDEXSTORE_SYMBOL_KIND_STATICMETHOD;
+  case SymbolKind::InstanceProperty:
+    return INDEXSTORE_SYMBOL_KIND_INSTANCEPROPERTY;
+  case SymbolKind::ClassProperty:
+    return INDEXSTORE_SYMBOL_KIND_CLASSPROPERTY;
+  case SymbolKind::StaticProperty:
+    return INDEXSTORE_SYMBOL_KIND_STATICPROPERTY;
+  case SymbolKind::Constructor:
+    return INDEXSTORE_SYMBOL_KIND_CONSTRUCTOR;
+  case SymbolKind::Destructor:
+    return INDEXSTORE_SYMBOL_KIND_DESTRUCTOR;
+  case SymbolKind::ConversionFunction:
+    return INDEXSTORE_SYMBOL_KIND_CONVERSIONFUNCTION;
+  case SymbolKind::Parameter:
+    return INDEXSTORE_SYMBOL_KIND_PARAMETER;
+  case SymbolKind::Using:
+    return INDEXSTORE_SYMBOL_KIND_USING;
+  case SymbolKind::CommentTag:
+    return INDEXSTORE_SYMBOL_KIND_COMMENTTAG;
+  }
+  llvm_unreachable("unexpected symbol kind");
+}
+
+indexstore_symbol_subkind_t index::getIndexStoreSubKind(SymbolSubKind K) {
+  switch (K) {
+  case SymbolSubKind::None:
+    return INDEXSTORE_SYMBOL_SUBKIND_NONE;
+  case SymbolSubKind::CXXCopyConstructor:
+    return INDEXSTORE_SYMBOL_SUBKIND_CXXCOPYCONSTRUCTOR;
+  case SymbolSubKind::CXXMoveConstructor:
+    return INDEXSTORE_SYMBOL_SUBKIND_CXXMOVECONSTRUCTOR;
+  case SymbolSubKind::AccessorGetter:
+    return INDEXSTORE_SYMBOL_SUBKIND_ACCESSORGETTER;
+  case SymbolSubKind::AccessorSetter:
+    return INDEXSTORE_SYMBOL_SUBKIND_ACCESSORSETTER;
+  case SymbolSubKind::UsingTypename:
+    return INDEXSTORE_SYMBOL_SUBKIND_USINGTYPENAME;
+  case SymbolSubKind::UsingValue:
+    return INDEXSTORE_SYMBOL_SUBKIND_USINGVALUE;
+  case SymbolSubKind::SwiftAccessorWillSet:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORWILLSET;
+  case SymbolSubKind::SwiftAccessorDidSet:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORDIDSET;
+  case SymbolSubKind::SwiftAccessorAddressor:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORADDRESSOR;
+  case SymbolSubKind::SwiftAccessorMutableAddressor:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTACCESSORMUTABLEADDRESSOR;
+  case SymbolSubKind::SwiftExtensionOfStruct:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFSTRUCT;
+  case SymbolSubKind::SwiftExtensionOfClass:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFCLASS;
+  case SymbolSubKind::SwiftExtensionOfEnum:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFENUM;
+  case SymbolSubKind::SwiftExtensionOfProtocol:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTEXTENSIONOFPROTOCOL;
+  case SymbolSubKind::SwiftPrefixOperator:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTPREFIXOPERATOR;
+  case SymbolSubKind::SwiftPostfixOperator:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTPOSTFIXOPERATOR;
+  case SymbolSubKind::SwiftInfixOperator:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTINFIXOPERATOR;
+  case SymbolSubKind::SwiftSubscript:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTSUBSCRIPT;
+  case SymbolSubKind::SwiftAssociatedType:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTASSOCIATEDTYPE;
+  case SymbolSubKind::SwiftGenericTypeParam:
+    return INDEXSTORE_SYMBOL_SUBKIND_SWIFTGENERICTYPEPARAM;
+  }
+  llvm_unreachable("unexpected symbol subkind");
+}
+
+/// Map a SymbolLanguage to a indexstore_symbol_language_t.
+indexstore_symbol_language_t index::getIndexStoreLang(SymbolLanguage L) {
+  switch (L) {
+  case SymbolLanguage::C:
+    return INDEXSTORE_SYMBOL_LANG_C;
+  case SymbolLanguage::ObjC:
+    return INDEXSTORE_SYMBOL_LANG_OBJC;
+  case SymbolLanguage::CXX:
+    return INDEXSTORE_SYMBOL_LANG_CXX;
+  case SymbolLanguage::Swift:
+    return INDEXSTORE_SYMBOL_LANG_SWIFT;
+  }
+  llvm_unreachable("unexpected symbol language");
+}
+
+/// Map a SymbolPropertySet to its indexstore representation.
+uint64_t index::getIndexStoreProperties(SymbolPropertySet Props) {
+  uint64_t storeProp = 0;
+  applyForEachSymbolProperty(Props, [&](SymbolProperty prop) {
+    switch (prop) {
+    case SymbolProperty::Generic:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_GENERIC;
+      break;
+    case SymbolProperty::TemplatePartialSpecialization:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_TEMPLATE_PARTIAL_SPECIALIZATION;
+      break;
+    case SymbolProperty::TemplateSpecialization:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_TEMPLATE_SPECIALIZATION;
+      break;
+    case SymbolProperty::UnitTest:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_UNITTEST;
+      break;
+    case SymbolProperty::IBAnnotated:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_IBANNOTATED;
+      break;
+    case SymbolProperty::IBOutletCollection:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_IBOUTLETCOLLECTION;
+      break;
+    case SymbolProperty::GKInspectable:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_GKINSPECTABLE;
+      break;
+    case SymbolProperty::Local:
+      storeProp |= INDEXSTORE_SYMBOL_PROPERTY_LOCAL;
+      break;
+    }
+  });
+  return storeProp;
+}
+
+/// Map a SymbolRoleSet to its indexstore representation.
+uint64_t index::getIndexStoreRoles(SymbolRoleSet Roles) {
+  uint64_t storeRoles = 0;
+  applyForEachSymbolRole(Roles, [&](SymbolRole role) {
+    switch (role) {
+    case SymbolRole::Declaration:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_DECLARATION;
+      break;
+    case SymbolRole::Definition:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_DEFINITION;
+      break;
+    case SymbolRole::Reference:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REFERENCE;
+      break;
+    case SymbolRole::Read:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_READ;
+      break;
+    case SymbolRole::Write:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_WRITE;
+      break;
+    case SymbolRole::Call:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_CALL;
+      break;
+    case SymbolRole::Dynamic:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_DYNAMIC;
+      break;
+    case SymbolRole::AddressOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_ADDRESSOF;
+      break;
+    case SymbolRole::Implicit:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_IMPLICIT;
+      break;
+    case SymbolRole::RelationChildOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_CHILDOF;
+      break;
+    case SymbolRole::RelationBaseOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_BASEOF;
+      break;
+    case SymbolRole::RelationOverrideOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_OVERRIDEOF;
+      break;
+    case SymbolRole::RelationReceivedBy:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_RECEIVEDBY;
+      break;
+    case SymbolRole::RelationCalledBy:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_CALLEDBY;
+      break;
+    case SymbolRole::RelationExtendedBy:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_EXTENDEDBY;
+      break;
+    case SymbolRole::RelationAccessorOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_ACCESSOROF;
+      break;
+    case SymbolRole::RelationContainedBy:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_CONTAINEDBY;
+      break;
+    case SymbolRole::RelationIBTypeOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_IBTYPEOF;
+      break;
+    case SymbolRole::RelationSpecializationOf:
+      storeRoles |= INDEXSTORE_SYMBOL_ROLE_REL_SPECIALIZATIONOF;
+      break;
+    }
+  });
+  return storeRoles;
+}
diff --git a/lib/Index/IndexDataStoreUtils.h b/lib/Index/IndexDataStoreUtils.h
index e69de29bb2..ad310e1916 100644
--- a/lib/Index/IndexDataStoreUtils.h
+++ b/lib/Index/IndexDataStoreUtils.h
@@ -0,0 +1,116 @@
+//===--- IndexDataStoreUtils.h - Functions/constants for the data store ---===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_INDEX_INDEXDATASTOREUTILS_H
+#define LLVM_CLANG_LIB_INDEX_INDEXDATASTOREUTILS_H
+
+#include "llvm/Bitcode/BitCodes.h"
+#include "clang/Basic/LLVM.h"
+
+namespace llvm {
+  class BitstreamWriter;
+}
+
+namespace clang {
+namespace index {
+namespace store {
+
+static const unsigned STORE_FORMAT_VERSION = 5;
+
+void appendUnitSubDir(SmallVectorImpl<char> &StorePathBuf);
+void appendInteriorUnitPath(StringRef UnitName,
+                            SmallVectorImpl<char> &PathBuf);
+void appendRecordSubDir(SmallVectorImpl<char> &StorePathBuf);
+void appendInteriorRecordPath(StringRef RecordName,
+                              SmallVectorImpl<char> &PathBuf);
+
+enum RecordBitRecord {
+  REC_VERSION         = 0,
+  REC_DECLINFO        = 1,
+  REC_DECLOFFSETS     = 2,
+  REC_DECLOCCURRENCE  = 3,
+};
+
+enum RecordBitBlock {
+  REC_VERSION_BLOCK_ID = llvm::bitc::FIRST_APPLICATION_BLOCKID,
+  REC_DECLS_BLOCK_ID,
+  REC_DECLOFFSETS_BLOCK_ID,
+  REC_DECLOCCURRENCES_BLOCK_ID,
+};
+
+enum UnitBitRecord {
+  UNIT_VERSION        = 0,
+  UNIT_INFO           = 1,
+  UNIT_DEPENDENCY     = 2,
+  UNIT_INCLUDE        = 3,
+  UNIT_PATH           = 4,
+  UNIT_PATH_BUFFER    = 5,
+  UNIT_MODULE         = 6,
+  UNIT_MODULE_BUFFER  = 7,
+};
+
+enum UnitBitBlock {
+  UNIT_VERSION_BLOCK_ID = llvm::bitc::FIRST_APPLICATION_BLOCKID,
+  UNIT_INFO_BLOCK_ID,
+  UNIT_DEPENDENCIES_BLOCK_ID,
+  UNIT_INCLUDES_BLOCK_ID,
+  UNIT_PATHS_BLOCK_ID,
+  UNIT_MODULES_BLOCK_ID,
+};
+
+enum UnitDependencyKind {
+  UNIT_DEPEND_KIND_FILE = 0,
+  UNIT_DEPEND_KIND_RECORD = 1,
+  UNIT_DEPEND_KIND_UNIT = 2,
+};
+static const unsigned UnitDependencyKindBitNum = 2;
+
+enum UnitFilePathPrefixKind {
+  UNIT_PATH_PREFIX_NONE = 0,
+  UNIT_PATH_PREFIX_WORKDIR = 1,
+  UNIT_PATH_PREFIX_SYSROOT = 2,
+};
+static const unsigned UnitFilePathPrefixKindBitNum = 2;
+
+typedef SmallVector<uint64_t, 64> RecordData;
+typedef SmallVectorImpl<uint64_t> RecordDataImpl;
+
+struct BitPathComponent {
+  size_t Offset = 0;
+  size_t Size = 0;
+  BitPathComponent(size_t Offset, size_t Size) : Offset(Offset), Size(Size) {}
+  BitPathComponent() = default;
+};
+
+struct DirBitPath {
+  UnitFilePathPrefixKind PrefixKind = UNIT_PATH_PREFIX_NONE;
+  BitPathComponent Dir;
+  DirBitPath(UnitFilePathPrefixKind Kind,
+             BitPathComponent Dir) : PrefixKind(Kind), Dir(Dir) {}
+  DirBitPath() = default;
+};
+
+struct FileBitPath : DirBitPath {
+  BitPathComponent Filename;
+  FileBitPath(UnitFilePathPrefixKind Kind, BitPathComponent Dir,
+              BitPathComponent Filename) : DirBitPath(Kind, Dir), Filename(Filename) {}
+  FileBitPath() = default;
+};
+
+void emitBlockID(unsigned ID, const char *Name,
+                 llvm::BitstreamWriter &Stream, RecordDataImpl &Record);
+
+void emitRecordID(unsigned ID, const char *Name,
+                  llvm::BitstreamWriter &Stream, RecordDataImpl &Record);
+
+} // end namespace store
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/lib/Index/IndexRecordHasher.cpp b/lib/Index/IndexRecordHasher.cpp
index e69de29bb2..1edf4c151c 100644
--- a/lib/Index/IndexRecordHasher.cpp
+++ b/lib/Index/IndexRecordHasher.cpp
@@ -0,0 +1,480 @@
+//===--- IndexRecordHasher.cpp - Index record hashing ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "IndexRecordHasher.h"
+#include "FileIndexRecord.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/DeclVisitor.h"
+#include "llvm/Support/Path.h"
+
+#define INITIAL_HASH 5381
+#define COMBINE_HASH(...) (Hash = hash_combine(Hash, __VA_ARGS__))
+
+using namespace clang;
+using namespace clang::index;
+using namespace llvm;
+
+static hash_code computeHash(const TemplateArgument &Arg,
+                             IndexRecordHasher &Hasher);
+
+namespace {
+class DeclHashVisitor : public ConstDeclVisitor<DeclHashVisitor, hash_code> {
+  IndexRecordHasher &Hasher;
+
+public:
+  DeclHashVisitor(IndexRecordHasher &Hasher) : Hasher(Hasher) {}
+
+  hash_code VisitDecl(const Decl *D) {
+    return VisitDeclContext(D->getDeclContext());
+  }
+
+  hash_code VisitNamedDecl(const NamedDecl *D) {
+    hash_code Hash = VisitDecl(D);
+    if (auto *attr = D->getExternalSourceSymbolAttr()) {
+      COMBINE_HASH(hash_value(attr->getDefinedIn()));
+    }
+    return COMBINE_HASH(Hasher.hash(D->getDeclName()));
+  }
+
+  hash_code VisitTagDecl(const TagDecl *D) {
+    if (D->getDeclName().isEmpty()) {
+      if (const TypedefNameDecl *TD = D->getTypedefNameForAnonDecl())
+        return Visit(TD);
+
+      hash_code Hash = VisitDeclContext(D->getDeclContext());
+      if (D->isEmbeddedInDeclarator() && !D->isFreeStanding()) {
+        COMBINE_HASH(hashLoc(D->getLocation(), /*IncludeOffset=*/true));
+      } else
+        COMBINE_HASH('a');
+      return Hash;
+    }
+
+    hash_code Hash = VisitTypeDecl(D);
+    return COMBINE_HASH('T');
+  }
+
+  hash_code VisitClassTemplateSpecializationDecl(const ClassTemplateSpecializationDecl *D) {
+    hash_code Hash = VisitCXXRecordDecl(D);
+    const TemplateArgumentList &Args = D->getTemplateArgs();
+    COMBINE_HASH('>');
+    for (unsigned I = 0, N = Args.size(); I != N; ++I) {
+      COMBINE_HASH(computeHash(Args.get(I), Hasher));
+    }
+    return Hash;
+  }
+
+  hash_code VisitObjCContainerDecl(const ObjCContainerDecl *D) {
+    hash_code Hash = VisitNamedDecl(D);
+    return COMBINE_HASH('I');
+  }
+
+  hash_code VisitObjCImplDecl(const ObjCImplDecl *D) {
+    if (auto *ID = D->getClassInterface())
+      return VisitObjCInterfaceDecl(ID);
+    else
+      return 0;
+  }
+
+  hash_code VisitObjCCategoryDecl(const ObjCCategoryDecl *D) {
+    // FIXME: Differentiate between category and the interface ?
+    if (auto *ID = D->getClassInterface())
+      return VisitObjCInterfaceDecl(ID);
+    else
+      return 0;
+  }
+
+  hash_code VisitFunctionDecl(const FunctionDecl *D) {
+    hash_code Hash = VisitNamedDecl(D);
+    ASTContext &Ctx = Hasher.getASTContext();
+    if ((!Ctx.getLangOpts().CPlusPlus && !D->hasAttr<OverloadableAttr>())
+        || D->isExternC())
+      return Hash;
+
+    for (auto param : D->parameters()) {
+      COMBINE_HASH(Hasher.hash(param->getType()));
+    }
+    return Hash;
+  }
+
+  hash_code VisitUnresolvedUsingTypenameDecl(const UnresolvedUsingTypenameDecl *D) {
+    hash_code Hash = VisitNamedDecl(D);
+    COMBINE_HASH(Hasher.hash(D->getQualifier()));
+    return Hash;
+  }
+
+  hash_code VisitUnresolvedUsingValueDecl(const UnresolvedUsingValueDecl *D) {
+    hash_code Hash = VisitNamedDecl(D);
+    COMBINE_HASH(Hasher.hash(D->getQualifier()));
+    return Hash;
+  }
+
+  hash_code VisitDeclContext(const DeclContext *DC) {
+    // FIXME: Add location if this is anonymous namespace ?
+    DC = DC->getRedeclContext();
+    const Decl *D = cast<Decl>(DC)->getCanonicalDecl();
+    if (auto *ND = dyn_cast<NamedDecl>(D))
+      return Hasher.hash(ND);
+    else
+      return 0;
+  }
+
+  hash_code hashLoc(SourceLocation Loc, bool IncludeOffset) {
+    if (Loc.isInvalid()) {
+      return 0;
+    }
+    hash_code Hash = INITIAL_HASH;
+    const SourceManager &SM = Hasher.getASTContext().getSourceManager();
+    Loc = SM.getFileLoc(Loc);
+    const std::pair<FileID, unsigned> &Decomposed = SM.getDecomposedLoc(Loc);
+    const FileEntry *FE = SM.getFileEntryForID(Decomposed.first);
+    if (FE) {
+      COMBINE_HASH(llvm::sys::path::filename(FE->getName()));
+    } else {
+      // This case really isn't interesting.
+      return 0;
+    }
+    if (IncludeOffset) {
+      // Use the offest into the FileID to represent the location.  Using
+      // a line/column can cause us to look back at the original source file,
+      // which is expensive.
+      COMBINE_HASH(Decomposed.second);
+    }
+    return Hash;
+  }
+};
+}
+
+hash_code IndexRecordHasher::hashRecord(const FileIndexRecord &Record) {
+  hash_code Hash = INITIAL_HASH;
+  for (auto &Info : Record.getDeclOccurrences()) {
+    COMBINE_HASH(Info.Roles, Info.Offset, hash(Info.Dcl));
+    for (auto &Rel : Info.Relations) {
+      COMBINE_HASH(hash(Rel.RelatedSymbol));
+    }
+  }
+  return Hash;
+}
+
+hash_code IndexRecordHasher::hash(const Decl *D) {
+  assert(D->isCanonicalDecl());
+
+  if (isa<TagDecl>(D) || isa<ObjCContainerDecl>(D)) {
+    return tryCache(D, D);
+  } else  if (auto *NS = dyn_cast<NamespaceDecl>(D)) {
+    if (NS->isAnonymousNamespace())
+      return hash_value(StringRef("@aN"));
+    return tryCache(D, D);
+  } else {
+    // There's a balance between caching results and not growing the cache too
+    // much. Measurements showed that avoiding caching all decls is beneficial
+    // particularly when including all of Cocoa.
+    return hashImpl(D);
+  }
+}
+
+hash_code IndexRecordHasher::hash(QualType NonCanTy) {
+  CanQualType CanTy = Ctx.getCanonicalType(NonCanTy);
+  return hash(CanTy);
+}
+
+hash_code IndexRecordHasher::hash(CanQualType CT) {
+  // Do some hashing without going to the cache, for example we can avoid
+  // storing the hash for both the type and its const-qualified version.
+  hash_code Hash = INITIAL_HASH;
+
+  auto asCanon = [](QualType Ty) -> CanQualType {
+    return CanQualType::CreateUnsafe(Ty);
+  };
+
+  while (true) {
+    Qualifiers Q = CT.getQualifiers();
+    CT = CT.getUnqualifiedType();
+    const Type *T = CT.getTypePtr();
+    unsigned qVal = 0;
+    if (Q.hasConst())
+      qVal |= 0x1;
+    if (Q.hasVolatile())
+      qVal |= 0x2;
+    if (Q.hasRestrict())
+      qVal |= 0x4;
+    if(qVal)
+      COMBINE_HASH(qVal);
+
+    // Hash in ObjC GC qualifiers?
+
+    if (const BuiltinType *BT = dyn_cast<BuiltinType>(T)) {
+      return COMBINE_HASH(BT->getKind());
+    }
+    if (const PointerType *PT = dyn_cast<PointerType>(T)) {
+      COMBINE_HASH('*');
+      CT = asCanon(PT->getPointeeType());
+      continue;
+    }
+    if (const ReferenceType *RT = dyn_cast<ReferenceType>(T)) {
+      COMBINE_HASH('&');
+      CT = asCanon(RT->getPointeeType());
+      continue;
+    }
+    if (const BlockPointerType *BT = dyn_cast<BlockPointerType>(T)) {
+      COMBINE_HASH('B');
+      CT = asCanon(BT->getPointeeType());
+      continue;
+    }
+    if (const ObjCObjectPointerType *OPT = dyn_cast<ObjCObjectPointerType>(T)) {
+      COMBINE_HASH('*');
+      CT = asCanon(OPT->getPointeeType());
+      continue;
+    }
+    if (const TagType *TT = dyn_cast<TagType>(T)) {
+      return COMBINE_HASH('$', hash(TT->getDecl()->getCanonicalDecl()));
+    }
+    if (const ObjCInterfaceType *OIT = dyn_cast<ObjCInterfaceType>(T)) {
+      return COMBINE_HASH('$', hash(OIT->getDecl()->getCanonicalDecl()));
+    }
+    if (const ObjCObjectType *OIT = dyn_cast<ObjCObjectType>(T)) {
+      for (auto *Prot : OIT->getProtocols())
+        COMBINE_HASH(hash(Prot));
+      CT = asCanon(OIT->getBaseType());
+      continue;
+    }
+    if (const TemplateTypeParmType *TTP = dyn_cast<TemplateTypeParmType>(T)) {
+      return COMBINE_HASH('t', TTP->getDepth(), TTP->getIndex());
+    }
+    if (const InjectedClassNameType *InjT = dyn_cast<InjectedClassNameType>(T)) {
+      CT = asCanon(InjT->getInjectedSpecializationType().getCanonicalType());
+      continue;
+    }
+
+    break;
+  }
+
+  return COMBINE_HASH(tryCache(CT.getAsOpaquePtr(), CT));
+}
+
+hash_code IndexRecordHasher::hash(DeclarationName Name) {
+  assert(!Name.isEmpty());
+  // Measurements for using cache or not here, showed significant slowdown when
+  // using the cache for all DeclarationNames when parsing Cocoa, and minor
+  // improvement or no difference for a couple of C++ single translation unit
+  // files. So we avoid caching DeclarationNames.
+  return hashImpl(Name);
+}
+
+hash_code IndexRecordHasher::hash(const NestedNameSpecifier *NNS) {
+  assert(NNS);
+  // Measurements for the C++ single translation unit files did not show much
+  // difference here; choosing to cache them currently.
+  return tryCache(NNS, NNS);
+}
+
+template <typename T>
+hash_code IndexRecordHasher::tryCache(const void *Ptr, T Obj) {
+  auto It = HashByPtr.find(Ptr);
+  if (It != HashByPtr.end())
+    return It->second;
+
+  hash_code Hash = hashImpl(Obj);
+  // hashImpl() may call into tryCache recursively and mutate
+  // HashByPtr, so we use find() earlier and insert the hash with another
+  // lookup here instead of calling insert() earlier and utilizing the iterator
+  // that insert() returns.
+  HashByPtr[Ptr] = Hash;
+  return Hash;
+}
+
+hash_code IndexRecordHasher::hashImpl(const Decl *D) {
+  return DeclHashVisitor(*this).Visit(D);
+}
+
+static hash_code computeHash(const IdentifierInfo *II) {
+  return hash_value(II->getName());
+}
+
+static hash_code computeHash(Selector Sel) {
+  unsigned N = Sel.getNumArgs();
+  if (N == 0)
+    ++N;
+  hash_code Hash = INITIAL_HASH;
+  for (unsigned I = 0; I != N; ++I)
+    if (IdentifierInfo *II = Sel.getIdentifierInfoForSlot(I))
+      COMBINE_HASH(computeHash(II));
+  return Hash;
+}
+
+static hash_code computeHash(TemplateName Name, IndexRecordHasher &Hasher) {
+  hash_code Hash = INITIAL_HASH;
+  if (TemplateDecl *Template = Name.getAsTemplateDecl()) {
+    if (TemplateTemplateParmDecl *TTP
+        = dyn_cast<TemplateTemplateParmDecl>(Template)) {
+      return COMBINE_HASH('t', TTP->getDepth(), TTP->getIndex());
+    }
+
+    return COMBINE_HASH(Hasher.hash(Template->getCanonicalDecl()));
+  }
+
+  // FIXME: Hash dependent template names.
+  return Hash;
+}
+
+static hash_code computeHash(const TemplateArgument &Arg,
+                             IndexRecordHasher &Hasher) {
+  hash_code Hash = INITIAL_HASH;
+
+  switch (Arg.getKind()) {
+  case TemplateArgument::Null:
+    break;
+
+  case TemplateArgument::Declaration:
+    COMBINE_HASH(Hasher.hash(Arg.getAsDecl()));
+    break;
+
+  case TemplateArgument::NullPtr:
+    break;
+
+  case TemplateArgument::TemplateExpansion:
+    COMBINE_HASH('P'); // pack expansion of...
+    // Fall through
+  case TemplateArgument::Template:
+    COMBINE_HASH(computeHash(Arg.getAsTemplateOrTemplatePattern(), Hasher));
+    break;
+      
+  case TemplateArgument::Expression:
+    // FIXME: Hash expressions.
+    break;
+      
+  case TemplateArgument::Pack:
+    COMBINE_HASH('p');
+    for (const auto &P : Arg.pack_elements())
+      COMBINE_HASH(computeHash(P, Hasher));
+    break;
+      
+  case TemplateArgument::Type:
+    COMBINE_HASH(Hasher.hash(Arg.getAsType()));
+    break;
+      
+  case TemplateArgument::Integral:
+    COMBINE_HASH('V', Hasher.hash(Arg.getIntegralType()), Arg.getAsIntegral());
+    break;
+  }
+
+  return Hash;
+}
+
+hash_code IndexRecordHasher::hashImpl(CanQualType CQT) {
+  hash_code Hash = INITIAL_HASH;
+
+  auto asCanon = [](QualType Ty) -> CanQualType {
+    return CanQualType::CreateUnsafe(Ty);
+  };
+
+  const Type *T = CQT.getTypePtr();
+
+  if (const PackExpansionType *Expansion = dyn_cast<PackExpansionType>(T)) {
+    return COMBINE_HASH('P', hash(asCanon(Expansion->getPattern())));
+  }
+  if (const RValueReferenceType *RT = dyn_cast<RValueReferenceType>(T)) {
+    return COMBINE_HASH('%', hash(asCanon(RT->getPointeeType())));
+  }
+  if (const FunctionProtoType *FT = dyn_cast<FunctionProtoType>(T)) {
+    COMBINE_HASH('F', hash(asCanon(FT->getReturnType())));
+    for (const auto &I : FT->param_types())
+      COMBINE_HASH(hash(asCanon(I)));
+    return COMBINE_HASH(FT->isVariadic());
+  }
+  if (const ComplexType *CT = dyn_cast<ComplexType>(T)) {
+    return COMBINE_HASH('<', hash(asCanon(CT->getElementType())));
+  }
+  if (const TemplateSpecializationType *Spec
+      = dyn_cast<TemplateSpecializationType>(T)) {
+    COMBINE_HASH('>', computeHash(Spec->getTemplateName(), *this));
+    for (unsigned I = 0, N = Spec->getNumArgs(); I != N; ++I)
+      COMBINE_HASH(computeHash(Spec->getArg(I), *this));
+    return Hash;
+  }
+  if (const DependentNameType *DNT = dyn_cast<DependentNameType>(T)) {
+    COMBINE_HASH('^');
+    if (const NestedNameSpecifier *NNS = DNT->getQualifier())
+      COMBINE_HASH(hash(NNS));
+    return COMBINE_HASH(computeHash(DNT->getIdentifier()));
+  }
+
+  // Unhandled type.
+  return Hash;
+}
+
+hash_code IndexRecordHasher::hashImpl(DeclarationName Name) {
+  hash_code Hash = INITIAL_HASH;
+  COMBINE_HASH(Name.getNameKind());
+
+  switch (Name.getNameKind()) {
+    case DeclarationName::Identifier:
+      COMBINE_HASH(computeHash(Name.getAsIdentifierInfo()));
+      break;
+    case DeclarationName::ObjCZeroArgSelector:
+    case DeclarationName::ObjCOneArgSelector:
+    case DeclarationName::ObjCMultiArgSelector:
+      COMBINE_HASH(computeHash(Name.getObjCSelector()));
+      break;
+    case DeclarationName::CXXConstructorName:
+    case DeclarationName::CXXDestructorName:
+    case DeclarationName::CXXConversionFunctionName:
+      break;
+    case DeclarationName::CXXOperatorName:
+      COMBINE_HASH(Name.getCXXOverloadedOperator());
+      break;
+    case DeclarationName::CXXLiteralOperatorName:
+      COMBINE_HASH(computeHash(Name.getCXXLiteralIdentifier()));
+    case DeclarationName::CXXUsingDirective:
+      break;
+    case DeclarationName::CXXDeductionGuideName:
+      COMBINE_HASH(computeHash(Name.getCXXDeductionGuideTemplate()
+                 ->getDeclName().getAsIdentifierInfo()));
+      break;
+  }
+
+  return Hash;
+}
+
+hash_code IndexRecordHasher::hashImpl(const NestedNameSpecifier *NNS) {
+  hash_code Hash = INITIAL_HASH;
+  if (auto *Pre = NNS->getPrefix())
+    COMBINE_HASH(hash(Pre));
+
+  COMBINE_HASH(NNS->getKind());
+
+  switch (NNS->getKind()) {
+  case NestedNameSpecifier::Identifier:
+    COMBINE_HASH(computeHash(NNS->getAsIdentifier()));
+    break;
+
+  case NestedNameSpecifier::Namespace:
+    COMBINE_HASH(hash(NNS->getAsNamespace()->getCanonicalDecl()));
+    break;
+
+  case NestedNameSpecifier::NamespaceAlias:
+    COMBINE_HASH(hash(NNS->getAsNamespaceAlias()->getCanonicalDecl()));
+    break;
+
+  case NestedNameSpecifier::Global:
+    break;
+
+  case NestedNameSpecifier::Super:
+    break;
+
+  case NestedNameSpecifier::TypeSpecWithTemplate:
+    // Fall through to hash the type.
+
+  case NestedNameSpecifier::TypeSpec:
+    COMBINE_HASH(hash(QualType(NNS->getAsType(), 0)));
+    break;
+  }
+
+  return Hash;
+}
diff --git a/lib/Index/IndexRecordHasher.h b/lib/Index/IndexRecordHasher.h
index e69de29bb2..af3acccff5 100644
--- a/lib/Index/IndexRecordHasher.h
+++ b/lib/Index/IndexRecordHasher.h
@@ -0,0 +1,58 @@
+//===--- IndexRecordHasher.h - Index record hashing -----------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_INDEX_INDEXRECORDHASHER_H
+#define LLVM_CLANG_LIB_INDEX_INDEXRECORDHASHER_H
+
+#include "clang/Basic/LLVM.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/Hashing.h"
+
+namespace clang {
+  class ASTContext;
+  class Decl;
+  class DeclarationName;
+  class NestedNameSpecifier;
+  class QualType;
+  class Type;
+  template <typename> class CanQual;
+  typedef CanQual<Type> CanQualType;
+
+namespace index {
+  class FileIndexRecord;
+
+class IndexRecordHasher {
+  ASTContext &Ctx;
+  llvm::DenseMap<const void *, llvm::hash_code> HashByPtr;
+
+public:
+  explicit IndexRecordHasher(ASTContext &Ctx) : Ctx(Ctx) {}
+  ASTContext &getASTContext() { return Ctx; }
+
+  llvm::hash_code hashRecord(const FileIndexRecord &Record);
+  llvm::hash_code hash(const Decl *D);
+  llvm::hash_code hash(QualType Ty);
+  llvm::hash_code hash(CanQualType Ty);
+  llvm::hash_code hash(DeclarationName Name);
+  llvm::hash_code hash(const NestedNameSpecifier *NNS);
+
+private:
+  template <typename T>
+  llvm::hash_code tryCache(const void *Ptr, T Obj);
+
+  llvm::hash_code hashImpl(const Decl *D);
+  llvm::hash_code hashImpl(CanQualType Ty);
+  llvm::hash_code hashImpl(DeclarationName Name);
+  llvm::hash_code hashImpl(const NestedNameSpecifier *NNS);
+};
+
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/lib/Index/IndexRecordReader.cpp b/lib/Index/IndexRecordReader.cpp
index e69de29bb2..c657d07bea 100644
--- a/lib/Index/IndexRecordReader.cpp
+++ b/lib/Index/IndexRecordReader.cpp
@@ -0,0 +1,408 @@
+//===--- IndexRecordReader.cpp - Index record deserialization -------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Index/IndexRecordReader.h"
+#include "IndexDataStoreUtils.h"
+#include "BitstreamVisitor.h"
+#include "clang/Index/IndexDataStoreSymbolUtils.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/Bitcode/BitstreamReader.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace clang::index::store;
+using namespace llvm;
+
+struct IndexRecordReader::Implementation {
+  BumpPtrAllocator Allocator;
+  std::unique_ptr<MemoryBuffer> Buffer;
+  llvm::BitstreamCursor DeclCursor;
+  llvm::BitstreamCursor OccurCursor;
+  ArrayRef<uint32_t> DeclOffsets;
+  const IndexRecordDecl **Decls;
+
+  void setDeclOffsets(ArrayRef<uint32_t> Offs) {
+    DeclOffsets = Offs;
+    Decls = Allocator.Allocate<const IndexRecordDecl*>(Offs.size());
+    memset(Decls, 0, sizeof(IndexRecordDecl*)*Offs.size());
+  }
+
+  unsigned getNumDecls() const { return DeclOffsets.size(); }
+
+  const IndexRecordDecl *getDeclByID(unsigned DeclID) {
+    if (DeclID == 0)
+      return nullptr;
+    return getDecl(DeclID-1);
+  }
+
+  const IndexRecordDecl *getDecl(unsigned Index) {
+    assert(Index < getNumDecls());
+    if (const IndexRecordDecl *D = Decls[Index])
+      return D;
+
+    IndexRecordDecl *D = Allocator.Allocate<IndexRecordDecl>();
+    readDecl(Index, *D);
+    Decls[Index] = D;
+    return D;
+  }
+
+  /// Goes through the decls and populates a vector of record decls, based on
+  /// what the given function returns.
+  ///
+  /// The advantage of this function is to allocate memory only for the record
+  /// decls that the caller is interested in.
+  bool searchDecls(llvm::function_ref<DeclSearchCheck> Checker,
+                   llvm::function_ref<void(const IndexRecordDecl *)> Receiver) {
+    for (unsigned I = 0, E = getNumDecls(); I != E; ++I) {
+      if (const IndexRecordDecl *D = Decls[I]) {
+        DeclSearchReturn Ret = Checker(*D);
+        if (Ret.AcceptDecl)
+          Receiver(D);
+        if (!Ret.ContinueSearch)
+          return false;
+        continue;
+      }
+
+      IndexRecordDecl LocalD;
+      readDecl(I, LocalD);
+      DeclSearchReturn Ret = Checker(LocalD);
+      if (Ret.AcceptDecl) {
+        IndexRecordDecl *D = Allocator.Allocate<IndexRecordDecl>();
+        *D = LocalD;
+        Decls[I] = D;
+        Receiver(D);
+      }
+      if (!Ret.ContinueSearch)
+        return false;
+    }
+    return true;
+  }
+
+  void readDecl(unsigned Index, IndexRecordDecl &RecD) {
+    RecordData Record;
+    StringRef Blob;
+    DeclCursor.JumpToBit(DeclOffsets[Index]);
+    unsigned Code = DeclCursor.ReadCode();
+    unsigned RecID = DeclCursor.readRecord(Code, Record, &Blob);
+    assert(RecID == REC_DECLINFO);
+    (void)RecID;
+
+    unsigned I = 0;
+    RecD.DeclID = Index+1;
+    RecD.SymInfo.Kind = getSymbolKind((indexstore_symbol_kind_t)read(Record, I));
+    RecD.SymInfo.SubKind = getSymbolSubKind((indexstore_symbol_subkind_t)read(Record, I));
+    RecD.SymInfo.Lang =
+        getSymbolLanguage((indexstore_symbol_language_t)read(Record, I));
+    RecD.SymInfo.Properties = getSymbolProperties(read(Record, I));
+    RecD.Roles = getSymbolRoles(read(Record, I));
+    RecD.RelatedRoles = getSymbolRoles(read(Record, I));
+    size_t NameLen = read(Record, I);
+    size_t USRLen = read(Record, I);
+    RecD.Name = Blob.substr(0, NameLen);
+    RecD.USR = Blob.substr(NameLen, USRLen);
+    RecD.CodeGenName = Blob.substr(NameLen+USRLen);
+  }
+
+  /// Reads occurrence data.
+  /// \param DeclsFilter if non-empty indicates the list of decls that we want
+  /// to get occurrences for. If empty then indicates that we want occurrences
+  /// for all decls.
+  /// \param RelatedDeclsFilter Same as \c DeclsFilter but for related decls.
+  /// \returns true if the occurrence info was filled out, false if occurrence
+  /// was ignored.
+  bool readOccurrence(RecordDataImpl &Record, StringRef Blob,
+                      ArrayRef<const IndexRecordDecl *> DeclsFilter,
+                      ArrayRef<const IndexRecordDecl *> RelatedDeclsFilter,
+                      IndexRecordOccurrence &RecOccur) {
+
+    auto isDeclIDContained = [](unsigned DeclID,
+                                ArrayRef<const IndexRecordDecl *> Ds) -> bool {
+      if (Ds.empty())
+        return true; // empty means accept all.
+      auto pred = [DeclID](const IndexRecordDecl *D) { return D->DeclID == DeclID; };
+      return std::find_if(Ds.begin(), Ds.end(), pred) != Ds.end();
+    };
+
+    unsigned I = 0;
+    unsigned DeclID = read(Record, I);
+    if (!isDeclIDContained(DeclID, DeclsFilter))
+      return false;
+
+    if (!RelatedDeclsFilter.empty()) {
+      unsigned RelI = I+3;
+      unsigned NumRelated = read(Record, RelI);
+      bool FoundRelated = false;
+      while (NumRelated--) {
+        ++RelI; // roles;
+        unsigned RelDID = read(Record, RelI);
+        if (isDeclIDContained(RelDID, RelatedDeclsFilter)) {
+          FoundRelated = true;
+          break;
+        }
+      }
+      if (!FoundRelated)
+        return false;
+    }
+
+    RecOccur.Dcl = getDeclByID(DeclID);
+    RecOccur.Roles = getSymbolRoles(read(Record, I));
+    RecOccur.Line = read(Record, I);
+    RecOccur.Column = read(Record, I);
+
+    unsigned NumRelated = read(Record, I);
+    while (NumRelated--) {
+      SymbolRoleSet RelRoles = getSymbolRoles(read(Record, I));
+      const IndexRecordDecl *RelD = getDeclByID(read(Record, I));
+      RecOccur.Relations.emplace_back(RelRoles, RelD);
+    }
+
+    return true;
+  }
+
+  bool foreachDecl(bool NoCache,
+                   function_ref<bool(const IndexRecordDecl *)> Receiver) {
+    for (unsigned I = 0, E = getNumDecls(); I != E; ++I) {
+      if (const IndexRecordDecl *D = Decls[I]) {
+        if (!Receiver(D))
+          return false;
+        continue;
+      }
+
+      if (NoCache) {
+        IndexRecordDecl LocalD;
+        readDecl(I, LocalD);
+        if (!Receiver(&LocalD))
+          return false;
+      } else {
+        if (!Receiver(getDecl(I)))
+          return false;
+      }
+    }
+    return true;
+  }
+
+  bool foreachOccurrence(ArrayRef<const IndexRecordDecl *> DeclsFilter,
+                         ArrayRef<const IndexRecordDecl *> RelatedDeclsFilter,
+                         function_ref<bool(const IndexRecordOccurrence &)> Receiver) {
+    class OccurBitVisitor : public BitstreamVisitor<OccurBitVisitor> {
+      IndexRecordReader::Implementation &Reader;
+      ArrayRef<const IndexRecordDecl *> DeclsFilter;
+      ArrayRef<const IndexRecordDecl *> RelatedDeclsFilter;
+      function_ref<bool(const IndexRecordOccurrence &)> Receiver;
+
+    public:
+      OccurBitVisitor(llvm::BitstreamCursor &Stream,
+                      IndexRecordReader::Implementation &Reader,
+                      ArrayRef<const IndexRecordDecl *> DeclsFilter,
+                      ArrayRef<const IndexRecordDecl *> RelatedDeclsFilter,
+                      function_ref<bool(const IndexRecordOccurrence &)> Receiver)
+        : BitstreamVisitor(Stream),
+          Reader(Reader),
+          DeclsFilter(DeclsFilter),
+          RelatedDeclsFilter(RelatedDeclsFilter),
+          Receiver(std::move(Receiver)) {}
+
+      StreamVisit visitRecord(unsigned BlockID, unsigned RecID,
+                              RecordDataImpl &Record, StringRef Blob) {
+        assert(RecID == REC_DECLOCCURRENCE);
+        IndexRecordOccurrence RecOccur;
+        if (Reader.readOccurrence(Record, Blob, DeclsFilter, RelatedDeclsFilter,
+                                   RecOccur))
+          if (!Receiver(RecOccur))
+            return StreamVisit::Abort;
+        return StreamVisit::Continue;
+      }
+    };
+
+    SavedStreamPosition SavedPosition(OccurCursor);
+    OccurBitVisitor Visitor(OccurCursor, *this, DeclsFilter, RelatedDeclsFilter,
+                            Receiver);
+    std::string Error;
+    return Visitor.visit(Error);
+  }
+
+  bool foreachOccurrenceInLineRange(unsigned lineStart, unsigned lineCount,
+            llvm::function_ref<bool(const IndexRecordOccurrence &)> receiver) {
+    // FIXME: Use binary search and make this more efficient.
+    unsigned lineEnd = lineStart+lineCount;
+    return foreachOccurrence(None, None, [&](const IndexRecordOccurrence &occur) -> bool {
+      if (occur.Line > lineEnd)
+        return false; // we're done.
+      if (occur.Line >= lineStart) {
+        if (!receiver(occur))
+          return false;
+      }
+      return true;
+    });
+  }
+
+  static uint64_t read(RecordDataImpl &Record, unsigned &I) {
+    return Record[I++];
+  }
+};
+
+namespace {
+
+class IndexBitstreamVisitor : public BitstreamVisitor<IndexBitstreamVisitor> {
+  IndexRecordReader::Implementation &Reader;
+
+public:
+  IndexBitstreamVisitor(llvm::BitstreamCursor &Stream,
+                        IndexRecordReader::Implementation &Reader)
+    : BitstreamVisitor(Stream), Reader(Reader) {}
+
+  StreamVisit visitBlock(unsigned ID) {
+    switch ((RecordBitBlock)ID) {
+    case REC_VERSION_BLOCK_ID:
+    case REC_DECLOFFSETS_BLOCK_ID:
+      return StreamVisit::Continue;
+
+    case REC_DECLS_BLOCK_ID:
+      Reader.DeclCursor = Stream;
+      if (Reader.DeclCursor.EnterSubBlock(ID)) {
+        *Error = "malformed block record";
+        return StreamVisit::Abort;
+      }
+      readBlockAbbrevs(Reader.DeclCursor);
+      return StreamVisit::Skip;
+
+    case REC_DECLOCCURRENCES_BLOCK_ID:
+      Reader.OccurCursor = Stream;
+      if (Reader.OccurCursor.EnterSubBlock(ID)) {
+        *Error = "malformed block record";
+        return StreamVisit::Abort;
+      }
+      readBlockAbbrevs(Reader.OccurCursor);
+      return StreamVisit::Skip;
+    }
+
+    // Some newly introduced block in a minor version update that we cannot
+    // handle.
+    return StreamVisit::Skip;
+  }
+
+  StreamVisit visitRecord(unsigned BlockID, unsigned RecID,
+                          RecordDataImpl &Record, StringRef Blob) {
+    switch (BlockID) {
+    case REC_VERSION_BLOCK_ID: {
+      unsigned StoreFormatVersion = Record[0];
+      if (StoreFormatVersion != STORE_FORMAT_VERSION) {
+        llvm::raw_string_ostream OS(*Error);
+        OS << "Store format version mismatch: " << StoreFormatVersion;
+        OS << " , expected: " << STORE_FORMAT_VERSION;
+        return StreamVisit::Abort;
+      }
+      break;
+    }
+    case REC_DECLOFFSETS_BLOCK_ID:
+      assert(RecID == REC_DECLOFFSETS);
+      Reader.setDeclOffsets(makeArrayRef((const uint32_t*)Blob.data(),
+                            Record[0]));
+      break;
+
+    case REC_DECLS_BLOCK_ID:
+    case REC_DECLOCCURRENCES_BLOCK_ID:
+      llvm_unreachable("shouldn't visit this block'");
+    }
+    return StreamVisit::Continue;
+  }
+};
+
+} // anonymous namespace
+
+std::unique_ptr<IndexRecordReader>
+IndexRecordReader::createWithRecordFilename(StringRef RecordFilename,
+                                            StringRef StorePath,
+                                            std::string &Error) {
+  SmallString<128> PathBuf = StorePath;
+  appendRecordSubDir(PathBuf);
+  appendInteriorRecordPath(RecordFilename, PathBuf);
+  return createWithFilePath(PathBuf.str(), Error);
+}
+
+std::unique_ptr<IndexRecordReader>
+IndexRecordReader::createWithFilePath(StringRef FilePath, std::string &Error) {
+  auto ErrOrBuf = MemoryBuffer::getFile(FilePath, /*FileSize=*/-1,
+                                        /*RequiresNullTerminator=*/false);
+  if (!ErrOrBuf) {
+    raw_string_ostream(Error) << "failed opening index record '"
+      << FilePath << "': " << ErrOrBuf.getError().message();
+    return nullptr;
+  }
+  return createWithBuffer(std::move(*ErrOrBuf), Error);
+}
+
+std::unique_ptr<IndexRecordReader>
+IndexRecordReader::createWithBuffer(std::unique_ptr<llvm::MemoryBuffer> Buffer,
+                                    std::string &Error) {
+
+  std::unique_ptr<IndexRecordReader> Reader;
+  Reader.reset(new IndexRecordReader());
+  auto &Impl = Reader->Impl;
+  Impl.Buffer = std::move(Buffer);
+  llvm::BitstreamCursor Stream(*Impl.Buffer);
+
+  // Sniff for the signature.
+  if (Stream.Read(8) != 'I' ||
+      Stream.Read(8) != 'D' ||
+      Stream.Read(8) != 'X' ||
+      Stream.Read(8) != 'R') {
+    Error = "not a serialized index record file";
+    return nullptr;
+  }
+
+  IndexBitstreamVisitor BitVisitor(Stream, Impl);
+  if (!BitVisitor.visit(Error))
+    return nullptr;
+
+  return Reader;
+}
+
+IndexRecordReader::IndexRecordReader()
+  : Impl(*new Implementation()) {
+
+}
+
+IndexRecordReader::~IndexRecordReader() {
+  delete &Impl;
+}
+
+bool IndexRecordReader::searchDecls(
+                        llvm::function_ref<DeclSearchCheck> Checker,
+                  llvm::function_ref<void(const IndexRecordDecl *)> Receiver) {
+  return Impl.searchDecls(std::move(Checker), std::move(Receiver));
+}
+
+bool IndexRecordReader::foreachDecl(bool NoCache,
+                                    function_ref<bool(const IndexRecordDecl *)> Receiver) {
+  return Impl.foreachDecl(NoCache, std::move(Receiver));
+}
+
+bool IndexRecordReader::foreachOccurrence(
+                  ArrayRef<const IndexRecordDecl *> DeclsFilter,
+                  ArrayRef<const IndexRecordDecl *> RelatedDeclsFilter,
+                  function_ref<bool(const IndexRecordOccurrence &)> Receiver) {
+  return Impl.foreachOccurrence(DeclsFilter, RelatedDeclsFilter,
+                                std::move(Receiver));
+}
+
+bool IndexRecordReader::foreachOccurrence(
+            llvm::function_ref<bool(const IndexRecordOccurrence &)> Receiver) {
+  return foreachOccurrence(None, None, std::move(Receiver));
+}
+
+bool IndexRecordReader::foreachOccurrenceInLineRange(unsigned lineStart,
+                                                     unsigned lineCount,
+             llvm::function_ref<bool(const IndexRecordOccurrence &)> Receiver) {
+  return Impl.foreachOccurrenceInLineRange(lineStart, lineCount, Receiver);
+}
diff --git a/lib/Index/IndexRecordWriter.cpp b/lib/Index/IndexRecordWriter.cpp
index e69de29bb2..c4e6d50716 100644
--- a/lib/Index/IndexRecordWriter.cpp
+++ b/lib/Index/IndexRecordWriter.cpp
@@ -0,0 +1,366 @@
+//===--- IndexRecordWriter.cpp - Index record serialization ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Index/IndexRecordWriter.h"
+#include "IndexDataStoreUtils.h"
+#include "indexstore/indexstore.h"
+#include "clang/Index/IndexDataStoreSymbolUtils.h"
+#include "llvm/ADT/APInt.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/StringSet.h"
+#include "llvm/Bitcode/BitstreamWriter.h"
+#include "llvm/Support/Errc.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace clang::index::store;
+using namespace llvm;
+
+using writer::OpaqueDecl;
+
+namespace {
+struct DeclInfo {
+  OpaqueDecl D;
+  SymbolRoleSet Roles;
+  SymbolRoleSet RelatedRoles;
+};
+
+struct OccurrenceInfo {
+  unsigned DeclID;
+  OpaqueDecl D;
+  SymbolRoleSet Roles;
+  unsigned Line;
+  unsigned Column;
+  SmallVector<std::pair<writer::SymbolRelation, unsigned>, 4> Related;
+};
+
+struct RecordState {
+  std::string RecordPath;
+  SmallString<512> Buffer;
+  BitstreamWriter Stream;
+
+  DenseMap<OpaqueDecl, unsigned> IndexForDecl;
+  std::vector<DeclInfo> Decls;
+  std::vector<OccurrenceInfo> Occurrences;
+
+  RecordState(std::string &&RecordPath)
+      : RecordPath(std::move(RecordPath)), Stream(Buffer) {}
+};
+} // end anonymous namespace
+
+static void writeBlockInfo(BitstreamWriter &Stream) {
+  RecordData Record;
+
+  Stream.EnterBlockInfoBlock();
+#define BLOCK(X) emitBlockID(X ## _ID, #X, Stream, Record)
+#define RECORD(X) emitRecordID(X, #X, Stream, Record)
+
+  BLOCK(REC_VERSION_BLOCK);
+  RECORD(REC_VERSION);
+
+  BLOCK(REC_DECLS_BLOCK);
+  RECORD(REC_DECLINFO);
+
+  BLOCK(REC_DECLOFFSETS_BLOCK);
+  RECORD(REC_DECLOFFSETS);
+
+  BLOCK(REC_DECLOCCURRENCES_BLOCK);
+  RECORD(REC_DECLOCCURRENCE);
+
+#undef RECORD
+#undef BLOCK
+  Stream.ExitBlock();
+}
+
+static void writeVersionInfo(BitstreamWriter &Stream) {
+  using namespace llvm::sys;
+
+  Stream.EnterSubblock(REC_VERSION_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(REC_VERSION));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 6)); // Store format version
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  RecordData Record;
+  Record.push_back(REC_VERSION);
+  Record.push_back(STORE_FORMAT_VERSION);
+  Stream.EmitRecordWithAbbrev(AbbrevCode, Record);
+
+  Stream.ExitBlock();
+}
+
+template <typename T, typename Allocator>
+static StringRef data(const std::vector<T, Allocator> &v) {
+  if (v.empty())
+    return StringRef();
+  return StringRef(reinterpret_cast<const char *>(&v[0]), sizeof(T) * v.size());
+}
+
+template <typename T> static StringRef data(const SmallVectorImpl<T> &v) {
+  return StringRef(reinterpret_cast<const char *>(v.data()),
+                   sizeof(T) * v.size());
+}
+
+static void writeDecls(BitstreamWriter &Stream, ArrayRef<DeclInfo> Decls,
+                       ArrayRef<OccurrenceInfo> Occurrences,
+                       writer::SymbolWriterCallback GetSymbolForDecl) {
+  SmallVector<uint32_t, 32> DeclOffsets;
+  DeclOffsets.reserve(Decls.size());
+
+  //===--------------------------------------------------------------------===//
+  // DECLS_BLOCK_ID
+  //===--------------------------------------------------------------------===//
+
+  Stream.EnterSubblock(REC_DECLS_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(REC_DECLINFO));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // Kind
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // SubKind
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // Language
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, SymbolPropertyBitNum)); // Properties
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, SymbolRoleBitNum)); // Roles
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, SymbolRoleBitNum)); // Related Roles
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 6)); // Length of name in block
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 6)); // Length of USR in block
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Blob)); // Name + USR + CodeGen symbol name
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+#ifndef NDEBUG
+  StringSet<> USRSet;
+#endif
+
+  RecordData Record;
+  llvm::SmallString<256> Blob;
+  llvm::SmallString<256> Scratch;
+  for (auto &Info : Decls) {
+    DeclOffsets.push_back(Stream.GetCurrentBitNo());
+    Blob.clear();
+    Scratch.clear();
+
+    writer::Symbol SymInfo = GetSymbolForDecl(Info.D, Scratch);
+    assert(SymInfo.SymInfo.Kind != SymbolKind::Unknown);
+    assert(!SymInfo.USR.empty() && "Recorded decl without USR!");
+
+    Blob += SymInfo.Name;
+    Blob += SymInfo.USR;
+    Blob += SymInfo.CodeGenName;
+
+#ifndef NDEBUG
+    bool IsNew = USRSet.insert(SymInfo.USR).second;
+    if (!IsNew) {
+      llvm::errs() << "Index: Duplicate USR! " << SymInfo.USR << "\n";
+      // FIXME: print more information so it's easier to find the declaration.
+    }
+#endif
+
+    Record.clear();
+    Record.push_back(REC_DECLINFO);
+    Record.push_back(getIndexStoreKind(SymInfo.SymInfo.Kind));
+    Record.push_back(getIndexStoreSubKind(SymInfo.SymInfo.SubKind));
+    Record.push_back(getIndexStoreLang(SymInfo.SymInfo.Lang));
+    Record.push_back(getIndexStoreProperties(SymInfo.SymInfo.Properties));
+    Record.push_back(getIndexStoreRoles(Info.Roles));
+    Record.push_back(getIndexStoreRoles(Info.RelatedRoles));
+    Record.push_back(SymInfo.Name.size());
+    Record.push_back(SymInfo.USR.size());
+    Stream.EmitRecordWithBlob(AbbrevCode, Record, Blob);
+  }
+
+  Stream.ExitBlock();
+
+  //===--------------------------------------------------------------------===//
+  // DECLOFFSETS_BLOCK_ID
+  //===--------------------------------------------------------------------===//
+
+  Stream.EnterSubblock(REC_DECLOFFSETS_BLOCK_ID, 3);
+
+  Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(REC_DECLOFFSETS));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 32)); // Number of Decls
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Blob)); // Offsets array
+  AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  Record.clear();
+  Record.push_back(REC_DECLOFFSETS);
+  Record.push_back(DeclOffsets.size());
+  Stream.EmitRecordWithBlob(AbbrevCode, Record, data(DeclOffsets));
+
+  Stream.ExitBlock();
+
+  //===--------------------------------------------------------------------===//
+  // DECLOCCURRENCES_BLOCK_ID
+  //===--------------------------------------------------------------------===//
+
+  Stream.EnterSubblock(REC_DECLOCCURRENCES_BLOCK_ID, 3);
+
+  Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(REC_DECLOCCURRENCE));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // Decl ID
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, SymbolRoleBitNum)); // Roles
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 12)); // Line
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // Column
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 4)); // Num related
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Array)); // Related Roles/IDs
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 16)); // Roles or ID
+  AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  for (auto &Occur : Occurrences) {
+    Record.clear();
+    Record.push_back(REC_DECLOCCURRENCE);
+    Record.push_back(Occur.DeclID);
+    Record.push_back(getIndexStoreRoles(Occur.Roles));
+    Record.push_back(Occur.Line);
+    Record.push_back(Occur.Column);
+    Record.push_back(Occur.Related.size());
+    for (auto &Rel : Occur.Related) {
+      Record.push_back(getIndexStoreRoles(Rel.first.Roles));
+      Record.push_back(Rel.second);
+    }
+    Stream.EmitRecordWithAbbrev(AbbrevCode, Record);
+  }
+  Stream.ExitBlock();
+}
+
+IndexRecordWriter::IndexRecordWriter(StringRef IndexPath)
+    : RecordsPath(IndexPath) {
+  store::appendRecordSubDir(RecordsPath);
+}
+
+IndexRecordWriter::Result
+IndexRecordWriter::beginRecord(StringRef Filename, hash_code RecordHash,
+                               std::string &Error, std::string *OutRecordFile) {
+  using namespace llvm::sys;
+  assert(!Record && "called beginRecord before calling endRecord on previous");
+
+  std::string RecordName;
+  {
+    llvm::raw_string_ostream RN(RecordName);
+    RN << path::filename(Filename);
+    RN << "-" << APInt(64, RecordHash).toString(36, /*Signed=*/false);
+  }
+  SmallString<256> RecordPath = RecordsPath.str();
+  appendInteriorRecordPath(RecordName, RecordPath);
+
+  if (OutRecordFile)
+    *OutRecordFile = RecordName;
+
+  if (std::error_code EC =
+          fs::access(RecordPath.c_str(), fs::AccessMode::Exist)) {
+    if (EC != errc::no_such_file_or_directory) {
+      llvm::raw_string_ostream Err(Error);
+      Err << "could not access record '" << RecordPath
+          << "': " << EC.message();
+      return Result::Failure;
+    }
+  } else {
+    return Result::AlreadyExists;
+  }
+
+  // Write the record header.
+  auto *State = new RecordState(RecordPath.str());
+  Record = State;
+  llvm::BitstreamWriter &Stream = State->Stream;
+  Stream.Emit('I', 8);
+  Stream.Emit('D', 8);
+  Stream.Emit('X', 8);
+  Stream.Emit('R', 8);
+
+  writeBlockInfo(Stream);
+  writeVersionInfo(Stream);
+
+  return Result::Success;
+}
+
+IndexRecordWriter::Result
+IndexRecordWriter::endRecord(std::string &Error,
+                             writer::SymbolWriterCallback GetSymbolForDecl) {
+  assert(Record && "called endRecord without calling beginRecord");
+  auto &State = *static_cast<RecordState *>(Record);
+  Record = nullptr;
+  struct ScopedDelete {
+    RecordState *S;
+    ScopedDelete(RecordState *S) : S(S) {}
+    ~ScopedDelete() { delete S; }
+  } Deleter(&State);
+
+  if (!State.Decls.empty()) {
+    writeDecls(State.Stream, State.Decls, State.Occurrences, GetSymbolForDecl);
+  }
+
+  if (std::error_code EC = sys::fs::create_directory(sys::path::parent_path(State.RecordPath))) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to create directory '" << sys::path::parent_path(State.RecordPath) << "': " << EC.message();
+    return Result::Failure;
+  }
+
+  // Create a unique file to write to so that we can move the result into place
+  // atomically. If this process crashes we don't want to interfere with any
+  // other concurrent processes.
+  SmallString<128> TempPath(State.RecordPath);
+  TempPath += "-temp-%%%%%%%%";
+  int TempFD;
+  if (sys::fs::createUniqueFile(TempPath.str(), TempFD, TempPath)) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to create temporary file: " << TempPath;
+    return Result::Failure;
+  }
+
+  raw_fd_ostream OS(TempFD, /*shouldClose=*/true);
+  OS.write(State.Buffer.data(), State.Buffer.size());
+  OS.close();
+
+  // Atomically move the unique file into place.
+  if (std::error_code EC =
+          sys::fs::rename(TempPath.c_str(), State.RecordPath.c_str())) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to rename '" << TempPath << "' to '" << State.RecordPath << "': " << EC.message();
+    return Result::Failure;
+  }
+
+  return Result::Success;
+}
+
+void IndexRecordWriter::addOccurrence(
+    OpaqueDecl D, SymbolRoleSet Roles, unsigned Line, unsigned Column,
+    ArrayRef<writer::SymbolRelation> Related) {
+  assert(Record && "called addOccurrence without calling beginRecord");
+  auto &State = *static_cast<RecordState *>(Record);
+
+  auto insertDecl = [&](OpaqueDecl D, SymbolRoleSet Roles,
+                        SymbolRoleSet RelatedRoles) -> unsigned {
+    auto Insert =
+        State.IndexForDecl.insert(std::make_pair(D, State.Decls.size()));
+    unsigned Index = Insert.first->second;
+
+    if (Insert.second) {
+      State.Decls.push_back(DeclInfo{D, Roles, RelatedRoles});
+    } else {
+      State.Decls[Index].Roles |= Roles;
+      State.Decls[Index].RelatedRoles |= RelatedRoles;
+    }
+    return Index + 1;
+  };
+
+  unsigned DeclID = insertDecl(D, Roles, SymbolRoleSet());
+
+  decltype(OccurrenceInfo::Related) RelatedDecls;
+  RelatedDecls.reserve(Related.size());
+  for (auto &Rel : Related) {
+    unsigned ID = insertDecl(Rel.RelatedSymbol, SymbolRoleSet(), Rel.Roles);
+    RelatedDecls.emplace_back(Rel, ID);
+  }
+
+  State.Occurrences.push_back(
+      OccurrenceInfo{DeclID, D, Roles, Line, Column, std::move(RelatedDecls)});
+}
diff --git a/lib/Index/IndexSymbol.cpp b/lib/Index/IndexSymbol.cpp
index 733d4dbc2f..8657f62303 100644
--- a/lib/Index/IndexSymbol.cpp
+++ b/lib/Index/IndexSymbol.cpp
@@ -466,6 +466,7 @@ StringRef index::getSymbolKindString(SymbolKind K) {
   case SymbolKind::ConversionFunction: return "coversion-func";
   case SymbolKind::Parameter: return "param";
   case SymbolKind::Using: return "using";
+  case SymbolKind::CommentTag: return "comment-tag";
   }
   llvm_unreachable("invalid symbol kind");
 }
@@ -479,6 +480,20 @@ StringRef index::getSymbolSubKindString(SymbolSubKind K) {
   case SymbolSubKind::AccessorSetter: return "acc-set";
   case SymbolSubKind::UsingTypename: return "using-typename";
   case SymbolSubKind::UsingValue: return "using-value";
+  case SymbolSubKind::SwiftAccessorWillSet: return "acc-willset";
+  case SymbolSubKind::SwiftAccessorDidSet: return "acc-didset";
+  case SymbolSubKind::SwiftAccessorAddressor: return "acc-addr";
+  case SymbolSubKind::SwiftAccessorMutableAddressor: return "acc-mutaddr";
+  case SymbolSubKind::SwiftExtensionOfStruct: return "ext-struct";
+  case SymbolSubKind::SwiftExtensionOfClass: return "ext-class";
+  case SymbolSubKind::SwiftExtensionOfEnum: return "ext-enum";
+  case SymbolSubKind::SwiftExtensionOfProtocol: return "ext-protocol";
+  case SymbolSubKind::SwiftPrefixOperator: return "prefix-operator";
+  case SymbolSubKind::SwiftPostfixOperator: return "postfix-operator";
+  case SymbolSubKind::SwiftInfixOperator: return "infix-operator";
+  case SymbolSubKind::SwiftSubscript: return "subscript";
+  case SymbolSubKind::SwiftAssociatedType: return "associated-type";
+  case SymbolSubKind::SwiftGenericTypeParam: return "generic-type-param";
   }
   llvm_unreachable("invalid symbol subkind");
 }
diff --git a/lib/Index/IndexUnitReader.cpp b/lib/Index/IndexUnitReader.cpp
index e69de29bb2..fa8e9e924e 100644
--- a/lib/Index/IndexUnitReader.cpp
+++ b/lib/Index/IndexUnitReader.cpp
@@ -0,0 +1,515 @@
+//===--- IndexUnitReader.cpp - Index unit deserialization -----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Index/IndexUnitReader.h"
+#include "IndexDataStoreUtils.h"
+#include "BitstreamVisitor.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Bitcode/BitstreamReader.h"
+#include "llvm/Support/Chrono.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/Process.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace clang::index::store;
+using namespace llvm;
+
+namespace {
+
+typedef function_ref<bool(const IndexUnitReader::DependencyInfo &)> DependencyReceiver;
+typedef function_ref<bool(const IndexUnitReader::IncludeInfo &)> IncludeReceiver;
+
+class IndexUnitReaderImpl {
+  sys::TimePoint<> ModTime;
+  std::unique_ptr<MemoryBuffer> MemBuf;
+
+public:
+  StringRef ProviderIdentifier;
+  StringRef ProviderVersion;
+  llvm::BitstreamCursor DependCursor;
+  llvm::BitstreamCursor IncludeCursor;
+  bool IsSystemUnit;
+  bool IsModuleUnit;
+  bool IsDebugCompilation;
+  StringRef WorkingDir;
+  StringRef OutputFile;
+  StringRef SysrootPath;
+  StringRef ModuleName;
+  SmallString<128> MainFilePath;
+  StringRef Target;
+  std::vector<FileBitPath> Paths;
+  StringRef PathsBuffer;
+
+  struct ModuleInfo {
+    unsigned NameOffset;
+    unsigned NameSize;
+  };
+  std::vector<ModuleInfo> Modules;
+  StringRef ModuleNamesBuffer;
+
+  bool init(std::unique_ptr<MemoryBuffer> Buf, sys::TimePoint<> ModTime,
+            std::string &Error);
+
+  StringRef getProviderIdentifier() const { return ProviderIdentifier; }
+  StringRef getProviderVersion() const { return ProviderVersion; }
+
+  sys::TimePoint<> getModificationTime() const { return ModTime; }
+  StringRef getWorkingDirectory() const { return WorkingDir; }
+  StringRef getOutputFile() const { return OutputFile; }
+  StringRef getSysrootPath() const { return SysrootPath; }
+  StringRef getTarget() const { return Target; }
+
+  StringRef getModuleName() const { return ModuleName; }
+  StringRef getMainFilePath() const { return MainFilePath.str(); }
+  bool hasMainFile() const { return !MainFilePath.empty(); }
+  bool isSystemUnit() const { return IsSystemUnit; }
+  bool isModuleUnit() const { return IsModuleUnit; }
+  bool isDebugCompilation() const { return IsDebugCompilation; }
+
+  /// Unit dependencies are provided ahead of record ones, record ones
+  /// ahead of the file ones.
+  bool foreachDependency(DependencyReceiver Receiver);
+
+  bool foreachInclude(IncludeReceiver Receiver);
+
+  StringRef getPathFromBuffer(size_t Offset, size_t Size) {
+    return PathsBuffer.substr(Offset, Size);
+  }
+
+  void constructFilePath(SmallVectorImpl<char> &Path, int PathIndex);
+
+  StringRef getModuleName(int ModuleIndex);
+};
+
+class IndexUnitBitstreamVisitor : public BitstreamVisitor<IndexUnitBitstreamVisitor> {
+  IndexUnitReaderImpl &Reader;
+  size_t WorkDirOffset;
+  size_t WorkDirSize;
+  size_t OutputFileOffset;
+  size_t OutputFileSize;
+  size_t SysrootOffset;
+  size_t SysrootSize;
+  int MainPathIndex;
+
+public:
+  IndexUnitBitstreamVisitor(llvm::BitstreamCursor &Stream,
+                            IndexUnitReaderImpl &Reader)
+    : BitstreamVisitor(Stream), Reader(Reader) {}
+
+  StreamVisit visitBlock(unsigned ID) {
+    switch ((UnitBitBlock)ID) {
+    case UNIT_VERSION_BLOCK_ID:
+    case UNIT_INFO_BLOCK_ID:
+    case UNIT_PATHS_BLOCK_ID:
+    case UNIT_MODULES_BLOCK_ID:
+      return StreamVisit::Continue;
+
+    case UNIT_DEPENDENCIES_BLOCK_ID:
+      Reader.DependCursor = Stream;
+      if (Reader.DependCursor.EnterSubBlock(ID)) {
+        *Error = "malformed unit dependencies block record";
+        return StreamVisit::Abort;
+      }
+      readBlockAbbrevs(Reader.DependCursor);
+      return StreamVisit::Skip;
+    case UNIT_INCLUDES_BLOCK_ID:
+      Reader.IncludeCursor = Stream;
+      if (Reader.IncludeCursor.EnterSubBlock(ID)) {
+        *Error = "malformed unit includes block record";
+        return StreamVisit::Abort;
+      }
+      readBlockAbbrevs(Reader.IncludeCursor);
+      return StreamVisit::Skip;
+    }
+
+    // Some newly introduced block in a minor version update that we cannot
+    // handle.
+    return StreamVisit::Skip;
+  }
+
+  StreamVisit visitRecord(unsigned BlockID, unsigned RecID,
+                          RecordDataImpl &Record, StringRef Blob) {
+    switch (BlockID) {
+    case UNIT_VERSION_BLOCK_ID: {
+      unsigned StoreFormatVersion = Record[0];
+      if (StoreFormatVersion != STORE_FORMAT_VERSION) {
+        llvm::raw_string_ostream OS(*Error);
+        OS << "Store format version mismatch: " << StoreFormatVersion;
+        OS << " , expected: " << STORE_FORMAT_VERSION;
+        return StreamVisit::Abort;
+      }
+      break;
+    }
+
+    case UNIT_INFO_BLOCK_ID: {
+      assert(RecID == UNIT_INFO);
+      unsigned I = 0;
+      Reader.IsSystemUnit = Record[I++];
+
+      // Save these to lookup them up after we get the paths buffer.
+      WorkDirOffset = Record[I++];
+      WorkDirSize = Record[I++];
+      OutputFileOffset = Record[I++];
+      OutputFileSize = Record[I++];
+      SysrootOffset = Record[I++];
+      SysrootSize = Record[I++];
+      MainPathIndex = (int)Record[I++] - 1;
+      Reader.IsDebugCompilation = Record[I++];
+      Reader.IsModuleUnit = Record[I++];
+
+      size_t moduleNameSize = Record[I++];
+      size_t providerIdentifierSize = Record[I++];
+      size_t providerVersionSize = Record[I++];
+      I++; // Reserved for ProviderDataVersion.
+      Reader.ModuleName = Blob.substr(0, moduleNameSize);
+      Blob = Blob.drop_front(moduleNameSize);
+      Reader.ProviderIdentifier = Blob.substr(0, providerIdentifierSize);
+      Blob = Blob.drop_front(providerIdentifierSize);
+      Reader.ProviderVersion = Blob.substr(0, providerVersionSize);
+      Reader.Target = Blob.drop_front(providerVersionSize);
+      break;
+    }
+
+    case UNIT_PATHS_BLOCK_ID:
+      switch (RecID) {
+      case UNIT_PATH:
+        {
+          unsigned I = 0;
+          UnitFilePathPrefixKind Kind = (UnitFilePathPrefixKind)Record[I++];
+          size_t DirOffset = Record[I++];
+          size_t DirSize = Record[I++];
+          size_t FilenameOffset = Record[I++];
+          size_t FilenameSize = Record[I++];
+
+          Reader.Paths.emplace_back(Kind, BitPathComponent(DirOffset, DirSize),
+                                  BitPathComponent(FilenameOffset, FilenameSize));
+        }
+        break;
+      case UNIT_PATH_BUFFER:
+        Reader.PathsBuffer = Blob;
+        Reader.WorkingDir = Reader.getPathFromBuffer(WorkDirOffset, WorkDirSize);
+        Reader.OutputFile = Reader.getPathFromBuffer(OutputFileOffset, OutputFileSize);
+        Reader.SysrootPath = Reader.getPathFromBuffer(SysrootOffset, SysrootSize);
+
+        // now we can populate the main file's path
+        Reader.constructFilePath(Reader.MainFilePath, MainPathIndex);
+        break;
+      default:
+          llvm_unreachable("shouldn't visit this record");
+      }
+      break;
+
+    case UNIT_MODULES_BLOCK_ID:
+      switch (RecID) {
+      case UNIT_MODULE:
+        {
+          unsigned I = 0;
+          unsigned NameOffset = Record[I++];
+          unsigned NameSize = Record[I++];
+          Reader.Modules.push_back({NameOffset, NameSize});
+        }
+        break;
+      case UNIT_MODULE_BUFFER:
+        Reader.ModuleNamesBuffer = Blob;
+        break;
+      default:
+          llvm_unreachable("shouldn't visit this record");
+      }
+      break;
+
+    case UNIT_DEPENDENCIES_BLOCK_ID:
+    case UNIT_INCLUDES_BLOCK_ID:
+      llvm_unreachable("shouldn't visit this block'");
+    }
+    return StreamVisit::Continue;
+  }
+};
+
+typedef std::function<bool(RecordDataImpl& Record, StringRef Blob)>
+  BlockVisitorCallback;
+
+class IndexUnitBlockBitstreamVisitor : public BitstreamVisitor<IndexUnitBlockBitstreamVisitor> {
+  unsigned RecID;
+  BlockVisitorCallback Visit;
+
+public:
+  IndexUnitBlockBitstreamVisitor(unsigned RecID,
+                                 llvm::BitstreamCursor &BlockStream,
+                                 BlockVisitorCallback Visit)
+  : BitstreamVisitor(BlockStream), RecID(RecID), Visit(std::move(Visit)) {}
+
+  StreamVisit visitRecord(unsigned BlockID, unsigned RecID,
+                          RecordDataImpl &Record, StringRef Blob) {
+    if (RecID != this->RecID)
+      llvm_unreachable("shouldn't be called with this RecID");
+
+    if (Visit(Record, Blob))
+      return StreamVisit::Continue;
+    return StreamVisit::Abort;
+  }
+};
+
+} // anonymous namespace
+
+bool IndexUnitReaderImpl::init(std::unique_ptr<MemoryBuffer> Buf,
+                               sys::TimePoint<> ModTime, std::string &Error) {
+  this->ModTime = ModTime;
+  this->MemBuf = std::move(Buf);
+  llvm::BitstreamCursor Stream(*MemBuf);
+
+  // Sniff for the signature.
+  if (Stream.Read(8) != 'I' ||
+      Stream.Read(8) != 'D' ||
+      Stream.Read(8) != 'X' ||
+      Stream.Read(8) != 'U') {
+    Error = "not a serialized index unit file";
+    return true;
+  }
+
+  IndexUnitBitstreamVisitor BitVisitor(Stream, *this);
+  return !BitVisitor.visit(Error);
+}
+
+/// Unit dependencies are provided ahead of record ones, record ones
+/// ahead of the file ones.
+bool IndexUnitReaderImpl::foreachDependency(DependencyReceiver Receiver) {
+  store::SavedStreamPosition SavedDepPosition(DependCursor);
+  IndexUnitBlockBitstreamVisitor Visitor(UNIT_DEPENDENCY, DependCursor,
+  [&](RecordDataImpl& Record, StringRef Blob) {
+    unsigned I = 0;
+    UnitDependencyKind UnitDepKind = (UnitDependencyKind)Record[I++];
+    bool IsSystem = Record[I++];
+    int PathIndex = (int)Record[I++] - 1;
+    int ModuleIndex = (int)Record[I++] - 1;
+    time_t ModTime = (time_t)Record[I++];
+    size_t FileSize = Record[I++];
+    StringRef Name = Blob;
+
+    IndexUnitReader::DependencyKind DepKind;
+    switch (UnitDepKind) {
+      case UNIT_DEPEND_KIND_UNIT:
+        DepKind = IndexUnitReader::DependencyKind::Unit; break;
+      case UNIT_DEPEND_KIND_RECORD:
+        DepKind = IndexUnitReader::DependencyKind::Record; break;
+      case UNIT_DEPEND_KIND_FILE:
+        DepKind = IndexUnitReader::DependencyKind::File; break;
+    }
+
+    SmallString<512> PathBuf;
+    this->constructFilePath(PathBuf, PathIndex);
+    StringRef ModuleName = this->getModuleName(ModuleIndex);
+
+    return Receiver(IndexUnitReader::DependencyInfo{DepKind, IsSystem, Name,
+      PathBuf.str(), ModuleName, FileSize, ModTime});
+  });
+
+  std::string Error;
+  return Visitor.visit(Error);
+}
+
+bool IndexUnitReaderImpl::foreachInclude(IncludeReceiver Receiver) {
+  store::SavedStreamPosition SavedIncPosition(IncludeCursor);
+  IndexUnitBlockBitstreamVisitor Visitor(UNIT_INCLUDE, IncludeCursor,
+  [&](RecordDataImpl& Record, StringRef Blob) {
+    unsigned I = 0;
+    int SourcePathIndex = (int)Record[I++] - 1;
+    unsigned Line = Record[I++];
+    int TargetPathIndex = (int)Record[I++] - 1;
+
+    SmallString<512> SourceBuf, TargetBuf;
+    this->constructFilePath(SourceBuf, SourcePathIndex);
+    this->constructFilePath(TargetBuf, TargetPathIndex);
+    return Receiver(IndexUnitReader::IncludeInfo{SourceBuf.str(), Line, TargetBuf.str()});
+  });
+
+  std::string Error;
+  return Visitor.visit(Error);
+}
+
+
+void IndexUnitReaderImpl::constructFilePath(SmallVectorImpl<char> &PathBuf,
+                       int PathIndex) {
+
+  if (PathIndex < 0) return;
+  FileBitPath &Path = Paths[PathIndex];
+  StringRef Prefix;
+  switch (Path.PrefixKind) {
+  case UNIT_PATH_PREFIX_NONE:
+    break;
+  case UNIT_PATH_PREFIX_WORKDIR:
+    Prefix = getWorkingDirectory();
+    break;
+  case UNIT_PATH_PREFIX_SYSROOT:
+    Prefix = getSysrootPath();
+    break;
+  }
+  PathBuf.append(Prefix.begin(), Prefix.end());
+  sys::path::append(PathBuf,
+                    getPathFromBuffer(Path.Dir.Offset, Path.Dir.Size),
+                    getPathFromBuffer(Path.Filename.Offset, Path.Filename.Size));
+}
+
+StringRef IndexUnitReaderImpl::getModuleName(int ModuleIndex) {
+  if (ModuleIndex < 0)
+    return StringRef();
+  auto &ModInfo = Modules[ModuleIndex];
+  return StringRef(ModuleNamesBuffer.data()+ModInfo.NameOffset, ModInfo.NameSize);
+}
+
+
+//===----------------------------------------------------------------------===//
+// IndexUnitReader
+//===----------------------------------------------------------------------===//
+
+std::unique_ptr<IndexUnitReader>
+IndexUnitReader::createWithUnitFilename(StringRef UnitFilename,
+                                        StringRef StorePath,
+                                        std::string &Error) {
+  SmallString<128> PathBuf = StorePath;
+  appendUnitSubDir(PathBuf);
+  sys::path::append(PathBuf, UnitFilename);
+  return createWithFilePath(PathBuf.str(), Error);
+}
+
+std::unique_ptr<IndexUnitReader>
+IndexUnitReader::createWithFilePath(StringRef FilePath, std::string &Error) {
+  int FD;
+  std::error_code EC = sys::fs::openFileForRead(FilePath, FD);
+  if (EC) {
+    raw_string_ostream(Error) << "Failed opening '" << FilePath << "': "
+      << EC.message();
+    return nullptr;
+  }
+
+  assert(FD != -1);
+  struct AutoFDClose {
+    int FD;
+    AutoFDClose(int FD) : FD(FD) {}
+    ~AutoFDClose() {
+        llvm::sys::Process::SafelyCloseFileDescriptor(FD);
+    }
+  } AutoFDClose(FD);
+
+  sys::fs::file_status FileStat;
+  EC = sys::fs::status(FD, FileStat);
+  if (EC) {
+    Error = EC.message();
+    return nullptr;
+  }
+
+  auto ErrOrBuf = MemoryBuffer::getOpenFile(FD, FilePath, /*FileSize=*/-1,
+                                            /*RequiresNullTerminator=*/false);
+  if (!ErrOrBuf) {
+    raw_string_ostream(Error) << "Failed opening '" << FilePath << "': "
+      << ErrOrBuf.getError().message();
+    return nullptr;
+  }
+
+  std::unique_ptr<IndexUnitReaderImpl> Impl(new IndexUnitReaderImpl());
+  bool Err = Impl->init(std::move(*ErrOrBuf), FileStat.getLastModificationTime(),
+                        Error);
+  if (Err)
+    return nullptr;
+
+  std::unique_ptr<IndexUnitReader> Reader;
+  Reader.reset(new IndexUnitReader(Impl.release()));
+  return Reader;
+}
+
+Optional<sys::TimePoint<>>
+IndexUnitReader::getModificationTimeForUnit(StringRef UnitFilename,
+                                            StringRef StorePath,
+                                            std::string &Error) {
+  SmallString<128> PathBuf = StorePath;
+  appendUnitSubDir(PathBuf);
+  sys::path::append(PathBuf, UnitFilename);
+
+  sys::fs::file_status FileStat;
+  std::error_code EC = sys::fs::status(PathBuf.str(), FileStat);
+  if (EC) {
+    Error = EC.message();
+    return None;
+  }
+  return FileStat.getLastModificationTime();
+}
+
+#define IMPL static_cast<IndexUnitReaderImpl*>(Impl)
+
+IndexUnitReader::~IndexUnitReader() {
+  delete IMPL;
+}
+
+StringRef IndexUnitReader::getProviderIdentifier() const {
+  return IMPL->getProviderIdentifier();
+}
+
+StringRef IndexUnitReader::getProviderVersion() const {
+  return IMPL->getProviderVersion();
+}
+
+llvm::sys::TimePoint<> IndexUnitReader::getModificationTime() const {
+  return IMPL->getModificationTime();
+}
+
+StringRef IndexUnitReader::getWorkingDirectory() const {
+  return IMPL->getWorkingDirectory();
+}
+
+StringRef IndexUnitReader::getOutputFile() const {
+  return IMPL->getOutputFile();
+}
+
+StringRef IndexUnitReader::getSysrootPath() const {
+  return IMPL->getSysrootPath();
+}
+
+StringRef IndexUnitReader::getMainFilePath() const {
+  return IMPL->getMainFilePath();
+}
+
+StringRef IndexUnitReader::getModuleName() const {
+  return IMPL->getModuleName();
+}
+
+StringRef IndexUnitReader::getTarget() const {
+  return IMPL->getTarget();
+}
+
+bool IndexUnitReader::hasMainFile() const {
+  return IMPL->hasMainFile();
+}
+
+bool IndexUnitReader::isSystemUnit() const {
+  return IMPL->isSystemUnit();
+}
+
+bool IndexUnitReader::isModuleUnit() const {
+  return IMPL->isModuleUnit();
+}
+
+bool IndexUnitReader::isDebugCompilation() const {
+  return IMPL->isDebugCompilation();
+}
+
+/// \c Index is the index in the \c getDependencies array.
+/// Unit dependencies are provided ahead of record ones.
+bool IndexUnitReader::foreachDependency(DependencyReceiver Receiver) {
+  return IMPL->foreachDependency(std::move(Receiver));
+}
+
+bool IndexUnitReader::foreachInclude(IncludeReceiver Receiver) {
+  return IMPL->foreachInclude(std::move(Receiver));
+}
diff --git a/lib/Index/IndexUnitWriter.cpp b/lib/Index/IndexUnitWriter.cpp
index e69de29bb2..7c981ae975 100644
--- a/lib/Index/IndexUnitWriter.cpp
+++ b/lib/Index/IndexUnitWriter.cpp
@@ -0,0 +1,628 @@
+//===--- IndexUnitWriter.cpp - Index unit serialization -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Index/IndexUnitWriter.h"
+#include "IndexDataStoreUtils.h"
+#include "clang/Basic/FileManager.h"
+#include "llvm/ADT/APInt.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/Hashing.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/Bitcode/BitstreamWriter.h"
+#include "llvm/Support/Allocator.h"
+#include "llvm/Support/Errc.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace clang::index::store;
+using namespace llvm;
+
+
+class IndexUnitWriter::PathStorage {
+  std::string WorkDir;
+  std::string SysrootPath;
+  SmallString<512> PathsBuf;
+  StringMap<DirBitPath, BumpPtrAllocator> Dirs;
+  std::vector<FileBitPath> FileBitPaths;
+  DenseMap<const FileEntry *, size_t> FileToIndex;
+
+public:
+  PathStorage(StringRef workDir, StringRef sysrootPath) {
+    WorkDir = workDir;
+    if (sysrootPath == "/")
+      sysrootPath = StringRef();
+    SysrootPath = sysrootPath;
+  }
+
+  StringRef getPathsBuffer() const { return PathsBuf.str(); }
+
+  ArrayRef<FileBitPath> getBitPaths() const { return FileBitPaths; }
+
+  int getPathIndex(const FileEntry *FE) {
+    if (!FE)
+      return -1;
+    auto Pair = FileToIndex.insert(std::make_pair(FE, FileBitPaths.size()));
+    bool IsNew = Pair.second;
+    size_t Index = Pair.first->getSecond();
+
+    if (IsNew) {
+      StringRef Filename = sys::path::filename(FE->getName());
+      DirBitPath Dir = getDirBitPath(sys::path::parent_path(FE->getName()));
+      FileBitPaths.emplace_back(Dir.PrefixKind, Dir.Dir,
+                                BitPathComponent(getPathOffset(Filename),
+                                                 Filename.size()));
+    }
+    return Index;
+  }
+
+  size_t getPathOffset(StringRef Path) {
+    if (Path.empty())
+      return 0;
+    size_t offset = PathsBuf.size();
+    PathsBuf += Path;
+    return offset;
+  }
+  
+private:
+  DirBitPath getDirBitPath(StringRef dirStr) {
+    auto pair = Dirs.insert(std::make_pair(dirStr, DirBitPath()));
+    bool isNew = pair.second;
+    auto &dirPath = pair.first->second;
+
+    if (isNew) {
+      if (isPathInDir(SysrootPath, dirStr)) {
+        dirPath.PrefixKind = UNIT_PATH_PREFIX_SYSROOT;
+        dirStr = dirStr.drop_front(SysrootPath.size());
+        while (!dirStr.empty() && dirStr[0] == '/')
+          dirStr = dirStr.drop_front();
+      } else if (isPathInDir(WorkDir, dirStr)) {
+        dirPath.PrefixKind = UNIT_PATH_PREFIX_WORKDIR;
+        dirStr = dirStr.drop_front(WorkDir.size());
+        while (!dirStr.empty() && dirStr[0] == '/')
+          dirStr = dirStr.drop_front();
+      }
+      dirPath.Dir.Offset = getPathOffset(dirStr);
+      dirPath.Dir.Size = dirStr.size();
+    }
+    return dirPath;
+  }
+
+  static bool isPathInDir(StringRef dir, StringRef path) {
+    if (dir.empty() || !path.startswith(dir))
+      return false;
+    StringRef rest = path.drop_front(dir.size());
+    return !rest.empty() && sys::path::is_separator(rest.front());
+  }
+};
+
+IndexUnitWriter::IndexUnitWriter(FileManager &FileMgr,
+                                 StringRef StorePath,
+                                 StringRef ProviderIdentifier,
+                                 StringRef ProviderVersion,
+                                 StringRef OutputFile,
+                                 StringRef ModuleName,
+                                 const FileEntry *MainFile,
+                                 bool IsSystem,
+                                 bool IsModuleUnit,
+                                 bool IsDebugCompilation,
+                                 StringRef TargetTriple,
+                                 StringRef SysrootPath,
+                                 writer::ModuleInfoWriterCallback GetInfoForModule)
+: FileMgr(FileMgr) {
+  this->UnitsPath = StorePath;
+  store::appendUnitSubDir(this->UnitsPath);
+  this->ProviderIdentifier = ProviderIdentifier;
+  this->ProviderVersion = ProviderVersion;
+  this->OutputFile = OutputFile;
+  this->ModuleName = ModuleName;
+  this->MainFile = MainFile;
+  this->IsSystemUnit = IsSystem;
+  this->IsModuleUnit = IsModuleUnit;
+  this->IsDebugCompilation = IsDebugCompilation;
+  this->TargetTriple = TargetTriple;
+  this->SysrootPath = SysrootPath;
+  this->GetInfoForModuleFn = GetInfoForModule;
+}
+
+IndexUnitWriter::~IndexUnitWriter() {}
+
+int IndexUnitWriter::addModule(writer::OpaqueModule Mod) {
+  if (!Mod)
+    return -1;
+
+  auto Pair = IndexByModule.insert(std::make_pair(Mod, Modules.size()));
+  bool WasInserted = Pair.second;
+  if (WasInserted) {
+    Modules.push_back(Mod);
+  }
+  return Pair.first->second;
+}
+
+int IndexUnitWriter::addFileDependency(const FileEntry *File, bool IsSystem,
+                                       writer::OpaqueModule Mod) {
+  assert(File);
+  auto Pair = IndexByFile.insert(std::make_pair(File, Files.size()));
+  bool WasInserted = Pair.second;
+  if (WasInserted) {
+    Files.push_back(FileEntryData{File, IsSystem, addModule(Mod), {}});
+  }
+  return Pair.first->second;
+}
+
+void IndexUnitWriter::addRecordFile(StringRef RecordFile, const FileEntry *File,
+                                    bool IsSystem, writer::OpaqueModule Mod) {
+  int Dep = File ? addFileDependency(File, IsSystem, /*module=*/nullptr) : -1;
+  Records.push_back(RecordOrUnitData{RecordFile, Dep, addModule(Mod), IsSystem});
+}
+
+void IndexUnitWriter::addASTFileDependency(const FileEntry *File, bool IsSystem,
+                                           writer::OpaqueModule Mod,
+                                           bool withoutUnitName) {
+  assert(File);
+  if (!SeenASTFiles.insert(File).second)
+    return;
+
+  SmallString<64> UnitName;
+  if (!withoutUnitName)
+    getUnitNameForOutputFile(File->getName(), UnitName);
+  addUnitDependency(UnitName.str(), File, IsSystem, Mod);
+}
+
+void IndexUnitWriter::addUnitDependency(StringRef UnitFile,
+                                        const FileEntry *File, bool IsSystem,
+                                        writer::OpaqueModule Mod) {
+  int Dep = File ? addFileDependency(File, IsSystem, /*module=*/nullptr) : -1;
+  ASTFileUnits.emplace_back(RecordOrUnitData{UnitFile, Dep, addModule(Mod), IsSystem});
+}
+
+bool IndexUnitWriter::addInclude(const FileEntry *Source, unsigned Line,
+                                 const FileEntry *Target) {
+  // FIXME: This will ignore includes of headers that resolve to module imports
+  // because the 'target' header has not been added as a file dependency earlier
+  // so it is missing from \c IndexByFile.
+
+  auto It = IndexByFile.find(Source);
+  if (It == IndexByFile.end())
+    return false;
+  int SourceIndex = It->getSecond();
+  It = IndexByFile.find(Target);
+  if (It == IndexByFile.end())
+    return false;
+  int TargetIndex = It->getSecond();
+  Files[SourceIndex].Includes.emplace_back(FileInclude{TargetIndex, Line});
+  return true;
+};
+
+void IndexUnitWriter::getUnitNameForOutputFile(StringRef FilePath,
+                                               SmallVectorImpl<char> &Str) {
+  SmallString<256> AbsPath(FilePath);
+  FileMgr.makeAbsolutePath(AbsPath);
+  return getUnitNameForAbsoluteOutputFile(AbsPath, Str);
+}
+
+void IndexUnitWriter::getUnitPathForOutputFile(StringRef FilePath,
+                                               SmallVectorImpl<char> &Str) {
+  Str.append(UnitsPath.begin(), UnitsPath.end());
+  Str.push_back('/');
+  return getUnitNameForOutputFile(FilePath, Str);
+}
+
+Optional<bool> IndexUnitWriter::isUnitUpToDateForOutputFile(StringRef FilePath,
+                                                            Optional<StringRef> TimeCompareFilePath,
+                                                            std::string &Error) {
+  SmallString<256> UnitPath;
+  getUnitPathForOutputFile(FilePath, UnitPath);
+
+  llvm::sys::fs::file_status UnitStat;
+  if (std::error_code EC = llvm::sys::fs::status(UnitPath.c_str(), UnitStat)) {
+    if (EC != llvm::errc::no_such_file_or_directory) {
+      llvm::raw_string_ostream Err(Error);
+      Err << "could not access path '" << UnitPath
+          << "': " << EC.message();
+      return None;
+    }
+    return false;
+  }
+
+  if (!TimeCompareFilePath.hasValue())
+    return true;
+
+  llvm::sys::fs::file_status CompareStat;
+  if (std::error_code EC = llvm::sys::fs::status(*TimeCompareFilePath, CompareStat)) {
+    if (EC != llvm::errc::no_such_file_or_directory) {
+      llvm::raw_string_ostream Err(Error);
+      Err << "could not access path '" << *TimeCompareFilePath
+          << "': " << EC.message();
+      return None;
+    }
+    return true;
+  }
+
+  // Return true (unit is up-to-date) if the file to compare is older than the
+  // unit file.
+  return CompareStat.getLastModificationTime() <= UnitStat.getLastModificationTime();
+}
+
+void IndexUnitWriter::getUnitNameForAbsoluteOutputFile(StringRef FilePath,
+                                                   SmallVectorImpl<char> &Str) {
+  StringRef Fname = sys::path::filename(FilePath);
+  Str.append(Fname.begin(), Fname.end());
+  Str.push_back('-');
+  llvm::hash_code PathHashVal = llvm::hash_value(FilePath);
+  llvm::APInt(64, PathHashVal).toString(Str, 36, /*Signed=*/false);
+}
+
+static void writeBlockInfo(BitstreamWriter &Stream) {
+  RecordData Record;
+
+  Stream.EnterBlockInfoBlock();
+#define BLOCK(X) emitBlockID(X ## _ID, #X, Stream, Record)
+#define RECORD(X) emitRecordID(X, #X, Stream, Record)
+
+  BLOCK(UNIT_VERSION_BLOCK);
+  RECORD(UNIT_VERSION);
+
+  BLOCK(UNIT_INFO_BLOCK);
+  RECORD(UNIT_INFO);
+
+  BLOCK(UNIT_DEPENDENCIES_BLOCK);
+  RECORD(UNIT_DEPENDENCY);
+
+  BLOCK(UNIT_INCLUDES_BLOCK);
+  RECORD(UNIT_INCLUDE);
+
+  BLOCK(UNIT_PATHS_BLOCK);
+  RECORD(UNIT_PATH);
+  RECORD(UNIT_PATH_BUFFER);
+
+  BLOCK(UNIT_MODULES_BLOCK);
+  RECORD(UNIT_MODULE);
+  RECORD(UNIT_MODULE_BUFFER);
+
+#undef RECORD
+#undef BLOCK
+  Stream.ExitBlock();
+}
+
+static void writeVersionInfo(BitstreamWriter &Stream) {
+  using namespace llvm::sys;
+
+  Stream.EnterSubblock(UNIT_VERSION_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(UNIT_VERSION));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 6)); // Store format version
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  RecordData Record;
+  Record.push_back(UNIT_VERSION);
+  Record.push_back(STORE_FORMAT_VERSION);
+  Stream.EmitRecordWithAbbrev(AbbrevCode, Record);
+
+  Stream.ExitBlock();
+}
+
+bool IndexUnitWriter::write(std::string &Error) {
+  using namespace llvm::sys;
+
+  // Determine the working directory.
+  SmallString<128> CWDPath;
+  if (!FileMgr.getFileSystemOpts().WorkingDir.empty()) {
+    CWDPath = FileMgr.getFileSystemOpts().WorkingDir;
+    if (!path::is_absolute(CWDPath)) {
+      fs::make_absolute(CWDPath);
+    }
+  } else {
+    std::error_code EC = sys::fs::current_path(CWDPath);
+    if (EC) {
+      llvm::raw_string_ostream Err(Error);
+      Err << "failed to determine current working directory: " << EC.message();
+      return true;
+    }
+  }
+  WorkDir = CWDPath.str();
+
+  SmallString<512> Buffer;
+  BitstreamWriter Stream(Buffer);
+  Stream.Emit('I', 8);
+  Stream.Emit('D', 8);
+  Stream.Emit('X', 8);
+  Stream.Emit('U', 8);
+
+  PathStorage PathStore(WorkDir, SysrootPath);
+
+  writeBlockInfo(Stream);
+  writeVersionInfo(Stream);
+  writeUnitInfo(Stream, PathStore);
+  writeDependencies(Stream, PathStore);
+  writeIncludes(Stream, PathStore);
+  writePaths(Stream, PathStore);
+  writeModules(Stream);
+
+  SmallString<256> UnitPath;
+  getUnitPathForOutputFile(OutputFile, UnitPath);
+
+  SmallString<128> TempPath;
+  TempPath = path::parent_path(UnitsPath);
+  TempPath += '/';
+  TempPath += path::filename(UnitPath);
+  TempPath += "-%%%%%%%%";
+  int TempFD;
+  if (llvm::sys::fs::createUniqueFile(TempPath.str(), TempFD, TempPath)) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to create temporary file: " << TempPath;
+    return true;
+  }
+
+  raw_fd_ostream OS(TempFD, /*shouldClose=*/true);
+  OS.write(Buffer.data(), Buffer.size());
+  OS.close();
+
+  std::error_code EC = fs::rename(/*from=*/TempPath.c_str(), /*to=*/UnitPath.c_str());
+  if (EC) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to rename '" << TempPath << "' to '" << UnitPath << "': " << EC.message();
+    return true;
+  }
+
+  return false;
+}
+
+void IndexUnitWriter::writeUnitInfo(llvm::BitstreamWriter &Stream,
+                                    PathStorage &PathStore) {
+  Stream.EnterSubblock(UNIT_INFO_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(UNIT_INFO));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsSystemUnit
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // WorkDir offset
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // WorkDir size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // OutputFile offset
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // OutputFile size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // Sysroot offset
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // Sysroot size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // Main path id
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsDebugCompilation
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsModuleUnit
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // Module name size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // ProviderIdentifier size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // ProviderVersion size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 5)); // ProviderDataVersion
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Blob)); // Module name + ProviderIdentifier + ProviderVersion + target triple
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  RecordData Record;
+  Record.push_back(UNIT_INFO);
+  Record.push_back(IsSystemUnit);
+  Record.push_back(PathStore.getPathOffset(WorkDir));
+  Record.push_back(WorkDir.size());
+  Record.push_back(PathStore.getPathOffset(OutputFile));
+  Record.push_back(OutputFile.size());
+  Record.push_back(PathStore.getPathOffset(SysrootPath));
+  Record.push_back(SysrootPath.size());
+  Record.push_back(PathStore.getPathIndex(MainFile) + 1); // Make 1-based with 0=invalid
+  Record.push_back(IsDebugCompilation);
+  Record.push_back(IsModuleUnit);
+  Record.push_back(ModuleName.size());
+  Record.push_back(ProviderIdentifier.size());
+  Record.push_back(ProviderVersion.size());
+  // ProviderDataVersion is reserved. Not sure it is a good to idea to have
+  // clients consider the specifics of a 'provider data version', but reserving
+  // to avoid store format version change in case there is a use case in the
+  // future.
+  Record.push_back(0); // ProviderDataVersion
+  SmallString<128> InfoStrings;
+  InfoStrings += ModuleName;
+  InfoStrings += ProviderIdentifier;
+  InfoStrings += ProviderVersion;
+  InfoStrings += TargetTriple;
+  Stream.EmitRecordWithBlob(AbbrevCode, Record, InfoStrings);
+
+  Stream.ExitBlock();
+}
+
+void IndexUnitWriter::writeDependencies(llvm::BitstreamWriter &Stream,
+                                        PathStorage &PathStore) {
+  std::vector<bool> FileUsedForRecordOrUnit;
+  FileUsedForRecordOrUnit.resize(Files.size());
+
+  Stream.EnterSubblock(UNIT_DEPENDENCIES_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(UNIT_DEPENDENCY));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, UnitDependencyKindBitNum)); // Dependency kind
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsSystem
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // PathIndex (1-based, 0 = none)
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // ModuleIndex (1-based, 0 = none)
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 32)); // time_t
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 16)); // file size
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Blob)); // Name
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  RecordData Record;
+
+  auto addRecordOrUnitData = [&](UnitDependencyKind K, const RecordOrUnitData &Data) {
+    Record.push_back(UNIT_DEPENDENCY);
+    Record.push_back(K);
+    Record.push_back(Data.IsSystem);
+    if (Data.FileIndex != -1) {
+      Record.push_back(PathStore.getPathIndex(Files[Data.FileIndex].File) + 1);
+      FileUsedForRecordOrUnit[Data.FileIndex] = true;
+    } else {
+      Record.push_back(0);
+    }
+    if (Data.ModuleIndex != -1) {
+      Record.push_back(Data.ModuleIndex + 1);
+    } else {
+      Record.push_back(0);
+    }
+    if (Data.FileIndex != -1) {
+      Record.push_back(Files[Data.FileIndex].File->getModificationTime());
+      Record.push_back(Files[Data.FileIndex].File->getSize());
+    } else {
+      Record.push_back(0);
+      Record.push_back(0);
+    }
+    Stream.EmitRecordWithBlob(AbbrevCode, Record, Data.Name);
+  };
+
+  for (auto &ASTData : ASTFileUnits) {
+    Record.clear();
+    addRecordOrUnitData(UNIT_DEPEND_KIND_UNIT, ASTData);
+  }
+  for (auto &recordData : Records) {
+    Record.clear();
+    addRecordOrUnitData(UNIT_DEPEND_KIND_RECORD, recordData);
+  }
+  size_t FileIndex = 0;
+  for (auto &File : Files) {
+    if (FileUsedForRecordOrUnit[FileIndex++])
+      continue;
+    Record.clear();
+    Record.push_back(UNIT_DEPENDENCY);
+    Record.push_back(UNIT_DEPEND_KIND_FILE);
+    Record.push_back(File.IsSystem);
+    Record.push_back(PathStore.getPathIndex(File.File) + 1);
+    if (File.ModuleIndex != -1) {
+      Record.push_back(File.ModuleIndex + 1);
+    } else {
+      Record.push_back(0);
+    }
+    Record.push_back(File.File->getModificationTime());
+    Record.push_back(File.File->getSize());
+    Stream.EmitRecordWithBlob(AbbrevCode, Record, StringRef());
+  }
+
+  Stream.ExitBlock();
+}
+
+void IndexUnitWriter::writeIncludes(llvm::BitstreamWriter &Stream,
+                                    PathStorage &PathStore) {
+  Stream.EnterSubblock(UNIT_INCLUDES_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(UNIT_INCLUDE));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // source path index (1-based, 0 = no path)
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 12)); // source include line
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // target path index (1-based, 0 = no path)
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  RecordData Record;
+
+  for (auto &Including : Files) {
+    for(auto &Included: Including.Includes) {
+      Record.clear();
+      Record.push_back(UNIT_INCLUDE);
+      Record.push_back(PathStore.getPathIndex(Including.File) + 1);
+      Record.push_back(Included.Line);
+      Record.push_back(PathStore.getPathIndex(Files[Included.Index].File) + 1);
+      Stream.EmitRecordWithAbbrev(AbbrevCode, Record);
+    }
+  }
+  Stream.ExitBlock();
+}
+
+void IndexUnitWriter::writePaths(llvm::BitstreamWriter &Stream,
+                                 PathStorage &PathStore) {
+  Stream.EnterSubblock(UNIT_PATHS_BLOCK_ID, 3);
+
+  auto PathAbbrev = std::make_shared<BitCodeAbbrev>();
+  PathAbbrev->Add(BitCodeAbbrevOp(UNIT_PATH));
+  PathAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, UnitFilePathPrefixKindBitNum)); // Path prefix kind
+  PathAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // DirPath offset
+  PathAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 8)); // DirPath size
+  PathAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 10)); // Filename offset
+  PathAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 6)); // Filename size
+  unsigned PathAbbrevCode = Stream.EmitAbbrev(std::move(PathAbbrev));
+
+  auto PathBufferAbbrev = std::make_shared<BitCodeAbbrev>();
+  PathBufferAbbrev->Add(BitCodeAbbrevOp(UNIT_PATH_BUFFER));
+  PathBufferAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Blob)); // Paths buffer
+  unsigned PathBufferAbbrevCode = Stream.EmitAbbrev(PathBufferAbbrev);
+
+  RecordData Record;
+  for(auto &BitPath: PathStore.getBitPaths()) {
+    Record.push_back(UNIT_PATH);
+    Record.push_back(BitPath.PrefixKind);
+    Record.push_back(BitPath.Dir.Offset);
+    Record.push_back(BitPath.Dir.Size);
+    Record.push_back(BitPath.Filename.Offset);
+    Record.push_back(BitPath.Filename.Size);
+    Stream.EmitRecordWithAbbrev(PathAbbrevCode, Record);
+    Record.clear();
+  }
+
+  Record.push_back(UNIT_PATH_BUFFER);
+  Stream.EmitRecordWithBlob(PathBufferAbbrevCode, Record, PathStore.getPathsBuffer());
+
+  Stream.ExitBlock();
+}
+
+void IndexUnitWriter::writeModules(llvm::BitstreamWriter &Stream) {
+  Stream.EnterSubblock(UNIT_MODULES_BLOCK_ID, 3);
+
+  auto Abbrev = std::make_shared<BitCodeAbbrev>();
+  Abbrev->Add(BitCodeAbbrevOp(UNIT_MODULE));
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 9)); // Module name offset
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::VBR, 6)); // Module name size
+  unsigned AbbrevCode = Stream.EmitAbbrev(std::move(Abbrev));
+
+  auto BufferAbbrev = std::make_shared<BitCodeAbbrev>();
+  BufferAbbrev->Add(BitCodeAbbrevOp(UNIT_MODULE_BUFFER));
+  BufferAbbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Blob)); // Module names buffer
+  unsigned BufferAbbrevCode = Stream.EmitAbbrev(BufferAbbrev);
+
+  SmallString<512> ModuleNamesBuf;
+
+  RecordData Record;
+  for (auto &Mod : Modules) {
+    SmallString<64> ModuleName;
+    StringRef name = GetInfoForModuleFn(Mod, ModuleName).Name;
+    size_t offset = ModuleNamesBuf.size();
+    ModuleNamesBuf += name;
+
+    Record.push_back(UNIT_MODULE);
+    Record.push_back(offset);
+    Record.push_back(name.size());
+    Stream.EmitRecordWithAbbrev(AbbrevCode, Record);
+    Record.clear();
+  }
+
+  Record.push_back(UNIT_MODULE_BUFFER);
+  Stream.EmitRecordWithBlob(BufferAbbrevCode, Record, ModuleNamesBuf.str());
+
+  Stream.ExitBlock();
+}
+
+bool IndexUnitWriter::initIndexDirectory(StringRef StorePath,
+                                         std::string &Error) {
+  using namespace llvm::sys;
+  SmallString<128> SubPath = StorePath;
+  store::appendRecordSubDir(SubPath);
+  std::error_code EC = fs::create_directories(SubPath);
+  if (EC) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to create directory '" << SubPath << "': " << EC.message();
+    return true;
+  }
+
+  SubPath = StorePath;
+  store::appendUnitSubDir(SubPath);
+  EC = fs::create_directory(SubPath);
+  if (EC) {
+    llvm::raw_string_ostream Err(Error);
+    Err << "failed to create directory '" << SubPath << "': " << EC.message();
+    return true;
+  }
+
+  return false;
+}
diff --git a/lib/Index/IndexingAction.cpp b/lib/Index/IndexingAction.cpp
index 411657bf3d..28dedea6a7 100644
--- a/lib/Index/IndexingAction.cpp
+++ b/lib/Index/IndexingAction.cpp
@@ -8,10 +8,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "clang/Index/IndexingAction.h"
+#include "FileIndexRecord.h"
 #include "IndexingContext.h"
+#include "ClangIndexRecordWriter.h"
+#include "IndexDataStoreUtils.h"
+#include "clang/Index/IndexUnitWriter.h"
 #include "clang/Frontend/CompilerInstance.h"
 #include "clang/Frontend/FrontendAction.h"
+#include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Frontend/MultiplexConsumer.h"
+#include "clang/Frontend/Utils.h"
 #include "clang/Index/IndexDataConsumer.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Serialization/ASTReader.h"
@@ -85,6 +91,7 @@ protected:
 
   std::unique_ptr<IndexASTConsumer>
   createIndexASTConsumer(CompilerInstance &CI) {
+    IndexCtx.setSysrootPath(CI.getHeaderSearchOpts().Sysroot);
     return llvm::make_unique<IndexASTConsumer>(CI.getPreprocessorPtr(),
                                                IndexCtx);
   }
@@ -113,7 +120,7 @@ protected:
 };
 
 class WrappingIndexAction : public WrapperFrontendAction, IndexActionBase {
-  bool IndexActionFailed = false;
+  bool CreatedASTConsumer = false;
 
 public:
   WrappingIndexAction(std::unique_ptr<FrontendAction> WrappedAction,
@@ -133,18 +140,17 @@ protected:
 void WrappingIndexAction::EndSourceFileAction() {
   // Invoke wrapped action's method.
   WrapperFrontendAction::EndSourceFileAction();
-  if (!IndexActionFailed)
+  if (CreatedASTConsumer)
     finish();
 }
 
 std::unique_ptr<ASTConsumer>
 WrappingIndexAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
   auto OtherConsumer = WrapperFrontendAction::CreateASTConsumer(CI, InFile);
-  if (!OtherConsumer) {
-    IndexActionFailed = true;
+  if (!OtherConsumer)
     return nullptr;
-  }
 
+  CreatedASTConsumer = true;
   std::vector<std::unique_ptr<ASTConsumer>> Consumers;
   Consumers.push_back(std::move(OtherConsumer));
   Consumers.push_back(createIndexASTConsumer(CI));
@@ -209,3 +215,629 @@ void index::indexModuleFile(serialization::ModuleFile &Mod,
   }
   DataConsumer->finish();
 }
+
+//===----------------------------------------------------------------------===//
+// Index Data Recording
+//===----------------------------------------------------------------------===//
+
+namespace {
+
+class IndexDataRecorder : public IndexDataConsumer {
+  IndexingContext *IndexCtx = nullptr;
+  const Preprocessor *PP = nullptr;
+  typedef llvm::DenseMap<FileID, std::unique_ptr<FileIndexRecord>> RecordByFileTy;
+  RecordByFileTy RecordByFile;
+
+public:
+  void init(IndexingContext *idxCtx, const CompilerInstance &CI) {
+    IndexCtx = idxCtx;
+    PP = &CI.getPreprocessor();
+    initialize(CI.getASTContext());
+  }
+
+  RecordByFileTy::const_iterator record_begin() const { return RecordByFile.begin(); }
+  RecordByFileTy::const_iterator record_end() const { return RecordByFile.end(); }
+  bool record_empty() const { return RecordByFile.empty(); }
+
+private:
+  bool handleDeclOccurence(const Decl *D, SymbolRoleSet Roles,
+                           ArrayRef<SymbolRelation> Relations,
+                           FileID FID, unsigned Offset,
+                           ASTNodeInfo ASTNode) override {
+    // Ignore the predefines buffer.
+    if (FID == PP->getPredefinesFileID())
+      return true;
+
+    FileIndexRecord &Rec = getFileIndexRecord(FID);
+    Rec.addDeclOccurence(Roles, Offset, D, Relations);
+    return true;
+  }
+
+  FileIndexRecord &getFileIndexRecord(FileID FID) {
+    auto &Entry = RecordByFile[FID];
+    if (!Entry) {
+      Entry.reset(new FileIndexRecord(FID, IndexCtx->isSystemFile(FID)));
+    }
+    return *Entry;
+  }
+};
+
+struct IncludeLocation {
+  const FileEntry *Source;
+  const FileEntry *Target;
+  unsigned Line;
+};
+
+class IncludePPCallbacks : public PPCallbacks {
+  IndexingContext &IndexCtx;
+  RecordingOptions RecordOpts;
+  std::vector<IncludeLocation> &Includes;
+  SourceManager &SourceMgr;
+
+public:
+  IncludePPCallbacks(IndexingContext &indexCtx, RecordingOptions recordOpts,
+                     std::vector<IncludeLocation> &IncludesForFile,
+                     SourceManager &SourceMgr) :
+    IndexCtx(indexCtx), RecordOpts(recordOpts),
+    Includes(IncludesForFile), SourceMgr(SourceMgr) {}
+
+private:
+  void addInclude(SourceLocation From, const FileEntry *To) {
+    assert(To);
+    if (RecordOpts.RecordIncludes == RecordingOptions::IncludesRecordingKind::None)
+      return;
+
+    std::pair<FileID, unsigned> LocInfo = SourceMgr.getDecomposedExpansionLoc(From);
+    switch (RecordOpts.RecordIncludes) {
+      case RecordingOptions::IncludesRecordingKind::None:
+        llvm_unreachable("should have already checked in the beginning");
+      case RecordingOptions::IncludesRecordingKind::UserOnly:
+        if (IndexCtx.isSystemFile(LocInfo.first))
+          return; // Ignore includes of system headers.
+        break;
+      case RecordingOptions::IncludesRecordingKind::All:
+        break;
+    }
+    auto *FE = SourceMgr.getFileEntryForID(LocInfo.first);
+    if (!FE)
+      return;
+    auto lineNo = SourceMgr.getLineNumber(LocInfo.first, LocInfo.second);
+    Includes.push_back({FE, To, lineNo});
+  }
+
+  virtual void InclusionDirective(SourceLocation HashLoc,
+                                  const Token &IncludeTok,
+                                  StringRef FileName,
+                                  bool IsAngled,
+                                  CharSourceRange FilenameRange,
+                                  const FileEntry *File,
+                                  StringRef SearchPath,
+                                  StringRef RelativePath,
+                                  const Module *Imported) override {
+    if (HashLoc.isFileID() && File && File->isValid())
+      addInclude(HashLoc, File);
+  }
+};
+
+class IndexDependencyProvider {
+public:
+  virtual ~IndexDependencyProvider() {}
+
+  virtual void visitFileDependencies(const CompilerInstance &CI,
+      llvm::function_ref<void(const FileEntry *FE, bool isSystem)> visitor) = 0;
+  virtual void visitIncludes(
+                 llvm::function_ref<void(const FileEntry *Source, unsigned Line,
+                                         const FileEntry *Target)> visitor) = 0;
+  virtual void visitModuleImports(const CompilerInstance &CI,
+                 llvm::function_ref<void(serialization::ModuleFile &Mod,
+                                         bool isSystem)> visitor) = 0;
+};
+
+class SourceFilesIndexDependencyCollector : public DependencyCollector, public IndexDependencyProvider {
+  IndexingContext &IndexCtx;
+  RecordingOptions RecordOpts;
+  llvm::SetVector<const FileEntry *> Entries;
+  llvm::BitVector IsSystemByUID;
+  std::vector<IncludeLocation> Includes;
+  SourceManager *SourceMgr = nullptr;
+  std::string SysrootPath;
+
+public:
+  SourceFilesIndexDependencyCollector(IndexingContext &indexCtx, RecordingOptions recordOpts)
+    : IndexCtx(indexCtx), RecordOpts(recordOpts) {}
+
+  virtual void attachToPreprocessor(Preprocessor &PP) override {
+    DependencyCollector::attachToPreprocessor(PP);
+    PP.addPPCallbacks(llvm::make_unique<IncludePPCallbacks>(IndexCtx,
+                                                            RecordOpts,
+                                                            Includes,
+                                                            PP.getSourceManager()));
+  }
+
+  void setSourceManager(SourceManager *SourceMgr) {
+    this->SourceMgr = SourceMgr;
+  }
+  void setSysrootPath(StringRef sysroot) { SysrootPath = sysroot; }
+
+  void visitFileDependencies(const CompilerInstance &CI,
+      llvm::function_ref<void(const FileEntry *FE, bool isSystem)> visitor) override {
+    for (auto *FE : getEntries()) {
+      visitor(FE, isSystemFile(FE));
+    }
+  }
+
+  void visitIncludes(
+                 llvm::function_ref<void(const FileEntry *Source, unsigned Line,
+                                         const FileEntry *Target)> visitor) override {
+    for (auto &Include : Includes) {
+      visitor(Include.Source, Include.Line, Include.Target);
+    }
+  }
+
+  void visitModuleImports(const CompilerInstance &CI,
+                 llvm::function_ref<void(serialization::ModuleFile &Mod,
+                                         bool isSystem)> visitor) override {
+    HeaderSearch &HS = CI.getPreprocessor().getHeaderSearchInfo();
+
+    if (auto Reader = CI.getModuleManager()) {
+      Reader->getModuleManager().visit([&](serialization::ModuleFile &Mod) -> bool {
+        bool isSystemMod = false;
+        if (Mod.isModule()) {
+          if (auto *M = HS.lookupModule(Mod.ModuleName, /*AllowSearch=*/false))
+            isSystemMod = M->IsSystem;
+        }
+        if (!isSystemMod || needSystemDependencies())
+          visitor(Mod, isSystemMod);
+        return true; // skip module dependencies.
+      });
+    }
+  }
+
+private:
+  bool isSystemFile(const FileEntry *FE) {
+    auto UID = FE->getUID();
+    return IsSystemByUID.size() > UID && IsSystemByUID[UID];
+  }
+
+  ArrayRef<const FileEntry *> getEntries() const {
+    return Entries.getArrayRef();
+  }
+
+  bool needSystemDependencies() override {
+    return RecordOpts.RecordSystemDependencies;
+  }
+
+  bool sawDependency(StringRef Filename, bool FromModule,
+                     bool IsSystem, bool IsModuleFile, bool IsMissing) override {
+    bool sawIt = DependencyCollector::sawDependency(Filename, FromModule,
+                                                    IsSystem, IsModuleFile,
+                                                    IsMissing);
+    if (auto *FE = SourceMgr->getFileManager().getFile(Filename)) {
+      if (sawIt)
+        Entries.insert(FE);
+      // Record system-ness for all files that we pass through.
+      if (IsSystemByUID.size() < FE->getUID()+1)
+        IsSystemByUID.resize(FE->getUID()+1);
+        IsSystemByUID[FE->getUID()] = IsSystem || isInSysroot(Filename);
+    }
+    return sawIt;
+  }
+
+  bool isInSysroot(StringRef Filename) {
+    return !SysrootPath.empty() && Filename.startswith(SysrootPath);
+  }
+};
+
+class IndexRecordActionBase {
+protected:
+  RecordingOptions RecordOpts;
+  IndexDataRecorder Recorder;
+  IndexingContext IndexCtx;
+  SourceFilesIndexDependencyCollector DepCollector;
+
+  IndexRecordActionBase(IndexingOptions IndexOpts, RecordingOptions recordOpts)
+    : RecordOpts(std::move(recordOpts)),
+      IndexCtx(IndexOpts, Recorder),
+      DepCollector(IndexCtx, RecordOpts) {
+  }
+
+  std::unique_ptr<IndexASTConsumer>
+  createIndexASTConsumer(CompilerInstance &CI) {
+    IndexCtx.setSysrootPath(CI.getHeaderSearchOpts().Sysroot);
+    Recorder.init(&IndexCtx, CI);
+
+    Preprocessor &PP = CI.getPreprocessor();
+    DepCollector.setSourceManager(&CI.getSourceManager());
+    DepCollector.setSysrootPath(IndexCtx.getSysrootPath());
+    DepCollector.attachToPreprocessor(PP);
+
+    return llvm::make_unique<IndexASTConsumer>(CI.getPreprocessorPtr(),
+                                               IndexCtx);
+  }
+
+  void finish(CompilerInstance &CI);
+};
+
+class IndexRecordAction : public ASTFrontendAction, IndexRecordActionBase {
+public:
+  IndexRecordAction(IndexingOptions IndexOpts, RecordingOptions RecordOpts)
+    : IndexRecordActionBase(std::move(IndexOpts), std::move(RecordOpts)) {}
+
+protected:
+  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
+                                                 StringRef InFile) override {
+    return createIndexASTConsumer(CI);
+  }
+
+  void EndSourceFileAction() override {
+    FrontendAction::EndSourceFileAction();
+    finish(getCompilerInstance());
+  }
+};
+
+class WrappingIndexRecordAction : public WrapperFrontendAction, IndexRecordActionBase {
+  bool CreatedASTConsumer = false;
+
+public:
+  WrappingIndexRecordAction(std::unique_ptr<FrontendAction> WrappedAction,
+                            IndexingOptions IndexOpts,
+                            RecordingOptions RecordOpts)
+    : WrapperFrontendAction(std::move(WrappedAction)),
+      IndexRecordActionBase(std::move(IndexOpts), std::move(RecordOpts)) {}
+
+protected:
+  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
+                                                 StringRef InFile) override {
+    auto OtherConsumer = WrapperFrontendAction::CreateASTConsumer(CI, InFile);
+    if (!OtherConsumer)
+      return nullptr;
+
+    CreatedASTConsumer = true;
+    std::vector<std::unique_ptr<ASTConsumer>> Consumers;
+    Consumers.push_back(std::move(OtherConsumer));
+    Consumers.push_back(createIndexASTConsumer(CI));
+    return llvm::make_unique<MultiplexConsumer>(std::move(Consumers));
+  }
+
+  void EndSourceFileAction() override {
+    // Invoke wrapped action's method.
+    WrapperFrontendAction::EndSourceFileAction();
+    if (CreatedASTConsumer)
+      finish(getCompilerInstance());
+  }
+};
+
+} // anonymous namespace
+
+static std::string getClangVersion() {
+  // Try picking the version from an Apple Clang tag.
+  std::string RepositoryPath = getClangRepositoryPath();
+  StringRef BuildNumber = StringRef(RepositoryPath);
+  size_t DashOffset = BuildNumber.find('-');
+  if (BuildNumber.startswith("clang") && DashOffset != StringRef::npos) {
+    BuildNumber = BuildNumber.substr(DashOffset + 1);
+    return BuildNumber;
+  }
+  // Fallback to the generic version.
+  return CLANG_VERSION_STRING;
+}
+
+static void writeUnitData(const CompilerInstance &CI,
+                          IndexDataRecorder &Recorder,
+                          IndexDependencyProvider &DepProvider,
+                          IndexingOptions IndexOpts,
+                          RecordingOptions RecordOpts,
+                          StringRef OutputFile,
+                          const FileEntry *RootFile,
+                          Module *UnitModule,
+                          StringRef SysrootPath);
+
+void IndexRecordActionBase::finish(CompilerInstance &CI) {
+  // We may emit more diagnostics so do the begin/end source file invocations
+  // on the diagnostic client.
+  // FIXME: FrontendAction::EndSourceFile() should probably not call
+  // CI.getDiagnosticClient().EndSourceFile()' until after it has called
+  // 'EndSourceFileAction()', so that code executing during EndSourceFileAction()
+  // can emit diagnostics. If this is fixed, DiagClientBeginEndRAII can go away.
+  struct DiagClientBeginEndRAII {
+    CompilerInstance &CI;
+    DiagClientBeginEndRAII(CompilerInstance &CI) : CI(CI) {
+      CI.getDiagnosticClient().BeginSourceFile(CI.getLangOpts());
+    }
+    ~DiagClientBeginEndRAII() {
+      CI.getDiagnosticClient().EndSourceFile();
+    }
+  } diagClientBeginEndRAII(CI);
+
+  SourceManager &SM = CI.getSourceManager();
+  DiagnosticsEngine &Diag = CI.getDiagnostics();
+  HeaderSearch &HS = CI.getPreprocessor().getHeaderSearchInfo();
+  StringRef DataPath = RecordOpts.DataDirPath;
+
+  std::string Error;
+  if (IndexUnitWriter::initIndexDirectory(DataPath, Error)) {
+    unsigned DiagID = Diag.getCustomDiagID(
+        DiagnosticsEngine::Error, "failed creating index directory %0");
+    Diag.Report(DiagID) << Error;
+    return;
+  }
+
+  std::string OutputFile = CI.getFrontendOpts().OutputFile;
+  if (OutputFile.empty()) {
+    OutputFile = CI.getFrontendOpts().Inputs[0].getFile();
+    OutputFile += ".o";
+  }
+
+  const FileEntry *RootFile = nullptr;
+  Module *UnitMod = nullptr;
+  bool isModuleGeneration = CI.getLangOpts().isCompilingModule();
+  if (!isModuleGeneration &&
+      CI.getFrontendOpts().ProgramAction != frontend::GeneratePCH) {
+    RootFile = SM.getFileEntryForID(SM.getMainFileID());
+  }
+  if (isModuleGeneration) {
+    UnitMod = HS.lookupModule(CI.getLangOpts().CurrentModule,
+                              /*AllowSearch=*/false);
+  }
+
+  writeUnitData(CI, Recorder, DepCollector, IndexCtx.getIndexOpts(), RecordOpts,
+                OutputFile, RootFile, UnitMod,
+                IndexCtx.getSysrootPath());
+}
+
+/// Checks if the unit file exists for module file, if it doesn't it generates
+/// index data for it.
+static bool produceIndexDataForModuleFile(
+                                      serialization::ModuleFile &Mod,
+                                      const CompilerInstance &CI,
+                                      IndexingOptions IndexOpts,
+                                      RecordingOptions RecordOpts,
+                                      IndexUnitWriter &ParentUnitWriter);
+
+static void writeUnitData(const CompilerInstance &CI,
+                          IndexDataRecorder &Recorder,
+                          IndexDependencyProvider &DepProvider,
+                          IndexingOptions IndexOpts,
+                          RecordingOptions RecordOpts,
+                          StringRef OutputFile,
+                          const FileEntry *RootFile,
+                          Module *UnitModule,
+                          StringRef SysrootPath) {
+
+  SourceManager &SM = CI.getSourceManager();
+  DiagnosticsEngine &Diag = CI.getDiagnostics();
+  HeaderSearch &HS = CI.getPreprocessor().getHeaderSearchInfo();
+  StringRef DataPath = RecordOpts.DataDirPath;
+  bool IsSystemUnit = UnitModule ? UnitModule->IsSystem : false;
+  bool IsModuleUnit = UnitModule != nullptr;
+  bool IsDebugCompilation = CI.getCodeGenOpts().OptimizationLevel == 0;
+  std::string ModuleName = UnitModule ? UnitModule->getFullModuleName() : std::string();
+
+  auto getModuleInfo = [](writer::OpaqueModule mod, SmallVectorImpl<char> &Scratch) -> writer::ModuleInfo {
+    assert(mod);
+    writer::ModuleInfo info;
+    std::string fullName = static_cast<const Module*>(mod)->getFullModuleName();
+    unsigned offset = Scratch.size();
+    Scratch.append(fullName.begin(), fullName.end());
+    info.Name = StringRef(Scratch.data()+offset, fullName.size());
+    return info;
+  };
+
+  auto findModuleForHeader = [&](const FileEntry *FE) -> Module * {
+    if (!UnitModule)
+      return nullptr;
+    if (auto Mod = HS.findModuleForHeader(FE).getModule())
+      if (Mod->isSubModuleOf(UnitModule))
+        return Mod;
+    return nullptr;
+  };
+
+  IndexUnitWriter UnitWriter(CI.getFileManager(),
+                             DataPath,
+                             "clang", getClangVersion(),
+                             OutputFile,
+                             ModuleName,
+                             RootFile,
+                             IsSystemUnit,
+                             IsModuleUnit,
+                             IsDebugCompilation,
+                             CI.getTargetOpts().Triple,
+                             SysrootPath,
+                             getModuleInfo);
+
+  DepProvider.visitFileDependencies(CI, [&](const FileEntry *FE, bool isSystemFile) {
+    UnitWriter.addFileDependency(FE, isSystemFile, findModuleForHeader(FE));
+  });
+  DepProvider.visitIncludes([&](const FileEntry *Source, unsigned Line, const FileEntry *Target) {
+    UnitWriter.addInclude(Source, Line, Target);
+  });
+  DepProvider.visitModuleImports(CI, [&](serialization::ModuleFile &Mod, bool isSystemMod) {
+    Module *UnitMod = HS.lookupModule(Mod.ModuleName, /*AllowSearch=*/false);
+    UnitWriter.addASTFileDependency(Mod.File, isSystemMod, UnitMod);
+    if (Mod.isModule()) {
+      produceIndexDataForModuleFile(Mod, CI, IndexOpts, RecordOpts, UnitWriter);
+    }
+  });
+
+  ClangIndexRecordWriter RecordWriter(CI.getASTContext(), RecordOpts);
+  for (auto I = Recorder.record_begin(), E = Recorder.record_end(); I != E; ++I) {
+    FileID FID = I->first;
+    const FileIndexRecord &Rec = *I->second;
+    const FileEntry *FE = SM.getFileEntryForID(FID);
+    std::string RecordFile;
+    std::string Error;
+
+    if (RecordWriter.writeRecord(FE->getName(), Rec, Error, &RecordFile)) {
+      unsigned DiagID = Diag.getCustomDiagID(DiagnosticsEngine::Error,
+                                             "failed writing record '%0': %1");
+      Diag.Report(DiagID) << RecordFile << Error;
+      return;
+    }
+    UnitWriter.addRecordFile(RecordFile, FE, Rec.isSystem(),
+                             findModuleForHeader(FE));
+  }
+
+  std::string Error;
+  if (UnitWriter.write(Error)) {
+    unsigned DiagID = Diag.getCustomDiagID(DiagnosticsEngine::Error,
+                                           "failed writing unit data: %0");
+    Diag.Report(DiagID) << Error;
+    return;
+  }
+}
+
+namespace {
+class ModuleFileIndexDependencyCollector : public IndexDependencyProvider {
+  serialization::ModuleFile &ModFile;
+  RecordingOptions RecordOpts;
+
+public:
+  ModuleFileIndexDependencyCollector(serialization::ModuleFile &Mod,
+                                     RecordingOptions recordOpts)
+  : ModFile(Mod), RecordOpts(recordOpts) {}
+
+  void visitFileDependencies(const CompilerInstance &CI,
+      llvm::function_ref<void(const FileEntry *FE, bool isSystem)> visitor) override {
+    auto Reader = CI.getModuleManager();
+    Reader->visitInputFiles(ModFile, RecordOpts.RecordSystemDependencies,
+                            /*Complain=*/false,
+                        [&](const serialization::InputFile &IF, bool isSystem) {
+      auto *FE = IF.getFile();
+      if (!FE)
+        return;
+      // Ignore module map files, they are not as important to track as source
+      // files and they may be auto-generated which would create an undesirable
+      // dependency on an intermediate build byproduct.
+      if (FE->getName().endswith("module.modulemap"))
+        return;
+
+      visitor(FE, isSystem);
+    });
+  }
+
+  void visitIncludes(
+           llvm::function_ref<void(const FileEntry *Source, unsigned Line,
+                                   const FileEntry *Target)> visitor) override {
+   // FIXME: Module files without a preprocessing record do not have info about
+   // include locations. Serialize enough data to be able to retrieve such info.
+  }
+
+  void visitModuleImports(const CompilerInstance &CI,
+                 llvm::function_ref<void(serialization::ModuleFile &Mod,
+                                         bool isSystem)> visitor) override {
+    HeaderSearch &HS = CI.getPreprocessor().getHeaderSearchInfo();
+    for (auto *Mod : ModFile.Imports) {
+      bool isSystemMod = false;
+      if (auto *M = HS.lookupModule(Mod->ModuleName, /*AllowSearch=*/false))
+        isSystemMod = M->IsSystem;
+      if (!isSystemMod || RecordOpts.RecordSystemDependencies)
+        visitor(*Mod, isSystemMod);
+    }
+  }
+};
+} // anonymous namespace.
+
+static void indexModule(serialization::ModuleFile &Mod,
+                        const CompilerInstance &CI,
+                        IndexingOptions IndexOpts,
+                        RecordingOptions RecordOpts) {
+  DiagnosticsEngine &Diag = CI.getDiagnostics();
+  Diag.Report(Mod.ImportLoc, diag::remark_index_producing_module_file_data)
+    << Mod.FileName;
+
+  StringRef SysrootPath = CI.getHeaderSearchOpts().Sysroot;
+  HeaderSearch &HS = CI.getPreprocessor().getHeaderSearchInfo();
+  Module *UnitMod = HS.lookupModule(Mod.ModuleName, /*AllowSearch=*/false);
+
+  IndexDataRecorder Recorder;
+  IndexingContext IndexCtx(IndexOpts, Recorder);
+
+  IndexCtx.setASTContext(CI.getASTContext());
+  IndexCtx.setSysrootPath(SysrootPath);
+  Recorder.init(&IndexCtx, CI);
+
+  for (const Decl *D : CI.getModuleManager()->getModuleFileLevelDecls(Mod)) {
+    IndexCtx.indexTopLevelDecl(D);
+  }
+  Recorder.finish();
+
+  ModuleFileIndexDependencyCollector DepCollector(Mod, RecordOpts);
+  writeUnitData(CI, Recorder, DepCollector, IndexOpts, RecordOpts,
+                Mod.FileName, /*RootFile=*/nullptr, UnitMod, SysrootPath);
+
+}
+
+static bool produceIndexDataForModuleFile(
+                                      serialization::ModuleFile &Mod,
+                                      const CompilerInstance &CI,
+                                      IndexingOptions IndexOpts,
+                                      RecordingOptions RecordOpts,
+                                      IndexUnitWriter &ParentUnitWriter) {
+  DiagnosticsEngine &Diag = CI.getDiagnostics();
+  std::string Error;
+  // We don't do timestamp check with the PCM file, on purpose. The PCM may get
+  // touched for various reasons which would cause unnecessary work to emit
+  // index data. User modules normally will get rebuilt and their index data
+  // re-emitted, and system modules are generally stable (and they can also can
+  // get rebuilt along with their index data).
+  auto IsUptodateOpt = ParentUnitWriter.isUnitUpToDateForOutputFile(Mod.FileName, None, Error);
+  if (!IsUptodateOpt.hasValue()) {
+    unsigned DiagID = Diag.getCustomDiagID(DiagnosticsEngine::Error,
+                                           "failed file status check: %0");
+    Diag.Report(DiagID) << Error;
+    return false;
+  }
+  if (*IsUptodateOpt)
+    return false;
+
+  indexModule(Mod, CI, IndexOpts, RecordOpts);
+  return true;
+}
+
+static std::unique_ptr<FrontendAction>
+createIndexDataRecordingAction(IndexingOptions IndexOpts,
+                               RecordingOptions RecordOpts,
+                               std::unique_ptr<FrontendAction> WrappedAction) {
+  if (WrappedAction)
+    return llvm::make_unique<WrappingIndexRecordAction>(std::move(WrappedAction),
+                                                        std::move(IndexOpts),
+                                                        std::move(RecordOpts));
+  return llvm::make_unique<IndexRecordAction>(std::move(IndexOpts),
+                                              std::move(RecordOpts));
+}
+
+static std::pair<IndexingOptions, RecordingOptions>
+getIndexOptionsFromFrontendOptions(const FrontendOptions &FEOpts) {
+  index::IndexingOptions IndexOpts;
+  index::RecordingOptions RecordOpts;
+  RecordOpts.DataDirPath = FEOpts.IndexStorePath;
+  if (FEOpts.IndexIgnoreSystemSymbols) {
+    IndexOpts.SystemSymbolFilter =
+    index::IndexingOptions::SystemSymbolFilterKind::None;
+  }
+  RecordOpts.RecordSymbolCodeGenName = FEOpts.IndexRecordCodegenName;
+  return { IndexOpts, RecordOpts };
+}
+
+std::unique_ptr<FrontendAction>
+index::createIndexDataRecordingAction(const FrontendOptions &FEOpts,
+                                std::unique_ptr<FrontendAction> WrappedAction) {
+  index::IndexingOptions IndexOpts;
+  index::RecordingOptions RecordOpts;
+  std::tie(IndexOpts, RecordOpts) = getIndexOptionsFromFrontendOptions(FEOpts);
+  return ::createIndexDataRecordingAction(IndexOpts, RecordOpts,
+                                          std::move(WrappedAction));
+}
+
+bool index::emitIndexDataForModuleFile(const Module *Mod,
+                                       const CompilerInstance &CI,
+                                       IndexUnitWriter &ParentUnitWriter) {
+  index::IndexingOptions IndexOpts;
+  index::RecordingOptions RecordOpts;
+  std::tie(IndexOpts, RecordOpts) = getIndexOptionsFromFrontendOptions(CI.getFrontendOpts());
+
+  auto astReader = CI.getModuleManager();
+  serialization::ModuleFile *ModFile = astReader->getModuleManager().lookup(Mod->getASTFile());
+  assert(ModFile && "no module file loaded for module ?");
+  return produceIndexDataForModuleFile(*ModFile, CI, IndexOpts, RecordOpts, ParentUnitWriter);
+}
diff --git a/lib/Index/IndexingContext.cpp b/lib/Index/IndexingContext.cpp
index de9fe39df0..c1ce8bc49c 100644
--- a/lib/Index/IndexingContext.cpp
+++ b/lib/Index/IndexingContext.cpp
@@ -93,12 +93,7 @@ bool IndexingContext::importedModule(const ImportDecl *ImportD) {
   if (FID.isInvalid())
     return true;
 
-  bool Invalid = false;
-  const SrcMgr::SLocEntry &SEntry = SM.getSLocEntry(FID, &Invalid);
-  if (Invalid || !SEntry.isFile())
-    return true;
-
-  if (SEntry.getFile().getFileCharacteristic() != SrcMgr::C_User) {
+  if (isSystemFile(FID)) {
     switch (IndexOpts.SystemSymbolFilter) {
     case IndexingOptions::SystemSymbolFilterKind::None:
       return true;
@@ -161,6 +156,56 @@ bool IndexingContext::shouldIgnoreIfImplicit(const Decl *D) {
   return true;
 }
 
+void IndexingContext::setSysrootPath(StringRef path) {
+  // Ignore sysroot path if it points to root, otherwise every header will be
+  // treated as system one.
+  if (path == "/")
+    path = StringRef();
+  SysrootPath = path;
+}
+
+bool IndexingContext::isSystemFile(FileID FID) {
+  if (LastFileCheck.first == FID)
+    return LastFileCheck.second;
+
+  auto result = [&](bool res) -> bool {
+    LastFileCheck = { FID, res };
+    return res;
+  };
+
+  bool Invalid = false;
+  const SrcMgr::SLocEntry &SEntry =
+    Ctx->getSourceManager().getSLocEntry(FID, &Invalid);
+  if (Invalid || !SEntry.isFile())
+    return result(false);
+
+  const SrcMgr::FileInfo &FI = SEntry.getFile();
+  if (FI.getFileCharacteristic() != SrcMgr::C_User)
+    return result(true);
+
+  auto *CC = FI.getContentCache();
+  if (!CC)
+    return result(false);
+  auto *FE = CC->OrigEntry;
+  if (!FE)
+    return result(false);
+
+  if (SysrootPath.empty())
+    return result(false);
+
+  // Check if directory is in sysroot so that we can consider system headers
+  // even the headers found via a user framework search path, pointing inside
+  // sysroot.
+  auto dirEntry = FE->getDir();
+  auto pair = DirEntries.insert(std::make_pair(dirEntry, false));
+  bool &isSystemDir = pair.first->second;
+  bool wasInserted = pair.second;
+  if (wasInserted) {
+    isSystemDir = StringRef(dirEntry->getName()).startswith(SysrootPath);
+  }
+  return result(isSystemDir);
+}
+
 static const CXXRecordDecl *
 getDeclContextForTemplateInstationPattern(const Decl *D) {
   if (const auto *CTSD =
@@ -321,7 +366,7 @@ bool IndexingContext::handleDeclOccurrence(const Decl *D, SourceLocation Loc,
                                            const Expr *OrigE,
                                            const Decl *OrigD,
                                            const DeclContext *ContainerDC) {
-  if (D->isImplicit() && !isa<ObjCMethodDecl>(D))
+  if (D->isImplicit() && !(isa<ObjCMethodDecl>(D) || isa<ObjCIvarDecl>(D)))
     return true;
   if (!isa<NamedDecl>(D) || shouldSkipNamelessDecl(cast<NamedDecl>(D)))
     return true;
@@ -337,12 +382,7 @@ bool IndexingContext::handleDeclOccurrence(const Decl *D, SourceLocation Loc,
   if (FID.isInvalid())
     return true;
 
-  bool Invalid = false;
-  const SrcMgr::SLocEntry &SEntry = SM.getSLocEntry(FID, &Invalid);
-  if (Invalid || !SEntry.isFile())
-    return true;
-
-  if (SEntry.getFile().getFileCharacteristic() != SrcMgr::C_User) {
+  if (isSystemFile(FID)) {
     switch (IndexOpts.SystemSymbolFilter) {
     case IndexingOptions::SystemSymbolFilterKind::None:
       return true;
diff --git a/lib/Index/IndexingContext.h b/lib/Index/IndexingContext.h
index 566651c83a..70e72e1d28 100644
--- a/lib/Index/IndexingContext.h
+++ b/lib/Index/IndexingContext.h
@@ -11,9 +11,11 @@
 #define LLVM_CLANG_LIB_INDEX_INDEXINGCONTEXT_H
 
 #include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
 #include "clang/Index/IndexSymbol.h"
 #include "clang/Index/IndexingAction.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/DenseMap.h"
 
 namespace clang {
   class ASTContext;
@@ -29,7 +31,7 @@ namespace clang {
   class Stmt;
   class Expr;
   class TypeLoc;
-  class SourceLocation;
+  class DirectoryEntry;
 
 namespace index {
   class IndexDataConsumer;
@@ -38,6 +40,13 @@ class IndexingContext {
   IndexingOptions IndexOpts;
   IndexDataConsumer &DataConsumer;
   ASTContext *Ctx = nullptr;
+  std::string SysrootPath;
+
+  // Records whether a directory entry is system or not.
+  llvm::DenseMap<const DirectoryEntry *, bool> DirEntries;
+  // Keeps track of the last check for whether a FileID is system or
+  // not. This is used to speed up isSystemFile() call.
+  std::pair<FileID, bool> LastFileCheck;
 
 public:
   IndexingContext(IndexingOptions IndexOpts, IndexDataConsumer &DataConsumer)
@@ -47,6 +56,10 @@ public:
   IndexDataConsumer &getDataConsumer() { return DataConsumer; }
 
   void setASTContext(ASTContext &ctx) { Ctx = &ctx; }
+  void setSysrootPath(StringRef path);
+  StringRef getSysrootPath() const { return SysrootPath; }
+
+  bool isSystemFile(FileID FID);
 
   bool shouldIndex(const Decl *D);
 
diff --git a/lib/Lex/Lexer.cpp b/lib/Lex/Lexer.cpp
index 8bd4ab0ff9..4456cd1bbc 100644
--- a/lib/Lex/Lexer.cpp
+++ b/lib/Lex/Lexer.cpp
@@ -1295,6 +1295,35 @@ SourceLocation Lexer::findLocationAfterToken(
   return TokenLoc.getLocWithOffset(Tok->getLength() + NumWhitespaceChars);
 }
 
+SourceLocation Lexer::findNextTokenLocationAfterTokenAt(
+    SourceLocation Loc, const SourceManager &SM, const LangOptions &LangOpts) {
+  // TODO: Share the code with the function above when upstreaming.
+  if (Loc.isMacroID()) {
+    if (!Lexer::isAtEndOfMacroExpansion(Loc, SM, LangOpts, &Loc))
+      return SourceLocation();
+  }
+  Loc = Lexer::getLocForEndOfToken(Loc, 0, SM, LangOpts);
+
+  // Break down the source location.
+  std::pair<FileID, unsigned> LocInfo = SM.getDecomposedLoc(Loc);
+
+  // Try to load the file buffer.
+  bool InvalidTemp = false;
+  StringRef File = SM.getBufferData(LocInfo.first, &InvalidTemp);
+  if (InvalidTemp)
+    return SourceLocation();
+
+  const char *TokenBegin = File.data() + LocInfo.second;
+
+  // Lex from the start of the given location.
+  Lexer lexer(SM.getLocForStartOfFile(LocInfo.first), LangOpts, File.begin(),
+              TokenBegin, File.end());
+  // Find the token.
+  Token Tok;
+  lexer.LexFromRawLexer(Tok);
+  return Tok.getLocation();
+}
+
 /// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,
 /// get its size, and return it.  This is tricky in several cases:
 ///   1. If currently at the start of a trigraph, we warn about the trigraph,
diff --git a/lib/Lex/ModuleMap.cpp b/lib/Lex/ModuleMap.cpp
index b3ac10c5c5..cf30f020f1 100644
--- a/lib/Lex/ModuleMap.cpp
+++ b/lib/Lex/ModuleMap.cpp
@@ -759,10 +759,24 @@ std::pair<Module *, bool> ModuleMap::findOrCreateModule(StringRef Name,
     if (LangOpts.CurrentModule == Name)
       SourceModule = Result;
     Modules[Name] = Result;
+    ModuleScopeIDs[Result] = CurrentModuleScopeID;
   }
   return std::make_pair(Result, true);
 }
 
+Module *ModuleMap::createShadowedModule(StringRef Name, bool IsFramework,
+                                        Module *ShadowingModule) {
+
+  // Create a new module with this name.
+  Module *Result =
+      new Module(Name, SourceLocation(), /*Parent=*/nullptr, IsFramework,
+                 /*IsExplicit=*/false, NumCreatedModules++);
+  Result->ShadowingModule = ShadowingModule;
+  Result->IsAvailable = false;
+  ModuleScopeIDs[Result] = CurrentModuleScopeID;
+  return Result;
+}
+
 Module *ModuleMap::createGlobalModuleForInterfaceUnit(SourceLocation Loc) {
   assert(!PendingGlobalModule && "created multiple global modules");
   PendingGlobalModule.reset(
@@ -921,6 +935,8 @@ Module *ModuleMap::inferFrameworkModule(const DirectoryEntry *FrameworkDir,
   Module *Result = new Module(ModuleName, SourceLocation(), Parent,
                               /*IsFramework=*/true, /*IsExplicit=*/false,
                               NumCreatedModules++);
+  if (!Parent)
+    ModuleScopeIDs[Result] = CurrentModuleScopeID;
   InferredModuleAllowedBy[Result] = ModuleMapFile;
   Result->IsInferred = true;
   if (!Parent) {
@@ -1602,6 +1618,9 @@ namespace {
     /// \brief The 'exhaustive' attribute.
     AT_exhaustive,
 
+    // \brief The 'swift_infer_import_as_member' attribute.
+    AT_swift_infer_import_as_member,
+
     /// \brief The 'no_undeclared_includes' attribute.
     AT_no_undeclared_includes
   };
@@ -1787,6 +1806,7 @@ void ModuleMapParser::parseModuleDecl() {
   SourceLocation LBraceLoc = consumeToken();
   
   // Determine whether this (sub)module has already been defined.
+  Module *ShadowingModule = nullptr;
   if (Module *Existing = Map.lookupModuleQualified(ModuleName, ActiveModule)) {
     // We might see a (re)definition of a module that we already have a
     // definition for in two cases:
@@ -1812,23 +1832,35 @@ void ModuleMapParser::parseModuleDecl() {
       }
       return;
     }
-    
-    Diags.Report(ModuleNameLoc, diag::err_mmap_module_redefinition)
-      << ModuleName;
-    Diags.Report(Existing->DefinitionLoc, diag::note_mmap_prev_definition);
-    
-    // Skip the module definition.
-    skipUntil(MMToken::RBrace);
-    if (Tok.is(MMToken::RBrace))
-      consumeToken();
-    
-    HadError = true;
-    return;
+
+    if (!Existing->Parent && Map.mayShadowNewModule(Existing)) {
+      ShadowingModule = Existing;
+    } else {
+      // This is not a shawdowed module decl, it is an illegal redefinition.
+      Diags.Report(ModuleNameLoc, diag::err_mmap_module_redefinition)
+          << ModuleName;
+      Diags.Report(Existing->DefinitionLoc, diag::note_mmap_prev_definition);
+
+      // Skip the module definition.
+      skipUntil(MMToken::RBrace);
+      if (Tok.is(MMToken::RBrace))
+        consumeToken();
+
+      HadError = true;
+      return;
+    }
   }
 
   // Start defining this module.
-  ActiveModule = Map.findOrCreateModule(ModuleName, ActiveModule, Framework,
-                                        Explicit).first;
+  if (ShadowingModule) {
+    ActiveModule =
+        Map.createShadowedModule(ModuleName, Framework, ShadowingModule);
+  } else {
+    ActiveModule =
+        Map.findOrCreateModule(ModuleName, ActiveModule, Framework, Explicit)
+            .first;
+  }
+
   ActiveModule->DefinitionLoc = ModuleNameLoc;
   if (Attrs.IsSystem || IsSystem)
     ActiveModule->IsSystem = true;
@@ -2722,6 +2754,7 @@ bool ModuleMapParser::parseOptionalAttributes(Attributes &Attrs) {
           .Case("extern_c", AT_extern_c)
           .Case("no_undeclared_includes", AT_no_undeclared_includes)
           .Case("system", AT_system)
+          .Case("swift_infer_import_as_member", AT_swift_infer_import_as_member)
           .Default(AT_unknown);
     switch (Attribute) {
     case AT_unknown:
@@ -2737,6 +2770,10 @@ bool ModuleMapParser::parseOptionalAttributes(Attributes &Attrs) {
       Attrs.IsExternC = true;
       break;
 
+    case AT_swift_infer_import_as_member:
+      Attrs.IsSwiftInferImportAsMember = true;
+      break;
+
     case AT_exhaustive:
       Attrs.IsExhaustive = true;
       break;
diff --git a/lib/Lex/PPDirectives.cpp b/lib/Lex/PPDirectives.cpp
index ca3e70fd10..ae3a04837d 100644
--- a/lib/Lex/PPDirectives.cpp
+++ b/lib/Lex/PPDirectives.cpp
@@ -1655,12 +1655,18 @@ bool Preprocessor::checkModuleIsAvailable(const LangOptions &LangOpts,
                                           DiagnosticsEngine &Diags, Module *M) {
   Module::Requirement Requirement;
   Module::UnresolvedHeaderDirective MissingHeader;
-  if (M->isAvailable(LangOpts, TargetInfo, Requirement, MissingHeader))
+  Module *ShadowingModule = nullptr;
+  if (M->isAvailable(LangOpts, TargetInfo, Requirement, MissingHeader,
+                     ShadowingModule))
     return false;
 
   if (MissingHeader.FileNameLoc.isValid()) {
     Diags.Report(MissingHeader.FileNameLoc, diag::err_module_header_missing)
         << MissingHeader.IsUmbrella << MissingHeader.FileName;
+  } else if (ShadowingModule) {
+    Diags.Report(M->DefinitionLoc, diag::err_module_shadowed) << M->Name;
+    Diags.Report(ShadowingModule->DefinitionLoc,
+                 diag::note_previous_definition);
   } else {
     // FIXME: Track the location at which the requirement was specified, and
     // use it here.
diff --git a/lib/Lex/PPMacroExpansion.cpp b/lib/Lex/PPMacroExpansion.cpp
index 41633f90c3..255977c733 100644
--- a/lib/Lex/PPMacroExpansion.cpp
+++ b/lib/Lex/PPMacroExpansion.cpp
@@ -1114,6 +1114,7 @@ static bool HasFeature(const Preprocessor &PP, StringRef Feature) {
       .Case("attribute_availability_with_version_underscores", true)
       .Case("attribute_availability_tvos", true)
       .Case("attribute_availability_watchos", true)
+      .Case("attribute_availability_swift", true)
       .Case("attribute_availability_with_strict", true)
       .Case("attribute_availability_with_replacement", true)
       .Case("attribute_availability_in_templates", true)
@@ -1139,6 +1140,7 @@ static bool HasFeature(const Preprocessor &PP, StringRef Feature) {
       .Case("cxx_exceptions", LangOpts.CXXExceptions)
       .Case("cxx_rtti", LangOpts.RTTI && LangOpts.RTTIData)
       .Case("enumerator_attributes", true)
+      .Case("generalized_swift_name", true)
       .Case("nullability", true)
       .Case("nullability_on_arrays", true)
       .Case("memory_sanitizer", LangOpts.Sanitize.has(SanitizerKind::Memory))
diff --git a/lib/Parse/ParseCXXInlineMethods.cpp b/lib/Parse/ParseCXXInlineMethods.cpp
index 2b3d4ba85b..9d7d211133 100644
--- a/lib/Parse/ParseCXXInlineMethods.cpp
+++ b/lib/Parse/ParseCXXInlineMethods.cpp
@@ -47,6 +47,7 @@ NamedDecl *Parser::ParseCXXInlineMethodDef(AccessSpecifier AS,
                                            VS, ICIS_NoInit);
     if (FnD) {
       Actions.ProcessDeclAttributeList(getCurScope(), FnD, AccessAttrs);
+      Actions.ProcessAPINotes(FnD);
       if (PureSpecLoc.isValid())
         Actions.ActOnPureSpecifier(FnD, PureSpecLoc);
     }
diff --git a/lib/Parse/ParseDecl.cpp b/lib/Parse/ParseDecl.cpp
index 127e18439b..4864b6dce1 100644
--- a/lib/Parse/ParseDecl.cpp
+++ b/lib/Parse/ParseDecl.cpp
@@ -244,6 +244,38 @@ IdentifierLoc *Parser::ParseIdentifierLoc() {
   return IL;
 }
 
+void Parser::ParseSwiftNewtypeAttribute(
+    IdentifierInfo &SwiftNewtype, SourceLocation SwiftNewtypeLoc,
+    ParsedAttributes &attrs, SourceLocation *endLoc, IdentifierInfo *ScopeName,
+    SourceLocation ScopeLoc, AttributeList::Syntax Syntax) {
+
+  BalancedDelimiterTracker Parens(*this, tok::l_paren);
+  Parens.consumeOpen();
+
+  if (Tok.is(tok::r_paren)) {
+    Diag(Tok.getLocation(), diag::err_argument_required_after_attribute);
+    Parens.consumeClose();
+    return;
+  }
+  if (Tok.isNot(tok::kw_struct) && Tok.isNot(tok::kw_enum)) {
+    Diag(Tok.getLocation(), diag::warn_attribute_type_not_supported)
+        << &SwiftNewtype << Tok.getIdentifierInfo();
+    if (!isTokenSpecial())
+      ConsumeToken();
+    Parens.consumeClose();
+    return;
+  }
+  auto IL = IdentifierLoc::create(Actions.Context, Tok.getLocation(),
+                                  Tok.getIdentifierInfo());
+  ConsumeToken();
+  auto identLoc = ArgsUnion(IL);
+
+  attrs.addNew(&SwiftNewtype,
+               SourceRange(SwiftNewtypeLoc, Parens.getCloseLocation()),
+               ScopeName, ScopeLoc, &identLoc, 1, Syntax);
+  Parens.consumeClose();
+}
+
 void Parser::ParseAttributeWithTypeArg(IdentifierInfo &AttrName,
                                        SourceLocation AttrNameLoc,
                                        ParsedAttributes &Attrs,
@@ -370,6 +402,10 @@ void Parser::ParseGNUAttributeArgs(IdentifierInfo *AttrName,
     ParseTypeTagForDatatypeAttribute(*AttrName, AttrNameLoc, Attrs, EndLoc,
                                      ScopeName, ScopeLoc, Syntax);
     return;
+  } else if (AttrKind == AttributeList::AT_SwiftNewtype) {
+    ParseSwiftNewtypeAttribute(*AttrName, AttrNameLoc, Attrs, EndLoc,
+                               ScopeName, ScopeLoc, Syntax);
+    return;
   } else if (attributeIsTypeArgAttr(*AttrName)) {
     ParseAttributeWithTypeArg(*AttrName, AttrNameLoc, Attrs, EndLoc, ScopeName,
                               ScopeLoc, Syntax);
@@ -880,7 +916,7 @@ VersionTuple Parser::ParseVersionTuple(SourceRange &Range) {
 ///
 /// version-arg:
 ///   'introduced' '=' version
-///   'deprecated' '=' version
+///   'deprecated' ['=' version]
 ///   'obsoleted' = version
 ///   'unavailable'
 /// opt-replacement:
@@ -973,6 +1009,21 @@ void Parser::ParseAvailabilityAttribute(IdentifierInfo &Availability,
       continue;
     }
 
+    if (Keyword == Ident_deprecated && Platform->Ident &&
+        Platform->Ident->getName() == "swift") {
+      // For swift, we deprecate for all versions.
+      if (!Changes[Deprecated].KeywordLoc.isInvalid()) {
+        Diag(KeywordLoc, diag::err_availability_redundant)
+          << Keyword
+          << SourceRange(Changes[Deprecated].KeywordLoc);
+      }
+
+      Changes[Deprecated].KeywordLoc = KeywordLoc;
+      // Use a fake version here.
+      Changes[Deprecated].Version = VersionTuple(1);
+      continue;
+    }
+
     if (Tok.isNot(tok::equal)) {
       Diag(Tok, diag::err_expected_after) << Keyword << tok::equal;
       SkipUntil(tok::r_paren, StopAtSemi);
@@ -6848,3 +6899,68 @@ bool Parser::TryAltiVecTokenOutOfLine(DeclSpec &DS, SourceLocation Loc,
   }
   return false;
 }
+
+TypeResult Parser::parseTypeFromString(StringRef typeStr, StringRef context,
+                                       SourceLocation includeLoc) {
+  // Consume (unexpanded) tokens up to the end-of-directive.
+  SmallVector<Token, 4> tokens;
+  {
+    // Create a new buffer from which we will parse the type.
+    auto &sourceMgr = PP.getSourceManager();
+    FileID fileID = sourceMgr.createFileID(
+                      llvm::MemoryBuffer::getMemBufferCopy(typeStr, context),
+                      SrcMgr::C_User, 0, 0, includeLoc);
+
+    // Form a new lexer that references the buffer.
+    Lexer lexer(fileID, sourceMgr.getBuffer(fileID), PP);
+    lexer.setParsingPreprocessorDirective(true);
+    lexer.setIsPragmaLexer(true);
+
+    // Lex the tokens from that buffer.
+    Token tok;
+    do {
+      lexer.Lex(tok);
+      tokens.push_back(tok);
+    } while (tok.isNot(tok::eod));
+  }
+
+  // Replace the "eod" token with an "eof" token identifying the end of
+  // the provided string.
+  Token &endToken = tokens.back();
+  endToken.startToken();
+  endToken.setKind(tok::eof);
+  endToken.setLocation(Tok.getLocation());
+  endToken.setEofData(typeStr.data());
+
+  // Add the current token back.
+  tokens.push_back(Tok);
+
+  // Enter the tokens into the token stream.
+  PP.EnterTokenStream(tokens, /*DisableMacroExpansion=*/false);
+
+  // Consume the current token so that we'll start parsing the tokens we
+  // added to the stream.
+  ConsumeAnyToken();
+
+  // Enter a new scope.
+  ParseScope localScope(this, 0);
+
+  // Parse the type.
+  TypeResult result = ParseTypeName(nullptr);
+
+  // Check if we parsed the whole thing.
+  if (result.isUsable() &&
+      (Tok.isNot(tok::eof) || Tok.getEofData() != typeStr.data())) {
+    Diag(Tok.getLocation(), diag::err_type_unparsed);
+  }
+
+  // There could be leftover tokens (e.g. because of an error).
+  // Skip through until we reach the 'end of directive' token.
+  while (Tok.isNot(tok::eof))
+    ConsumeAnyToken();
+
+  // Consume the end token.
+  if (Tok.is(tok::eof) && Tok.getEofData() == typeStr.data())
+    ConsumeAnyToken();
+  return result;
+}
diff --git a/lib/Parse/ParseDeclCXX.cpp b/lib/Parse/ParseDeclCXX.cpp
index 68b73ca1d2..ae4a63e78e 100644
--- a/lib/Parse/ParseDeclCXX.cpp
+++ b/lib/Parse/ParseDeclCXX.cpp
@@ -2776,8 +2776,10 @@ Parser::ParseCXXClassMemberDeclaration(AccessSpecifier AS,
         // initialize it.
         ThisDecl = VT->getTemplatedDecl();
 
-      if (ThisDecl && AccessAttrs)
+      if (ThisDecl) {
         Actions.ProcessDeclAttributeList(getCurScope(), ThisDecl, AccessAttrs);
+        Actions.ProcessAPINotes(ThisDecl);
+      }
     }
 
     // Error recovery might have converted a non-static member into a static
diff --git a/lib/Parse/ParseObjc.cpp b/lib/Parse/ParseObjc.cpp
index 688376ca28..e37bc7a086 100644
--- a/lib/Parse/ParseObjc.cpp
+++ b/lib/Parse/ParseObjc.cpp
@@ -213,6 +213,8 @@ void Parser::CheckNestedObjCContexts(SourceLocation AtLoc)
 ///     __attribute__((unavailable))
 ///     __attribute__((objc_exception)) - used by NSException on 64-bit
 ///     __attribute__((objc_root_class))
+///     __attribute__((objc_subclassing_restricted))
+///     __attribute__((objc_complete_definition))
 ///
 Decl *Parser::ParseObjCAtInterfaceDeclaration(SourceLocation AtLoc,
                                               ParsedAttributes &attrs) {
diff --git a/lib/Parse/Parser.cpp b/lib/Parse/Parser.cpp
index a6f966eda1..1f32517003 100644
--- a/lib/Parse/Parser.cpp
+++ b/lib/Parse/Parser.cpp
@@ -67,6 +67,11 @@ Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies)
   PP.addCommentHandler(CommentSemaHandler.get());
 
   PP.setCodeCompletionHandler(*this);
+
+  Actions.ParseTypeFromStringCallback =
+    [this](StringRef typeStr, StringRef context, SourceLocation includeLoc) {
+      return this->parseTypeFromString(typeStr, context, includeLoc);
+    };
 }
 
 DiagnosticBuilder Parser::Diag(SourceLocation Loc, unsigned DiagID) {
@@ -406,6 +411,9 @@ Parser::ParseScopeFlags::~ParseScopeFlags() {
 //===----------------------------------------------------------------------===//
 
 Parser::~Parser() {
+  // Clear out the parse-type-from-string callback.
+  Actions.ParseTypeFromStringCallback = nullptr;
+
   // If we still have scopes active, delete the scope tree.
   delete getCurScope();
   Actions.CurScope = nullptr;
diff --git a/lib/Sema/CMakeLists.txt b/lib/Sema/CMakeLists.txt
index 7d9ae621c9..75fca76b45 100644
--- a/lib/Sema/CMakeLists.txt
+++ b/lib/Sema/CMakeLists.txt
@@ -21,6 +21,7 @@ add_clang_library(clangSema
   Sema.cpp
   SemaAccess.cpp
   SemaAttr.cpp
+  SemaAPINotes.cpp
   SemaCXXScopeSpec.cpp
   SemaCast.cpp
   SemaChecking.cpp
@@ -62,4 +63,5 @@ add_clang_library(clangSema
   clangBasic
   clangEdit
   clangLex
+  clangAPINotes
   )
diff --git a/lib/Sema/Sema.cpp b/lib/Sema/Sema.cpp
index 4e57e5ef81..9089cf2647 100644
--- a/lib/Sema/Sema.cpp
+++ b/lib/Sema/Sema.cpp
@@ -118,7 +118,13 @@ Sema::Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,
     : ExternalSource(nullptr), isMultiplexExternalSource(false),
       FPFeatures(pp.getLangOpts()), LangOpts(pp.getLangOpts()), PP(pp),
       Context(ctxt), Consumer(consumer), Diags(PP.getDiagnostics()),
-      SourceMgr(PP.getSourceManager()), CollectStats(false),
+      SourceMgr(PP.getSourceManager()),
+
+      // Don't you dare clang-format this.
+      // APINotes is a never-ending source of conflicts. Don't make it worse.
+      APINotes(SourceMgr, LangOpts),
+
+      CollectStats(false),
       CodeCompleter(CodeCompleter), CurContext(nullptr),
       OriginalLexicalContext(nullptr), MSStructPragmaOn(false),
       MSPointerToMemberRepresentationMethod(
diff --git a/lib/Sema/SemaAPINotes.cpp b/lib/Sema/SemaAPINotes.cpp
index e69de29bb2..d472f35095 100644
--- a/lib/Sema/SemaAPINotes.cpp
+++ b/lib/Sema/SemaAPINotes.cpp
@@ -0,0 +1,952 @@
+//===--- SemaAPINotes.cpp - API Notes Handling ----------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//  This file implements the mapping from API notes to declaration attributes.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Sema/SemaInternal.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/APINotes/APINotesReader.h"
+using namespace clang;
+
+namespace {
+  enum IsActive_t : bool {
+    IsNotActive,
+    IsActive
+  };
+  enum IsReplacement_t : bool {
+    IsNotReplacement,
+    IsReplacement
+  };
+
+  struct VersionedInfoMetadata {
+    /// An empty version refers to unversioned metadata.
+    VersionTuple Version;
+    unsigned IsActive: 1;
+    unsigned IsReplacement: 1;
+
+    VersionedInfoMetadata(VersionTuple version, IsActive_t active,
+                          IsReplacement_t replacement)
+      : Version(version), IsActive(active == IsActive_t::IsActive),
+        IsReplacement(replacement == IsReplacement_t::IsReplacement) {}
+  };
+} // end anonymous namespace
+
+/// Determine whether this is a multi-level pointer type.
+static bool isMultiLevelPointerType(QualType type) {
+  QualType pointee = type->getPointeeType();
+  if (pointee.isNull())
+    return false;
+
+  return pointee->isAnyPointerType() || pointee->isObjCObjectPointerType() ||
+         pointee->isMemberPointerType();
+}
+
+// Apply nullability to the given declaration.
+static void applyNullability(Sema &S, Decl *decl, NullabilityKind nullability,
+                             VersionedInfoMetadata metadata) {
+  if (!metadata.IsActive)
+    return;
+
+  QualType type;
+
+  // Nullability for a function/method appertains to the retain type.
+  if (auto function = dyn_cast<FunctionDecl>(decl)) {
+    type = function->getReturnType();
+  } else if (auto method = dyn_cast<ObjCMethodDecl>(decl)) {
+    type = method->getReturnType();
+  } else if (auto value = dyn_cast<ValueDecl>(decl)) {
+    type = value->getType();
+  } else if (auto property = dyn_cast<ObjCPropertyDecl>(decl)) {
+    type = property->getType();
+  } else {
+    return;
+  }
+
+  // Check the nullability specifier on this type.
+  QualType origType = type;
+  S.checkNullabilityTypeSpecifier(type, nullability, decl->getLocation(),
+                                  /*isContextSensitive=*/false,
+                                  isa<ParmVarDecl>(decl), /*implicit=*/true,
+                                  /*overrideExisting=*/true);
+  if (type.getTypePtr() == origType.getTypePtr())
+    return;
+
+  if (auto function = dyn_cast<FunctionDecl>(decl)) {
+    const FunctionType *fnType = function->getType()->castAs<FunctionType>();
+    if (const FunctionProtoType *proto = dyn_cast<FunctionProtoType>(fnType)) {
+      function->setType(S.Context.getFunctionType(type, proto->getParamTypes(),
+                                                  proto->getExtProtoInfo()));
+    } else {
+      function->setType(S.Context.getFunctionNoProtoType(type,
+                                                         fnType->getExtInfo()));
+    }
+  } else if (auto method = dyn_cast<ObjCMethodDecl>(decl)) {
+    method->setReturnType(type);
+
+    // Make it a context-sensitive keyword if we can.
+    if (!isMultiLevelPointerType(type)) {
+      method->setObjCDeclQualifier(
+        Decl::ObjCDeclQualifier(method->getObjCDeclQualifier() |
+                                Decl::OBJC_TQ_CSNullability));
+    }
+  } else if (auto value = dyn_cast<ValueDecl>(decl)) {
+    value->setType(type);
+
+    // Make it a context-sensitive keyword if we can.
+    if (auto parm = dyn_cast<ParmVarDecl>(decl)) {
+      if (parm->isObjCMethodParameter() && !isMultiLevelPointerType(type)) {
+        parm->setObjCDeclQualifier(
+          Decl::ObjCDeclQualifier(parm->getObjCDeclQualifier() |
+                                  Decl::OBJC_TQ_CSNullability));
+      }
+    }
+  } else if (auto property = dyn_cast<ObjCPropertyDecl>(decl)) {
+    property->setType(type, property->getTypeSourceInfo());
+
+    // Make it a property attribute if we can.
+    if (!isMultiLevelPointerType(type)) {
+      property->setPropertyAttributes(
+        ObjCPropertyDecl::OBJC_PR_null_resettable);
+    }
+  } else {
+    llvm_unreachable("cannot handle nullability here");
+  }
+}
+
+/// Copy a string into ASTContext-allocated memory.
+static StringRef CopyString(ASTContext &ctx, StringRef string) {
+  void *mem = ctx.Allocate(string.size(), alignof(char));
+  memcpy(mem, string.data(), string.size());
+  return StringRef(static_cast<char *>(mem), string.size());
+}
+
+namespace {
+  template <typename A>
+  struct AttrKindFor {};
+
+#define ATTR(X) \
+  template <> struct AttrKindFor<X##Attr> { \
+    static const attr::Kind value = attr::X; \
+  };
+#include "clang/Basic/AttrList.inc"
+
+  /// Handle an attribute introduced by API notes.
+  ///
+  /// \param shouldAddAttribute Whether we should add a new attribute
+  /// (otherwise, we might remove an existing attribute).
+  /// \param createAttr Create the new attribute to be added.
+  template<typename A>
+  void handleAPINotedAttribute(
+         Sema &S, Decl *D, bool shouldAddAttribute,
+         VersionedInfoMetadata metadata,
+         llvm::function_ref<A *()> createAttr,
+         llvm::function_ref<Decl::attr_iterator(const Decl*)> getExistingAttr) {
+    if (metadata.IsActive) {
+      auto existing = getExistingAttr(D);
+      if (existing != D->attr_end()) {
+        // Remove the existing attribute, and treat it as a superseded
+        // non-versioned attribute.
+        auto *versioned = SwiftVersionedAttr::CreateImplicit(
+            S.Context, metadata.Version, *existing, /*IsReplacedByActive*/true);
+
+        D->getAttrs().erase(existing);
+        D->addAttr(versioned);
+      }
+
+      // If we're supposed to add a new attribute, do so.
+      if (shouldAddAttribute) {
+        if (auto attr = createAttr()) {
+          D->addAttr(attr);
+        }
+      }
+
+    } else {
+      if (shouldAddAttribute) {
+        if (auto attr = createAttr()) {
+          auto *versioned = SwiftVersionedAttr::CreateImplicit(
+              S.Context, metadata.Version, attr,
+              /*IsReplacedByActive*/metadata.IsReplacement);
+          D->addAttr(versioned);
+        }
+      } else {
+        // FIXME: This isn't preserving enough information for things like
+        // availability, where we're trying to remove a /specific/ kind of
+        // attribute.
+        auto *versioned = SwiftVersionedRemovalAttr::CreateImplicit(
+            S.Context,  metadata.Version, AttrKindFor<A>::value,
+            /*IsReplacedByActive*/metadata.IsReplacement);
+        D->addAttr(versioned);
+      }
+    }
+  }
+  
+  template<typename A>
+  void handleAPINotedAttribute(
+         Sema &S, Decl *D, bool shouldAddAttribute,
+         VersionedInfoMetadata metadata,
+         llvm::function_ref<A *()> createAttr) {
+    handleAPINotedAttribute<A>(S, D, shouldAddAttribute, metadata, createAttr,
+                               [](const Decl *decl) {
+      return llvm::find_if(decl->attrs(), [](const Attr *next) {
+        return isa<A>(next);
+      });
+    });
+  }
+}
+
+template <typename A = CFReturnsRetainedAttr>
+static void handleAPINotedRetainCountAttribute(Sema &S, Decl *D,
+                                               bool shouldAddAttribute,
+                                               VersionedInfoMetadata metadata) {
+  // The template argument has a default to make the "removal" case more
+  // concise; it doesn't matter /which/ attribute is being removed.
+  handleAPINotedAttribute<A>(S, D, shouldAddAttribute, metadata, [&] {
+    return A::CreateImplicit(S.Context);
+  }, [](const Decl *D) -> Decl::attr_iterator {
+    return llvm::find_if(D->attrs(), [](const Attr *next) -> bool {
+      return isa<CFReturnsRetainedAttr>(next) ||
+             isa<CFReturnsNotRetainedAttr>(next) ||
+             isa<NSReturnsRetainedAttr>(next) ||
+             isa<NSReturnsNotRetainedAttr>(next);
+    });
+  });
+}
+
+static void handleAPINotedRetainCountConvention(
+    Sema &S, Decl *D, VersionedInfoMetadata metadata,
+    Optional<api_notes::RetainCountConventionKind> convention) {
+  if (!convention)
+    return;
+  switch (convention.getValue()) {
+  case api_notes::RetainCountConventionKind::None:
+    handleAPINotedRetainCountAttribute(S, D, /*shouldAddAttribute*/false,
+                                       metadata);
+    break;
+  case api_notes::RetainCountConventionKind::CFReturnsRetained:
+    handleAPINotedRetainCountAttribute<CFReturnsRetainedAttr>(
+        S, D, /*shouldAddAttribute*/true, metadata);
+    break;
+  case api_notes::RetainCountConventionKind::CFReturnsNotRetained:
+    handleAPINotedRetainCountAttribute<CFReturnsNotRetainedAttr>(
+        S, D, /*shouldAddAttribute*/true, metadata);
+    break;
+  case api_notes::RetainCountConventionKind::NSReturnsRetained:
+    handleAPINotedRetainCountAttribute<NSReturnsRetainedAttr>(
+        S, D, /*shouldAddAttribute*/true, metadata);
+    break;
+  case api_notes::RetainCountConventionKind::NSReturnsNotRetained:
+    handleAPINotedRetainCountAttribute<NSReturnsNotRetainedAttr>(
+        S, D, /*shouldAddAttribute*/true, metadata);
+    break;
+  }
+}
+
+static void ProcessAPINotes(Sema &S, Decl *D,
+                            const api_notes::CommonEntityInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // Availability
+  if (info.Unavailable) {
+    handleAPINotedAttribute<UnavailableAttr>(S, D, true, metadata,
+      [&] {
+        return UnavailableAttr::CreateImplicit(S.Context,
+                                               CopyString(S.Context,
+                                                          info.UnavailableMsg));
+    });
+  }
+
+  if (info.UnavailableInSwift) {
+    handleAPINotedAttribute<AvailabilityAttr>(S, D, true, metadata, [&] {
+      return AvailabilityAttr::CreateImplicit(
+                   S.Context,
+                   &S.Context.Idents.get("swift"),
+                   VersionTuple(),
+                   VersionTuple(),
+                   VersionTuple(),
+                   /*Unavailable=*/true,
+                   CopyString(S.Context, info.UnavailableMsg),
+                   /*Strict=*/false,
+                   /*Replacement=*/StringRef());
+    },
+    [](const Decl *decl) {
+      return llvm::find_if(decl->attrs(), [](const Attr *next) -> bool {
+        auto *AA = dyn_cast<AvailabilityAttr>(next);
+        if (!AA)
+          return false;
+        const IdentifierInfo *platform = AA->getPlatform();
+        if (!platform)
+          return false;
+        return platform->isStr("swift");
+      });
+    });
+  }
+
+  // swift_private
+  if (auto swiftPrivate = info.isSwiftPrivate()) {
+    handleAPINotedAttribute<SwiftPrivateAttr>(S, D, *swiftPrivate, metadata,
+                                              [&] {
+      return SwiftPrivateAttr::CreateImplicit(S.Context);
+    });
+  }
+
+  // swift_name
+  if (!info.SwiftName.empty()) {
+    handleAPINotedAttribute<SwiftNameAttr>(S, D, true, metadata,
+                                           [&]() -> SwiftNameAttr * {
+      auto &APINoteName = S.getASTContext().Idents.get("SwiftName API Note");
+      
+      if (!S.DiagnoseSwiftName(D, info.SwiftName, D->getLocation(),
+                               &APINoteName)) {
+        return nullptr;
+      }
+
+      return SwiftNameAttr::CreateImplicit(S.Context,
+                                           CopyString(S.Context,
+                                                      info.SwiftName));
+    });
+  }
+}
+
+static void ProcessAPINotes(Sema &S, Decl *D,
+                            const api_notes::CommonTypeInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // swift_bridge
+  if (auto swiftBridge = info.getSwiftBridge()) {
+    handleAPINotedAttribute<SwiftBridgeAttr>(S, D, !swiftBridge->empty(),
+                                             metadata, [&] {
+      return SwiftBridgeAttr::CreateImplicit(S.Context,
+                                             CopyString(S.Context,
+                                                        *swiftBridge));
+    });
+  }
+
+  // ns_error_domain
+  if (auto nsErrorDomain = info.getNSErrorDomain()) {
+    handleAPINotedAttribute<NSErrorDomainAttr>(S, D, !nsErrorDomain->empty(),
+                                               metadata, [&] {
+      return NSErrorDomainAttr::CreateImplicit(
+               S.Context,
+               &S.Context.Idents.get(*nsErrorDomain));
+    });
+  }
+
+  ProcessAPINotes(S, D, static_cast<const api_notes::CommonEntityInfo &>(info),
+                  metadata);
+}
+
+/// Check that the replacement type provided by API notes is reasonable.
+///
+/// This is a very weak form of ABI check.
+static bool checkAPINotesReplacementType(Sema &S, SourceLocation loc,
+                                         QualType origType,
+                                         QualType replacementType) {
+  if (S.Context.getTypeSize(origType) !=
+        S.Context.getTypeSize(replacementType)) {
+    S.Diag(loc, diag::err_incompatible_replacement_type)
+      << replacementType << origType;
+    return true;
+  }
+
+  return false;
+}
+
+/// Process API notes for a variable or property.
+static void ProcessAPINotes(Sema &S, Decl *D,
+                            const api_notes::VariableInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // Type override.
+  if (metadata.IsActive && !info.getType().empty() &&
+      S.ParseTypeFromStringCallback) {
+    auto parsedType = S.ParseTypeFromStringCallback(info.getType(),
+                                                    "<API Notes>",
+                                                    D->getLocation());
+    if (parsedType.isUsable()) {
+      QualType type = Sema::GetTypeFromParser(parsedType.get());
+      auto typeInfo =
+        S.Context.getTrivialTypeSourceInfo(type, D->getLocation());
+
+      if (auto var = dyn_cast<VarDecl>(D)) {
+        // Make adjustments to parameter types.
+        if (isa<ParmVarDecl>(var)) {
+          type = S.adjustParameterTypeForObjCAutoRefCount(type,
+                                                          D->getLocation());
+          type = S.Context.getAdjustedParameterType(type);
+        }
+
+        if (!checkAPINotesReplacementType(S, var->getLocation(), var->getType(),
+                                          type)) {
+          var->setType(type);
+          var->setTypeSourceInfo(typeInfo);
+        }
+      } else if (auto property = dyn_cast<ObjCPropertyDecl>(D)) {
+        if (!checkAPINotesReplacementType(S, property->getLocation(),
+                                          property->getType(),
+                                          type)) {
+          property->setType(type, typeInfo);
+        }
+      } else {
+        llvm_unreachable("API notes allowed a type on an unknown declaration");
+      }
+    }
+  }
+
+  // Nullability.
+  if (auto Nullability = info.getNullability()) {
+    applyNullability(S, D, *Nullability, metadata);
+  }
+
+  // Handle common entity information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::CommonEntityInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for a parameter.
+static void ProcessAPINotes(Sema &S, ParmVarDecl *D,
+                            const api_notes::ParamInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // noescape
+  if (auto noescape = info.isNoEscape()) {
+    handleAPINotedAttribute<NoEscapeAttr>(S, D, *noescape, metadata, [&] {
+      return NoEscapeAttr::CreateImplicit(S.Context);
+    });
+  }
+
+  // Retain count convention
+  handleAPINotedRetainCountConvention(S, D, metadata,
+                                      info.getRetainCountConvention());
+
+  // Handle common entity information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::VariableInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for a global variable.
+static void ProcessAPINotes(Sema &S, VarDecl *D,
+                            const api_notes::GlobalVariableInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // Handle common entity information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::VariableInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for an Objective-C property.
+static void ProcessAPINotes(Sema &S, ObjCPropertyDecl *D,
+                            const api_notes::ObjCPropertyInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // Handle common entity information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::VariableInfo &>(info),
+                  metadata);
+  if (auto asAccessors = info.getSwiftImportAsAccessors()) {
+    handleAPINotedAttribute<SwiftImportPropertyAsAccessorsAttr>(S, D,
+                                                                *asAccessors,
+                                                                metadata, [&] {
+      return SwiftImportPropertyAsAccessorsAttr::CreateImplicit(S.Context);
+    });
+  }
+}
+
+namespace {
+  typedef llvm::PointerUnion<FunctionDecl *, ObjCMethodDecl *> FunctionOrMethod;
+}
+
+/// Process API notes for a function or method.
+static void ProcessAPINotes(Sema &S, FunctionOrMethod AnyFunc,
+                            const api_notes::FunctionInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // Find the declaration itself.
+  FunctionDecl *FD = AnyFunc.dyn_cast<FunctionDecl *>();
+  Decl *D = FD;
+  ObjCMethodDecl *MD = 0;
+  if (!D) {
+    MD = AnyFunc.get<ObjCMethodDecl *>();
+    D = MD;
+  }
+
+  // Nullability of return type.
+  if (info.NullabilityAudited) {
+    applyNullability(S, D, info.getReturnTypeInfo(), metadata);
+  }
+
+  // Parameters.
+  unsigned NumParams;
+  if (FD)
+    NumParams = FD->getNumParams();
+  else
+    NumParams = MD->param_size();
+
+  bool anyTypeChanged = false;
+  for (unsigned I = 0; I != NumParams; ++I) {
+    ParmVarDecl *Param;
+    if (FD)
+      Param = FD->getParamDecl(I);
+    else
+      Param = MD->param_begin()[I];
+
+    QualType paramTypeBefore = Param->getType();
+
+    if (I < info.Params.size()) {
+      ProcessAPINotes(S, Param, info.Params[I], metadata);
+    }
+
+    // Nullability.
+    if (info.NullabilityAudited)
+      applyNullability(S, Param, info.getParamTypeInfo(I), metadata);
+
+    if (paramTypeBefore.getAsOpaquePtr() != Param->getType().getAsOpaquePtr())
+      anyTypeChanged = true;
+  }
+
+  // Result type override.
+  QualType overriddenResultType;
+  if (metadata.IsActive && !info.ResultType.empty() &&
+      S.ParseTypeFromStringCallback) {
+    auto parsedType = S.ParseTypeFromStringCallback(info.ResultType,
+                                                    "<API Notes>",
+                                                    D->getLocation());
+    if (parsedType.isUsable()) {
+      QualType resultType = Sema::GetTypeFromParser(parsedType.get());
+
+      if (MD) {
+        if (!checkAPINotesReplacementType(S, D->getLocation(),
+                                          MD->getReturnType(), resultType)) {
+          auto resultTypeInfo =
+            S.Context.getTrivialTypeSourceInfo(resultType, D->getLocation());
+          MD->setReturnType(resultType);
+          MD->setReturnTypeSourceInfo(resultTypeInfo);
+        }
+      } else if (!checkAPINotesReplacementType(S, FD->getLocation(),
+                                               FD->getReturnType(),
+                                               resultType)) {
+        overriddenResultType = resultType;
+        anyTypeChanged = true;
+      }
+    }
+  }
+
+  // If the result type or any of the parameter types changed for a function
+  // declaration, we have to rebuild the type.
+  if (FD && anyTypeChanged) {
+    if (const auto *fnProtoType = FD->getType()->getAs<FunctionProtoType>()) {
+      if (overriddenResultType.isNull())
+        overriddenResultType = fnProtoType->getReturnType();
+
+      SmallVector<QualType, 4> paramTypes;
+      for (auto param : FD->parameters()) {
+        paramTypes.push_back(param->getType());
+      }
+      FD->setType(S.Context.getFunctionType(overriddenResultType,
+                                            paramTypes,
+                                            fnProtoType->getExtProtoInfo()));
+    } else if (!overriddenResultType.isNull()) {
+      const auto *fnNoProtoType = FD->getType()->castAs<FunctionNoProtoType>();
+      FD->setType(
+              S.Context.getFunctionNoProtoType(overriddenResultType,
+                                               fnNoProtoType->getExtInfo()));
+    }
+  }
+
+  // Retain count convention
+  handleAPINotedRetainCountConvention(S, D, metadata,
+                                      info.getRetainCountConvention());
+
+  // Handle common entity information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::CommonEntityInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for a global function.
+static void ProcessAPINotes(Sema &S, FunctionDecl *D,
+                            const api_notes::GlobalFunctionInfo &info,
+                            VersionedInfoMetadata metadata) {
+
+  // Handle common function information.
+  ProcessAPINotes(S, FunctionOrMethod(D),
+                  static_cast<const api_notes::FunctionInfo &>(info), metadata);
+}
+
+/// Process API notes for an enumerator.
+static void ProcessAPINotes(Sema &S, EnumConstantDecl *D,
+                            const api_notes::EnumConstantInfo &info,
+                            VersionedInfoMetadata metadata) {
+
+  // Handle common information.
+  ProcessAPINotes(S, D,
+                  static_cast<const api_notes::CommonEntityInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for an Objective-C method.
+static void ProcessAPINotes(Sema &S, ObjCMethodDecl *D,
+                            const api_notes::ObjCMethodInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // Designated initializers.
+  if (info.DesignatedInit) {
+    handleAPINotedAttribute<ObjCDesignatedInitializerAttr>(S, D, true, metadata,
+                                                           [&] {
+      if (ObjCInterfaceDecl *IFace = D->getClassInterface()) {
+        IFace->setHasDesignatedInitializers();
+      }
+      return ObjCDesignatedInitializerAttr::CreateImplicit(S.Context);
+    });
+  }
+
+  // Handle common function information.
+  ProcessAPINotes(S, FunctionOrMethod(D),
+                  static_cast<const api_notes::FunctionInfo &>(info), metadata);
+}
+
+/// Process API notes for a tag.
+static void ProcessAPINotes(Sema &S, TagDecl *D,
+                            const api_notes::TagInfo &info,
+                            VersionedInfoMetadata metadata) {
+  if (auto extensibility = info.EnumExtensibility) {
+    using api_notes::EnumExtensibilityKind;
+    bool shouldAddAttribute = (*extensibility != EnumExtensibilityKind::None);
+    handleAPINotedAttribute<EnumExtensibilityAttr>(S, D, shouldAddAttribute,
+                                                   metadata, [&] {
+      EnumExtensibilityAttr::Kind kind;
+      switch (extensibility.getValue()) {
+      case EnumExtensibilityKind::None:
+        llvm_unreachable("remove only");
+      case EnumExtensibilityKind::Open:
+        kind = EnumExtensibilityAttr::Open;
+        break;
+      case EnumExtensibilityKind::Closed:
+        kind = EnumExtensibilityAttr::Closed;
+        break;
+      }
+      return EnumExtensibilityAttr::CreateImplicit(S.Context, kind);
+    });
+  }
+
+  if (auto flagEnum = info.isFlagEnum()) {
+    handleAPINotedAttribute<FlagEnumAttr>(S, D, flagEnum.getValue(), metadata,
+                                          [&] {
+      return FlagEnumAttr::CreateImplicit(S.Context);
+    });
+  }
+
+  // Handle common type information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::CommonTypeInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for a typedef.
+static void ProcessAPINotes(Sema &S, TypedefNameDecl *D,
+                            const api_notes::TypedefInfo &info,
+                            VersionedInfoMetadata metadata) {
+  // swift_wrapper
+  using SwiftWrapperKind = api_notes::SwiftWrapperKind;
+
+  if (auto swiftWrapper = info.SwiftWrapper) {
+    handleAPINotedAttribute<SwiftNewtypeAttr>(S, D,
+      *swiftWrapper != SwiftWrapperKind::None, metadata,
+      [&] {
+        SwiftNewtypeAttr::NewtypeKind kind;
+        switch (*swiftWrapper) {
+        case SwiftWrapperKind::None:
+          llvm_unreachable("Shouldn't build an attribute");
+
+        case SwiftWrapperKind::Struct:
+          kind = SwiftNewtypeAttr::NK_Struct;
+          break;
+
+        case SwiftWrapperKind::Enum:
+          kind = SwiftNewtypeAttr::NK_Enum;
+          break;
+        }
+        return SwiftNewtypeAttr::CreateImplicit(
+                 S.Context,
+                 SwiftNewtypeAttr::GNU_swift_wrapper,
+                 kind);
+    });
+  }
+
+  // Handle common type information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::CommonTypeInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for an Objective-C class or protocol.
+static void ProcessAPINotes(Sema &S, ObjCContainerDecl *D,
+                            const api_notes::ObjCContextInfo &info,
+                            VersionedInfoMetadata metadata) {
+
+  // Handle common type information.
+  ProcessAPINotes(S, D, static_cast<const api_notes::CommonTypeInfo &>(info),
+                  metadata);
+}
+
+/// Process API notes for an Objective-C class.
+static void ProcessAPINotes(Sema &S, ObjCInterfaceDecl *D,
+                            const api_notes::ObjCContextInfo &info,
+                            VersionedInfoMetadata metadata) {
+  if (auto asNonGeneric = info.getSwiftImportAsNonGeneric()) {
+    handleAPINotedAttribute<SwiftImportAsNonGenericAttr>(S, D, *asNonGeneric,
+                                                         metadata, [&] {
+      return SwiftImportAsNonGenericAttr::CreateImplicit(S.Context);
+    });
+  }
+
+    if (auto objcMembers = info.getSwiftObjCMembers()) {
+    handleAPINotedAttribute<SwiftObjCMembersAttr>(S, D, *objcMembers,
+                                                         metadata, [&] {
+      return SwiftObjCMembersAttr::CreateImplicit(S.Context);
+    });
+  }
+
+  // Handle information common to Objective-C classes and protocols.
+  ProcessAPINotes(S, static_cast<clang::ObjCContainerDecl *>(D), info,
+                  metadata);
+}
+
+/// If we're applying API notes with an active, non-default version, and the
+/// versioned API notes have a SwiftName but the declaration normally wouldn't
+/// have one, add a removal attribute to make it clear that the new SwiftName
+/// attribute only applies to the active version of \p D, not to all versions.
+///
+/// This must be run \em before processing API notes for \p D, because otherwise
+/// any existing SwiftName attribute will have been packaged up in a 
+/// SwiftVersionedAttr.
+template <typename SpecificInfo>
+static void maybeAttachUnversionedSwiftName(
+    Sema &S, Decl *D,
+    const api_notes::APINotesReader::VersionedInfo<SpecificInfo> Info) {
+  if (D->hasAttr<SwiftNameAttr>())
+    return;
+  if (!Info.getSelected())
+    return;
+
+  // Is the active slice versioned, and does it set a Swift name?
+  VersionTuple SelectedVersion;
+  SpecificInfo SelectedInfoSlice;
+  std::tie(SelectedVersion, SelectedInfoSlice) = Info[*Info.getSelected()];
+  if (SelectedVersion.empty())
+    return;
+  if (SelectedInfoSlice.SwiftName.empty())
+    return;
+
+  // Does the unversioned slice /not/ set a Swift name?
+  for (const auto &VersionAndInfoSlice : Info) {
+    if (!VersionAndInfoSlice.first.empty())
+      continue;
+    if (!VersionAndInfoSlice.second.SwiftName.empty())
+      return;
+  }
+
+  // Then explicitly call that out with a removal attribute.
+  VersionedInfoMetadata DummyFutureMetadata(SelectedVersion, IsNotActive,
+                                            IsReplacement);
+  handleAPINotedAttribute<SwiftNameAttr>(S, D, /*add*/false,
+                                         DummyFutureMetadata,
+                                         []() -> SwiftNameAttr * {
+    llvm_unreachable("should not try to add an attribute here");
+  });
+}
+
+/// Processes all versions of versioned API notes.
+///
+/// Just dispatches to the various ProcessAPINotes functions in this file.
+template <typename SpecificDecl, typename SpecificInfo>
+static void ProcessVersionedAPINotes(
+    Sema &S, SpecificDecl *D,
+    const api_notes::APINotesReader::VersionedInfo<SpecificInfo> Info) {
+
+  maybeAttachUnversionedSwiftName(S, D, Info);
+
+  unsigned Selected = Info.getSelected().getValueOr(Info.size());
+
+  VersionTuple Version;
+  SpecificInfo InfoSlice;
+  for (unsigned i = 0, e = Info.size(); i != e; ++i) {
+    std::tie(Version, InfoSlice) = Info[i];
+    auto Active = (i == Selected) ? IsActive : IsNotActive;
+    auto Replacement = IsNotReplacement;
+    if (Active == IsNotActive && Version.empty()) {
+      Replacement = IsReplacement;
+      Version = Info[Selected].first;
+    }
+    ProcessAPINotes(S, D, InfoSlice, VersionedInfoMetadata(Version, Active,
+                                                           Replacement));
+  }
+}
+
+/// Process API notes that are associated with this declaration, mapping them
+/// to attributes as appropriate.
+void Sema::ProcessAPINotes(Decl *D) {
+  if (!D)
+    return;
+
+  // Globals.
+  if (D->getDeclContext()->isFileContext()) {
+    // Global variables.
+    if (auto VD = dyn_cast<VarDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        auto Info = Reader->lookupGlobalVariable(VD->getName());
+        ProcessVersionedAPINotes(*this, VD, Info);
+      }
+
+      return;
+    }
+
+    // Global functions.
+    if (auto FD = dyn_cast<FunctionDecl>(D)) {
+      if (FD->getDeclName().isIdentifier()) {
+        for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+          auto Info = Reader->lookupGlobalFunction(FD->getName());
+          ProcessVersionedAPINotes(*this, FD, Info);
+        }
+      }
+
+      return;
+    }
+
+    // Objective-C classes.
+    if (auto Class = dyn_cast<ObjCInterfaceDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        auto Info = Reader->lookupObjCClassInfo(Class->getName());
+        ProcessVersionedAPINotes(*this, Class, Info);
+      }
+
+      return;
+    }
+
+    // Objective-C protocols.
+    if (auto Protocol = dyn_cast<ObjCProtocolDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        auto Info = Reader->lookupObjCProtocolInfo(Protocol->getName());
+        ProcessVersionedAPINotes(*this, Protocol, Info);
+      }
+
+      return;
+    }
+
+    // Tags
+    if (auto Tag = dyn_cast<TagDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        auto Info = Reader->lookupTag(Tag->getName());
+        ProcessVersionedAPINotes(*this, Tag, Info);
+      }
+
+      return;
+    }
+
+    // Typedefs
+    if (auto Typedef = dyn_cast<TypedefNameDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        auto Info = Reader->lookupTypedef(Typedef->getName());
+        ProcessVersionedAPINotes(*this, Typedef, Info);
+      }
+
+      return;
+    }
+
+    return;
+  }
+
+  // Enumerators.
+  if (D->getDeclContext()->getRedeclContext()->isFileContext()) {
+    if (auto EnumConstant = dyn_cast<EnumConstantDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        auto Info = Reader->lookupEnumConstant(EnumConstant->getName());
+        ProcessVersionedAPINotes(*this, EnumConstant, Info);
+      }
+
+      return;
+    }
+  }
+
+  if (auto ObjCContainer = dyn_cast<ObjCContainerDecl>(D->getDeclContext())) {
+    // Location function that looks up an Objective-C context.
+    auto GetContext = [&](api_notes::APINotesReader *Reader)
+                        -> Optional<api_notes::ContextID> {
+      if (auto Protocol = dyn_cast<ObjCProtocolDecl>(ObjCContainer)) {
+        if (auto Found = Reader->lookupObjCProtocolID(Protocol->getName()))
+          return *Found;
+
+        return None;
+      }
+
+      if (auto Impl = dyn_cast<ObjCCategoryImplDecl>(ObjCContainer)) {
+        if (auto Cat = Impl->getCategoryDecl())
+          ObjCContainer = Cat;
+        else
+          return None;
+      }
+
+      if (auto Category = dyn_cast<ObjCCategoryDecl>(ObjCContainer)) {
+        if (Category->getClassInterface())
+          ObjCContainer = Category->getClassInterface();
+        else
+          return None;
+      }
+
+      if (auto Impl = dyn_cast<ObjCImplDecl>(ObjCContainer)) {
+        if (Impl->getClassInterface())
+          ObjCContainer = Impl->getClassInterface();
+        else
+          return None;
+      }
+
+      if (auto Class = dyn_cast<ObjCInterfaceDecl>(ObjCContainer)) {
+        if (auto Found = Reader->lookupObjCClassID(Class->getName()))
+          return *Found;
+
+        return None;
+
+      }
+
+      return None;
+    };
+
+    // Objective-C methods.
+    if (auto Method = dyn_cast<ObjCMethodDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        if (auto Context = GetContext(Reader)) {
+          // Map the selector.
+          Selector Sel = Method->getSelector();
+          SmallVector<StringRef, 2> SelPieces;
+          if (Sel.isUnarySelector())
+            SelPieces.push_back(Sel.getNameForSlot(0));
+          else {
+            for (unsigned i = 0, n = Sel.getNumArgs(); i != n; ++i)
+              SelPieces.push_back(Sel.getNameForSlot(i));
+          }
+
+          api_notes::ObjCSelectorRef SelectorRef;
+          SelectorRef.NumPieces = Sel.getNumArgs();
+          SelectorRef.Identifiers = SelPieces;
+
+          auto Info = Reader->lookupObjCMethod(*Context, SelectorRef,
+                                               Method->isInstanceMethod());
+          ProcessVersionedAPINotes(*this, Method, Info);
+        }
+      }
+    }
+
+    // Objective-C properties.
+    if (auto Property = dyn_cast<ObjCPropertyDecl>(D)) {
+      for (auto Reader : APINotes.findAPINotes(D->getLocation())) {
+        if (auto Context = GetContext(Reader)) {
+          bool isInstanceProperty =
+            (Property->getPropertyAttributesAsWritten() &
+               ObjCPropertyDecl::OBJC_PR_class) == 0;
+          auto Info = Reader->lookupObjCProperty(*Context, Property->getName(),
+                                                 isInstanceProperty);
+          ProcessVersionedAPINotes(*this, Property, Info);
+        }
+      }
+
+      return;
+    }
+
+    return;
+  }
+}
diff --git a/lib/Sema/SemaCodeComplete.cpp b/lib/Sema/SemaCodeComplete.cpp
index 2acc896d53..7a0b60087b 100644
--- a/lib/Sema/SemaCodeComplete.cpp
+++ b/lib/Sema/SemaCodeComplete.cpp
@@ -434,53 +434,6 @@ ResultBuilder::ShadowMapEntry::end() const {
   return iterator(DeclOrVector.get<DeclIndexPairVector *>()->end());
 }
 
-/// \brief Compute the qualification required to get from the current context
-/// (\p CurContext) to the target context (\p TargetContext).
-///
-/// \param Context the AST context in which the qualification will be used.
-///
-/// \param CurContext the context where an entity is being named, which is
-/// typically based on the current scope.
-///
-/// \param TargetContext the context in which the named entity actually 
-/// resides.
-///
-/// \returns a nested name specifier that refers into the target context, or
-/// NULL if no qualification is needed.
-static NestedNameSpecifier *
-getRequiredQualification(ASTContext &Context,
-                         const DeclContext *CurContext,
-                         const DeclContext *TargetContext) {
-  SmallVector<const DeclContext *, 4> TargetParents;
-  
-  for (const DeclContext *CommonAncestor = TargetContext;
-       CommonAncestor && !CommonAncestor->Encloses(CurContext);
-       CommonAncestor = CommonAncestor->getLookupParent()) {
-    if (CommonAncestor->isTransparentContext() ||
-        CommonAncestor->isFunctionOrMethod())
-      continue;
-    
-    TargetParents.push_back(CommonAncestor);
-  }
-
-  NestedNameSpecifier *Result = nullptr;
-  while (!TargetParents.empty()) {
-    const DeclContext *Parent = TargetParents.pop_back_val();
-
-    if (const NamespaceDecl *Namespace = dyn_cast<NamespaceDecl>(Parent)) {
-      if (!Namespace->getIdentifier())
-        continue;
-
-      Result = NestedNameSpecifier::Create(Context, Result, Namespace);
-    }
-    else if (const TagDecl *TD = dyn_cast<TagDecl>(Parent))
-      Result = NestedNameSpecifier::Create(Context, Result,
-                                           false,
-                                     Context.getTypeDeclType(TD).getTypePtr());
-  }  
-  return Result;
-}
-
 /// Determine whether \p Id is a name reserved for the implementation (C99
 /// 7.1.3, C++ [lib.global.names]).
 static bool isReservedName(const IdentifierInfo *Id,
@@ -592,9 +545,8 @@ bool ResultBuilder::CheckHiddenResult(Result &R, DeclContext *CurContext,
   R.QualifierIsInformative = false;
   
   if (!R.Qualifier)
-    R.Qualifier = getRequiredQualification(SemaRef.Context, 
-                                           CurContext, 
-                                           R.Declaration->getDeclContext());
+    R.Qualifier = NestedNameSpecifier::getRequiredQualification(
+        SemaRef.Context, CurContext, R.Declaration->getDeclContext());
   return false;
 }
 
@@ -3386,9 +3338,8 @@ static void MaybeAddOverrideCalls(Sema &S, DeclContext *InContext,
         
     // If we need a nested-name-specifier, add one now.
     if (!InContext) {
-      NestedNameSpecifier *NNS
-        = getRequiredQualification(S.Context, CurContext,
-                                   Overridden->getDeclContext());
+      NestedNameSpecifier *NNS = NestedNameSpecifier::getRequiredQualification(
+          S.Context, CurContext, Overridden->getDeclContext());
       if (NNS) {
         std::string Str;
         llvm::raw_string_ostream OS(Str);
@@ -4250,7 +4201,8 @@ void Sema::CodeCompleteCase(Scope *S) {
     // If there are no prior enumerators in C++, check whether we have to 
     // qualify the names of the enumerators that we suggest, because they
     // may not be visible in this scope.
-    Qualifier = getRequiredQualification(Context, CurContext, Enum);
+    Qualifier = NestedNameSpecifier::getRequiredQualification(Context,
+                                                              CurContext, Enum);
   }
   
   // Add any enumerators that have not yet been mentioned.
diff --git a/lib/Sema/SemaDecl.cpp b/lib/Sema/SemaDecl.cpp
index 7ca48c34e5..512080948e 100644
--- a/lib/Sema/SemaDecl.cpp
+++ b/lib/Sema/SemaDecl.cpp
@@ -2475,6 +2475,10 @@ static bool mergeDeclAttribute(Sema &S, NamedDecl *D,
     NewAttr = S.mergeMinSizeAttr(D, MA->getRange(), AttrSpellingListIndex);
   else if (const auto *OA = dyn_cast<OptimizeNoneAttr>(Attr))
     NewAttr = S.mergeOptimizeNoneAttr(D, OA->getRange(), AttrSpellingListIndex);
+  else if (const auto *SNA = dyn_cast<SwiftNameAttr>(Attr))
+    NewAttr = S.mergeSwiftNameAttr(D, SNA->getRange(), SNA->getName(),
+                                   AMK == Sema::AMK_Override,
+                                   AttrSpellingListIndex);
   else if (const auto *InternalLinkageA = dyn_cast<InternalLinkageAttr>(Attr))
     NewAttr = S.mergeInternalLinkageAttr(
         D, InternalLinkageA->getRange(),
@@ -2492,6 +2496,8 @@ static bool mergeDeclAttribute(Sema &S, NamedDecl *D,
            (AMK == Sema::AMK_Override ||
             AMK == Sema::AMK_ProtocolImplementation))
     NewAttr = nullptr;
+  else if (isa<SwiftPrivateAttr>(Attr) && AMK == Sema::AMK_Override)
+    NewAttr = nullptr;
   else if (const auto *UA = dyn_cast<UuidAttr>(Attr))
     NewAttr = S.mergeUuidAttr(D, UA->getRange(), AttrSpellingListIndex,
                               UA->getGuid());
@@ -11714,10 +11720,8 @@ void Sema::DiagnoseSizeOfParametersAndReturnValue(
   }
 }
 
-ParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,
-                                  SourceLocation NameLoc, IdentifierInfo *Name,
-                                  QualType T, TypeSourceInfo *TSInfo,
-                                  StorageClass SC) {
+QualType Sema::adjustParameterTypeForObjCAutoRefCount(QualType T,
+                                                      SourceLocation Loc) {
   // In ARC, infer a lifetime qualifier for appropriate parameter types.
   if (getLangOpts().ObjCAutoRefCount &&
       T.getObjCLifetime() == Qualifiers::OCL_None &&
@@ -11732,7 +11736,7 @@ ParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,
       if (!T.isConstQualified()) {
         DelayedDiagnostics.add(
             sema::DelayedDiagnostic::makeForbiddenType(
-            NameLoc, diag::err_arc_array_param_no_ownership, T, false));
+            Loc, diag::err_arc_array_param_no_ownership, T, false));
       }
       lifetime = Qualifiers::OCL_ExplicitNone;
     } else {
@@ -11741,6 +11745,16 @@ ParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,
     T = Context.getLifetimeQualifiedType(T, lifetime);
   }
 
+  return T;
+}
+
+ParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,
+                                  SourceLocation NameLoc, IdentifierInfo *Name,
+                                  QualType T, TypeSourceInfo *TSInfo,
+                                  StorageClass SC) {
+  // Perform Objective-C ARC adjustments.
+  T = adjustParameterTypeForObjCAutoRefCount(T, NameLoc);
+
   ParmVarDecl *New = ParmVarDecl::Create(Context, DC, StartLoc, NameLoc, Name,
                                          Context.getAdjustedParameterType(T),
                                          TSInfo, SC, nullptr);
@@ -12496,7 +12510,9 @@ void Sema::ActOnFinishDelayedAttribute(Scope *S, Decl *D,
   // Always attach attributes to the underlying decl.
   if (TemplateDecl *TD = dyn_cast<TemplateDecl>(D))
     D = TD->getTemplatedDecl();
-  ProcessDeclAttributeList(S, D, Attrs.getList());
+
+  ProcessDeclAttributeList(S, D, Attrs.getList());  
+  ProcessAPINotes(D);
 
   if (CXXMethodDecl *Method = dyn_cast_or_null<CXXMethodDecl>(D))
     if (Method->isStatic())
@@ -15220,6 +15236,7 @@ void Sema::ActOnFields(Scope *S, SourceLocation RecLoc, Decl *EnclosingDecl,
 
   if (Attr)
     ProcessDeclAttributeList(S, Record, Attr);
+  ProcessAPINotes(Record);
 }
 
 /// \brief Determine whether the given integral value is representable within
@@ -15520,6 +15537,8 @@ Decl *Sema::ActOnEnumConstant(Scope *S, Decl *theEnumDecl, Decl *lastEnumConst,
   if (Attr) ProcessDeclAttributeList(S, New, Attr);
   AddPragmaAttributes(S, New);
 
+  ProcessAPINotes(New);
+
   // Register this decl in the current scope stack.
   New->setAccess(TheEnumDecl->getAccess());
   PushOnScopeChains(New, S);
@@ -15743,6 +15762,7 @@ void Sema::ActOnEnumBody(SourceLocation EnumLoc, SourceRange BraceRange,
 
   if (Attr)
     ProcessDeclAttributeList(S, Enum, Attr);
+  ProcessAPINotes(Enum);
 
   if (Enum->isDependentType()) {
     for (unsigned i = 0, e = Elements.size(); i != e; ++i) {
diff --git a/lib/Sema/SemaDeclAttr.cpp b/lib/Sema/SemaDeclAttr.cpp
index 21fe46ad9d..8957863095 100644
--- a/lib/Sema/SemaDeclAttr.cpp
+++ b/lib/Sema/SemaDeclAttr.cpp
@@ -2464,6 +2464,15 @@ static void handleAvailabilityAttr(Sema &S, Decl *D,
           dyn_cast_or_null<StringLiteral>(Attr.getReplacementExpr()))
     Replacement = SE->getString();
 
+  if (II->getName() == "swift") {
+    if (Introduced.isValid() || Obsoleted.isValid() ||
+        (!IsUnavailable && !Deprecated.isValid())) {
+      S.Diag(Attr.getLoc(),
+             diag::warn_availability_swift_unavailable_deprecated_only);
+      return;
+    }
+  }
+
   AvailabilityAttr *NewAttr = S.mergeAvailabilityAttr(ND, Attr.getRange(), II,
                                                       false/*Implicit*/,
                                                       Introduced.Version,
@@ -4067,6 +4076,27 @@ OptimizeNoneAttr *Sema::mergeOptimizeNoneAttr(Decl *D, SourceRange Range,
                                           AttrSpellingListIndex);
 }
 
+SwiftNameAttr *Sema::mergeSwiftNameAttr(Decl *D, SourceRange Range,
+                                        StringRef Name, bool Override,
+                                        unsigned AttrSpellingListIndex) {
+  if (SwiftNameAttr *Inline = D->getAttr<SwiftNameAttr>()) {
+    if (Override) {
+      // FIXME: Warn about an incompatible override.
+      return nullptr;
+    }
+
+    if (Inline->getName() != Name && !Inline->isImplicit()) {
+      Diag(Inline->getLocation(), diag::warn_attribute_ignored) << Inline;
+      Diag(Range.getBegin(), diag::note_conflicting_attribute);
+    }
+
+    D->dropAttr<SwiftNameAttr>();
+  }
+
+  return ::new (Context) SwiftNameAttr(Range, Context, Name,
+                                       AttrSpellingListIndex);
+}
+
 static void handleAlwaysInlineAttr(Sema &S, Decl *D,
                                    const AttributeList &Attr) {
   if (checkAttrMutualExclusion<NotTailCalledAttr>(S, D, Attr.getRange(),
@@ -4894,6 +4924,40 @@ static void handleObjCRequiresSuperAttr(Sema &S, Decl *D,
                                         Attrs.getAttributeSpellingListIndex()));
 }
 
+static void handleNSErrorDomain(Sema &S, Decl *D, const AttributeList &Attr) {
+  if (!isa<TagDecl>(D)) {
+    S.Diag(D->getLocStart(), diag::err_nserrordomain_not_tagdecl)
+        << S.getLangOpts().CPlusPlus;
+    return;
+  }
+  IdentifierLoc *identLoc =
+      Attr.isArgIdent(0) ? Attr.getArgAsIdent(0) : nullptr;
+  if (!identLoc || !identLoc->Ident) {
+    // Try to locate the argument directly
+    SourceLocation loc = Attr.getLoc();
+    if (Attr.isArgExpr(0) && Attr.getArgAsExpr(0))
+      loc = Attr.getArgAsExpr(0)->getLocStart();
+
+    S.Diag(loc, diag::err_nserrordomain_requires_identifier);
+    return;
+  }
+
+  // Verify that the identifier is a valid decl in the C decl namespace
+  LookupResult lookupResult(S, DeclarationName(identLoc->Ident),
+                            SourceLocation(),
+                            Sema::LookupNameKind::LookupOrdinaryName);
+  if (!S.LookupName(lookupResult, S.TUScope) ||
+      !lookupResult.getAsSingle<VarDecl>()) {
+    S.Diag(identLoc->Loc, diag::err_nserrordomain_invalid_decl)
+        << identLoc->Ident;
+    return;
+  }
+
+  D->addAttr(::new (S.Context)
+                 NSErrorDomainAttr(Attr.getRange(), S.Context, identLoc->Ident,
+                                   Attr.getAttributeSpellingListIndex()));
+}
+
 static void handleCFAuditedTransferAttr(Sema &S, Decl *D,
                                         const AttributeList &Attr) {
   if (checkAttrMutualExclusion<CFUnknownTransferAttr>(S, D, Attr.getRange(),
@@ -5083,6 +5147,421 @@ static void handleObjCPreciseLifetimeAttr(Sema &S, Decl *D,
                                      Attr.getAttributeSpellingListIndex()));
 }
 
+static Optional<unsigned>
+validateSwiftFunctionName(StringRef Name,
+                          unsigned &SwiftParamCount,
+                          bool &IsSingleParamInit) {
+  SwiftParamCount = 0;
+
+  // Check whether this will be mapped to a getter or setter of a
+  // property.
+  bool isGetter = false;
+  bool isSetter = false;
+  if (Name.startswith("getter:")) {
+    isGetter = true;
+    Name = Name.substr(7);
+  } else if (Name.startswith("setter:")) {
+    isSetter = true;
+    Name = Name.substr(7);
+  }
+
+  if (Name.back() != ')')
+    return diag::warn_attr_swift_name_function;
+
+  StringRef BaseName, Parameters;
+  std::tie(BaseName, Parameters) = Name.split('(');
+
+  // Split at the first '.', if it exists, which separates the context
+  // name from the base name.
+  StringRef ContextName;
+  bool IsMember = false;
+  std::tie(ContextName, BaseName) = BaseName.split('.');
+  if (BaseName.empty()) {
+    BaseName = ContextName;
+    ContextName = StringRef();
+  } else if (ContextName.empty() || !isValidIdentifier(ContextName)) {
+    return diag::warn_attr_swift_name_context_name_invalid_identifier;
+  } else {
+    IsMember = true;
+  }
+
+  if (!isValidIdentifier(BaseName) || BaseName == "_")
+    return diag::warn_attr_swift_name_basename_invalid_identifier;
+
+  bool IsSubscript = BaseName == "subscript";
+  // A subscript accessor must be a getter or setter.
+  if (IsSubscript && !isGetter && !isSetter)
+    return diag::warn_attr_swift_name_subscript_not_accessor;
+  
+  if (Parameters.empty())
+    return diag::warn_attr_swift_name_missing_parameters;
+  Parameters = Parameters.drop_back(); // ')'
+
+  if (Parameters.empty()) {
+    // Setters and subscripts must have at least one parameter.
+    if (IsSubscript)
+      return diag::warn_attr_swift_name_subscript_no_parameter;
+    if (isSetter)
+      return diag::warn_attr_swift_name_setter_parameters;
+    
+    return None;
+  }
+
+  if (Parameters.back() != ':')
+    return diag::warn_attr_swift_name_function;
+
+  Optional<unsigned> SelfLocation;
+  Optional<unsigned> NewValueLocation;
+  unsigned NewValueCount = 0;
+  StringRef NextParam;
+  do {
+    std::tie(NextParam, Parameters) = Parameters.split(':');
+
+    if (!isValidIdentifier(NextParam))
+      return diag::warn_attr_swift_name_parameter_invalid_identifier;
+
+    // "self" indicates the "self" argument for a member.
+    if (IsMember && NextParam == "self") {
+      // More than one "self"?
+      if (SelfLocation) return diag::warn_attr_swift_name_multiple_selfs;
+
+      // The "self" location is the current parameter.
+      SelfLocation = SwiftParamCount;
+    }
+    
+    // "newValue" indicates the "newValue" argument for a setter.
+    if (NextParam == "newValue") {
+      // There should only be one 'newValue', but it's only significant for
+      // subscript accessors, so don't error right away.
+      ++NewValueCount;
+      
+      NewValueLocation = SwiftParamCount;
+    }
+    ++SwiftParamCount;
+  } while (!Parameters.empty());
+
+  // Only instance subscripts are currently supported.
+  if (IsSubscript && !SelfLocation)
+    return diag::warn_attr_swift_name_static_subscript;
+
+  IsSingleParamInit =
+      (SwiftParamCount == 1 && BaseName == "init" && NextParam != "_");
+
+  // Check the number of parameters for a getter/setter.
+  if (isGetter || isSetter) {
+    // Setters have one parameter for the new value.
+    unsigned NumExpectedParams;
+    unsigned ParamDiag;
+    
+    if (isSetter) {
+      NumExpectedParams = 1;
+      ParamDiag = diag::warn_attr_swift_name_setter_parameters;
+    } else {
+      NumExpectedParams = 0;
+      ParamDiag = diag::warn_attr_swift_name_getter_parameters;
+    }
+
+    // Instance methods have one parameter for "self".
+    if (SelfLocation) ++NumExpectedParams;
+    
+    // Subscripts may have additional parameters beyond the expected params for
+    // the index.
+    if (IsSubscript) {
+      if (SwiftParamCount < NumExpectedParams)
+        return ParamDiag;
+      // A subscript setter must explicitly label its newValue parameter to
+      // distinguish it from index parameters.
+      if (isSetter) {
+        if (!NewValueLocation)
+          return diag::warn_attr_swift_name_subscript_setter_no_newValue;
+        // There can only be one.
+        if (NewValueCount > 1)
+          return diag::warn_attr_swift_name_subscript_setter_multiple_newValues;
+      } else {
+        // Subscript getters should have no 'newValue:' parameter.
+        if (NewValueLocation)
+          return diag::warn_attr_swift_name_subscript_getter_newValue;
+      }
+    } else {
+      // Property accessors must have exactly the number of expected params.
+      if (SwiftParamCount != NumExpectedParams)
+        return ParamDiag;
+    }
+  }
+  
+  return None;
+}
+
+/// Do a check to make sure \p Name looks like a legal swift_name
+/// attribute for the decl \p D. Raise a diagnostic if the name is invalid
+/// for the given declaration.
+///
+/// For a function, this will validate a compound Swift name,
+/// e.g. <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>,
+/// and the function will output the number of parameter names, and whether this
+/// is a single-arg initializer.
+///
+/// For a type, enum constant, property, or variable declaration, this will
+/// validate either a simple identifier, or a qualified
+/// <code>context.identifier</code> name.
+///
+/// \returns true if the name is a valid swift name for \p D, false otherwise.
+bool Sema::DiagnoseSwiftName(Decl *D, StringRef Name,
+                             SourceLocation ArgLoc,
+                             IdentifierInfo *AttrName) {
+  if (isa<ObjCMethodDecl>(D) || isa<FunctionDecl>(D)) {
+    ArrayRef<ParmVarDecl*> Params;
+    unsigned ParamCount;
+
+    if (const auto *Method = dyn_cast<ObjCMethodDecl>(D)) {
+      ParamCount = Method->getSelector().getNumArgs();
+      Params = Method->parameters().slice(0, ParamCount);
+    } else {
+      const auto *Function = cast<FunctionDecl>(D);
+      ParamCount = Function->getNumParams();
+      Params = Function->parameters();
+      
+      if (!Function->hasWrittenPrototype()) {
+        Diag(ArgLoc, diag::warn_attr_swift_name_function_no_prototype)
+          << AttrName;
+        return false;
+      }
+    }
+
+    unsigned SwiftParamCount;
+    bool IsSingleParamInit;
+    if (auto diagID = validateSwiftFunctionName(Name, SwiftParamCount,
+                                                IsSingleParamInit)) {
+      Diag(ArgLoc, *diagID) << AttrName;
+      return false;
+    }
+  
+    bool ParamsOK;
+    if (SwiftParamCount == ParamCount) {
+      ParamsOK = true;
+    } else if (SwiftParamCount > ParamCount) {
+      ParamsOK = IsSingleParamInit && ParamCount == 0;
+    } else {
+      // We have fewer Swift parameters than Objective-C parameters, but that
+      // might be because we've transformed some of them. Check for potential
+      // "out" parameters and err on the side of not warning.
+      unsigned MaybeOutParamCount =
+          std::count_if(Params.begin(), Params.end(),
+                        [](const ParmVarDecl *Param) -> bool {
+        QualType ParamTy = Param->getType();
+        if (ParamTy->isReferenceType() || ParamTy->isPointerType())
+          return !ParamTy->getPointeeType().isConstQualified();
+        return false;
+      });
+      ParamsOK = (SwiftParamCount + MaybeOutParamCount >= ParamCount);
+    }
+
+    if (!ParamsOK) {
+      Diag(ArgLoc, diag::warn_attr_swift_name_num_params)
+          << (SwiftParamCount > ParamCount) << AttrName
+          << ParamCount << SwiftParamCount;
+      return false;
+    }
+
+  } else if (isa<EnumConstantDecl>(D) || isa<ObjCProtocolDecl>(D) ||
+             isa<ObjCInterfaceDecl>(D) || isa<ObjCPropertyDecl>(D) ||
+             isa<VarDecl>(D) || isa<TypedefNameDecl>(D) || isa<TagDecl>(D) ||
+             isa<IndirectFieldDecl>(D) || isa<FieldDecl>(D)) {
+    StringRef ContextName, BaseName;
+    std::tie(ContextName, BaseName) = Name.split('.');
+    if (BaseName.empty()) {
+      BaseName = ContextName;
+      ContextName = StringRef();
+    } else if (!isValidIdentifier(ContextName)) {
+      Diag(ArgLoc, diag::warn_attr_swift_name_context_name_invalid_identifier)
+        << AttrName;
+      return false;
+    }
+
+    if (!isValidIdentifier(BaseName)) {
+      Diag(ArgLoc, diag::warn_attr_swift_name_basename_invalid_identifier)
+        << AttrName;
+      return false;
+    }
+
+  } else {
+    Diag(ArgLoc, diag::warn_attr_swift_name_decl_kind) << AttrName;
+    return false;
+  }
+  return true;
+}
+
+static void handleSwiftName(Sema &S, Decl *D, const AttributeList &Attr) {
+  StringRef Name;
+  SourceLocation ArgLoc;
+  if (!S.checkStringLiteralArgumentAttr(Attr, 0, Name, &ArgLoc))
+    return;
+
+  if (!S.DiagnoseSwiftName(D, Name, ArgLoc, Attr.getName()))
+    return;
+
+  D->addAttr(::new (S.Context) SwiftNameAttr(Attr.getRange(), S.Context, Name,
+                                         Attr.getAttributeSpellingListIndex()));
+}
+
+static bool isErrorParameter(Sema &S, QualType paramType) {
+  if (auto ptr = paramType->getAs<PointerType>()) {
+    auto outerPointee = ptr->getPointeeType();
+
+    // NSError**.
+    if (auto objcPtr = outerPointee->getAs<ObjCObjectPointerType>()) {
+      if (auto iface = objcPtr->getInterfaceDecl())
+        if (iface->getIdentifier() == S.getNSErrorIdent())
+          return true;
+    }
+
+    // CFErrorRef*.
+    if (auto cPtr = outerPointee->getAs<PointerType>()) {
+      auto innerPointee = cPtr->getPointeeType();
+      if (auto recordType = innerPointee->getAs<RecordType>()) {
+        if (S.isCFError(recordType->getDecl()))
+          return true;
+      }
+    }
+  }
+
+  return false;
+}
+
+static void handleSwiftError(Sema &S, Decl *D, const AttributeList &attr) {
+  SwiftErrorAttr::ConventionKind convention;
+  IdentifierLoc *conventionLoc = attr.getArgAsIdent(0);
+  StringRef conventionStr = conventionLoc->Ident->getName();
+  if (!SwiftErrorAttr::ConvertStrToConventionKind(conventionStr, convention)) {
+    S.Diag(attr.getLoc(), diag::warn_attribute_type_not_supported)
+      << attr.getName() << conventionLoc->Ident;
+    return;
+  }
+
+  auto requireErrorParameter = [&]() -> bool {
+    if (D->isInvalidDecl()) return true;
+
+    for (unsigned i = 0, e = getFunctionOrMethodNumParams(D); i != e; ++i) {
+      if (isErrorParameter(S, getFunctionOrMethodParamType(D, i)))
+        return true;
+    }
+
+    S.Diag(attr.getLoc(), diag::err_attr_swift_error_no_error_parameter)
+      << attr.getName() << isa<ObjCMethodDecl>(D);
+    return false;
+  };
+
+  auto requirePointerResult = [&] {
+    if (D->isInvalidDecl()) return true;
+
+    // C, ObjC, and block pointers are definitely okay.
+    // References are definitely not okay.
+    // nullptr_t is weird but acceptable.
+    QualType returnType = getFunctionOrMethodResultType(D);
+    if (returnType->hasPointerRepresentation() &&
+        !returnType->isReferenceType()) return true;
+
+    S.Diag(attr.getLoc(), diag::err_attr_swift_error_return_type)
+      << attr.getName() << conventionStr
+      << isa<ObjCMethodDecl>(D) << /*pointer*/ 1;
+    return false;
+  };
+
+  auto requireIntegerResult = [&] {
+    if (D->isInvalidDecl()) return true;
+
+    QualType returnType = getFunctionOrMethodResultType(D);
+    if (returnType->isIntegralType(S.Context)) return true;
+
+    S.Diag(attr.getLoc(), diag::err_attr_swift_error_return_type)
+      << attr.getName() << conventionStr
+      << isa<ObjCMethodDecl>(D) << /*integral*/ 0;
+    return false;
+  };
+
+  switch (convention) {
+  case SwiftErrorAttr::None:
+    // No additional validation required.
+    break;
+
+  case SwiftErrorAttr::NonNullError:
+    if (!requireErrorParameter()) return;
+    break;
+
+  case SwiftErrorAttr::NullResult:
+    if (!requireErrorParameter()) return;
+    if (!requirePointerResult()) return;
+    break;
+
+  case SwiftErrorAttr::NonZeroResult:
+  case SwiftErrorAttr::ZeroResult:
+    if (!requireErrorParameter()) return;
+    if (!requireIntegerResult()) return;
+    break;
+  }
+
+  D->addAttr(::new (S.Context)
+             SwiftErrorAttr(attr.getRange(), S.Context, convention,
+                            attr.getAttributeSpellingListIndex()));
+}
+
+static void handleSwiftBridgeAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  // Make sure that there is a string literal as the annotation's single
+  // argument.
+  StringRef Str;
+  if (!S.checkStringLiteralArgumentAttr(Attr, 0, Str))
+    return;
+
+  // Don't duplicate annotations that are already set.
+  if (D->hasAttr<SwiftBridgeAttr>()) {
+    S.Diag(Attr.getLoc(), diag::warn_duplicate_attribute) << Attr.getName();
+    return;
+  }
+
+  D->addAttr(::new (S.Context)
+             SwiftBridgeAttr(Attr.getRange(), S.Context, Str,
+                             Attr.getAttributeSpellingListIndex()));
+}
+
+static void handleSwiftNewtypeAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  // Make sure that there is an identifier as the annotation's single
+  // argument.
+  if (Attr.getNumArgs() != 1) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments)
+      << Attr.getName() << 1;
+    Attr.setInvalid();
+    return;
+  }
+  if (!Attr.isArgIdent(0)) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_argument_type)
+      << Attr.getName() << AANT_ArgumentIdentifier;
+    Attr.setInvalid();
+    return;
+  }
+
+  IdentifierInfo *II = Attr.getArgAsIdent(0)->Ident;
+  SwiftNewtypeAttr::NewtypeKind Kind;
+  if (II->isStr("struct"))
+    Kind = SwiftNewtypeAttr::NK_Struct;
+  else if (II->isStr("enum"))
+    Kind = SwiftNewtypeAttr::NK_Enum;
+  else {
+    S.Diag(Attr.getLoc(), diag::warn_attribute_type_not_supported)
+      << Attr.getName() << II;
+    Attr.setInvalid();
+    return;
+  }
+
+  if (!isa<TypedefNameDecl>(D)) {
+    S.Diag(Attr.getLoc(), diag::warn_swift_newtype_attribute_non_typedef);
+    return;
+  }
+
+  D->addAttr(::new (S.Context)
+             SwiftNewtypeAttr(Attr.getRange(), S.Context, Kind,
+                              Attr.getAttributeSpellingListIndex()));
+}
+
 //===----------------------------------------------------------------------===//
 // Microsoft specific attribute handlers.
 //===----------------------------------------------------------------------===//
@@ -6239,6 +6718,9 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_ObjCBoxable:
     handleObjCBoxable(S, D, Attr);
     break;
+  case AttributeList::AT_NSErrorDomain:
+    handleNSErrorDomain(S, D, Attr);
+    break;
   case AttributeList::AT_CFAuditedTransfer:
     handleCFAuditedTransferAttr(S, D, Attr);
     break;
@@ -6298,6 +6780,9 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_ObjCSubclassingRestricted:
     handleSimpleAttribute<ObjCSubclassingRestrictedAttr>(S, D, Attr);
     break;
+  case AttributeList::AT_ObjCCompleteDefinition:
+    handleSimpleAttribute<ObjCCompleteDefinitionAttr>(S, D, Attr);
+    break;
   case AttributeList::AT_ObjCExplicitProtocolImpl:
     handleObjCSuppresProtocolAttr(S, D, Attr);
     break;
@@ -6570,6 +7055,25 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_RenderScriptKernel:
     handleSimpleAttribute<RenderScriptKernelAttr>(S, D, Attr);
     break;
+  // Swift attributes.
+  case AttributeList::AT_SwiftPrivate:
+    handleSimpleAttribute<SwiftPrivateAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_SwiftName:
+    handleSwiftName(S, D, Attr);
+    break;
+  case AttributeList::AT_SwiftError:
+    handleSwiftError(S, D, Attr);
+    break;
+  case AttributeList::AT_SwiftBridge:
+    handleSwiftBridgeAttr(S, D, Attr);
+    break;
+  case AttributeList::AT_SwiftObjCMembers:
+    handleSimpleAttribute<SwiftObjCMembersAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_SwiftNewtype:
+    handleSwiftNewtypeAttr(S, D, Attr);
+    break;
   // XRay attributes.
   case AttributeList::AT_XRayInstrument:
     handleSimpleAttribute<XRayInstrumentAttr>(S, D, Attr);
@@ -6812,6 +7316,9 @@ void Sema::ProcessDeclAttributes(Scope *S, Decl *D, const Declarator &PD) {
 
   // Apply additional attributes specified by '#pragma clang attribute'.
   AddPragmaAttributes(S, D);
+
+  // Look for API notes that map to attributes.
+  ProcessAPINotes(D);
 }
 
 /// Is the given declaration allowed to use a forbidden type?
diff --git a/lib/Sema/SemaDeclCXX.cpp b/lib/Sema/SemaDeclCXX.cpp
index 5e24649c71..65c8e41abb 100644
--- a/lib/Sema/SemaDeclCXX.cpp
+++ b/lib/Sema/SemaDeclCXX.cpp
@@ -8563,6 +8563,7 @@ Decl *Sema::ActOnStartNamespaceDef(Scope *NamespcScope,
 
   ProcessDeclAttributeList(DeclRegionScope, Namespc, AttrList);
   AddPragmaAttributes(DeclRegionScope, Namespc);
+  ProcessAPINotes(Namespc);
 
   // FIXME: Should we be merging attributes?
   if (const VisibilityAttr *Attr = Namespc->getAttr<VisibilityAttr>())
@@ -8952,6 +8953,7 @@ Decl *Sema::ActOnUsingDirective(Scope *S,
 
   if (UDir)
     ProcessDeclAttributeList(S, UDir, AttrList);
+  ProcessAPINotes(UDir);
 
   return UDir;
 }
@@ -10053,6 +10055,7 @@ Decl *Sema::ActOnAliasDeclaration(Scope *S,
 
   ProcessDeclAttributeList(S, NewTD, AttrList);
   AddPragmaAttributes(S, NewTD);
+  ProcessAPINotes(NewTD);
 
   CheckTypedefForVariablyModifiedType(S, NewTD);
   Invalid |= NewTD->isInvalidDecl();
diff --git a/lib/Sema/SemaDeclObjC.cpp b/lib/Sema/SemaDeclObjC.cpp
index ff3c07e938..5975303574 100644
--- a/lib/Sema/SemaDeclObjC.cpp
+++ b/lib/Sema/SemaDeclObjC.cpp
@@ -20,6 +20,7 @@
 #include "clang/AST/ExprObjC.h"
 #include "clang/AST/RecursiveASTVisitor.h"
 #include "clang/Basic/SourceManager.h"
+#include "clang/Edit/RefactoringFixits.h"
 #include "clang/Sema/DeclSpec.h"
 #include "clang/Sema/Lookup.h"
 #include "clang/Sema/Scope.h"
@@ -1015,6 +1016,10 @@ ActOnStartClassInterface(Scope *S, SourceLocation AtInterfaceLoc,
   ObjCInterfaceDecl *IDecl
     = ObjCInterfaceDecl::Create(Context, CurContext, AtInterfaceLoc, ClassName,
                                 typeParamList, PrevIDecl, ClassLoc);
+  if (AttrList)
+    ProcessDeclAttributeList(TUScope, IDecl, AttrList);
+  ProcessAPINotes(IDecl);
+
   if (PrevIDecl) {
     // Class already seen. Was it a definition?
     if (ObjCInterfaceDecl *Def = PrevIDecl->getDefinition()) {
@@ -1025,8 +1030,6 @@ ActOnStartClassInterface(Scope *S, SourceLocation AtInterfaceLoc,
     }
   }
   
-  if (AttrList)
-    ProcessDeclAttributeList(TUScope, IDecl, AttrList);
   AddPragmaAttributes(TUScope, IDecl);
   PushOnScopeChains(IDecl, TUScope);
 
@@ -1130,7 +1133,8 @@ Decl *Sema::ActOnCompatibilityAlias(SourceLocation AtLoc,
 
   // Everything checked out, instantiate a new alias declaration AST.
   ObjCCompatibleAliasDecl *AliasDecl =
-    ObjCCompatibleAliasDecl::Create(Context, CurContext, AtLoc, AliasName, CDecl);
+      ObjCCompatibleAliasDecl::Create(Context, CurContext, AliasLocation,
+                                      AliasName, CDecl, ClassLocation, AtLoc);
 
   if (!CheckObjCDeclScope(AliasDecl))
     PushOnScopeChains(AliasDecl, TUScope);
@@ -1215,6 +1219,7 @@ Sema::ActOnStartProtocolInterface(SourceLocation AtProtoInterfaceLoc,
   if (AttrList)
     ProcessDeclAttributeList(TUScope, PDecl, AttrList);
   AddPragmaAttributes(TUScope, PDecl);
+  ProcessAPINotes(PDecl);
 
   // Merge attributes from previous declarations.
   if (PrevDecl)
@@ -1739,13 +1744,15 @@ Sema::ActOnForwardProtocolDeclaration(SourceLocation AtProtocolLoc,
       = ObjCProtocolDecl::Create(Context, CurContext, Ident, 
                                  IdentPair.second, AtProtocolLoc,
                                  PrevDecl);
-        
+    ProcessAPINotes(PDecl);
+
     PushOnScopeChains(PDecl, TUScope);
     CheckObjCDeclScope(PDecl);
     
     if (attrList)
       ProcessDeclAttributeList(TUScope, PDecl, attrList);
     AddPragmaAttributes(TUScope, PDecl);
+    ProcessAPINotes(PDecl);
 
     if (PrevDecl)
       mergeDeclAttributes(PDecl, PrevDecl);
@@ -2156,23 +2163,28 @@ void Sema::CheckImplementationIvars(ObjCImplementationDecl *ImpDecl,
     Diag(IVI->getLocation(), diag::err_inconsistent_ivar_count);
 }
 
-static void WarnUndefinedMethod(Sema &S, SourceLocation ImpLoc,
-                                ObjCMethodDecl *method,
-                                bool &IncompleteImpl,
-                                unsigned DiagID,
-                                NamedDecl *NeededFor = nullptr) {
+static bool shouldWarnUndefinedMethod(const ObjCMethodDecl *M) {
   // No point warning no definition of method which is 'unavailable'.
-  switch (method->getAvailability()) {
+  switch (M->getAvailability()) {
   case AR_Available:
   case AR_Deprecated:
-    break;
+    return true;
 
-      // Don't warn about unavailable or not-yet-introduced methods.
+  // Don't warn about unavailable or not-yet-introduced methods.
   case AR_NotYetIntroduced:
   case AR_Unavailable:
-    return;
+    return false;
   }
-  
+  llvm_unreachable("Invalid availability");
+}
+
+static void WarnUndefinedMethod(Sema &S, SourceLocation ImpLoc,
+                                ObjCMethodDecl *method, bool &IncompleteImpl,
+                                unsigned DiagID,
+                                NamedDecl *NeededFor = nullptr) {
+  if (!shouldWarnUndefinedMethod(method))
+    return;
+
   // FIXME: For now ignore 'IncompleteImpl'.
   // Previously we grouped all unimplemented methods under a single
   // warning, but some users strongly voiced that they would prefer
@@ -2633,14 +2645,12 @@ static void findProtocolsWithExplicitImpls(const ObjCInterfaceDecl *Super,
 
 /// CheckProtocolMethodDefs - This routine checks unimplemented methods
 /// Declared in protocol, and those referenced by it.
-static void CheckProtocolMethodDefs(Sema &S,
-                                    SourceLocation ImpLoc,
-                                    ObjCProtocolDecl *PDecl,
-                                    bool& IncompleteImpl,
-                                    const Sema::SelectorSet &InsMap,
-                                    const Sema::SelectorSet &ClsMap,
-                                    ObjCContainerDecl *CDecl,
-                                    LazyProtocolNameSet &ProtocolsExplictImpl) {
+static void CheckProtocolMethodDefs(
+    Sema &S, SourceLocation ImpLoc, ObjCProtocolDecl *PDecl,
+    bool &IncompleteImpl, const Sema::SelectorSet &InsMap,
+    const Sema::SelectorSet &ClsMap, ObjCContainerDecl *CDecl,
+    LazyProtocolNameSet &ProtocolsExplictImpl,
+    llvm::SmallPtrSetImpl<ObjCProtocolDecl *> *MissingRequirements) {
   ObjCCategoryDecl *C = dyn_cast<ObjCCategoryDecl>(CDecl);
   ObjCInterfaceDecl *IDecl = C ? C->getClassInterface() 
                                : dyn_cast<ObjCInterfaceDecl>(CDecl);
@@ -2700,6 +2710,7 @@ static void CheckProtocolMethodDefs(Sema &S,
   // protocol. This lookup is slow, but occurs rarely in correct code
   // and otherwise would terminate in a warning.
 
+  bool HasMissingRequirements = false;
   // check unimplemented instance methods.
   if (!NSIDecl)
     for (auto *method : PDecl->instance_methods()) {
@@ -2729,8 +2740,13 @@ static void CheckProtocolMethodDefs(Sema &S,
                 continue;
             unsigned DIAG = diag::warn_unimplemented_protocol_method;
             if (!S.Diags.isIgnored(DIAG, ImpLoc)) {
-              WarnUndefinedMethod(S, ImpLoc, method, IncompleteImpl, DIAG,
-                                  PDecl);
+              if (MissingRequirements) {
+                if (!HasMissingRequirements)
+                  HasMissingRequirements = shouldWarnUndefinedMethod(method);
+              } else {
+                WarnUndefinedMethod(S, ImpLoc, method, IncompleteImpl, DIAG,
+                                    PDecl);
+              }
             }
           }
     }
@@ -2752,14 +2768,23 @@ static void CheckProtocolMethodDefs(Sema &S,
 
       unsigned DIAG = diag::warn_unimplemented_protocol_method;
       if (!S.Diags.isIgnored(DIAG, ImpLoc)) {
-        WarnUndefinedMethod(S, ImpLoc, method, IncompleteImpl, DIAG, PDecl);
+        if (MissingRequirements) {
+          if (!HasMissingRequirements)
+            HasMissingRequirements = shouldWarnUndefinedMethod(method);
+        } else {
+          WarnUndefinedMethod(S, ImpLoc, method, IncompleteImpl, DIAG, PDecl);
+        }
       }
     }
   }
+  if (HasMissingRequirements) {
+    assert(MissingRequirements != nullptr && "No missing requirements!");
+    MissingRequirements->insert(PDecl);
+  }
   // Check on this protocols's referenced protocols, recursively.
   for (auto *PI : PDecl->protocols())
     CheckProtocolMethodDefs(S, ImpLoc, PI, IncompleteImpl, InsMap, ClsMap,
-                            CDecl, ProtocolsExplictImpl);
+                            CDecl, ProtocolsExplictImpl, MissingRequirements);
 }
 
 /// MatchAllMethodDeclarations - Check methods declared in interface
@@ -2971,23 +2996,49 @@ void Sema::ImplMethodsVsClassMethods(Scope *S, ObjCImplDecl* IMPDecl,
 
   LazyProtocolNameSet ExplicitImplProtocols;
 
+  bool UseEditorDiagnostics = !getDiagnostics()
+                                   .getDiagnosticOptions()
+                                   .DiagnosticSerializationFile.empty() ||
+                              getLangOpts().AllowEditorPlaceholders;
+  llvm::SmallPtrSet<ObjCProtocolDecl *, 4> MissingRequirements;
   if (ObjCInterfaceDecl *I = dyn_cast<ObjCInterfaceDecl> (CDecl)) {
     for (auto *PI : I->all_referenced_protocols())
       CheckProtocolMethodDefs(*this, IMPDecl->getLocation(), PI, IncompleteImpl,
-                              InsMap, ClsMap, I, ExplicitImplProtocols);
+                              InsMap, ClsMap, I, ExplicitImplProtocols,
+                              UseEditorDiagnostics ? &MissingRequirements
+                                                   : nullptr);
   } else if (ObjCCategoryDecl *C = dyn_cast<ObjCCategoryDecl>(CDecl)) {
     // For extended class, unimplemented methods in its protocols will
     // be reported in the primary class.
     if (!C->IsClassExtension()) {
       for (auto *P : C->protocols())
-        CheckProtocolMethodDefs(*this, IMPDecl->getLocation(), P,
-                                IncompleteImpl, InsMap, ClsMap, CDecl,
-                                ExplicitImplProtocols);
+        CheckProtocolMethodDefs(
+            *this, IMPDecl->getLocation(), P, IncompleteImpl, InsMap, ClsMap,
+            CDecl, ExplicitImplProtocols,
+            UseEditorDiagnostics ? &MissingRequirements : nullptr);
       DiagnoseUnimplementedProperties(S, IMPDecl, CDecl,
                                       /*SynthesizeProperties=*/false);
     } 
   } else
     llvm_unreachable("invalid ObjCContainerDecl type.");
+  if (!MissingRequirements.empty()) {
+    {
+      auto DB = Diag(IMPDecl->getLocation(),
+                     diag::warn_class_does_not_conform_protocol)
+                << (isa<ObjCCategoryDecl>(CDecl) ? /*category=*/1 : /*class=*/0)
+                << CDecl << (unsigned)MissingRequirements.size();
+      unsigned NumProtocols = 0;
+      for (const auto *PD : MissingRequirements) {
+        DB << PD;
+        if (++NumProtocols > 3)
+          break;
+      }
+    }
+    auto DB =
+        Diag(IMPDecl->getLocation(), diag::note_add_missing_protocol_stubs);
+    edit::fillInMissingProtocolStubs::addMissingProtocolStubs(
+        Context, IMPDecl, [&](const FixItHint &Hint) { DB << Hint; });
+  }
 }
 
 Sema::DeclGroupPtrTy
@@ -3077,6 +3128,7 @@ Sema::ActOnForwardClassDeclaration(SourceLocation AtClassLoc,
                                   ClassName, TypeParams, PrevIDecl,
                                   IdentLocs[i]);
     IDecl->setAtEndRange(IdentLocs[i]);
+    ProcessAPINotes(IDecl);
 
     PushOnScopeChains(IDecl, TUScope);
     CheckObjCDeclScope(IDecl);
@@ -3988,7 +4040,7 @@ Decl *Sema::ActOnAtEnd(Scope *S, SourceRange AtEnd, ArrayRef<Decl *> allMethods,
       if (IDecl->getSuperClass() == nullptr) {
         // This class has no superclass, so check that it has been marked with
         // __attribute((objc_root_class)).
-        if (!HasRootClassAttr) {
+        if (!HasRootClassAttr && !IDecl->hasAttr<ObjCCompleteDefinitionAttr>()) {
           SourceLocation DeclLoc(IDecl->getLocation());
           SourceLocation SuperClassLoc(getLocForEndOfToken(DeclLoc));
           Diag(DeclLoc, diag::warn_objc_root_class_missing)
@@ -4084,12 +4136,10 @@ CvtQTToAstBitMask(ObjCDeclSpec::ObjCDeclQualifier PQTVal) {
   return (Decl::ObjCDeclQualifier) (unsigned) PQTVal;
 }
 
-/// \brief Check whether the declared result type of the given Objective-C
-/// method declaration is compatible with the method's class.
-///
-static Sema::ResultTypeCompatibilityKind 
-CheckRelatedResultTypeCompatibility(Sema &S, ObjCMethodDecl *Method,
-                                    ObjCInterfaceDecl *CurrentClass) {
+Sema::ResultTypeCompatibilityKind
+Sema::checkRelatedResultTypeCompatibility(
+    const ObjCMethodDecl *Method,
+    const ObjCInterfaceDecl *CurrentClass) {
   QualType ResultType = Method->getReturnType();
 
   // If an Objective-C method inherits its related result type, then its 
@@ -4593,6 +4643,7 @@ Decl *Sema::ActOnMethodDeclaration(
     // Apply the attributes to the parameter.
     ProcessDeclAttributeList(TUScope, Param, ArgInfo[i].ArgAttrs);
     AddPragmaAttributes(TUScope, Param);
+    ProcessAPINotes(Param);
 
     if (Param->hasAttr<BlocksAttr>()) {
       Diag(Param->getLocation(), diag::err_block_on_nonlocal);
@@ -4624,6 +4675,7 @@ Decl *Sema::ActOnMethodDeclaration(
   if (AttrList)
     ProcessDeclAttributeList(TUScope, ObjCMethod, AttrList);
   AddPragmaAttributes(TUScope, ObjCMethod);
+  ProcessAPINotes(ObjCMethod);
 
   // Add the method now.
   const ObjCMethodDecl *PrevMethod = nullptr;
@@ -4679,7 +4731,7 @@ Decl *Sema::ActOnMethodDeclaration(
   }
 
   ResultTypeCompatibilityKind RTC
-    = CheckRelatedResultTypeCompatibility(*this, ObjCMethod, CurrentClass);
+    = checkRelatedResultTypeCompatibility(ObjCMethod, CurrentClass);
 
   CheckObjCMethodOverrides(ObjCMethod, CurrentClass, RTC);
 
diff --git a/lib/Sema/SemaObjCProperty.cpp b/lib/Sema/SemaObjCProperty.cpp
index ea5b1da46f..5ebdf1d615 100644
--- a/lib/Sema/SemaObjCProperty.cpp
+++ b/lib/Sema/SemaObjCProperty.cpp
@@ -644,8 +644,6 @@ ObjCPropertyDecl *Sema::CreatePropertyDecl(Scope *S,
     PDecl->setInvalidDecl();
   }
 
-  ProcessDeclAttributes(S, PDecl, FD.D);
-
   // Regardless of setter/getter attribute, we save the default getter/setter
   // selector names in anticipation of declaration of setter/getter methods.
   PDecl->setGetterName(GetterSel, GetterNameLoc);
@@ -653,6 +651,8 @@ ObjCPropertyDecl *Sema::CreatePropertyDecl(Scope *S,
   PDecl->setPropertyAttributesAsWritten(
                           makePropertyAttributesAsWritten(AttributesAsWritten));
 
+  ProcessDeclAttributes(S, PDecl, FD.D);
+
   if (Attributes & ObjCDeclSpec::DQ_PR_readonly)
     PDecl->setPropertyAttributes(ObjCPropertyDecl::OBJC_PR_readonly);
 
@@ -2406,6 +2406,8 @@ void Sema::ProcessPropertyDecl(ObjCPropertyDecl *property) {
           SectionAttr::CreateImplicit(Context, SectionAttr::GNU_section,
                                       SA->getName(), Loc));
 
+    ProcessAPINotes(GetterMethod);
+
     if (getLangOpts().ObjCAutoRefCount)
       CheckARCMethodDecl(GetterMethod);
   } else
@@ -2471,6 +2473,9 @@ void Sema::ProcessPropertyDecl(ObjCPropertyDecl *property) {
         SetterMethod->addAttr(
             SectionAttr::CreateImplicit(Context, SectionAttr::GNU_section,
                                         SA->getName(), Loc));
+
+    ProcessAPINotes(SetterMethod);
+
       // It's possible for the user to have set a very odd custom
       // setter selector that causes it to have a method family.
       if (getLangOpts().ObjCAutoRefCount)
diff --git a/lib/Sema/SemaStmt.cpp b/lib/Sema/SemaStmt.cpp
index 1ebc36716a..1e56d63d82 100644
--- a/lib/Sema/SemaStmt.cpp
+++ b/lib/Sema/SemaStmt.cpp
@@ -11,12 +11,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "clang/Sema/SemaInternal.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/ASTDiagnostic.h"
 #include "clang/AST/ASTLambda.h"
 #include "clang/AST/CharUnits.h"
 #include "clang/AST/CXXInheritance.h"
+#include "clang/AST/CharUnits.h"
 #include "clang/AST/DeclObjC.h"
 #include "clang/AST/EvaluatedExprVisitor.h"
 #include "clang/AST/ExprCXX.h"
@@ -27,11 +27,13 @@
 #include "clang/AST/TypeLoc.h"
 #include "clang/AST/TypeOrdering.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/Edit/RefactoringFixits.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Sema/Initialization.h"
 #include "clang/Sema/Lookup.h"
 #include "clang/Sema/Scope.h"
 #include "clang/Sema/ScopeInfo.h"
+#include "clang/Sema/SemaInternal.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/STLExtras.h"
@@ -1202,14 +1204,22 @@ Sema::ActOnFinishSwitchStmt(SourceLocation SwitchLoc, Stmt *Switch,
 
       // Produce a nice diagnostic if multiple values aren't handled.
       if (!UnhandledNames.empty()) {
-        DiagnosticBuilder DB = Diag(CondExpr->getExprLoc(),
-                                    TheDefaultStmt ? diag::warn_def_missing_case
-                                                   : diag::warn_missing_case)
-                               << (int)UnhandledNames.size();
-
-        for (size_t I = 0, E = std::min(UnhandledNames.size(), (size_t)3);
-             I != E; ++I)
-          DB << UnhandledNames[I];
+        {
+          DiagnosticBuilder DB =
+              Diag(CondExpr->getExprLoc(), TheDefaultStmt
+                                               ? diag::warn_def_missing_case
+                                               : diag::warn_missing_case)
+              << (int)UnhandledNames.size();
+
+          for (size_t I = 0, E = std::min(UnhandledNames.size(), (size_t)3);
+               I != E; ++I)
+            DB << UnhandledNames[I];
+        }
+        auto DB =
+            Diag(CondExpr->getExprLoc(), diag::note_fill_in_missing_cases);
+        edit::fillInMissingSwitchEnumCases(
+            Context, SS, ED, CurContext,
+            [&](const FixItHint &Hint) { DB << Hint; });
       }
 
       if (!hasCasesNotInSwitch)
diff --git a/lib/Sema/SemaTemplate.cpp b/lib/Sema/SemaTemplate.cpp
index 7c6af5793f..6544b23f85 100644
--- a/lib/Sema/SemaTemplate.cpp
+++ b/lib/Sema/SemaTemplate.cpp
@@ -1503,6 +1503,7 @@ Sema::CheckClassTemplate(Scope *S, unsigned TagSpec, TagUseKind TUK,
 
   if (Attr)
     ProcessDeclAttributeList(S, NewClass, Attr);
+  ProcessAPINotes(NewClass);
 
   if (PrevClassTemplate)
     mergeDeclAttributes(NewClass, PrevClassTemplate->getTemplatedDecl());
@@ -7651,6 +7652,7 @@ Sema::ActOnClassTemplateSpecialization(Scope *S, unsigned TagSpec,
 
   if (Attr)
     ProcessDeclAttributeList(S, Specialization, Attr);
+  ProcessAPINotes(Specialization);
 
   // Add alignment attributes if necessary; these attributes are checked when
   // the ASTContext lays out the structure.
@@ -8694,6 +8696,7 @@ Sema::ActOnExplicitInstantiation(Scope *S,
   bool PreviouslyDLLExported = Specialization->hasAttr<DLLExportAttr>();
   if (Attr)
     ProcessDeclAttributeList(S, Specialization, Attr);
+  ProcessAPINotes(Specialization);
 
   // Add the explicit instantiation into its lexical context. However,
   // since explicit instantiations are never found by name lookup, we
@@ -9103,6 +9106,7 @@ DeclResult Sema::ActOnExplicitInstantiation(Scope *S,
         // Merge attributes.
         if (AttributeList *Attr = D.getDeclSpec().getAttributes().getList())
           ProcessDeclAttributeList(S, Prev, Attr);
+        ProcessAPINotes(Prev);
       }
       if (TSK == TSK_ExplicitInstantiationDefinition)
         InstantiateVariableDefinition(D.getIdentifierLoc(), Prev);
@@ -9267,6 +9271,7 @@ DeclResult Sema::ActOnExplicitInstantiation(Scope *S,
 
   if (Attr)
     ProcessDeclAttributeList(S, Specialization, Attr);
+  ProcessAPINotes(Specialization);
 
   // In MSVC mode, dllimported explicit instantiation definitions are treated as
   // instantiation declarations.
diff --git a/lib/Sema/SemaType.cpp b/lib/Sema/SemaType.cpp
index af060cf21b..4584823f18 100644
--- a/lib/Sema/SemaType.cpp
+++ b/lib/Sema/SemaType.cpp
@@ -1157,20 +1157,6 @@ TypeResult Sema::actOnObjCTypeArgsAndProtocolQualifiers(
     ResultTL = ObjCObjectPointerTL.getPointeeLoc();
   }
 
-  if (auto OTPTL = ResultTL.getAs<ObjCTypeParamTypeLoc>()) {
-    // Protocol qualifier information.
-    if (OTPTL.getNumProtocols() > 0) {
-      assert(OTPTL.getNumProtocols() == Protocols.size());
-      OTPTL.setProtocolLAngleLoc(ProtocolLAngleLoc);
-      OTPTL.setProtocolRAngleLoc(ProtocolRAngleLoc);
-      for (unsigned i = 0, n = Protocols.size(); i != n; ++i)
-        OTPTL.setProtocolLoc(i, ProtocolLocs[i]);
-    }
-
-    // We're done. Return the completed type to the parser.
-    return CreateParsedType(Result, ResultTInfo);
-  }
-
   auto ObjCObjectTL = ResultTL.castAs<ObjCObjectTypeLoc>();
 
   // Type argument information.
@@ -3510,32 +3496,9 @@ classifyPointerDeclarator(Sema &S, QualType type, Declarator &declarator,
     if (auto recordType = type->getAs<RecordType>()) {
       RecordDecl *recordDecl = recordType->getDecl();
 
-      bool isCFError = false;
-      if (S.CFError) {
-        // If we already know about CFError, test it directly.
-        isCFError = (S.CFError == recordDecl);
-      } else {
-        // Check whether this is CFError, which we identify based on its bridge
-        // to NSError. CFErrorRef used to be declared with "objc_bridge" but is
-        // now declared with "objc_bridge_mutable", so look for either one of
-        // the two attributes.
-        if (recordDecl->getTagKind() == TTK_Struct && numNormalPointers > 0) {
-          IdentifierInfo *bridgedType = nullptr;
-          if (auto bridgeAttr = recordDecl->getAttr<ObjCBridgeAttr>())
-            bridgedType = bridgeAttr->getBridgedType();
-          else if (auto bridgeAttr =
-                       recordDecl->getAttr<ObjCBridgeMutableAttr>())
-            bridgedType = bridgeAttr->getBridgedType();
-
-          if (bridgedType == S.getNSErrorIdent()) {
-            S.CFError = recordDecl;
-            isCFError = true;
-          }
-        }
-      }
-
       // If this is CFErrorRef*, report it as such.
-      if (isCFError && numNormalPointers == 2 && numTypeSpecifierPointers < 2) {
+      if (numNormalPointers == 2 && numTypeSpecifierPointers < 2 &&
+          S.isCFError(recordDecl)) {
         return PointerDeclaratorKind::CFErrorRefPointer;
       }
       break;
@@ -3559,6 +3522,33 @@ classifyPointerDeclarator(Sema &S, QualType type, Declarator &declarator,
   }
 }
 
+bool Sema::isCFError(RecordDecl *recordDecl) {
+  // If we already know about CFError, test it directly.
+  if (CFError) {
+    return (CFError == recordDecl);
+  }
+
+  // Check whether this is CFError, which we identify based on being
+  // bridged to NSError. CFErrorRef used to be declared with "objc_bridge" but
+  // is now declared with "objc_bridge_mutable", so look for either one of the
+  // two attributes.
+  if (recordDecl->getTagKind() == TTK_Struct) {
+    IdentifierInfo *bridgedType = nullptr;
+    if (auto bridgeAttr = recordDecl->getAttr<ObjCBridgeAttr>())
+      bridgedType = bridgeAttr->getBridgedType();
+    else if (auto bridgeAttr =
+                 recordDecl->getAttr<ObjCBridgeMutableAttr>())
+      bridgedType = bridgeAttr->getBridgedType();
+
+    if (bridgedType == getNSErrorIdent()) {
+      CFError = recordDecl;
+      return true;
+    }
+  }
+
+  return false;
+}
+
 static FileID getNullabilityCompletenessCheckFileID(Sema &S,
                                                     SourceLocation loc) {
   // If we're anywhere in a function, method, or closure context, don't perform
@@ -6286,12 +6276,34 @@ static bool handleMSPointerTypeQualifierAttr(TypeProcessingState &State,
   return false;
 }
 
+/// Rebuild an attributed type without the nullability attribute on it.
+static QualType rebuildAttributedTypeWithoutNullability(ASTContext &ctx,
+                                                        QualType type) {
+  auto attributed = dyn_cast<AttributedType>(type.getTypePtr());
+  if (!attributed) return type;
+
+  // Skip the nullability attribute; we're done.
+  if (attributed->getImmediateNullability()) {
+    return attributed->getModifiedType();
+  }
+
+  // Build the modified type.
+  auto modified = rebuildAttributedTypeWithoutNullability(
+                    ctx, attributed->getModifiedType());
+  assert(modified.getTypePtr() != attributed->getModifiedType().getTypePtr());
+  return ctx.getAttributedType(attributed->getAttrKind(), modified,
+                                   attributed->getEquivalentType());
+}
+
 bool Sema::checkNullabilityTypeSpecifier(QualType &type,
                                          NullabilityKind nullability,
                                          SourceLocation nullabilityLoc,
                                          bool isContextSensitive,
-                                         bool allowOnArrayType) {
-  recordNullabilitySeen(*this, nullabilityLoc);
+                                         bool allowOnArrayType,
+                                         bool implicit,
+                                         bool overrideExisting) {
+  if (!implicit)
+    recordNullabilitySeen(*this, nullabilityLoc);
 
   // Check for existing nullability attributes on the type.
   QualType desugared = type;
@@ -6300,6 +6312,9 @@ bool Sema::checkNullabilityTypeSpecifier(QualType &type,
     if (auto existingNullability = attributed->getImmediateNullability()) {
       // Duplicated nullability.
       if (nullability == *existingNullability) {
+        if (implicit)
+          break;
+
         Diag(nullabilityLoc, diag::warn_nullability_duplicate)
           << DiagNullabilityKind(nullability, isContextSensitive)
           << FixItHint::CreateRemoval(nullabilityLoc);
@@ -6307,11 +6322,16 @@ bool Sema::checkNullabilityTypeSpecifier(QualType &type,
         break;
       } 
 
-      // Conflicting nullability.
-      Diag(nullabilityLoc, diag::err_nullability_conflicting)
-        << DiagNullabilityKind(nullability, isContextSensitive)
-        << DiagNullabilityKind(*existingNullability, false);
-      return true;
+      if (!overrideExisting) {
+        // Conflicting nullability.
+        Diag(nullabilityLoc, diag::err_nullability_conflicting)
+          << DiagNullabilityKind(nullability, isContextSensitive)
+          << DiagNullabilityKind(*existingNullability, false);
+        return true;
+      }
+
+      // Rebuild the attributed type, dropping the existing nullability.
+      type  = rebuildAttributedTypeWithoutNullability(Context, type);
     }
 
     desugared = attributed->getModifiedType();
@@ -6322,7 +6342,7 @@ bool Sema::checkNullabilityTypeSpecifier(QualType &type,
   // have nullability specifiers on them, which means we cannot
   // provide a useful Fix-It.
   if (auto existingNullability = desugared->getNullability(Context)) {
-    if (nullability != *existingNullability) {
+    if (nullability != *existingNullability && !implicit) {
       Diag(nullabilityLoc, diag::err_nullability_conflicting)
         << DiagNullabilityKind(nullability, isContextSensitive)
         << DiagNullabilityKind(*existingNullability, false);
@@ -6347,15 +6367,16 @@ bool Sema::checkNullabilityTypeSpecifier(QualType &type,
   // If this definitely isn't a pointer type, reject the specifier.
   if (!desugared->canHaveNullability() &&
       !(allowOnArrayType && desugared->isArrayType())) {
-    Diag(nullabilityLoc, diag::err_nullability_nonpointer)
-      << DiagNullabilityKind(nullability, isContextSensitive) << type;
+    if (!implicit) {
+      Diag(nullabilityLoc, diag::err_nullability_nonpointer)
+        << DiagNullabilityKind(nullability, isContextSensitive) << type;
+    }
     return true;
   }
   
   // For the context-sensitive keywords/Objective-C property
   // attributes, require that the type be a single-level pointer.
   if (isContextSensitive) {
-    // Make sure that the pointee isn't itself a pointer type.
     const Type *pointeeType;
     if (desugared->isArrayType())
       pointeeType = desugared->getArrayElementTypeNoTypeQual();
@@ -6384,13 +6405,6 @@ bool Sema::checkNullabilityTypeSpecifier(QualType &type,
 }
 
 bool Sema::checkObjCKindOfType(QualType &type, SourceLocation loc) {
-  if (isa<ObjCTypeParamType>(type)) {
-    // Build the attributed type to record where __kindof occurred.
-    type = Context.getAttributedType(AttributedType::attr_objc_kindof,
-                                     type, type);
-    return false;
-  }
-
   // Find out if it's an Objective-C object or object pointer type;
   const ObjCObjectPointerType *ptrType = type->getAs<ObjCObjectPointerType>();
   const ObjCObjectType *objType = ptrType ? ptrType->getObjectType() 
@@ -7243,7 +7257,7 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
               mapNullabilityAttrKind(attr.getKind()),
               attr.getLoc(),
               attr.isContextSensitiveKeywordAttribute(),
-              allowOnArrayType)) {
+              allowOnArrayType, /*implicit=*/false)) {
           attr.setInvalid();
         }
 
diff --git a/lib/Serialization/ASTReader.cpp b/lib/Serialization/ASTReader.cpp
index 4ed822e04f..b8b9b79287 100644
--- a/lib/Serialization/ASTReader.cpp
+++ b/lib/Serialization/ASTReader.cpp
@@ -4254,6 +4254,11 @@ ASTReader::readUnhashedControlBlock(ModuleFile &F, bool WasImportedBy,
     return Failure;
   }
 
+  // FIXME: Should we check the signature even if DisableValidation?
+  if (PP.getLangOpts().NeededByPCHOrCompilationUsesPCH || DisableValidation ||
+      (AllowConfigurationMismatch && Result == ConfigurationMismatch))
+    return Success;
+
   if (Result == OutOfDate && F.Kind == MK_ImplicitModule) {
     // If this module has already been finalized in the PCMCache, we're stuck
     // with it; we can only load a single version of each module.
@@ -4975,6 +4980,7 @@ ASTReader::ReadSubmoduleBlock(ModuleFile &F, unsigned ClientLoadCapabilities) {
       bool IsExplicit = Record[Idx++];
       bool IsSystem = Record[Idx++];
       bool IsExternC = Record[Idx++];
+      bool IsSwiftInferImportAsMember = Record[Idx++];
       bool InferSubmodules = Record[Idx++];
       bool InferExplicitSubmodules = Record[Idx++];
       bool InferExportWildcard = Record[Idx++];
@@ -5022,6 +5028,7 @@ ASTReader::ReadSubmoduleBlock(ModuleFile &F, unsigned ClientLoadCapabilities) {
       CurrentModule->IsFromModuleFile = true;
       CurrentModule->IsSystem = IsSystem || CurrentModule->IsSystem;
       CurrentModule->IsExternC = IsExternC;
+      CurrentModule->IsSwiftInferImportAsMember = IsSwiftInferImportAsMember;
       CurrentModule->InferSubmodules = InferSubmodules;
       CurrentModule->InferExplicitSubmodules = InferExplicitSubmodules;
       CurrentModule->InferExportWildcard = InferExportWildcard;
diff --git a/lib/Serialization/ASTReaderDecl.cpp b/lib/Serialization/ASTReaderDecl.cpp
index efbaf92a84..96453adcdb 100644
--- a/lib/Serialization/ASTReaderDecl.cpp
+++ b/lib/Serialization/ASTReaderDecl.cpp
@@ -1160,6 +1160,8 @@ void ASTDeclReader::VisitObjCCategoryDecl(ObjCCategoryDecl *CD) {
 void ASTDeclReader::VisitObjCCompatibleAliasDecl(ObjCCompatibleAliasDecl *CAD) {
   VisitNamedDecl(CAD);
   CAD->setClassInterface(ReadDeclAs<ObjCInterfaceDecl>());
+  CAD->setClassInterfaceLoc(ReadSourceLocation());
+  CAD->setAtLoc(ReadSourceLocation());
 }
 
 void ASTDeclReader::VisitObjCPropertyDecl(ObjCPropertyDecl *D) {
diff --git a/lib/Serialization/ASTWriter.cpp b/lib/Serialization/ASTWriter.cpp
index 1e72ced2ee..ee387bfd86 100644
--- a/lib/Serialization/ASTWriter.cpp
+++ b/lib/Serialization/ASTWriter.cpp
@@ -2782,6 +2782,7 @@ void ASTWriter::WriteSubmodules(Module *WritingModule) {
   Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsExplicit
   Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsSystem
   Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsExternC
+  Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // IsSwiftInferIAM...
   Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // InferSubmodules...
   Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // InferExplicit...
   Abbrev->Add(BitCodeAbbrevOp(BitCodeAbbrevOp::Fixed, 1)); // InferExportWild...
@@ -2887,6 +2888,7 @@ void ASTWriter::WriteSubmodules(Module *WritingModule) {
                                          Mod->IsExplicit,
                                          Mod->IsSystem,
                                          Mod->IsExternC,
+                                         Mod->IsSwiftInferImportAsMember,
                                          Mod->InferSubmodules,
                                          Mod->InferExplicitSubmodules,
                                          Mod->InferExportWildcard,
diff --git a/lib/Serialization/ASTWriterDecl.cpp b/lib/Serialization/ASTWriterDecl.cpp
index bb72a3b383..8c8e217d3a 100644
--- a/lib/Serialization/ASTWriterDecl.cpp
+++ b/lib/Serialization/ASTWriterDecl.cpp
@@ -787,6 +787,8 @@ void ASTDeclWriter::VisitObjCCategoryDecl(ObjCCategoryDecl *D) {
 void ASTDeclWriter::VisitObjCCompatibleAliasDecl(ObjCCompatibleAliasDecl *D) {
   VisitNamedDecl(D);
   Record.AddDeclRef(D->getClassInterface());
+  Record.AddSourceLocation(D->getClassInterfaceLoc());
+  Record.AddSourceLocation(D->getAtLoc());
   Code = serialization::DECL_OBJC_COMPATIBLE_ALIAS;
 }
 
diff --git a/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp b/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
index db9179e018..835840c07e 100644
--- a/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
+++ b/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
@@ -638,7 +638,7 @@ static bool isObjCTypeParamDependent(QualType Type) {
       : public RecursiveASTVisitor<IsObjCTypeParamDependentTypeVisitor> {
   public:
     IsObjCTypeParamDependentTypeVisitor() : Result(false) {}
-    bool VisitObjCTypeParamType(const ObjCTypeParamType *Type) {
+    bool VisitTypedefType(const TypedefType *Type) {
       if (isa<ObjCTypeParamDecl>(Type->getDecl())) {
         Result = true;
         return false;
diff --git a/lib/Tooling/CMakeLists.txt b/lib/Tooling/CMakeLists.txt
index ee681bbb45..ac216fd530 100644
--- a/lib/Tooling/CMakeLists.txt
+++ b/lib/Tooling/CMakeLists.txt
@@ -4,6 +4,7 @@ set(LLVM_LINK_COMPONENTS
   )
 
 add_subdirectory(Core)
+add_subdirectory(Refactor)
 add_subdirectory(Refactoring)
 add_subdirectory(ASTDiff)
 
@@ -33,4 +34,6 @@ add_clang_library(clangTooling
   clangLex
   clangRewrite
   clangToolingCore
+  clangToolingRefactor
+  clangToolingRefactoring
   )
diff --git a/lib/Tooling/Refactor/ASTSlice.cpp b/lib/Tooling/Refactor/ASTSlice.cpp
index e69de29bb2..ebf6abc286 100644
--- a/lib/Tooling/Refactor/ASTSlice.cpp
+++ b/lib/Tooling/Refactor/ASTSlice.cpp
@@ -0,0 +1,636 @@
+//===--- ASTSlice.cpp - Represents a portion of the AST -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "ASTSlice.h"
+#include "SourceLocationUtilities.h"
+#include "StmtUtils.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/Basic/SourceManager.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/SaveAndRestore.h"
+#include <algorithm>
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+/// Searches for AST nodes around the given source location and range that can
+/// be used to initiate a refactoring operation.
+class ASTSliceFinder : public clang::RecursiveASTVisitor<ASTSliceFinder> {
+public:
+  explicit ASTSliceFinder(SourceLocation Location, SourceRange SelectionRange,
+                          const ASTContext &Context)
+      : Location(Location), SelectionRange(SelectionRange), Context(Context) {}
+
+  bool TraverseDecl(Decl *D) {
+    if (!D)
+      return true;
+    if (isa<DeclContext>(D) && !D->isImplicit())
+      collectDeclIfInRange(D);
+    // TODO: Handle Lambda/Blocks.
+    if (!isa<FunctionDecl>(D) && !isa<ObjCMethodDecl>(D)) {
+      RecursiveASTVisitor::TraverseDecl(D);
+      return true;
+    }
+    const Decl *PreviousDecl = CurrentDecl;
+    CurrentDecl = D;
+    RecursiveASTVisitor::TraverseDecl(D);
+    CurrentDecl = PreviousDecl;
+    return true;
+  }
+
+  bool TraverseStmt(Stmt *S) {
+    if (!S)
+      return true;
+    // PseudoObjectExpressions don't have to be parents.
+    if (isa<PseudoObjectExpr>(S))
+      return RecursiveASTVisitor::TraverseStmt(S);
+    llvm::SaveAndRestore<const Stmt *> Parent(ParentStmt, CurrentStmt);
+    llvm::SaveAndRestore<const Stmt *> Current(CurrentStmt, S);
+    RecursiveASTVisitor::TraverseStmt(S);
+    return true;
+  }
+
+  bool TraversePseudoObjectExpr(PseudoObjectExpr *E) {
+    // Avoid traversing the getter/setter message sends for property
+    // expressions.
+    TraverseStmt(E->getSyntacticForm());
+    return true;
+  }
+
+  bool TraverseObjCPropertyRefExpr(ObjCPropertyRefExpr *E) {
+    RecursiveASTVisitor::TraverseObjCPropertyRefExpr(E);
+    // Visit the opaque base manually as it won't be traversed by the
+    // PseudoObjectExpr.
+    if (E->isObjectReceiver()) {
+      if (const auto *Opaque = dyn_cast<OpaqueValueExpr>(E->getBase()))
+        TraverseStmt(Opaque->getSourceExpr());
+    }
+    return true;
+  }
+
+  // Statement visitors:
+
+  bool VisitStmt(Stmt *S) {
+    collectStmtIfInRange(S, S->getSourceRange());
+    return true;
+  }
+
+  // Ignore some implicit expressions.
+
+  bool WalkUpFromMaterializeTemporaryExpr(MaterializeTemporaryExpr *E) {
+    return true;
+  }
+
+  bool WalkUpFromCXXThisExpr(CXXThisExpr *E) {
+    if (E->isImplicit())
+      return true;
+    return RecursiveASTVisitor::WalkUpFromCXXThisExpr(E);
+  }
+
+  /// Checks if the given statement and its source range has the location
+  /// of interest or overlaps with the selection range, and adds this node to
+  /// the set of statements for the slice that's being constructed.
+  void collectStmtIfInRange(const Stmt *S, SourceRange Range) {
+    SourceLocation Start = Range.getBegin();
+    const auto &SM = Context.getSourceManager();
+    bool IsStartMacroArg = false;
+    if (Start.isMacroID()) {
+      if (SM.isMacroArgExpansion(Start)) {
+        Start = SM.getSpellingLoc(Start);
+        IsStartMacroArg = true;
+      } else {
+        Start = SM.getExpansionLoc(Start);
+      }
+    }
+    SourceLocation End = Range.getEnd();
+    if (End.isMacroID() && SM.isMacroArgExpansion(End)) {
+      // Ignore the node that's span across normal code and a macro argument.
+      if (IsStartMacroArg)
+        End = SM.getSpellingLoc(End);
+    }
+    End = getPreciseTokenLocEnd(End, SM, Context.getLangOpts());
+    if (!isPairOfFileLocations(Start, End))
+      return;
+    if (SelectionRange.isValid()) {
+      if (!areRangesOverlapping(SelectionRange, SourceRange(Start, End),
+                                Context.getSourceManager()))
+        return;
+    } else if (!isPointWithin(Location, Start, End, Context.getSourceManager()))
+      return;
+    Matches.emplace_back(S, ParentStmt, CurrentDecl, SourceRange(Start, End));
+  }
+
+  void collectDeclIfInRange(const Decl *D) {
+    SourceLocation Start = D->getSourceRange().getBegin();
+    SourceLocation End = getPreciseTokenLocEnd(
+        getLexicalEndLocForDecl(D, Context.getSourceManager(),
+                                Context.getLangOpts()),
+        Context.getSourceManager(), Context.getLangOpts());
+    if (!isPairOfFileLocations(Start, End))
+      return;
+    if (SelectionRange.isValid()) {
+      if (!areRangesOverlapping(SelectionRange, SourceRange(Start, End),
+                                Context.getSourceManager()))
+        return;
+    } else if (!isPointWithin(Location, Start, End, Context.getSourceManager()))
+      return;
+    Matches.emplace_back(D, CurrentDecl, SourceRange(Start, End));
+  }
+
+  SmallVector<ASTSlice::Node, 16> Matches;
+  /// The point of interest.
+  ///
+  /// Represents a location at which refactoring should be initiated.
+  const SourceLocation Location;
+  const SourceRange SelectionRange;
+  const ASTContext &Context;
+  const Decl *CurrentDecl = nullptr;
+  const Stmt *ParentStmt = nullptr, *CurrentStmt = nullptr;
+};
+
+} // end anonymous namespace
+
+ASTSlice::SelectedStmt::SelectedStmt(ASTSlice &Slice, const Stmt *S,
+                                     unsigned Index)
+    : Slice(Slice), S(S), Index(Index) {
+  assert(S && "No statement given!");
+}
+
+ASTSlice::SelectedDecl::SelectedDecl(const Decl *D) : D(D) {
+  assert(D && "No decl given!");
+}
+
+const Decl *ASTSlice::SelectedStmt::getParentDecl() {
+  return Slice.parentDeclForIndex(Index);
+}
+
+ASTSlice::ASTSlice(SourceLocation Location, SourceRange SelectionRange,
+                   ASTContext &Context)
+    : Context(Context), SelectionLocation(Location),
+      SelectionRange(SelectionRange) {
+  FileID SearchFile = Context.getSourceManager().getFileID(Location);
+  ASTSliceFinder Visitor(Location, SelectionRange, Context);
+  SourceLocation EndLoc;
+  for (auto *CurrDecl : Context.getTranslationUnitDecl()->decls()) {
+    if (EndLoc.isValid() &&
+        !Context.getSourceManager().isBeforeInTranslationUnit(
+            CurrDecl->getLocStart(), EndLoc))
+      break;
+    const SourceLocation FileLoc =
+        Context.getSourceManager().getSpellingLoc(CurrDecl->getLocStart());
+    if (Context.getSourceManager().getFileID(FileLoc) == SearchFile)
+      Visitor.TraverseDecl(CurrDecl);
+    // We are only interested in looking at a single top level declaration
+    // even if our selection range spans across multiple top level declarations.
+    if (!Visitor.Matches.empty()) {
+      // Objective-C @implementation declarations might have trailing functions
+      // that are declared outside of the @implementation, so continue looking
+      // through them.
+      if (isa<ObjCImplDecl>(CurrDecl)) {
+        EndLoc = CurrDecl->getLocEnd();
+        continue;
+      }
+      break;
+    }
+  }
+
+  for (auto I = Visitor.Matches.rbegin(), E = Visitor.Matches.rend(); I != E;
+       ++I)
+    NodeTree.push_back(*I);
+}
+
+bool ASTSlice::isSourceRangeSelected(CharSourceRange Range) const {
+  SourceRange R = Range.getAsRange();
+  if (Range.isTokenRange())
+    R.setEnd(getPreciseTokenLocEnd(R.getEnd(), Context.getSourceManager(),
+                                   Context.getLangOpts()));
+  if (SelectionRange.isInvalid())
+    return isPointWithin(SelectionLocation, R.getBegin(), R.getEnd(),
+                         Context.getSourceManager());
+  return areRangesOverlapping(SelectionRange, R, Context.getSourceManager());
+}
+
+/// Find the 'if' statement that acts as the start of the
+/// 'if'/'else if'/'else' construct.
+static std::pair<const IfStmt *, unsigned>
+findIfStmtStart(const IfStmt *If, unsigned Index,
+                ArrayRef<ASTSlice::Node> NodeTree) {
+  if (Index >= NodeTree.size())
+    return {If, Index}; // We've reached the top of the tree, return.
+  const auto *ParentIf =
+      dyn_cast_or_null<IfStmt>(NodeTree[Index + 1].getStmtOrNull());
+  // The current 'if' is actually an 'else if' when the next 'if' has an else
+  // statement that points to the current 'if'.
+  if (!ParentIf || ParentIf->getElse() != If)
+    return {If, Index};
+  return findIfStmtStart(ParentIf, Index + 1, NodeTree);
+}
+
+/// Find an expression that best represents the given selected expression.
+static std::pair<const Stmt *, unsigned>
+canonicalizeSelectedExpr(const Stmt *S, unsigned Index,
+                         ArrayRef<ASTSlice::Node> NodeTree) {
+  const auto Same = std::make_pair(S, Index);
+  if (Index + 1 >= NodeTree.size())
+    return Same;
+  const Stmt *Parent = NodeTree[Index + 1].getStmtOrNull();
+  if (!Parent)
+    return Same;
+  auto Next = std::make_pair(Parent, Index + 1);
+  // The entire pseudo expression is selected when just its syntactic
+  // form is selected.
+  if (isa<Expr>(S)) {
+    if (const auto *POE = dyn_cast_or_null<PseudoObjectExpr>(Parent)) {
+      if (POE->getSyntacticForm() == S)
+        return Next;
+    }
+  }
+
+  // Look through the implicit casts in the parents.
+  unsigned ParentIndex = Index + 1;
+  for (; ParentIndex <= NodeTree.size() && isa<ImplicitCastExpr>(Parent);
+       ++ParentIndex) {
+    const Stmt *NewParent = NodeTree[ParentIndex + 1].getStmtOrNull();
+    if (!NewParent)
+      break;
+    Parent = NewParent;
+  }
+  Next = std::make_pair(Parent, ParentIndex);
+
+  // The entire ObjC string literal is selected when just its string
+  // literal is selected.
+  if (isa<StringLiteral>(S) && isa<ObjCStringLiteral>(Parent))
+    return Next;
+  // The entire call should be selected when just the member expression
+  // that refers to the method is selected.
+  // FIXME: Check if this can be one of the call arguments.
+  if (isa<MemberExpr>(S) && isa<CXXMemberCallExpr>(Parent))
+    return Next;
+  // The entire call should be selected when just the callee is selected.
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(S)) {
+    if (const auto *Call = dyn_cast<CallExpr>(Parent)) {
+      if (Call->getCalleeDecl() == DRE->getDecl())
+        return Next;
+    }
+    }
+  return Same;
+}
+
+Optional<ASTSlice::SelectedStmt> ASTSlice::nearestSelectedStmt(
+    llvm::function_ref<bool(const Stmt *)> Predicate) {
+  for (const auto &Node : llvm::enumerate(NodeTree)) {
+    const Stmt *S = Node.value().getStmtOrNull();
+    if (!S || !Predicate(S))
+      continue;
+
+    // Found the match. Perform any additional adjustments.
+    if (isa<Expr>(S)) {
+      auto CanonicalExpr = canonicalizeSelectedExpr(S, Node.index(), NodeTree);
+      return SelectedStmt(*this, CanonicalExpr.first, CanonicalExpr.second);
+    }
+    switch (S->getStmtClass()) {
+    case Stmt::IfStmtClass: {
+      // TODO: Fix findIfStmtStart bug with Index where it will return the
+      // index of the last statement.
+      auto If = findIfStmtStart(cast<IfStmt>(S), Node.index(), NodeTree);
+      return SelectedStmt(*this, If.first, If.second);
+    }
+    default:
+      break;
+    }
+
+    return SelectedStmt(*this, S, Node.index());
+  }
+  return None;
+}
+
+Optional<ASTSlice::SelectedStmt>
+ASTSlice::nearestSelectedStmt(Stmt::StmtClass Class) {
+  return nearestSelectedStmt(
+      [Class](const Stmt *S) -> bool { return S->getStmtClass() == Class; });
+}
+
+const Stmt *ASTSlice::nearestStmt(Stmt::StmtClass Class) {
+  auto Result = nearestSelectedStmt(Class);
+  return Result ? Result->getStmt() : nullptr;
+}
+
+Optional<ASTSlice::SelectedDecl> ASTSlice::innermostSelectedDecl(
+    llvm::function_ref<bool(const Decl *)> Predicate, unsigned Options) {
+  if (SelectionRange.isValid()) {
+    if (Options & ASTSlice::InnermostDeclOnly) {
+      auto Result = getInnermostCompletelySelectedDecl();
+      if (!Result)
+        return None;
+      if (Predicate(Result->getDecl()))
+        return Result;
+      return None;
+    }
+    // Traverse down through all of the selected node checking the predicate.
+    // TODO: Cache the SelectionRangeOverlap kinds properly instead of relying
+    // on getInnermostCompletelySelectedDecl.
+    getInnermostCompletelySelectedDecl();
+    for (const auto &N : NodeTree) {
+      const Decl *D = N.getDeclOrNull();
+      if (!D)
+        continue;
+      if (N.SelectionRangeOverlap != Node::ContainsSelectionRange)
+        continue;
+      if (Predicate(D))
+        return SelectedDecl(D);
+    }
+    return None;
+  }
+  for (const auto &Node : llvm::enumerate(NodeTree)) {
+    const Decl *D = Node.value().getDeclOrNull();
+    if (!D)
+      continue;
+    if (Predicate(D))
+      return SelectedDecl(D);
+    if (Options & ASTSlice::InnermostDeclOnly)
+      return None;
+  }
+  return None;
+}
+
+Optional<ASTSlice::SelectedDecl>
+ASTSlice::innermostSelectedDecl(ArrayRef<Decl::Kind> Classes,
+                                unsigned Options) {
+  assert(!Classes.empty() && "Expected at least one decl kind");
+  return innermostSelectedDecl(
+      [&](const Decl *D) {
+        for (Decl::Kind Class : Classes) {
+          if (D->getKind() == Class)
+            return true;
+        }
+        return false;
+      },
+      Options);
+}
+
+/// Compute the SelectionRangeOverlap kinds for matched AST nodes.
+///
+/// The overlap kinds are computed only upto the first node that contains the
+/// entire selection range.
+static void
+computeSelectionRangeOverlapKinds(MutableArrayRef<ASTSlice::Node> NodeTree,
+                                  SourceRange SelectionRange,
+                                  const SourceManager &SM) {
+  for (ASTSlice::Node &Node : NodeTree) {
+    bool HasStart =
+        isPointWithin(SelectionRange.getBegin(), Node.Range.getBegin(),
+                      Node.Range.getEnd(), SM);
+    bool HasEnd = isPointWithin(SelectionRange.getEnd(), Node.Range.getBegin(),
+                                Node.Range.getEnd(), SM);
+    if (HasStart && HasEnd)
+      Node.SelectionRangeOverlap = ASTSlice::Node::ContainsSelectionRange;
+    else if (HasStart)
+      Node.SelectionRangeOverlap = ASTSlice::Node::ContainsSelectionRangeStart;
+    else if (HasEnd)
+      Node.SelectionRangeOverlap = ASTSlice::Node::ContainsSelectionRangeEnd;
+  }
+}
+
+const Stmt *findFirstStatementAfter(const CompoundStmt *CS, SourceLocation Loc,
+                                    const SourceManager &SM) {
+  for (const Stmt *S : CS->body()) {
+    if (!SM.isBeforeInTranslationUnit(S->getLocStart(), Loc))
+      return S;
+  }
+  return nullptr;
+}
+
+const Stmt *findLastStatementBefore(const CompoundStmt *CS, SourceLocation Loc,
+                                    const Stmt *StartAt,
+                                    const SourceManager &SM) {
+  auto It = std::find(CS->body_begin(), CS->body_end(), StartAt);
+  assert(It != CS->body_end());
+  const Stmt *Last = StartAt;
+  for (auto E = CS->body_end(); It != E; ++It) {
+    const Stmt *S = *It;
+    if (!SM.isBeforeInTranslationUnit(S->getLocStart(), Loc))
+      return Last;
+    Last = S;
+  }
+  return Last;
+}
+
+/// Return the source construct that contains the given compound statement.
+///
+/// This is useful to find the source construct to which the given compound
+/// statement belongs to lexically. For example, if we've selected just the
+/// body of an if statement, we ideally want to select the entire if statement.
+static std::pair<const Stmt *, unsigned>
+findCompoundStatementSourceConstruct(const CompoundStmt *CS,
+                                     ArrayRef<ASTSlice::Node> NodeTree) {
+  for (const auto &Node : llvm::enumerate(NodeTree)) {
+    const Stmt *S = Node.value().getStmtOrNull();
+    if (!S)
+      continue;
+    for (const Stmt *Child : S->children()) {
+      if (Child == CS) {
+        if (isa<CompoundStmt>(S))
+          return {CS, 0};
+        if (const auto *If = dyn_cast<IfStmt>(S))
+          return findIfStmtStart(If, Node.index(), NodeTree);
+        return {S, Node.index()};
+      }
+    }
+  }
+  // This is the outer compound statement.
+  return {CS, 0};
+}
+
+/// Return the source construct that contains the given switch case.
+static std::pair<const Stmt *, unsigned>
+findSwitchSourceConstruct(const SwitchCase *Case,
+                          ArrayRef<ASTSlice::Node> NodeTree) {
+  for (const auto &Node : llvm::enumerate(NodeTree)) {
+    const Stmt *S = Node.value().getStmtOrNull();
+    if (!S)
+      continue;
+    if (isa<SwitchStmt>(S))
+      return {S, Node.index()};
+  }
+  return {Case, 0};
+}
+
+SelectedStmtSet SelectedStmtSet::createFromEntirelySelected(const Stmt *S,
+                                                            unsigned Index) {
+  SelectedStmtSet Result;
+  Result.containsSelectionRange = S;
+  Result.containsSelectionRangeIndex = Index;
+  return Result;
+}
+
+Optional<ASTSlice::SelectedDecl>
+ASTSlice::getInnermostCompletelySelectedDecl() {
+  assert(SelectionRange.isValid() && "No selection range!");
+  if (CachedSelectedInnermostDecl)
+    return *CachedSelectedInnermostDecl;
+  computeSelectionRangeOverlapKinds(NodeTree, SelectionRange,
+                                    Context.getSourceManager());
+  Optional<SelectedDecl> Result;
+  for (const auto &N : llvm::enumerate(NodeTree)) {
+    const Decl *D = N.value().getDeclOrNull();
+    if (!D)
+      continue;
+    if (N.value().SelectionRangeOverlap != Node::ContainsSelectionRange)
+      continue;
+    Result = SelectedDecl(D);
+    break;
+  }
+  CachedSelectedInnermostDecl = Result;
+  return Result;
+}
+
+static bool isCaseSelected(const SwitchStmt *S, SourceRange SelectionRange,
+                           const SourceManager &SM) {
+  for (const SwitchCase *Case = S->getSwitchCaseList(); Case;
+       Case = Case->getNextSwitchCase()) {
+    SourceRange Range(Case->getLocStart(), Case->getColonLoc());
+    if (areRangesOverlapping(Range, SelectionRange, SM))
+      return true;
+  }
+  return false;
+}
+
+Optional<SelectedStmtSet> ASTSlice::computeSelectedStmtSet() {
+  if (SelectionRange.isInvalid())
+    return None;
+  computeSelectionRangeOverlapKinds(NodeTree, SelectionRange,
+                                    Context.getSourceManager());
+
+  SelectedStmtSet Result;
+  for (const auto &N : llvm::enumerate(NodeTree)) {
+    const auto *S = N.value().getStmtOrNull();
+    if (!S)
+      continue;
+    switch (N.value().SelectionRangeOverlap) {
+    case Node::ContainsSelectionRange: {
+      Result.containsSelectionRange = S;
+      Result.containsSelectionRangeIndex = N.index();
+
+      const auto *CS = dyn_cast<CompoundStmt>(Result.containsSelectionRange);
+      if (!CS) {
+        // The entire if should be selected when just the 'else if' overlaps
+        // with the selection range.
+        if (const auto *If = dyn_cast<IfStmt>(Result.containsSelectionRange)) {
+          auto IfConstruct = findIfStmtStart(If, N.index(), NodeTree);
+          return SelectedStmtSet::createFromEntirelySelected(
+              IfConstruct.first, IfConstruct.second);
+        }
+        // The entire switch should be selected when just a 'case' overlaps
+        // with the selection range.
+        if (const auto *Case =
+                dyn_cast<SwitchCase>(Result.containsSelectionRange)) {
+          auto Switch = findSwitchSourceConstruct(
+              Case, makeArrayRef(NodeTree).drop_front(N.index() + 1));
+          return SelectedStmtSet::createFromEntirelySelected(
+              Switch.first, N.index() + Switch.second);
+        }
+
+        auto CanonicalExpr = canonicalizeSelectedExpr(S, N.index(), NodeTree);
+        Result.containsSelectionRange = CanonicalExpr.first;
+        Result.containsSelectionRangeIndex = CanonicalExpr.second;
+        return Result;
+      }
+
+      bool IsLBraceSelected =
+          !Context.getSourceManager().isBeforeInTranslationUnit(
+              CS->getLBracLoc(), SelectionRange.getBegin());
+      bool IsRBraceSelected =
+          Context.getSourceManager().isBeforeInTranslationUnit(
+              CS->getRBracLoc(), SelectionRange.getEnd());
+
+      // Return the entire source construct that has the compound statement
+      // when one of the braces is selected, or when an actual `case` of the
+      // switch is selected.
+      auto Construct = findCompoundStatementSourceConstruct(
+          CS, makeArrayRef(NodeTree).drop_front(N.index() + 1));
+      if (Construct.first != CS &&
+          ((IsLBraceSelected || IsRBraceSelected) ||
+           (isa<SwitchStmt>(Construct.first) &&
+            isCaseSelected(cast<SwitchStmt>(Construct.first), SelectionRange,
+                           Context.getSourceManager()))))
+        return SelectedStmtSet::createFromEntirelySelected(
+            Construct.first, N.index() + Construct.second);
+
+      // When both braces are selected the entire compound statement is
+      // considered to be selected.
+      if (IsLBraceSelected && IsRBraceSelected)
+        return Result;
+      if (IsLBraceSelected)
+        Result.containsSelectionRangeStart = CS->body_front();
+      else if (IsRBraceSelected)
+        Result.containsSelectionRangeEnd = CS->body_back();
+
+      if (!Result.containsSelectionRangeStart)
+        Result.containsSelectionRangeStart = findFirstStatementAfter(
+            CS, SelectionRange.getBegin(), Context.getSourceManager());
+
+      // Return an empty set when the compound statements os empty or the
+      // selection range starts after the last statement or the selection range
+      // doesn't overlap with any actual statements.
+      if (!Result.containsSelectionRangeStart ||
+          !Context.getSourceManager().isBeforeInTranslationUnit(
+              Result.containsSelectionRangeStart->getLocStart(),
+              SelectionRange.getEnd()))
+        return None;
+
+      if (!Result.containsSelectionRangeEnd)
+        Result.containsSelectionRangeEnd = findLastStatementBefore(
+            CS, SelectionRange.getEnd(), Result.containsSelectionRangeStart,
+            Context.getSourceManager());
+
+      return Result;
+    }
+    case Node::ContainsSelectionRangeStart:
+      Result.containsSelectionRangeStart = S;
+      break;
+    case Node::ContainsSelectionRangeEnd:
+      Result.containsSelectionRangeEnd = S;
+      break;
+    case Node::UnknownOverlap:
+      break;
+    }
+  }
+  return Result;
+}
+
+Optional<SelectedStmtSet> ASTSlice::getSelectedStmtSet() {
+  if (CachedSelectedStmtSet)
+    return *CachedSelectedStmtSet;
+  CachedSelectedStmtSet = computeSelectedStmtSet();
+  return *CachedSelectedStmtSet;
+}
+
+bool ASTSlice::isContainedInCompoundStmt(unsigned Index) {
+  assert(Index < NodeTree.size() && "Invalid node index");
+  for (unsigned I = Index + 1, E = NodeTree.size(); I != E; ++I) {
+    const Stmt *S = NodeTree[I].getStmtOrNull();
+    if (!S)
+      continue;
+    if (isa<CompoundStmt>(S))
+      return true;
+  }
+  return false;
+}
+
+const Decl *ASTSlice::parentDeclForIndex(unsigned Index) {
+  return NodeTree[Index].ParentDecl;
+}
+
+const Stmt *ASTSlice::parentStmtForIndex(unsigned Index) {
+  return NodeTree[Index].ParentStmt;
+}
diff --git a/lib/Tooling/Refactor/ASTSlice.h b/lib/Tooling/Refactor/ASTSlice.h
index e69de29bb2..f5cb9c6f3a 100644
--- a/lib/Tooling/Refactor/ASTSlice.h
+++ b/lib/Tooling/Refactor/ASTSlice.h
@@ -0,0 +1,182 @@
+//===--- ASTSlice.h - Represents a portion of the AST ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_ASTSLICE_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_ASTSLICE_H
+
+#include "clang/AST/DeclBase.h"
+#include "clang/AST/Stmt.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "llvm/ADT/PointerUnion.h"
+#include "llvm/ADT/SmallVector.h"
+
+namespace clang {
+
+class NamedDecl;
+
+namespace tooling {
+
+/// Represents a set of statements that overlap with the selection range.
+struct SelectedStmtSet {
+  /// The outermost statement that contains the start of the selection range.
+  const Stmt *containsSelectionRangeStart = nullptr;
+
+  /// The outermost statement that contains the end of the selection range.
+  const Stmt *containsSelectionRangeEnd = nullptr;
+
+  /// The innermost statement that contains the entire selection range.
+  const Stmt *containsSelectionRange = nullptr;
+
+  /// The index of the innermost statement that contains the entire selection
+  /// range. The index points into the NodeTree stored in the \c ASTSlice.
+  Optional<unsigned> containsSelectionRangeIndex;
+
+  static SelectedStmtSet createFromEntirelySelected(const Stmt *S,
+                                                    unsigned Index);
+
+  /// Returns true if the compound statement is not fully selected.
+  bool isCompoundStatementPartiallySelected() const {
+    assert(containsSelectionRange && "No statement selected");
+    return isa<CompoundStmt>(containsSelectionRange) &&
+           (containsSelectionRangeStart || containsSelectionRangeEnd);
+  }
+};
+
+/// A portion of the AST that is located around the location and/or source
+/// range of interest.
+class ASTSlice {
+public:
+  struct Node {
+    enum SelectionRangeOverlapKind {
+      UnknownOverlap,
+      ContainsSelectionRangeStart,
+      ContainsSelectionRangeEnd,
+      ContainsSelectionRange
+    };
+    llvm::PointerUnion<const Stmt *, const Decl *> StmtOrDecl;
+    const Stmt *ParentStmt;
+    const Decl *ParentDecl;
+    SourceRange Range;
+    SelectionRangeOverlapKind SelectionRangeOverlap = UnknownOverlap;
+
+    const Stmt *getStmtOrNull() const {
+      return StmtOrDecl.dyn_cast<const Stmt *>();
+    }
+
+    const Decl *getDeclOrNull() const {
+      return StmtOrDecl.dyn_cast<const Decl *>();
+    }
+
+    Node(const Stmt *S, const Stmt *ParentStmt, const Decl *ParentDecl,
+         SourceRange Range)
+        : StmtOrDecl(S), ParentStmt(ParentStmt), ParentDecl(ParentDecl),
+          Range(Range) {}
+    Node(const Decl *D, const Decl *ParentDecl, SourceRange Range)
+        : StmtOrDecl(D), ParentStmt(nullptr), ParentDecl(ParentDecl),
+          Range(Range) {}
+  };
+
+  /// Represents a statement that overlaps with the selection range/point.
+  class SelectedStmt {
+    ASTSlice &Slice;
+    const Stmt *S;
+    unsigned Index;
+
+    friend class ASTSlice;
+
+    SelectedStmt(ASTSlice &Slice, const Stmt *S, unsigned Index);
+
+  public:
+    const Stmt *getStmt() { return S; }
+    const Decl *getParentDecl();
+  };
+
+  /// Represents a declaration that overlaps with the selection range/point.
+  class SelectedDecl {
+    const Decl *D;
+
+    friend class ASTSlice;
+
+    SelectedDecl(const Decl *D);
+
+  public:
+    const Decl *getDecl() { return D; }
+  };
+
+  ASTSlice(SourceLocation Location, SourceRange SelectionRange,
+           ASTContext &Context);
+
+  /// Returns true if the given source range overlaps with the selection.
+  bool isSourceRangeSelected(CharSourceRange Range) const;
+
+  enum SelectionSearchOptions {
+    /// Search with-in the innermost declaration only, including the declaration
+    /// itself without inspecting any other outer declarations.
+    InnermostDeclOnly = 1
+  };
+
+  /// Returns the statement that results in true when passed into \p Predicate
+  /// that's nearest to the location of interest, or \c None if such statement
+  /// isn't found.
+  Optional<SelectedStmt>
+  nearestSelectedStmt(llvm::function_ref<bool(const Stmt *)> Predicate);
+
+  /// Returns the statement of the given class that's nearest to the location
+  /// of interest, or \c None if such statement isn't found.
+  Optional<SelectedStmt> nearestSelectedStmt(Stmt::StmtClass Class);
+
+  /// TODO: Remove in favour of nearestStmt that returns \c SelectedStmt
+  const Stmt *nearestStmt(Stmt::StmtClass Class);
+
+  /// Returns the declaration that overlaps with the selection range, is
+  /// nearest to the location of interest and that results in true when passed
+  /// into \p Predicate, or \c None if such declaration isn't found.
+  Optional<SelectedDecl>
+  innermostSelectedDecl(llvm::function_ref<bool(const Decl *)> Predicate,
+                        unsigned Options = 0);
+
+  /// Returns the declaration closest to the location of interest whose decl
+  /// kind is in \p Classes, or \c None if no such decl can't be found.
+  Optional<SelectedDecl> innermostSelectedDecl(ArrayRef<Decl::Kind> Classes,
+                                               unsigned Options = 0);
+
+  /// Returns the set of statements that overlap with the selection range.
+  Optional<SelectedStmtSet> getSelectedStmtSet();
+
+  /// Returns true if the statement with the given index is contained in a
+  /// compound statement that overlaps with the selection range.
+  bool isContainedInCompoundStmt(unsigned Index);
+
+  /// Returns the declaration that contains the statement at the given index.
+  const Decl *parentDeclForIndex(unsigned Index);
+
+  /// Returns the statement that contains the statement at the given index.
+  const Stmt *parentStmtForIndex(unsigned Index);
+
+private:
+  Optional<SelectedStmtSet> computeSelectedStmtSet();
+
+  /// Returns the innermost declaration that contains both the start and the
+  /// end of the selection range.
+  Optional<SelectedDecl> getInnermostCompletelySelectedDecl();
+
+  /// The lowest element is the top of the hierarchy
+  SmallVector<Node, 16> NodeTree;
+  ASTContext &Context;
+  SourceLocation SelectionLocation;
+  SourceRange SelectionRange;
+  Optional<Optional<SelectedStmtSet>> CachedSelectedStmtSet;
+  Optional<Optional<SelectedDecl>> CachedSelectedInnermostDecl;
+};
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_ASTSLICE_H
diff --git a/lib/Tooling/Refactor/ASTStateSerialization.cpp b/lib/Tooling/Refactor/ASTStateSerialization.cpp
index e69de29bb2..2d10fbc31a 100644
--- a/lib/Tooling/Refactor/ASTStateSerialization.cpp
+++ b/lib/Tooling/Refactor/ASTStateSerialization.cpp
@@ -0,0 +1,70 @@
+//===-- ASTStateSerialization.cpp - Persists TU-specific state across TUs -===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringContinuations.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+
+using namespace clang;
+using namespace clang::tooling;
+using namespace clang::tooling::detail;
+
+namespace {
+
+class USRToDeclConverter
+    : public clang::RecursiveASTVisitor<USRToDeclConverter> {
+  llvm::StringMap<const Decl *> &USRs;
+  unsigned NumFound = 0;
+
+public:
+  USRToDeclConverter(llvm::StringMap<const Decl *> &USRs) : USRs(USRs) {}
+
+  bool isDone() const { return NumFound == USRs.size(); }
+
+  bool VisitNamedDecl(const NamedDecl *D) {
+    std::string USR = rename::getUSRForDecl(D);
+    auto It = USRs.find(USR);
+    if (It == USRs.end() || It->second)
+      return true;
+    It->second = D;
+    ++NumFound;
+    return NumFound != USRs.size();
+  }
+};
+
+} // end anonymous namespace
+
+const Decl *PersistentToASTSpecificStateConverter::lookupDecl(StringRef USR) {
+  if (USR.empty())
+    return nullptr;
+  auto It = ConvertedDeclRefs.find(USR);
+  if (It != ConvertedDeclRefs.end())
+    return It->second;
+  // FIXME: If we ever need to convert a PersistentDeclRef through the ASTQuery,
+  // we have to support conversion without coalesced conversion.
+  assert(false && "Persistent decl refs should be converted all at once");
+  return nullptr;
+}
+
+void PersistentToASTSpecificStateConverter::runCoalescedConversions() {
+  USRToDeclConverter Converter(ConvertedDeclRefs);
+  for (Decl *D : Context.getTranslationUnitDecl()->decls()) {
+    Converter.TraverseDecl(D);
+    if (Converter.isDone())
+      break;
+  }
+}
+
+FileID
+PersistentToASTSpecificStateConverter::convert(const PersistentFileID &Ref) {
+  FileManager &FM = Context.getSourceManager().getFileManager();
+  const FileEntry *Entry = FM.getFile(Ref.Filename);
+  if (!Entry)
+    return FileID();
+  return Context.getSourceManager().translateFile(Entry);
+}
diff --git a/lib/Tooling/Refactor/CMakeLists.txt b/lib/Tooling/Refactor/CMakeLists.txt
index e69de29bb2..bd93afa13d 100644
--- a/lib/Tooling/Refactor/CMakeLists.txt
+++ b/lib/Tooling/Refactor/CMakeLists.txt
@@ -0,0 +1,45 @@
+set(LLVM_LINK_COMPONENTS support)
+
+add_clang_library(clangToolingRefactor
+  ASTSlice.cpp
+  ASTStateSerialization.cpp
+  Extract.cpp
+  ExtractRepeatedExpressionIntoVariable.cpp
+  ExtractionUtils.cpp
+  FillInEnumSwitchCases.cpp
+  FillInMissingMethodStubsFromAbstractClasses.cpp
+  FillInMissingProtocolStubs.cpp
+  IfSwitchConversion.cpp
+  ImplementDeclaredMethods.cpp
+  IndexerQueries.cpp
+  LocalizeObjCStringLiteral.cpp
+  RefactoringActions.cpp
+  RefactoringActionFinder.cpp
+  RefactoringOperation.cpp
+  RefactoringOptions.cpp
+  RenamingOperation.cpp
+  RenameIndexedFile.cpp
+  RenamedSymbol.cpp
+  SourceLocationUtilities.cpp
+  StmtUtils.cpp
+  SymbolOperation.cpp
+  SymbolOccurrenceFinder.cpp
+  SymbolName.cpp
+  SymbolUSRFinder.cpp
+  TypeUtils.cpp
+  USRFinder.cpp
+
+  DEPENDS
+  ClangDriverOptions
+
+  LINK_LIBS
+  clangAST
+  clangASTMatchers
+  clangBasic
+  clangEdit
+  clangFrontend
+  clangIndex
+  clangLex
+  clangToolingCore
+  clangRewrite
+  )
diff --git a/lib/Tooling/Refactor/Extract.cpp b/lib/Tooling/Refactor/Extract.cpp
index e69de29bb2..4f6b4de0b5 100644
--- a/lib/Tooling/Refactor/Extract.cpp
+++ b/lib/Tooling/Refactor/Extract.cpp
@@ -0,0 +1,1999 @@
+//===--- Extract.cpp -  ---------------------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "extract" refactoring operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "ExtractionUtils.h"
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "StmtUtils.h"
+#include "TypeUtils.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/ASTMatchers/ASTMatchFinder.h"
+#include "clang/Lex/Lexer.h"
+#include "clang/Lex/MacroInfo.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Rewrite/Core/Rewriter.h"
+#include "clang/Tooling/Refactor/RefactoringOptions.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/Support/Path.h"
+#include <algorithm>
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+struct CompoundStatementRange {
+  CompoundStmt::const_body_iterator First, Last;
+
+  const Stmt *getFirst() const {
+    // We must have selected just the child of the case, since a selection that
+    // includes the case is treated like a selection of the entire switch.
+    if (const auto *Case = dyn_cast<SwitchCase>(*First)) {
+      if (const Stmt *S = Case->getSubStmt())
+        return S;
+    }
+    return *First;
+  }
+
+  const Stmt *getLast() const { return *Last; }
+
+  // TODO: We might not want to iterate over the switch case if we've just
+  // selected its child. We should switch over to an array of nodes instead of
+  // an iterator pair instead.
+  CompoundStmt::const_body_iterator begin() const { return First; }
+  CompoundStmt::const_body_iterator end() const { return Last + 1; }
+};
+
+enum class ExtractionKind { Function, Method, Expression };
+
+class ExtractOperation : public RefactoringOperation {
+public:
+  struct CandidateInfo {
+    CandidateInfo(SourceRange Range, StringRef PreInsertedText = "",
+                  const Stmt *AnalyzedStatement = nullptr)
+        : Range(Range), PreInsertedText(PreInsertedText),
+          AnalyzedStatement(AnalyzedStatement) {}
+
+    /// The candidate token range, i.e. the end location is the starting
+    /// location of the last token.
+    SourceRange Range;
+    /// The text that should be inserted before the call to the extracted
+    /// function.
+    StringRef PreInsertedText;
+    /// The expression that should be analyzed for captured variables and the
+    /// return value.
+    const Stmt *AnalyzedStatement;
+  };
+
+  ExtractOperation(const Stmt *S, const Stmt *ParentStmt,
+                   const Decl *FunctionLikeParentDecl,
+                   std::vector<std::string> Candidates,
+                   Optional<CompoundStatementRange> ExtractedStmtRange,
+                   Optional<CandidateInfo> FirstCandidateInfo,
+                   ExtractionKind Kind)
+      : S(S), ParentStmt(ParentStmt),
+        FunctionLikeParentDecl(FunctionLikeParentDecl),
+        Candidates(std::move(Candidates)),
+        ExtractedStmtRange(ExtractedStmtRange), Kind(Kind) {
+    if (FirstCandidateInfo)
+      CandidateExtractionInfo.push_back(*FirstCandidateInfo);
+  }
+
+  const Stmt *getTransformedStmt() const override {
+    if (ExtractedStmtRange)
+      return ExtractedStmtRange->getFirst();
+    return S;
+  }
+
+  const Stmt *getLastTransformedStmt() const override {
+    if (ExtractedStmtRange)
+      return ExtractedStmtRange->getLast();
+    return nullptr;
+  }
+
+  std::vector<std::string> getRefactoringCandidates() override {
+    return Candidates;
+  }
+
+  std::vector<RefactoringActionType> getAvailableSubActions() override {
+    std::vector<RefactoringActionType> SubActions;
+    if (isa<CXXMethodDecl>(FunctionLikeParentDecl) ||
+        isa<ObjCMethodDecl>(FunctionLikeParentDecl))
+      SubActions.push_back(RefactoringActionType::Extract_Method);
+    if (isLexicalExpression(S, ParentStmt))
+      SubActions.push_back(RefactoringActionType::Extract_Expression);
+    return SubActions;
+  }
+
+  bool isMethodExtraction() const { return Kind == ExtractionKind::Method; }
+
+  bool isExpressionExtraction() const {
+    return Kind == ExtractionKind::Expression;
+  }
+
+  llvm::Expected<RefactoringResult> perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  llvm::Expected<RefactoringResult>
+  performExpressionExtraction(ASTContext &Context, PrintingPolicy &PP);
+
+  const Stmt *S, *ParentStmt;
+  const Decl *FunctionLikeParentDecl;
+  std::vector<std::string> Candidates;
+  /// A set of extraction candidates that correspond to the extracted code.
+  SmallVector<CandidateInfo, 2> CandidateExtractionInfo;
+  Optional<CompoundStatementRange> ExtractedStmtRange;
+  ExtractionKind Kind;
+};
+
+} // end anonymous namespace
+
+bool isSimpleExpression(const Expr *E) {
+  switch (E->IgnoreParenCasts()->getStmtClass()) {
+  case Stmt::DeclRefExprClass:
+  case Stmt::PredefinedExprClass:
+  case Stmt::IntegerLiteralClass:
+  case Stmt::FloatingLiteralClass:
+  case Stmt::ImaginaryLiteralClass:
+  case Stmt::CharacterLiteralClass:
+  case Stmt::StringLiteralClass:
+    return true;
+  default:
+    return false;
+  }
+}
+
+static bool isMultipleCandidateBinOp(BinaryOperatorKind Op) {
+  return Op == BO_Add || Op == BO_Sub;
+}
+
+/// Searches for the selected statement in the given CompoundStatement, looking
+/// through things like PseudoObjectExpressions.
+static CompoundStmt::const_body_iterator
+findSelectedStmt(CompoundStmt::body_const_range Statements,
+                 const Stmt *Target) {
+  return llvm::find_if(Statements, [=](const Stmt *S) {
+    if (S == Target)
+      return true;
+    if (const auto *POE = dyn_cast<PseudoObjectExpr>(S)) {
+      if (POE->getSyntacticForm() == Target)
+        return true;
+    }
+    return false;
+  });
+}
+
+/// Returns the first and the last statements that should be extracted from a
+/// compound statement.
+Optional<CompoundStatementRange> getExtractedStatements(const CompoundStmt *CS,
+                                                        const Stmt *Begin,
+                                                        const Stmt *End) {
+  if (CS->body_empty())
+    return None;
+  assert(Begin && End);
+  CompoundStatementRange Result;
+  Result.First = findSelectedStmt(CS->body(), Begin);
+  assert(Result.First != CS->body_end());
+  Result.Last = findSelectedStmt(
+      CompoundStmt::body_const_range(Result.First, CS->body_end()), End);
+  assert(Result.Last != CS->body_end());
+  return Result;
+}
+
+static RefactoringOperationResult
+initiateAnyExtractOperation(ASTSlice &Slice, ASTContext &Context,
+                            SourceLocation Location, SourceRange SelectionRange,
+                            bool CreateOperation,
+                            ExtractionKind Kind = ExtractionKind::Function) {
+  auto SelectedStmtsOpt = Slice.getSelectedStmtSet();
+  if (!SelectedStmtsOpt)
+    return None;
+  SelectedStmtSet Stmts = *SelectedStmtsOpt;
+  // The selection range is contained entirely within this statement (without
+  // taking leading/trailing comments and whitespace into account).
+  const Stmt *Selected = Stmts.containsSelectionRange;
+
+  // We only want to perform the extraction if the selection range is entirely
+  // within a body of a function or method.
+  if (!Selected)
+    return None;
+  const Decl *ParentDecl =
+      Slice.parentDeclForIndex(*Stmts.containsSelectionRangeIndex);
+
+  if (!ParentDecl ||
+      (!Stmts.isCompoundStatementPartiallySelected() &&
+       !Slice.isContainedInCompoundStmt(*Stmts.containsSelectionRangeIndex)))
+    return RefactoringOperationResult(
+        "the selected expression is not in a function");
+
+  if (isa<Expr>(Selected) && isSimpleExpression(cast<Expr>(Selected)))
+    return RefactoringOperationResult("the selected expression is too simple");
+  if (const auto *PRE = dyn_cast<ObjCPropertyRefExpr>(Selected)) {
+    if (!PRE->isMessagingGetter())
+      return RefactoringOperationResult("property setter can't be extracted");
+  }
+
+  const Stmt *ParentStmt =
+      Slice.parentStmtForIndex(*Stmts.containsSelectionRangeIndex);
+  if (Kind == ExtractionKind::Expression &&
+      !isLexicalExpression(Selected, ParentStmt))
+    return None;
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (!CreateOperation)
+    return Result;
+
+  Optional<CompoundStatementRange> ExtractedStmtRange;
+
+  // Check if there are multiple candidates that can be extracted.
+  std::vector<std::string> Candidates;
+  Optional<ExtractOperation::CandidateInfo> FirstCandidateInfo;
+  if (const auto *BinOp = dyn_cast<BinaryOperator>(Selected)) {
+    // Binary '+' and '-' operators allow multiple candidates when the
+    // selection range starts after the LHS expression but still overlaps
+    // with the RHS.
+    if (isMultipleCandidateBinOp(BinOp->getOpcode()) &&
+        (!Stmts.containsSelectionRangeStart ||
+         getPreciseTokenLocEnd(
+             BinOp->getLHS()->getLocEnd(), Context.getSourceManager(),
+             Context.getLangOpts()) == SelectionRange.getBegin()) &&
+        Stmts.containsSelectionRangeEnd) {
+      SourceRange FirstCandidateRange =
+          SourceRange(SelectionRange.getBegin(), BinOp->getLocEnd());
+      if (FirstCandidateRange.getEnd().isMacroID())
+        FirstCandidateRange.setEnd(Context.getSourceManager().getExpansionLoc(
+            FirstCandidateRange.getEnd()));
+      FirstCandidateInfo = ExtractOperation::CandidateInfo(
+          FirstCandidateRange, "+ ",
+          /*AnalyzedStatement=*/BinOp->getRHS());
+      Candidates.push_back(
+          Lexer::getSourceText(
+              CharSourceRange::getTokenRange(FirstCandidateRange),
+              Context.getSourceManager(), Context.getLangOpts())
+              .trim());
+      Candidates.push_back(Lexer::getSourceText(
+          CharSourceRange::getTokenRange(BinOp->getSourceRange()),
+          Context.getSourceManager(), Context.getLangOpts()));
+    }
+  } else if (const auto *CS = dyn_cast<CompoundStmt>(Selected)) {
+    // We want to extract some child statements from a compound statement unless
+    // we've selected the entire compound statement including the opening and
+    // closing brace.
+    if (Stmts.containsSelectionRangeStart)
+      ExtractedStmtRange =
+          getExtractedStatements(CS, Stmts.containsSelectionRangeStart,
+                                 Stmts.containsSelectionRangeEnd);
+  }
+
+  auto Operation = llvm::make_unique<ExtractOperation>(
+      Selected, ParentStmt, ParentDecl, std::move(Candidates),
+      ExtractedStmtRange, FirstCandidateInfo, Kind);
+  auto &CandidateExtractionInfo = Operation->CandidateExtractionInfo;
+  SourceRange Range;
+  if (ExtractedStmtRange)
+    Range = SourceRange(ExtractedStmtRange->getFirst()->getLocStart(),
+                        ExtractedStmtRange->getLast()->getLocEnd());
+  else
+    Range = Selected->getSourceRange();
+  bool IsBeginMacroArgument = false;
+  if (Range.getBegin().isMacroID()) {
+    if (Context.getSourceManager().isMacroArgExpansion(Range.getBegin())) {
+      Range.setBegin(
+          Context.getSourceManager().getSpellingLoc(Range.getBegin()));
+      IsBeginMacroArgument = true;
+    } else {
+      Range.setBegin(
+          Context.getSourceManager().getExpansionLoc(Range.getBegin()));
+    }
+  }
+  if (Range.getEnd().isMacroID()) {
+    if (IsBeginMacroArgument &&
+        Context.getSourceManager().isMacroArgExpansion(Range.getEnd()))
+      Range.setEnd(Context.getSourceManager().getSpellingLoc(Range.getEnd()));
+    else
+      Range.setEnd(
+          Context.getSourceManager().getExpansionRange(Range.getEnd()).second);
+  }
+  CandidateExtractionInfo.push_back(ExtractOperation::CandidateInfo(Range));
+  Result.RefactoringOp = std::move(Operation);
+  return Result;
+}
+
+RefactoringOperationResult clang::tooling::initiateExtractOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  return initiateAnyExtractOperation(Slice, Context, Location, SelectionRange,
+                                     CreateOperation);
+}
+
+RefactoringOperationResult clang::tooling::initiateExtractMethodOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  // TODO: Verify that method extraction is actually possible.
+  return initiateAnyExtractOperation(Slice, Context, Location, SelectionRange,
+                                     CreateOperation, ExtractionKind::Method);
+}
+
+RefactoringOperationResult clang::tooling::initiateExtractExpressionOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  RefactoringOperationResult R =
+      initiateAnyExtractOperation(Slice, Context, Location, SelectionRange,
+                                  CreateOperation, ExtractionKind::Expression);
+  return R;
+}
+
+using ReferencedEntity =
+    llvm::PointerUnion<const DeclRefExpr *, const FieldDecl *>;
+
+/// Iterate over the entities (variables/instance variables) that are directly
+/// referenced by the given expression \p E.
+///
+/// Note: Objective-C ivars are always captured via 'self'.
+static void findEntitiesDirectlyReferencedInExpr(
+    const Expr *E,
+    llvm::function_ref<void(const ReferencedEntity &Entity)> Handler) {
+  E = E->IgnoreParenCasts();
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(E))
+    return Handler(DRE);
+
+  if (const auto *ME = dyn_cast<MemberExpr>(E)) {
+    if (isa<CXXThisExpr>(ME->getBase()->IgnoreParenCasts())) {
+      if (const auto *FD = dyn_cast_or_null<FieldDecl>(ME->getMemberDecl()))
+        Handler(FD);
+      return;
+    }
+    if (const auto *MD = ME->getMemberDecl()) {
+      if (isa<FieldDecl>(MD) || isa<IndirectFieldDecl>(MD))
+        findEntitiesDirectlyReferencedInExpr(ME->getBase(), Handler);
+    }
+    return;
+  }
+
+  if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {
+    findEntitiesDirectlyReferencedInExpr(CO->getTrueExpr(), Handler);
+    findEntitiesDirectlyReferencedInExpr(CO->getFalseExpr(), Handler);
+    return;
+  }
+
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    if (BO->getOpcode() == BO_Comma)
+      return findEntitiesDirectlyReferencedInExpr(BO->getRHS(), Handler);
+  }
+}
+
+template <typename T, typename Matcher>
+static void
+findMatchingParameters(Matcher &ParameterMatcher, const Stmt *S,
+                       ASTContext &Context, StringRef Node,
+                       llvm::function_ref<void(const T *E)> Handler) {
+  using namespace clang::ast_matchers;
+  auto Matches = match(findAll(callExpr(ParameterMatcher)), *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.template getNodeAs<T>(Node));
+  Matches = match(findAll(cxxConstructExpr(ParameterMatcher)), *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.template getNodeAs<T>(Node));
+}
+
+static void
+findUseOfConstThis(const Stmt *S, ASTContext &Context,
+                   llvm::function_ref<void(const CXXThisExpr *E)> Handler) {
+  using namespace clang::ast_matchers;
+  // Check the receiver in method call and member operator calls.
+  auto This = cxxThisExpr().bind("this");
+  auto ThisReceiver = ignoringParenCasts(
+      anyOf(This, unaryOperator(hasOperatorName("*"),
+                                hasUnaryOperand(ignoringParenCasts(This)))));
+  auto ConstMethodCallee = callee(cxxMethodDecl(isConst()));
+  auto Matches = match(
+      findAll(expr(anyOf(cxxMemberCallExpr(ConstMethodCallee, on(ThisReceiver)),
+                         cxxOperatorCallExpr(ConstMethodCallee,
+                                             hasArgument(0, ThisReceiver))))),
+      *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.getNodeAs<CXXThisExpr>("this"));
+  // Check parameters in calls.
+  auto ConstPointee = pointee(qualType(isConstQualified()));
+  auto RefParameter = forEachArgumentWithParam(
+      ThisReceiver,
+      parmVarDecl(hasType(qualType(referenceType(ConstPointee)))));
+  findMatchingParameters(RefParameter, S, Context, "this", Handler);
+  auto PtrParameter = forEachArgumentWithParam(
+      ignoringParenCasts(This),
+      parmVarDecl(hasType(qualType(pointerType(ConstPointee)))));
+  findMatchingParameters(PtrParameter, S, Context, "this", Handler);
+}
+
+static void findArgumentsPassedByNonConstReference(
+    const Stmt *S, ASTContext &Context,
+    llvm::function_ref<void(const Expr *E)> Handler) {
+  using namespace clang::ast_matchers;
+  // Check the receiver in method call and member operator calls.
+  auto NonPointerReceiver =
+      expr(unless(hasType(qualType(pointerType())))).bind("arg");
+  auto NonConstMethodCallee = callee(cxxMethodDecl(unless(isConst())));
+  auto Matches =
+      match(findAll(expr(anyOf(
+                cxxMemberCallExpr(NonConstMethodCallee, on(NonPointerReceiver)),
+                cxxOperatorCallExpr(NonConstMethodCallee,
+                                    hasArgument(0, NonPointerReceiver))))),
+            *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.getNodeAs<Expr>("arg"));
+  // Check parameters in calls.
+  auto RefParameter = forEachArgumentWithParam(
+      expr().bind("arg"), parmVarDecl(hasType(qualType(referenceType(unless(
+                              pointee(qualType(isConstQualified()))))))));
+  Matches = match(findAll(callExpr(RefParameter)), *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.getNodeAs<Expr>("arg"));
+  Matches = match(findAll(cxxConstructExpr(RefParameter)), *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.getNodeAs<Expr>("arg"));
+}
+
+static void findAddressExpressionsPassedByConstPointer(
+    const Stmt *S, ASTContext &Context,
+    llvm::function_ref<void(const UnaryOperator *E)> Handler) {
+  using namespace clang::ast_matchers;
+  auto ConstPtrParameter = forEachArgumentWithParam(
+      ignoringParenImpCasts(unaryOperator(hasOperatorName("&")).bind("arg")),
+      parmVarDecl(hasType(
+          qualType(pointerType(pointee(qualType(isConstQualified())))))));
+  auto Matches = match(findAll(callExpr(ConstPtrParameter)), *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.getNodeAs<UnaryOperator>("arg"));
+  Matches = match(findAll(cxxConstructExpr(ConstPtrParameter)), *S, Context);
+  for (const auto &Match : Matches)
+    Handler(Match.getNodeAs<UnaryOperator>("arg"));
+}
+
+static bool isImplicitInitializer(const VarDecl *VD) {
+  assert(VD->hasInit());
+  const auto *E = VD->getInit();
+  if (isa<ExprWithCleanups>(E))
+    return false;
+  const auto *Construct = dyn_cast<CXXConstructExpr>(E);
+  if (!Construct)
+    return E->getLocStart() == VD->getLocation();
+  return Construct->getParenOrBraceRange().isInvalid();
+}
+
+static const Expr *getInitializerExprWithLexicalRange(const Expr *E) {
+  if (const auto *EWC = dyn_cast<ExprWithCleanups>(E)) {
+    if (const auto *Construct = dyn_cast<CXXConstructExpr>(EWC->getSubExpr())) {
+      if (Construct->getNumArgs() == 1) {
+        if (const auto *ME =
+                dyn_cast<MaterializeTemporaryExpr>(Construct->getArg(0)))
+          return ME;
+      }
+    }
+  }
+  return E;
+}
+
+namespace {
+
+class ExtractedCodeVisitor : public RecursiveASTVisitor<ExtractedCodeVisitor> {
+  int DefineOrdering = 0;
+
+public:
+  struct CaptureInfo {
+    bool IsMutated = false;
+    bool IsDefined = false;
+    bool IsAddressTaken = false;
+    bool IsConstAddressTaken = false;
+    bool IsFieldCapturedWithThis = false;
+    bool IsUsed = false;
+    int DefineOrderingPriority = 0;
+
+    bool isPassedByRefOrPtr() const {
+      return IsMutated || IsAddressTaken || IsConstAddressTaken;
+    }
+    bool isRefOrPtrConst() const {
+      return IsConstAddressTaken && !IsMutated && !IsAddressTaken;
+    }
+  };
+
+  const ImplicitParamDecl *SelfDecl;
+
+  ExtractedCodeVisitor(const ImplicitParamDecl *SelfDecl)
+      : SelfDecl(SelfDecl) {}
+
+  bool HasReturnInExtracted = false;
+
+  CaptureInfo &captureVariable(const VarDecl *VD) {
+    CaptureInfo &Result = CapturedVariables[VD];
+    Result.IsUsed = true;
+    return Result;
+  }
+
+  CaptureInfo &captureField(const FieldDecl *FD) { return CapturedFields[FD]; }
+
+  bool VisitDeclRefExpr(const DeclRefExpr *E) {
+    const VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
+    if (!VD)
+      return true;
+    if (VD == SelfDecl) {
+      CaptureSelf = true;
+      SelfType = VD->getType();
+      return true;
+    }
+    if (!VD->isLocalVarDeclOrParm())
+      return true;
+    captureVariable(VD);
+    return true;
+  }
+
+  void captureThisWithoutConstConcerns(const CXXThisExpr *E) {
+    CaptureThis = true;
+    ThisRecordType = E->getType()->getPointeeType();
+  }
+
+  bool VisitCXXThisExpr(const CXXThisExpr *E) {
+    captureThisWithoutConstConcerns(E);
+    ThisUsesWithUnknownConstness.insert(E);
+    return true;
+  }
+
+  bool TraverseMemberExpr(MemberExpr *E) {
+    const auto *Base = dyn_cast<CXXThisExpr>(E->getBase()->IgnoreParenCasts());
+    if (!Base)
+      return RecursiveASTVisitor::TraverseMemberExpr(E);
+    const FieldDecl *FD = dyn_cast_or_null<FieldDecl>(E->getMemberDecl());
+    if (!FD)
+      return RecursiveASTVisitor::TraverseMemberExpr(E);
+    CaptureInfo &Info = captureField(FD);
+    // Don't capture the implicit 'this' for private fields as we don't want to
+    // capture this if we only use the private fields.
+    if (FD->getAccess() == AS_public || !Base->isImplicit()) {
+      Info.IsFieldCapturedWithThis = true;
+      // The member might have an effect on the constness of the captured 'this'
+      // but this is checked via mutation/const tracking for the field itself,
+      // so we just capture 'this' without worrying about checking if it's used
+      // in a 'const' manner here.
+      captureThisWithoutConstConcerns(Base);
+    }
+    return true;
+  }
+
+  void captureSuper(QualType T) {
+    if (CaptureSuper)
+      return;
+    SuperType = T;
+    CaptureSuper = true;
+  }
+
+  bool TraverseObjCPropertyRefExpr(ObjCPropertyRefExpr *E) {
+    if (E->isSuperReceiver())
+      captureSuper(E->getSuperReceiverType());
+    // Base might be an opaque expression, so we have to visit it manually as
+    // we don't necessarily visit the setter/getter message sends if just the
+    // property was selected.
+    if (E->isObjectReceiver()) {
+      if (const auto *OVE = dyn_cast<OpaqueValueExpr>(E->getBase()))
+        TraverseStmt(OVE->getSourceExpr());
+    }
+    return RecursiveASTVisitor::TraverseObjCPropertyRefExpr(E);
+  }
+
+  bool TraverseBinAssign(BinaryOperator *S) {
+    // RHS might be an opaque expression, if this is a property assignment. We
+    // have to visit it manually as we don't necessarily visit the setter/getter
+    // message sends if just the property was selected.
+    if (const auto *OVE = dyn_cast<OpaqueValueExpr>(S->getRHS()))
+      TraverseStmt(OVE->getSourceExpr());
+    return RecursiveASTVisitor::TraverseBinAssign(S);
+  }
+
+  void findCapturedVariableOrFieldsInExpression(
+      const Expr *E, llvm::function_ref<void(CaptureInfo &)> Handler) {
+    findEntitiesDirectlyReferencedInExpr(
+        E, [&Handler, this](const ReferencedEntity &Entity) {
+          if (const auto *DRE = Entity.dyn_cast<const DeclRefExpr *>()) {
+            const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());
+            if (!VD || !VD->isLocalVarDeclOrParm() || VD->isImplicit())
+              return;
+            return Handler(captureVariable(VD));
+          }
+          return Handler(captureField(Entity.get<const FieldDecl *>()));
+        });
+  }
+
+  void
+  markDirectlyReferencedVariableOrFieldInExpressionAsMutated(const Expr *E) {
+    findCapturedVariableOrFieldsInExpression(
+        E, [](CaptureInfo &Capture) { Capture.IsMutated = true; });
+  }
+
+  bool VisitBinaryOperator(const BinaryOperator *E) {
+    if (E->isAssignmentOp())
+      markDirectlyReferencedVariableOrFieldInExpressionAsMutated(E->getLHS());
+    return true;
+  }
+
+  bool VisitUnaryPreInc(const UnaryOperator *E) {
+    markDirectlyReferencedVariableOrFieldInExpressionAsMutated(E->getSubExpr());
+    return true;
+  }
+
+  bool VisitUnaryPostInc(const UnaryOperator *E) {
+    markDirectlyReferencedVariableOrFieldInExpressionAsMutated(E->getSubExpr());
+    return true;
+  }
+
+  bool VisitUnaryPreDec(const UnaryOperator *E) {
+    markDirectlyReferencedVariableOrFieldInExpressionAsMutated(E->getSubExpr());
+    return true;
+  }
+
+  bool VisitUnaryPostDec(const UnaryOperator *E) {
+    markDirectlyReferencedVariableOrFieldInExpressionAsMutated(E->getSubExpr());
+    return true;
+  }
+
+  /// If the given expression refers to a local/instance variable or a
+  /// a member of such variable that variable is marked as captured by
+  /// reference.
+  void captureVariableOrFieldInExpressionByReference(const Expr *E) {
+    findCapturedVariableOrFieldsInExpression(
+        E, [](CaptureInfo &Capture) { Capture.IsAddressTaken = true; });
+  }
+
+  bool VisitUnaryAddrOf(const UnaryOperator *E) {
+    // Capture the entity with 'const' reference/pointer when its address is
+    // passed into a function that takes a 'const' pointer and no other
+    // mutations or non-const address/reference acquisitions occur.
+    if (AddressExpressionsPassedToConstPointerParameter.count(E))
+      findCapturedVariableOrFieldsInExpression(
+          E->getSubExpr(),
+          [](CaptureInfo &Capture) { Capture.IsConstAddressTaken = true; });
+    else
+      captureVariableOrFieldInExpressionByReference(E->getSubExpr());
+    return true;
+  }
+
+  bool VisitObjCMessageExpr(const ObjCMessageExpr *E) {
+    if (E->getSuperLoc().isValid())
+      captureSuper(E->getSuperType());
+    const ObjCMethodDecl *MD = E->getMethodDecl();
+    if (!MD)
+      return true;
+    for (const auto &Param : llvm::enumerate(MD->parameters())) {
+      QualType T = Param.value()->getType();
+      if (Param.index() >= E->getNumArgs())
+        break;
+      if (T->isReferenceType() && !T->getPointeeType().isConstQualified())
+        captureVariableOrFieldInExpressionByReference(E->getArg(Param.index()));
+      if (T->isPointerType() && T->getPointeeType().isConstQualified()) {
+        // Check if this is an '&' passed into a const pointer parameter.
+        const Expr *Arg = E->getArg(Param.index());
+        if (const auto *Op =
+                dyn_cast<UnaryOperator>(Arg->IgnoreParenImpCasts())) {
+          if (Op->getOpcode() == UO_AddrOf)
+            AddressExpressionsPassedToConstPointerParameter.insert(Op);
+        }
+      }
+    }
+    return true;
+  }
+
+  bool VisitVarDecl(const VarDecl *VD) {
+    // Don't capture using the captureVariable method as we don't want to mark
+    // the declaration as a 'use'. This allows us to avoid passing in variables
+    // that are defined in extracted code, used afterwards, but never actually
+    // used in the extracted code.
+    CaptureInfo &Capture = CapturedVariables[VD];
+    Capture.IsDefined = true;
+    Capture.DefineOrderingPriority = ++DefineOrdering;
+    // Ensure the capture is marked as 'used' when the variable declaration has
+    // an explicit initialization expression. This allows us to pass it by
+    // reference when it's defined in extracted code, used afterwards, but never
+    // actually used in the extracted code. The main reason why we want to try
+    // to keep this initialization in the extracted code is to preserve
+    // semantics as the initialization expression might have side-effects.
+    if (!Capture.IsUsed && VD->hasInit() && !isImplicitInitializer(VD))
+      Capture.IsUsed = true;
+    QualType T = VD->getType();
+    if (T->isReferenceType() && !T->getPointeeType().isConstQualified() &&
+        VD->hasInit())
+      captureVariableOrFieldInExpressionByReference(VD->getInit());
+    return true;
+  }
+
+  bool VisitReturnStmt(const ReturnStmt *S) {
+    HasReturnInExtracted = true;
+    return true;
+  }
+
+  void InspectExtractedStmt(Stmt *S, ASTContext &Context) {
+    findAddressExpressionsPassedByConstPointer(
+        S, Context, [this](const UnaryOperator *Arg) {
+          AddressExpressionsPassedToConstPointerParameter.insert(Arg);
+        });
+    TraverseStmt(S);
+    findArgumentsPassedByNonConstReference(S, Context, [this](const Expr *Arg) {
+      captureVariableOrFieldInExpressionByReference(Arg);
+    });
+    if (CaptureThis && !ThisUsesWithUnknownConstness.empty()) {
+      // Compare the definite 'const' uses of 'this' to all the seen uses
+      // (except for the known field uses).
+      findUseOfConstThis(S, Context, [this](const CXXThisExpr *Arg) {
+        ThisUsesWithUnknownConstness.erase(Arg);
+      });
+      IsThisConstForNonCapturedFieldUses = ThisUsesWithUnknownConstness.empty();
+    }
+  }
+
+  llvm::DenseMap<const VarDecl *, CaptureInfo> CapturedVariables;
+  llvm::DenseMap<const FieldDecl *, CaptureInfo> CapturedFields;
+  llvm::SmallPtrSet<const UnaryOperator *, 8>
+      AddressExpressionsPassedToConstPointerParameter;
+  llvm::SmallPtrSet<const CXXThisExpr *, 16> ThisUsesWithUnknownConstness;
+  bool CaptureThis = false;
+  bool IsThisConstForNonCapturedFieldUses = true;
+  QualType ThisRecordType;
+  bool CaptureSelf = false, CaptureSuper = false;
+  QualType SelfType, SuperType;
+};
+
+/// Traverses the extracted code and finds the uses of captured variables
+/// that are passed into the extracted function using a pointer.
+class VariableDefinedInExtractedCodeUseAfterExtractionFinder
+    : public RecursiveASTVisitor<
+          VariableDefinedInExtractedCodeUseAfterExtractionFinder> {
+  bool IsAfterExtracted = false;
+
+public:
+  const Stmt *LastExtractedStmt;
+  const llvm::SmallPtrSetImpl<const VarDecl *> &VariablesDefinedInExtractedCode;
+  llvm::SmallPtrSet<const VarDecl *, 4> VariablesUsedAfterExtraction;
+
+  VariableDefinedInExtractedCodeUseAfterExtractionFinder(
+      const Stmt *LastExtractedStmt,
+      const llvm::SmallPtrSetImpl<const VarDecl *>
+          &VariablesDefinedInExtractedCode)
+      : LastExtractedStmt(LastExtractedStmt),
+        VariablesDefinedInExtractedCode(VariablesDefinedInExtractedCode) {}
+
+  bool TraverseStmt(Stmt *S) {
+    RecursiveASTVisitor::TraverseStmt(S);
+    if (S == LastExtractedStmt)
+      IsAfterExtracted = true;
+    return true;
+  }
+
+  bool VisitDeclRefExpr(const DeclRefExpr *E) {
+    if (!IsAfterExtracted)
+      return true;
+    const VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
+    if (!VD)
+      return true;
+    if (VariablesDefinedInExtractedCode.count(VD))
+      VariablesUsedAfterExtraction.insert(VD);
+    return true;
+  }
+};
+
+class PossibleShadowingVariableFinder
+    : public RecursiveASTVisitor<PossibleShadowingVariableFinder> {
+  const VarDecl *TargetVD;
+
+  PossibleShadowingVariableFinder(const VarDecl *TargetVD)
+      : TargetVD(TargetVD) {}
+
+public:
+  bool VisitVarDecl(const VarDecl *VD) {
+    if (VD == TargetVD || VD->getName() != TargetVD->getName())
+      return true;
+    return false;
+  }
+
+  /// Returns true if the given statement \p S has a variable declaration whose
+  /// name is identical to the given variable declaration \p VD.
+  static bool hasShadowingVar(const VarDecl *VD, const Stmt *S) {
+    return !PossibleShadowingVariableFinder(VD).TraverseStmt(
+        const_cast<Stmt *>(S));
+  }
+};
+
+/// Traverses the extracted code and rewrites the 'return' statements to ensure
+/// that they now return some value.
+class ReturnRewriter : public RecursiveASTVisitor<ReturnRewriter> {
+  Rewriter &SourceRewriter;
+  std::string Text;
+
+public:
+  ReturnRewriter(Rewriter &SourceRewriter, StringRef Text)
+      : SourceRewriter(SourceRewriter), Text(std::string(" ") + Text.str()) {}
+
+  bool VisitReturnStmt(const ReturnStmt *S) {
+    SourceRewriter.InsertText(
+        getPreciseTokenLocEnd(S->getLocEnd(), SourceRewriter.getSourceMgr(),
+                              SourceRewriter.getLangOpts()),
+        Text);
+    return true;
+  }
+};
+
+/// Prints the given initializer expression using the original source code if
+/// possible.
+static void printInitializerExpressionUsingOriginalSyntax(
+    const VarDecl *VD, const Expr *E, bool IsDeclaration, const ASTContext &Ctx,
+    llvm::raw_ostream &OS, const PrintingPolicy &PP) {
+  E = getInitializerExprWithLexicalRange(E);
+  SourceRange Range = E->getSourceRange();
+  bool UseEquals = true;
+  bool UseTypeName = false;
+  if (const auto *Construct = dyn_cast<CXXConstructExpr>(E)) {
+    SourceRange SubRange = Construct->getParenOrBraceRange();
+    if (SubRange.isValid()) {
+      UseEquals = false;
+      UseTypeName = true;
+      Range = SubRange;
+    }
+  }
+  if (Range.getBegin().isMacroID())
+    Range.setBegin(Ctx.getSourceManager().getExpansionLoc(Range.getBegin()));
+  if (Range.getEnd().isMacroID())
+    Range.setEnd(Ctx.getSourceManager().getExpansionLoc(Range.getEnd()));
+  bool IsInvalid = false;
+  StringRef Text = Lexer::getSourceText(CharSourceRange::getTokenRange(Range),
+                                        Ctx.getSourceManager(),
+                                        Ctx.getLangOpts(), &IsInvalid);
+  if (IsDeclaration && UseEquals)
+    OS << " = ";
+  else if (!IsDeclaration && UseTypeName)
+    VD->getType().print(OS, PP);
+  if (IsInvalid)
+    E->printPretty(OS, nullptr, PP);
+  else
+    OS << Text;
+};
+
+/// Traverses the extracted code and rewrites the declaration statements that
+/// declare variables that are used after the extracted code.
+class DefinedInExtractedCodeDeclStmtRewriter
+    : public RecursiveASTVisitor<DefinedInExtractedCodeDeclStmtRewriter> {
+public:
+  Rewriter &SourceRewriter;
+  const llvm::SmallPtrSetImpl<const VarDecl *> &VariablesUsedAfterExtraction;
+  const PrintingPolicy &PP;
+
+  DefinedInExtractedCodeDeclStmtRewriter(
+      Rewriter &SourceRewriter, const llvm::SmallPtrSetImpl<const VarDecl *>
+                                    &VariablesUsedAfterExtraction,
+      const PrintingPolicy &PP)
+      : SourceRewriter(SourceRewriter),
+        VariablesUsedAfterExtraction(VariablesUsedAfterExtraction), PP(PP) {}
+
+  /// When a declaration statement declares variables that are all used
+  /// after extraction, we can rewrite it completely into a set of assignments
+  /// while still preserving the original initializer expressions when we
+  /// can.
+  void rewriteAllVariableDeclarationsToAssignments(const DeclStmt *S) {
+    SourceLocation StartLoc = S->getLocStart();
+    for (const Decl *D : S->decls()) {
+      const auto *VD = dyn_cast<VarDecl>(D);
+      if (!VD || !VariablesUsedAfterExtraction.count(VD))
+        continue;
+      if (!VD->hasInit() || isImplicitInitializer(VD)) {
+        // Remove the variable declarations without explicit initializers.
+        // This can affect the semantics of the program if the implicit
+        // initialization expression has side effects.
+        SourceRange Range = SourceRange(
+            StartLoc, S->isSingleDecl() ? S->getLocEnd() : VD->getLocation());
+        SourceRewriter.RemoveText(Range);
+        continue;
+      }
+      std::string Str;
+      llvm::raw_string_ostream OS(Str);
+      if (StartLoc != S->getLocStart())
+        OS << "; ";
+      const ASTContext &Ctx = D->getASTContext();
+      // Dereference the variable unless the source uses C++.
+      if (!Ctx.getLangOpts().CPlusPlus)
+        OS << '*';
+      OS << VD->getName() << " = ";
+      const Expr *Init = getInitializerExprWithLexicalRange(VD->getInit());
+      SourceLocation End = Init->getLocStart();
+      if (const auto *Construct = dyn_cast<CXXConstructExpr>(Init)) {
+        SourceRange SubRange = Construct->getParenOrBraceRange();
+        if (SubRange.isValid()) {
+          End = SubRange.getBegin();
+          VD->getType().print(OS, PP);
+        }
+      }
+      if (End.isMacroID())
+        End = Ctx.getSourceManager().getExpansionLoc(End);
+      auto Range = CharSourceRange::getCharRange(StartLoc, End);
+      SourceRewriter.ReplaceText(StartLoc, SourceRewriter.getRangeSize(Range),
+                                 OS.str());
+      StartLoc = getPreciseTokenLocEnd(D->getLocEnd(), Ctx.getSourceManager(),
+                                       Ctx.getLangOpts());
+    }
+  }
+
+  /// When a declaration statement has variables that are both used after
+  /// extraction and not used after extraction, we create new declaration
+  /// statements that declare the unused variables, while creating assignment
+  /// statements that "initialize" the variables that are used after the
+  /// extraction. This way we can preserve the order of
+  /// initialization/assignment from the original declaration statement.
+  void rewriteMixedDeclarations(const DeclStmt *S) {
+    // Completely rewrite the declaration statement.
+    std::string Str;
+    llvm::raw_string_ostream OS(Str);
+    for (const Decl *D : S->decls()) {
+      const ASTContext &Ctx = D->getASTContext();
+      const VarDecl *VD = dyn_cast<VarDecl>(D);
+      bool IsLast = D == S->decl_end()[-1];
+      if (!VD) {
+        OS << "<<unsupported declaration>>;";
+        continue;
+      }
+
+      auto PrintInit = [&](bool IsDeclaration) {
+        printInitializerExpressionUsingOriginalSyntax(
+            VD, VD->getInit(), IsDeclaration, Ctx, OS, PP);
+      };
+      if (!VariablesUsedAfterExtraction.count(VD)) {
+        VD->getType().print(OS, PP);
+        OS << " " << VD->getName();
+        if (VD->hasInit() && !isImplicitInitializer(VD))
+          PrintInit(/*IsDeclaration=*/true);
+        OS << ";";
+        if (!IsLast)
+          OS << ' ';
+        continue;
+      }
+      if (VD->hasInit() && !isImplicitInitializer(VD)) {
+        // Dereference the variable unless the source uses C++.
+        if (!Ctx.getLangOpts().CPlusPlus)
+          OS << '*';
+        OS << VD->getName() << " = ";
+        PrintInit(/*IsDeclaration=*/false);
+        OS << ";";
+        if (!IsLast)
+          OS << ' ';
+      }
+    }
+    SourceRewriter.ReplaceText(S->getSourceRange(), OS.str());
+  }
+
+  bool VisitDeclStmt(const DeclStmt *S) {
+    bool AreAllUsed = true;
+    bool AreNoneUsed = true;
+    for (const Decl *D : S->decls()) {
+      const auto *VD = dyn_cast<VarDecl>(D);
+      if (!VD || !VariablesUsedAfterExtraction.count(VD)) {
+        AreAllUsed = false;
+        continue;
+      }
+      AreNoneUsed = false;
+      // Exit early when both flags were set in the loop.
+      if (!AreAllUsed)
+        break;
+    }
+    if (AreNoneUsed)
+      return true;
+
+    if (AreAllUsed)
+      rewriteAllVariableDeclarationsToAssignments(S);
+    else
+      rewriteMixedDeclarations(S);
+    return true;
+  }
+};
+
+/// Takes care of pseudo object expressions and Objective-C properties to avoid
+/// duplicate rewrites and missing rewrites.
+template <typename T>
+class PseudoObjectRewriter : public RecursiveASTVisitor<T> {
+  typedef RecursiveASTVisitor<T> Base;
+
+public:
+  bool TraversePseudoObjectExpr(PseudoObjectExpr *E) {
+    return Base::TraverseStmt(E->getSyntacticForm());
+  }
+
+  bool TraverseObjCPropertyRefExpr(ObjCPropertyRefExpr *E) {
+    // Base might be an opaque expression, so we have to visit it manually as
+    // we don't necessarily visit the setter/getter message sends if just the
+    // property was selected.
+    if (E->isObjectReceiver()) {
+      if (const auto *OVE = dyn_cast<OpaqueValueExpr>(E->getBase()))
+        Base::TraverseStmt(OVE->getSourceExpr());
+    }
+    return Base::TraverseObjCPropertyRefExpr(E);
+  }
+
+  bool TraverseBinAssign(BinaryOperator *S) {
+    // RHS might be an opaque expression, if this is a property assignment. We
+    // have to visit it manually as we don't necessarily visit the setter/getter
+    // message sends if just the property was selected.
+    if (const auto *OVE = dyn_cast<OpaqueValueExpr>(S->getRHS()))
+      Base::TraverseStmt(OVE->getSourceExpr());
+    return Base::TraverseBinAssign(S);
+  }
+};
+
+/// Traverses the extracted code and rewrites the uses of captured variables
+/// that are passed into the extracted function using a pointer.
+class CapturedVariableCaptureByPointerRewriter
+    : public PseudoObjectRewriter<CapturedVariableCaptureByPointerRewriter> {
+public:
+  const VarDecl *TargetVD;
+  Rewriter &SourceRewriter;
+
+  CapturedVariableCaptureByPointerRewriter(const VarDecl *VD,
+                                           Rewriter &SourceRewriter)
+      : TargetVD(VD), SourceRewriter(SourceRewriter) {}
+
+  bool isTargetDeclRefExpr(const Expr *E) {
+    const auto *DRE = dyn_cast<DeclRefExpr>(E);
+    if (!DRE)
+      return false;
+    return dyn_cast<VarDecl>(DRE->getDecl()) == TargetVD;
+  }
+
+  void dereferenceTargetVar(const Expr *E, bool WrapInParens = false) {
+    SourceRewriter.InsertTextBefore(E->getLocStart(),
+                                    WrapInParens ? "(*" : "*");
+    if (WrapInParens)
+      SourceRewriter.InsertTextAfterToken(E->getLocEnd(), ")");
+  }
+
+  bool VisitDeclRefExpr(const DeclRefExpr *E) {
+    const VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
+    if (VD != TargetVD)
+      return true;
+    dereferenceTargetVar(E);
+    return true;
+  }
+
+  bool TraverseUnaryAddrOf(UnaryOperator *E) {
+    if (const auto *DRE =
+            dyn_cast<DeclRefExpr>(E->getSubExpr()->IgnoreParenCasts())) {
+      const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());
+      if (VD == TargetVD) {
+        // Remove the '&' as the variable is now a pointer.
+        SourceRewriter.RemoveText(
+            CharSourceRange::getTokenRange(E->getLocStart(), E->getLocStart()));
+        return true;
+      }
+    }
+    return RecursiveASTVisitor::TraverseUnaryAddrOf(E);
+  }
+
+  bool TraverseMemberExpr(MemberExpr *E) {
+    if (!E->isArrow()) {
+      if (const auto *DRE =
+              dyn_cast<DeclRefExpr>(E->getBase()->IgnoreParenCasts())) {
+        const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());
+        if (VD == TargetVD) {
+          // Replace '.' with '->'.
+          SourceRewriter.ReplaceText(E->getOperatorLoc(), 1, "->");
+          return true;
+        }
+      }
+    } else if (isTargetDeclRefExpr(E->getBase()->IgnoreImpCasts())) {
+      // Ensure the variable is wrapped in parenthesis when it's the base of
+      // '->' operator.
+      dereferenceTargetVar(E->getBase(), /*WrapInParens=*/true);
+      return true;
+    }
+    return RecursiveASTVisitor::TraverseMemberExpr(E);
+  }
+};
+
+/// Traverses the extracted code and rewrites the uses of 'this' that can be
+/// rewritten as references.
+class CapturedThisReferenceRewriter
+    : public PseudoObjectRewriter<CapturedThisReferenceRewriter> {
+public:
+  Rewriter &SourceRewriter;
+  llvm::SmallPtrSet<const CXXThisExpr *, 8> RewrittenExpressions;
+
+  CapturedThisReferenceRewriter(Rewriter &SourceRewriter)
+      : SourceRewriter(SourceRewriter) {}
+
+  void rewriteThis(const CXXThisExpr *E) {
+    RewrittenExpressions.insert(E);
+    if (!E->isImplicit())
+      SourceRewriter.ReplaceText(E->getLocStart(), 4, "object");
+    else
+      SourceRewriter.InsertText(E->getLocStart(), "object");
+  }
+
+  bool VisitMemberExpr(const MemberExpr *E) {
+    const auto *This =
+        dyn_cast<CXXThisExpr>(E->getBase()->IgnoreParenImpCasts());
+    if (This) {
+      rewriteThis(This);
+      if (!This->isImplicit() && E->isArrow())
+        SourceRewriter.ReplaceText(E->getOperatorLoc(), 2, ".");
+      else
+        SourceRewriter.InsertText(E->getBase()->getLocEnd(), ".");
+    }
+    return true;
+  }
+};
+
+/// Traverses the extracted code and rewrites the uses of 'this' into '&object'.
+class CapturedThisPointerRewriter
+    : public PseudoObjectRewriter<CapturedThisPointerRewriter> {
+public:
+  Rewriter &SourceRewriter;
+  const llvm::SmallPtrSetImpl<const CXXThisExpr *> &RewrittenExpressions;
+
+  CapturedThisPointerRewriter(
+      Rewriter &SourceRewriter,
+      const llvm::SmallPtrSetImpl<const CXXThisExpr *> &RewrittenExpressions)
+      : SourceRewriter(SourceRewriter),
+        RewrittenExpressions(RewrittenExpressions) {}
+
+  void replace(const CXXThisExpr *E, StringRef Text) {
+    SourceRewriter.ReplaceText(E->getLocStart(), 4, Text);
+  }
+
+  bool VisitCXXThisExpr(const CXXThisExpr *E) {
+    if (RewrittenExpressions.count(E))
+      return true;
+    if (!E->isImplicit())
+      replace(E, "&object");
+    return true;
+  }
+
+  bool TraverseUnaryDeref(UnaryOperator *E) {
+    if (const auto *This =
+            dyn_cast<CXXThisExpr>(E->getSubExpr()->IgnoreParenImpCasts())) {
+      if (!This->isImplicit()) {
+        // Remove the '*' as the variable is now a reference.
+        SourceRewriter.RemoveText(
+            CharSourceRange::getTokenRange(E->getLocStart(), E->getLocStart()));
+        replace(This, "object");
+        return true;
+      }
+    }
+    return RecursiveASTVisitor::TraverseUnaryAddrOf(E);
+  }
+};
+
+/// Traverses the extracted code and rewrites the uses of 'self' into 'object'.
+class CapturedSelfRewriter : public PseudoObjectRewriter<CapturedSelfRewriter> {
+public:
+  Rewriter &SourceRewriter;
+  const ImplicitParamDecl *SelfDecl;
+
+  CapturedSelfRewriter(Rewriter &SourceRewriter,
+                       const ImplicitParamDecl *SelfDecl)
+      : SourceRewriter(SourceRewriter), SelfDecl(SelfDecl) {
+    assert(SelfDecl);
+  }
+
+  bool VisitDeclRefExpr(const DeclRefExpr *E) {
+    const VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
+    if (!VD || VD != SelfDecl)
+      return true;
+    if (E->getLocStart().isInvalid())
+      return true;
+    SourceRewriter.ReplaceText(E->getLocStart(), 4, "object");
+    return true;
+  }
+
+  void insertObjectForImplicitSelf(const Expr *E, SourceLocation Loc,
+                                   StringRef Text) {
+    const auto *DRE = dyn_cast<DeclRefExpr>(E);
+    if (!DRE)
+      return;
+    const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());
+    if (!VD || VD != SelfDecl || DRE->getLocStart().isValid())
+      return;
+    SourceRewriter.InsertText(Loc, Text);
+  }
+
+  bool VisitObjCIvarRefExpr(const ObjCIvarRefExpr *E) {
+    insertObjectForImplicitSelf(E->getBase()->IgnoreImpCasts(),
+                                E->getLocStart(), "object->");
+    return true;
+  }
+};
+
+/// Traverses the extracted code and rewrites the uses of 'self' into the name
+/// of the class.
+class CapturedClassSelfRewriter
+    : public PseudoObjectRewriter<CapturedClassSelfRewriter> {
+public:
+  Rewriter &SourceRewriter;
+  StringRef ClassName;
+  const ImplicitParamDecl *SelfDecl;
+
+  CapturedClassSelfRewriter(Rewriter &SourceRewriter, StringRef ClassName,
+                            const ImplicitParamDecl *SelfDecl)
+      : SourceRewriter(SourceRewriter), ClassName(ClassName),
+        SelfDecl(SelfDecl) {
+
+    assert(SelfDecl);
+  }
+
+  bool VisitDeclRefExpr(const DeclRefExpr *E) {
+    const VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
+    if (!VD || VD != SelfDecl || E->getLocStart().isInvalid())
+      return true;
+    SourceRewriter.ReplaceText(E->getLocStart(), 4, ClassName);
+    return true;
+  }
+};
+
+/// Traverses the extracted code and rewrites the uses of 'super' into
+/// 'superObject' or the name of the super class.
+class CapturedSuperRewriter
+    : public PseudoObjectRewriter<CapturedSuperRewriter> {
+public:
+  Rewriter &SourceRewriter;
+  StringRef ReplacementString;
+
+  CapturedSuperRewriter(Rewriter &SourceRewriter, StringRef ReplacementString)
+      : SourceRewriter(SourceRewriter), ReplacementString(ReplacementString) {}
+
+  void rewriteSuper(SourceLocation Loc) {
+    SourceRewriter.ReplaceText(Loc, strlen("super"), ReplacementString);
+  }
+
+  bool VisitObjCPropertyRefExpr(const ObjCPropertyRefExpr *E) {
+    if (E->isSuperReceiver())
+      rewriteSuper(E->getReceiverLocation());
+    return true;
+  }
+
+  bool VisitObjCMessageExpr(const ObjCMessageExpr *E) {
+    if (E->getSuperLoc().isValid())
+      rewriteSuper(E->getSuperLoc());
+    return true;
+  }
+};
+
+struct ExtractionSemicolonPolicy {
+  bool IsNeededInExtractedFunction;
+  bool IsNeededInOriginalFunction;
+
+  static ExtractionSemicolonPolicy neededInExtractedFunction() {
+    return {true, false};
+  }
+  static ExtractionSemicolonPolicy neededInOriginalFunction() {
+    return {false, true};
+  }
+  static ExtractionSemicolonPolicy neededInBoth() { return {true, true}; }
+};
+
+} // end anonymous namespace
+
+ExtractionSemicolonPolicy
+computeSemicolonExtractionPolicy(const Stmt *S, SourceRange &ExtractedRange,
+                                 const SourceManager &SM,
+                                 const LangOptions &LangOpts) {
+  if (isa<Expr>(S))
+    return ExtractionSemicolonPolicy::neededInExtractedFunction();
+  bool NeedsSemi = isSemicolonRequiredAfter(S);
+  if (!NeedsSemi)
+    return ExtractionSemicolonPolicy::neededInOriginalFunction();
+  SourceLocation End = ExtractedRange.getEnd();
+  if (isSemicolonAtLocation(End, SM, LangOpts))
+    return ExtractionSemicolonPolicy::neededInOriginalFunction();
+  SourceLocation NextTokenLoc =
+      Lexer::findNextTokenLocationAfterTokenAt(End, SM, LangOpts);
+  if (NextTokenLoc.isValid() &&
+      isSemicolonAtLocation(NextTokenLoc, SM, LangOpts) &&
+      areOnSameLine(NextTokenLoc, End, SM)) {
+    ExtractedRange.setEnd(NextTokenLoc);
+    return ExtractionSemicolonPolicy::neededInOriginalFunction();
+  }
+  return ExtractionSemicolonPolicy::neededInBoth();
+}
+
+PrintingPolicy getPrintingPolicy(const ASTContext &Context,
+                                 const Preprocessor &PP) {
+  PrintingPolicy Policy = Context.getPrintingPolicy();
+  // Our printing policy is copied over the ASTContext printing policy whenever
+  // a diagnostic is emitted, so recompute it.
+  Policy.Bool = Context.getLangOpts().Bool;
+  // FIXME: This is duplicated with Sema.cpp. When upstreaming this should be
+  // cleaned up.
+  if (!Policy.Bool) {
+    if (const MacroInfo *BoolMacro = PP.getMacroInfo(Context.getBoolName())) {
+      Policy.Bool = BoolMacro->isObjectLike() &&
+                    BoolMacro->getNumTokens() == 1 &&
+                    BoolMacro->getReplacementToken(0).is(tok::kw__Bool);
+    }
+  }
+  return Policy;
+}
+
+static QualType getFunctionLikeParentDeclReturnType(const Decl *D) {
+  // FIXME: might need to handle ObjC blocks in the future.
+  if (const auto *M = dyn_cast<ObjCMethodDecl>(D))
+    return M->getReturnType();
+  return cast<FunctionDecl>(D)->getReturnType();
+}
+
+static const Stmt *getEnclosingDeclBody(const Decl *D) {
+  // FIXME: might need to handle ObjC blocks in the future.
+  if (const auto *M = dyn_cast<ObjCMethodDecl>(D))
+    return M->getBody();
+  return cast<FunctionDecl>(D)->getBody();
+}
+
+static bool isEnclosingMethodConst(const Decl *D) {
+  if (const auto *MD = dyn_cast<CXXMethodDecl>(D))
+    return MD->isConst();
+  return false;
+}
+
+static bool isEnclosingMethodStatic(const Decl *D) {
+  if (const auto *MD = dyn_cast<CXXMethodDecl>(D))
+    return MD->isStatic();
+  return false;
+}
+
+static bool isEnclosingMethodOutOfLine(const Decl *D) {
+  const auto *MD = dyn_cast<CXXMethodDecl>(D);
+  if (!MD)
+    return false;
+  return MD->isOutOfLine();
+}
+
+static void printEnclosingMethodScope(const Decl *D, llvm::raw_ostream &OS,
+                                      const PrintingPolicy &PP) {
+  const auto *MD = dyn_cast<CXXMethodDecl>(D);
+  if (!MD)
+    return;
+  if (!MD->isOutOfLine() || !MD->getQualifier())
+    return;
+  MD->getQualifier()->print(OS, PP);
+}
+
+static SourceLocation
+computeFunctionExtractionLocation(const Decl *D, bool IsMethodExtraction) {
+  if (!IsMethodExtraction && isa<CXXMethodDecl>(D)) {
+    // Code from methods that defined in class bodies should be extracted to a
+    // function defined just before the class.
+    while (const auto *RD = dyn_cast<CXXRecordDecl>(D->getLexicalDeclContext()))
+      D = RD;
+  }
+  return D->getLocStart();
+}
+
+namespace {
+enum class MethodDeclarationPlacement { After, Before };
+
+/// \brief Represents an entity captured from the original function that's
+/// passed into the new function/method.
+struct CapturedVariable {
+  const VarDecl *VD;
+  const FieldDecl *FD;
+  QualType ThisType;
+  bool PassByRefOrPtr;
+  bool IsRefOrPtrConst;
+  bool IsThisSelf = false;
+  bool IsThisSuper = false;
+  bool TakeAddress = false;
+  QualType ParameterType;
+
+  CapturedVariable(const VarDecl *VD, bool PassByRefOrPtr, bool IsRefOrPtrConst)
+      : VD(VD), FD(nullptr), PassByRefOrPtr(PassByRefOrPtr),
+        IsRefOrPtrConst(IsRefOrPtrConst) {}
+  CapturedVariable(const FieldDecl *FD, bool PassByRefOrPtr,
+                   bool IsRefOrPtrConst)
+      : VD(nullptr), FD(FD), PassByRefOrPtr(PassByRefOrPtr),
+        IsRefOrPtrConst(IsRefOrPtrConst) {}
+  CapturedVariable(QualType ThisType, bool PassByRefOrPtr, bool IsConst)
+      : VD(nullptr), FD(nullptr), ThisType(ThisType),
+        PassByRefOrPtr(PassByRefOrPtr), IsRefOrPtrConst(IsConst) {}
+
+  static CapturedVariable getThis(QualType T, bool IsConst) {
+    return CapturedVariable(T, /*PassByRefOrPtr=*/true, /*IsConst*/ IsConst);
+  }
+
+  static CapturedVariable getSelf(QualType T) {
+    auto Result =
+        CapturedVariable(T, /*PassByRefOrPtr=*/false, /*IsConst*/ false);
+    Result.IsThisSelf = true;
+    return Result;
+  }
+
+  static CapturedVariable getSuper(QualType T) {
+    auto Result =
+        CapturedVariable(T, /*PassByRefOrPtr=*/false, /*IsConst*/ false);
+    Result.IsThisSuper = true;
+    return Result;
+  }
+
+  StringRef getName() const {
+    return VD ? VD->getName()
+              : FD ? FD->getName() : IsThisSuper ? "superObject" : "object";
+  }
+  StringRef getExpr() const {
+    return ThisType.isNull()
+               ? getName()
+               : IsThisSelf ? "self" : IsThisSuper ? "super.self" : "*this";
+  }
+  QualType getType() const {
+    return VD ? VD->getType() : FD ? FD->getType() : ThisType;
+  }
+};
+} // end anonymous namespace
+
+static std::pair<SourceLocation, MethodDeclarationPlacement>
+computeAppropriateExtractionLocationForMethodDeclaration(
+    const CXXMethodDecl *D) {
+  const CXXRecordDecl *RD = D->getParent();
+  // Try to put the new declaration after the last method, or just before the
+  // end of the class.
+  SourceLocation Loc;
+  for (const CXXMethodDecl *M : RD->methods()) {
+    if (M->isImplicit())
+      continue;
+    Loc = M->getLocEnd();
+  }
+  return Loc.isValid() ? std::make_pair(Loc, MethodDeclarationPlacement::After)
+                       : std::make_pair(RD->getLocEnd(),
+                                        MethodDeclarationPlacement::Before);
+}
+
+static bool isInHeader(SourceLocation Loc, const SourceManager &SM) {
+  // Base the header decision on the filename.
+  StringRef Extension = llvm::sys::path::extension(SM.getFilename(Loc));
+  if (Extension.empty())
+    return false;
+  return llvm::StringSwitch<bool>(Extension.drop_front())
+      .Case("h", true)
+      .Case("hpp", true)
+      .Case("hh", true)
+      .Case("h++", true)
+      .Case("hxx", true)
+      .Case("inl", true)
+      .Case("def", true)
+      .Default(false);
+}
+
+llvm::Expected<RefactoringResult>
+ExtractOperation::performExpressionExtraction(ASTContext &Context,
+                                              PrintingPolicy &PP) {
+  assert(isExpressionExtraction() && "Not an expression extraction");
+  std::vector<RefactoringReplacement> Replacements;
+  const Expr *E = cast<Expr>(S);
+  QualType VarType = findExpressionLexicalType(FunctionLikeParentDecl, E,
+                                               E->getType(), PP, Context);
+  StringRef VarName = "extractedExpr";
+  auto CreatedSymbol = llvm::make_unique<RefactoringResultAssociatedSymbol>(
+      OldSymbolName(VarName));
+
+  SourceRange ExtractedTokenRange = CandidateExtractionInfo[0].Range;
+  SourceRange ExtractedCharRange = SourceRange(
+      ExtractedTokenRange.getBegin(),
+      getPreciseTokenLocEnd(ExtractedTokenRange.getEnd(),
+                            Context.getSourceManager(), Context.getLangOpts()));
+
+  // Create the variable that will hold the value of the duplicate expression.
+  std::string VariableDeclarationString;
+  llvm::raw_string_ostream OS(VariableDeclarationString);
+  VarType.print(OS, PP, /*PlaceHolder*/ VarName);
+  // FIXME: We should hook into the TypePrinter when moving over to llvm.org
+  // instead and get the offset from it.
+  unsigned NameOffset = StringRef(OS.str()).find(VarName);
+  OS << " = ";
+  OS << Lexer::getSourceText(CharSourceRange::getCharRange(ExtractedCharRange),
+                             Context.getSourceManager(), Context.getLangOpts());
+  OS << ";\n";
+
+  // Variable declaration.
+  SourceLocation InsertionLoc =
+      extract::locationForExtractedVariableDeclaration(
+          E, FunctionLikeParentDecl, Context.getSourceManager());
+  Replacements.push_back(RefactoringReplacement(
+      SourceRange(InsertionLoc, InsertionLoc), OS.str(), CreatedSymbol.get(),
+      RefactoringReplacement::AssociatedSymbolLocation(
+          llvm::makeArrayRef(NameOffset), /*IsDeclaration=*/true)));
+  // Replace the expression with the variable.
+  Replacements.push_back(
+      RefactoringReplacement(ExtractedCharRange, VarName, CreatedSymbol.get(),
+                             /*NameOffset=*/llvm::makeArrayRef(unsigned(0))));
+
+  RefactoringResult Result(std::move(Replacements));
+  Result.AssociatedSymbols.push_back(std::move(CreatedSymbol));
+  return std::move(Result);
+}
+
+llvm::Expected<RefactoringResult> ExtractOperation::perform(
+    ASTContext &Context, const Preprocessor &ThePreprocessor,
+    const RefactoringOptionSet &Options, unsigned SelectedCandidateIndex) {
+  std::vector<RefactoringReplacement> Replacements;
+  SourceManager &SM = Context.getSourceManager();
+  const LangOptions &LangOpts = Context.getLangOpts();
+  Rewriter SourceRewriter(SM, LangOpts);
+  PrintingPolicy PP = getPrintingPolicy(Context, ThePreprocessor);
+  PP.UseStdFunctionForLambda = true;
+  PP.SuppressStrongLifetime = true;
+  PP.SuppressLifetimeQualifiers = true;
+  PP.SuppressUnwrittenScope = true;
+
+  if (isExpressionExtraction())
+    return performExpressionExtraction(Context, PP);
+
+  const Stmt *S =
+      CandidateExtractionInfo[SelectedCandidateIndex].AnalyzedStatement
+          ? CandidateExtractionInfo[SelectedCandidateIndex].AnalyzedStatement
+          : this->S;
+
+  const auto *EnclosingObjCMethod =
+      dyn_cast<ObjCMethodDecl>(FunctionLikeParentDecl);
+
+  // Find the variables that are captured by the extracted code.
+  ExtractedCodeVisitor Visitor(/*SelfDecl=*/EnclosingObjCMethod
+                                   ? EnclosingObjCMethod->getSelfDecl()
+                                   : nullptr);
+  if (ExtractedStmtRange) {
+    for (const Stmt *S : *ExtractedStmtRange)
+      Visitor.InspectExtractedStmt(const_cast<Stmt *>(S), Context);
+  } else
+    Visitor.InspectExtractedStmt(const_cast<Stmt *>(S), Context);
+  // Compute the return type.
+  bool IsExpr = isLexicalExpression(S, ParentStmt);
+  QualType ReturnType;
+  if (IsExpr || Visitor.HasReturnInExtracted) {
+    if (const auto *E = dyn_cast<Expr>(S)) {
+      assert(!ExtractedStmtRange);
+      ReturnType = findExpressionLexicalType(FunctionLikeParentDecl, E,
+                                             E->getType(), PP, Context);
+    } else
+      ReturnType = getFunctionLikeParentDeclReturnType(FunctionLikeParentDecl);
+  } else
+    ReturnType = Context.VoidTy;
+  // Sort the captured variables.
+  std::vector<CapturedVariable> CapturedVariables;
+  llvm::SmallPtrSet<const VarDecl *, 4> VariablesDefinedInExtractedCode;
+  CapturedVariables.reserve(Visitor.CapturedVariables.size() +
+                            Visitor.CapturedFields.size());
+  for (const auto &I : Visitor.CapturedVariables) {
+    if (I.getSecond().IsDefined) {
+      VariablesDefinedInExtractedCode.insert(I.getFirst());
+      continue;
+    }
+    CapturedVariables.push_back(
+        CapturedVariable(I.getFirst(), I.getSecond().isPassedByRefOrPtr(),
+                         I.getSecond().isRefOrPtrConst()));
+  }
+  // Take a look at the variables that are defined in the extracted code.
+  VariableDefinedInExtractedCodeUseAfterExtractionFinder
+      UsedAfterExtractionFinder(ExtractedStmtRange ? *ExtractedStmtRange->Last
+                                                   : S,
+                                VariablesDefinedInExtractedCode);
+  UsedAfterExtractionFinder.TraverseStmt(
+      const_cast<Stmt *>(getEnclosingDeclBody(FunctionLikeParentDecl)));
+  struct RedeclaredVariable {
+    const VarDecl *VD;
+    int OrderingPriority;
+  };
+  llvm::SmallVector<RedeclaredVariable, 4> RedeclaredVariables;
+  bool CanUseReturnForVariablesUsedAfterwards =
+      !isa<Expr>(S) && ReturnType->isVoidType() &&
+      UsedAfterExtractionFinder.VariablesUsedAfterExtraction.size() == 1;
+  if (CanUseReturnForVariablesUsedAfterwards) {
+    // Avoid using the return value for the variable that's used afterwards as
+    // another variable might shadow it at the point of a 'return' that we
+    // have to rewrite to 'return var'.
+    const VarDecl *VD =
+        *UsedAfterExtractionFinder.VariablesUsedAfterExtraction.begin();
+    if (ExtractedStmtRange) {
+      for (const Stmt *S : *ExtractedStmtRange) {
+        if (PossibleShadowingVariableFinder::hasShadowingVar(VD, S)) {
+          CanUseReturnForVariablesUsedAfterwards = false;
+          break;
+        }
+      }
+    } else
+      CanUseReturnForVariablesUsedAfterwards =
+          !PossibleShadowingVariableFinder::hasShadowingVar(VD, S);
+  }
+  if (CanUseReturnForVariablesUsedAfterwards) {
+    for (const auto &I : Visitor.CapturedVariables) {
+      if (!I.getSecond().IsDefined ||
+          !UsedAfterExtractionFinder.VariablesUsedAfterExtraction.count(
+              I.getFirst()))
+        continue;
+      RedeclaredVariables.push_back(
+          {I.getFirst(), I.getSecond().DefineOrderingPriority});
+      ReturnType = I.getFirst()->getType();
+      // Const qualifier can be dropped as we don't want to declare the return
+      // type as 'const'.
+      if (ReturnType.isConstQualified())
+        ReturnType.removeLocalConst();
+      break;
+    }
+    if (Visitor.HasReturnInExtracted) {
+      ReturnRewriter ReturnsRewriter(SourceRewriter,
+                                     RedeclaredVariables.front().VD->getName());
+      if (ExtractedStmtRange) {
+        for (const Stmt *S : *ExtractedStmtRange)
+          ReturnsRewriter.TraverseStmt(const_cast<Stmt *>(S));
+      } else
+        ReturnsRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    }
+  } else {
+    for (const auto &I : Visitor.CapturedVariables) {
+      if (!I.getSecond().IsDefined ||
+          !UsedAfterExtractionFinder.VariablesUsedAfterExtraction.count(
+              I.getFirst()))
+        continue;
+      RedeclaredVariables.push_back(
+          {I.getFirst(), I.getSecond().DefineOrderingPriority});
+      if (!I.getSecond().IsUsed)
+        continue;
+      // Pass the variable that's defined in the extracted code but used
+      // afterwards as a parameter only when it's actually used in the extracted
+      // code.
+      CapturedVariables.push_back(CapturedVariable(I.getFirst(),
+                                                   /*PassByRefOrPtr=*/true,
+                                                   /*IsRefOrPtrConst=*/false));
+    }
+    std::sort(RedeclaredVariables.begin(), RedeclaredVariables.end(),
+              [](const RedeclaredVariable &X, const RedeclaredVariable &Y) {
+                return X.OrderingPriority < Y.OrderingPriority;
+              });
+    DefinedInExtractedCodeDeclStmtRewriter DeclRewriter(
+        SourceRewriter, UsedAfterExtractionFinder.VariablesUsedAfterExtraction,
+        PP);
+    if (ExtractedStmtRange) {
+      for (const Stmt *S : *ExtractedStmtRange)
+        DeclRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    } else
+      DeclRewriter.TraverseStmt(const_cast<Stmt *>(S));
+  }
+  // Capture any fields if necessary.
+  bool IsThisConstInCapturedFieldUses = true;
+  if (!isMethodExtraction()) {
+    for (const auto &I : Visitor.CapturedFields) {
+      if (I.getSecond().isPassedByRefOrPtr() &&
+          !I.getSecond().isRefOrPtrConst())
+        IsThisConstInCapturedFieldUses = false;
+      // Private fields that use explicit 'this' should be captured using 'this'
+      // even if they might end up being inaccessible in the extracted function.
+      if (I.getSecond().IsFieldCapturedWithThis)
+        continue;
+      CapturedVariables.push_back(
+          CapturedVariable(I.getFirst(), I.getSecond().isPassedByRefOrPtr(),
+                           I.getSecond().isRefOrPtrConst()));
+    }
+  }
+  std::sort(CapturedVariables.begin(), CapturedVariables.end(),
+            [](const CapturedVariable &X, const CapturedVariable &Y) {
+              return X.getName() < Y.getName();
+            });
+  // 'This'/'self' should be passed-in first.
+  if (!isMethodExtraction() && Visitor.CaptureThis) {
+    CapturedVariables.insert(
+        CapturedVariables.begin(),
+        CapturedVariable::getThis(
+            Visitor.ThisRecordType,
+            IsThisConstInCapturedFieldUses &&
+                Visitor.IsThisConstForNonCapturedFieldUses));
+    CapturedThisReferenceRewriter ThisRewriter(SourceRewriter);
+    if (ExtractedStmtRange) {
+      for (const Stmt *S : *ExtractedStmtRange)
+        ThisRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    } else
+      ThisRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    CapturedThisPointerRewriter PtrThisRewriter(
+        SourceRewriter, ThisRewriter.RewrittenExpressions);
+    if (ExtractedStmtRange) {
+      for (const Stmt *S : *ExtractedStmtRange)
+        PtrThisRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    } else
+      PtrThisRewriter.TraverseStmt(const_cast<Stmt *>(S));
+  } else if (!isMethodExtraction() && Visitor.CaptureSelf &&
+             EnclosingObjCMethod) {
+    if (EnclosingObjCMethod->isInstanceMethod()) {
+      // Instance methods rewrite 'self' into an 'object' parameter.
+      CapturedVariables.insert(CapturedVariables.begin(),
+                               CapturedVariable::getSelf(Visitor.SelfType));
+      CapturedSelfRewriter SelfRewriter(SourceRewriter,
+                                        EnclosingObjCMethod->getSelfDecl());
+      if (ExtractedStmtRange) {
+        for (const Stmt *S : *ExtractedStmtRange)
+          SelfRewriter.TraverseStmt(const_cast<Stmt *>(S));
+      } else
+        SelfRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    } else {
+      // Class methods rewrite 'self' into the class name and don't pass 'self'
+      // as a parameter.
+      CapturedClassSelfRewriter SelfRewriter(
+          SourceRewriter, EnclosingObjCMethod->getClassInterface()->getName(),
+          EnclosingObjCMethod->getSelfDecl());
+      if (ExtractedStmtRange) {
+        for (const Stmt *S : *ExtractedStmtRange)
+          SelfRewriter.TraverseStmt(const_cast<Stmt *>(S));
+      } else
+        SelfRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    }
+  }
+  if (!isMethodExtraction() && Visitor.CaptureSuper && EnclosingObjCMethod) {
+    if (EnclosingObjCMethod->isInstanceMethod())
+      // Instance methods rewrite 'super' into an 'superObject' parameter.
+      CapturedVariables.insert(Visitor.CaptureSelf
+                                   ? CapturedVariables.begin() + 1
+                                   : CapturedVariables.begin(),
+                               CapturedVariable::getSuper(Visitor.SuperType));
+    CapturedSuperRewriter SuperRewriter(
+        SourceRewriter, EnclosingObjCMethod->isInstanceMethod()
+                            ? "superObject"
+                            : EnclosingObjCMethod->getClassInterface()
+                                  ->getSuperClass()
+                                  ->getName());
+    if (ExtractedStmtRange) {
+      for (const Stmt *S : *ExtractedStmtRange)
+        SuperRewriter.TraverseStmt(const_cast<Stmt *>(S));
+    } else
+      SuperRewriter.TraverseStmt(const_cast<Stmt *>(S));
+  }
+
+  // Compute the parameter types.
+  for (auto &Var : CapturedVariables) {
+    QualType T = Var.getType();
+
+    // Array types are passed into the extracted function using a pointer.
+    if (const auto *AT = Context.getAsArrayType(T))
+      T = Context.getPointerType(AT->getElementType());
+
+    // Captured records and other mutated variables are passed into the
+    // extracted function either using a reference (C++) or a pointer.
+    if ((T->isRecordType() || Var.PassByRefOrPtr) && !T->isReferenceType()) {
+      // Add a 'const' qualifier to the record when it's not mutated in the
+      // extracted code or when we are taking the address of the captured
+      // variable for just a 'const' use.
+      if (!Var.PassByRefOrPtr || Var.IsRefOrPtrConst)
+        T.addConst();
+
+      if (LangOpts.CPlusPlus)
+        T = Context.getLValueReferenceType(T);
+      else {
+        T = Context.getPointerType(T);
+        CapturedVariableCaptureByPointerRewriter UseRewriter(Var.VD,
+                                                             SourceRewriter);
+        if (ExtractedStmtRange) {
+          for (const Stmt *S : *ExtractedStmtRange)
+            UseRewriter.TraverseStmt(const_cast<Stmt *>(S));
+        } else
+          UseRewriter.TraverseStmt(const_cast<Stmt *>(S));
+        Var.TakeAddress = true;
+      }
+    }
+    // Const qualifier can be dropped as we don't want to declare the parameter
+    // as 'const'.
+    else if (T.isLocalConstQualified())
+      T.removeLocalConst();
+
+    Var.ParameterType = T;
+  }
+
+  // TODO: Choose a better name if there are collisions.
+  StringRef ExtractedName = "extracted";
+  llvm::SmallVector<StringRef, 4> ExtractedNamePieces;
+  ExtractedNamePieces.push_back(ExtractedName);
+  if (isMethodExtraction() && EnclosingObjCMethod &&
+      !CapturedVariables.empty()) {
+    for (const auto &Var : llvm::makeArrayRef(CapturedVariables).drop_front())
+      ExtractedNamePieces.push_back(Var.getName());
+  }
+  std::unique_ptr<RefactoringResultAssociatedSymbol> CreatedSymbol =
+      llvm::make_unique<RefactoringResultAssociatedSymbol>(
+          OldSymbolName(ExtractedNamePieces));
+
+  SourceLocation FunctionExtractionLoc = computeFunctionExtractionLocation(
+      FunctionLikeParentDecl, isMethodExtraction());
+  FunctionExtractionLoc =
+      getLocationOfPrecedingComment(FunctionExtractionLoc, SM, LangOpts);
+
+  // Create the replacement that contains the new function.
+  auto PrintFunctionHeader =
+      [&](llvm::raw_string_ostream &OS,
+          bool IsDefinition =
+              true) -> RefactoringReplacement::AssociatedSymbolLocation {
+    if (isMethodExtraction() && EnclosingObjCMethod) {
+      OS << (EnclosingObjCMethod->isClassMethod() ? '+' : '-') << " (";
+      ReturnType.print(OS, PP);
+      OS << ')';
+      llvm::SmallVector<unsigned, 4> NameOffsets;
+      NameOffsets.push_back(OS.str().size());
+      OS << ExtractedName;
+      bool IsFirst = true;
+      for (const auto &Var : CapturedVariables) {
+        if (!IsFirst) {
+          OS << ' ';
+          NameOffsets.push_back(OS.str().size());
+          OS << Var.getName();
+        }
+        IsFirst = false;
+        OS << ":(";
+        Var.ParameterType.print(OS, PP);
+        OS << ')' << Var.getName();
+      }
+      return RefactoringReplacement::AssociatedSymbolLocation(
+          NameOffsets, /*IsDeclaration=*/true);
+    }
+    auto *FD = dyn_cast<FunctionDecl>(FunctionLikeParentDecl);
+    if (isMethodExtraction() && IsDefinition &&
+        !FD->getDescribedFunctionTemplate()) {
+      // Print the class template parameter lists for an out-of-line method.
+      for (unsigned I = 0,
+                    NumTemplateParams = FD->getNumTemplateParameterLists();
+           I < NumTemplateParams; ++I) {
+        FD->getTemplateParameterList(I)->print(OS, PP, Context);
+        OS << "\n";
+      }
+    }
+    if (isMethodExtraction() && isEnclosingMethodStatic(FunctionLikeParentDecl))
+      OS << "static ";
+    else if (!isMethodExtraction())
+      OS << (isInHeader(FunctionExtractionLoc, SM) ? "inline " : "static ");
+    ReturnType.print(OS, PP);
+    OS << ' ';
+    if (isMethodExtraction() && IsDefinition)
+      printEnclosingMethodScope(FunctionLikeParentDecl, OS, PP);
+    unsigned NameOffset = OS.str().size();
+    OS << ExtractedName << '(';
+    bool IsFirst = true;
+    for (const auto &Var : CapturedVariables) {
+      if (!IsFirst)
+        OS << ", ";
+      IsFirst = false;
+      Var.ParameterType.print(OS, PP, /*PlaceHolder=*/Var.getName());
+    }
+    OS << ')';
+    if (isMethodExtraction() && isEnclosingMethodConst(FunctionLikeParentDecl))
+      OS << " const";
+    return RefactoringReplacement::AssociatedSymbolLocation(
+        NameOffset, /*IsDeclaration=*/true);
+    ;
+  };
+
+  if (isMethodExtraction() &&
+      isEnclosingMethodOutOfLine(FunctionLikeParentDecl)) {
+    // The location of the declaration should be either before the original
+    // declararation, or, if this method has not declaration, somewhere
+    // appropriate in the class.
+    MethodDeclarationPlacement Placement;
+    SourceLocation DeclarationLoc;
+    if (FunctionLikeParentDecl->getCanonicalDecl() != FunctionLikeParentDecl) {
+      DeclarationLoc = computeFunctionExtractionLocation(
+          FunctionLikeParentDecl->getCanonicalDecl(), isMethodExtraction());
+      Placement = MethodDeclarationPlacement::Before;
+    } else {
+      auto LocAndPlacement =
+          computeAppropriateExtractionLocationForMethodDeclaration(
+              cast<CXXMethodDecl>(FunctionLikeParentDecl));
+      DeclarationLoc = LocAndPlacement.first;
+      Placement = LocAndPlacement.second;
+    }
+    if (Placement == MethodDeclarationPlacement::Before)
+      DeclarationLoc =
+          getLocationOfPrecedingComment(DeclarationLoc, SM, LangOpts);
+    else
+      DeclarationLoc = getLastLineLocationUnlessItHasOtherTokens(
+          getPreciseTokenLocEnd(DeclarationLoc, SM, LangOpts), SM, LangOpts);
+    // Add a replacement for the method declaration if necessary.
+    std::string DeclarationString;
+    llvm::raw_string_ostream OS(DeclarationString);
+    if (Placement == MethodDeclarationPlacement::After)
+      OS << "\n\n";
+    RefactoringReplacement::AssociatedSymbolLocation SymbolLoc =
+        PrintFunctionHeader(OS, /*IsDefinition=*/false);
+    OS << ";\n";
+    if (Placement == MethodDeclarationPlacement::Before)
+      OS << "\n";
+    Replacements.push_back(RefactoringReplacement(
+        SourceRange(DeclarationLoc, DeclarationLoc), std::move(OS.str()),
+        CreatedSymbol.get(), SymbolLoc));
+  }
+  std::string ExtractedCode;
+  llvm::raw_string_ostream ExtractedOS(ExtractedCode);
+  RefactoringReplacement::AssociatedSymbolLocation SymbolLoc =
+      PrintFunctionHeader(ExtractedOS);
+  ExtractedOS << " {\n";
+  if (IsExpr && !ReturnType->isVoidType())
+    ExtractedOS << "return ";
+  SourceRange ExtractedTokenRange =
+      CandidateExtractionInfo[SelectedCandidateIndex].Range;
+  auto Semicolons = computeSemicolonExtractionPolicy(
+      ExtractedStmtRange ? *(ExtractedStmtRange->Last) : S, ExtractedTokenRange,
+      SM, LangOpts);
+  ExtractedOS << SourceRewriter.getRewrittenText(ExtractedTokenRange);
+  if (Semicolons.IsNeededInExtractedFunction)
+    ExtractedOS << ';';
+  if (CanUseReturnForVariablesUsedAfterwards)
+    ExtractedOS << "\nreturn " << RedeclaredVariables.front().VD->getName()
+                << ";";
+  ExtractedOS << "\n}\n\n";
+  Replacements.push_back(RefactoringReplacement(
+      SourceRange(FunctionExtractionLoc, FunctionExtractionLoc),
+      std::move(ExtractedOS.str()), CreatedSymbol.get(), SymbolLoc));
+
+  // Create a replacements that removes the extracted code in favor of the
+  // function call.
+  std::string InsertedCode;
+  llvm::raw_string_ostream InsertedOS(InsertedCode);
+  // We might have to declare variables that were declared in the extracted code
+  // but still used afterwards.
+  if (CanUseReturnForVariablesUsedAfterwards) {
+    const auto &Var = RedeclaredVariables.front();
+    Var.VD->getType().print(InsertedOS, PP);
+    InsertedOS << ' ' << Var.VD->getName() << " = ";
+  } else {
+    for (const auto &Var : RedeclaredVariables) {
+      Var.VD->getType().print(InsertedOS, PP);
+      InsertedOS << ' ' << Var.VD->getName() << ";\n";
+    }
+  }
+  InsertedOS << CandidateExtractionInfo[SelectedCandidateIndex].PreInsertedText;
+  llvm::SmallVector<unsigned, 4> NameOffsets;
+  if (isMethodExtraction() && EnclosingObjCMethod) {
+    InsertedOS << "[self ";
+    NameOffsets.push_back(InsertedOS.str().size());
+    InsertedOS << ExtractedName;
+    bool IsFirst = true;
+    for (const auto &Var : CapturedVariables) {
+      if (!IsFirst) {
+        InsertedOS << ' ';
+        NameOffsets.push_back(InsertedOS.str().size());
+        InsertedOS << Var.getName();
+      }
+      IsFirst = false;
+      InsertedOS << ':';
+      if (Var.TakeAddress)
+        InsertedOS << '&';
+      InsertedOS << Var.getExpr();
+    }
+    InsertedOS << ']';
+  } else {
+    NameOffsets.push_back(InsertedOS.str().size());
+    InsertedOS << ExtractedName << '(';
+    bool IsFirst = true;
+    for (const auto &Var : CapturedVariables) {
+      if (!IsFirst)
+        InsertedOS << ", ";
+      IsFirst = false;
+      if (Var.TakeAddress)
+        InsertedOS << '&';
+      InsertedOS << Var.getExpr();
+    }
+    InsertedOS << ')';
+  }
+  if (Semicolons.IsNeededInOriginalFunction)
+    InsertedOS << ';';
+  SourceRange ExtractedCharRange = SourceRange(
+      ExtractedTokenRange.getBegin(),
+      getPreciseTokenLocEnd(ExtractedTokenRange.getEnd(), SM, LangOpts));
+  Replacements.push_back(RefactoringReplacement(
+      ExtractedCharRange, std::move(InsertedOS.str()), CreatedSymbol.get(),
+      llvm::makeArrayRef(NameOffsets)));
+
+  RefactoringResult Result(std::move(Replacements));
+  Result.AssociatedSymbols.push_back(std::move(CreatedSymbol));
+  return std::move(Result);
+}
diff --git a/lib/Tooling/Refactor/ExtractRepeatedExpressionIntoVariable.cpp b/lib/Tooling/Refactor/ExtractRepeatedExpressionIntoVariable.cpp
index e69de29bb2..4641e0e923 100644
--- a/lib/Tooling/Refactor/ExtractRepeatedExpressionIntoVariable.cpp
+++ b/lib/Tooling/Refactor/ExtractRepeatedExpressionIntoVariable.cpp
@@ -0,0 +1,299 @@
+//===--- ExtractRepeatedExpressionIntoVariable.cpp -  ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Extract repeated expression into variable" refactoring
+// operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "ExtractionUtils.h"
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+class ExtractRepeatedExpressionIntoVariableOperation
+    : public RefactoringOperation {
+public:
+  ExtractRepeatedExpressionIntoVariableOperation(
+      const Expr *E, ArrayRef<const Expr *> Duplicates, const Decl *ParentDecl)
+      : E(E), DuplicateExpressions(Duplicates.begin(), Duplicates.end()),
+        ParentDecl(ParentDecl) {}
+
+  const Stmt *getTransformedStmt() const override { return E; }
+
+  llvm::Expected<RefactoringResult> perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  const Expr *E;
+  SmallVector<const Expr *, 4> DuplicateExpressions;
+  const Decl *ParentDecl;
+};
+
+using UseOfDeclaration = std::pair<const Decl *, unsigned>;
+
+bool shouldIgnoreParens(const ParenExpr *E) {
+  if (!E)
+    return false;
+  const Expr *Child = E->getSubExpr();
+  // Ignore the parens unless they are around an expression that
+  // really needs them.
+  if (isa<UnaryOperator>(Child) || isa<BinaryOperator>(Child) ||
+      isa<AbstractConditionalOperator>(Child) ||
+      isa<CXXOperatorCallExpr>(Child))
+    return false;
+  return true;
+}
+
+/// Builds up a list of declarations that are used in an expression.
+class DuplicateExprSemanticProfiler
+    : public RecursiveASTVisitor<DuplicateExprSemanticProfiler> {
+  unsigned Index = 0;
+  llvm::SmallVectorImpl<UseOfDeclaration> &DeclRefs;
+
+public:
+  DuplicateExprSemanticProfiler(
+      llvm::SmallVectorImpl<UseOfDeclaration> &DeclRefs)
+      : DeclRefs(DeclRefs) {
+    DeclRefs.clear();
+  }
+
+  bool VisitStmt(const Stmt *S) {
+    if (!shouldIgnoreParens(dyn_cast<ParenExpr>(S)))
+      ++Index;
+    return true;
+  }
+
+  bool VisitDeclRefExpr(const DeclRefExpr *E) {
+    if (E->getDecl())
+      DeclRefs.emplace_back(E->getDecl(), Index);
+    return true;
+  }
+};
+
+class DuplicateExprFinder : public RecursiveASTVisitor<DuplicateExprFinder>,
+                            PrinterHelper {
+  const Expr *Target;
+  const ASTContext &Context;
+  const PrintingPolicy &PP;
+  Stmt::StmtClass ExprKind;
+  QualType T;
+  std::string ExprString, OSString;
+  llvm::SmallVector<UseOfDeclaration, 8> ExprDecls, DeclUses;
+
+  void printExpr(std::string &Str, const Expr *E) {
+    llvm::raw_string_ostream OS(Str);
+    E->printPretty(OS, /*Helper=*/this, PP);
+  }
+
+public:
+  SmallVector<const Expr *, 4> DuplicateExpressions;
+
+  DuplicateExprFinder(const Expr *E, const ASTContext &Context,
+                      const PrintingPolicy &PP)
+      : Target(E), Context(Context), PP(PP), ExprKind(E->getStmtClass()),
+        T(E->getType()) {
+    printExpr(ExprString, E);
+    DuplicateExprSemanticProfiler(ExprDecls).TraverseStmt(
+        const_cast<Expr *>(E));
+  }
+
+  bool handledStmt(Stmt *E, raw_ostream &OS) final override {
+    if (const auto *Paren = dyn_cast<ParenExpr>(E)) {
+      if (!shouldIgnoreParens(Paren))
+        return false;
+      Paren->getSubExpr()->printPretty(OS, /*Helper=*/this, PP);
+      return true;
+    }
+    return false;
+  }
+
+  bool VisitStmt(const Stmt *S) {
+    if (S->getStmtClass() != ExprKind)
+      return true;
+    const auto *E = cast<Expr>(S);
+    if (E == Target) {
+      DuplicateExpressions.push_back(E);
+      return true;
+    }
+    // The expression should not be in a macro.
+    SourceRange R = E->getSourceRange();
+    if (R.getBegin().isMacroID()) {
+      if (!Context.getSourceManager().isMacroArgExpansion(R.getBegin()))
+        return true;
+    }
+    if (R.getEnd().isMacroID()) {
+      if (!Context.getSourceManager().isMacroArgExpansion(R.getEnd()))
+        return true;
+    }
+    // The expression types should match.
+    if (E->getType() != T)
+      return true;
+    // Check if the expression is a duplicate by comparing their lexical
+    // representations.
+    OSString.clear();
+    printExpr(OSString, E);
+    if (OSString == ExprString) {
+      DuplicateExprSemanticProfiler(DeclUses).TraverseStmt(
+          const_cast<Expr *>(E));
+      // Check if they're semantically equivalent.
+      if (ExprDecls.size() == DeclUses.size() &&
+          std::equal(ExprDecls.begin(), ExprDecls.end(), DeclUses.begin()))
+        DuplicateExpressions.push_back(E);
+    }
+    return true;
+  }
+};
+
+} // end anonymous namespace
+
+static QualType returnTypeOfCall(const Expr *E) {
+  if (const auto *Call = dyn_cast<CallExpr>(E)) {
+    if (const auto *Fn = Call->getDirectCallee())
+      return Fn->getReturnType();
+  } else if (const auto *Msg = dyn_cast<ObjCMessageExpr>(E)) {
+    if (const auto *M = Msg->getMethodDecl())
+      return M->getReturnType();
+  } else if (const auto *PRE = dyn_cast<ObjCPropertyRefExpr>(E)) {
+    if (PRE->isImplicitProperty()) {
+      if (const auto *M = PRE->getImplicitPropertyGetter())
+        return M->getReturnType();
+    } else if (const auto *Prop = PRE->getExplicitProperty())
+      return Prop->getType();
+  }
+  return QualType();
+}
+
+static bool isRepeatableExpression(const Stmt *S) {
+  if (const auto *Op = dyn_cast<CXXOperatorCallExpr>(S))
+    return Op->getOperator() == OO_Call || Op->getOperator() == OO_Subscript;
+  return isa<CallExpr>(S) || isa<ObjCMessageExpr>(S) ||
+         isa<ObjCPropertyRefExpr>(S);
+}
+
+RefactoringOperationResult
+clang::tooling::initiateExtractRepeatedExpressionIntoVariableOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  const Stmt *S;
+  const Decl *ParentDecl;
+  if (SelectionRange.isValid()) {
+    auto SelectedStmt = Slice.getSelectedStmtSet();
+    if (!SelectedStmt)
+      return None;
+    if (!SelectedStmt->containsSelectionRange)
+      return None;
+    if (!isRepeatableExpression(SelectedStmt->containsSelectionRange))
+      return None;
+    S = SelectedStmt->containsSelectionRange;
+    ParentDecl =
+        Slice.parentDeclForIndex(*SelectedStmt->containsSelectionRangeIndex);
+  } else {
+    auto SelectedStmt = Slice.nearestSelectedStmt(isRepeatableExpression);
+    if (!SelectedStmt)
+      return None;
+    S = SelectedStmt->getStmt();
+    ParentDecl = SelectedStmt->getParentDecl();
+  }
+
+  const Expr *E = cast<Expr>(S);
+  // Check if the function/method returns a reference/pointer.
+  QualType T = returnTypeOfCall(E);
+  if (!T.getTypePtrOrNull() ||
+      (!T->isAnyPointerType() && !T->isReferenceType()))
+    return None;
+
+  DuplicateExprFinder DupFinder(E, Context, Context.getPrintingPolicy());
+  DupFinder.TraverseDecl(const_cast<Decl *>(ParentDecl));
+  if (DupFinder.DuplicateExpressions.size() < 2)
+    return None;
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (!CreateOperation)
+    return Result;
+  auto Operation =
+      llvm::make_unique<ExtractRepeatedExpressionIntoVariableOperation>(
+          E, DupFinder.DuplicateExpressions, ParentDecl);
+  Result.RefactoringOp = std::move(Operation);
+  return Result;
+}
+
+static StringRef nameForExtractedVariable(const Expr *E) {
+  auto SuggestedName = extract::nameForExtractedVariable(E);
+  if (!SuggestedName)
+    return "duplicate";
+  return *SuggestedName;
+}
+
+llvm::Expected<RefactoringResult>
+ExtractRepeatedExpressionIntoVariableOperation::perform(
+    ASTContext &Context, const Preprocessor &ThePreprocessor,
+    const RefactoringOptionSet &Options, unsigned SelectedCandidateIndex) {
+  RefactoringResult Result(std::vector<RefactoringReplacement>{});
+  std::vector<RefactoringReplacement> &Replacements = Result.Replacements;
+
+  const SourceManager &SM = Context.getSourceManager();
+  SourceLocation InsertionLoc =
+      extract::locationForExtractedVariableDeclaration(DuplicateExpressions,
+                                                       ParentDecl, SM);
+  if (InsertionLoc.isInvalid())
+    return llvm::make_error<RefactoringOperationError>(
+        "no appropriate insertion location found");
+
+  StringRef Name = nameForExtractedVariable(E);
+  Result.AssociatedSymbols.push_back(
+      llvm::make_unique<RefactoringResultAssociatedSymbol>(
+          OldSymbolName(Name)));
+  RefactoringResultAssociatedSymbol *CreatedSymbol =
+      Result.AssociatedSymbols.back().get();
+
+  // Create the variable that will hold the value of the duplicate expression.
+  std::string VariableDeclarationString;
+  llvm::raw_string_ostream OS(VariableDeclarationString);
+  QualType T = returnTypeOfCall(E);
+  PrintingPolicy PP = Context.getPrintingPolicy();
+  PP.SuppressStrongLifetime = true;
+  PP.SuppressLifetimeQualifiers = true;
+  PP.SuppressUnwrittenScope = true;
+  T.print(OS, PP, /*PlaceHolder*/ Name);
+  // FIXME: We should hook into the TypePrinter when moving over to llvm.org
+  // instead and get the offset from it.
+  unsigned NameOffset = StringRef(OS.str()).find(Name);
+  OS << " = ";
+  PrintingPolicy ExprPP = Context.getPrintingPolicy();
+  ExprPP.SuppressStrongLifetime = true;
+  ExprPP.SuppressImplicitBase = true;
+  E->printPretty(OS, /*Helper=*/nullptr, ExprPP);
+  OS << ";\n";
+  Replacements.push_back(RefactoringReplacement(
+      SourceRange(InsertionLoc, InsertionLoc), OS.str(), CreatedSymbol,
+      RefactoringReplacement::AssociatedSymbolLocation(
+          llvm::makeArrayRef(NameOffset), /*IsDeclaration=*/true)));
+
+  // Replace the duplicates with a reference to the variable.
+  for (const Expr *E : DuplicateExpressions) {
+    Replacements.push_back(RefactoringReplacement(
+        SourceRange(SM.getSpellingLoc(E->getLocStart()),
+                    getPreciseTokenLocEnd(SM.getSpellingLoc(E->getLocEnd()), SM,
+                                          Context.getLangOpts())),
+        Name, CreatedSymbol,
+        /*NameOffset=*/llvm::makeArrayRef(unsigned(0))));
+  }
+
+  return std::move(Result);
+}
diff --git a/lib/Tooling/Refactor/ExtractionUtils.cpp b/lib/Tooling/Refactor/ExtractionUtils.cpp
index e69de29bb2..a733add982 100644
--- a/lib/Tooling/Refactor/ExtractionUtils.cpp
+++ b/lib/Tooling/Refactor/ExtractionUtils.cpp
@@ -0,0 +1,137 @@
+//===--- ExtractionUtils.cpp - Extraction helper functions ----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "ExtractionUtils.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/ExprObjC.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/Support/SaveAndRestore.h"
+
+using namespace clang;
+
+Optional<StringRef> tooling::extract::nameForExtractedVariable(const Expr *E) {
+  if (const auto *Call = dyn_cast<CallExpr>(E)) {
+    if (const auto *Fn = Call->getDirectCallee())
+      return Fn->getName();
+  } else if (const auto *Msg = dyn_cast<ObjCMessageExpr>(E)) {
+    if (const auto *M = Msg->getMethodDecl()) {
+      if (M->getSelector().isUnarySelector())
+        return M->getSelector().getNameForSlot(0);
+    }
+  } else if (const auto *PRE = dyn_cast<ObjCPropertyRefExpr>(E)) {
+    if (PRE->isImplicitProperty()) {
+      if (const auto *M = PRE->getImplicitPropertyGetter())
+        return M->getSelector().getNameForSlot(0);
+    } else if (const auto *Prop = PRE->getExplicitProperty())
+      return Prop->getName();
+  }
+  return None;
+}
+
+namespace {
+
+/// Checks if a set of expressions is directly contained in some AST region.
+class StmtReachabilityChecker
+    : public RecursiveASTVisitor<StmtReachabilityChecker> {
+  const llvm::SmallPtrSetImpl<const Stmt *> &Expressions;
+  unsigned Count = 0;
+
+  StmtReachabilityChecker(
+      const llvm::SmallPtrSetImpl<const Stmt *> &Expressions)
+      : Expressions(Expressions) {}
+
+  bool areAllExpressionsReached() const { return Count == Expressions.size(); }
+
+public:
+  bool VisitStmt(const Stmt *S) {
+    if (Expressions.count(S)) {
+      ++Count;
+      if (areAllExpressionsReached())
+        return false;
+    }
+    return true;
+  }
+
+  static bool areAllExpressionsReachableFrom(
+      CompoundStmt *S, const llvm::SmallPtrSetImpl<const Stmt *> &Expressions) {
+    StmtReachabilityChecker Checker(Expressions);
+    Checker.TraverseStmt(S);
+    return Checker.areAllExpressionsReached();
+  }
+};
+
+/// Figures out where the extracted variable should go.
+class ExtractedVariableInsertionLocFinder
+    : public RecursiveASTVisitor<ExtractedVariableInsertionLocFinder> {
+  llvm::SmallPtrSet<const Stmt *, 4> Expressions;
+  llvm::SmallVector<std::pair<CompoundStmt *, const Stmt *>, 4>
+      InsertionCandidateStack;
+  bool IsPrevCompoundStmt = false;
+
+public:
+  SourceLocation Loc;
+
+  /// Initializes the insertion location finder using the set of duplicate
+  /// \p Expressions from one function.
+  ExtractedVariableInsertionLocFinder(ArrayRef<const Expr *> Expressions) {
+    for (const Expr *E : Expressions)
+      this->Expressions.insert(E);
+  }
+
+  bool TraverseStmt(Stmt *S) {
+    if (!S)
+      return RecursiveASTVisitor::TraverseStmt(S);
+    if (IsPrevCompoundStmt && !InsertionCandidateStack.empty())
+      InsertionCandidateStack.back().second = S;
+    llvm::SaveAndRestore<bool> IsPrevCompoundStmtTracker(IsPrevCompoundStmt,
+                                                         false);
+    if (auto *CS = dyn_cast<CompoundStmt>(S)) {
+      IsPrevCompoundStmt = true;
+      InsertionCandidateStack.emplace_back(CS, nullptr);
+      RecursiveASTVisitor::TraverseStmt(S);
+      InsertionCandidateStack.pop_back();
+      return true;
+    }
+    return RecursiveASTVisitor::TraverseStmt(S);
+  }
+
+  bool VisitStmt(const Stmt *S) {
+    if (Expressions.count(S)) {
+      // The insertion location should be in the first compound statement that
+      // includes all of the expressions as descendants as we want the new
+      // variable to be visible to all uses.
+      for (auto I = InsertionCandidateStack.rbegin(),
+                E = InsertionCandidateStack.rend();
+           I != E; ++I) {
+        if (StmtReachabilityChecker::areAllExpressionsReachableFrom(
+                I->first, Expressions) &&
+            I->second) {
+          Loc = I->second->getLocStart();
+          break;
+        }
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+} // end anonymous namespace
+
+SourceLocation tooling::extract::locationForExtractedVariableDeclaration(
+    ArrayRef<const Expr *> Expressions, const Decl *ParentDecl,
+    const SourceManager &SM) {
+  ExtractedVariableInsertionLocFinder LocFinder(Expressions);
+  LocFinder.TraverseDecl(const_cast<Decl *>(ParentDecl));
+  SourceLocation Result = LocFinder.Loc;
+  if (Result.isValid() && Result.isMacroID())
+    return SM.getExpansionLoc(Result);
+  return Result;
+}
diff --git a/lib/Tooling/Refactor/ExtractionUtils.h b/lib/Tooling/Refactor/ExtractionUtils.h
index e69de29bb2..816a081510 100644
--- a/lib/Tooling/Refactor/ExtractionUtils.h
+++ b/lib/Tooling/Refactor/ExtractionUtils.h
@@ -0,0 +1,40 @@
+//===--- ExtractionUtils.h - Extraction helper functions ------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_EXTRACTION_UTILS_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_EXTRACTION_UTILS_H
+
+#include "clang/AST/Type.h"
+#include "clang/Basic/LLVM.h"
+
+namespace clang {
+
+class Expr;
+class Decl;
+class SourceManager;
+
+namespace tooling {
+namespace extract {
+
+/// Returns a good name for an extracted variable based on the declaration
+/// that's used in the given expression \p E.
+Optional<StringRef> nameForExtractedVariable(const Expr *E);
+
+/// Returns an appropriate location for a variable declaration that will be
+/// visible to all the given expressions.
+SourceLocation
+locationForExtractedVariableDeclaration(ArrayRef<const Expr *> Expressions,
+                                        const Decl *ParentDecl,
+                                        const SourceManager &SM);
+
+} // end namespace extract
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_EXTRACTION_UTILS_H
diff --git a/lib/Tooling/Refactor/FillInEnumSwitchCases.cpp b/lib/Tooling/Refactor/FillInEnumSwitchCases.cpp
index e69de29bb2..2cab0ee182 100644
--- a/lib/Tooling/Refactor/FillInEnumSwitchCases.cpp
+++ b/lib/Tooling/Refactor/FillInEnumSwitchCases.cpp
@@ -0,0 +1,110 @@
+//===--- FillInEnumSwitchCases.cpp -  -------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Add missing switch cases" refactoring operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringOperations.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/Edit/RefactoringFixits.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+class FillInEnumSwitchCasesOperation : public RefactoringOperation {
+public:
+  FillInEnumSwitchCasesOperation(const EnumDecl *Enum, const SwitchStmt *Switch,
+                                 const DeclContext *SwitchContext)
+      : Enum(Enum), Switch(Switch), SwitchContext(SwitchContext) {}
+
+  const Stmt *getTransformedStmt() const override { return Switch; }
+
+  llvm::Expected<RefactoringResult>
+  perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  const EnumDecl *Enum;
+  const SwitchStmt *Switch;
+  const DeclContext *SwitchContext;
+};
+
+} // end anonymous namespace
+
+RefactoringOperationResult
+clang::tooling::initiateFillInEnumSwitchCasesOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  const SwitchStmt *Switch;
+  const Decl *ParentDecl;
+  if (SelectionRange.isValid()) {
+    auto SelectedSet = Slice.getSelectedStmtSet();
+    if (!SelectedSet)
+      return None;
+    Switch = dyn_cast_or_null<SwitchStmt>(SelectedSet->containsSelectionRange);
+    // FIXME: Improve the interface for this to make it similar to SelectedStmt
+    if (SelectedSet->containsSelectionRange)
+      ParentDecl =
+          Slice.parentDeclForIndex(*SelectedSet->containsSelectionRangeIndex);
+  } else {
+    auto SelectedStmt = Slice.nearestSelectedStmt(Stmt::SwitchStmtClass);
+    if (!SelectedStmt)
+      return None;
+    Switch = cast<SwitchStmt>(SelectedStmt->getStmt());
+    ParentDecl = SelectedStmt->getParentDecl();
+  }
+  if (!Switch)
+    return None;
+
+  // Ensure that the type is an enum.
+  const Expr *Cond = Switch->getCond()->IgnoreImpCasts();
+  const EnumDecl *ED = nullptr;
+  if (const auto *ET = Cond->getType()->getAs<EnumType>())
+    ED = ET->getDecl();
+  else {
+    // Enum literals are 'int' in C.
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(Cond)) {
+      if (const auto *EC = dyn_cast<EnumConstantDecl>(DRE->getDecl()))
+        ED = dyn_cast<EnumDecl>(EC->getDeclContext());
+    }
+  }
+
+  if (!ED)
+    return RefactoringOperationResult("The switch doesn't operate on an enum");
+  if (!ED->isCompleteDefinition())
+    return RefactoringOperationResult("The enum type is incomplete");
+
+  if (Switch->isAllEnumCasesCovered())
+    return RefactoringOperationResult("All enum cases are already covered");
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (!CreateOperation)
+    return Result;
+  auto Operation = llvm::make_unique<FillInEnumSwitchCasesOperation>(
+      ED, Switch, dyn_cast<DeclContext>(ParentDecl));
+  Result.RefactoringOp = std::move(Operation);
+  return Result;
+}
+
+llvm::Expected<RefactoringResult>
+FillInEnumSwitchCasesOperation::perform(ASTContext &Context,
+                                        const Preprocessor &ThePreprocessor,
+                                        const RefactoringOptionSet &Options,
+                                        unsigned SelectedCandidateIndex) {
+  std::vector<RefactoringReplacement> Replacements;
+  edit::fillInMissingSwitchEnumCases(
+      Context, Switch, Enum, SwitchContext,
+      [&](const FixItHint &Hint) { Replacements.push_back(Hint); });
+  return std::move(Replacements);
+}
diff --git a/lib/Tooling/Refactor/FillInMissingMethodStubsFromAbstractClasses.cpp b/lib/Tooling/Refactor/FillInMissingMethodStubsFromAbstractClasses.cpp
index e69de29bb2..ba730f68a8 100644
--- a/lib/Tooling/Refactor/FillInMissingMethodStubsFromAbstractClasses.cpp
+++ b/lib/Tooling/Refactor/FillInMissingMethodStubsFromAbstractClasses.cpp
@@ -0,0 +1,293 @@
+//===--- FillInMissingMethodStubsFromAbstractClasses.cpp -  ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Add missing abstract class method overrides" refactoring
+// operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+#include "llvm/ADT/DenseSet.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+class FillInMissingMethodStubsFromAbstractClassesOperation
+    : public RefactoringOperation {
+public:
+  FillInMissingMethodStubsFromAbstractClassesOperation(
+      const CXXRecordDecl *Class)
+      : Class(Class) {}
+
+  const Decl *getTransformedDecl() const override { return Class; }
+
+  llvm::Expected<RefactoringResult> perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  const CXXRecordDecl *Class;
+};
+
+} // end anonymous namespace
+
+static bool hasAbstractBases(const CXXRecordDecl *Class) {
+  for (const CXXBaseSpecifier &Base : Class->bases()) {
+    if (const auto *RD = Base.getType()->getAsCXXRecordDecl()) {
+      if (RD->isAbstract())
+        return true;
+    }
+  }
+  return false;
+}
+
+RefactoringOperationResult
+clang::tooling::initiateFillInMissingMethodStubsFromAbstractClassesOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  auto SelectedDecl = Slice.innermostSelectedDecl(
+      llvm::makeArrayRef(Decl::CXXRecord), ASTSlice::InnermostDeclOnly);
+  if (!SelectedDecl)
+    return None;
+  const auto *Class = cast<CXXRecordDecl>(SelectedDecl->getDecl());
+  if (Class->isUnion() || !Class->isThisDeclarationADefinition())
+    return None;
+  if (!hasAbstractBases(Class))
+    return RefactoringOperationResult("The class has no abstract bases");
+  if (!Class->isDependentType() && !Class->isAbstract())
+    return RefactoringOperationResult(
+        "The class has no missing abstract class methods");
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (!CreateOperation)
+    return Result;
+  auto Operation =
+      llvm::make_unique<FillInMissingMethodStubsFromAbstractClassesOperation>(
+          Class);
+  Result.RefactoringOp = std::move(Operation);
+  return Result;
+}
+
+namespace {
+
+class PureMethodSet {
+  llvm::DenseMap<const CXXMethodDecl *, int> Methods;
+
+  void addPureMethodsFromAbstractClasses(const CXXRecordDecl *Class,
+                                         int &Priority) {
+    for (const CXXBaseSpecifier &Base : Class->bases()) {
+      const auto *RD = Base.getType()->getAsCXXRecordDecl();
+      if (!RD || !RD->isAbstract())
+        continue;
+      for (const CXXMethodDecl *M : RD->methods()) {
+        if (M->isPure())
+          Methods.insert(std::make_pair(M->getCanonicalDecl(), Priority++));
+      }
+      addPureMethodsFromAbstractClasses(RD, Priority);
+    }
+  }
+
+  void addPureMethodsFromAbstractClasses(const CXXRecordDecl *Class) {
+    int Priority = 0;
+    addPureMethodsFromAbstractClasses(Class, Priority);
+  }
+
+  void subtractImplementedPureMethods(const CXXRecordDecl *Class) {
+    for (const CXXMethodDecl *M : Class->methods()) {
+      if (!M->isVirtual() || M->isPure())
+        continue;
+      for (const CXXMethodDecl *OM : M->overridden_methods()) {
+        OM = OM->getCanonicalDecl();
+        if (OM->isPure())
+          Methods.erase(OM);
+      }
+    }
+    for (const CXXBaseSpecifier &Base : Class->bases()) {
+      const auto *RD = Base.getType()->getAsCXXRecordDecl();
+      if (!RD || !RD->isAbstract())
+        continue;
+      subtractImplementedPureMethods(RD);
+    }
+  }
+
+public:
+  static std::vector<const CXXMethodDecl *>
+  gatherMissingMethods(const CXXRecordDecl *Class) {
+    PureMethodSet MethodSet;
+    MethodSet.addPureMethodsFromAbstractClasses(Class);
+    MethodSet.subtractImplementedPureMethods(Class);
+    // Sort the missing methods. That will place methods from the same abstract
+    // class together in the order in which they were declared.
+    struct MethodInfo {
+      const CXXMethodDecl *M;
+      int Priority;
+    };
+    std::vector<MethodInfo> MissingMethods;
+    for (const auto &M : MethodSet.Methods)
+      MissingMethods.push_back({M.first, M.second});
+    std::sort(MissingMethods.begin(), MissingMethods.end(),
+              [](const MethodInfo &LHS, const MethodInfo &RHS) {
+                return LHS.Priority < RHS.Priority;
+              });
+    std::vector<const CXXMethodDecl *> Result;
+    Result.reserve(MissingMethods.size());
+    for (const auto &M : MissingMethods)
+      Result.push_back(M.M);
+    return Result;
+  }
+};
+
+} // end anonymous namespace
+
+static SourceLocation findInsertionLocationForMethodsFromAbstractClass(
+    const CXXRecordDecl *AbstractClass, const CXXRecordDecl *Class,
+    const SourceManager &SM, const LangOptions &LangOpts) {
+  SourceLocation Loc;
+  for (const CXXMethodDecl *M : Class->methods()) {
+    if (!M->isVirtual() || M->isPure() || M->isImplicit())
+      continue;
+    for (const CXXMethodDecl *OM : M->overridden_methods()) {
+      OM = OM->getCanonicalDecl();
+      if (OM->getLexicalDeclContext() == AbstractClass) {
+        SourceLocation EndLoc = M->getLocEnd();
+        if (EndLoc.isMacroID())
+          EndLoc = SM.getExpansionRange(EndLoc).second;
+        if (Loc.isInvalid())
+          Loc = EndLoc;
+        else if (SM.isBeforeInTranslationUnit(Loc, EndLoc))
+          Loc = EndLoc;
+        break;
+      }
+    }
+  }
+  if (Loc.isInvalid())
+    return Loc;
+  return getLastLineLocationUnlessItHasOtherTokens(Loc, SM, LangOpts);
+}
+
+/// Returns true if the given \p Class implements the majority of declared
+/// methods in the class itself.
+static bool shouldImplementMethodsInClass(const CXXRecordDecl *Class) {
+  // Check if this class implements the methods in the class itself.
+  unsigned NumMethods = 0, NumImplementedMethods = 0;
+  for (const CXXMethodDecl *M : Class->methods()) {
+    if (M->isImplicit())
+      continue;
+    // Only look at methods/operators.
+    if (isa<CXXConstructorDecl>(M) || isa<CXXDestructorDecl>(M))
+      continue;
+    ++NumMethods;
+    if (M->hasBody())
+      ++NumImplementedMethods;
+  }
+  if (!NumMethods)
+    return false;
+  // Use the following arbitrary heuristic:
+  // If the number of method declarations is less than 4, then all of the
+  // methods must have bodies. Otherwise, at least 75% of the methods must
+  // have bodies.
+  return NumMethods < 4
+             ? NumMethods == NumImplementedMethods
+             : float(NumImplementedMethods) / float(NumMethods) > 0.75;
+}
+
+llvm::Expected<RefactoringResult>
+FillInMissingMethodStubsFromAbstractClassesOperation::perform(
+    ASTContext &Context, const Preprocessor &ThePreprocessor,
+    const RefactoringOptionSet &Options, unsigned SelectedCandidateIndex) {
+  std::vector<RefactoringReplacement> Replacements;
+
+  std::vector<const CXXMethodDecl *> MissingMethods =
+      PureMethodSet::gatherMissingMethods(Class);
+
+  bool GenerateBodyDummies = shouldImplementMethodsInClass(Class);
+
+  PrintingPolicy PP = Context.getPrintingPolicy();
+  PP.PolishForDeclaration = true;
+  PP.SuppressStrongLifetime = true;
+  PP.SuppressLifetimeQualifiers = true;
+  PP.SuppressUnwrittenScope = true;
+
+  std::string EndInsertionOSStr;
+  llvm::raw_string_ostream EndInsertionOS(EndInsertionOSStr);
+
+  std::string InsertionGroupOSStr;
+  llvm::raw_string_ostream InsertionGroupOS(InsertionGroupOSStr);
+
+  SourceLocation InsertionLoc = Class->getLocEnd();
+  const CXXRecordDecl *CurrentAbstractClass = nullptr;
+  SourceLocation CurrentGroupInsertionLoc;
+  for (const auto &I : llvm::enumerate(MissingMethods)) {
+    const CXXMethodDecl *Method = I.value();
+    const CXXRecordDecl *AbstractClass = Method->getParent();
+    if (CurrentAbstractClass != AbstractClass) {
+      if (!InsertionGroupOS.str().empty()) {
+        assert(CurrentGroupInsertionLoc.isValid());
+        Replacements.emplace_back(
+            SourceRange(CurrentGroupInsertionLoc, CurrentGroupInsertionLoc),
+            InsertionGroupOS.str());
+      }
+      InsertionGroupOSStr.clear();
+      CurrentAbstractClass = AbstractClass;
+      CurrentGroupInsertionLoc =
+          findInsertionLocationForMethodsFromAbstractClass(
+              CurrentAbstractClass, Class, Context.getSourceManager(),
+              Context.getLangOpts());
+    }
+    bool IsInsertingAfterRelatedMethods = CurrentGroupInsertionLoc.isValid();
+    raw_ostream &OS =
+        IsInsertingAfterRelatedMethods ? InsertionGroupOS : EndInsertionOS;
+
+    if (IsInsertingAfterRelatedMethods && InsertionGroupOS.str().empty())
+      OS << "\n\n";
+    // Print the method without the 'virtual' specifier and the pure '= 0'
+    // annotation.
+    auto *MD = const_cast<CXXMethodDecl *>(Method);
+    bool IsVirtual = MD->isVirtualAsWritten();
+    MD->setVirtualAsWritten(false);
+    bool IsPure = MD->isPure();
+    MD->setPure(false);
+    MD->print(OS, PP);
+    MD->setVirtualAsWritten(IsVirtual);
+    MD->setPure(IsPure);
+
+    OS << " override";
+    if (GenerateBodyDummies)
+      OS << " { \n  <#code#>\n}\n";
+    else
+      OS << ";\n";
+    // Avoid an additional newline for the last method in an insertion group.
+    if (IsInsertingAfterRelatedMethods) {
+      const CXXRecordDecl *NextAbstractClass =
+          (I.index() + 1) != MissingMethods.size()
+              ? MissingMethods[I.index() + 1]->getParent()
+              : nullptr;
+      if (NextAbstractClass == CurrentAbstractClass)
+        OS << "\n";
+    } else
+      OS << "\n";
+  }
+  if (!InsertionGroupOS.str().empty()) {
+    assert(CurrentGroupInsertionLoc.isValid());
+    Replacements.emplace_back(
+        SourceRange(CurrentGroupInsertionLoc, CurrentGroupInsertionLoc),
+        InsertionGroupOS.str());
+  }
+  if (!EndInsertionOS.str().empty())
+    Replacements.emplace_back(SourceRange(InsertionLoc, InsertionLoc),
+                              EndInsertionOS.str());
+
+  return std::move(Replacements);
+}
diff --git a/lib/Tooling/Refactor/FillInMissingProtocolStubs.cpp b/lib/Tooling/Refactor/FillInMissingProtocolStubs.cpp
index e69de29bb2..de8cfbe4ce 100644
--- a/lib/Tooling/Refactor/FillInMissingProtocolStubs.cpp
+++ b/lib/Tooling/Refactor/FillInMissingProtocolStubs.cpp
@@ -0,0 +1,91 @@
+//===--- FillInMissingProtocolStubs.cpp -  --------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Add methods from protocol(s)" refactoring operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringOperations.h"
+#include "clang/AST/AST.h"
+#include "clang/Edit/RefactoringFixits.h"
+
+using namespace clang;
+using namespace clang::tooling;
+using namespace edit::fillInMissingProtocolStubs;
+
+namespace {
+
+class FillInMissingProtocolStubsOperation : public RefactoringOperation {
+public:
+  FillInMissingProtocolStubsOperation(const ObjCContainerDecl *Container,
+                                      FillInMissingProtocolStubs Impl)
+      : Container(Container), Impl(std::move(Impl)) {}
+
+  const Decl *getTransformedDecl() const override { return Container; }
+
+  llvm::Expected<RefactoringResult> perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  const ObjCContainerDecl *Container;
+  FillInMissingProtocolStubs Impl;
+};
+
+} // end anonymous namespace
+
+RefactoringOperationResult
+clang::tooling::initiateFillInMissingProtocolStubsOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  auto SelectedDecl = Slice.innermostSelectedDecl(
+      {Decl::ObjCImplementation, Decl::ObjCCategoryImpl, Decl::ObjCInterface,
+       Decl::ObjCCategory},
+      ASTSlice::InnermostDeclOnly);
+  if (!SelectedDecl)
+    return None;
+  const auto *Container = cast<ObjCContainerDecl>(SelectedDecl->getDecl());
+
+  // If this in a class extension, initiate the operation on the @implementation
+  // if it's in the same TU.
+  if (const auto *Category = dyn_cast<ObjCCategoryDecl>(Container)) {
+    if (Category->IsClassExtension()) {
+      const ObjCInterfaceDecl *I = Category->getClassInterface();
+      if (I && I->getImplementation())
+        Container = I->getImplementation();
+      else
+        return RefactoringOperationResult(
+            "Class extension without suitable @implementation");
+    }
+  }
+
+  FillInMissingProtocolStubs Impl;
+  if (Impl.initiate(Context, Container))
+    return None;
+  if (!Impl.hasMissingRequiredMethodStubs())
+    return RefactoringOperationResult("All of the @required methods are there");
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (!CreateOperation)
+    return Result;
+  auto Operation = llvm::make_unique<FillInMissingProtocolStubsOperation>(
+      Container, std::move(Impl));
+  Result.RefactoringOp = std::move(Operation);
+  return Result;
+}
+
+llvm::Expected<RefactoringResult>
+FillInMissingProtocolStubsOperation::perform(
+    ASTContext &Context, const Preprocessor &ThePreprocessor,
+    const RefactoringOptionSet &Options, unsigned SelectedCandidateIndex) {
+  std::vector<RefactoringReplacement> Replacements;
+  Impl.perform(Context,
+               [&](const FixItHint &Hint) { Replacements.push_back(Hint); });
+  return std::move(Replacements);
+}
diff --git a/lib/Tooling/Refactor/IfSwitchConversion.cpp b/lib/Tooling/Refactor/IfSwitchConversion.cpp
index e69de29bb2..5ce3955287 100644
--- a/lib/Tooling/Refactor/IfSwitchConversion.cpp
+++ b/lib/Tooling/Refactor/IfSwitchConversion.cpp
@@ -0,0 +1,468 @@
+//===--- IfSwitchConversion.cpp -  ----------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "convert to switch" refactoring operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+class IfSwitchConversionOperation : public RefactoringOperation {
+public:
+  IfSwitchConversionOperation(const IfStmt *If) : If(If) {}
+
+  const Stmt *getTransformedStmt() const override { return If; }
+
+  llvm::Expected<RefactoringResult> perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  const IfStmt *If;
+};
+
+class ValidIfBodyVerifier : public RecursiveASTVisitor<ValidIfBodyVerifier> {
+  bool CheckBreaks = true;
+
+public:
+  bool IsValid = true;
+
+  bool VisitBreakStmt(const BreakStmt *S) {
+    if (!CheckBreaks)
+      return true;
+    IsValid = false;
+    return false;
+  }
+  bool VisitDefaultStmt(const DefaultStmt *S) {
+    IsValid = false;
+    return false;
+  }
+  bool VisitCaseStmt(const CaseStmt *S) {
+    IsValid = false;
+    return false;
+  }
+
+// Handle nested loops:
+
+#define TRAVERSE_LOOP(STMT)                                                    \
+  bool Traverse##STMT(STMT *S) {                                               \
+    bool Prev = CheckBreaks;                                                   \
+    CheckBreaks = false;                                                       \
+    RecursiveASTVisitor::Traverse##STMT(S);                                    \
+    CheckBreaks = Prev;                                                        \
+    return true;                                                               \
+  }
+
+  TRAVERSE_LOOP(ForStmt)
+  TRAVERSE_LOOP(WhileStmt)
+  TRAVERSE_LOOP(DoStmt)
+  TRAVERSE_LOOP(CXXForRangeStmt)
+  TRAVERSE_LOOP(ObjCForCollectionStmt)
+
+#undef TRAVERSE_LOOP
+
+  // Handle switches:
+
+  bool TraverseSwitchStmt(SwitchStmt *S) {
+    // Don't visit the body as 'break'/'case'/'default' are all allowed inside
+    // switches.
+    return true;
+  }
+};
+
+} // end anonymous namespace
+
+/// Returns true if any of the if statements in the given if construct have
+/// conditions that aren't allowed by the "convert to switch" operation.
+static bool checkIfsHaveConditionExpression(const IfStmt *If) {
+  for (; If; If = dyn_cast_or_null<IfStmt>(If->getElse())) {
+    if (If->getConditionVariable() || If->getInit() || !If->getCond())
+      return true;
+  }
+  return false;
+}
+
+static Optional<std::pair<const Expr *, const Expr *>>
+matchBinOp(const Expr *E, BinaryOperator::Opcode Kind) {
+  const auto *BinOp = dyn_cast<BinaryOperator>(E->IgnoreParens());
+  if (!BinOp || BinOp->getOpcode() != Kind)
+    return None;
+  return std::pair<const Expr *, const Expr *>(
+      BinOp->getLHS()->IgnoreParenImpCasts(), BinOp->getRHS()->IgnoreParens());
+}
+
+typedef llvm::SmallDenseSet<int64_t, 4> RHSValueSet;
+
+/// Returns true if the conditional expression of an 'if' statement allows
+/// the "convert to switch" refactoring action.
+static bool isConditionValid(const Expr *E, ASTContext &Context,
+                             Optional<llvm::FoldingSetNodeID> &MatchedLHSNodeID,
+                             RHSValueSet &RHSValues) {
+  auto Equals = matchBinOp(E, BO_EQ);
+  if (!Equals.hasValue()) {
+    auto LogicalOr = matchBinOp(E, BO_LOr);
+    if (!LogicalOr.hasValue())
+      return false;
+    return isConditionValid(LogicalOr.getValue().first, Context,
+                            MatchedLHSNodeID, RHSValues) &&
+           isConditionValid(LogicalOr.getValue().second, Context,
+                            MatchedLHSNodeID, RHSValues);
+  }
+  const Expr *LHS = Equals.getValue().first;
+  const Expr *RHS = Equals.getValue().second;
+  if (!LHS->getType()->isIntegralOrEnumerationType() ||
+      !RHS->getType()->isIntegralOrEnumerationType())
+    return false;
+
+  // RHS must be a constant and unique.
+  llvm::APSInt Value;
+  if (!RHS->EvaluateAsInt(Value, Context))
+    return false;
+  // Only allow constant that fix into 64 bits.
+  if (Value.getMinSignedBits() > 64 ||
+      !RHSValues.insert(Value.getExtValue()).second)
+    return false;
+
+  // LHS must be identical to the other LHS expressions.
+  llvm::FoldingSetNodeID LHSNodeID;
+  LHS->Profile(LHSNodeID, Context, /*Canonical=*/false);
+  if (MatchedLHSNodeID.hasValue()) {
+    if (MatchedLHSNodeID.getValue() != LHSNodeID)
+      return false;
+  } else
+    MatchedLHSNodeID = std::move(LHSNodeID);
+  return true;
+}
+
+RefactoringOperationResult clang::tooling::initiateIfSwitchConversionOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  // FIXME: Add support for selections.
+  const auto *If = cast_or_null<IfStmt>(Slice.nearestStmt(Stmt::IfStmtClass));
+  if (!If)
+    return None;
+
+  // Don't allow if statements without any 'else' or 'else if'.
+  if (!If->getElse())
+    return None;
+
+  // Don't allow ifs with variable declarations in conditions or C++17
+  // initializer statements.
+  if (checkIfsHaveConditionExpression(If))
+    return None;
+
+  // Find the ranges in which initiation can be performed and verify that the
+  // ifs don't have any initialization expressions or condition variables.
+  SmallVector<SourceRange, 4> Ranges;
+  SourceLocation RangeStart = If->getLocStart();
+  const IfStmt *CurrentIf = If;
+  const SourceManager &SM = Context.getSourceManager();
+  while (true) {
+    const Stmt *Then = CurrentIf->getThen();
+    Ranges.emplace_back(RangeStart,
+                        findLastLocationOfSourceConstruct(
+                            CurrentIf->getCond()->getLocEnd(), Then, SM));
+    const auto *Else = CurrentIf->getElse();
+    if (!Else)
+      break;
+    RangeStart =
+        findFirstLocationOfSourceConstruct(CurrentIf->getElseLoc(), Then, SM);
+    if (const auto *If = dyn_cast<IfStmt>(Else)) {
+      CurrentIf = If;
+      continue;
+    }
+    Ranges.emplace_back(RangeStart, findLastLocationOfSourceConstruct(
+                                        CurrentIf->getElseLoc(), Else, SM));
+    break;
+  }
+
+  if (!isLocationInAnyRange(Location, Ranges, SM))
+    return None;
+
+  // Verify that the bodies don't have any 'break'/'default'/'case' statements.
+  ValidIfBodyVerifier BodyVerifier;
+  BodyVerifier.TraverseStmt(const_cast<IfStmt *>(If));
+  if (!BodyVerifier.IsValid)
+    return RefactoringOperationResult(
+        "if's body contains a 'break'/'default'/'case' statement");
+
+  // FIXME: Use ASTMatchers if possible.
+  Optional<llvm::FoldingSetNodeID> MatchedLHSNodeID;
+  RHSValueSet RHSValues;
+  for (const IfStmt *CurrentIf = If; CurrentIf;
+       CurrentIf = dyn_cast_or_null<IfStmt>(CurrentIf->getElse())) {
+    if (!isConditionValid(CurrentIf->getCond(), Context, MatchedLHSNodeID,
+                          RHSValues))
+      return RefactoringOperationResult("unsupported conditional expression");
+  }
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (CreateOperation)
+    Result.RefactoringOp.reset(new IfSwitchConversionOperation(If));
+  return Result;
+}
+
+/// Returns the first LHS expression in the if's condition.
+const Expr *getConditionFirstLHS(const Expr *E) {
+  auto Equals = matchBinOp(E, BO_EQ);
+  if (!Equals.hasValue()) {
+    auto LogicalOr = matchBinOp(E, BO_LOr);
+    if (!LogicalOr.hasValue())
+      return nullptr;
+    return getConditionFirstLHS(LogicalOr.getValue().first);
+  }
+  return Equals.getValue().first;
+}
+
+/// Gathers all of the RHS operands of the == expressions in the if's condition.
+void gatherCaseValues(const Expr *E,
+                      SmallVectorImpl<const Expr *> &CaseValues) {
+  auto Equals = matchBinOp(E, BO_EQ);
+  if (Equals.hasValue()) {
+    CaseValues.push_back(Equals.getValue().second);
+    return;
+  }
+  auto LogicalOr = matchBinOp(E, BO_LOr);
+  if (!LogicalOr.hasValue())
+    return;
+  gatherCaseValues(LogicalOr.getValue().first, CaseValues);
+  gatherCaseValues(LogicalOr.getValue().second, CaseValues);
+}
+
+/// Return true iff the given body should be terminated with a 'break' statement
+/// when used inside of a switch.
+static bool isBreakNeeded(const Stmt *Body) {
+  const auto *CS = dyn_cast<CompoundStmt>(Body);
+  if (!CS)
+    return !isa<ReturnStmt>(Body);
+  return CS->body_empty() ? true : isBreakNeeded(CS->body_back());
+}
+
+/// Returns true if the given statement declares a variable.
+static bool isVarDeclaringStatement(const Stmt *S) {
+  const auto *DS = dyn_cast<DeclStmt>(S);
+  if (!DS)
+    return false;
+  for (const Decl *D : DS->decls()) {
+    if (isa<VarDecl>(D))
+      return true;
+  }
+  return false;
+}
+
+/// Return true if the body of an if/else if/else needs to be wrapped in braces
+/// when put in a switch.
+static bool areBracesNeeded(const Stmt *Body) {
+  const auto *CS = dyn_cast<CompoundStmt>(Body);
+  if (!CS)
+    return isVarDeclaringStatement(Body);
+  for (const Stmt *S : CS->body()) {
+    if (isVarDeclaringStatement(S))
+      return true;
+  }
+  return false;
+}
+
+namespace {
+
+/// Information about the replacement that replaces 'if'/'else' with a 'case' or
+/// a 'default'.
+struct CasePlacement {
+  /// The location of the 'case' or 'default'.
+  SourceLocation CaseStartLoc;
+  /// True when this 'case' or 'default' statement needs a newline.
+  bool NeedsNewLine;
+  /// True if this the first 'if' in the source construct.
+  bool IsFirstIf;
+  /// True if we need to insert a 'break' to terminate the previous body
+  /// before the 'case' or 'default'.
+  bool IsBreakNeeded;
+  /// True if we need to insert a '}' before the case.
+  bool ArePreviousBracesNeeded;
+
+  CasePlacement(SourceLocation Loc)
+      : CaseStartLoc(Loc), NeedsNewLine(false), IsFirstIf(true),
+        IsBreakNeeded(false), ArePreviousBracesNeeded(false) {}
+
+  CasePlacement(const IfStmt *If, const SourceManager &SM,
+                bool AreBracesNeeded) {
+    CaseStartLoc = SM.getSpellingLoc(isa<CompoundStmt>(If->getThen())
+                                         ? If->getThen()->getLocEnd()
+                                         : If->getElseLoc());
+    SourceLocation BodyEndLoc = findLastNonCompoundLocation(If->getThen());
+    NeedsNewLine = BodyEndLoc.isValid()
+                       ? areOnSameLine(CaseStartLoc, BodyEndLoc, SM)
+                       : false;
+    IsFirstIf = false;
+    IsBreakNeeded = isBreakNeeded(If->getThen());
+    ArePreviousBracesNeeded = AreBracesNeeded;
+  }
+
+  std::string getCaseReplacementString(bool IsDefault = false,
+                                       bool AreNextBracesNeeded = false) const {
+    if (IsFirstIf)
+      return ") {\ncase ";
+    std::string Result;
+    llvm::raw_string_ostream OS(Result);
+    if (NeedsNewLine)
+      OS << '\n';
+    if (IsBreakNeeded)
+      OS << "break;\n";
+    if (ArePreviousBracesNeeded)
+      OS << "}\n";
+    OS << (IsDefault ? "default:" : "case ");
+    if (IsDefault && AreNextBracesNeeded)
+      OS << " {";
+    return std::move(OS.str());
+  }
+};
+
+} // end anonymous namespace
+
+static llvm::Error
+addCaseReplacements(const IfStmt *If, const CasePlacement &CaseInfo,
+                    bool &AreBracesNeeded,
+                    std::vector<RefactoringReplacement> &Replacements,
+                    const SourceManager &SM, const LangOptions &LangOpts) {
+  SmallVector<const Expr *, 2> CaseValues;
+  gatherCaseValues(If->getCond(), CaseValues);
+  assert(!CaseValues.empty());
+  Replacements.emplace_back(
+      SourceRange(CaseInfo.CaseStartLoc,
+                  SM.getSpellingLoc(CaseValues[0]->getLocStart())),
+      CaseInfo.getCaseReplacementString());
+
+  SourceLocation PrevCaseEnd = getPreciseTokenLocEnd(
+      SM.getSpellingLoc(CaseValues[0]->getLocEnd()), SM, LangOpts);
+  for (const Expr *CaseValue : llvm::makeArrayRef(CaseValues).drop_front()) {
+    Replacements.emplace_back(
+        SourceRange(PrevCaseEnd, SM.getSpellingLoc(CaseValue->getLocStart())),
+        StringRef(":\ncase "));
+    PrevCaseEnd = getPreciseTokenLocEnd(
+        SM.getSpellingLoc(CaseValue->getLocEnd()), SM, LangOpts);
+  }
+
+  AreBracesNeeded = areBracesNeeded(If->getThen());
+  StringRef ColonReplacement = AreBracesNeeded ? ": {" : ":";
+  if (isa<CompoundStmt>(If->getThen())) {
+    Replacements.emplace_back(
+        SourceRange(
+            PrevCaseEnd,
+            getPreciseTokenLocEnd(
+                SM.getSpellingLoc(If->getThen()->getLocStart()), SM, LangOpts)),
+        ColonReplacement);
+  } else {
+    // Find the location of the if's ')'
+    SourceLocation End = findClosingParenLocEnd(
+        SM.getSpellingLoc(If->getCond()->getLocEnd()), SM, LangOpts);
+    if (!End.isValid())
+      return llvm::make_error<RefactoringOperationError>(
+          "couldn't find the location of ')'");
+    Replacements.emplace_back(SourceRange(PrevCaseEnd, End), ColonReplacement);
+  }
+  return llvm::Error::success();
+}
+
+llvm::Expected<RefactoringResult>
+IfSwitchConversionOperation::perform(ASTContext &Context,
+                                     const Preprocessor &ThePreprocessor,
+                                     const RefactoringOptionSet &Options,
+                                     unsigned SelectedCandidateIndex) {
+  std::vector<RefactoringReplacement> Replacements;
+  const SourceManager &SM = Context.getSourceManager();
+  const LangOptions &LangOpts = Context.getLangOpts();
+
+  // The first if should be replaced with a 'switch' and the text for first LHS
+  // should be preserved.
+  const Expr *LHS = getConditionFirstLHS(If->getCond());
+  assert(LHS && "Missing == expression");
+  Replacements.emplace_back(SourceRange(SM.getSpellingLoc(If->getLocStart()),
+                                        SM.getSpellingLoc(LHS->getLocStart())),
+                            StringRef("switch ("));
+
+  bool AreBracesNeeded = false;
+  if (auto Error = addCaseReplacements(
+          If, CasePlacement(getPreciseTokenLocEnd(
+                  SM.getSpellingLoc(LHS->getLocEnd()), SM, LangOpts)),
+          AreBracesNeeded, Replacements, SM, LangOpts))
+    return std::move(Error);
+
+  // Convert the remaining ifs to 'case' statements.
+  const IfStmt *CurrentIf = If;
+  while (true) {
+    const IfStmt *NextIf = dyn_cast_or_null<IfStmt>(CurrentIf->getElse());
+    if (!NextIf)
+      break;
+    if (auto Error = addCaseReplacements(
+            NextIf, CasePlacement(CurrentIf, SM, AreBracesNeeded),
+            AreBracesNeeded, Replacements, SM, LangOpts))
+      return std::move(Error);
+    CurrentIf = NextIf;
+  }
+
+  // Convert the 'else' to 'default'
+  if (const Stmt *Else = CurrentIf->getElse()) {
+    CasePlacement DefaultInfo(CurrentIf, SM, AreBracesNeeded);
+    AreBracesNeeded = areBracesNeeded(Else);
+
+    SourceLocation EndLoc = getPreciseTokenLocEnd(
+        SM.getSpellingLoc(isa<CompoundStmt>(Else) ? Else->getLocStart()
+                                                  : CurrentIf->getElseLoc()),
+        SM, LangOpts);
+    Replacements.emplace_back(SourceRange(DefaultInfo.CaseStartLoc, EndLoc),
+                              DefaultInfo.getCaseReplacementString(
+                                  /*IsDefault=*/true, AreBracesNeeded));
+  }
+
+  // Add the trailing break and one or two '}' if needed.
+  const Stmt *LastBody =
+      CurrentIf->getElse() ? CurrentIf->getElse() : CurrentIf->getThen();
+  bool IsLastBreakNeeded = isBreakNeeded(LastBody);
+  SourceLocation TerminatingReplacementLoc;
+  std::string TerminatingReplacement;
+  llvm::raw_string_ostream OS(TerminatingReplacement);
+  if (!isa<CompoundStmt>(LastBody)) {
+    TerminatingReplacementLoc = LastBody->getLocEnd();
+    // Try to adjust the location in order to preserve any trailing comments on
+    // the last line of the last body.
+    if (!TerminatingReplacementLoc.isMacroID())
+      TerminatingReplacementLoc = getLastLineLocationUnlessItHasOtherTokens(
+          TerminatingReplacementLoc, SM, LangOpts);
+    if (IsLastBreakNeeded)
+      OS << "\nbreak;";
+    OS << "\n}";
+    if (AreBracesNeeded)
+      OS << "\n}";
+  } else {
+    TerminatingReplacementLoc = LastBody->getLocEnd();
+    if (IsLastBreakNeeded)
+      OS << "break;\n";
+    if (AreBracesNeeded)
+      OS << "}\n";
+  }
+
+  if (!OS.str().empty()) {
+    TerminatingReplacementLoc = SM.getSpellingLoc(TerminatingReplacementLoc);
+    Replacements.emplace_back(
+        SourceRange(TerminatingReplacementLoc, TerminatingReplacementLoc),
+        std::move(OS.str()));
+  }
+
+  return std::move(Replacements);
+}
diff --git a/lib/Tooling/Refactor/ImplementDeclaredMethods.cpp b/lib/Tooling/Refactor/ImplementDeclaredMethods.cpp
index e69de29bb2..c5865e468a 100644
--- a/lib/Tooling/Refactor/ImplementDeclaredMethods.cpp
+++ b/lib/Tooling/Refactor/ImplementDeclaredMethods.cpp
@@ -0,0 +1,446 @@
+//===--- ImplementDeclaredMethods.cpp -  ----------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Generate missing method definitions" refactoring
+// operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringContinuations.h"
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+template <typename ClassType, typename MethodType, typename Derived>
+class ImplementDeclaredMethodsOperation : public RefactoringOperation {
+public:
+  ImplementDeclaredMethodsOperation(
+      const ClassType *Container, ArrayRef<const MethodType *> SelectedMethods)
+      : Container(Container),
+        SelectedMethods(SelectedMethods.begin(), SelectedMethods.end()) {}
+
+  const Decl *getTransformedDecl() const override {
+    return SelectedMethods.front();
+  }
+
+  const Decl *getLastTransformedDecl() const override {
+    return SelectedMethods.back();
+  }
+
+  static RefactoringOperationResult
+  initiate(const ClassType *Container, ArrayRef<const MethodType *> Methods,
+           bool CreateOperation) {
+    if (Methods.empty())
+      return None;
+
+    RefactoringOperationResult Result;
+    Result.Initiated = true;
+    if (!CreateOperation)
+      return Result;
+    auto Operation = llvm::make_unique<Derived>(Container, Methods);
+    Result.RefactoringOp = std::move(Operation);
+    return Result;
+  }
+
+  const ClassType *Container;
+  llvm::SmallVector<const MethodType *, 8> SelectedMethods;
+};
+
+class ImplementDeclaredCXXMethodsOperation
+    : public ImplementDeclaredMethodsOperation<
+          CXXRecordDecl, CXXMethodDecl, ImplementDeclaredCXXMethodsOperation> {
+public:
+  ImplementDeclaredCXXMethodsOperation(
+      const CXXRecordDecl *Container,
+      ArrayRef<const CXXMethodDecl *> SelectedMethods)
+      : ImplementDeclaredMethodsOperation(Container, SelectedMethods) {}
+
+  llvm::Expected<RefactoringResult>
+  perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  static void addInlineBody(const CXXMethodDecl *MD, const ASTContext &Context,
+                            std::vector<RefactoringReplacement> &Replacements);
+
+  static llvm::Expected<RefactoringResult> runInImplementationAST(
+      ASTContext &Context, const FileID &File, const CXXRecordDecl *Class,
+      ArrayRef<indexer::Indexed<const CXXMethodDecl *>> SelectedMethods);
+};
+
+class ImplementDeclaredObjCMethodsOperation
+    : public ImplementDeclaredMethodsOperation<
+          ObjCContainerDecl, ObjCMethodDecl,
+          ImplementDeclaredObjCMethodsOperation> {
+  const ObjCInterfaceDecl *Interface;
+
+public:
+  ImplementDeclaredObjCMethodsOperation(
+      const ObjCContainerDecl *Container,
+      ArrayRef<const ObjCMethodDecl *> SelectedMethods)
+      : ImplementDeclaredMethodsOperation(Container, SelectedMethods) {
+    if (const auto *CD = dyn_cast<ObjCCategoryDecl>(Container))
+      Interface = CD->getClassInterface();
+    else
+      Interface = nullptr;
+  }
+
+  llvm::Expected<RefactoringResult>
+  perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  static llvm::Expected<RefactoringResult> runInImplementationAST(
+      ASTContext &Context, const FileID &File,
+      const ObjCContainerDecl *Container, const ObjCInterfaceDecl *Interface,
+      ArrayRef<std::string> MethodDeclarations,
+      ArrayRef<indexer::Indexed<const ObjCMethodDecl *>> SelectedMethods);
+};
+
+/// Returns true if the given Objective-C method has an implementation.
+bool isImplemented(const ObjCMethodDecl *M) {
+  if (M->hasBody() || M->isDefined())
+    return true;
+  return false;
+}
+
+} // end anonymous namespace
+
+RefactoringOperationResult
+clang::tooling::initiateImplementDeclaredMethodsOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  // Find the selected Class.
+  auto SelectedDecl = Slice.innermostSelectedDecl([](const Decl *D) {
+    return isa<CXXRecordDecl>(D) || isa<ObjCInterfaceDecl>(D) ||
+           isa<ObjCCategoryDecl>(D);
+  });
+  if (!SelectedDecl)
+    return None;
+  // Look at the set of methods that intersect with the selection.
+  if (const auto *CXXClass = dyn_cast<CXXRecordDecl>(SelectedDecl->getDecl())) {
+    if (CXXClass->isDependentType())
+      return RefactoringOperationResult("templates are unsupported");
+    llvm::SmallVector<const CXXMethodDecl *, 8> SelectedMethods;
+    for (const CXXMethodDecl *M : CXXClass->methods()) {
+      if (M->isImplicit() || M->hasBody() || M->isPure() || M->isDefaulted() ||
+          M->isDeletedAsWritten() || M->getDescribedFunctionTemplate())
+        continue;
+      if (Slice.isSourceRangeSelected(
+              CharSourceRange::getTokenRange(M->getSourceRange())))
+        SelectedMethods.push_back(M);
+    }
+    return ImplementDeclaredCXXMethodsOperation::initiate(
+        CXXClass, SelectedMethods, CreateOperation);
+  }
+  const ObjCContainerDecl *Container =
+      cast<ObjCContainerDecl>(SelectedDecl->getDecl());
+  llvm::SmallVector<const ObjCMethodDecl *, 8> SelectedMethods;
+  for (const ObjCMethodDecl *M : Container->methods()) {
+    if (M->isImplicit() || isImplemented(M))
+      continue;
+    if (Slice.isSourceRangeSelected(
+            CharSourceRange::getTokenRange(M->getSourceRange())))
+      SelectedMethods.push_back(M);
+  }
+  // Method declarations from class extensions should be defined in class
+  // @implementations.
+  if (const auto *Category = dyn_cast<ObjCCategoryDecl>(Container)) {
+    if (Category->IsClassExtension())
+      Container = Category->getClassInterface();
+  }
+  return ImplementDeclaredObjCMethodsOperation::initiate(
+      Container, SelectedMethods, CreateOperation);
+}
+
+llvm::Expected<RefactoringResult>
+ImplementDeclaredCXXMethodsOperation::perform(
+    ASTContext &Context, const Preprocessor &ThePreprocessor,
+    const RefactoringOptionSet &Options, unsigned SelectedCandidateIndex) {
+  if (Container->isLexicallyWithinFunctionOrMethod()) {
+    // Local methods can be implemented inline.
+    std::vector<RefactoringReplacement> Replacements;
+    for (const CXXMethodDecl *MD : SelectedMethods)
+      addInlineBody(MD, Context, Replacements);
+    return std::move(Replacements);
+  }
+  using namespace indexer;
+  return continueInExternalASTUnit(
+      fileThatShouldContainImplementationOf(Container), runInImplementationAST,
+      Container, filter(llvm::makeArrayRef(SelectedMethods),
+                        [](const DeclEntity &D) { return !D.isDefined(); }));
+}
+
+void ImplementDeclaredCXXMethodsOperation::addInlineBody(
+    const CXXMethodDecl *MD, const ASTContext &Context,
+    std::vector<RefactoringReplacement> &Replacements) {
+  SourceLocation EndLoc = MD->getLocEnd();
+  SourceRange SemiRange = getRangeOfNextToken(
+      EndLoc, tok::semi, Context.getSourceManager(), Context.getLangOpts());
+  if (SemiRange.isValid()) {
+    Replacements.push_back(RefactoringReplacement(SemiRange));
+    EndLoc = SemiRange.getEnd();
+  }
+  SourceLocation InsertionLoc = getLastLineLocationUnlessItHasOtherTokens(
+      EndLoc, Context.getSourceManager(), Context.getLangOpts());
+  Replacements.push_back(
+      RefactoringReplacement(SourceRange(InsertionLoc, InsertionLoc),
+                             StringRef(" { \n  <#code#>;\n}")));
+}
+
+static const RecordDecl *findOutermostRecord(const RecordDecl *RD) {
+  const RecordDecl *Result = RD;
+  for (const DeclContext *DC = Result->getLexicalDeclContext();
+       isa<RecordDecl>(DC); DC = Result->getLexicalDeclContext())
+    Result = cast<RecordDecl>(DC);
+  return Result;
+}
+
+static bool containsUsingOf(const NamespaceDecl *ND,
+                            const ASTContext &Context) {
+  for (const Decl *D : Context.getTranslationUnitDecl()->decls()) {
+    if (const auto *UDD = dyn_cast<UsingDirectiveDecl>(D)) {
+      if (UDD->getNominatedNamespace() == ND)
+        return true;
+    }
+  }
+  return false;
+}
+
+llvm::Expected<RefactoringResult>
+ImplementDeclaredCXXMethodsOperation::runInImplementationAST(
+    ASTContext &Context, const FileID &File, const CXXRecordDecl *Class,
+    ArrayRef<indexer::Indexed<const CXXMethodDecl *>> SelectedMethods) {
+  if (!Class)
+    return llvm::make_error<RefactoringOperationError>(
+        "the target class is not defined in the continuation AST unit");
+
+  SourceManager &SM = Context.getSourceManager();
+
+  // Find the defined methods of the class.
+  llvm::SmallVector<const CXXMethodDecl *, 8> DefinedOutOfLineMethods;
+  for (const CXXMethodDecl *M : Class->methods()) {
+    if (M->isImplicit())
+      continue;
+    if (const FunctionDecl *MD = M->getDefinition()) {
+      if (!MD->isOutOfLine())
+        continue;
+      SourceLocation Loc = SM.getExpansionLoc(MD->getLocStart());
+      if (SM.getFileID(Loc) == File)
+        DefinedOutOfLineMethods.push_back(cast<CXXMethodDecl>(MD));
+    }
+  }
+
+  std::vector<RefactoringReplacement> Replacements;
+  std::string MethodString;
+  llvm::raw_string_ostream OS(MethodString);
+
+  // Pick a good insertion location.
+  SourceLocation InsertionLoc;
+  const CXXMethodDecl *InsertAfterMethod = nullptr;
+  NestedNameSpecifier *NamePrefix = nullptr;
+  if (DefinedOutOfLineMethods.empty()) {
+    const RecordDecl *OutermostRecord = findOutermostRecord(Class);
+    InsertionLoc = SM.getExpansionRange(OutermostRecord->getLocEnd()).second;
+    if (SM.getFileID(InsertionLoc) == File) {
+      // We can insert right after the class. Compute the appropriate
+      // qualification.
+      NamePrefix = NestedNameSpecifier::getRequiredQualification(
+          Context, OutermostRecord->getLexicalDeclContext(),
+          Class->getLexicalDeclContext());
+    } else {
+      // We can't insert after the end of the class, since the indexer told us
+      // that some file should have the implementation of it, even when there
+      // are no methods here. We should try to insert at the end of the file.
+      InsertionLoc = SM.getLocForEndOfFile(File);
+      NamePrefix = NestedNameSpecifier::getRequiredQualification(
+          Context, Context.getTranslationUnitDecl(),
+          Class->getLexicalDeclContext());
+      llvm::SmallVector<const NamespaceDecl *, 4> Namespaces;
+      for (const NestedNameSpecifier *Qualifier = NamePrefix; Qualifier;
+           Qualifier = Qualifier->getPrefix()) {
+        if (const NamespaceDecl *ND = Qualifier->getAsNamespace())
+          Namespaces.push_back(ND);
+      }
+      // When the class is in a namespace, add a 'using' declaration if it's
+      // needed and adjust the out-of-line qualification.
+      if (!Namespaces.empty()) {
+        const NamespaceDecl *InnermostNamespace = Namespaces[0];
+        if (!containsUsingOf(InnermostNamespace, Context)) {
+          std::string NamespaceString;
+          llvm::raw_string_ostream NamespaceOS(NamespaceString);
+          for (const NamespaceDecl *ND : llvm::reverse(Namespaces)) {
+            if (!NamespaceOS.str().empty())
+              NamespaceOS << "::";
+            NamespaceOS << ND->getDeclName();
+          }
+          OS << "\nusing namespace " << NamespaceOS.str() << ";";
+        }
+        // Re-compute the name qualifier without the namespace.
+        NamePrefix = NestedNameSpecifier::getRequiredQualification(
+            Context, InnermostNamespace, Class->getLexicalDeclContext());
+      }
+    }
+  } else {
+    // Insert at the end of the defined methods.
+    for (const CXXMethodDecl *M : DefinedOutOfLineMethods) {
+      SourceLocation EndLoc = SM.getExpansionRange(M->getLocEnd()).second;
+      if (InsertionLoc.isInvalid() ||
+          SM.isBeforeInTranslationUnit(InsertionLoc, EndLoc)) {
+        InsertionLoc = EndLoc;
+        InsertAfterMethod = M;
+      }
+    }
+  }
+  InsertionLoc = getLastLineLocationUnlessItHasOtherTokens(
+      InsertionLoc, SM, Context.getLangOpts());
+
+  PrintingPolicy PP = Context.getPrintingPolicy();
+  PP.PolishForDeclaration = true;
+  PP.SupressStorageClassSpecifiers = true;
+  PP.SuppressStrongLifetime = true;
+  PP.SuppressLifetimeQualifiers = true;
+  PP.SuppressUnwrittenScope = true;
+  OS << "\n";
+  for (const auto &I : SelectedMethods) {
+    const CXXMethodDecl *MD = I.Decl;
+    // Check if the method is already defined.
+    if (!MD)
+      continue;
+
+    // Drop the 'virtual' specifier.
+    bool IsVirtual = MD->isVirtualAsWritten();
+    const_cast<CXXMethodDecl *>(MD)->setVirtualAsWritten(false);
+
+    // Drop the default arguments.
+    llvm::SmallVector<std::pair<ParmVarDecl *, Expr *>, 4> DefaultArgs;
+    for (const ParmVarDecl *P : MD->parameters()) {
+      if (!P->hasDefaultArg())
+        continue;
+      Expr *E = const_cast<ParmVarDecl *>(P)->getDefaultArg();
+      const_cast<ParmVarDecl *>(P)->setDefaultArg(nullptr);
+      DefaultArgs.emplace_back(const_cast<ParmVarDecl *>(P), E);
+    }
+
+    // Add the nested name specifiers that are appropriate for an out-of-line
+    // method.
+    auto *Qualifier =
+        InsertAfterMethod
+            ? InsertAfterMethod->getQualifier()
+            : NestedNameSpecifier::Create(
+                  Context, /*Prefix=*/NamePrefix, /*Template=*/false,
+                  Context.getRecordType(Class).getTypePtr());
+    NestedNameSpecifierLoc PrevQualifierInfo = MD->getQualifierLoc();
+    const_cast<CXXMethodDecl *>(MD)->setQualifierInfo(
+        NestedNameSpecifierLoc(Qualifier, /*Loc=*/nullptr));
+
+    OS << "\n";
+    MD->print(OS, PP);
+    OS << " { \n  <#code#>;\n}\n";
+
+    // Restore the original method
+    for (const auto &DefaultArg : DefaultArgs)
+      DefaultArg.first->setDefaultArg(DefaultArg.second);
+    const_cast<CXXMethodDecl *>(MD)->setVirtualAsWritten(IsVirtual);
+    const_cast<CXXMethodDecl *>(MD)->setQualifierInfo(PrevQualifierInfo);
+  }
+
+  Replacements.push_back(RefactoringReplacement(
+      SourceRange(InsertionLoc, InsertionLoc), std::move(OS.str())));
+
+  return std::move(Replacements);
+}
+
+llvm::Expected<RefactoringResult>
+ImplementDeclaredObjCMethodsOperation::perform(
+    ASTContext &Context, const Preprocessor &ThePreprocessor,
+    const RefactoringOptionSet &Options, unsigned SelectedCandidateIndex) {
+  using namespace indexer;
+
+  // Print the methods before running the continuation because the continuation
+  // TU might not have these method declarations (e.g. category implemented in
+  // the class implementation).
+  PrintingPolicy PP = Context.getPrintingPolicy();
+  PP.PolishForDeclaration = true;
+  PP.SuppressStrongLifetime = true;
+  PP.SuppressLifetimeQualifiers = true;
+  PP.SuppressUnwrittenScope = true;
+  std::vector<std::string> MethodDeclarations;
+  for (const ObjCMethodDecl *MD : SelectedMethods) {
+    std::string MethodDeclStr;
+    llvm::raw_string_ostream MethodOS(MethodDeclStr);
+    MD->print(MethodOS, PP);
+    MethodDeclarations.push_back(std::move(MethodOS.str()));
+  }
+
+  return continueInExternalASTUnit(
+      fileThatShouldContainImplementationOf(Container), runInImplementationAST,
+      Container, Interface, MethodDeclarations,
+      filter(llvm::makeArrayRef(SelectedMethods),
+             [](const DeclEntity &D) { return !D.isDefined(); }));
+}
+
+static const ObjCImplDecl *
+getImplementationContainer(const ObjCContainerDecl *Container,
+                           const ObjCInterfaceDecl *Interface = nullptr) {
+  if (!Container)
+    return Interface ? getImplementationContainer(Interface) : nullptr;
+  if (const auto *ID = dyn_cast<ObjCInterfaceDecl>(Container))
+    return ID->getImplementation();
+  if (const auto *CD = dyn_cast<ObjCCategoryDecl>(Container)) {
+    if (const auto *Impl = CD->getImplementation())
+      return Impl;
+    return getImplementationContainer(Interface);
+  }
+  return nullptr;
+}
+
+llvm::Expected<RefactoringResult>
+ImplementDeclaredObjCMethodsOperation::runInImplementationAST(
+    ASTContext &Context, const FileID &File, const ObjCContainerDecl *Container,
+    const ObjCInterfaceDecl *Interface,
+    ArrayRef<std::string> MethodDeclarations,
+    ArrayRef<indexer::Indexed<const ObjCMethodDecl *>> SelectedMethods) {
+  const ObjCImplDecl *ImplementationContainer =
+      getImplementationContainer(Container, Interface);
+  if (!ImplementationContainer)
+    return llvm::make_error<RefactoringOperationError>(
+        "the target @interface is not implemented in the continuation AST "
+        "unit");
+
+  std::vector<RefactoringReplacement> Replacements;
+
+  std::string MethodString;
+  llvm::raw_string_ostream OS(MethodString);
+
+  assert(MethodDeclarations.size() >= SelectedMethods.size() &&
+         "fewer declarations than selected methods?");
+  for (const auto &I : llvm::enumerate(SelectedMethods)) {
+    indexer::Indexed<const ObjCMethodDecl *> Decl = I.value();
+    // Skip methods that are already defined.
+    if (!Decl.isNotDefined())
+      continue;
+
+    OS << StringRef(MethodDeclarations[I.index()]).drop_back(); // Drop the ';'
+    OS << " { \n  <#code#>;\n}\n\n";
+  }
+  SourceLocation InsertionLoc = ImplementationContainer->getLocEnd();
+
+  Replacements.push_back(RefactoringReplacement(
+      SourceRange(InsertionLoc, InsertionLoc), std::move(OS.str())));
+
+  return std::move(Replacements);
+}
diff --git a/lib/Tooling/Refactor/IndexerQueries.cpp b/lib/Tooling/Refactor/IndexerQueries.cpp
index e69de29bb2..7a3a0903e1 100644
--- a/lib/Tooling/Refactor/IndexerQueries.cpp
+++ b/lib/Tooling/Refactor/IndexerQueries.cpp
@@ -0,0 +1,172 @@
+//===--- IndexerQueries.cpp - Indexer queries -----------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactoring/RefactoringDiagnostic.h"
+#include "clang/Tooling/Refactor/IndexerQuery.h"
+#include "llvm/Support/Errc.h"
+#include "llvm/Support/Error.h"
+#include "llvm/Support/YAMLTraits.h"
+
+using namespace clang;
+using namespace clang::tooling;
+using namespace clang::tooling::indexer;
+using namespace clang::tooling::indexer::detail;
+using namespace llvm::yaml;
+
+const char *ASTProducerQuery::BaseUIDString = "ast.producer.query";
+const char *DeclarationsQuery::BaseUIDString = "decl.query";
+const char *ASTUnitForImplementationOfDeclarationQuery::NameUIDString =
+    "file.for.impl.of.decl";
+
+const char *DeclPredicateNodePredicate::NameUIDString = "decl.predicate";
+const char *DeclPredicateNotPredicate::NameUIDString = "not.decl.predicate";
+
+std::unique_ptr<DeclPredicateNode>
+DeclPredicateNode::create(const DeclPredicate &Predicate) {
+  return llvm::make_unique<DeclPredicateNodePredicate>(Predicate);
+}
+
+std::unique_ptr<DeclPredicateNode>
+DeclPredicateNode::create(const BoolDeclPredicate &Predicate) {
+  if (Predicate.IsInverted)
+    return llvm::make_unique<DeclPredicateNotPredicate>(
+        create(Predicate.Predicate));
+  return create(Predicate.Predicate);
+}
+
+std::unique_ptr<ASTUnitForImplementationOfDeclarationQuery>
+clang::tooling::indexer::fileThatShouldContainImplementationOf(const Decl *D) {
+  return llvm::make_unique<ASTUnitForImplementationOfDeclarationQuery>(D);
+}
+
+bool ASTUnitForImplementationOfDeclarationQuery::verify(ASTContext &Context) {
+  if (!D) {
+    assert(false && "Query should be verified before persisting");
+    return false;
+  }
+  // Check if we've got the filename.
+  if (!Result.Filename.empty())
+    return false;
+  Context.getDiagnostics().Report(
+      D->getLocation(), diag::err_ref_continuation_missing_implementation)
+      << isa<ObjCContainerDecl>(D) << cast<NamedDecl>(D);
+  return true;
+}
+
+bool DeclarationsQuery::verify(ASTContext &Context) {
+  if (Input.empty()) {
+    assert(false && "Query should be verified before persisting");
+    return false;
+  }
+  if (!Output.empty()) {
+    // At least one output declaration must be valid.
+    for (const auto &Ref : Output) {
+      if (!Ref.Decl.USR.empty())
+        return false;
+    }
+  }
+  // FIXME: This is too specific, the new refactoring engine at llvm.org should
+  // generalize this.
+  Context.getDiagnostics().Report(
+      Input[0]->getLocation(),
+      diag::err_implement_declared_methods_all_implemented);
+  return true;
+}
+
+namespace {
+
+struct QueryPredicateNode {
+  std::string Name;
+  std::vector<int> IntegerValues;
+};
+
+struct QueryYAMLNode {
+  std::string Name;
+  std::vector<QueryPredicateNode> PredicateResults;
+  std::string FilenameResult;
+};
+
+} // end anonymous namespace
+
+LLVM_YAML_IS_SEQUENCE_VECTOR(QueryPredicateNode)
+LLVM_YAML_IS_SEQUENCE_VECTOR(QueryYAMLNode)
+
+namespace llvm {
+namespace yaml {
+
+template <> struct MappingTraits<QueryPredicateNode> {
+  static void mapping(IO &Yaml, QueryPredicateNode &Predicate) {
+    Yaml.mapRequired("name", Predicate.Name);
+    Yaml.mapRequired("intValues", Predicate.IntegerValues);
+  }
+};
+
+template <> struct MappingTraits<QueryYAMLNode> {
+  static void mapping(IO &Yaml, QueryYAMLNode &Query) {
+    Yaml.mapRequired("name", Query.Name);
+    Yaml.mapOptional("predicateResults", Query.PredicateResults);
+    Yaml.mapOptional("filenameResult", Query.FilenameResult);
+    // FIXME: Report an error if no results are provided at all.
+  }
+};
+
+} // end namespace yaml
+} // end namespace llvm
+
+llvm::Error
+IndexerQuery::loadResultsFromYAML(StringRef Source,
+                                  ArrayRef<IndexerQuery *> Queries) {
+  std::vector<QueryYAMLNode> QueryResults;
+  Input YamlIn(Source);
+  YamlIn >> QueryResults;
+  if (YamlIn.error())
+    return llvm::make_error<llvm::StringError>("Failed to parse query results",
+                                               YamlIn.error());
+  if (QueryResults.size() != Queries.size())
+    return llvm::make_error<llvm::StringError>("Mismatch in query results size",
+                                               llvm::errc::invalid_argument);
+  for (const auto &QueryTuple : llvm::zip(Queries, QueryResults)) {
+    IndexerQuery *Query = std::get<0>(QueryTuple);
+    const QueryYAMLNode &Result = std::get<1>(QueryTuple);
+    if ((Query->NameUID && Query->NameUID != Result.Name) &&
+        (Query->BaseUID && Query->BaseUID != Result.Name))
+      continue;
+    if (auto *DQ = dyn_cast<DeclarationsQuery>(Query)) {
+      const DeclPredicateNode &Predicate = DQ->getPredicateNode();
+      DeclPredicate ActualPredicate("");
+      bool IsNot = false;
+      if (const auto *Not = dyn_cast<DeclPredicateNotPredicate>(&Predicate)) {
+        ActualPredicate =
+            cast<DeclPredicateNodePredicate>(Not->getChild()).getPredicate();
+        IsNot = true;
+      } else
+        ActualPredicate =
+            cast<DeclPredicateNodePredicate>(Predicate).getPredicate();
+      for (const auto &PredicateResult : Result.PredicateResults) {
+        if (PredicateResult.Name != ActualPredicate.Name)
+          continue;
+        std::vector<Indexed<PersistentDeclRef<Decl>>> Output;
+        for (const auto &ResultTuple :
+             zip(DQ->getInputs(), PredicateResult.IntegerValues)) {
+          const Decl *D = std::get<0>(ResultTuple);
+          int Result = std::get<1>(ResultTuple);
+          bool Value = (IsNot ? !Result : !!Result);
+          Output.push_back(Indexed<PersistentDeclRef<Decl>>(
+              PersistentDeclRef<Decl>::create(Value ? D : nullptr),
+              Value ? QueryBoolResult::Yes : QueryBoolResult::No));
+        }
+        DQ->setOutput(std::move(Output));
+        break;
+      }
+    } else if (auto *AQ =
+                   dyn_cast<ASTUnitForImplementationOfDeclarationQuery>(Query))
+      AQ->setResult(Result.FilenameResult);
+  }
+  return llvm::Error::success();
+}
diff --git a/lib/Tooling/Refactor/LocalizeObjCStringLiteral.cpp b/lib/Tooling/Refactor/LocalizeObjCStringLiteral.cpp
index e69de29bb2..08cf41dbbb 100644
--- a/lib/Tooling/Refactor/LocalizeObjCStringLiteral.cpp
+++ b/lib/Tooling/Refactor/LocalizeObjCStringLiteral.cpp
@@ -0,0 +1,83 @@
+//===--- LocalizeObjCString.cpp -  ----------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the "Wrap in NSLocalizedString" refactoring operation.
+//
+//===----------------------------------------------------------------------===//
+
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Expr.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+namespace {
+
+class LocalizeObjCStringLiteralOperation : public RefactoringOperation {
+public:
+  LocalizeObjCStringLiteralOperation(const ObjCStringLiteral *E) : E(E) {}
+
+  const Stmt *getTransformedStmt() const override { return E; }
+
+  llvm::Expected<RefactoringResult> perform(ASTContext &Context, const Preprocessor &ThePreprocessor,
+          const RefactoringOptionSet &Options,
+          unsigned SelectedCandidateIndex) override;
+
+  const ObjCStringLiteral *E;
+};
+
+} // end anonymous namespace
+
+RefactoringOperationResult
+clang::tooling::initiateLocalizeObjCStringLiteralOperation(
+    ASTSlice &Slice, ASTContext &Context, SourceLocation Location,
+    SourceRange SelectionRange, bool CreateOperation) {
+  const ObjCStringLiteral *E;
+  if (SelectionRange.isValid()) {
+    auto SelectedSet = Slice.getSelectedStmtSet();
+    if (!SelectedSet)
+      return None;
+    E = dyn_cast_or_null<ObjCStringLiteral>(
+        SelectedSet->containsSelectionRange);
+  } else
+    E = cast_or_null<ObjCStringLiteral>(
+        Slice.nearestStmt(Stmt::ObjCStringLiteralClass));
+  if (!E)
+    return None;
+
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  if (!CreateOperation)
+    return Result;
+  auto Operation = llvm::make_unique<LocalizeObjCStringLiteralOperation>(E);
+  Result.RefactoringOp = std::move(Operation);
+  return Result;
+}
+
+llvm::Expected<RefactoringResult>
+LocalizeObjCStringLiteralOperation::perform(ASTContext &Context,
+                                            const Preprocessor &ThePreprocessor,
+                                            const RefactoringOptionSet &Options,
+                                            unsigned SelectedCandidateIndex) {
+  std::vector<RefactoringReplacement> Replacements;
+  // TODO: New API: Replace by something like Node.wrap("NSLocalizedString(", ",
+  // @""")
+  SourceLocation LocStart =
+      Context.getSourceManager().getSpellingLoc(E->getLocStart());
+  Replacements.emplace_back(SourceRange(LocStart, LocStart),
+                            StringRef("NSLocalizedString("));
+  SourceLocation LocEnd = getPreciseTokenLocEnd(
+      Context.getSourceManager().getSpellingLoc(E->getLocEnd()),
+      Context.getSourceManager(), Context.getLangOpts());
+  Replacements.emplace_back(SourceRange(LocEnd, LocEnd), StringRef(", @\"\")"));
+  return std::move(Replacements);
+}
diff --git a/lib/Tooling/Refactor/RefactoringActionFinder.cpp b/lib/Tooling/Refactor/RefactoringActionFinder.cpp
index e69de29bb2..2fd7cd5c13 100644
--- a/lib/Tooling/Refactor/RefactoringActionFinder.cpp
+++ b/lib/Tooling/Refactor/RefactoringActionFinder.cpp
@@ -0,0 +1,57 @@
+//===--- RefactoringActionFinder.cpp - Clang refactoring library ----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Implements methods that find the refactoring actions that can be
+/// performed at specific locations / source ranges in a translation unit.
+///
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RefactoringActionFinder.h"
+#include "clang/Tooling/Refactor/RefactoringOperation.h"
+#include "clang/Tooling/Refactor/USRFinder.h"
+
+namespace clang {
+namespace tooling {
+
+RefactoringActionSet findActionSetAt(SourceLocation Location,
+                                     SourceRange SelectionRange,
+                                     ASTContext &Context) {
+  RefactoringActionSet Result;
+  if (const auto *ND = rename::getNamedDeclAt(Context, Location))
+    Result.Actions.push_back(isLocalSymbol(ND, Context.getLangOpts())
+                                 ? RefactoringActionType::Rename_Local
+                                 : RefactoringActionType::Rename);
+
+  // FIXME: We can avoid checking if some actions can be initiated when they're
+  // not allowed in the current language mode.
+  RefactoringActionType Actions[] = {
+#define REFACTORING_OPERATION_ACTION(Name, Spelling, Command)                  \
+  RefactoringActionType::Name,
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+  };
+
+  for (auto Action : Actions) {
+    auto Op = initiateRefactoringOperationAt(Location, SelectionRange, Context,
+                                             Action,
+                                             /*CreateOperation=*/true);
+    if (Op.Initiated) {
+      Result.Actions.push_back(Action);
+      if (Op.RefactoringOp) {
+        for (const auto &SubAction : Op.RefactoringOp->getAvailableSubActions())
+          Result.Actions.push_back(SubAction);
+      }
+    }
+  }
+
+  return Result;
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/RefactoringActions.cpp b/lib/Tooling/Refactor/RefactoringActions.cpp
index e69de29bb2..4b2b735b3d 100644
--- a/lib/Tooling/Refactor/RefactoringActions.cpp
+++ b/lib/Tooling/Refactor/RefactoringActions.cpp
@@ -0,0 +1,30 @@
+//===--- RefactoringActions.cpp - Clang refactoring library ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Contains a list of all the supported refactoring actions.
+///
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RefactoringActions.h"
+
+namespace clang {
+namespace tooling {
+
+StringRef getRefactoringActionTypeName(RefactoringActionType Action) {
+  switch (Action) {
+#define REFACTORING_ACTION(Name, Spelling)                                     \
+  case RefactoringActionType::Name:                                            \
+    return Spelling;
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+  }
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/RefactoringContinuations.h b/lib/Tooling/Refactor/RefactoringContinuations.h
index e69de29bb2..ec2ee1bcf5 100644
--- a/lib/Tooling/Refactor/RefactoringContinuations.h
+++ b/lib/Tooling/Refactor/RefactoringContinuations.h
@@ -0,0 +1,398 @@
+//===--- RefactoringContinuations.h - Defines refactoring continuations ---===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_REFACTORING_CONTINUATIONS_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_REFACTORING_CONTINUATIONS_H
+
+#include "clang/AST/Decl.h"
+#include "clang/Tooling/Refactor/IndexerQuery.h"
+#include "clang/Tooling/Refactor/RefactoringOperation.h"
+#include "llvm/ADT/StringMap.h"
+#include <tuple>
+
+namespace clang {
+namespace tooling {
+
+namespace detail {
+
+struct ValidBase {};
+
+/// The ContinuationPassType determine which type is passed into the refactoring
+/// continuation.
+template <typename T> struct ContinuationPassType { using Type = T; };
+
+template <typename T> struct ContinuationPassType<std::vector<T>> {
+  using Type = ArrayRef<T>;
+};
+
+/// Refactoring operations can pass state to the continuations. Valid state
+/// values should have a corresponding \c StateTraits specialization.
+template <typename T> struct StateTraits {
+  /// Specializations should define the following types:
+  ///
+  /// StoredResultType: The TU-specific type which is then passed into the
+  /// continuation function. The continuation receives the result whose type is
+  /// \c ContinuationPassType<StoredResultType>::Type.
+  ///
+  /// PersistentType: The TU-independent type that's persisted even after the
+  /// TU in which the continuation was created is disposed.
+};
+
+template <typename T>
+struct StateTraits<const T *>
+    : std::enable_if<std::is_base_of<Decl, T>::value, ValidBase>::type {
+  using StoredResultType = const T *;
+  using PersistentType = PersistentDeclRef<T>;
+};
+
+template <typename T>
+struct StateTraits<ArrayRef<const T *>>
+    : std::enable_if<std::is_base_of<Decl, T>::value, ValidBase>::type {
+  using StoredResultType = std::vector<const T *>;
+  using PersistentType = std::vector<PersistentDeclRef<T>>;
+};
+
+template <typename T>
+struct StateTraits<std::unique_ptr<indexer::ManyToManyDeclarationsQuery<T>>>
+    : std::enable_if<std::is_base_of<Decl, T>::value, ValidBase>::type {
+  using StoredResultType = std::vector<indexer::Indexed<const T *>>;
+  using PersistentType = std::vector<indexer::Indexed<PersistentDeclRef<T>>>;
+};
+
+template <> struct StateTraits<std::vector<std::string>> {
+  using StoredResultType = std::vector<std::string>;
+  using PersistentType = std::vector<std::string>;
+};
+
+/// Conversion functions convert the TU-specific state to a TU independent
+/// state and vice-versa.
+template <typename T>
+PersistentDeclRef<T> convertToPersistentRepresentation(
+    const T *Declaration,
+    typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+        nullptr) {
+  return PersistentDeclRef<T>::create(Declaration);
+}
+
+template <typename T>
+std::vector<PersistentDeclRef<T>> convertToPersistentRepresentation(
+    ArrayRef<const T *> Declarations,
+    typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+        nullptr) {
+  std::vector<PersistentDeclRef<T>> Result;
+  Result.reserve(Declarations.size());
+  for (const T *D : Declarations)
+    Result.push_back(PersistentDeclRef<T>::create(D));
+  return Result;
+}
+
+template <typename T>
+std::vector<indexer::Indexed<PersistentDeclRef<T>>>
+convertToPersistentRepresentation(
+    std::unique_ptr<indexer::ManyToManyDeclarationsQuery<T>> &Query,
+    typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+        nullptr) {
+  Query->invalidateTUSpecificState();
+  return Query->getOutput();
+}
+
+inline std::vector<std::string>
+convertToPersistentRepresentation(const std::vector<std::string> &Values) {
+  return Values;
+}
+
+/// Converts the TU-independent state to the TU-specific state.
+class PersistentToASTSpecificStateConverter {
+  ASTContext &Context;
+  llvm::StringMap<const Decl *> ConvertedDeclRefs;
+
+  const Decl *lookupDecl(StringRef USR);
+
+public:
+  // FIXME: We can hide the addConvertible/convert interface so that
+  // the continuation will just invoke one conversion function for the entire
+  // tuple.
+  PersistentToASTSpecificStateConverter(ASTContext &Context)
+      : Context(Context) {}
+
+  template <typename T>
+  bool addConvertible(
+      const PersistentDeclRef<T> &Ref,
+      typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+          nullptr) {
+    if (!Ref.USR.empty())
+      ConvertedDeclRefs[Ref.USR] = nullptr;
+    return true;
+  }
+
+  template <typename T>
+  const T *
+  convert(const PersistentDeclRef<T> &Ref,
+          typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+              nullptr) {
+    return dyn_cast_or_null<T>(lookupDecl(Ref.USR));
+  }
+
+  template <typename T>
+  bool addConvertible(
+      const std::vector<PersistentDeclRef<T>> &Refs,
+      typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+          nullptr) {
+    for (const auto &Ref : Refs) {
+      if (!Ref.USR.empty())
+        ConvertedDeclRefs[Ref.USR] = nullptr;
+    }
+    return true;
+  }
+
+  template <typename T>
+  std::vector<const T *>
+  convert(const std::vector<PersistentDeclRef<T>> &Refs,
+          typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+              nullptr) {
+    std::vector<const T *> Results;
+    Results.reserve(Refs.size());
+    // Allow nulls in the produced array, the continuation will have to deal
+    // with them by itself.
+    for (const auto &Ref : Refs)
+      Results.push_back(dyn_cast_or_null<T>(lookupDecl(Ref.USR)));
+    return Results;
+  }
+
+  template <typename T>
+  bool addConvertible(
+      const std::vector<indexer::Indexed<PersistentDeclRef<T>>> &Refs,
+      typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+          nullptr) {
+    for (const auto &Ref : Refs) {
+      if (!Ref.Decl.USR.empty())
+        ConvertedDeclRefs[Ref.Decl.USR] = nullptr;
+    }
+    return true;
+  }
+
+  template <typename T>
+  std::vector<indexer::Indexed<const T *>>
+  convert(const std::vector<indexer::Indexed<PersistentDeclRef<T>>> &Refs,
+          typename std::enable_if<std::is_base_of<Decl, T>::value>::type * =
+              nullptr) {
+    std::vector<indexer::Indexed<const T *>> Results;
+    Results.reserve(Refs.size());
+    // Allow nulls in the produced array, the continuation will have to deal
+    // with them by itself.
+    for (const auto &Ref : Refs)
+      Results.push_back(indexer::Indexed<const T *>(
+          dyn_cast_or_null<T>(lookupDecl(Ref.Decl.USR)), Ref.IsNotDefined));
+    return Results;
+  }
+
+  bool addConvertible(const PersistentFileID &) {
+    // Do nothing since FileIDs are converted one-by-one.
+    return true;
+  }
+
+  FileID convert(const PersistentFileID &Ref);
+
+  bool addConvertible(const std::vector<std::string> &) { return true; }
+
+  std::vector<std::string> convert(const std::vector<std::string> &Values) {
+    return Values;
+  }
+
+  /// Converts the added persistent state into TU-specific state using one
+  /// efficient operation.
+  void runCoalescedConversions();
+};
+
+template <typename T, typename ASTQueryType, typename... QueryOrState>
+struct ContinuationFunction {
+  using Type = llvm::Expected<RefactoringResult> (*)(
+      ASTContext &, const T &,
+      typename ContinuationPassType<
+          typename StateTraits<QueryOrState>::StoredResultType>::Type...);
+
+  template <size_t... Is>
+  static llvm::Expected<RefactoringResult> dispatch(
+      Type Fn, detail::PersistentToASTSpecificStateConverter &Converter,
+      ASTContext &Context, const ASTQueryType &Query,
+      const std::tuple<typename StateTraits<QueryOrState>::StoredResultType...>
+          &Arguments,
+      llvm::index_sequence<Is...>) {
+    auto ASTQueryResult = Converter.convert(Query.getResult());
+    return Fn(Context, ASTQueryResult, std::get<Is>(Arguments)...);
+  }
+};
+
+template <typename ASTQueryType, typename... QueryOrState>
+struct ContinuationFunction<void, ASTQueryType, QueryOrState...> {
+  using Type = llvm::Expected<RefactoringResult> (*)(
+      ASTContext &,
+      typename ContinuationPassType<
+          typename StateTraits<QueryOrState>::StoredResultType>::Type...);
+
+  template <size_t... Is>
+  static llvm::Expected<RefactoringResult> dispatch(
+      Type Fn, detail::PersistentToASTSpecificStateConverter &,
+      ASTContext &Context, const ASTQueryType &,
+      const std::tuple<typename StateTraits<QueryOrState>::StoredResultType...>
+          &Arguments,
+      llvm::index_sequence<Is...>) {
+    return Fn(Context, std::get<Is>(Arguments)...);
+  }
+};
+
+/// The refactoring contination contains a set of structures that implement
+/// the refactoring operation continuation mechanism.
+template <typename ASTQueryType, typename... QueryOrState>
+class SpecificRefactoringContinuation final : public RefactoringContinuation {
+public:
+  static_assert(std::is_base_of<indexer::ASTProducerQuery, ASTQueryType>::value,
+                "Invalid AST Query");
+  // TODO: Validate the QueryOrState types.
+
+  /// The consumer function is the actual continuation. It receives the state
+  /// that was passed-in in the request or the results of the indexing queries
+  /// that were passed-in in the request.
+  using ConsumerFn =
+      typename ContinuationFunction<typename ASTQueryType::ResultTy,
+                                    ASTQueryType, QueryOrState...>::Type;
+
+private:
+  ConsumerFn Consumer;
+  std::unique_ptr<ASTQueryType> ASTQuery;
+  /// Inputs store state that's dependent on the original TU.
+  llvm::Optional<std::tuple<QueryOrState...>> Inputs;
+  /// State contains TU-independent values.
+  llvm::Optional<
+      std::tuple<typename StateTraits<QueryOrState>::PersistentType...>>
+      State;
+
+  /// Converts a tuple that contains the TU dependent state to a tuple with
+  /// TU independent state.
+  template <size_t... Is>
+  std::tuple<typename StateTraits<QueryOrState>::PersistentType...>
+  convertToPersistentImpl(llvm::index_sequence<Is...>) {
+    assert(Inputs && "TU-dependent state is already converted");
+    return std::make_tuple(
+        detail::convertToPersistentRepresentation(std::get<Is>(*Inputs))...);
+  }
+
+  template <typename T>
+  bool gatherQueries(
+      std::vector<indexer::IndexerQuery *> &Queries,
+      const std::unique_ptr<T> &Query,
+      typename std::enable_if<
+          std::is_base_of<indexer::IndexerQuery, T>::value>::type * = nullptr) {
+    Queries.push_back(Query.get());
+    return true;
+  }
+
+  template <typename T>
+  bool gatherQueries(std::vector<indexer::IndexerQuery *> &, const T &) {
+    // This input element is not a query.
+    return true;
+  }
+
+  template <size_t... Is>
+  std::vector<indexer::IndexerQuery *>
+  gatherQueries(llvm::index_sequence<Is...>) {
+    assert(Inputs && "TU-dependent state is already converted");
+    std::vector<indexer::IndexerQuery *> Queries;
+    std::make_tuple(gatherQueries(Queries, std::get<Is>(*Inputs))...);
+    return Queries;
+  }
+
+  /// Calls the consumer function with the given \p Context and the state
+  /// whose values are converted from the TU-independent to TU-specific values.
+  template <size_t... Is>
+  llvm::Expected<RefactoringResult> dispatch(ASTContext &Context,
+                                             llvm::index_sequence<Is...> Seq) {
+    assert(State && "TU-independent state is not yet produced");
+    detail::PersistentToASTSpecificStateConverter Converter(Context);
+    (void)std::make_tuple(Converter.addConvertible(std::get<Is>(*State))...);
+    Converter.runCoalescedConversions();
+    auto Results = std::make_tuple(Converter.convert(std::get<Is>(*State))...);
+    // TODO: Check for errors?
+    return detail::ContinuationFunction<
+        typename ASTQueryType::ResultTy, ASTQueryType,
+        QueryOrState...>::dispatch(Consumer, Converter, Context, *ASTQuery,
+                                   Results, Seq);
+  }
+
+public:
+  SpecificRefactoringContinuation(ConsumerFn Consumer,
+                                  std::unique_ptr<ASTQueryType> ASTQuery,
+                                  QueryOrState... Inputs)
+      : Consumer(Consumer), ASTQuery(std::move(ASTQuery)),
+        Inputs(std::make_tuple(std::move(Inputs)...)) {}
+
+  SpecificRefactoringContinuation(SpecificRefactoringContinuation &&) = default;
+  SpecificRefactoringContinuation &
+  operator=(SpecificRefactoringContinuation &&) = default;
+
+  indexer::ASTProducerQuery *getASTUnitIndexerQuery() override {
+    return ASTQuery.get();
+  }
+
+  std::vector<indexer::IndexerQuery *> getAdditionalIndexerQueries() override {
+    return gatherQueries(llvm::index_sequence_for<QueryOrState...>());
+  }
+
+  /// Query results are fetched. State is converted to a persistent
+  /// representation.
+  void persistTUSpecificState() override {
+    ASTQuery->invalidateTUSpecificState();
+    State =
+        convertToPersistentImpl(llvm::index_sequence_for<QueryOrState...>());
+    Inputs = None;
+  }
+
+  /// The state is converted to the AST representation in the given ASTContext
+  /// and the continuation is dispatched.
+  llvm::Expected<RefactoringResult>
+  runInExternalASTUnit(ASTContext &Context) override {
+    return dispatch(Context, llvm::index_sequence_for<QueryOrState...>());
+  }
+};
+
+} // end namespace detail
+
+/// Returns a refactoring continuation that will run within the context of a
+/// single external AST unit.
+///
+/// The indexer determines which AST unit should receive the continuation by
+/// evaluation the AST query operation \p ASTQuery.
+///
+/// \param ASTQuery The query that will determine which AST unit should the
+/// continuation run in.
+///
+/// \param Consumer The continuation function that will be called once the
+/// external AST unit is loaded.
+///
+/// \param Inputs Each individiual input element can contain either some
+/// state value that will be passed into the \p Consumer function or an
+/// indexer query whose results will be passed into the \p Consumer function.
+template <typename ASTQueryType, typename... QueryOrState>
+typename std::enable_if<
+    std::is_base_of<indexer::ASTProducerQuery, ASTQueryType>::value,
+    std::unique_ptr<RefactoringContinuation>>::type
+continueInExternalASTUnit(
+    std::unique_ptr<ASTQueryType> ASTQuery,
+    typename detail::SpecificRefactoringContinuation<
+        ASTQueryType, QueryOrState...>::ConsumerFn Consumer,
+    QueryOrState... Inputs) {
+  return llvm::make_unique<
+      detail::SpecificRefactoringContinuation<ASTQueryType, QueryOrState...>>(
+      Consumer, std::move(ASTQuery), std::move(Inputs)...);
+}
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_REFACTORING_CONTINUATIONS_H
diff --git a/lib/Tooling/Refactor/RefactoringOperation.cpp b/lib/Tooling/Refactor/RefactoringOperation.cpp
index e69de29bb2..a9f431f98d 100644
--- a/lib/Tooling/Refactor/RefactoringOperation.cpp
+++ b/lib/Tooling/Refactor/RefactoringOperation.cpp
@@ -0,0 +1,93 @@
+//===--- RefactoringOperation.cpp - Defines a refactoring operation -------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RefactoringOperation.h"
+#include "ASTSlice.h"
+#include "RefactoringOperations.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/Tooling/Refactor/SymbolOperation.h"
+#include "clang/Tooling/Refactor/USRFinder.h"
+#include "llvm/Support/Errc.h"
+
+using namespace clang;
+using namespace clang::tooling;
+
+char RefactoringOperationError::ID;
+
+void RefactoringOperationError::log(raw_ostream &OS) const {
+  OS << "Refactoring operation failed: " << FailureReason;
+}
+
+std::error_code RefactoringOperationError::convertToErrorCode() const {
+  return make_error_code(llvm::errc::operation_not_permitted);
+}
+
+RefactoringOperationResult clang::tooling::initiateRefactoringOperationAt(
+    SourceLocation Location, SourceRange SelectionRange, ASTContext &Context,
+    RefactoringActionType ActionType, bool CreateOperation) {
+  if (Location.isInvalid())
+    return None;
+  if (ActionType == RefactoringActionType::Rename ||
+      ActionType == RefactoringActionType::Rename_Local) {
+    const NamedDecl *FoundDecl = rename::getNamedDeclAt(Context, Location);
+    if (!FoundDecl)
+      return None;
+    RefactoringOperationResult Result;
+    Result.Initiated = true;
+    if (CreateOperation)
+      Result.SymbolOp = llvm::make_unique<SymbolOperation>(FoundDecl, Context);
+    return Result;
+  }
+  SourceManager &SM = Context.getSourceManager();
+  if (Location.isMacroID())
+    Location = SM.getSpellingLoc(Location);
+  assert(Location.isFileID() && "Invalid location");
+
+  // TODO: Don't perform duplicate work when initiateRefactoringOperationAt is
+  // called from findRefactoringActionsAt.
+  if (SelectionRange.isValid()) {
+    if (SelectionRange.getBegin().isMacroID() ||
+        SelectionRange.getEnd().isMacroID())
+      SelectionRange = SourceRange(SM.getSpellingLoc(SelectionRange.getBegin()),
+                                   SM.getSpellingLoc(SelectionRange.getEnd()));
+    SelectionRange = trimSelectionRange(
+        SelectionRange, Context.getSourceManager(), Context.getLangOpts());
+  }
+  ASTSlice Slice(Location, SelectionRange, Context);
+
+  switch (ActionType) {
+#define REFACTORING_OPERATION_ACTION(Name, Spelling, Command)                  \
+  case RefactoringActionType::Name:                                            \
+    return initiate##Name##Operation(Slice, Context, Location, SelectionRange, \
+                                     CreateOperation);
+#define REFACTORING_OPERATION_SUB_ACTION(Name, Parent, Spelling, Command)      \
+  case RefactoringActionType::Parent##_##Name:                                 \
+    return initiate##Parent##Name##Operation(Slice, Context, Location,         \
+                                             SelectionRange, CreateOperation);
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+  default:
+    break;
+  }
+  return RefactoringOperationResult();
+}
+
+RefactoringOperationResult clang::tooling::initiateRefactoringOperationOnDecl(
+    StringRef DeclUSR, ASTContext &Context, RefactoringActionType ActionType) {
+  if (ActionType != RefactoringActionType::Rename)
+    return None;
+  const NamedDecl *FoundDecl = rename::getNamedDeclWithUSR(Context, DeclUSR);
+  if (!FoundDecl)
+    return None;
+  RefactoringOperationResult Result;
+  Result.Initiated = true;
+  Result.SymbolOp = llvm::make_unique<SymbolOperation>(FoundDecl, Context);
+  return Result;
+}
diff --git a/lib/Tooling/Refactor/RefactoringOperations.h b/lib/Tooling/Refactor/RefactoringOperations.h
index e69de29bb2..e02a3cf0b3 100644
--- a/lib/Tooling/Refactor/RefactoringOperations.h
+++ b/lib/Tooling/Refactor/RefactoringOperations.h
@@ -0,0 +1,37 @@
+//===--- RefactoringOperations.h - The supported refactoring operations ---===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_REFACTORINGOPERATIONS_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_REFACTORINGOPERATIONS_H
+
+#include "ASTSlice.h"
+#include "clang/Tooling/Refactor/RefactoringOperation.h"
+
+namespace clang {
+
+class Expr;
+class IfStmt;
+class VarDecl;
+
+namespace tooling {
+
+#define REFACTORING_OPERATION_ACTION(Name, Spelling, Command)                  \
+  RefactoringOperationResult initiate##Name##Operation(                        \
+      ASTSlice &Slice, ASTContext &Context, SourceLocation Location,           \
+      SourceRange SelectionRange, bool CreateOperation = true);
+#define REFACTORING_OPERATION_SUB_ACTION(Name, Parent, Spelling, Command)      \
+  RefactoringOperationResult initiate##Parent##Name##Operation(                \
+      ASTSlice &Slice, ASTContext &Context, SourceLocation Location,           \
+      SourceRange SelectionRange, bool CreateOperation = true);
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_REFACTORINGOPERATIONS_H
diff --git a/lib/Tooling/Refactor/RefactoringOptions.cpp b/lib/Tooling/Refactor/RefactoringOptions.cpp
index e69de29bb2..ca62890edb 100644
--- a/lib/Tooling/Refactor/RefactoringOptions.cpp
+++ b/lib/Tooling/Refactor/RefactoringOptions.cpp
@@ -0,0 +1,65 @@
+//===--- RefactoringOptions.cpp - A set of all the refactoring options ----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RefactoringOptions.h"
+#include "llvm/Support/YAMLTraits.h"
+
+using namespace clang;
+using namespace clang::tooling;
+using namespace clang::tooling::option;
+using namespace llvm::yaml;
+
+void RefactoringOptionSet::print(llvm::raw_ostream &OS) const {
+  Output YamlOut(OS);
+  if (YamlOut.preflightDocument(0)) {
+    YamlOut.beginFlowMapping();
+    for (const auto &Option : Options)
+      Option.getValue()->serialize(YamlOut);
+    YamlOut.endFlowMapping();
+    YamlOut.postflightDocument();
+  }
+}
+
+template <> struct CustomMappingTraits<RefactoringOptionSet> {
+  static void inputOne(IO &YamlIn, StringRef Key,
+                       RefactoringOptionSet &Result) {
+#define HANDLE(Type)                                                           \
+  if (Key == Type::Name) {                                                     \
+    Type Value;                                                                \
+    Value.serialize(YamlIn);                                                   \
+    Result.add(Value);                                                         \
+    return;                                                                    \
+  }
+    HANDLE(AvoidTextualMatches)
+#undef HANDLE
+    YamlIn.setError(Twine("Unknown refactoring option ") + Key);
+  }
+  static void output(IO &, RefactoringOptionSet &) {
+    llvm_unreachable("Output is done without mapping traits");
+  }
+};
+
+llvm::Expected<RefactoringOptionSet>
+RefactoringOptionSet::parse(StringRef Source) {
+  Input YamlIn(Source);
+  // FIXME: Don't dump errors to stderr.
+  RefactoringOptionSet Result;
+  YamlIn >> Result;
+  if (YamlIn.error())
+    return llvm::make_error<llvm::StringError>("Failed to parse the option set",
+                                               YamlIn.error());
+  return std::move(Result);
+}
+
+void OldRefactoringOption::serialize(const SerializationContext &) {}
+
+void clang::tooling::option::detail::BoolOptionBase::serializeImpl(
+    const SerializationContext &Context, const char *Name) {
+  Context.IO.mapRequired(Name, Value);
+}
diff --git a/lib/Tooling/Refactor/RenameIndexedFile.cpp b/lib/Tooling/Refactor/RenameIndexedFile.cpp
index e69de29bb2..6d976748f9 100644
--- a/lib/Tooling/Refactor/RenameIndexedFile.cpp
+++ b/lib/Tooling/Refactor/RenameIndexedFile.cpp
@@ -0,0 +1,670 @@
+//===--- RenameIndexedFile.cpp - ------------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RenameIndexedFile.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Frontend/CompilerInstance.h"
+#include "clang/Frontend/FrontendActions.h"
+#include "clang/Lex/LiteralSupport.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Tooling/Refactor/RefactoringOptions.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/Path.h"
+
+using namespace clang;
+
+namespace clang {
+namespace tooling {
+namespace rename {
+
+IndexedFileOccurrenceProducer::IndexedFileOccurrenceProducer(
+    ArrayRef<IndexedSymbol> Symbols, IndexedFileOccurrenceConsumer &Consumer,
+    const RefactoringOptionSet *Options)
+    : Symbols(Symbols), Consumer(Consumer), Options(Options) {
+  IsMultiPiece = false;
+  for (const auto &Symbol : Symbols) {
+    if (Symbol.Name.size() > 1) {
+      IsMultiPiece = true;
+      break;
+    }
+  }
+  if (IsMultiPiece) {
+    for (const auto &Symbol : Symbols) {
+      (void)Symbol;
+      assert(Symbol.Name.size() > 1 &&
+             "Mixed multi-piece and single piece symbols "
+             "are unsupported");
+    }
+  }
+}
+
+namespace {
+
+enum class MatchKind {
+  SourceMatch,
+  SourcePropSetterMatch,
+  MacroExpansion,
+  None
+};
+
+} // end anonymous namespace
+
+static bool isSetterNameEqualToPropName(StringRef SetterName,
+                                        StringRef PropertyName) {
+  assert(SetterName.startswith("set") && "invalid setter name");
+  SetterName = SetterName.drop_front(3);
+  return SetterName[0] == toUppercase(PropertyName[0]) &&
+         SetterName.drop_front() == PropertyName.drop_front();
+}
+
+static MatchKind checkOccurrence(const IndexedOccurrence &Occurrence,
+                                 const IndexedSymbol &Symbol,
+                                 const SourceManager &SM,
+                                 const LangOptions &LangOpts,
+                                 SourceRange &SymbolRange,
+                                 bool AllowObjCSetterProp = false) {
+  if (!Occurrence.Line || !Occurrence.Column)
+    return MatchKind::None; // Ignore any invalid indexed locations.
+
+  // Ensure that the first string in the name is present at the given
+  // location.
+  SourceLocation BeginLoc = SM.translateLineCol(
+      SM.getMainFileID(), Occurrence.Line, Occurrence.Column);
+  if (BeginLoc.isInvalid())
+    return MatchKind::None;
+  StringRef SymbolNameStart = Symbol.Name[0];
+  // Extract the token at the location.
+  auto DecomposedLoc = SM.getDecomposedLoc(BeginLoc);
+  const llvm::MemoryBuffer *File = SM.getBuffer(DecomposedLoc.first);
+  Lexer RawLex(
+      BeginLoc, LangOpts, File->getBufferStart() + DecomposedLoc.second,
+      File->getBufferStart() + DecomposedLoc.second, File->getBufferEnd());
+  Token Tok;
+  RawLex.LexFromRawLexer(Tok);
+  if (Tok.isNot(tok::raw_identifier) || Tok.getLocation() != BeginLoc) {
+    if (SymbolNameStart.empty() && Tok.is(tok::colon) &&
+        Tok.getLocation() == BeginLoc) {
+      // Must be the location of an empty Objective-C selector piece.
+      SymbolRange = SourceRange(BeginLoc, BeginLoc);
+      return MatchKind::SourceMatch;
+    }
+    // FIXME: Handle empty selector piece in a macro?
+    return MatchKind::None;
+  }
+  SymbolRange = SourceRange(BeginLoc, Tok.getEndLoc());
+  if (Tok.getRawIdentifier() == SymbolNameStart)
+    return MatchKind::SourceMatch;
+  // Match 'prop' when looking for 'setProp'.
+  // FIXME: Verify that the previous token is a '.' to be sure.
+  if (AllowObjCSetterProp &&
+      Occurrence.Kind == IndexedOccurrence::IndexedObjCMessageSend &&
+      SymbolNameStart.startswith("set") &&
+      isSetterNameEqualToPropName(SymbolNameStart, Tok.getRawIdentifier()))
+    return MatchKind::SourcePropSetterMatch;
+  return MatchKind::MacroExpansion;
+}
+
+static void
+findObjCMultiPieceSelectorOccurrences(CompilerInstance &CI,
+                                      ArrayRef<IndexedSymbol> Symbols,
+                                      IndexedFileOccurrenceConsumer &Consumer);
+
+namespace {
+
+struct TextualMatchOccurrence {
+  SourceLocation Location;
+  unsigned SymbolIndex;
+};
+
+/// Finds '@selector' expressions by looking at tokens one-by-one.
+class SelectorParser {
+  enum ParseState {
+    None,
+    At,
+    Selector,
+    ExpectingSelectorPiece,
+    ExpectingColon,
+    ExpectingRParenOrColon,
+    ExpectingRParen,
+    Success
+  };
+  ParseState State = None;
+  const OldSymbolName &Name;
+
+  ParseState stateForToken(const Token &RawTok);
+
+public:
+  unsigned SymbolIndex;
+  llvm::SmallVector<SourceLocation, 8> SelectorLocations;
+
+  SelectorParser(const OldSymbolName &Name, unsigned SymbolIndex)
+      : Name(Name), SymbolIndex(SymbolIndex) {}
+
+  /// Returns true if the parses has found a '@selector' expression.
+  bool handleToken(const Token &RawTok);
+};
+
+class InclusionLexer final : public Lexer {
+public:
+  InclusionLexer(SourceLocation FileLoc, const LangOptions &LangOpts,
+                 const char *BufStart, const char *BufEnd)
+      : Lexer(FileLoc, LangOpts, BufStart, BufStart, BufEnd) {}
+
+  void IndirectLex(Token &Result) override { LexFromRawLexer(Result); }
+};
+
+/// Finds matching textual occurrences in string literals.
+class StringLiteralTextualParser {
+  const OldSymbolName &Name;
+
+public:
+  unsigned SymbolIndex;
+
+  StringLiteralTextualParser(const OldSymbolName &Name, unsigned SymbolIndex)
+      : Name(Name), SymbolIndex(SymbolIndex) {
+    assert(Name.size() == 1 && "can't search for multi-piece names in strings");
+  }
+
+  /// Returns the name's location if the parses has found a matching textual
+  /// name in a string literal.
+  SourceLocation handleToken(const Token &RawTok, Preprocessor &PP);
+};
+
+} // end anonymous namespace
+
+SelectorParser::ParseState SelectorParser::stateForToken(const Token &RawTok) {
+  assert(RawTok.isNot(tok::comment) && "unexpected comment token");
+  switch (State) {
+  case None:
+    break;
+  case At:
+    if (RawTok.is(tok::raw_identifier) &&
+        RawTok.getRawIdentifier() == "selector")
+      return Selector;
+    break;
+  case Selector:
+    if (RawTok.isNot(tok::l_paren))
+      break;
+    SelectorLocations.clear();
+    return ExpectingSelectorPiece;
+  case ExpectingSelectorPiece: {
+    assert(SelectorLocations.size() < Name.size() &&
+           "Expecting invalid selector piece");
+    StringRef NamePiece = Name[SelectorLocations.size()];
+    if ((RawTok.isNot(tok::raw_identifier) ||
+         RawTok.getRawIdentifier() != NamePiece) &&
+        !(NamePiece.empty() && RawTok.is(tok::colon))) {
+      break;
+    }
+    SelectorLocations.push_back(RawTok.getLocation());
+    if (SelectorLocations.size() == Name.size()) {
+      // We found the selector that we were looking for, now check for ')'.
+      return NamePiece.empty() ? ExpectingRParen : ExpectingRParenOrColon;
+    }
+    return NamePiece.empty() ? ExpectingSelectorPiece : ExpectingColon;
+  }
+  case ExpectingColon:
+    if (RawTok.is(tok::colon))
+      return ExpectingSelectorPiece;
+    break;
+  case ExpectingRParenOrColon:
+    if (RawTok.is(tok::colon))
+      return ExpectingRParen;
+  // Fallthrough
+  case ExpectingRParen:
+    if (RawTok.is(tok::r_paren)) {
+      // We found the selector that we were looking for.
+      return Success;
+    }
+    break;
+  case Success:
+    llvm_unreachable("should not get here");
+  }
+  // Look for the start of the selector expression.
+  return RawTok.is(tok::at) ? At : None;
+}
+
+bool SelectorParser::handleToken(const Token &RawTok) {
+  if (RawTok.is(tok::coloncolon)) {
+    // Split the '::' into two ':'.
+    Token T(RawTok);
+    T.setKind(tok::colon);
+    T.setLength(1);
+    handleToken(T);
+    T.setLocation(T.getLocation().getLocWithOffset(1));
+    return handleToken(T);
+  }
+  State = stateForToken(RawTok);
+  if (State != Success)
+    return false;
+  State = None;
+  return true;
+}
+
+SourceLocation StringLiteralTextualParser::handleToken(const Token &RawTok,
+                                                       Preprocessor &PP) {
+  if (!tok::isStringLiteral(RawTok.getKind()))
+    return SourceLocation();
+  StringLiteralParser Literal(RawTok, PP);
+  if (Literal.hadError)
+    return SourceLocation();
+  return Literal.GetString() == Name[0]
+             ? RawTok.getLocation().getLocWithOffset(
+                   Literal.getOffsetOfStringByte(RawTok, 0))
+             : SourceLocation();
+}
+
+static void collectTextualMatchesInComment(
+    ArrayRef<IndexedSymbol> Symbols, SourceLocation CommentLoc,
+    StringRef Comment, llvm::SmallVectorImpl<TextualMatchOccurrence> &Result) {
+  for (const auto &Symbol : llvm::enumerate(Symbols)) {
+    const OldSymbolName &Name = Symbol.value().Name;
+    if (Name.containsEmptyPiece()) // Ignore Objective-C selectors with empty
+                                   // pieces.
+      continue;
+    size_t Offset = 0;
+    while (true) {
+      Offset = Comment.find(Name[0], /*From=*/Offset);
+      if (Offset == StringRef::npos)
+        break;
+      Result.push_back(
+          {CommentLoc.getLocWithOffset(Offset), (unsigned)Symbol.index()});
+      Offset += Name[0].size();
+    }
+  }
+}
+
+/// Lex the comment to figure out if textual matches in a comment are standalone
+/// tokens.
+static void findTextualMatchesInComment(
+    const SourceManager &SM, const LangOptions &LangOpts,
+    ArrayRef<IndexedSymbol> Symbols,
+    ArrayRef<TextualMatchOccurrence> TextualMatches, SourceRange CommentRange,
+    llvm::function_ref<void(OldSymbolOccurrence::OccurrenceKind,
+                            ArrayRef<SourceLocation> Locations,
+                            unsigned SymbolIndex)>
+        MatchHandler) {
+  std::string Source =
+      Lexer::getSourceText(CharSourceRange::getCharRange(CommentRange), SM,
+                           LangOpts)
+          .str();
+  OldSymbolOccurrence::OccurrenceKind Kind =
+      RawComment(SM, CommentRange, /*Merged=*/false, /*ParseAllComments=*/false)
+              .isDocumentation()
+          ? OldSymbolOccurrence::MatchingDocComment
+          : OldSymbolOccurrence::MatchingComment;
+  // Replace some special characters  with ' ' to avoid comments and literals.
+  std::replace_if(
+      Source.begin(), Source.end(),
+      [](char c) -> bool { return c == '/' || c == '"' || c == '\''; }, ' ');
+  Lexer RawLex(CommentRange.getBegin(), LangOpts, Source.c_str(),
+               Source.c_str(), Source.c_str() + Source.size());
+  Token RawTok;
+  RawLex.LexFromRawLexer(RawTok);
+  while (RawTok.isNot(tok::eof)) {
+    auto It = std::find_if(TextualMatches.begin(), TextualMatches.end(),
+                           [&](const TextualMatchOccurrence &Match) {
+                             return Match.Location == RawTok.getLocation();
+                           });
+    if (It != TextualMatches.end()) {
+      StringRef TokenName =
+          Lexer::getSourceText(CharSourceRange::getCharRange(
+                                   RawTok.getLocation(), RawTok.getEndLoc()),
+                               SM, LangOpts);
+      // Only report matches that are identical to the symbol. When dealing with
+      // multi-piece selectors we only look for the first selector piece as we
+      // assume that textual matches correspond to a match of the first selector
+      // piece.
+      if (TokenName == Symbols[It->SymbolIndex].Name[0])
+        MatchHandler(Kind, It->Location, It->SymbolIndex);
+    }
+    RawLex.LexFromRawLexer(RawTok);
+  }
+}
+
+static void findMatchingTextualOccurrences(
+    Preprocessor &PP, const SourceManager &SM, const LangOptions &LangOpts,
+    ArrayRef<IndexedSymbol> Symbols,
+    llvm::function_ref<void(OldSymbolOccurrence::OccurrenceKind,
+                            ArrayRef<SourceLocation> Locations,
+                            unsigned SymbolIndex)>
+        MatchHandler) {
+  const llvm::MemoryBuffer *FromFile = SM.getBuffer(SM.getMainFileID());
+  Lexer RawLex(SM.getMainFileID(), FromFile, SM, LangOpts);
+  RawLex.SetCommentRetentionState(true);
+
+  llvm::SmallVector<TextualMatchOccurrence, 4> CommentMatches;
+  llvm::SmallVector<SelectorParser, 2> SelectorParsers;
+  for (const auto &Symbol : llvm::enumerate(Symbols)) {
+    if (Symbol.value().IsObjCSelector)
+      SelectorParsers.push_back(
+          SelectorParser(Symbol.value().Name, Symbol.index()));
+  }
+  llvm::SmallVector<StringLiteralTextualParser, 1> StringParsers;
+  for (const auto &Symbol : llvm::enumerate(Symbols)) {
+    if (Symbol.value().SearchForStringLiteralOccurrences)
+      StringParsers.push_back(
+          StringLiteralTextualParser(Symbol.value().Name, Symbol.index()));
+  }
+
+  Token RawTok;
+  RawLex.LexFromRawLexer(RawTok);
+  bool ScanNonCommentTokens =
+      !SelectorParsers.empty() || !StringParsers.empty();
+  while (RawTok.isNot(tok::eof)) {
+    if (RawTok.is(tok::comment)) {
+      SourceRange Range(RawTok.getLocation(), RawTok.getEndLoc());
+      StringRef Comment = Lexer::getSourceText(
+          CharSourceRange::getCharRange(Range), SM, LangOpts);
+      collectTextualMatchesInComment(Symbols, Range.getBegin(), Comment,
+                                     CommentMatches);
+      if (!CommentMatches.empty()) {
+        findTextualMatchesInComment(SM, LangOpts, Symbols, CommentMatches,
+                                    Range, MatchHandler);
+        CommentMatches.clear();
+      }
+    } else if (ScanNonCommentTokens) {
+      for (auto &Parser : SelectorParsers) {
+        if (Parser.handleToken(RawTok))
+          MatchHandler(OldSymbolOccurrence::MatchingSelector,
+                       Parser.SelectorLocations, Parser.SymbolIndex);
+      }
+      for (auto &Parser : StringParsers) {
+        SourceLocation Loc = Parser.handleToken(RawTok, PP);
+        if (Loc.isValid())
+          MatchHandler(OldSymbolOccurrence::MatchingStringLiteral, Loc,
+                       Parser.SymbolIndex);
+      }
+    }
+    RawLex.LexFromRawLexer(RawTok);
+  }
+}
+
+static void findInclusionDirectiveOccurrence(
+    const IndexedOccurrence &Occurrence, const IndexedSymbol &Symbol,
+    unsigned SymbolIndex, SourceManager &SM, const LangOptions &LangOpts,
+    IndexedFileOccurrenceConsumer &Consumer) {
+  if (!Occurrence.Line || !Occurrence.Column)
+    return; // Ignore any invalid indexed locations.
+
+  SourceLocation Loc = SM.translateLineCol(SM.getMainFileID(), Occurrence.Line,
+                                           Occurrence.Column);
+  if (Loc.isInvalid())
+    return;
+  unsigned Offset = SM.getDecomposedLoc(Loc).second;
+  const llvm::MemoryBuffer *File = SM.getBuffer(SM.getMainFileID());
+
+  InclusionLexer RawLex(Loc, LangOpts, File->getBufferStart() + Offset,
+                        File->getBufferEnd());
+  Token RawTok;
+  RawLex.LexFromRawLexer(RawTok);
+  if (RawTok.isNot(tok::hash))
+    return;
+  // include/import
+  RawLex.LexFromRawLexer(RawTok);
+  if (RawTok.isNot(tok::raw_identifier))
+    return;
+  // string literal/angled literal.
+  RawLex.setParsingPreprocessorDirective(true);
+  RawLex.LexIncludeFilename(RawTok);
+  if (RawTok.isNot(tok::string_literal) &&
+      RawTok.isNot(tok::angle_string_literal))
+    return;
+  StringRef Filename = llvm::sys::path::filename(
+      StringRef(RawTok.getLiteralData(), RawTok.getLength())
+          .drop_front()
+          .drop_back());
+  size_t NameOffset = Filename.rfind_lower(Symbol.Name[0]);
+  if (NameOffset == StringRef::npos)
+    return;
+  OldSymbolOccurrence Result(
+      OldSymbolOccurrence::MatchingFilename,
+      /*IsMacroExpansion=*/false, SymbolIndex,
+      RawTok.getLocation().getLocWithOffset(
+          NameOffset + (Filename.data() - RawTok.getLiteralData())));
+  Consumer.handleOccurrence(Result, SM, LangOpts);
+}
+
+void IndexedFileOccurrenceProducer::ExecuteAction() {
+  Preprocessor &PP = getCompilerInstance().getPreprocessor();
+  PP.EnterMainSourceFile();
+
+  SourceManager &SM = getCompilerInstance().getSourceManager();
+  const LangOptions &LangOpts = getCompilerInstance().getLangOpts();
+  if (IsMultiPiece) {
+    findObjCMultiPieceSelectorOccurrences(getCompilerInstance(), Symbols,
+                                          Consumer);
+  } else {
+    for (const auto &Symbol : llvm::enumerate(Symbols)) {
+      for (const IndexedOccurrence &Occurrence :
+           Symbol.value().IndexedOccurrences) {
+        if (Occurrence.Kind == IndexedOccurrence::InclusionDirective) {
+          findInclusionDirectiveOccurrence(Occurrence, Symbol.value(),
+                                           Symbol.index(), SM, LangOpts,
+                                           Consumer);
+          continue;
+        }
+        SourceRange SymbolRange;
+        MatchKind Match = checkOccurrence(Occurrence, Symbol.value(), SM,
+                                          LangOpts, SymbolRange,
+                                          /*AllowObjCSetterProp=*/true);
+        if (Match == MatchKind::None)
+          continue;
+        llvm::SmallVector<SourceLocation, 2> Locs;
+        Locs.push_back(SymbolRange.getBegin());
+        bool IsImpProp = Match == MatchKind::SourcePropSetterMatch;
+        if (IsImpProp)
+          Locs.push_back(SymbolRange.getEnd());
+        OldSymbolOccurrence Result(
+            IsImpProp ? OldSymbolOccurrence::MatchingImplicitProperty
+                      : OldSymbolOccurrence::MatchingSymbol,
+            /*IsMacroExpansion=*/Match == MatchKind::MacroExpansion,
+            Symbol.index(), Locs);
+        Consumer.handleOccurrence(Result, SM, LangOpts);
+      }
+    }
+  }
+
+  if (Options && Options->get(option::AvoidTextualMatches()))
+    return;
+  findMatchingTextualOccurrences(
+      PP, SM, LangOpts, Symbols,
+      [&](OldSymbolOccurrence::OccurrenceKind Kind,
+          ArrayRef<SourceLocation> Locations, unsigned SymbolIndex) {
+        OldSymbolOccurrence Result(Kind, /*IsMacroExpansion=*/false,
+                                   SymbolIndex, Locations);
+        Consumer.handleOccurrence(Result, SM, LangOpts);
+      });
+}
+
+namespace {
+
+/// Maps from source locations to the indexed occurrences.
+typedef llvm::DenseMap<unsigned, std::pair<IndexedOccurrence, unsigned>>
+    SourceLocationsToIndexedOccurrences;
+
+enum class ObjCSymbolSelectorKind { MessageSend, MethodDecl };
+
+} // end anonymous namespace
+
+static bool isMatchingSelectorName(const Token &Tok, const Token &Next,
+                                   StringRef NamePiece) {
+  if (NamePiece.empty())
+    return Tok.is(tok::colon);
+  return Tok.is(tok::raw_identifier) && Next.is(tok::colon) &&
+         Tok.getRawIdentifier() == NamePiece;
+}
+
+static bool
+findObjCSymbolSelectorPieces(ArrayRef<Token> Tokens, const OldSymbolName &Name,
+                             SmallVectorImpl<SourceLocation> &Pieces,
+                             ObjCSymbolSelectorKind Kind) {
+  assert(!Tokens.empty() && "no tokens");
+  assert(Name[0].empty() || Tokens[0].getRawIdentifier() == Name[0]);
+  assert(Name.size() > 1);
+  assert(Pieces.empty());
+
+  Pieces.push_back(Tokens[0].getLocation());
+
+  // We have to track square brackets, parens and braces as we want to skip the
+  // tokens inside them. This ensures that we don't use identical selector
+  // pieces in inner message sends, blocks, lambdas and @selector expressions.
+  unsigned SquareCount = 0;
+  unsigned ParenCount = 0;
+  unsigned BraceCount = 0;
+
+  // Start looking for the next selector piece.
+  unsigned Last = Tokens.size() - 1;
+  // Skip the ':' or any other token after the first selector piece token.
+  for (unsigned Index = Name[0].empty() ? 1 : 2; Index < Last; ++Index) {
+    const auto &Tok = Tokens[Index];
+
+    bool NoScoping = SquareCount == 0 && BraceCount == 0 && ParenCount == 0;
+    if (NoScoping &&
+        isMatchingSelectorName(Tok, Tokens[Index + 1], Name[Pieces.size()])) {
+      if (!Name[Pieces.size()].empty()) {
+        // Skip the ':' after the name. This ensures that it won't match a
+        // follow-up selector piece with an empty name.
+        ++Index;
+      }
+      Pieces.push_back(Tok.getLocation());
+      // All the selector pieces have been found.
+      if (Pieces.size() == Name.size())
+        return true;
+    } else if (Tok.is(tok::r_square)) {
+      // Stop scanning at the end of the message send.
+      // Also account for spurious ']' in blocks or lambdas.
+      if (Kind == ObjCSymbolSelectorKind::MessageSend && !SquareCount &&
+          !BraceCount)
+        break;
+      if (SquareCount)
+        --SquareCount;
+    } else if (Tok.is(tok::l_square))
+      ++SquareCount;
+    else if (Tok.is(tok::l_paren))
+      ++ParenCount;
+    else if (Tok.is(tok::r_paren)) {
+      if (!ParenCount)
+        break;
+      --ParenCount;
+    } else if (Tok.is(tok::l_brace)) {
+      // Stop scanning at the start of the of the method's body.
+      // Also account for any spurious blocks inside argument parameter types
+      // or parameter attributes.
+      if (Kind == ObjCSymbolSelectorKind::MethodDecl && !BraceCount &&
+          !ParenCount)
+        break;
+      ++BraceCount;
+    } else if (Tok.is(tok::r_brace)) {
+      if (!BraceCount)
+        break;
+      --BraceCount;
+    }
+    // Stop scanning at the end of the method's declaration.
+    if (Kind == ObjCSymbolSelectorKind::MethodDecl && NoScoping &&
+        (Tok.is(tok::semi) || Tok.is(tok::minus) || Tok.is(tok::plus)))
+      break;
+  }
+  return false;
+}
+
+// Scan the file and find multi-piece selector occurrences in a token stream.
+static void
+findObjCMultiPieceSelectorOccurrences(CompilerInstance &CI,
+                                      ArrayRef<IndexedSymbol> Symbols,
+                                      IndexedFileOccurrenceConsumer &Consumer) {
+  for (const auto &Symbol : Symbols) {
+    (void)Symbol;
+    assert(Symbol.Name.size() > 1 && "Not a multi-piece symbol!");
+  }
+
+  SourceManager &SM = CI.getSourceManager();
+  const LangOptions &LangOpts = CI.getLangOpts();
+  // Create a mapping from source locations to the indexed occurrences.
+  SourceLocationsToIndexedOccurrences MappedIndexedOccurrences;
+  for (const auto &Symbol : llvm::enumerate(Symbols)) {
+    for (const IndexedOccurrence &Occurrence :
+         Symbol.value().IndexedOccurrences) {
+      // Selectors and names in #includes shouldn't really mix.
+      if (Occurrence.Kind == IndexedOccurrence::InclusionDirective)
+        continue;
+      SourceRange SymbolRange;
+      MatchKind Match = checkOccurrence(Occurrence, Symbol.value(), SM,
+                                        LangOpts, SymbolRange);
+      if (Match == MatchKind::None)
+        continue;
+      SourceLocation Loc = SymbolRange.getBegin();
+      if (Match == MatchKind::MacroExpansion) {
+        OldSymbolOccurrence Result(OldSymbolOccurrence::MatchingSymbol,
+                                   /*IsMacroExpansion=*/true, Symbol.index(),
+                                   Loc);
+        Consumer.handleOccurrence(Result, SM, LangOpts);
+        continue;
+      }
+      MappedIndexedOccurrences.try_emplace(Loc.getRawEncoding(), Occurrence,
+                                           Symbol.index());
+    }
+  }
+
+  // Lex the file and look for tokens.
+  // Start lexing the specified input file.
+  const llvm::MemoryBuffer *FromFile = SM.getBuffer(SM.getMainFileID());
+  Lexer RawLex(SM.getMainFileID(), FromFile, SM, LangOpts);
+
+  std::vector<Token> Tokens;
+  bool SaveTokens = false;
+  Token RawTok;
+  RawLex.LexFromRawLexer(RawTok);
+  while (RawTok.isNot(tok::eof)) {
+    // Start saving tokens only when we've got a match
+    if (!SaveTokens) {
+      if (MappedIndexedOccurrences.find(
+              RawTok.getLocation().getRawEncoding()) !=
+          MappedIndexedOccurrences.end())
+        SaveTokens = true;
+    }
+    if (SaveTokens)
+      Tokens.push_back(RawTok);
+    RawLex.LexFromRawLexer(RawTok);
+  }
+
+  for (const auto &I : llvm::enumerate(Tokens)) {
+    const auto &Tok = I.value();
+    auto It = MappedIndexedOccurrences.find(Tok.getLocation().getRawEncoding());
+    if (It == MappedIndexedOccurrences.end())
+      continue;
+    unsigned SymbolIndex = It->second.second;
+    if (Tok.getKind() != tok::raw_identifier &&
+        !(Symbols[SymbolIndex].Name[0].empty() && Tok.is(tok::colon)))
+      continue;
+    const IndexedOccurrence &Occurrence = It->second.first;
+
+    // Scan the source for the remaining selector pieces.
+    SmallVector<SourceLocation, 4> SelectorPieces;
+    ObjCSymbolSelectorKind Kind =
+        Occurrence.Kind == IndexedOccurrence::IndexedObjCMessageSend
+            ? ObjCSymbolSelectorKind::MessageSend
+            : ObjCSymbolSelectorKind::MethodDecl;
+    if (findObjCSymbolSelectorPieces(
+            llvm::makeArrayRef(Tokens).drop_front(I.index()),
+            Symbols[SymbolIndex].Name, SelectorPieces, Kind)) {
+      OldSymbolOccurrence Result(OldSymbolOccurrence::MatchingSymbol,
+                                 /*IsMacroExpansion=*/false, SymbolIndex,
+                                 std::move(SelectorPieces));
+      Consumer.handleOccurrence(Result, SM, LangOpts);
+    }
+  }
+}
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/RenamedSymbol.cpp b/lib/Tooling/Refactor/RenamedSymbol.cpp
index e69de29bb2..c4f7d34032 100644
--- a/lib/Tooling/Refactor/RenamedSymbol.cpp
+++ b/lib/Tooling/Refactor/RenamedSymbol.cpp
@@ -0,0 +1,42 @@
+//===--- RenamedSymbol.cpp - ----------------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RenamedSymbol.h"
+#include "clang/AST/DeclObjC.h"
+#include <algorithm>
+
+using namespace clang;
+
+namespace clang {
+namespace tooling {
+namespace rename {
+
+Symbol::Symbol(const NamedDecl *FoundDecl, unsigned SymbolIndex,
+               const LangOptions &LangOpts)
+    : Name(FoundDecl->getNameAsString(), LangOpts), SymbolIndex(SymbolIndex),
+      FoundDecl(FoundDecl) {
+  if (const auto *MD = dyn_cast<ObjCMethodDecl>(FoundDecl))
+    ObjCSelector = MD->getSelector();
+}
+
+bool operator<(const OldSymbolOccurrence &LHS, const OldSymbolOccurrence &RHS) {
+  assert(!LHS.Locations.empty() && !RHS.Locations.empty());
+  return LHS.Locations[0] < RHS.Locations[0];
+}
+
+bool operator==(const OldSymbolOccurrence &LHS,
+                const OldSymbolOccurrence &RHS) {
+  return LHS.Kind == RHS.Kind && LHS.SymbolIndex == RHS.SymbolIndex &&
+         std::equal(LHS.Locations.begin(), LHS.Locations.end(),
+                    RHS.Locations.begin());
+}
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/RenamingOperation.cpp b/lib/Tooling/Refactor/RenamingOperation.cpp
index e69de29bb2..6c6d1284f5 100644
--- a/lib/Tooling/Refactor/RenamingOperation.cpp
+++ b/lib/Tooling/Refactor/RenamingOperation.cpp
@@ -0,0 +1,99 @@
+//===--- RenamingOperation.cpp - ------------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/RenamingOperation.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/Basic/IdentifierTable.h"
+#include "clang/Lex/Lexer.h"
+#include "clang/Tooling/Refactor/SymbolOperation.h"
+
+using namespace clang;
+
+/// \brief Lexes the given name string.
+///
+/// \return False if the name was consumed fully, true otherwise.
+static bool lexNameString(StringRef Name, Token &Result,
+                          const LangOptions &LangOpts) {
+  Lexer Lex(SourceLocation(), LangOpts, Name.data(), Name.data(),
+            Name.data() + Name.size());
+  return !Lex.LexFromRawLexer(Result);
+}
+
+namespace clang {
+namespace tooling {
+namespace rename {
+
+bool isNewNameValid(const OldSymbolName &NewName, bool IsSymbolObjCSelector,
+                    IdentifierTable &IDs, const LangOptions &LangOpts) {
+  Token Tok;
+  if (IsSymbolObjCSelector) {
+    // Check if the name is a valid selector.
+    for (const auto &Name : NewName.strings()) {
+      // Lex the name and verify that it was fully consumed. Then make sure that
+      // it's a valid identifier.
+      if (lexNameString(Name, Tok, LangOpts) || !Tok.isAnyIdentifier())
+        return false;
+    }
+    return true;
+  }
+
+  for (const auto &Name : NewName.strings()) {
+    // Lex the name and verify that it was fully consumed. Then make sure that
+    // it's a valid identifier that's also not a language keyword.
+    if (lexNameString(Name, Tok, LangOpts) || !Tok.isAnyIdentifier() ||
+        !tok::isAnyIdentifier(IDs.get(Name).getTokenID()))
+      return false;
+  }
+  return true;
+}
+
+bool isNewNameValid(const OldSymbolName &NewName,
+                    const SymbolOperation &Operation, IdentifierTable &IDs,
+                    const LangOptions &LangOpts) {
+  assert(!Operation.symbols().empty());
+  return isNewNameValid(NewName,
+                        Operation.symbols().front().ObjCSelector.hasValue(),
+                        IDs, LangOpts);
+}
+
+void determineNewNames(OldSymbolName NewName, const SymbolOperation &Operation,
+                       SmallVectorImpl<OldSymbolName> &NewNames,
+                       const LangOptions &LangOpts) {
+  auto Symbols = Operation.symbols();
+  assert(!Symbols.empty());
+  NewNames.push_back(std::move(NewName));
+  if (const auto *PropertyDecl =
+          dyn_cast<ObjCPropertyDecl>(Symbols.front().FoundDecl)) {
+    assert(NewNames.front().size() == 1 &&
+           "Property's name should have one string only");
+    StringRef PropertyName = NewNames.front()[0];
+    Symbols = Symbols.drop_front();
+
+    auto AddName = [&](const NamedDecl *D, StringRef Name) {
+      assert(Symbols.front().FoundDecl == D && "decl is missing");
+      NewNames.push_back(OldSymbolName(Name, LangOpts));
+      Symbols = Symbols.drop_front();
+    };
+
+    if (!PropertyDecl->hasExplicitGetterName()) {
+      if (const auto *Getter = PropertyDecl->getGetterMethodDecl())
+        AddName(Getter, PropertyName);
+    }
+    if (!PropertyDecl->hasExplicitSetterName()) {
+      if (const auto *Setter = PropertyDecl->getSetterMethodDecl()) {
+        auto SetterName = SelectorTable::constructSetterName(PropertyName);
+        AddName(Setter, SetterName);
+      }
+    }
+  }
+}
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/SourceLocationUtilities.cpp b/lib/Tooling/Refactor/SourceLocationUtilities.cpp
index e69de29bb2..0a0c4cdc9d 100644
--- a/lib/Tooling/Refactor/SourceLocationUtilities.cpp
+++ b/lib/Tooling/Refactor/SourceLocationUtilities.cpp
@@ -0,0 +1,260 @@
+//===--- SourceLocationUtilities.cpp - Source location helper functions ---===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "SourceLocationUtilities.h"
+#include "clang/AST/Stmt.h"
+#include "clang/Lex/Lexer.h"
+#include <limits>
+
+namespace clang {
+namespace tooling {
+
+SourceLocation findLastLocationOfSourceConstruct(SourceLocation HeaderEnd,
+                                                 const Stmt *Body,
+                                                 const SourceManager &SM) {
+  SourceLocation BodyStart = SM.getSpellingLoc(Body->getLocStart());
+  unsigned BodyLine = SM.getSpellingLineNumber(BodyStart);
+  unsigned HeaderLine = SM.getSpellingLineNumber(HeaderEnd);
+
+  if (BodyLine > HeaderLine) {
+    // The Last location on the previous line if the body is not on the same
+    // line as the last known location.
+    SourceLocation LineLocThatPrecedesBody =
+        SM.translateLineCol(SM.getFileID(BodyStart), BodyLine - 1,
+                            std::numeric_limits<unsigned>::max());
+    if (LineLocThatPrecedesBody.isValid())
+      return LineLocThatPrecedesBody;
+  }
+  // We want to include the location of the '{'.
+  return isa<CompoundStmt>(Body) ? BodyStart : BodyStart.getLocWithOffset(-1);
+}
+
+SourceLocation findFirstLocationOfSourceConstruct(SourceLocation HeaderStart,
+                                                  const Stmt *PreviousBody,
+                                                  const SourceManager &SM) {
+  if (!isa<CompoundStmt>(PreviousBody))
+    return HeaderStart;
+  SourceLocation BodyEnd = SM.getSpellingLoc(PreviousBody->getLocEnd());
+  unsigned BodyLine = SM.getSpellingLineNumber(BodyEnd);
+  unsigned HeaderLine = SM.getSpellingLineNumber(HeaderStart);
+  if (BodyLine >= HeaderLine)
+    return BodyEnd;
+  return HeaderStart;
+}
+
+bool isLocationInAnyRange(SourceLocation Location, ArrayRef<SourceRange> Ranges,
+                          const SourceManager &SM) {
+  for (const SourceRange &Range : Ranges) {
+    if (!isPointWithin(Location, Range.getBegin(), Range.getEnd(), SM))
+      continue;
+    return true;
+  }
+  return false;
+}
+
+SourceLocation getPreciseTokenLocEnd(SourceLocation Loc,
+                                     const SourceManager &SM,
+                                     const LangOptions &LangOpts) {
+  return Lexer::getLocForEndOfToken(Loc, 0, SM, LangOpts);
+}
+
+SourceLocation findClosingParenLocEnd(SourceLocation LastKnownLoc,
+                                      const SourceManager &SM,
+                                      const LangOptions &LangOpts) {
+  return Lexer::findLocationAfterToken(
+      LastKnownLoc, tok::r_paren, SM, LangOpts,
+      /*SkipTrailingWhitespaceAndNewLine=*/false);
+}
+
+SourceRange getRangeOfNextToken(SourceLocation Loc, tok::TokenKind Kind,
+                                const SourceManager &SM,
+                                const LangOptions &LangOpts) {
+  SourceLocation NextLoc =
+      Lexer::findLocationAfterToken(Loc, Kind, SM, LangOpts,
+                                    /*SkipTrailingWhitespaceAndNewLine=*/false);
+  if (NextLoc.isInvalid())
+    return SourceRange();
+  return SourceRange(
+      Lexer::GetBeginningOfToken(NextLoc.getLocWithOffset(-1), SM, LangOpts),
+      NextLoc);
+}
+
+SourceLocation findLastNonCompoundLocation(const Stmt *S) {
+  const auto *CS = dyn_cast<CompoundStmt>(S);
+  if (!CS)
+    return S->getLocEnd();
+  return CS->body_back() ? CS->body_back()->getLocEnd() : SourceLocation();
+}
+
+bool areOnSameLine(SourceLocation Loc1, SourceLocation Loc2,
+                   const SourceManager &SM) {
+  return !Loc1.isMacroID() && !Loc2.isMacroID() &&
+         SM.getSpellingLineNumber(Loc1) == SM.getSpellingLineNumber(Loc2);
+}
+
+SourceLocation
+getLastLineLocationUnlessItHasOtherTokens(SourceLocation SpellingLoc,
+                                          const SourceManager &SM,
+                                          const LangOptions &LangOpts) {
+  assert(!SpellingLoc.isMacroID() && "Expecting a spelling location");
+  SourceLocation NextTokenLoc =
+      Lexer::findNextTokenLocationAfterTokenAt(SpellingLoc, SM, LangOpts);
+  if (NextTokenLoc.isValid()) {
+    bool IsSameLine = areOnSameLine(SpellingLoc, NextTokenLoc, SM);
+    if (IsSameLine) {
+      // Could be a ';' on the same line, so try looking after the ';'
+      if (isSemicolonAtLocation(NextTokenLoc, SM, LangOpts))
+        return getLastLineLocationUnlessItHasOtherTokens(NextTokenLoc, SM,
+                                                         LangOpts);
+    } else {
+      SourceLocation LastLoc = SM.translateLineCol(
+          SM.getFileID(SpellingLoc), SM.getSpellingLineNumber(SpellingLoc),
+          std::numeric_limits<unsigned>::max());
+      if (LastLoc.isValid())
+        return LastLoc;
+    }
+  }
+  return getPreciseTokenLocEnd(SpellingLoc, SM, LangOpts);
+}
+
+bool isSemicolonAtLocation(SourceLocation TokenLoc, const SourceManager &SM,
+                           const LangOptions &LangOpts) {
+  return Lexer::getSourceText(
+             CharSourceRange::getTokenRange(TokenLoc, TokenLoc), SM,
+             LangOpts) == ";";
+}
+
+SourceRange trimSelectionRange(SourceRange Range, const SourceManager &SM,
+                               const LangOptions &LangOpts) {
+  bool IsInvalid = false;
+  StringRef Text = Lexer::getSourceText(CharSourceRange::getCharRange(Range),
+                                        SM, LangOpts, &IsInvalid);
+  if (IsInvalid || Text.empty())
+    return Range;
+  assert(Range.getBegin().isFileID() && "Not a file range!");
+
+  std::string Source = Text.str();
+  Lexer Lex(Range.getBegin(), LangOpts, Source.c_str(), Source.c_str(),
+            Source.c_str() + Source.size());
+  // Get comment tokens as well.
+  Lex.SetCommentRetentionState(true);
+  SourceLocation StartLoc, EndLoc;
+  while (true) {
+    Token Tok;
+    Lex.LexFromRawLexer(Tok);
+    if (Tok.getKind() == tok::eof)
+      break;
+    if (StartLoc.isInvalid())
+      StartLoc = Tok.getLocation();
+    if (Tok.getKind() != tok::semi)
+      EndLoc = Tok.getEndLoc();
+  }
+  return StartLoc.isValid() && EndLoc.isValid() ? SourceRange(StartLoc, EndLoc)
+                                                : SourceRange();
+}
+
+/// Tokenize the given file and check if it contains a comment that ends at the
+/// given location.
+static SourceLocation findCommentThatEndsAt(FileID FID,
+                                            SourceLocation StartOfFile,
+                                            const SourceManager &SM,
+                                            const LangOptions &LangOpts,
+                                            SourceLocation ExpectedEndLoc) {
+  // Try to load the file buffer.
+  bool InvalidTemp = false;
+  StringRef File = SM.getBufferData(FID, &InvalidTemp);
+  if (InvalidTemp)
+    return SourceLocation();
+
+  // Search for the comment that ends at the given location.
+  Lexer Lex(StartOfFile, LangOpts, File.begin(), File.begin(), File.end());
+  Lex.SetCommentRetentionState(true);
+  Token Tok;
+  while (!Lex.LexFromRawLexer(Tok)) {
+    if (Tok.is(tok::comment) && Tok.getEndLoc() == ExpectedEndLoc)
+      return Tok.getLocation();
+  }
+  // Find the token.
+  return SourceLocation();
+}
+
+SourceLocation getLocationOfPrecedingComment(SourceLocation Location,
+                                             const SourceManager &SM,
+                                             const LangOptions &LangOpts) {
+  SourceLocation PrevResult = Location;
+  SourceLocation Result = Location;
+  if (Result.isMacroID())
+    Result = SM.getExpansionLoc(Result);
+  FileID FID = SM.getFileID(Result);
+  SourceLocation StartOfFile = SM.getLocForStartOfFile(FID);
+  Token Tok;
+  Tok.setKind(tok::unknown);
+  SourceLocation TokenLoc = Result;
+  auto GetPreviousToken = [&]() -> bool {
+    TokenLoc =
+        Lexer::GetBeginningOfToken(TokenLoc.getLocWithOffset(-1), SM, LangOpts);
+    return !Lexer::getRawToken(TokenLoc, Tok, SM, LangOpts);
+  };
+  // Look for a comment token.
+  while (TokenLoc != StartOfFile) {
+    bool LocHasToken = GetPreviousToken();
+    if (LocHasToken && Tok.is(tok::slash)) {
+      // Check if this  the end of a multiline '/*' comment before returning.
+      SourceLocation CommentLoc = findCommentThatEndsAt(
+          FID, StartOfFile, SM, LangOpts, Tok.getEndLoc());
+      return CommentLoc.isInvalid() ? Result : CommentLoc;
+    }
+    if (LocHasToken && Tok.isNot(tok::comment))
+      break;
+    if (!LocHasToken)
+      continue;
+    // We found a preceding comment. Check if there are other preceding
+    // comments.
+    PrevResult = Result;
+    Result = Tok.getLocation();
+    while (TokenLoc != StartOfFile) {
+      bool LocHasToken = GetPreviousToken();
+      if (LocHasToken && Tok.isNot(tok::comment)) {
+        // Reset the result to the previous location if this comment trails
+        // another token on the same line.
+        if (SM.getSpellingLineNumber(Tok.getEndLoc()) ==
+            SM.getSpellingLineNumber(Result))
+          Result = PrevResult;
+        break;
+      }
+      if (!LocHasToken)
+        continue;
+      // The location of this comment is accepted only when the next comment
+      // is located immediately after this comment.
+      if (SM.getSpellingLineNumber(Tok.getEndLoc()) !=
+          SM.getSpellingLineNumber(Result) - 1)
+        break;
+      PrevResult = Result;
+      Result = Tok.getLocation();
+    }
+    break;
+  }
+  return Result;
+}
+
+SourceLocation getLocationOfPrecedingToken(SourceLocation Loc,
+                                           const SourceManager &SM,
+                                           const LangOptions &LangOpts) {
+  SourceLocation Result = Loc;
+  if (Result.isMacroID())
+    Result = SM.getExpansionLoc(Result);
+  FileID FID = SM.getFileID(Result);
+  SourceLocation StartOfFile = SM.getLocForStartOfFile(FID);
+  if (Loc == StartOfFile)
+    return SourceLocation();
+  return Lexer::GetBeginningOfToken(Result.getLocWithOffset(-1), SM, LangOpts);
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/SourceLocationUtilities.h b/lib/Tooling/Refactor/SourceLocationUtilities.h
index e69de29bb2..ba7425bf88 100644
--- a/lib/Tooling/Refactor/SourceLocationUtilities.h
+++ b/lib/Tooling/Refactor/SourceLocationUtilities.h
@@ -0,0 +1,174 @@
+//===--- SourceLocationUtilities.h - Source location helper functions -----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_SOURCE_LOCATION_UTILITIES_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_SOURCE_LOCATION_UTILITIES_H
+
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Basic/TokenKinds.h"
+
+namespace clang {
+
+class Stmt;
+class LangOptions;
+
+namespace tooling {
+
+inline bool isPairOfFileLocations(SourceLocation Start, SourceLocation End) {
+  return Start.isValid() && Start.isFileID() && End.isValid() && End.isFileID();
+}
+
+/// Return true if the Point is within Start and End.
+inline bool isPointWithin(SourceLocation Location, SourceLocation Start,
+                          SourceLocation End, const SourceManager &SM) {
+  return Location == Start || Location == End ||
+         (SM.isBeforeInTranslationUnit(Start, Location) &&
+          SM.isBeforeInTranslationUnit(Location, End));
+}
+
+/// Return true if the two given ranges overlap with each other.
+inline bool areRangesOverlapping(SourceRange R1, SourceRange R2,
+                                 const SourceManager &SM) {
+  return isPointWithin(R1.getBegin(), R2.getBegin(), R2.getEnd(), SM) ||
+         isPointWithin(R2.getBegin(), R1.getBegin(), R1.getEnd(), SM);
+}
+
+/// \brief Return the source location that can be considered the last location
+/// of the source construct before its body.
+///
+/// The returned location is determined using the following rules:
+///
+/// 1) If the source construct has a compound body that starts on the same line,
+///    then this function will return the location of the opening '{'.
+///
+///    if (condition) {
+///                   ^
+///
+/// 2) If the source construct's body is not a compound statement that starts
+///    on the same line, then this function will return the location just before
+///    the starting location of the body.
+///
+///    if (condition) foo()
+///                  ^
+///
+/// 3) Otherwise, this function will return the last location on the line prior
+///    to the the line on which the body starts.
+///
+///    if (condition)
+///                  ^
+///      foo()
+///
+/// \param HeaderEnd The last known location of the pre-body portion of the
+/// source construct. For example, for an if statement, HeaderEnd should
+/// be the ending location of its conditional expression.
+SourceLocation findLastLocationOfSourceConstruct(SourceLocation HeaderEnd,
+                                                 const Stmt *Body,
+                                                 const SourceManager &SM);
+
+/// \brief Return the source location that can be considered the first location
+/// of the source construct prior to the previous portion of its body.
+///
+/// The returned location is determined using the following rules:
+///
+/// 1) If the source construct's body is a compound statement that ends
+///    on the same line, then this function will return the location of the
+///    closing '}'.
+///
+///    } else if (condition)
+///    ^
+///
+/// 2) Otherwise, this function will return the starting location of the source
+///    construct.
+///
+///      foo();
+///    else if (condition)
+///    ^
+///
+///    }
+///    else if (condition)
+///    ^
+///
+/// \param HeaderStart The first known location of the post-body portion of the
+/// source construct. For example, for an if statement, HeaderStart should
+/// be the starting location of the if keyword.
+SourceLocation findFirstLocationOfSourceConstruct(SourceLocation HeaderStart,
+                                                  const Stmt *PreviousBody,
+                                                  const SourceManager &SM);
+
+/// Return true if the given \p Location is within any range.
+bool isLocationInAnyRange(SourceLocation Location, ArrayRef<SourceRange> Ranges,
+                          const SourceManager &SM);
+
+/// Return the precise end location for the given token.
+SourceLocation getPreciseTokenLocEnd(SourceLocation Loc,
+                                     const SourceManager &SM,
+                                     const LangOptions &LangOpts);
+
+/// \brief Find the source location right after the location of the next ')'.
+///
+/// If the token that's located after \p LastKnownLoc isn't ')', then this
+/// function returns an invalid source location.
+SourceLocation findClosingParenLocEnd(SourceLocation LastKnownLoc,
+                                      const SourceManager &SM,
+                                      const LangOptions &LangOpts);
+
+/// Return the range of the next token if it has the given kind.
+SourceRange getRangeOfNextToken(SourceLocation Loc, tok::TokenKind Kind,
+                                const SourceManager &SM,
+                                const LangOptions &LangOpts);
+
+/// Return the end location of the body when \p S is a compound statement or an
+/// invalid location when \p S is an empty compound statement. Otherwise,
+/// return the end location of the given statement \p S.
+SourceLocation findLastNonCompoundLocation(const Stmt *S);
+
+/// Return true if the two locations are on the same line and aren't
+///  macro locations.
+bool areOnSameLine(SourceLocation Loc1, SourceLocation Loc2,
+                   const SourceManager &SM);
+
+/// Return the last location of the line which contains the given spellling
+/// location \p SpellingLoc unless that line has other tokens after the given
+/// location.
+SourceLocation
+getLastLineLocationUnlessItHasOtherTokens(SourceLocation SpellingLoc,
+                                          const SourceManager &SM,
+                                          const LangOptions &LangOpts);
+
+/// Return true if the token at the given location is a semicolon.
+bool isSemicolonAtLocation(SourceLocation TokenLoc, const SourceManager &SM,
+                           const LangOptions &LangOpts);
+
+/// Shrink the given range by ignoring leading whitespace and trailing
+/// whitespace and semicolons.
+///
+/// Returns an invalid source range if the source range consists of whitespace
+/// or semicolons only.
+SourceRange trimSelectionRange(SourceRange Range, const SourceManager &SM,
+                               const LangOptions &LangOpts);
+
+/// Return the source location of the conjoined comment(s) that precede the
+/// given location \p Loc, or the same location if there's no comment before
+/// \p Loc.
+SourceLocation getLocationOfPrecedingComment(SourceLocation Loc,
+                                             const SourceManager &SM,
+                                             const LangOptions &LangOpts);
+
+/// Return the source location of the token that comes before the token at the
+/// given location.
+SourceLocation getLocationOfPrecedingToken(SourceLocation Loc,
+                                           const SourceManager &SM,
+                                           const LangOptions &LangOpts);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_SOURCE_LOCATION_UTILITIES_H
diff --git a/lib/Tooling/Refactor/StmtUtils.cpp b/lib/Tooling/Refactor/StmtUtils.cpp
index e69de29bb2..d5644b29c1 100644
--- a/lib/Tooling/Refactor/StmtUtils.cpp
+++ b/lib/Tooling/Refactor/StmtUtils.cpp
@@ -0,0 +1,72 @@
+//===--- StmtUtils.cpp - Statement helper functions -----------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "StmtUtils.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/Stmt.h"
+#include "clang/AST/StmtCXX.h"
+#include "clang/AST/StmtObjC.h"
+#include "clang/Lex/Lexer.h"
+
+using namespace clang;
+
+SourceLocation
+clang::tooling::getLexicalEndLocForDecl(const Decl *D, const SourceManager &SM,
+                                        const LangOptions &LangOpts) {
+  if (!isa<ObjCImplDecl>(D))
+    return D->getSourceRange().getEnd();
+  auto AtEnd = D->getSourceRange().getEnd();
+  auto AdjustedEnd =
+      Lexer::findNextTokenLocationAfterTokenAt(AtEnd, SM, LangOpts);
+  return AdjustedEnd.isValid() ? AdjustedEnd : AtEnd;
+}
+
+bool clang::tooling::isSemicolonRequiredAfter(const Stmt *S) {
+  if (isa<CompoundStmt>(S))
+    return false;
+  if (const auto *If = dyn_cast<IfStmt>(S))
+    return isSemicolonRequiredAfter(If->getElse() ? If->getElse()
+                                                  : If->getThen());
+  if (const auto *While = dyn_cast<WhileStmt>(S))
+    return isSemicolonRequiredAfter(While->getBody());
+  if (const auto *For = dyn_cast<ForStmt>(S))
+    return isSemicolonRequiredAfter(For->getBody());
+  if (const auto *CXXFor = dyn_cast<CXXForRangeStmt>(S))
+    return isSemicolonRequiredAfter(CXXFor->getBody());
+  if (const auto *ObjCFor = dyn_cast<ObjCForCollectionStmt>(S))
+    return isSemicolonRequiredAfter(ObjCFor->getBody());
+  switch (S->getStmtClass()) {
+  case Stmt::SwitchStmtClass:
+  case Stmt::CXXTryStmtClass:
+  case Stmt::ObjCAtSynchronizedStmtClass:
+  case Stmt::ObjCAutoreleasePoolStmtClass:
+  case Stmt::ObjCAtTryStmtClass:
+    return false;
+  default:
+    return true;
+  }
+}
+
+static bool isAssignmentOperator(const Stmt *S) {
+  if (const auto *PseudoExpr = dyn_cast<PseudoObjectExpr>(S))
+    return isAssignmentOperator(PseudoExpr->getSyntacticForm());
+  if (const auto *BO = dyn_cast<BinaryOperator>(S))
+    return BO->isAssignmentOp();
+  return false;
+}
+
+bool clang::tooling::isLexicalExpression(const Stmt *S, const Stmt *Parent) {
+  if (!isa<Expr>(S))
+    return false;
+  // Assignment operators should be treated as statements unless they are a part
+  // of an expression.
+  if (isAssignmentOperator(S) && (!Parent || !isa<Expr>(Parent)))
+    return false;
+  return !cast<Expr>(S)->getType()->isVoidType();
+}
diff --git a/lib/Tooling/Refactor/StmtUtils.h b/lib/Tooling/Refactor/StmtUtils.h
index e69de29bb2..5bc319528e 100644
--- a/lib/Tooling/Refactor/StmtUtils.h
+++ b/lib/Tooling/Refactor/StmtUtils.h
@@ -0,0 +1,38 @@
+//===--- StmtUtils.h - Statement helper functions -------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_STMT_UTILS_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_STMT_UTILS_H
+
+#include "clang/Basic/SourceLocation.h"
+
+namespace clang {
+
+class Decl;
+class LangOptions;
+class Stmt;
+
+namespace tooling {
+
+SourceLocation getLexicalEndLocForDecl(const Decl *D, const SourceManager &SM,
+                                       const LangOptions &LangOpts);
+
+/// \brief Returns true if there should be a semicolon after the given
+/// statement.
+bool isSemicolonRequiredAfter(const Stmt *S);
+
+/// Returns true if the given statement \p S is an actual expression in the
+/// source. Assignment expressions are considered to be statements unless they
+/// are a part of an expression.
+bool isLexicalExpression(const Stmt *S, const Stmt *Parent);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_STMT_UTILS_H
diff --git a/lib/Tooling/Refactor/SymbolName.cpp b/lib/Tooling/Refactor/SymbolName.cpp
index e69de29bb2..2a02d1627e 100644
--- a/lib/Tooling/Refactor/SymbolName.cpp
+++ b/lib/Tooling/Refactor/SymbolName.cpp
@@ -0,0 +1,58 @@
+//===--- SymbolName.cpp - Clang refactoring library -----------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/SymbolName.h"
+#include "clang/Basic/LangOptions.h"
+#include "llvm/Support/raw_ostream.h"
+
+namespace clang {
+namespace tooling {
+
+static void initNames(std::vector<std::string> &Strings, StringRef Name,
+                      bool IsObjectiveCSelector) {
+  if (!IsObjectiveCSelector) {
+    Strings.push_back(Name.str());
+    return;
+  }
+  // Decompose an Objective-C selector name into multiple strings.
+  do {
+    auto StringAndName = Name.split(':');
+    Strings.push_back(StringAndName.first.str());
+    Name = StringAndName.second;
+  } while (!Name.empty());
+}
+
+OldSymbolName::OldSymbolName(StringRef Name, const LangOptions &LangOpts) {
+  initNames(Strings, Name, LangOpts.ObjC1);
+}
+
+OldSymbolName::OldSymbolName(StringRef Name, bool IsObjectiveCSelector) {
+  initNames(Strings, Name, IsObjectiveCSelector);
+}
+
+OldSymbolName::OldSymbolName(ArrayRef<StringRef> Name) {
+  for (const auto &Piece : Name)
+    Strings.push_back(Piece.str());
+}
+
+void OldSymbolName::print(raw_ostream &OS) const {
+  for (size_t I = 0, E = Strings.size(); I != E; ++I) {
+    if (I != 0)
+      OS << ':';
+    OS << Strings[I];
+  }
+}
+
+raw_ostream &operator<<(raw_ostream &OS, const OldSymbolName &N) {
+  N.print(OS);
+  return OS;
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/SymbolOccurrenceFinder.cpp b/lib/Tooling/Refactor/SymbolOccurrenceFinder.cpp
index e69de29bb2..aa90503847 100644
--- a/lib/Tooling/Refactor/SymbolOccurrenceFinder.cpp
+++ b/lib/Tooling/Refactor/SymbolOccurrenceFinder.cpp
@@ -0,0 +1,412 @@
+//===--- SymbolOccurrenceFinder.cpp - Clang refactoring library -----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Methods for finding all instances of a USR. Our strategy is very
+/// simple; we just compare the USR at every relevant AST node with the one
+/// provided.
+///
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/SymbolOccurrenceFinder.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DependentASTVisitor.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Index/USRGeneration.h"
+#include "clang/Lex/Lexer.h"
+#include "clang/Tooling/Refactor/USRFinder.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallVector.h"
+
+using namespace llvm;
+
+namespace clang {
+namespace tooling {
+namespace rename {
+
+namespace {
+// \brief This visitor recursively searches for all instances of a USR in a
+// translation unit and stores them for later usage.
+class SymbolOccurrenceFinderASTVisitor
+    : public DependentASTVisitor<SymbolOccurrenceFinderASTVisitor> {
+public:
+  explicit SymbolOccurrenceFinderASTVisitor(
+      const SymbolOperation &Operation, const ASTContext &Context,
+      std::vector<OldSymbolOccurrence> &Occurrences)
+      : Operation(Operation), Context(Context), Occurrences(Occurrences) {}
+
+  /// Returns a \c Symbol if the given declaration corresponds to the symbol
+  /// that we're looking for.
+  const Symbol *symbolForDecl(const Decl *D) const {
+    if (!D)
+      return nullptr;
+    std::string USR = getUSRForDecl(D);
+    return Operation.getSymbolForUSR(USR);
+  }
+
+  void checkDecl(const Decl *D, SourceLocation Loc,
+                 OldSymbolOccurrence::OccurrenceKind Kind =
+                     OldSymbolOccurrence::MatchingSymbol) {
+    if (!D)
+      return;
+    std::string USR = getUSRForDecl(D);
+    if (const Symbol *S = Operation.getSymbolForUSR(USR))
+      checkAndAddLocations(S->SymbolIndex, Loc, Kind);
+  }
+
+  // Declaration visitors:
+
+  bool VisitCXXConstructorDecl(clang::CXXConstructorDecl *ConstructorDecl) {
+    for (const auto *Initializer : ConstructorDecl->inits()) {
+      // Ignore implicit initializers.
+      if (!Initializer->isWritten())
+        continue;
+      if (const clang::FieldDecl *FieldDecl = Initializer->getMember())
+        checkDecl(FieldDecl, Initializer->getSourceLocation());
+    }
+    return true;
+  }
+
+  bool VisitNamedDecl(const NamedDecl *Decl) {
+    checkDecl(Decl, Decl->getLocation());
+    return true;
+  }
+
+  bool WalkUpFromTypedefNameDecl(const TypedefNameDecl *D) {
+    // Don't visit the NamedDecl for TypedefNameDecl.
+    return VisitTypedefNamedDecl(D);
+  }
+
+  bool VisitTypedefNamedDecl(const TypedefNameDecl *D) {
+    if (D->isTransparentTag()) {
+      if (const auto *Underlying = D->getUnderlyingType()->getAsTagDecl()) {
+        checkDecl(Underlying, D->getLocation());
+        return true;
+      }
+    }
+    return VisitNamedDecl(D);
+  }
+
+  bool WalkUpFromUsingDecl(const UsingDecl *D) {
+    // Don't visit the NamedDecl for UsingDecl.
+    return VisitUsingDecl(D);
+  }
+
+  bool VisitUsingDecl(const UsingDecl *D) {
+    for (const auto *Shadow : D->shadows()) {
+      const NamedDecl *UD = Shadow->getUnderlyingDecl();
+      if (UD->isImplicit() || UD == D)
+        continue;
+      if (const auto *FTD = dyn_cast<FunctionTemplateDecl>(UD)) {
+        UD = FTD->getTemplatedDecl();
+        if (!UD)
+          continue;
+      }
+      checkDecl(UD, D->getLocation());
+    }
+    return true;
+  }
+
+  bool WalkUpFromUsingDirectiveDecl(const UsingDirectiveDecl *D) {
+    // Don't visit the NamedDecl for UsingDirectiveDecl.
+    return VisitUsingDirectiveDecl(D);
+  }
+
+  bool VisitUsingDirectiveDecl(const UsingDirectiveDecl *D) {
+    checkDecl(D->getNominatedNamespaceAsWritten(), D->getLocation());
+    return true;
+  }
+
+  bool WalkUpFromUnresolvedUsingValueDecl(const UnresolvedUsingValueDecl *D) {
+    // Don't visit the NamedDecl for UnresolvedUsingValueDecl.
+    // FIXME: Can we try to lookup the name?
+    return true;
+  }
+
+  bool
+  WalkUpFromUnresolvedUsingTypenameDecl(const UnresolvedUsingTypenameDecl *D) {
+    // Don't visit the NamedDecl for UnresolvedUsingTypenameDecl.
+    // FIXME: Can we try to lookup the name?
+    return true;
+  }
+
+  bool WalkUpFromObjCMethodDecl(const ObjCMethodDecl *Decl) {
+    // Don't visit the NamedDecl for Objective-C methods.
+    return VisitObjCMethodDecl(Decl);
+  }
+
+  bool VisitObjCMethodDecl(const ObjCMethodDecl *Decl) {
+    const Symbol *S = symbolForDecl(Decl);
+    if (!S)
+      return true;
+    SmallVector<SourceLocation, 8> SelectorLocs;
+    Decl->getSelectorLocs(SelectorLocs);
+    checkAndAddLocations(S->SymbolIndex, SelectorLocs);
+    return true;
+  }
+
+  bool handleObjCProtocolList(const ObjCProtocolList &Protocols) {
+    for (auto It : enumerate(Protocols))
+      checkDecl(It.value(), Protocols.loc_begin()[It.index()]);
+    return true;
+  }
+
+  bool VisitObjCInterfaceDecl(const ObjCInterfaceDecl *Decl) {
+    if (!Decl->hasDefinition())
+      return true;
+    return handleObjCProtocolList(Decl->getReferencedProtocols());
+  }
+
+  bool VisitObjCProtocolDecl(const ObjCProtocolDecl *Decl) {
+    if (!Decl->hasDefinition())
+      return true;
+    return handleObjCProtocolList(Decl->getReferencedProtocols());
+  }
+
+  bool VisitObjCCategoryDecl(const ObjCCategoryDecl *Decl) {
+    checkDecl(Decl, Decl->getCategoryNameLoc());
+    // The location of the class name is the location of the declaration.
+    checkDecl(Decl->getClassInterface(), Decl->getLocation());
+    return handleObjCProtocolList(Decl->getReferencedProtocols());
+  }
+
+  bool VisitObjCCategoryImplDecl(const ObjCCategoryImplDecl *Decl) {
+    checkDecl(Decl, Decl->getCategoryNameLoc());
+    // The location of the class name is the location of the declaration.
+    checkDecl(Decl->getClassInterface(), Decl->getLocation());
+    return true;
+  }
+
+  bool VisitObjCCompatibleAliasDecl(const ObjCCompatibleAliasDecl *Decl) {
+    checkDecl(Decl->getClassInterface(), Decl->getClassInterfaceLoc());
+    return true;
+  }
+
+  bool VisitObjCPropertyDecl(const ObjCPropertyDecl *Decl) {
+    if (Decl->hasExplicitGetterName())
+      checkDecl(Decl->getGetterMethodDecl(), Decl->getGetterNameLoc());
+    if (Decl->hasExplicitSetterName())
+      checkDecl(Decl->getSetterMethodDecl(), Decl->getSetterNameLoc());
+    return true;
+  }
+
+  bool VisitObjCPropertyImplDecl(const ObjCPropertyImplDecl *Decl) {
+    checkDecl(Decl->getPropertyDecl(), Decl->getLocation());
+    if (Decl->isIvarNameSpecified())
+      checkDecl(Decl->getPropertyIvarDecl(), Decl->getPropertyIvarDeclLoc());
+    return true;
+  }
+
+  // Expression visitors:
+
+  bool VisitDeclRefExpr(const DeclRefExpr *Expr) {
+    checkDecl(Expr->getFoundDecl(), Expr->getLocation());
+    return true;
+  }
+
+  bool VisitMemberExpr(const MemberExpr *Expr) {
+    checkDecl(Expr->getFoundDecl().getDecl(), Expr->getMemberLoc());
+    return true;
+  }
+
+  bool VisitObjCMessageExpr(const ObjCMessageExpr *Expr) {
+    const Symbol *S = symbolForDecl(Expr->getMethodDecl());
+    if (!S)
+      return true;
+    SmallVector<SourceLocation, 8> SelectorLocs;
+    Expr->getSelectorLocs(SelectorLocs);
+    checkAndAddLocations(S->SymbolIndex, SelectorLocs);
+    return true;
+  }
+
+  bool VisitObjCProtocolExpr(const ObjCProtocolExpr *Expr) {
+    checkDecl(Expr->getProtocol(), Expr->getProtocolIdLoc());
+    return true;
+  }
+
+  bool VisitObjCIvarRefExpr(const ObjCIvarRefExpr *Expr) {
+    checkDecl(Expr->getDecl(), Expr->getLocation());
+    return true;
+  }
+
+  bool VisitObjCPropertyRefExpr(const ObjCPropertyRefExpr *Expr) {
+    if (Expr->isClassReceiver())
+      checkDecl(Expr->getClassReceiver(), Expr->getReceiverLocation());
+    if (Expr->isImplicitProperty()) {
+      // Class properties that are explicitly defined using @property
+      // declarations are represented implicitly as there is no ivar for class
+      // properties.
+      if (const ObjCMethodDecl *Getter = Expr->getImplicitPropertyGetter()) {
+        if (Getter->isClassMethod())
+          if (const auto *PD = Getter->getCanonicalDecl()->findPropertyDecl()) {
+            checkDecl(PD, Expr->getLocation());
+            return true;
+          }
+      }
+
+      checkDecl(Expr->getImplicitPropertyGetter(), Expr->getLocation(),
+                OldSymbolOccurrence::MatchingImplicitProperty);
+      // Add a manual location for a setter since a token like 'property' won't
+      // match the the name of the renamed symbol like 'setProperty'.
+      if (const auto *S = symbolForDecl(Expr->getImplicitPropertySetter()))
+        addLocation(S->SymbolIndex, Expr->getLocation(),
+                    OldSymbolOccurrence::MatchingImplicitProperty);
+      return true;
+    }
+    checkDecl(Expr->getExplicitProperty(), Expr->getLocation());
+    return true;
+  }
+
+  // Other visitors:
+
+  bool VisitTypeLoc(const TypeLoc Loc) {
+    TypedefTypeLoc TTL = Loc.getAs<TypedefTypeLoc>();
+    if (TTL) {
+      const auto *TND = TTL.getTypedefNameDecl();
+      if (TND->isTransparentTag()) {
+        if (const auto *Underlying = TND->getUnderlyingType()->getAsTagDecl()) {
+          checkDecl(Underlying, TTL.getNameLoc());
+          return true;
+        }
+      }
+      checkDecl(TND, TTL.getNameLoc());
+      return true;
+    }
+    TypeSpecTypeLoc TSTL = Loc.getAs<TypeSpecTypeLoc>();
+    if (TSTL) {
+      checkDecl(Loc.getType()->getAsTagDecl(), TSTL.getNameLoc());
+    }
+    if (const auto *TemplateTypeParm =
+            dyn_cast<TemplateTypeParmType>(Loc.getType())) {
+      checkDecl(TemplateTypeParm->getDecl(), Loc.getBeginLoc());
+    }
+    if (const auto *TemplateSpecType =
+            dyn_cast<TemplateSpecializationType>(Loc.getType())) {
+      checkDecl(TemplateSpecType->getTemplateName().getAsTemplateDecl(),
+                Loc.getBeginLoc());
+    }
+    return true;
+  }
+
+  bool VisitObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc Loc) {
+    checkDecl(Loc.getIFaceDecl(), Loc.getNameLoc());
+    return true;
+  }
+
+  bool VisitObjCObjectTypeLoc(ObjCObjectTypeLoc Loc) {
+    for (unsigned I = 0, E = Loc.getNumProtocols(); I < E; ++I)
+      checkDecl(Loc.getProtocol(I), Loc.getProtocolLoc(I));
+    return true;
+  }
+
+  bool VisitDependentSymbolReference(const NamedDecl *Symbol,
+                                     SourceLocation SymbolNameLoc) {
+    checkDecl(Symbol, SymbolNameLoc);
+    return true;
+  }
+
+  // Non-visitors:
+
+  // Namespace traversal:
+  void handleNestedNameSpecifierLoc(NestedNameSpecifierLoc NameLoc) {
+    while (NameLoc) {
+      checkDecl(NameLoc.getNestedNameSpecifier()->getAsNamespace(),
+                NameLoc.getLocalBeginLoc());
+      NameLoc = NameLoc.getPrefix();
+    }
+  }
+
+private:
+  size_t getOffsetForString(SourceLocation Loc, StringRef PrevNameString) {
+    const SourceLocation BeginLoc = Loc;
+    const SourceLocation EndLoc = Lexer::getLocForEndOfToken(
+        BeginLoc, 0, Context.getSourceManager(), Context.getLangOpts());
+    StringRef TokenName =
+        Lexer::getSourceText(CharSourceRange::getTokenRange(BeginLoc, EndLoc),
+                             Context.getSourceManager(), Context.getLangOpts());
+    return TokenName.find(PrevNameString);
+  }
+
+  void checkAndAddLocations(unsigned SymbolIndex,
+                            ArrayRef<SourceLocation> Locations,
+                            OldSymbolOccurrence::OccurrenceKind Kind =
+                                OldSymbolOccurrence::MatchingSymbol) {
+    if (Locations.size() != Operation.symbols()[SymbolIndex].Name.size())
+      return;
+
+    SmallVector<SourceLocation, 4> StringLocations;
+    for (size_t I = 0, E = Locations.size(); I != E; ++I) {
+      SourceLocation Loc = Locations[I];
+      bool IsMacroExpansion = Loc.isMacroID();
+      if (IsMacroExpansion) {
+        const SourceManager &SM = Context.getSourceManager();
+        if (SM.isMacroArgExpansion(Loc)) {
+          Loc = SM.getSpellingLoc(Loc);
+          IsMacroExpansion = false;
+        } else
+          Loc = SM.getExpansionLoc(Loc);
+      }
+      if (IsMacroExpansion) {
+        Occurrences.push_back(OldSymbolOccurrence(
+            Kind, /*IsMacroExpansion=*/true, SymbolIndex, Loc));
+        return;
+      }
+      size_t Offset =
+          getOffsetForString(Loc, Operation.symbols()[SymbolIndex].Name[I]);
+      if (Offset == StringRef::npos)
+        return;
+      StringLocations.push_back(Loc.getLocWithOffset(Offset));
+    }
+
+    Occurrences.push_back(OldSymbolOccurrence(Kind, /*IsMacroExpansion=*/false,
+                                              SymbolIndex, StringLocations));
+  }
+
+  /// Adds a location without checking if the name is actually there.
+  void addLocation(unsigned SymbolIndex, SourceLocation Location,
+                   OldSymbolOccurrence::OccurrenceKind Kind) {
+    if (1 != Operation.symbols()[SymbolIndex].Name.size())
+      return;
+    bool IsMacroExpansion = Location.isMacroID();
+    if (IsMacroExpansion) {
+      const SourceManager &SM = Context.getSourceManager();
+      if (SM.isMacroArgExpansion(Location)) {
+        Location = SM.getSpellingLoc(Location);
+        IsMacroExpansion = false;
+      } else
+        Location = SM.getExpansionLoc(Location);
+    }
+    Occurrences.push_back(
+        OldSymbolOccurrence(Kind, IsMacroExpansion, SymbolIndex, Location));
+  }
+
+  const SymbolOperation &Operation;
+  const ASTContext &Context;
+  std::vector<OldSymbolOccurrence> &Occurrences;
+};
+} // namespace
+
+std::vector<OldSymbolOccurrence>
+findSymbolOccurrences(const SymbolOperation &Operation, Decl *Decl) {
+  std::vector<OldSymbolOccurrence> Occurrences;
+  SymbolOccurrenceFinderASTVisitor Visitor(Operation, Decl->getASTContext(),
+                                           Occurrences);
+  Visitor.TraverseDecl(Decl);
+  NestedNameSpecifierLocFinder Finder(Decl->getASTContext());
+
+  for (const auto &Location : Finder.getNestedNameSpecifierLocations())
+    Visitor.handleNestedNameSpecifierLoc(Location);
+
+  return Occurrences;
+}
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/SymbolOperation.cpp b/lib/Tooling/Refactor/SymbolOperation.cpp
index e69de29bb2..111b6c0762 100644
--- a/lib/Tooling/Refactor/SymbolOperation.cpp
+++ b/lib/Tooling/Refactor/SymbolOperation.cpp
@@ -0,0 +1,210 @@
+//===--- SymbolOperation.cpp - --------------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/SymbolOperation.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclTemplate.h"
+#include "clang/Basic/LangOptions.h"
+#include "clang/Tooling/Refactor/RefactoringActionFinder.h"
+
+using namespace clang;
+
+/// Return true if the given local record decl escapes the given enclosing
+/// function or block \p Ctx.
+static bool escapesEnclosingDecl(const DeclContext *Ctx, const RecordDecl *RD) {
+  QualType ReturnType;
+  bool DependentBlock = false;
+  if (const auto *FD = dyn_cast<FunctionDecl>(Ctx))
+    ReturnType = FD->getReturnType();
+  else if (const auto *BD = dyn_cast<BlockDecl>(Ctx)) {
+    ReturnType = BD->getSignatureAsWritten()->getType();
+    // Blocks that don't have an explicitly specified type (represented with a
+    // dependent type) could potentially return the record, e.g.
+    // auto block = ^ {
+    //   struct Foo { };
+    //   return Foo();
+    // };
+    if (const auto *FT = ReturnType->getAs<FunctionType>())
+      ReturnType = FT->getReturnType();
+    if (ReturnType->isDependentType())
+      DependentBlock = true;
+  } else
+    return false;
+
+  // The record can be returned from its enclosing function when the function's
+  // return type is auto.
+  //
+  // FIXME: Use a smarter heuristic that detects if the record type is
+  // actually returned from the function. Have to account for inner records,
+  // like in the example below:
+  //
+  //   auto foo() {
+  //     struct Foo { struct Bar { }; };
+  //     return Foo::Bar();
+  //   };
+  //
+  // for types that depend on the record, like in the example below:
+  //
+  //   auto foo() {
+  //     template<typename T> struct C<T> { T x; };
+  //     struct Foo { struct Bar { }; };
+  //     return C<Bar>();
+  //   }
+  //
+  // and for things like typedefs and function types as well.
+  if (!DependentBlock && !ReturnType->getContainedAutoType())
+    return false;
+
+  // Even if the enclosing function returns the local record, this record is
+  // still local if the enclosing function is inside a function/method that
+  // doesn't return this record.
+  const auto *D = cast<Decl>(Ctx);
+  if (D->isLexicallyWithinFunctionOrMethod())
+    return escapesEnclosingDecl(D->getParentFunctionOrMethod(), RD);
+
+  return true;
+}
+
+static bool escapesEnclosingDecl(const RecordDecl *RD,
+                                 const LangOptions &LangOpts) {
+  // We only care about things that escape in header files since things that
+  // escape in source files will be used only in the initial TU.
+  return LangOpts.IsHeaderFile &&
+         escapesEnclosingDecl(RD->getParentFunctionOrMethod(), RD);
+}
+
+/// Return true if the given declaration corresponds to a local symbol.
+bool clang::tooling::isLocalSymbol(const NamedDecl *FoundDecl,
+                                   const LangOptions &LangOpts) {
+  // Template parameters aren't indexed, so use local rename.
+  if (isa<TemplateTypeParmDecl>(FoundDecl) ||
+      isa<NonTypeTemplateParmDecl>(FoundDecl) ||
+      isa<TemplateTemplateParmDecl>(FoundDecl))
+    return true;
+
+  if (const auto *VD = dyn_cast<VarDecl>(FoundDecl))
+    return VD->isLocalVarDeclOrParm();
+
+  // Objective-C selector renames must be global.
+  if (isa<ObjCMethodDecl>(FoundDecl))
+    return false;
+
+  // Local declarations are defined in a function or a method, or are anonymous.
+  if (!FoundDecl->isLexicallyWithinFunctionOrMethod())
+    return false;
+
+  // A locally defined record is global when it is returned from the enclosing
+  // function because we can refer to its destructor externally.
+  if (const auto *RD = dyn_cast<CXXRecordDecl>(FoundDecl))
+    return !escapesEnclosingDecl(RD, LangOpts);
+
+  // A locally defined field is global when its record is returned from the
+  // enclosing function.
+  if (const auto *FD = dyn_cast<FieldDecl>(FoundDecl))
+    return !escapesEnclosingDecl(FD->getParent(), LangOpts);
+
+  if (const auto *MD = dyn_cast<CXXMethodDecl>(FoundDecl)) {
+    // A locally defined method is global when its record is returned from the
+    // enclosing function.
+    if (escapesEnclosingDecl(MD->getParent(), LangOpts))
+      return false;
+
+    // Method renames can be local only iff this method doesn't override
+    // a global method, for example:
+    //
+    //   void func() {
+    //     struct Foo: GlobalSuper {
+    //       // When renaming foo we should also rename GlobalSuper's foo
+    //       void foo() override;
+    //     }
+    //   }
+    //
+    // FIXME: We can try to be smarter about it and check if we override
+    // a local method, which would make this method local as well.
+    return !MD->isVirtual();
+  }
+
+  return true;
+}
+
+static const NamedDecl *
+findDeclThatRequiresImplementationTU(const NamedDecl *FoundDecl) {
+  // TODO: implement the rest.
+  if (const ObjCIvarDecl *IVarDecl = dyn_cast<ObjCIvarDecl>(FoundDecl)) {
+    // We need the implementation TU when the IVAR is declared in an @interface
+    // without an @implementation.
+    if (const auto *ID =
+            dyn_cast<ObjCInterfaceDecl>(IVarDecl->getDeclContext())) {
+      if (!ID->getImplementation())
+        return IVarDecl;
+    }
+  }
+  return nullptr;
+}
+
+namespace clang {
+namespace tooling {
+
+SymbolOperation::SymbolOperation(const NamedDecl *FoundDecl,
+                                 ASTContext &Context)
+    : IsLocal(isLocalSymbol(FoundDecl, Context.getLangOpts())) {
+  // Take the category declaration if this is a category implementation.
+  if (const auto *CategoryImplDecl =
+          dyn_cast<ObjCCategoryImplDecl>(FoundDecl)) {
+    if (const auto *CategoryDecl = CategoryImplDecl->getCategoryDecl())
+      FoundDecl = CategoryDecl;
+  }
+  // Use the property if this method is a getter/setter.
+  else if (const auto *MethodDecl = dyn_cast<ObjCMethodDecl>(FoundDecl)) {
+    if (const auto *PropertyDecl =
+            MethodDecl->getCanonicalDecl()->findPropertyDecl()) {
+      // Don't use the property if the getter/setter method has an explicitly
+      // specified name.
+      if (MethodDecl->param_size() == 0
+              ? !PropertyDecl->hasExplicitGetterName()
+              : !PropertyDecl->hasExplicitSetterName())
+        FoundDecl = PropertyDecl;
+    }
+  }
+
+  DeclThatRequiresImplementationTU =
+      findDeclThatRequiresImplementationTU(FoundDecl);
+
+  // TODO: Split into initiation that works after implementation TU is loaded.
+
+  // Find the set of symbols that this operation has to work on.
+  auto AddSymbol = [this, &Context](const NamedDecl *FoundDecl) {
+    unsigned Index = Symbols.size();
+    Symbols.push_back(rename::Symbol(FoundDecl, Index, Context.getLangOpts()));
+    for (const auto &USR : findSymbolsUSRSet(FoundDecl, Context))
+      USRToSymbol.insert(std::make_pair(USR.getKey(), Index));
+  };
+  AddSymbol(FoundDecl);
+  // Take getters, setters and ivars into account when dealing with
+  // Objective-C @property declarations.
+  if (const auto *PropertyDecl = dyn_cast<ObjCPropertyDecl>(FoundDecl)) {
+    // FIXME: findSymbolsUSRSet is called for every symbol we add, which is
+    // inefficient since we currently have to traverse the AST every time it is
+    // called. Fix this so that the AST isn't traversed more than once.
+    if (!PropertyDecl->hasExplicitGetterName()) {
+      if (const auto *Getter = PropertyDecl->getGetterMethodDecl())
+        AddSymbol(Getter);
+    }
+    if (!PropertyDecl->hasExplicitSetterName()) {
+      if (const auto *Setter = PropertyDecl->getSetterMethodDecl())
+        AddSymbol(Setter);
+    }
+  }
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/SymbolUSRFinder.cpp b/lib/Tooling/Refactor/SymbolUSRFinder.cpp
index e69de29bb2..267f90c7ed 100644
--- a/lib/Tooling/Refactor/SymbolUSRFinder.cpp
+++ b/lib/Tooling/Refactor/SymbolUSRFinder.cpp
@@ -0,0 +1,206 @@
+//===--- SymbolUSRFinder.cpp - Clang refactoring library ------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Implements methods that find the set of USRs that correspond to
+/// a symbol that's required for a refactoring operation.
+///
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTConsumer.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/Tooling/Refactor/RefactoringActionFinder.h"
+#include "clang/Tooling/Refactor/USRFinder.h"
+#include "llvm/ADT/StringRef.h"
+
+#include <vector>
+
+using namespace clang;
+using namespace clang::tooling::rename;
+
+namespace {
+
+/// \brief NamedDeclFindingConsumer delegates finding USRs of a found Decl to
+/// \c AdditionalUSRFinder. \c AdditionalUSRFinder adds USRs of ctors and dtor
+/// if the found declaration refers to a class and adds USRs of all overridden
+/// methods if the declaration refers to a virtual C++ method or an ObjC method.
+class AdditionalUSRFinder : public RecursiveASTVisitor<AdditionalUSRFinder> {
+public:
+  AdditionalUSRFinder(const Decl *FoundDecl, ASTContext &Context)
+      : FoundDecl(FoundDecl), Context(Context) {}
+
+  llvm::StringSet<> Find() {
+    llvm::StringSet<> USRSet;
+
+    // Fill OverriddenMethods and PartialSpecs storages.
+    TraverseDecl(Context.getTranslationUnitDecl());
+    if (const auto *MethodDecl = dyn_cast<CXXMethodDecl>(FoundDecl)) {
+      addUSRsOfOverridenFunctions(MethodDecl, USRSet);
+      // FIXME: Use a more efficient/optimal algorithm to find the related
+      // methods.
+      for (const auto &OverriddenMethod : OverriddenMethods) {
+        if (checkIfOverriddenFunctionAscends(OverriddenMethod, USRSet))
+          USRSet.insert(getUSRForDecl(OverriddenMethod));
+      }
+    } else if (const auto *RecordDecl = dyn_cast<CXXRecordDecl>(FoundDecl)) {
+      handleCXXRecordDecl(RecordDecl, USRSet);
+    } else if (const auto *TemplateDecl =
+                   dyn_cast<ClassTemplateDecl>(FoundDecl)) {
+      handleClassTemplateDecl(TemplateDecl, USRSet);
+    } else if (const auto *MethodDecl = dyn_cast<ObjCMethodDecl>(FoundDecl)) {
+      addUSRsOfOverriddenObjCMethods(MethodDecl, USRSet);
+      for (const auto &PotentialOverrider : PotentialObjCMethodOverridders)
+        if (checkIfPotentialObjCMethodOverriddes(PotentialOverrider, USRSet))
+          USRSet.insert(getUSRForDecl(PotentialOverrider));
+    } else {
+      USRSet.insert(getUSRForDecl(FoundDecl));
+    }
+    return USRSet;
+  }
+
+  bool VisitCXXMethodDecl(const CXXMethodDecl *MethodDecl) {
+    if (MethodDecl->isVirtual())
+      OverriddenMethods.push_back(MethodDecl);
+    return true;
+  }
+
+  bool VisitObjCMethodDecl(const ObjCMethodDecl *MethodDecl) {
+    if (const auto *FoundMethodDecl = dyn_cast<ObjCMethodDecl>(FoundDecl))
+      if (DeclarationName::compare(MethodDecl->getDeclName(),
+                                   FoundMethodDecl->getDeclName()) == 0 &&
+          MethodDecl->isOverriding())
+        PotentialObjCMethodOverridders.push_back(MethodDecl);
+    return true;
+  }
+
+  bool VisitClassTemplatePartialSpecializationDecl(
+      const ClassTemplatePartialSpecializationDecl *PartialSpec) {
+    if (!isa<ClassTemplateDecl>(FoundDecl) && !isa<CXXRecordDecl>(FoundDecl))
+      return true;
+    PartialSpecs.push_back(PartialSpec);
+    return true;
+  }
+
+private:
+  void handleCXXRecordDecl(const CXXRecordDecl *RecordDecl,
+                           llvm::StringSet<> &USRSet) {
+    const auto *RD = RecordDecl->getDefinition();
+    if (!RD) {
+      USRSet.insert(getUSRForDecl(RecordDecl));
+      return;
+    }
+    if (const auto *ClassTemplateSpecDecl =
+            dyn_cast<ClassTemplateSpecializationDecl>(RD))
+      handleClassTemplateDecl(ClassTemplateSpecDecl->getSpecializedTemplate(),
+                              USRSet);
+    addUSRsOfCtorDtors(RD, USRSet);
+  }
+
+  void handleClassTemplateDecl(const ClassTemplateDecl *TemplateDecl,
+                               llvm::StringSet<> &USRSet) {
+    for (const auto *Specialization : TemplateDecl->specializations())
+      addUSRsOfCtorDtors(Specialization, USRSet);
+
+    for (const auto *PartialSpec : PartialSpecs) {
+      if (PartialSpec->getSpecializedTemplate() == TemplateDecl)
+        addUSRsOfCtorDtors(PartialSpec, USRSet);
+    }
+    addUSRsOfCtorDtors(TemplateDecl->getTemplatedDecl(), USRSet);
+  }
+
+  void addUSRsOfCtorDtors(const CXXRecordDecl *RecordDecl,
+                          llvm::StringSet<> &USRSet) {
+    const CXXRecordDecl *RD = RecordDecl;
+    RecordDecl = RD->getDefinition();
+    if (!RecordDecl) {
+      USRSet.insert(getUSRForDecl(RD));
+      return;
+    }
+
+    for (const auto *CtorDecl : RecordDecl->ctors()) {
+      auto USR = getUSRForDecl(CtorDecl);
+      if (!USR.empty())
+        USRSet.insert(USR);
+    }
+
+    auto USR = getUSRForDecl(RecordDecl->getDestructor());
+    if (!USR.empty())
+      USRSet.insert(USR);
+    USRSet.insert(getUSRForDecl(RecordDecl));
+  }
+
+  void addUSRsOfOverridenFunctions(const CXXMethodDecl *MethodDecl,
+                                   llvm::StringSet<> &USRSet) {
+    USRSet.insert(getUSRForDecl(MethodDecl));
+    // Recursively visit each OverridenMethod.
+    for (const auto &OverriddenMethod : MethodDecl->overridden_methods())
+      addUSRsOfOverridenFunctions(OverriddenMethod, USRSet);
+  }
+
+  bool checkIfOverriddenFunctionAscends(const CXXMethodDecl *MethodDecl,
+                                        const llvm::StringSet<> &USRSet) {
+    for (const auto &OverriddenMethod : MethodDecl->overridden_methods()) {
+      if (USRSet.find(getUSRForDecl(OverriddenMethod)) != USRSet.end())
+        return true;
+      return checkIfOverriddenFunctionAscends(OverriddenMethod, USRSet);
+    }
+    return false;
+  }
+
+  /// \brief Recursively visit all the methods which the given method
+  /// declaration overrides and adds them to the USR set.
+  void addUSRsOfOverriddenObjCMethods(const ObjCMethodDecl *MethodDecl,
+                                      llvm::StringSet<> &USRSet) {
+    // Exit early if this method was already visited.
+    if (!USRSet.insert(getUSRForDecl(MethodDecl)).second)
+      return;
+    SmallVector<const ObjCMethodDecl *, 8> Overrides;
+    MethodDecl->getOverriddenMethods(Overrides);
+    for (const auto &OverriddenMethod : Overrides)
+      addUSRsOfOverriddenObjCMethods(OverriddenMethod, USRSet);
+  }
+
+  /// \brief Returns true if the given Objective-C method overrides the
+  /// found Objective-C method declaration.
+  bool checkIfPotentialObjCMethodOverriddes(const ObjCMethodDecl *MethodDecl,
+                                            const llvm::StringSet<> &USRSet) {
+    SmallVector<const ObjCMethodDecl *, 8> Overrides;
+    MethodDecl->getOverriddenMethods(Overrides);
+    for (const auto &OverriddenMethod : Overrides) {
+      if (USRSet.find(getUSRForDecl(OverriddenMethod)) != USRSet.end())
+        return true;
+      if (checkIfPotentialObjCMethodOverriddes(OverriddenMethod, USRSet))
+        return true;
+    }
+    return false;
+  }
+
+  const Decl *FoundDecl;
+  ASTContext &Context;
+  std::vector<const CXXMethodDecl *> OverriddenMethods;
+  std::vector<const ClassTemplatePartialSpecializationDecl *> PartialSpecs;
+  /// \brief An array of Objective-C methods that potentially override the
+  /// found Objective-C method declaration \p FoundDecl.
+  std::vector<const ObjCMethodDecl *> PotentialObjCMethodOverridders;
+};
+} // end anonymous namespace
+
+namespace clang {
+namespace tooling {
+
+llvm::StringSet<> findSymbolsUSRSet(const NamedDecl *FoundDecl,
+                                    ASTContext &Context) {
+  return AdditionalUSRFinder(FoundDecl, Context).Find();
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/TypeUtils.cpp b/lib/Tooling/Refactor/TypeUtils.cpp
index e69de29bb2..c07136bd70 100644
--- a/lib/Tooling/Refactor/TypeUtils.cpp
+++ b/lib/Tooling/Refactor/TypeUtils.cpp
@@ -0,0 +1,200 @@
+//===--- TypeUtils.cpp - Type helper functions ----------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "TypeUtils.h"
+#include "clang/AST/Expr.h"
+#include "clang/AST/NSAPI.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+
+using namespace clang;
+
+namespace {
+
+/// Returns false if a BOOL expression is found.
+class BOOLUseFinder : public RecursiveASTVisitor<BOOLUseFinder> {
+public:
+  NSAPI API;
+
+  BOOLUseFinder(const ASTContext &Context)
+      : API(const_cast<ASTContext &>(Context)) {}
+
+  bool VisitStmt(const Stmt *S) {
+    if (const auto *E = dyn_cast<Expr>(S))
+      return !API.isObjCBOOLType(E->getType());
+    return true;
+  }
+
+  static bool hasUseOfObjCBOOL(const ASTContext &Ctx, const Expr *E) {
+    return !BOOLUseFinder(Ctx).TraverseStmt(const_cast<Expr *>(E));
+  }
+};
+
+} // end anonymous namespace
+
+static QualType preferredBoolType(const Decl *FunctionLikeParentDecl,
+                                  const Expr *E, QualType T,
+                                  const PrintingPolicy &Policy,
+                                  const ASTContext &Ctx) {
+  // We want to target expressions that return either 'int' or 'bool'
+  const auto *BTy = T->getAs<BuiltinType>();
+  if (!BTy)
+    return T;
+  switch (BTy->getKind()) {
+  case BuiltinType::Int:
+  case BuiltinType::Bool:
+    // In Objective-C[++] we want to try to use 'BOOL' when the 'BOOL' typedef
+    // is defined.
+    if (Ctx.getLangOpts().ObjC1 && Ctx.getBOOLDecl()) {
+      if (Ctx.getLangOpts().CPlusPlus && FunctionLikeParentDecl) {
+        // When extracting expression from a standalone function in
+        // Objective-C++ we should use BOOL when expression uses BOOL, otherwise
+        // we should use bool.
+        if (isa<FunctionDecl>(FunctionLikeParentDecl)) {
+          if (BOOLUseFinder::hasUseOfObjCBOOL(Ctx, E))
+            return Ctx.getBOOLType();
+          return T;
+        }
+      }
+      return Ctx.getBOOLType();
+    }
+    // In C mode we want to use 'bool' instead of 'int' when the 'bool' macro
+    // is defined.
+    if (!Ctx.getLangOpts().CPlusPlus && Policy.Bool)
+      return Ctx.BoolTy;
+    break;
+  default:
+    break;
+  }
+  return T;
+}
+
+static bool isInStdNamespace(const Decl *D) {
+  const DeclContext *DC = D->getDeclContext()->getEnclosingNamespaceContext();
+  const NamespaceDecl *ND = dyn_cast<NamespaceDecl>(DC);
+  if (!ND)
+    return false;
+
+  while (const DeclContext *Parent = ND->getParent()) {
+    if (!isa<NamespaceDecl>(Parent))
+      break;
+    ND = cast<NamespaceDecl>(Parent);
+  }
+
+  return ND->isStdNamespace();
+}
+
+static QualType desugarStdTypedef(QualType T) {
+  const auto *TT = T->getAs<TypedefType>();
+  if (!TT)
+    return QualType();
+  const TypedefNameDecl *TND = TT->getDecl();
+  if (!isInStdNamespace(TND))
+    return QualType();
+  return TT->desugar();
+}
+
+// Desugars a typedef of a typedef that are both defined in STL.
+//
+// This is used to find the right type for a c_str() call on a std::string
+// object: we want to return const char *, not const value_type *.
+static QualType desugarStdType(QualType T) {
+  QualType DesugaredType = T;
+  if (const auto *PT = T->getAs<PointerType>())
+    DesugaredType = PT->getPointeeType();
+  DesugaredType = desugarStdTypedef(DesugaredType);
+  if (DesugaredType.isNull())
+    return T;
+  if (const auto *ET = DesugaredType->getAs<ElaboratedType>())
+    DesugaredType = ET->desugar();
+  DesugaredType = desugarStdTypedef(DesugaredType);
+  if (DesugaredType.isNull())
+    return T;
+  return T.getCanonicalType();
+}
+
+// Given an operator call like std::string() + "", we would like to ensure
+// that we return std::string instead of std::basic_string.
+static QualType canonicalizeStdOperatorReturnType(const Expr *E, QualType T) {
+  const auto *OCE = dyn_cast<CXXOperatorCallExpr>(E->IgnoreParenImpCasts());
+  if (!OCE)
+    return T;
+  if (OCE->getNumArgs() < 2 || !isInStdNamespace(OCE->getCalleeDecl()))
+    return T;
+  QualType CanonicalReturn = T.getCanonicalType();
+  if (const auto *RD = CanonicalReturn->getAsCXXRecordDecl()) {
+    if (!isInStdNamespace(RD))
+      return T;
+  } else
+    return T;
+  for (unsigned I = 0, E = OCE->getNumArgs(); I < E; ++I) {
+    const Expr *Arg = OCE->getArgs()[I];
+    QualType T = Arg->getType();
+    if (const auto *ET = dyn_cast<ElaboratedType>(T))
+      T = ET->desugar();
+    if (desugarStdTypedef(T).isNull())
+      continue;
+    QualType CanonicalArg = Arg->getType().getCanonicalType();
+    CanonicalArg.removeLocalFastQualifiers();
+    if (CanonicalArg == CanonicalReturn) {
+      QualType Result = Arg->getType();
+      Result.removeLocalFastQualifiers();
+      return Result;
+    }
+  }
+  return T;
+}
+
+namespace clang {
+namespace tooling {
+
+/// Tthe return type of the extracted function should match user's intent,
+/// e.g. we want to use bool type whenever possible.
+QualType findExpressionLexicalType(const Decl *FunctionLikeParentDecl,
+                                   const Expr *E, QualType T,
+                                   const PrintingPolicy &Policy,
+                                   const ASTContext &Ctx) {
+  // Get the correct property type.
+  if (const auto *PRE = dyn_cast<ObjCPropertyRefExpr>(E)) {
+    if (PRE->isMessagingGetter()) {
+      if (PRE->isExplicitProperty()) {
+        QualType ReceiverType = PRE->getReceiverType(Ctx);
+        return PRE->getExplicitProperty()->getUsageType(ReceiverType);
+      }
+      if (const ObjCMethodDecl *M = PRE->getImplicitPropertyGetter()) {
+        if (!PRE->isObjectReceiver())
+          return M->getSendResultType(PRE->getReceiverType(Ctx));
+        const Expr *Base = PRE->getBase();
+        return M->getSendResultType(findExpressionLexicalType(
+            FunctionLikeParentDecl, Base, Base->getType(), Policy, Ctx));
+      }
+    }
+  }
+
+  // Perform STL-specific type corrections.
+  if (Ctx.getLangOpts().CPlusPlus) {
+    T = desugarStdType(T);
+    T = canonicalizeStdOperatorReturnType(E, T);
+  }
+
+  // The bool type adjustment is required only in C or Objective-C[++].
+  if (Ctx.getLangOpts().CPlusPlus && !Ctx.getLangOpts().ObjC1)
+    return T;
+  E = E->IgnoreParenImpCasts();
+  if (const auto *BinOp = dyn_cast<BinaryOperator>(E)) {
+    if (BinOp->isLogicalOp() || BinOp->isComparisonOp())
+      return preferredBoolType(FunctionLikeParentDecl, E, T, Policy, Ctx);
+  } else if (const auto *UnOp = dyn_cast<UnaryOperator>(E)) {
+    if (UnOp->getOpcode() == UO_LNot)
+      return preferredBoolType(FunctionLikeParentDecl, E, T, Policy, Ctx);
+  }
+  return T;
+}
+
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactor/TypeUtils.h b/lib/Tooling/Refactor/TypeUtils.h
index e69de29bb2..8d575e8bb9 100644
--- a/lib/Tooling/Refactor/TypeUtils.h
+++ b/lib/Tooling/Refactor/TypeUtils.h
@@ -0,0 +1,35 @@
+//===--- TypeUtils.h - Type helper functions ------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_TOOLING_REFACTOR_TYPE_UTILS_H
+#define LLVM_CLANG_LIB_TOOLING_REFACTOR_TYPE_UTILS_H
+
+#include "clang/AST/Type.h"
+
+namespace clang {
+
+class Decl;
+
+namespace tooling {
+
+/// \brief Find the most lexically appropriate type that can be used to describe
+/// the return type of the given expression \p E.
+///
+/// When extracting code, we want to produce a function that returns a type
+/// that matches the user's intent. This function can be used to find such a
+/// type.
+QualType findExpressionLexicalType(const Decl *FunctionLikeParentDecl,
+                                   const Expr *E, QualType T,
+                                   const PrintingPolicy &Policy,
+                                   const ASTContext &Ctx);
+
+} // end namespace tooling
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_TOOLING_REFACTOR_TYPE_UTILS_H
diff --git a/lib/Tooling/Refactor/USRFinder.cpp b/lib/Tooling/Refactor/USRFinder.cpp
index e69de29bb2..92f16d3141 100644
--- a/lib/Tooling/Refactor/USRFinder.cpp
+++ b/lib/Tooling/Refactor/USRFinder.cpp
@@ -0,0 +1,706 @@
+//===--- USRFinder.cpp - Clang refactoring library ------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file Implements a recursive AST visitor that finds the USR of a symbol at a
+/// point.
+///
+//===----------------------------------------------------------------------===//
+
+#include "clang/Tooling/Refactor/USRFinder.h"
+#include "SourceLocationUtilities.h"
+#include "clang/AST/AST.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DependentASTVisitor.h"
+#include "clang/Index/USRGeneration.h"
+#include "clang/Lex/Lexer.h"
+#include "clang/Tooling/Refactoring/RefactoringDiagnostic.h"
+#include "llvm/ADT/SmallVector.h"
+#include <functional>
+
+using namespace llvm;
+
+namespace clang {
+namespace tooling {
+namespace rename {
+
+typedef std::function<bool(const NamedDecl *, SourceLocation, SourceLocation)>
+    OccurrenceCheckerType;
+
+// NamedDeclFindingASTVisitor recursively visits each AST node to find the
+// symbol underneath the cursor.
+// FIXME: move to seperate .h/.cc file if this gets too large.
+namespace {
+class NamedDeclFindingASTVisitor
+    : public DependentASTVisitor<NamedDeclFindingASTVisitor> {
+public:
+  // \brief Finds the NamedDecl at a point in the source.
+  // \param Point the location in the source to search for the NamedDecl.
+  explicit NamedDeclFindingASTVisitor(
+      const OccurrenceCheckerType &OccurrenceChecker, const ASTContext &Context)
+      : Result(nullptr), OccurrenceChecker(OccurrenceChecker),
+        Context(Context) {}
+
+  // Declaration visitors:
+
+  // \brief Checks if the point falls within the NameDecl. This covers every
+  // declaration of a named entity that we may come across. Usually, just
+  // checking if the point lies within the length of the name of the declaration
+  // and the start location is sufficient.
+  bool VisitNamedDecl(const NamedDecl *Decl) {
+    return dyn_cast<CXXConversionDecl>(Decl)
+               ? true
+               : checkOccurrence(Decl, Decl->getLocation(),
+                                 Decl->getNameAsString().length());
+  }
+
+  bool WalkUpFromTypedefNameDecl(const TypedefNameDecl *D) {
+    // Don't visit the NamedDecl for TypedefNameDecl.
+    return VisitTypedefNamedDecl(D);
+  }
+
+  bool VisitTypedefNamedDecl(const TypedefNameDecl *D) {
+    if (D->isTransparentTag()) {
+      if (const auto *Underlying = D->getUnderlyingType()->getAsTagDecl())
+        return checkOccurrence(Underlying, D->getLocation(),
+                               D->getNameAsString().size());
+    }
+    return VisitNamedDecl(D);
+  }
+
+  bool WalkUpFromUsingDecl(const UsingDecl *D) {
+    // Don't visit the NamedDecl for UsingDecl.
+    return VisitUsingDecl(D);
+  }
+
+  bool VisitUsingDecl(const UsingDecl *D) {
+    for (const auto *Shadow : D->shadows()) {
+      // Currently we always find the first declaration, but is this the right
+      // behaviour?
+      const NamedDecl *UD = Shadow->getUnderlyingDecl();
+      if (UD->isImplicit() || UD == D)
+        continue;
+      if (const auto *FTD = dyn_cast<FunctionTemplateDecl>(UD)) {
+        UD = FTD->getTemplatedDecl();
+        if (!UD)
+          continue;
+      }
+      if (!checkOccurrence(UD, D->getLocation()))
+        return false;
+    }
+    return true;
+  }
+
+  bool WalkUpFromUsingDirectiveDecl(const UsingDirectiveDecl *D) {
+    // Don't visit the NamedDecl for UsingDirectiveDecl.
+    return VisitUsingDirectiveDecl(D);
+  }
+
+  bool VisitUsingDirectiveDecl(const UsingDirectiveDecl *D) {
+    return checkOccurrence(D->getNominatedNamespaceAsWritten(),
+                           D->getLocation());
+  }
+
+  bool WalkUpFromUnresolvedUsingValueDecl(const UnresolvedUsingValueDecl *D) {
+    // Don't visit the NamedDecl for UnresolvedUsingValueDecl.
+    // FIXME: Can we try to lookup the name?
+    return true;
+  }
+
+  bool
+  WalkUpFromUnresolvedUsingTypenameDecl(const UnresolvedUsingTypenameDecl *D) {
+    // Don't visit the NamedDecl for UnresolvedUsingTypenameDecl.
+    // FIXME: Can we try to lookup the name?
+    return true;
+  }
+
+  bool WalkUpFromObjCMethodDecl(const ObjCMethodDecl *Decl) {
+    // Don't visit the NamedDecl for Objective-C methods.
+    return VisitObjCMethodDecl(Decl);
+  }
+
+  bool VisitObjCMethodDecl(const ObjCMethodDecl *Decl) {
+    // Check all of the selector source ranges.
+    for (unsigned I = 0, E = Decl->getNumSelectorLocs(); I != E; ++I) {
+      SourceLocation Loc = Decl->getSelectorLoc(I);
+      if (!checkOccurrence(Decl, Loc,
+                           Loc.getLocWithOffset(
+                               Decl->getSelector().getNameForSlot(I).size())))
+        return false;
+    }
+    return true;
+  }
+
+  bool VisitObjCProtocolList(const ObjCProtocolList &Protocols) {
+    for (unsigned I = 0, E = Protocols.size(); I != E; ++I) {
+      if (!checkOccurrence(Protocols[I], Protocols.loc_begin()[I]))
+        return false;
+    }
+    return true;
+  }
+
+  bool VisitObjCInterfaceDecl(const ObjCInterfaceDecl *Decl) {
+    if (!Decl->hasDefinition())
+      return true;
+    return VisitObjCProtocolList(Decl->getReferencedProtocols());
+  }
+
+  bool VisitObjCProtocolDecl(const ObjCProtocolDecl *Decl) {
+    if (!Decl->hasDefinition())
+      return true;
+    return VisitObjCProtocolList(Decl->getReferencedProtocols());
+  }
+
+  bool WalkUpFromObjCCategoryDecl(const ObjCCategoryDecl *Decl) {
+    // Don't visit the NamedDecl for Objective-C categories because the location
+    // of the name refers to the interface declaration.
+    return VisitObjCCategoryDecl(Decl);
+  }
+
+  bool VisitObjCCategoryDecl(const ObjCCategoryDecl *Decl) {
+    if (!checkOccurrence(Decl, Decl->getCategoryNameLoc()))
+      return false;
+    if (const auto *Class = Decl->getClassInterface()) {
+      // The location of the class name is the location of the declaration.
+      if (!checkOccurrence(Class, Decl->getLocation()))
+        return false;
+    }
+    return VisitObjCProtocolList(Decl->getReferencedProtocols());
+  }
+
+  bool WalkUpFromObjCCategoryImplDecl(const ObjCCategoryImplDecl *Decl) {
+    // Don't visit the NamedDecl for Objective-C categories because the location
+    // of the name refers to the interface declaration.
+    return VisitObjCCategoryImplDecl(Decl);
+  }
+
+  bool VisitObjCCategoryImplDecl(const ObjCCategoryImplDecl *Decl) {
+    if (!checkOccurrence(Decl, Decl->getCategoryNameLoc()))
+      return false;
+    if (const auto *Class = Decl->getClassInterface()) {
+      // The location of the class name is the location of the declaration.
+      if (!checkOccurrence(Class, Decl->getLocation()))
+        return false;
+    }
+    return true;
+  }
+
+  bool VisitObjCCompatibleAliasDecl(const ObjCCompatibleAliasDecl *Decl) {
+    return checkOccurrence(Decl->getClassInterface(),
+                           Decl->getClassInterfaceLoc());
+  }
+
+  bool WalkUpFromObjCIvarDecl(ObjCIvarDecl *Decl) {
+    // Don't visit the NamedDecl for automatically synthesized ivars as the
+    // implicit ivars have the same location as the property declarations, and
+    // we want to find the property declarations.
+    if (Decl->getSynthesize())
+      return true;
+    return RecursiveASTVisitor::WalkUpFromObjCIvarDecl(Decl);
+  }
+
+  bool VisitObjCPropertyDecl(const ObjCPropertyDecl *Decl) {
+    if (Decl->hasExplicitGetterName()) {
+      if (const auto *Getter = Decl->getGetterMethodDecl())
+        if (!checkOccurrence(Getter, Decl->getGetterNameLoc(),
+                             Decl->getGetterName().getNameForSlot(0).size()))
+          return false;
+    }
+    if (Decl->hasExplicitSetterName()) {
+      if (const auto *Setter = Decl->getSetterMethodDecl())
+        return checkOccurrence(Setter, Decl->getSetterNameLoc(),
+                               Decl->getSetterName().getNameForSlot(0).size());
+    }
+    return true;
+  }
+
+  bool VisitObjCPropertyImplDecl(const ObjCPropertyImplDecl *Decl) {
+    if (!checkOccurrence(Decl->getPropertyDecl(), Decl->getLocation()))
+      return false;
+    if (Decl->isIvarNameSpecified())
+      return checkOccurrence(Decl->getPropertyIvarDecl(),
+                             Decl->getPropertyIvarDeclLoc());
+    return true;
+  }
+
+  // Expression visitors:
+
+  bool VisitDeclRefExpr(const DeclRefExpr *Expr) {
+    const NamedDecl *Decl = Expr->getFoundDecl();
+    return checkOccurrence(Decl, Expr->getLocation(),
+                           Decl->getNameAsString().length());
+  }
+
+  bool VisitMemberExpr(const MemberExpr *Expr) {
+    const NamedDecl *Decl = Expr->getFoundDecl().getDecl();
+    return checkOccurrence(Decl, Expr->getMemberLoc(),
+                           Decl->getNameAsString().length());
+  }
+
+  bool VisitObjCMessageExpr(const ObjCMessageExpr *Expr) {
+    const ObjCMethodDecl *Decl = Expr->getMethodDecl();
+    if (Decl == nullptr)
+      return true;
+
+    // Check all of the selector source ranges.
+    for (unsigned I = 0, E = Expr->getNumSelectorLocs(); I != E; ++I) {
+      SourceLocation Loc = Expr->getSelectorLoc(I);
+      if (!checkOccurrence(Decl, Loc,
+                           Loc.getLocWithOffset(
+                               Decl->getSelector().getNameForSlot(I).size())))
+        return false;
+    }
+    return true;
+  }
+
+  bool VisitObjCProtocolExpr(const ObjCProtocolExpr *Expr) {
+    return checkOccurrence(Expr->getProtocol(), Expr->getProtocolIdLoc());
+  }
+
+  bool VisitObjCIvarRefExpr(const ObjCIvarRefExpr *Expr) {
+    return checkOccurrence(Expr->getDecl(), Expr->getLocation());
+  }
+
+  bool VisitObjCPropertyRefExpr(const ObjCPropertyRefExpr *Expr) {
+    if (Expr->isClassReceiver())
+      checkOccurrence(Expr->getClassReceiver(), Expr->getReceiverLocation());
+    if (Expr->isImplicitProperty()) {
+      // Class properties that are explicitly defined using @property
+      // declarations are represented implicitly as there is no ivar for class
+      // properties.
+      if (const ObjCMethodDecl *Getter = Expr->getImplicitPropertyGetter()) {
+        if (Getter->isClassMethod()) {
+          if (const auto *PD = Getter->getCanonicalDecl()->findPropertyDecl())
+            return checkOccurrence(PD, Expr->getLocation());
+        }
+      }
+
+      if (Expr->isMessagingGetter()) {
+        if (const ObjCMethodDecl *Getter = Expr->getImplicitPropertyGetter())
+          return checkOccurrence(Getter, Expr->getLocation());
+      } else if (const ObjCMethodDecl *Setter =
+                     Expr->getImplicitPropertySetter()) {
+        return checkOccurrence(Setter, Expr->getLocation());
+      }
+
+      return true;
+    }
+    return checkOccurrence(Expr->getExplicitProperty(), Expr->getLocation());
+  }
+
+  // Other visitors:
+
+  bool VisitTypeLoc(const TypeLoc Loc) {
+    const SourceLocation TypeBeginLoc = Loc.getBeginLoc();
+    const SourceLocation TypeEndLoc = Lexer::getLocForEndOfToken(
+        TypeBeginLoc, 0, Context.getSourceManager(), Context.getLangOpts());
+    if (const auto *TemplateTypeParm =
+            dyn_cast<TemplateTypeParmType>(Loc.getType()))
+      return checkOccurrence(TemplateTypeParm->getDecl(), TypeBeginLoc,
+                             TypeEndLoc);
+    if (const auto *TemplateSpecType =
+            dyn_cast<TemplateSpecializationType>(Loc.getType())) {
+      return checkOccurrence(
+          TemplateSpecType->getTemplateName().getAsTemplateDecl(), TypeBeginLoc,
+          TypeEndLoc);
+    }
+    TypedefTypeLoc TTL = Loc.getAs<TypedefTypeLoc>();
+    if (TTL) {
+      const auto *TND = TTL.getTypedefNameDecl();
+      if (TND->isTransparentTag()) {
+        if (const auto *Underlying = TND->getUnderlyingType()->getAsTagDecl())
+          return checkOccurrence(Underlying, TTL.getNameLoc());
+      }
+      return checkOccurrence(TND, TTL.getNameLoc());
+    }
+    TypeSpecTypeLoc TSTL = Loc.getAs<TypeSpecTypeLoc>();
+    if (TSTL) {
+      return checkOccurrence(Loc.getType()->getAsTagDecl(), TSTL.getNameLoc());
+    }
+    return true;
+  }
+
+  bool VisitObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc Loc) {
+    return checkOccurrence(Loc.getIFaceDecl(), Loc.getNameLoc());
+  }
+
+  bool VisitObjCObjectTypeLoc(ObjCObjectTypeLoc Loc) {
+    for (unsigned I = 0, E = Loc.getNumProtocols(); I < E; ++I) {
+      if (!checkOccurrence(Loc.getProtocol(I), Loc.getProtocolLoc(I)))
+        return false;
+    }
+    return true;
+  }
+
+  bool VisitCXXConstructorDecl(clang::CXXConstructorDecl *ConstructorDecl) {
+    for (const auto *Initializer : ConstructorDecl->inits()) {
+      // Ignore implicit initializers.
+      if (!Initializer->isWritten())
+        continue;
+      if (const clang::FieldDecl *FieldDecl = Initializer->getMember()) {
+        const SourceLocation InitBeginLoc = Initializer->getSourceLocation(),
+                             InitEndLoc = Lexer::getLocForEndOfToken(
+                                 InitBeginLoc, 0, Context.getSourceManager(),
+                                 Context.getLangOpts());
+        if (!checkOccurrence(FieldDecl, InitBeginLoc, InitEndLoc))
+          return false;
+      }
+    }
+    return true;
+  }
+
+  bool VisitDependentSymbolReference(const NamedDecl *Symbol,
+                                     SourceLocation SymbolNameLoc) {
+    return checkOccurrence(Symbol, SymbolNameLoc);
+  }
+
+  // Other:
+
+  const NamedDecl *getNamedDecl() { return Result; }
+
+  bool isDone() const { return Result; }
+
+  // \brief Determines if a namespace qualifier contains the point.
+  // \returns false on success and sets Result.
+  void handleNestedNameSpecifierLoc(NestedNameSpecifierLoc NameLoc) {
+    while (NameLoc) {
+      const NamespaceDecl *Decl =
+          NameLoc.getNestedNameSpecifier()->getAsNamespace();
+      checkOccurrence(Decl, NameLoc.getLocalBeginLoc(),
+                      NameLoc.getLocalEndLoc());
+      NameLoc = NameLoc.getPrefix();
+    }
+  }
+
+private:
+  /// \brief Sets Result to \p Decl if the occurrence checker returns true.
+  ///
+  /// \returns false on success.
+  bool checkRange(const NamedDecl *Decl, SourceLocation Start,
+                  SourceLocation End) {
+    assert(!Start.isMacroID() && !End.isMacroID() && "Macro location?");
+    if (!Decl)
+      return true;
+    if (isa<ImplicitParamDecl>(Decl))
+      return true;
+    if (const auto *FD = dyn_cast<FunctionDecl>(Decl)) {
+      // Don't match operators.
+      if (FD->isOverloadedOperator())
+        return true;
+    }
+    if (!OccurrenceChecker(Decl, Start, End))
+      return true;
+    Result = Decl;
+    return false;
+  }
+
+  /// Checks if the given declaration is valid, and if it is, sets Result to
+  /// \p Decl if the occurrence checker returns true.
+  ///
+  /// \returns false if the point of interest is inside the range that
+  /// corresponds the occurrence of this declaration.
+  bool checkOccurrence(const NamedDecl *Decl, SourceLocation Loc) {
+    if (!Decl)
+      return true;
+    return checkOccurrence(Decl, Loc, Decl->getNameAsString().size());
+  }
+
+  /// \brief Sets Result to \p Decl if the occurrence checker returns true.
+  ///
+  /// \returns false on success.
+  bool checkOccurrence(const NamedDecl *Decl, SourceLocation Loc,
+                       unsigned Length) {
+    if (Loc.isMacroID()) {
+      const SourceManager &SM = Context.getSourceManager();
+      if (SM.isMacroArgExpansion(Loc))
+        Loc = SM.getSpellingLoc(Loc);
+      else
+        return true;
+    }
+
+    return Length == 0 ||
+           checkRange(Decl, Loc, Loc.getLocWithOffset(Length - 1));
+  }
+
+  bool checkOccurrence(const NamedDecl *ND, SourceLocation Start,
+                       SourceLocation End) {
+    const SourceManager &SM = Context.getSourceManager();
+    if (Start.isMacroID()) {
+      if (SM.isMacroArgExpansion(Start))
+        Start = SM.getSpellingLoc(Start);
+      else
+        return true;
+    }
+    if (End.isMacroID()) {
+      if (SM.isMacroArgExpansion(End))
+        End = SM.getSpellingLoc(End);
+      else
+        return true;
+    }
+    return checkRange(ND, Start, End);
+  }
+
+  const NamedDecl *Result;
+  const OccurrenceCheckerType &OccurrenceChecker;
+  const ASTContext &Context;
+};
+
+} // namespace
+
+static const ExternalSourceSymbolAttr *getExternalSymAttr(const Decl *D) {
+  if (const auto *A = D->getAttr<ExternalSourceSymbolAttr>())
+    return A;
+  if (const auto *DCD = dyn_cast<Decl>(D->getDeclContext())) {
+    if (const auto *A = DCD->getAttr<ExternalSourceSymbolAttr>())
+      return A;
+  }
+  return nullptr;
+}
+
+static bool overridesSystemMethod(const ObjCMethodDecl *MD,
+                                  const SourceManager &SM) {
+  SmallVector<const ObjCMethodDecl *, 8> Overrides;
+  MD->getOverriddenMethods(Overrides);
+  for (const auto *Override : Overrides) {
+    SourceLocation Loc = Override->getLocStart();
+    if (Loc.isValid()) {
+      if (SM.getFileCharacteristic(Loc) != SrcMgr::C_User)
+        return true;
+    }
+    if (overridesSystemMethod(Override, SM))
+      return true;
+  }
+  return false;
+}
+
+// TODO: Share with the indexer?
+static bool isTemplateImplicitInstantiation(const Decl *D) {
+  TemplateSpecializationKind TKind = TSK_Undeclared;
+  if (const ClassTemplateSpecializationDecl *SD =
+          dyn_cast<ClassTemplateSpecializationDecl>(D)) {
+    TKind = SD->getSpecializationKind();
+  } else if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+    TKind = FD->getTemplateSpecializationKind();
+  } else if (auto *VD = dyn_cast<VarDecl>(D)) {
+    TKind = VD->getTemplateSpecializationKind();
+  } else if (const auto *RD = dyn_cast<CXXRecordDecl>(D)) {
+    if (RD->getInstantiatedFromMemberClass())
+      TKind = RD->getTemplateSpecializationKind();
+  } else if (const auto *ED = dyn_cast<EnumDecl>(D)) {
+    if (ED->getInstantiatedFromMemberEnum())
+      TKind = ED->getTemplateSpecializationKind();
+  } else if (isa<FieldDecl>(D) || isa<TypedefNameDecl>(D) ||
+             isa<EnumConstantDecl>(D)) {
+    if (const auto *Parent = dyn_cast<Decl>(D->getDeclContext()))
+      return isTemplateImplicitInstantiation(Parent);
+  }
+  switch (TKind) {
+  case TSK_Undeclared:
+  case TSK_ExplicitSpecialization:
+    return false;
+  case TSK_ImplicitInstantiation:
+  case TSK_ExplicitInstantiationDeclaration:
+  case TSK_ExplicitInstantiationDefinition:
+    return true;
+  }
+  llvm_unreachable("invalid TemplateSpecializationKind");
+}
+
+static const CXXRecordDecl *
+getDeclContextForTemplateInstationPattern(const Decl *D) {
+  if (const auto *CTSD =
+          dyn_cast<ClassTemplateSpecializationDecl>(D->getDeclContext()))
+    return CTSD->getTemplateInstantiationPattern();
+  else if (const auto *RD = dyn_cast<CXXRecordDecl>(D->getDeclContext()))
+    return RD->getInstantiatedFromMemberClass();
+  return nullptr;
+}
+
+static const NamedDecl *
+adjustTemplateImplicitInstantiation(const NamedDecl *D) {
+  if (const ClassTemplateSpecializationDecl *SD =
+          dyn_cast<ClassTemplateSpecializationDecl>(D)) {
+    return SD->getTemplateInstantiationPattern();
+  } else if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+    return FD->getTemplateInstantiationPattern();
+  } else if (auto *VD = dyn_cast<VarDecl>(D)) {
+    return VD->getTemplateInstantiationPattern();
+  } else if (const auto *RD = dyn_cast<CXXRecordDecl>(D)) {
+    return RD->getInstantiatedFromMemberClass();
+  } else if (const auto *ED = dyn_cast<EnumDecl>(D)) {
+    return ED->getInstantiatedFromMemberEnum();
+  } else if (isa<FieldDecl>(D) || isa<TypedefNameDecl>(D)) {
+    const auto *ND = cast<NamedDecl>(D);
+    if (const CXXRecordDecl *Pattern =
+            getDeclContextForTemplateInstationPattern(ND)) {
+      for (const NamedDecl *BaseND : Pattern->lookup(ND->getDeclName())) {
+        if (BaseND->isImplicit())
+          continue;
+        if (BaseND->getKind() == ND->getKind())
+          return BaseND;
+      }
+    }
+  } else if (const auto *ECD = dyn_cast<EnumConstantDecl>(D)) {
+    if (const auto *ED = dyn_cast<EnumDecl>(ECD->getDeclContext())) {
+      if (const EnumDecl *Pattern = ED->getInstantiatedFromMemberEnum()) {
+        for (const NamedDecl *BaseECD : Pattern->lookup(ECD->getDeclName()))
+          return BaseECD;
+      }
+    }
+  }
+  return D;
+}
+
+const NamedDecl *getNamedDeclAt(const ASTContext &Context,
+                                SourceLocation Point) {
+  if (Point.isMacroID())
+    Point = Context.getSourceManager().getSpellingLoc(Point);
+  // FIXME: If point is in a system header, return early here.
+
+  OccurrenceCheckerType PointChecker = [Point, &Context](
+      const NamedDecl *Decl, SourceLocation Start, SourceLocation End) -> bool {
+    return Start.isValid() && Start.isFileID() && End.isValid() &&
+           End.isFileID() &&
+           isPointWithin(Point, Start, End, Context.getSourceManager());
+  };
+  NamedDeclFindingASTVisitor Visitor(PointChecker, Context);
+
+  // We only want to search the decls that exist in the same file as the point.
+  FileID InitiationFile = Context.getSourceManager().getFileID(Point);
+  for (auto *CurrDecl : Context.getTranslationUnitDecl()->decls()) {
+    const SourceRange DeclRange = CurrDecl->getSourceRange();
+    SourceLocation FileLoc;
+    if (DeclRange.getBegin().isMacroID() && !DeclRange.getEnd().isMacroID())
+      FileLoc = DeclRange.getEnd();
+    else
+      FileLoc = Context.getSourceManager().getSpellingLoc(DeclRange.getBegin());
+    // FIXME: Add test.
+    if (Context.getSourceManager().getFileID(FileLoc) == InitiationFile)
+      Visitor.TraverseDecl(CurrDecl);
+    if (Visitor.isDone())
+      break;
+  }
+
+  if (!Visitor.isDone()) {
+    NestedNameSpecifierLocFinder Finder(const_cast<ASTContext &>(Context));
+    for (const auto &Location : Finder.getNestedNameSpecifierLocations()) {
+      Visitor.handleNestedNameSpecifierLoc(Location);
+      if (Visitor.isDone())
+        break;
+    }
+  }
+
+  const auto Diag = [&](unsigned DiagID) -> DiagnosticBuilder {
+    return Context.getDiagnostics().Report(Point, DiagID);
+  };
+  const auto *ND = Visitor.getNamedDecl();
+  if (!ND)
+    return nullptr;
+
+  // Canonicalize the found declaration.
+  //
+  // If FoundDecl is a constructor or destructor, we want to instead take
+  // the Decl of the corresponding class.
+  if (const auto *CtorDecl = dyn_cast<CXXConstructorDecl>(ND))
+    ND = CtorDecl->getParent();
+  else if (const auto *DtorDecl = dyn_cast<CXXDestructorDecl>(ND))
+    ND = DtorDecl->getParent();
+
+  if (isTemplateImplicitInstantiation(ND))
+    ND = adjustTemplateImplicitInstantiation(ND);
+
+  // Builtins can't be renamed.
+  if (const auto *FD = dyn_cast<FunctionDecl>(ND)) {
+    if (FD->getBuiltinID()) {
+      Diag(diag::err_rename_builtin_function) << ND->getDeclName();
+      return nullptr;
+    }
+  }
+  // Declarations with invalid locations are probably implicit.
+  if (ND->getLocStart().isInvalid())
+    return nullptr;
+  // Declarations in system headers can't be renamed.
+  auto CheckSystemLoc = [&](SourceLocation Loc) -> bool {
+    if (Context.getSourceManager().getFileCharacteristic(Loc) !=
+        SrcMgr::C_User) {
+      Diag(diag::err_rename_sys_header) << ND->getDeclName();
+      return true;
+    }
+    return false;
+  };
+  if (CheckSystemLoc(ND->getLocStart()))
+    return nullptr;
+  if (const auto *TD = dyn_cast<TypedefNameDecl>(ND)) {
+    if (const TypedefNameDecl *CTD = TD->getCanonicalDecl()) {
+      if (CheckSystemLoc(CTD->getLocStart()))
+        return nullptr;
+    }
+  } else if (const auto *TD = dyn_cast<TagDecl>(ND)) {
+    if (const TagDecl *CTD = TD->getCanonicalDecl()) {
+      if (CheckSystemLoc(CTD->getLocStart()))
+        return nullptr;
+    }
+  } else if (const auto *FD = dyn_cast<FunctionDecl>(ND)) {
+    if (const FunctionDecl *CFD = FD->getCanonicalDecl()) {
+      if (CheckSystemLoc(CFD->getLocStart()))
+        return nullptr;
+    }
+  } else if (const auto *VD = dyn_cast<VarDecl>(ND)) {
+    if (const VarDecl *CVD = VD->getCanonicalDecl()) {
+      if (CheckSystemLoc(CVD->getLocStart()))
+        return nullptr;
+    }
+  }
+  // Declarations from other languages can't be renamed.
+  if (const ExternalSourceSymbolAttr *ESSA = getExternalSymAttr(ND)) {
+    Diag(diag::err_rename_external_source_symbol) << ND->getDeclName()
+                                                  << ESSA->getLanguage();
+    return nullptr;
+  }
+  // Methods that override methods from system headers can't be renamed.
+  if (const auto *MD = dyn_cast<ObjCMethodDecl>(ND)) {
+    if (overridesSystemMethod(MD, Context.getSourceManager())) {
+      Diag(diag::err_method_rename_override_sys_framework) << ND->getDeclName();
+      return nullptr;
+    }
+  }
+  return ND;
+}
+
+const NamedDecl *getNamedDeclWithUSR(const ASTContext &Context, StringRef USR) {
+  // TODO: Remove in favour of the new converter.
+  OccurrenceCheckerType USRChecker =
+      [USR](const NamedDecl *Decl, SourceLocation Start, SourceLocation End) {
+        return USR == getUSRForDecl(Decl);
+      };
+  NamedDeclFindingASTVisitor Visitor(USRChecker, Context);
+
+  for (auto *CurrDecl : Context.getTranslationUnitDecl()->decls()) {
+    Visitor.TraverseDecl(CurrDecl);
+    if (Visitor.isDone())
+      break;
+  }
+
+  // Don't need to visit nested name specifiers as they refer to previously
+  // declared declarations that we've already seen.
+  return Visitor.getNamedDecl();
+}
+
+std::string getUSRForDecl(const Decl *Decl) {
+  llvm::SmallVector<char, 128> Buff;
+
+  // FIXME: Add test for the nullptr case.
+  if (Decl == nullptr || index::generateUSRForDecl(Decl, Buff))
+    return "";
+
+  return std::string(Buff.data(), Buff.size());
+}
+
+} // end namespace rename
+} // end namespace tooling
+} // end namespace clang
diff --git a/lib/Tooling/Refactoring/CMakeLists.txt b/lib/Tooling/Refactoring/CMakeLists.txt
index 402b5d3c6a..db889d2a06 100644
--- a/lib/Tooling/Refactoring/CMakeLists.txt
+++ b/lib/Tooling/Refactoring/CMakeLists.txt
@@ -1,6 +1,6 @@
 set(LLVM_LINK_COMPONENTS Support)
 
-add_clang_library(clangToolingRefactor
+add_clang_library(clangToolingRefactoring
   ASTSelection.cpp
   ASTSelectionRequirements.cpp
   AtomicChange.cpp
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 9f76d36dba..ed13ce860f 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -10,6 +10,7 @@ add_clang_subdirectory(clang-import-test)
 add_clang_subdirectory(clang-offload-bundler)
 
 add_clang_subdirectory(c-index-test)
+add_clang_subdirectory(IndexStore)
 
 add_clang_subdirectory(clang-rename)
 add_clang_subdirectory(clang-refactor)
@@ -35,3 +36,6 @@ add_llvm_external_project(clang-tools-extra extra)
 
 # libclang may require clang-tidy in clang-tools-extra.
 add_clang_subdirectory(libclang)
+
+add_clang_subdirectory(clang-refactor-test)
+
diff --git a/tools/IndexStore/CMakeLists.txt b/tools/IndexStore/CMakeLists.txt
index e69de29bb2..616c402c14 100644
--- a/tools/IndexStore/CMakeLists.txt
+++ b/tools/IndexStore/CMakeLists.txt
@@ -0,0 +1,92 @@
+include(CheckIncludeFiles)
+
+set(SOURCES
+  IndexStore.cpp
+
+  ADDITIONAL_HEADERS
+  ../../include/indexstore/indexstore.h
+  ../../include/indexstore/IndexStoreCXX.h
+  )
+
+set(LIBS
+  clangDirectoryWatcher
+  clangIndex
+)
+
+set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/IndexStore.exports)
+
+set(ENABLE_SHARED SHARED)
+
+if(WIN32)
+  set(output_name "libIndexStore")
+else()
+  set(output_name "IndexStore")
+endif()
+
+# FIXME: needs to be ported to non-Apple platforms.
+if(APPLE)
+
+add_clang_library(IndexStore ${ENABLE_SHARED} ${ENABLE_STATIC}
+  OUTPUT_NAME ${output_name}
+  ${SOURCES}
+
+  LINK_LIBS
+  ${LIBS}
+
+  LINK_COMPONENTS
+  ${LLVM_TARGETS_TO_BUILD}
+  Core
+  Support
+  )
+
+set(INDEXSTORE_LIBRARY_VERSION "${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}")
+
+if(ENABLE_SHARED)
+  if(WIN32)
+    set_target_properties(IndexStore
+      PROPERTIES
+      VERSION ${INDEXSTORE_LIBRARY_VERSION}
+      DEFINE_SYMBOL _CINDEX_LIB_)
+  elseif(APPLE)
+    set(INDEXSTORE_LINK_FLAGS " -Wl,-compatibility_version -Wl,1")
+    set(INDEXSTORE_LINK_FLAGS "${INDEXSTORE_LINK_FLAGS} -Wl,-current_version -Wl,${INDEXSTORE_LIBRARY_VERSION}")
+
+    check_include_files("CoreServices/CoreServices.h" HAVE_CORESERVICES_H)
+    if(HAVE_CORESERVICES_H)
+      set(INDEXSTORE_LINK_FLAGS "${INDEXSTORE_LINK_FLAGS} -framework CoreServices")
+    endif()
+
+    set_property(TARGET IndexStore APPEND_STRING PROPERTY
+                 LINK_FLAGS ${INDEXSTORE_LINK_FLAGS})
+  else()
+    set_target_properties(IndexStore
+      PROPERTIES
+      VERSION ${INDEXSTORE_LIBRARY_VERSION}
+      DEFINE_SYMBOL _CINDEX_LIB_)
+  endif()
+endif()
+
+if (LLVM_INSTALL_TOOLCHAIN_ONLY)
+  install(TARGETS IndexStore
+    COMPONENT IndexStore
+    LIBRARY DESTINATION lib${LLVM_LIBDIR_SUFFIX}
+    ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX}
+    RUNTIME DESTINATION bin)
+
+  if (NOT CMAKE_CONFIGURATION_TYPES)
+    add_llvm_install_targets(install-IndexStore
+                             DEPENDS IndexStore
+                             COMPONENT IndexStore)
+  endif()
+endif()
+
+set(INDEXSTORE_HEADERS_INSTALL_DESTINATION "local/include")
+
+install(DIRECTORY ../../include/indexstore
+  COMPONENT IndexStore
+  DESTINATION "${INDEXSTORE_HEADERS_INSTALL_DESTINATION}"
+  FILES_MATCHING
+  PATTERN "*.h"
+  PATTERN ".svn" EXCLUDE
+  )
+endif()
diff --git a/tools/IndexStore/IndexStore.cpp b/tools/IndexStore/IndexStore.cpp
index e69de29bb2..b24cde8663 100644
--- a/tools/IndexStore/IndexStore.cpp
+++ b/tools/IndexStore/IndexStore.cpp
@@ -0,0 +1,647 @@
+//===- IndexStore.cpp - Index store API -----------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the API for the index store.
+//
+//===----------------------------------------------------------------------===//
+
+#include "indexstore/indexstore.h"
+#include "clang/Index/IndexDataStore.h"
+#include "clang/Index/IndexDataStoreSymbolUtils.h"
+#include "clang/Index/IndexRecordReader.h"
+#include "clang/Index/IndexUnitReader.h"
+#include "clang/Index/IndexUnitWriter.h"
+#include "clang/DirectoryWatcher/DirectoryWatcher.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/ADT/SmallString.h"
+#include "llvm/Support/Chrono.h"
+#include <Block.h>
+
+using namespace clang;
+using namespace clang::index;
+using namespace llvm;
+
+static indexstore_string_ref_t toIndexStoreString(StringRef str) {
+  return indexstore_string_ref_t{ str.data(), str.size() };
+}
+
+static timespec toTimeSpec(sys::TimePoint<> tp) {
+  std::chrono::seconds sec = std::chrono::time_point_cast<std::chrono::seconds>(
+                 tp).time_since_epoch();
+  std::chrono::nanoseconds nsec =
+    std::chrono::time_point_cast<std::chrono::nanoseconds>(tp - sec)
+      .time_since_epoch();
+  timespec ts;
+  ts.tv_sec = sec.count();
+  ts.tv_nsec = nsec.count();
+  return ts;
+}
+
+namespace {
+
+struct IndexStoreError {
+  std::string Error;
+};
+
+} // anonymous namespace
+
+const char *
+indexstore_error_get_description(indexstore_error_t err) {
+  return static_cast<IndexStoreError*>(err)->Error.c_str();
+}
+
+void
+indexstore_error_dispose(indexstore_error_t err) {
+  delete static_cast<IndexStoreError*>(err);
+}
+
+unsigned
+indexstore_format_version(void) {
+  return IndexDataStore::getFormatVersion();
+}
+
+indexstore_t
+indexstore_store_create(const char *store_path, indexstore_error_t *c_error) {
+  std::unique_ptr<IndexDataStore> store;
+  std::string error;
+  store = IndexDataStore::create(store_path, error);
+  if (!store) {
+    if (c_error)
+      *c_error = new IndexStoreError{ error };
+    return nullptr;
+  }
+  return store.release();
+}
+
+void
+indexstore_store_dispose(indexstore_t store) {
+  delete static_cast<IndexDataStore*>(store);
+}
+
+#if INDEXSTORE_HAS_BLOCKS
+bool
+indexstore_store_units_apply(indexstore_t c_store, unsigned sorted,
+                            bool(^applier)(indexstore_string_ref_t unit_name)) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  return store->foreachUnitName(sorted, [&](StringRef unitName) -> bool {
+    return applier(toIndexStoreString(unitName));
+  });
+}
+
+size_t
+indexstore_unit_event_notification_get_events_count(indexstore_unit_event_notification_t c_evtnote) {
+  auto *evtnote = static_cast<IndexDataStore::UnitEventNotification*>(c_evtnote);
+  return evtnote->Events.size();
+}
+
+indexstore_unit_event_t
+indexstore_unit_event_notification_get_event(indexstore_unit_event_notification_t c_evtnote, size_t index) {
+  auto *evtnote = static_cast<IndexDataStore::UnitEventNotification*>(c_evtnote);
+  return (indexstore_unit_event_t)&evtnote->Events[index];
+}
+
+bool
+indexstore_unit_event_notification_is_initial(indexstore_unit_event_notification_t c_evtnote) {
+  auto *evtnote = static_cast<IndexDataStore::UnitEventNotification*>(c_evtnote);
+  return evtnote->IsInitial;
+}
+
+indexstore_unit_event_kind_t
+indexstore_unit_event_get_kind(indexstore_unit_event_t c_evt) {
+  auto *evt = static_cast<IndexDataStore::UnitEvent*>(c_evt);
+  indexstore_unit_event_kind_t k;
+  switch (evt->Kind) {
+    case IndexDataStore::UnitEventKind::Added:
+      k = INDEXSTORE_UNIT_EVENT_ADDED; break;
+    case IndexDataStore::UnitEventKind::Removed:
+      k = INDEXSTORE_UNIT_EVENT_REMOVED; break;
+    case IndexDataStore::UnitEventKind::Modified:
+      k = INDEXSTORE_UNIT_EVENT_MODIFIED; break;
+    case IndexDataStore::UnitEventKind::DirectoryDeleted:
+      k = INDEXSTORE_UNIT_EVENT_DIRECTORY_DELETED; break;
+  }
+  return k;
+}
+
+indexstore_string_ref_t
+indexstore_unit_event_get_unit_name(indexstore_unit_event_t c_evt) {
+  auto *evt = static_cast<IndexDataStore::UnitEvent*>(c_evt);
+  return toIndexStoreString(evt->UnitName);
+}
+
+timespec
+indexstore_unit_event_get_modification_time(indexstore_unit_event_t c_evt) {
+  auto *evt = static_cast<IndexDataStore::UnitEvent*>(c_evt);
+  return toTimeSpec(evt->ModTime);
+}
+
+void
+indexstore_store_set_unit_event_handler(indexstore_t c_store,
+                                    indexstore_unit_event_handler_t blk_handler) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  if (!blk_handler) {
+    store->setUnitEventHandler(nullptr);
+    return;
+  }
+
+  class BlockWrapper {
+    indexstore_unit_event_handler_t blk_handler;
+  public:
+    BlockWrapper(indexstore_unit_event_handler_t handler) {
+      blk_handler = Block_copy(handler);
+    }
+    BlockWrapper(const BlockWrapper &other) {
+      blk_handler = Block_copy(other.blk_handler);
+    }
+    ~BlockWrapper() {
+      Block_release(blk_handler);
+    }
+
+    void operator()(indexstore_unit_event_notification_t evt_note) const {
+      blk_handler(evt_note);
+    }
+  };
+
+  BlockWrapper handler(blk_handler);
+
+  store->setUnitEventHandler([handler](IndexDataStore::UnitEventNotification evtNote) {
+    handler(&evtNote);
+  });
+}
+#endif
+
+bool
+indexstore_store_start_unit_event_listening(indexstore_t c_store,
+                                            indexstore_unit_event_listen_options_t *client_opts,
+                                            size_t listen_options_struct_size,
+                                            indexstore_error_t *c_error) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  indexstore_unit_event_listen_options_t listen_opts;
+  memset(&listen_opts, 0, sizeof(listen_opts));
+  unsigned clientOptSize = listen_options_struct_size < sizeof(listen_opts)
+                             ? listen_options_struct_size : sizeof(listen_opts);
+  memcpy(&listen_opts, client_opts, clientOptSize);
+
+  std::string error;
+  auto createFn = [](StringRef Path, AbstractDirectoryWatcher::EventReceiver Receiver, bool waitInitialSync, std::string &Error)
+      -> std::unique_ptr<AbstractDirectoryWatcher> {
+    return DirectoryWatcher::create(Path, std::move(Receiver), waitInitialSync, Error);
+  };
+  bool err = store->startEventListening(createFn, listen_opts.wait_initial_sync, error);
+  if (err && c_error)
+    *c_error = new IndexStoreError{ error };
+  return err;
+}
+
+void
+indexstore_store_stop_unit_event_listening(indexstore_t c_store) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  store->stopEventListening();
+}
+
+void
+indexstore_store_discard_unit(indexstore_t c_store, const char *unit_name) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  store->discardUnit(unit_name);
+}
+
+void
+indexstore_store_discard_record(indexstore_t c_store, const char *record_name) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  store->discardRecord(record_name);
+}
+
+void
+indexstore_store_purge_stale_data(indexstore_t c_store) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  store->purgeStaleData();
+}
+
+indexstore_symbol_kind_t
+indexstore_symbol_get_kind(indexstore_symbol_t sym) {
+  return getIndexStoreKind(static_cast<IndexRecordDecl *>(sym)->SymInfo.Kind);
+}
+
+indexstore_symbol_subkind_t
+indexstore_symbol_get_subkind(indexstore_symbol_t sym) {
+  return getIndexStoreSubKind(static_cast<IndexRecordDecl *>(sym)->SymInfo.SubKind);
+}
+
+indexstore_symbol_language_t
+indexstore_symbol_get_language(indexstore_symbol_t sym) {
+  return getIndexStoreLang(static_cast<IndexRecordDecl *>(sym)->SymInfo.Lang);
+}
+
+uint64_t
+indexstore_symbol_get_properties(indexstore_symbol_t sym) {
+  return getIndexStoreProperties(static_cast<IndexRecordDecl *>(sym)->SymInfo.Properties);
+}
+
+uint64_t
+indexstore_symbol_get_roles(indexstore_symbol_t sym) {
+  return getIndexStoreRoles(static_cast<IndexRecordDecl *>(sym)->Roles);
+}
+
+uint64_t
+indexstore_symbol_get_related_roles(indexstore_symbol_t sym) {
+  return getIndexStoreRoles(static_cast<IndexRecordDecl *>(sym)->RelatedRoles);
+}
+
+indexstore_string_ref_t
+indexstore_symbol_get_name(indexstore_symbol_t sym) {
+  auto *D = static_cast<IndexRecordDecl*>(sym);
+  return toIndexStoreString(D->Name);
+}
+
+indexstore_string_ref_t
+indexstore_symbol_get_usr(indexstore_symbol_t sym) {
+  auto *D = static_cast<IndexRecordDecl*>(sym);
+  return toIndexStoreString(D->USR);
+}
+
+indexstore_string_ref_t
+indexstore_symbol_get_codegen_name(indexstore_symbol_t sym) {
+  auto *D = static_cast<IndexRecordDecl*>(sym);
+  return toIndexStoreString(D->CodeGenName);
+}
+
+uint64_t
+indexstore_symbol_relation_get_roles(indexstore_symbol_relation_t sym_rel) {
+  return getIndexStoreRoles(static_cast<IndexRecordRelation *>(sym_rel)->Roles);
+}
+
+indexstore_symbol_t
+indexstore_symbol_relation_get_symbol(indexstore_symbol_relation_t sym_rel) {
+  return (indexstore_symbol_t)static_cast<IndexRecordRelation*>(sym_rel)->Dcl;
+}
+
+indexstore_symbol_t
+indexstore_occurrence_get_symbol(indexstore_occurrence_t occur) {
+  return (indexstore_symbol_t)static_cast<IndexRecordOccurrence*>(occur)->Dcl;
+}
+
+#if INDEXSTORE_HAS_BLOCKS
+bool
+indexstore_occurrence_relations_apply(indexstore_occurrence_t occur,
+                      bool(^applier)(indexstore_symbol_relation_t symbol_rel)) {
+  auto *recOccur = static_cast<IndexRecordOccurrence*>(occur);
+  for (auto &rel : recOccur->Relations) {
+    if (!applier(&rel))
+      return false;
+  }
+  return true;
+}
+#endif
+
+uint64_t
+indexstore_occurrence_get_roles(indexstore_occurrence_t occur) {
+  return static_cast<IndexRecordOccurrence*>(occur)->Roles;
+}
+
+void
+indexstore_occurrence_get_line_col(indexstore_occurrence_t occur,
+                              unsigned *line, unsigned *column) {
+  auto *recOccur = static_cast<IndexRecordOccurrence*>(occur);
+  if (line)
+    *line = recOccur->Line;
+  if (column)
+    *column = recOccur->Column;
+}
+
+typedef void *indexstore_record_reader_t;
+
+indexstore_record_reader_t
+indexstore_record_reader_create(indexstore_t c_store, const char *record_name,
+                                indexstore_error_t *c_error) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  std::unique_ptr<IndexRecordReader> reader;
+  std::string error;
+  reader = IndexRecordReader::createWithRecordFilename(record_name,
+                                                       store->getFilePath(),
+                                                       error);
+  if (!reader) {
+    if (c_error)
+      *c_error = new IndexStoreError{ error };
+    return nullptr;
+  }
+  return reader.release();
+}
+
+void
+indexstore_record_reader_dispose(indexstore_record_reader_t rdr) {
+  auto *reader = static_cast<IndexRecordReader *>(rdr);
+  delete reader;
+}
+
+#if INDEXSTORE_HAS_BLOCKS
+/// Goes through the symbol data and passes symbols to \c receiver, for the
+/// symbol data that \c filter returns true on.
+///
+/// This allows allocating memory only for the record symbols that the caller is
+/// interested in.
+bool
+indexstore_record_reader_search_symbols(indexstore_record_reader_t rdr,
+    bool(^filter)(indexstore_symbol_t symbol, bool *stop),
+    void(^receiver)(indexstore_symbol_t symbol)) {
+  auto *reader = static_cast<IndexRecordReader *>(rdr);
+
+  auto filterFn = [&](const IndexRecordDecl &D) -> IndexRecordReader::DeclSearchReturn {
+    bool stop = false;
+    bool accept = filter((indexstore_symbol_t)&D, &stop);
+    return { accept, !stop };
+  };
+  auto receiverFn = [&](const IndexRecordDecl *D) {
+    receiver((indexstore_symbol_t)D);
+  };
+
+  return reader->searchDecls(filterFn, receiverFn);
+}
+
+bool
+indexstore_record_reader_symbols_apply(indexstore_record_reader_t rdr,
+                                        bool nocache,
+                                   bool(^applier)(indexstore_symbol_t symbol)) {
+  auto *reader = static_cast<IndexRecordReader *>(rdr);
+  auto receiverFn = [&](const IndexRecordDecl *D) -> bool {
+    return applier((indexstore_symbol_t)D);
+  };
+  return reader->foreachDecl(nocache, receiverFn);
+}
+
+bool
+indexstore_record_reader_occurrences_apply(indexstore_record_reader_t rdr,
+                                bool(^applier)(indexstore_occurrence_t occur)) {
+  auto *reader = static_cast<IndexRecordReader *>(rdr);
+  auto receiverFn = [&](const IndexRecordOccurrence &RO) -> bool {
+    return applier((indexstore_occurrence_t)&RO);
+  };
+  return reader->foreachOccurrence(receiverFn);
+}
+
+bool
+indexstore_record_reader_occurrences_in_line_range_apply(indexstore_record_reader_t rdr,
+                                                         unsigned line_start,
+                                                         unsigned line_count,
+                                bool(^applier)(indexstore_occurrence_t occur)) {
+  auto *reader = static_cast<IndexRecordReader *>(rdr);
+  auto receiverFn = [&](const IndexRecordOccurrence &RO) -> bool {
+    return applier((indexstore_occurrence_t)&RO);
+  };
+  return reader->foreachOccurrenceInLineRange(line_start, line_count, receiverFn);
+}
+
+/// \param symbols if non-zero \c symbols_count, indicates the list of symbols
+/// that we want to get occurrences for. An empty array indicates that we want
+/// occurrences for all symbols.
+/// \param related_symbols Same as \c symbols but for related symbols.
+bool
+indexstore_record_reader_occurrences_of_symbols_apply(indexstore_record_reader_t rdr,
+        indexstore_symbol_t *symbols, size_t symbols_count,
+        indexstore_symbol_t *related_symbols, size_t related_symbols_count,
+        bool(^applier)(indexstore_occurrence_t occur)) {
+  auto *reader = static_cast<IndexRecordReader *>(rdr);
+  auto receiverFn = [&](const IndexRecordOccurrence &RO) -> bool {
+    return applier((indexstore_occurrence_t)&RO);
+  };
+  return reader->foreachOccurrence({(IndexRecordDecl**)symbols, symbols_count},
+                                   {(IndexRecordDecl**)related_symbols, related_symbols_count},
+                                   receiverFn);
+}
+#endif
+
+size_t
+indexstore_store_get_unit_name_from_output_path(indexstore_t store,
+                                                const char *output_path,
+                                                char *name_buf,
+                                                size_t buf_size) {
+  SmallString<256> unitName;
+  IndexUnitWriter::getUnitNameForAbsoluteOutputFile(output_path, unitName);
+  size_t nameLen = unitName.size();
+  strlcpy(name_buf, unitName.c_str(), buf_size);
+  return nameLen;
+}
+
+bool
+indexstore_store_get_unit_modification_time(indexstore_t c_store,
+                                            const char *unit_name,
+                                            int64_t *seconds,
+                                            int64_t *nanoseconds,
+                                            indexstore_error_t *c_error) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  std::string error;
+  // FIXME: This provides mod time with second-only accuracy.
+  auto optModTime = IndexUnitReader::getModificationTimeForUnit(unit_name,
+                                              store->getFilePath(), error);
+  if (!optModTime) {
+    if (c_error)
+      *c_error = new IndexStoreError{ error };
+    return true;
+  }
+
+  timespec ts = toTimeSpec(*optModTime);
+  if (seconds)
+    *seconds = ts.tv_sec;
+  if (nanoseconds)
+    *nanoseconds = ts.tv_nsec;
+
+  return false;
+}
+
+indexstore_unit_reader_t
+indexstore_unit_reader_create(indexstore_t c_store, const char *unit_name,
+                              indexstore_error_t *c_error) {
+  IndexDataStore *store = static_cast<IndexDataStore*>(c_store);
+  std::unique_ptr<IndexUnitReader> reader;
+  std::string error;
+  reader = IndexUnitReader::createWithUnitFilename(unit_name,
+                                                   store->getFilePath(), error);
+  if (!reader) {
+    if (c_error)
+      *c_error = new IndexStoreError{ error };
+    return nullptr;
+  }
+  return reader.release();
+}
+
+void
+indexstore_unit_reader_dispose(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  delete reader;
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_provider_identifier(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getProviderIdentifier());
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_provider_version(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getProviderVersion());
+}
+
+void
+indexstore_unit_reader_get_modification_time(indexstore_unit_reader_t rdr,
+                                             int64_t *seconds,
+                                             int64_t *nanoseconds) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  // FIXME: This provides mod time with second-only accuracy.
+  sys::TimePoint<> timeVal = reader->getModificationTime();
+  timespec ts = toTimeSpec(timeVal);
+  if (seconds)
+    *seconds = ts.tv_sec;
+  if (nanoseconds)
+    *nanoseconds = ts.tv_nsec;
+}
+
+bool
+indexstore_unit_reader_is_system_unit(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return reader->isSystemUnit();
+}
+
+bool
+indexstore_unit_reader_is_module_unit(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return reader->isModuleUnit();
+}
+
+bool
+indexstore_unit_reader_is_debug_compilation(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return reader->isDebugCompilation();
+}
+
+bool
+indexstore_unit_reader_has_main_file(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return reader->hasMainFile();
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_main_file(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getMainFilePath());
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_module_name(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getModuleName());
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_working_dir(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getWorkingDirectory());
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_output_file(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getOutputFile());
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_sysroot_path(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getSysrootPath());
+}
+
+indexstore_string_ref_t
+indexstore_unit_reader_get_target(indexstore_unit_reader_t rdr) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return toIndexStoreString(reader->getTarget());
+}
+
+indexstore_unit_dependency_kind_t
+indexstore_unit_dependency_get_kind(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  switch (dep->Kind) {
+  case IndexUnitReader::DependencyKind::Unit: return INDEXSTORE_UNIT_DEPENDENCY_UNIT;
+  case IndexUnitReader::DependencyKind::Record: return INDEXSTORE_UNIT_DEPENDENCY_RECORD;
+  case IndexUnitReader::DependencyKind::File: return INDEXSTORE_UNIT_DEPENDENCY_FILE;
+  }
+}
+
+bool
+indexstore_unit_dependency_is_system(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  return dep->IsSystem;
+}
+
+indexstore_string_ref_t
+indexstore_unit_dependency_get_filepath(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  return toIndexStoreString(dep->FilePath);
+}
+
+indexstore_string_ref_t
+indexstore_unit_dependency_get_modulename(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  return toIndexStoreString(dep->ModuleName);
+}
+
+indexstore_string_ref_t
+indexstore_unit_dependency_get_name(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  return toIndexStoreString(dep->UnitOrRecordName);
+}
+
+time_t
+indexstore_unit_dependency_get_modification_time(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  return dep->ModTime;
+}
+
+size_t
+indexstore_unit_dependency_get_file_size(indexstore_unit_dependency_t c_dep) {
+  auto dep = static_cast<const IndexUnitReader::DependencyInfo*>(c_dep);
+  return dep->FileSize;
+}
+
+indexstore_string_ref_t
+indexstore_unit_include_get_source_path(indexstore_unit_include_t c_inc) {
+  auto inc = static_cast<const IndexUnitReader::IncludeInfo*>(c_inc);
+  return toIndexStoreString(inc->SourcePath);
+}
+
+indexstore_string_ref_t
+indexstore_unit_include_get_target_path(indexstore_unit_include_t c_inc) {
+  auto inc = static_cast<const IndexUnitReader::IncludeInfo*>(c_inc);
+  return toIndexStoreString(inc->TargetPath);
+}
+
+unsigned
+indexstore_unit_include_get_source_line(indexstore_unit_include_t c_inc) {
+  auto inc = static_cast<const IndexUnitReader::IncludeInfo*>(c_inc);
+  return inc->SourceLine;
+}
+
+#if INDEXSTORE_HAS_BLOCKS
+bool
+indexstore_unit_reader_dependencies_apply(indexstore_unit_reader_t rdr,
+                             bool(^applier)(indexstore_unit_dependency_t)) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return reader->foreachDependency([&](const IndexUnitReader::DependencyInfo &depInfo) -> bool {
+    return applier((void*)&depInfo);
+  });
+}
+
+bool
+indexstore_unit_reader_includes_apply(indexstore_unit_reader_t rdr,
+                             bool(^applier)(indexstore_unit_include_t)) {
+  auto reader = static_cast<IndexUnitReader*>(rdr);
+  return reader->foreachInclude([&](const IndexUnitReader::IncludeInfo &incInfo) -> bool {
+    return applier((void*)&incInfo);
+  });
+}
+#endif
diff --git a/tools/IndexStore/IndexStore.exports b/tools/IndexStore/IndexStore.exports
index e69de29bb2..70c174f360 100644
--- a/tools/IndexStore/IndexStore.exports
+++ b/tools/IndexStore/IndexStore.exports
@@ -0,0 +1,69 @@
+indexstore_error_get_description
+indexstore_error_dispose
+indexstore_format_version
+indexstore_store_create
+indexstore_store_dispose
+indexstore_store_get_unit_modification_time
+indexstore_store_get_unit_name_from_output_path
+indexstore_store_units_apply
+indexstore_store_set_unit_event_handler
+indexstore_store_start_unit_event_listening
+indexstore_store_stop_unit_event_listening
+indexstore_store_discard_unit
+indexstore_store_discard_record
+indexstore_store_purge_stale_data
+indexstore_symbol_get_kind
+indexstore_symbol_get_language
+indexstore_symbol_get_properties
+indexstore_symbol_get_roles
+indexstore_symbol_get_related_roles
+indexstore_symbol_get_subkind
+indexstore_symbol_get_name
+indexstore_symbol_get_usr
+indexstore_symbol_get_codegen_name
+indexstore_symbol_relation_get_roles
+indexstore_symbol_relation_get_symbol
+indexstore_occurrence_get_symbol
+indexstore_occurrence_get_roles
+indexstore_occurrence_get_line_col
+indexstore_occurrence_relations_apply
+indexstore_record_reader_create
+indexstore_record_reader_dispose
+indexstore_record_reader_search_symbols
+indexstore_record_reader_symbols_apply
+indexstore_record_reader_occurrences_apply
+indexstore_record_reader_occurrences_in_line_range_apply
+indexstore_record_reader_occurrences_of_symbols_apply
+indexstore_unit_dependency_get_kind
+indexstore_unit_dependency_get_filepath
+indexstore_unit_dependency_get_file_size
+indexstore_unit_dependency_get_modification_time
+indexstore_unit_dependency_get_modulename
+indexstore_unit_dependency_get_name
+indexstore_unit_dependency_is_system
+indexstore_unit_event_get_kind
+indexstore_unit_event_get_modification_time
+indexstore_unit_event_get_unit_name
+indexstore_unit_event_notification_get_event
+indexstore_unit_event_notification_get_events_count
+indexstore_unit_event_notification_is_initial
+indexstore_unit_reader_create
+indexstore_unit_reader_dispose
+indexstore_unit_reader_get_main_file
+indexstore_unit_reader_get_modification_time
+indexstore_unit_reader_get_module_name
+indexstore_unit_reader_get_provider_identifier
+indexstore_unit_reader_get_provider_version
+indexstore_unit_reader_get_working_dir
+indexstore_unit_reader_get_output_file
+indexstore_unit_reader_get_sysroot_path
+indexstore_unit_reader_get_target
+indexstore_unit_reader_dependencies_apply
+indexstore_unit_reader_includes_apply
+indexstore_unit_reader_has_main_file
+indexstore_unit_reader_is_debug_compilation
+indexstore_unit_reader_is_module_unit
+indexstore_unit_reader_is_system_unit
+indexstore_unit_include_get_source_path
+indexstore_unit_include_get_target_path
+indexstore_unit_include_get_source_line
diff --git a/tools/c-index-test/CMakeLists.txt b/tools/c-index-test/CMakeLists.txt
index d38c7bb287..82245dc08a 100644
--- a/tools/c-index-test/CMakeLists.txt
+++ b/tools/c-index-test/CMakeLists.txt
@@ -1,3 +1,5 @@
+include(CheckIncludeFiles)
+
 set(LLVM_LINK_COMPONENTS
   support
 )
@@ -5,8 +7,15 @@ set(LLVM_LINK_COMPONENTS
 add_clang_executable(c-index-test
   c-index-test.c
   core_main.cpp
+  JSONAggregation.cpp
   )
 
+set(INDEXSTORE_LIB)
+set(CINDEXTEST_LIBS)
+if(APPLE)
+  set(INDEXSTORE_LIB IndexStore)
+endif()
+
 if(NOT MSVC)
   set_property(
     SOURCE c-index-test.c
@@ -20,17 +29,21 @@ if (LLVM_BUILD_STATIC)
     libclang_static
     clangCodeGen
     clangIndex
+    ${CINDEXTEST_LIBS}
   )
 else()
   target_link_libraries(c-index-test
     PRIVATE
     libclang
+    ${INDEXSTORE_LIB}
     clangAST
     clangBasic
     clangCodeGen
+    clangDirectoryWatcher
     clangFrontend
     clangIndex
     clangSerialization
+    ${CINDEXTEST_LIBS}
   )
 endif()
 
@@ -44,6 +57,13 @@ if (CLANG_HAVE_LIBXML)
   target_link_libraries(c-index-test PRIVATE ${LIBXML2_LIBRARIES})
 endif()
 
+if(APPLE)
+  check_include_files("CoreServices/CoreServices.h" HAVE_CORESERVICES_H)
+  if(HAVE_CORESERVICES_H)
+    target_link_libraries(c-index-test PRIVATE "-framework CoreServices")
+  endif()
+endif()
+
 if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY)
   if(INTERNAL_INSTALL_PREFIX)
     set(INSTALL_DESTINATION "${INTERNAL_INSTALL_PREFIX}/bin")
diff --git a/tools/c-index-test/JSONAggregation.cpp b/tools/c-index-test/JSONAggregation.cpp
index e69de29bb2..83118fcc23 100644
--- a/tools/c-index-test/JSONAggregation.cpp
+++ b/tools/c-index-test/JSONAggregation.cpp
@@ -0,0 +1,411 @@
+//===--- JSONAggregation.cpp - Index data aggregation in JSON format ------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "JSONAggregation.h"
+#include "indexstore/IndexStoreCXX.h"
+#include "clang/Frontend/Utils.h"
+#include "clang/Index/IndexDataStoreSymbolUtils.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/Support/Allocator.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace clang;
+using namespace clang::index;
+using namespace indexstore;
+using namespace llvm;
+
+#if INDEXSTORE_HAS_BLOCKS
+
+namespace {
+
+typedef size_t FilePathIndex;
+typedef size_t RecordIndex;
+typedef size_t SymbolIndex;
+
+struct UnitSourceInfo {
+  FilePathIndex FilePath;
+  SmallVector<RecordIndex, 2> AssociatedRecords;
+};
+
+struct UnitInfo {
+  std::string Name;
+  SmallVector<UnitSourceInfo, 8> Sources;
+  SmallVector<std::string, 3> UnitDepends;
+  FilePathIndex OutFile;
+  StringRef Triple;
+};
+
+struct SymbolInfo {
+  SymbolKind Kind;
+  SymbolLanguage Lang;
+  StringRef USR;
+  StringRef Name;
+  StringRef CodegenName;
+  SymbolRoleSet Roles = 0;
+  SymbolRoleSet RelatedRoles = 0;
+};
+
+struct SymbolRelationInfo {
+  SymbolIndex RelatedSymbol;
+  SymbolRoleSet Roles;
+  SymbolRelationInfo(SymbolIndex relSymbol, SymbolRoleSet roles)
+    : RelatedSymbol(relSymbol), Roles(roles) {}
+};
+
+struct SymbolOccurrenceInfo {
+  SymbolIndex Symbol;
+  SymbolRoleSet Roles = 0;
+  std::vector<SymbolRelationInfo> Relations;
+  unsigned Line;
+  unsigned Column;
+};
+
+struct RecordInfo {
+  SmallVector<SymbolOccurrenceInfo, 8> Occurrences;
+};
+
+class Aggregator {
+  IndexStore Store;
+
+  BumpPtrAllocator Allocator;
+
+  StringMap<FilePathIndex, BumpPtrAllocator &> FilePathIndices;
+  std::vector<StringRef> FilePaths;
+  StringMap<char, BumpPtrAllocator &> Triples;
+
+  std::vector<std::unique_ptr<UnitInfo>> Units;
+
+  StringMap<RecordIndex, BumpPtrAllocator &> RecordIndices;
+  std::vector<std::unique_ptr<RecordInfo>> Records;
+
+  StringMap<SymbolIndex, BumpPtrAllocator &> SymbolIndices;
+  std::vector<SymbolInfo> Symbols;
+
+public:
+  explicit Aggregator(IndexStore store)
+  : Store(std::move(store)),
+    FilePathIndices(Allocator),
+    Triples(Allocator),
+    RecordIndices(Allocator),
+    SymbolIndices(Allocator) {}
+
+  bool process();
+  void processUnit(StringRef name, IndexUnitReader &UnitReader);
+  void dumpJSON(raw_ostream &OS);
+
+private:
+  StringRef copyStr(StringRef str) {
+    if (str.empty())
+      return StringRef();
+    char *buf = Allocator.Allocate<char>(str.size());
+    std::copy(str.begin(), str.end(), buf);
+    return StringRef(buf, str.size());
+  }
+
+  StringRef getTripleString(StringRef inputTriple) {
+    return Triples.insert(std::make_pair(inputTriple, 0)).first->first();
+  }
+
+  FilePathIndex getFilePathIndex(StringRef path, StringRef workingDir);
+  RecordIndex getRecordIndex(StringRef recordFile);
+  SymbolIndex getSymbolIndex(IndexRecordSymbol sym);
+  std::unique_ptr<RecordInfo> processRecord(StringRef recordFile);
+};
+
+} // anonymous namespace
+
+bool Aggregator::process() {
+  bool succ = Store.foreachUnit(/*sorted=*/true, [&](StringRef unitName) -> bool {
+    std::string error;
+    auto unitReader = IndexUnitReader(Store, unitName, error);
+    if (!unitReader) {
+      errs() << "error opening unit file '" << unitName << "': " << error << '\n';
+      return false;
+    }
+
+    processUnit(unitName, unitReader);
+    return true;
+  });
+
+  return !succ;
+}
+
+void Aggregator::processUnit(StringRef name, IndexUnitReader &UnitReader) {
+  auto workDir = UnitReader.getWorkingDirectory();
+  auto unit = llvm::make_unique<UnitInfo>();
+  unit->Name = name;
+  unit->Triple = getTripleString(UnitReader.getTarget());
+  unit->OutFile = getFilePathIndex(UnitReader.getOutputFile(), workDir);
+
+  struct DepInfo {
+    UnitSourceInfo source;
+    std::string unitName;
+  };
+  SmallVector<DepInfo, 32> Deps;
+  UnitReader.foreachDependency([&](IndexUnitDependency dep) -> bool {
+    Deps.resize(Deps.size()+1);
+    auto &depInfo = Deps.back();
+    switch (dep.getKind()) {
+      case IndexUnitDependency::DependencyKind::Unit: {
+        depInfo.unitName = dep.getName();
+        StringRef filePath = dep.getFilePath();
+        if (!filePath.empty())
+          depInfo.source.FilePath = getFilePathIndex(filePath, workDir);
+        break;
+      }
+      case IndexUnitDependency::DependencyKind::Record: {
+        depInfo.source.FilePath = getFilePathIndex(dep.getFilePath(), workDir);
+        RecordIndex recIndex = getRecordIndex(dep.getName());
+        depInfo.source.AssociatedRecords.push_back(recIndex);
+        break;
+      }
+      case IndexUnitDependency::DependencyKind::File:
+        depInfo.source.FilePath = getFilePathIndex(dep.getFilePath(), workDir);
+    }
+    return true;
+  });
+
+  unit->Sources.reserve(Deps.size());
+  for (auto &dep : Deps) {
+    if (!dep.unitName.empty()) {
+      unit->UnitDepends.emplace_back(std::move(dep.unitName));
+    } else {
+      unit->Sources.push_back(std::move(dep.source));
+    }
+  }
+
+  Units.push_back(std::move(unit));
+}
+
+FilePathIndex Aggregator::getFilePathIndex(StringRef path, StringRef workingDir) {
+  StringRef absPath;
+  SmallString<128> absPathBuf;
+  if (sys::path::is_absolute(path) || workingDir.empty()) {
+    absPath = path;
+  } else {
+    absPathBuf = workingDir;
+    sys::path::append(absPathBuf, path);
+    absPath = absPathBuf.str();
+  }
+
+  auto pair = FilePathIndices.insert(std::make_pair(absPath, FilePaths.size()));
+  bool wasInserted = pair.second;
+  if (wasInserted) {
+    FilePaths.push_back(pair.first->first());
+  }
+  return pair.first->second;
+}
+
+RecordIndex Aggregator::getRecordIndex(StringRef recordFile) {
+  auto pair = RecordIndices.insert(std::make_pair(recordFile, Records.size()));
+  bool wasInserted = pair.second;
+  if (wasInserted) {
+    Records.push_back(processRecord(recordFile));
+  }
+  return pair.first->second;
+}
+
+std::unique_ptr<RecordInfo> Aggregator::processRecord(StringRef recordFile) {
+  std::string error;
+  auto recordReader = IndexRecordReader(Store, recordFile, error);
+  if (!recordReader) {
+    errs() << "failed reading record file: " << recordFile << '\n';
+    ::exit(1);
+  }
+  auto record = llvm::make_unique<RecordInfo>();
+  recordReader.foreachOccurrence([&](IndexRecordOccurrence idxOccur) -> bool {
+    SymbolIndex symIdx = getSymbolIndex(idxOccur.getSymbol());
+    SymbolInfo &symInfo = Symbols[symIdx];
+    symInfo.Roles |= idxOccur.getRoles();
+    SymbolOccurrenceInfo occurInfo;
+    occurInfo.Symbol = symIdx;
+    idxOccur.foreachRelation([&](IndexSymbolRelation rel) -> bool {
+      SymbolIndex relsymIdx = getSymbolIndex(rel.getSymbol());
+      SymbolInfo &relsymInfo = Symbols[relsymIdx];
+      relsymInfo.RelatedRoles |= rel.getRoles();
+      occurInfo.Relations.emplace_back(relsymIdx, rel.getRoles());
+      return true;
+    });
+    occurInfo.Roles = idxOccur.getRoles();
+    std::tie(occurInfo.Line, occurInfo.Column) = idxOccur.getLineCol();
+    record->Occurrences.push_back(std::move(occurInfo));
+    return true;
+  });
+  return record;
+}
+
+SymbolIndex Aggregator::getSymbolIndex(IndexRecordSymbol sym) {
+  auto pair = SymbolIndices.insert(std::make_pair(sym.getUSR(), Symbols.size()));
+  bool wasInserted = pair.second;
+  if (wasInserted) {
+    SymbolInfo symInfo;
+    symInfo.Kind = getSymbolKind(sym.getKind());
+    symInfo.Lang = getSymbolLanguage(sym.getLanguage());
+    symInfo.USR = pair.first->first();
+    symInfo.Name = copyStr(sym.getName());
+    symInfo.CodegenName = copyStr(sym.getCodegenName());
+    Symbols.push_back(std::move(symInfo));
+  }
+  return pair.first->second;
+}
+
+
+void Aggregator::dumpJSON(raw_ostream &OS) {
+  OS << "{\n";
+  OS.indent(2) << "\"files\": [\n";
+  for (unsigned i = 0, e = FilePaths.size(); i != e; ++i) {
+    OS.indent(4) << '\"' << FilePaths[i] << '\"';
+    if (i < e-1) OS << ',';
+    OS << '\n';
+  }
+  OS.indent(2) << "],\n";
+
+  OS.indent(2) << "\"symbols\": [\n";
+  for (unsigned i = 0, e = Symbols.size(); i != e; ++i) {
+    OS.indent(4) << "{\n";
+    SymbolInfo &symInfo = Symbols[i];
+    OS.indent(6) << "\"kind\": \"" << getSymbolKindString(symInfo.Kind) << "\",\n";
+    OS.indent(6) << "\"lang\": \"" << getSymbolLanguageString(symInfo.Lang) << "\",\n";
+    OS.indent(6) << "\"usr\": \"" << symInfo.USR << "\",\n";
+    OS.indent(6) << "\"name\": \"" << symInfo.Name << "\",\n";
+    if (!symInfo.CodegenName.empty())
+      OS.indent(6) << "\"codegen\": \"" << symInfo.CodegenName << "\",\n";
+    OS.indent(6) << "\"roles\": \"";
+    printSymbolRoles(symInfo.Roles, OS);
+    OS << '\"';
+    if (symInfo.RelatedRoles != 0) {
+      OS << ",\n";
+      OS.indent(6) << "\"rel-roles\": \"";
+      printSymbolRoles(symInfo.RelatedRoles, OS);
+      OS << '\"';
+    }
+    OS << '\n';
+    OS.indent(4) << "}";
+    if (i < e-1) OS << ',';
+    OS << '\n';
+  }
+  OS.indent(2) << "],\n";
+
+  OS.indent(2) << "\"records\": [\n";
+  for (unsigned i = 0, e = Records.size(); i != e; ++i) {
+    OS.indent(4) << "{\n";
+    RecordInfo &recInfo = *Records[i];
+    OS.indent(6) << "\"occurrences\": [\n";
+    for (unsigned oi = 0, oe = recInfo.Occurrences.size(); oi != oe; ++oi) {
+      OS.indent(8) << "{\n";
+      SymbolOccurrenceInfo &occurInfo = recInfo.Occurrences[oi];
+      OS.indent(10) << "\"symbol\": " << occurInfo.Symbol << ",\n";
+      OS.indent(10) << "\"line\": " << occurInfo.Line << ",\n";
+      OS.indent(10) << "\"col\": " << occurInfo.Column << ",\n";
+      OS.indent(10) << "\"roles\": \"";
+      printSymbolRoles(occurInfo.Roles, OS);
+      OS << '\"';
+      if (!occurInfo.Relations.empty()) {
+        OS << ",\n";
+        OS.indent(10) << "\"relations\": [\n";
+        for (unsigned ri = 0, re = occurInfo.Relations.size(); ri != re; ++ri) {
+          OS.indent(12) << "{\n";
+          SymbolRelationInfo &relInfo = occurInfo.Relations[ri];
+          OS.indent(14) << "\"symbol\": " << relInfo.RelatedSymbol << ",\n";
+          OS.indent(14) << "\"rel-roles\": \"";
+          printSymbolRoles(relInfo.Roles, OS);
+          OS << "\"\n";
+          OS.indent(12) << "}";
+          if (ri < re-1) OS << ',';
+          OS << '\n';
+        }
+        OS.indent(10) << "]\n";
+      }
+      OS << '\n';
+      OS.indent(8) << "}";
+      if (oi < oe-1) OS << ',';
+      OS << '\n';
+    }
+    OS.indent(6) << "]\n";
+    OS.indent(4) << "}";
+    if (i < e-1) OS << ',';
+    OS << '\n';
+  }
+  OS.indent(2) << "],\n";
+
+  StringMap<size_t> UnitIndicesByName;
+  for (unsigned i = 0, e = Units.size(); i != e; ++i) {
+    UnitInfo &unit = *Units[i];
+    UnitIndicesByName[unit.Name] = i;
+  }
+
+  OS.indent(2) << "\"units\": [\n";
+  for (unsigned i = 0, e = Units.size(); i != e; ++i) {
+    OS.indent(4) << "{\n";
+    UnitInfo &unit = *Units[i];
+    OS.indent(6) << "\"triple\": \"" << unit.Triple << "\",\n";
+    OS.indent(6) << "\"out-file\": " << unit.OutFile << ",\n";
+    if (!unit.UnitDepends.empty()) {
+      OS.indent(6) << "\"unit-dependencies\": [";
+      for (unsigned ui = 0, ue = unit.UnitDepends.size(); ui != ue; ++ui) {
+        OS << UnitIndicesByName[unit.UnitDepends[ui]];
+        if (ui < ue-1) OS << ", ";
+      }
+      OS << "],\n";
+    }
+    OS.indent(6) << "\"sources\": [\n";
+    for (unsigned si = 0, se = unit.Sources.size(); si != se; ++si) {
+      OS.indent(8) << "{\n";
+      UnitSourceInfo &source = unit.Sources[si];
+      OS.indent(10) << "\"file\": " << source.FilePath;
+      if (!source.AssociatedRecords.empty()) {
+        OS << ",\n";
+        OS.indent(10) << "\"records\": [";
+        for (unsigned ri = 0, re = source.AssociatedRecords.size(); ri != re; ++ri) {
+          OS << source.AssociatedRecords[ri];
+          if (ri < re-1) OS << ", ";
+        }
+        OS << ']';
+      }
+      OS << '\n';
+      OS.indent(8) << "}";
+      if (si < se-1) OS << ',';
+      OS << '\n';
+    }
+    OS.indent(6) << "]\n";
+    OS.indent(4) << "}";
+    if (i < e-1) OS << ',';
+    OS << '\n';
+  }
+  OS.indent(2) << "]\n";
+  OS << "}\n";
+}
+
+
+bool index::aggregateDataAsJSON(StringRef StorePath, raw_ostream &OS) {
+  std::string error;
+  auto dataStore = IndexStore(StorePath, error);
+  if (!dataStore) {
+    errs() << "error opening store path '" << StorePath << "': " << error << '\n';
+    return true;
+  }
+
+  // Explicitely avoid doing any memory cleanup for aggregator since the process
+  // is going to exit when we are done.
+  Aggregator *aggregator = new Aggregator(std::move(dataStore));
+  bool err = aggregator->process();
+  if (err)
+    return true;
+  aggregator->dumpJSON(OS);
+  BuryPointer(aggregator);
+  return false;
+}
+
+#else
+
+bool index::aggregateDataAsJSON(StringRef StorePath, raw_ostream &OS) {
+  return true;
+}
+#endif
diff --git a/tools/c-index-test/JSONAggregation.h b/tools/c-index-test/JSONAggregation.h
index e69de29bb2..5224ce8e87 100644
--- a/tools/c-index-test/JSONAggregation.h
+++ b/tools/c-index-test/JSONAggregation.h
@@ -0,0 +1,24 @@
+//===--- JSONAggregation.h - Index data aggregation in JSON format --------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLS_CINDEXTEST_JSONAGGREGATION_H
+#define LLVM_CLANG_TOOLS_CINDEXTEST_JSONAGGREGATION_H
+
+#include "clang/Basic/LLVM.h"
+
+namespace clang {
+namespace index {
+
+/// Returns true if an error occurred, false otherwise.
+bool aggregateDataAsJSON(StringRef StorePath, raw_ostream &OS);
+
+} // end namespace index
+} // end namespace clang
+
+#endif
diff --git a/tools/c-index-test/c-index-test.c b/tools/c-index-test/c-index-test.c
index 99f05669b6..fab284d92c 100644
--- a/tools/c-index-test/c-index-test.c
+++ b/tools/c-index-test/c-index-test.c
@@ -110,6 +110,10 @@ static void describeLibclangFailure(enum CXErrorCode Err) {
   case CXError_ASTReadError:
     fprintf(stderr, "Failure: AST deserialization error occurred\n");
     return;
+
+  default:
+    fprintf(stderr, "Failure (other)\n");
+    return;
   }
 }
 
diff --git a/tools/c-index-test/core_main.cpp b/tools/c-index-test/core_main.cpp
index c255f54ba6..0a6ee1b5fa 100644
--- a/tools/c-index-test/core_main.cpp
+++ b/tools/c-index-test/core_main.cpp
@@ -7,6 +7,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "JSONAggregation.h"
+#include "indexstore/IndexStoreCXX.h"
+#include "clang/DirectoryWatcher/DirectoryWatcher.h"
 #include "clang/CodeGen/ObjectFilePCHContainerOperations.h"
 #include "clang/Frontend/ASTUnit.h"
 #include "clang/Frontend/CompilerInstance.h"
@@ -14,14 +17,31 @@
 #include "clang/Frontend/FrontendAction.h"
 #include "clang/Index/IndexingAction.h"
 #include "clang/Index/IndexDataConsumer.h"
+#include "clang/Index/IndexDataStoreSymbolUtils.h"
+#include "clang/Index/IndexRecordReader.h"
+#include "clang/Index/IndexUnitReader.h"
 #include "clang/Index/USRGeneration.h"
 #include "clang/Index/CodegenNameGenerator.h"
 #include "clang/Serialization/ASTReader.h"
 #include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Path.h"
 #include "llvm/Support/Signals.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Support/PrettyStackTrace.h"
 
+#define HAVE_CORESERVICES 0
+
+#if defined(__has_include)
+#if __has_include(<CoreServices/CoreServices.h>)
+
+#include <CoreServices/CoreServices.h>
+#undef HAVE_CORESERVICES
+#define HAVE_CORESERVICES 1
+
+#endif
+#endif
+
 using namespace clang;
 using namespace clang::index;
 using namespace llvm;
@@ -33,6 +53,11 @@ namespace {
 enum class ActionType {
   None,
   PrintSourceSymbols,
+  PrintRecord,
+  PrintUnit,
+  PrintStoreFormatVersion,
+  AggregateAsJSON,
+  WatchDir,
 };
 
 namespace options {
@@ -43,9 +68,26 @@ static cl::opt<ActionType>
 Action(cl::desc("Action:"), cl::init(ActionType::None),
        cl::values(
           clEnumValN(ActionType::PrintSourceSymbols,
-                     "print-source-symbols", "Print symbols from source")),
+                     "print-source-symbols", "Print symbols from source"),
+          clEnumValN(ActionType::PrintRecord,
+                     "print-record", "Print record info"),
+          clEnumValN(ActionType::PrintUnit,
+                     "print-unit", "Print unit info"),
+          clEnumValN(ActionType::PrintStoreFormatVersion,
+                     "print-store-format-version", "Print store format version"),
+          clEnumValN(ActionType::AggregateAsJSON,
+                     "aggregate-json", "Aggregate index data in JSON format"),
+          clEnumValN(ActionType::WatchDir,
+                     "watch-dir", "Watch directory for file events")),
        cl::cat(IndexTestCoreCategory));
 
+static cl::opt<std::string>
+OutputFile("o", cl::desc("output file"),
+           cl::cat(IndexTestCoreCategory));
+
+static cl::list<std::string>
+InputFiles(cl::Positional, cl::desc("<filename>..."));
+
 static cl::extrahelp MoreHelp(
   "\nAdd \"-- <compiler arguments>\" at the end to setup the compiler "
   "invocation\n"
@@ -65,6 +107,10 @@ static cl::opt<std::string>
   ModuleFormat("fmodule-format", cl::init("raw"),
         cl::desc("Container format for clang modules and PCH, 'raw' or 'obj'"));
 
+static cl::opt<std::string>
+FilePathAndRange("filepath",
+               cl::desc("File path that can optionally include a line range"));
+
 }
 } // anonymous namespace
 
@@ -235,6 +281,305 @@ static bool printSourceSymbolsFromModule(StringRef modulePath,
   return false;
 }
 
+#if INDEXSTORE_HAS_BLOCKS
+
+//===----------------------------------------------------------------------===//
+// Print Record
+//===----------------------------------------------------------------------===//
+
+static void printSymbol(const IndexRecordDecl &Rec, raw_ostream &OS);
+static void printSymbol(const IndexRecordOccurrence &Rec, raw_ostream &OS);
+
+static int printRecord(StringRef Filename, raw_ostream &OS) {
+  std::string Error;
+  auto Reader = IndexRecordReader::createWithFilePath(Filename, Error);
+  if (!Reader) {
+    errs() << Error << '\n';
+    return true;
+  }
+
+  Reader->foreachDecl(/*noCache=*/true, [&](const IndexRecordDecl *Rec)->bool {
+    printSymbol(*Rec, OS);
+    return true;
+  });
+  OS << "------------\n";
+  Reader->foreachOccurrence([&](const IndexRecordOccurrence &Rec)->bool {
+    printSymbol(Rec, OS);
+    return true;
+  });
+
+  return false;
+};
+
+//===----------------------------------------------------------------------===//
+// Print Store Records
+//===----------------------------------------------------------------------===//
+
+static void printSymbol(indexstore::IndexRecordSymbol Sym, raw_ostream &OS);
+static void printSymbol(indexstore::IndexRecordOccurrence Occur, raw_ostream &OS);
+
+static bool printStoreRecord(indexstore::IndexStore &Store, StringRef RecName,
+                             StringRef FilePath, raw_ostream &OS) {
+  std::string Error;
+  indexstore::IndexRecordReader Reader(Store, RecName, Error);
+  if (!Reader) {
+    errs() << "error loading record: " << Error << "\n";
+    return true;
+  }
+
+  StringRef Filename = sys::path::filename(FilePath);
+  OS << Filename << '\n';
+  OS << "------------\n";
+  Reader.foreachSymbol(/*noCache=*/true, [&](indexstore::IndexRecordSymbol Sym) -> bool {
+    printSymbol(Sym, OS);
+    return true;
+  });
+  OS << "------------\n";
+  Reader.foreachOccurrence([&](indexstore::IndexRecordOccurrence Occur)->bool {
+    printSymbol(Occur, OS);
+    return true;
+  });
+
+  return false;
+}
+
+static int printStoreRecords(StringRef StorePath, raw_ostream &OS) {
+  std::string Error;
+  indexstore::IndexStore Store(StorePath, Error);
+  if (!Store) {
+    errs() << "error loading store: " << Error << "\n";
+    return 1;
+  }
+
+  bool Success = Store.foreachUnit(/*sorted=*/true, [&](StringRef UnitName) -> bool {
+    indexstore::IndexUnitReader Reader(Store, UnitName, Error);
+    if (!Reader) {
+      errs() << "error loading unit: " << Error << "\n";
+      return false;
+    }
+    return Reader.foreachDependency([&](indexstore::IndexUnitDependency Dep) -> bool {
+      if (Dep.getKind() == indexstore::IndexUnitDependency::DependencyKind::Record) {
+        bool Err = printStoreRecord(Store, Dep.getName(), Dep.getFilePath(), OS);
+        OS << '\n';
+        return !Err;
+      }
+      return true;
+    });
+  });
+
+  return !Success;
+}
+
+static std::string findRecordNameForFile(indexstore::IndexStore &store,
+                                         StringRef filePath) {
+  std::string recName;
+  store.foreachUnit(/*sorted=*/false, [&](StringRef unitName) -> bool {
+    std::string error;
+    indexstore::IndexUnitReader Reader(store, unitName, error);
+    if (!Reader) {
+      errs() << "error loading unit: " << error << "\n";
+      return false;
+    }
+    Reader.foreachDependency([&](indexstore::IndexUnitDependency Dep) -> bool {
+      if (Dep.getKind() == indexstore::IndexUnitDependency::DependencyKind::Record) {
+        if (Dep.getFilePath() == filePath) {
+          recName = Dep.getName();
+          return false;
+        }
+        return true;
+      }
+      return true;
+    });
+    return true;
+  });
+  return recName;
+}
+
+static int printStoreFileRecord(StringRef storePath, StringRef filePath,
+                                Optional<unsigned> lineStart, unsigned lineCount,
+                                raw_ostream &OS) {
+  std::string error;
+  indexstore::IndexStore store(storePath, error);
+  if (!store) {
+    errs() << "error loading store: " << error << "\n";
+    return 1;
+  }
+
+  std::string recName = findRecordNameForFile(store, filePath);
+  if (recName.empty()) {
+    errs() << "could not find record for '" << filePath << "'\n";
+    return 1;
+  }
+
+  if (!lineStart.hasValue())
+    return printStoreRecord(store, recName, filePath, OS);
+
+  indexstore::IndexRecordReader Reader(store, recName, error);
+  if (!Reader) {
+    errs() << "error loading record: " << error << "\n";
+    return 1;
+  }
+
+  Reader.foreachOccurrenceInLineRange(*lineStart, lineCount, [&](indexstore::IndexRecordOccurrence Occur)->bool {
+    printSymbol(Occur, OS);
+    return true;
+  });
+
+  return 0;
+}
+
+
+//===----------------------------------------------------------------------===//
+// Print Unit
+//===----------------------------------------------------------------------===//
+
+static int printUnit(StringRef Filename, raw_ostream &OS) {
+  std::string Error;
+  auto Reader = IndexUnitReader::createWithFilePath(Filename, Error);
+  if (!Reader) {
+    errs() << Error << '\n';
+    return true;
+  }
+
+  OS << "provider: " << Reader->getProviderIdentifier() << '-' << Reader->getProviderVersion() << '\n';
+  OS << "is-system: " << Reader->isSystemUnit() << '\n';
+  OS << "is-module: " << Reader->isModuleUnit() << '\n';
+  OS << "module-name: " << (Reader->getModuleName().empty() ? "<none>" : Reader->getModuleName()) << '\n';
+  OS << "has-main: " << Reader->hasMainFile() << '\n';
+  OS << "main-path: " << Reader->getMainFilePath() << '\n';
+  OS << "work-dir: " << Reader->getWorkingDirectory() << '\n';
+  OS << "out-file: " << Reader->getOutputFile() << '\n';
+  OS << "target: " << Reader->getTarget() << '\n';
+  OS << "is-debug: " << Reader->isDebugCompilation() << '\n';
+  OS << "DEPEND START\n";
+  unsigned NumDepends = 0;
+  Reader->foreachDependency([&](const IndexUnitReader::DependencyInfo &Dep) -> bool {
+    switch (Dep.Kind) {
+    case IndexUnitReader::DependencyKind::Unit:
+      OS << "Unit | "; break;
+    case IndexUnitReader::DependencyKind::Record:
+      OS << "Record | "; break;
+    case IndexUnitReader::DependencyKind::File:
+      OS << "File | "; break;
+    }
+    OS << (Dep.IsSystem ? "system" : "user");
+    OS << " | ";
+    if (!Dep.ModuleName.empty())
+      OS << Dep.ModuleName << " | ";
+    OS << Dep.FilePath << " | " << Dep.UnitOrRecordName << " | ";
+    OS << Dep.ModTime << " | " << Dep.FileSize << '\n';
+    ++NumDepends;
+    return true;
+  });
+  OS << "DEPEND END (" << NumDepends << ")\n";
+  OS << "INCLUDE START\n";
+  unsigned NumIncludes = 0;
+  Reader->foreachInclude([&](const IndexUnitReader::IncludeInfo &Inc) -> bool {
+    OS << Inc.SourcePath << ":" << Inc.SourceLine << " | ";
+    OS << Inc.TargetPath << '\n';
+    ++NumIncludes;
+    return true;
+  });
+  OS << "INCLUDE END (" << NumIncludes << ")\n";
+
+  return false;
+};
+
+//===----------------------------------------------------------------------===//
+// Print Store Units
+//===----------------------------------------------------------------------===//
+
+static bool printStoreUnit(indexstore::IndexStore &Store, StringRef UnitName,
+                           raw_ostream &OS) {
+  std::string Error;
+  indexstore::IndexUnitReader Reader(Store, UnitName, Error);
+  if (!Reader) {
+    errs() << "error loading unit: " << Error << "\n";
+    return true;
+  }
+
+  OS << "provider: " << Reader.getProviderIdentifier() << '-' << Reader.getProviderVersion() << '\n';
+  OS << "is-system: " << Reader.isSystemUnit() << '\n';
+  OS << "is-module: " << Reader.isModuleUnit() << '\n';
+  OS << "module-name: " << (Reader.getModuleName().empty() ? "<none>" : Reader.getModuleName()) << '\n';
+  OS << "has-main: " << Reader.hasMainFile() << '\n';
+  OS << "main-path: " << Reader.getMainFilePath() << '\n';
+  OS << "work-dir: " << Reader.getWorkingDirectory() << '\n';
+  OS << "out-file: " << Reader.getOutputFile() << '\n';
+  OS << "target: " << Reader.getTarget() << '\n';
+  OS << "is-debug: " << Reader.isDebugCompilation() << '\n';
+  OS << "DEPEND START\n";
+  unsigned NumDepends = 0;
+  Reader.foreachDependency([&](indexstore::IndexUnitDependency Dep) -> bool {
+    switch (Dep.getKind()) {
+    case indexstore::IndexUnitDependency::DependencyKind::Unit:
+      OS << "Unit | "; break;
+    case indexstore::IndexUnitDependency::DependencyKind::Record:
+      OS << "Record | "; break;
+    case indexstore::IndexUnitDependency::DependencyKind::File:
+      OS << "File | "; break;
+    }
+    OS << (Dep.isSystem() ? "system" : "user");
+    OS << " | ";
+    if (!Dep.getModuleName().empty())
+      OS << Dep.getModuleName() << " | ";
+    OS << Dep.getFilePath() << " | " << Dep.getName() << " | ";
+    OS << Dep.getModificationTime() << '\n';
+    ++NumDepends;
+    return true;
+  });
+  OS << "DEPEND END (" << NumDepends << ")\n";
+  OS << "INCLUDE START\n";
+  unsigned NumIncludes = 0;
+  Reader.foreachInclude([&](indexstore::IndexUnitInclude Inc) -> bool {
+    OS << Inc.getSourcePath() << ":" << Inc.getSourceLine() << " | ";
+    OS << Inc.getTargetPath() << '\n';
+    ++NumIncludes;
+    return true;
+  });
+  OS << "INCLUDE END (" << NumIncludes << ")\n";
+
+  return false;
+}
+
+static int printStoreUnits(StringRef StorePath, raw_ostream &OS) {
+  std::string Error;
+  indexstore::IndexStore Store(StorePath, Error);
+  if (!Store) {
+    errs() << "error loading store: " << Error << "\n";
+    return 1;
+  }
+
+  bool Success = Store.foreachUnit(/*sorted=*/true, [&](StringRef UnitName) -> bool {
+    OS << UnitName << '\n';
+    OS << "--------\n";
+    bool err = printStoreUnit(Store, UnitName, OS);
+    OS << '\n';
+    return !err;
+  });
+
+  return !Success;
+}
+
+
+#else
+
+static int printUnit(StringRef Filename, raw_ostream &OS) {
+  return 1;
+}
+
+static int printStoreUnits(StringRef StorePath, raw_ostream &OS) {
+  return 1;
+}
+
+static int printStoreFileRecord(StringRef storePath, StringRef filePath,
+                                Optional<unsigned> lineStart, unsigned lineCount,
+                                raw_ostream &OS) {
+  return 1;
+}
+
+#endif
+
 //===----------------------------------------------------------------------===//
 // Helper Utils
 //===----------------------------------------------------------------------===//
@@ -266,10 +611,210 @@ static void printSymbolNameAndUSR(const Decl *D, ASTContext &Ctx,
   }
 }
 
+#if INDEXSTORE_HAS_BLOCKS
+
+static void printSymbol(const IndexRecordDecl &Rec, raw_ostream &OS) {
+  printSymbolInfo(Rec.SymInfo, OS);
+  OS << " | ";
+
+  if (Rec.Name.empty())
+    OS << "<no-name>";
+  else
+    OS << Rec.Name;
+  OS << " | ";
+
+  if (Rec.USR.empty())
+    OS << "<no-usr>";
+  else
+    OS << Rec.USR;
+  OS << " | ";
+
+  if (Rec.CodeGenName.empty())
+    OS << "<no-cgname>";
+  else
+    OS << Rec.CodeGenName;
+  OS << " | ";
+
+  printSymbolRoles(Rec.Roles, OS);
+  OS << " - ";
+  printSymbolRoles(Rec.RelatedRoles, OS);
+  OS << '\n';
+}
+
+static void printSymbol(const IndexRecordOccurrence &Rec, raw_ostream &OS) {
+  OS << Rec.Line << ':' << Rec.Column << " | ";
+  printSymbolInfo(Rec.Dcl->SymInfo, OS);
+  OS << " | ";
+
+  if (Rec.Dcl->USR.empty())
+    OS << "<no-usr>";
+  else
+    OS << Rec.Dcl->USR;
+  OS << " | ";
+
+  printSymbolRoles(Rec.Roles, OS);
+  OS << " | ";
+  OS << "rel: " << Rec.Relations.size() << '\n';
+  for (auto &Rel : Rec.Relations) {
+    OS << '\t';
+    printSymbolRoles(Rel.Roles, OS);
+    OS << " | ";
+    if (Rel.Dcl->USR.empty())
+      OS << "<no-usr>";
+    else
+      OS << Rel.Dcl->USR;
+    OS << '\n';
+  }
+}
+
+static void printSymbol(indexstore::IndexRecordSymbol Sym, raw_ostream &OS) {
+  SymbolInfo SymInfo{getSymbolKind(Sym.getKind()),
+                     getSymbolSubKind(Sym.getSubKind()),
+                     getSymbolLanguage(Sym.getLanguage()),
+                     SymbolPropertySet(Sym.getProperties())};
+
+  printSymbolInfo(SymInfo, OS);
+  OS << " | ";
+
+  if (Sym.getName().empty())
+    OS << "<no-name>";
+  else
+    OS << Sym.getName();
+  OS << " | ";
+
+  if (Sym.getUSR().empty())
+    OS << "<no-usr>";
+  else
+    OS << Sym.getUSR();
+  OS << " | ";
+
+  if (Sym.getCodegenName().empty())
+    OS << "<no-cgname>";
+  else
+    OS << Sym.getCodegenName();
+  OS << " | ";
+
+  printSymbolRoles(Sym.getRoles(), OS);
+  OS << " - ";
+  printSymbolRoles(Sym.getRelatedRoles(), OS);
+  OS << '\n';
+}
+
+static void printSymbol(indexstore::IndexRecordOccurrence Occur, raw_ostream &OS) {
+  OS << Occur.getLineCol().first << ':' << Occur.getLineCol().second << " | ";
+  auto Sym = Occur.getSymbol();
+  SymbolInfo SymInfo{getSymbolKind(Sym.getKind()),
+                     getSymbolSubKind(Sym.getSubKind()),
+                     getSymbolLanguage(Sym.getLanguage()),
+                     SymbolPropertySet(Sym.getProperties())};
+
+  printSymbolInfo(SymInfo, OS);
+  OS << " | ";
+
+  if (Sym.getUSR().empty())
+    OS << "<no-usr>";
+  else
+    OS << Sym.getUSR();
+  OS << " | ";
+
+  unsigned NumRelations = 0;
+  Occur.foreachRelation([&](indexstore::IndexSymbolRelation) {
+    ++NumRelations;
+    return true;
+  });
+
+  printSymbolRoles(Occur.getRoles(), OS);
+  OS << " | ";
+  OS << "rel: " << NumRelations << '\n';
+  Occur.foreachRelation([&](indexstore::IndexSymbolRelation Rel) {
+    OS << '\t';
+    printSymbolRoles(Rel.getRoles(), OS);
+    OS << " | ";
+    auto Sym = Rel.getSymbol();
+    if (Sym.getUSR().empty())
+      OS << "<no-usr>";
+    else
+      OS << Sym.getUSR();
+    OS << '\n';
+    return true;
+  });
+}
+
+#else
+
+static int printRecord(StringRef Filename, raw_ostream &OS) {
+  return 1;
+}
+static int printStoreRecords(StringRef StorePath, raw_ostream &OS) {
+  return 1;
+}
+
+#endif
+
+static int watchDirectory(StringRef dirPath) {
+  raw_ostream &OS = outs();
+  auto receiver = [&](ArrayRef<DirectoryWatcher::Event> Events, bool isInitial) {
+    for (auto evt : Events) {
+      switch (evt.Kind) {
+        case DirectoryWatcher::EventKind::Added:
+          OS << "added: "; break;
+        case DirectoryWatcher::EventKind::Modified:
+          OS << "modified: "; break;
+        case DirectoryWatcher::EventKind::Removed:
+          OS << "removed: "; break;
+        case DirectoryWatcher::EventKind::DirectoryDeleted:
+          OS << "dir deleted: "; break;
+
+      }
+      OS << evt.Filename << '\n';
+    }
+  };
+  std::string Error;
+  auto watcher = DirectoryWatcher::create(dirPath, receiver,
+                                          /*waitInitialSync=*/true, Error);
+  if (!watcher) {
+    errs() << "failed creating directory watcher: " << Error << '\n';
+    return 1;
+  }
+#if HAVE_CORESERVICES
+  dispatch_main();
+#else
+  return 1;
+#endif
+}
+
 //===----------------------------------------------------------------------===//
 // Command line processing.
 //===----------------------------------------------------------------------===//
 
+bool deconstructPathAndRange(StringRef input,
+                             std::string &filepath,
+                             Optional<unsigned> &lineStart,
+                             unsigned &lineCount) {
+  StringRef path, range;
+  std::tie(path, range) = input.split(':');
+  StringRef start, end;
+  std::tie(start, end) = range.split(':');
+  filepath = path;
+  lineCount = 0;
+  if (start.empty())
+    return false;
+  unsigned num;
+  if (start.getAsInteger(10, num)) {
+    errs() << "couldn't convert to integer: " << start << '\n';
+    return true;
+  }
+  lineStart = num;
+  if (end.empty())
+    return false;
+  if (end.getAsInteger(10, num)) {
+    errs() << "couldn't convert to integer: " << end << '\n';
+    return true;
+  }
+  lineCount = num-lineStart.getValue();
+  return false;
+}
+
 int indextest_core_main(int argc, const char **argv) {
   sys::PrintStackTraceOnErrorSignal(argv[0]);
   PrettyStackTraceProgram X(argc, argv);
@@ -305,5 +850,75 @@ int indextest_core_main(int argc, const char **argv) {
     return printSourceSymbols(CompArgs, options::DumpModuleImports, options::IncludeLocals);
   }
 
+  if (options::Action == ActionType::PrintRecord) {
+    if (!options::FilePathAndRange.empty()) {
+      std::string filepath;
+      Optional<unsigned> lineStart;
+      unsigned lineCount;
+      if (deconstructPathAndRange(options::FilePathAndRange,
+                                  filepath, lineStart, lineCount))
+        return 1;
+
+      if (options::InputFiles.empty()) {
+        errs() << "error: missing index store path\n";
+        return 1;
+      }
+      return printStoreFileRecord(options::InputFiles[0], filepath, lineStart, lineCount, outs());
+    }
+
+    if (options::InputFiles.empty()) {
+      errs() << "error: missing input file or directory\n";
+      return 1;
+    }
+
+    if (sys::fs::is_directory(options::InputFiles[0]))
+      return printStoreRecords(options::InputFiles[0], outs());
+    else
+      return printRecord(options::InputFiles[0], outs());
+  }
+
+  if (options::Action == ActionType::PrintUnit) {
+    if (options::InputFiles.empty()) {
+      errs() << "error: missing input file or directory\n";
+      return 1;
+    }
+
+    if (sys::fs::is_directory(options::InputFiles[0]))
+      return printStoreUnits(options::InputFiles[0], outs());
+    else
+      return printUnit(options::InputFiles[0], outs());
+  }
+
+#if INDEXSTORE_HAS_BLOCKS
+  if (options::Action == ActionType::PrintStoreFormatVersion) {
+    outs() << indexstore::IndexStore::formatVersion() << '\n';
+  }
+#endif
+
+  if (options::Action == ActionType::AggregateAsJSON) {
+    if (options::InputFiles.empty()) {
+      errs() << "error: missing input data store directory\n";
+      return 1;
+    }
+    StringRef storePath = options::InputFiles[0];
+    if (options::OutputFile.empty())
+      return aggregateDataAsJSON(storePath, outs());
+    std::error_code EC;
+    raw_fd_ostream OS(options::OutputFile, EC, llvm::sys::fs::F_None);
+    if (EC) {
+      errs() << "failed to open output file: " << EC.message() << '\n';
+      return 1;
+    }
+    return aggregateDataAsJSON(storePath, OS);
+  }
+
+  if (options::Action == ActionType::WatchDir) {
+    if (options::InputFiles.empty()) {
+      errs() << "error: missing directory path\n";
+      return 1;
+    }
+    return watchDirectory(options::InputFiles[0]);
+  }
+
   return 0;
 }
diff --git a/tools/clang-check/CMakeLists.txt b/tools/clang-check/CMakeLists.txt
index c5ace26c29..903d288bc3 100644
--- a/tools/clang-check/CMakeLists.txt
+++ b/tools/clang-check/CMakeLists.txt
@@ -10,6 +10,7 @@ add_clang_executable(clang-check
 
 target_link_libraries(clang-check
   PRIVATE
+  clangAPINotes
   clangAST
   clangBasic
   clangDriver
diff --git a/tools/clang-refactor-test/CMakeLists.txt b/tools/clang-refactor-test/CMakeLists.txt
index e69de29bb2..1817ed00ad 100644
--- a/tools/clang-refactor-test/CMakeLists.txt
+++ b/tools/clang-refactor-test/CMakeLists.txt
@@ -0,0 +1,25 @@
+set(LLVM_LINK_COMPONENTS
+  support
+  )
+
+add_clang_executable(clang-refactor-test
+  ClangRefactorTest.cpp
+  )
+
+if (LLVM_BUILD_STATIC)
+  target_link_libraries(clang-refactor-test
+    PRIVATE
+    libclang_static
+  )
+else()
+  target_link_libraries(clang-refactor-test
+    PRIVATE
+    libclang
+    clangBasic
+    clangFrontend
+    clangRewrite
+    clangTooling
+    clangToolingCore
+    clangToolingRefactor
+  )
+endif()
diff --git a/tools/clang-refactor-test/ClangRefactorTest.cpp b/tools/clang-refactor-test/ClangRefactorTest.cpp
index e69de29bb2..3bca876ce4 100644
--- a/tools/clang-refactor-test/ClangRefactorTest.cpp
+++ b/tools/clang-refactor-test/ClangRefactorTest.cpp
@@ -0,0 +1,1403 @@
+//===--- ClangRefactorTest.cpp - ------------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//  This file implements a clang-refactor-test tool that is used to test the
+//  refactoring library in Clang.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang-c/Refactor.h"
+#include "clang/Basic/LangOptions.h"
+#include "clang/Frontend/CommandLineSourceLoc.h"
+#include "clang/Tooling/Refactor/SymbolName.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/LineIterator.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/Regex.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+using namespace clang;
+
+namespace opts {
+
+static cl::OptionCategory
+    ClangRefactorTestOptions("clang-refactor-test common options");
+
+cl::SubCommand RenameInitiateSubcommand(
+    "rename-initiate", "Initiate renaming in an initial translation unit");
+
+cl::SubCommand RenameInitiateUSRSubcommand(
+    "rename-initiate-usr",
+    "Initiate renaming in an translation unit on a specific declaration");
+
+cl::SubCommand RenameIndexedFileSubcommand(
+    "rename-indexed-file",
+    "Initiate renaming and find occurrences in an indexed file");
+
+cl::SubCommand ListRefactoringActionsSubcommand("list-actions",
+                                                "Print the list of the "
+                                                "refactoring actions that can "
+                                                "be performed at the specified "
+                                                "location");
+
+cl::SubCommand InitiateActionSubcommand("initiate",
+                                        "Initiate a refactoring action");
+
+cl::SubCommand
+    PerformActionSubcommand("perform",
+                            "Initiate and perform a refactoring action");
+
+const cl::desc
+    AtOptionDescription("The location at which the refactoring should be "
+                        "initiated (<file>:<line>:<column>)");
+
+const cl::desc InRangeOptionDescription(
+    "The location(s) at which the refactoring should be "
+    "initiated (<file>:<line>:<column>-<last-column>)");
+
+const cl::desc SelectedRangeOptionDescription(
+    "The selected source range in which the refactoring should be "
+    "initiated (<file>:<line>:<column>-<line>:<column>)");
+
+static cl::opt<bool> Help("h", cl::desc("Alias for -help"), cl::Hidden);
+
+namespace rename {
+static cl::list<std::string> AtLocation("at", AtOptionDescription, cl::Required,
+                                        cl::cat(ClangRefactorTestOptions),
+                                        cl::sub(RenameInitiateSubcommand),
+                                        cl::OneOrMore);
+
+static cl::opt<std::string>
+    USR("usr", cl::desc("The USR of the declaration that should be renamed"),
+        cl::cat(ClangRefactorTestOptions), cl::sub(RenameInitiateUSRSubcommand),
+        cl::Required);
+
+static cl::opt<std::string>
+    NewName("new-name", cl::desc("The new name to change the symbol to."),
+            cl::Required, cl::cat(ClangRefactorTestOptions),
+            cl::sub(RenameInitiateSubcommand),
+            cl::sub(RenameInitiateUSRSubcommand));
+
+static cl::list<std::string>
+    IndexedNames("name", cl::desc("The names of the renamed symbols"),
+                 cl::Required, cl::OneOrMore, cl::cat(ClangRefactorTestOptions),
+                 cl::sub(RenameIndexedFileSubcommand));
+
+static cl::list<std::string> IndexedNewNames(
+    "new-name", cl::desc("The new name to change the symbol to."), cl::Required,
+    cl::OneOrMore, cl::cat(ClangRefactorTestOptions),
+    cl::sub(RenameIndexedFileSubcommand));
+
+static cl::opt<std::string>
+    IndexedSymbolKind("indexed-symbol-kind",
+                      cl::desc("The kind of the indexed symbol."), cl::Optional,
+                      cl::cat(ClangRefactorTestOptions),
+                      cl::sub(RenameIndexedFileSubcommand));
+
+static cl::opt<std::string>
+    IndexedFileName("indexed-file", cl::desc("The name of the indexed file"),
+                    cl::Required, cl::cat(ClangRefactorTestOptions),
+                    cl::sub(RenameIndexedFileSubcommand));
+
+static cl::list<std::string>
+    IndexedLocations("indexed-at",
+                     cl::desc("The location of an indexed occurrence "
+                              "([<kind>|<symbol-index>:]<line>:<column>)"),
+                     cl::ZeroOrMore, cl::cat(ClangRefactorTestOptions),
+                     cl::sub(RenameIndexedFileSubcommand));
+
+static cl::opt<bool> AvoidTextual(
+    "no-textual-matches", cl::desc("Avoid searching for textual matches"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(RenameIndexedFileSubcommand));
+
+static cl::opt<bool> DumpSymbols(
+    "dump-symbols", cl::desc("Dump the information about the renamed symbols"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(RenameInitiateSubcommand),
+    cl::sub(RenameInitiateUSRSubcommand));
+}
+
+namespace listActions {
+cl::opt<std::string> AtLocation("at", AtOptionDescription, cl::Required,
+                                cl::cat(ClangRefactorTestOptions),
+                                cl::sub(ListRefactoringActionsSubcommand));
+
+cl::opt<std::string> SelectedRange("selected", SelectedRangeOptionDescription,
+                                   cl::cat(ClangRefactorTestOptions),
+                                   cl::sub(ListRefactoringActionsSubcommand));
+
+cl::opt<bool> DumpRawActionType(
+    "dump-raw-action-type",
+    cl::desc("Prints the action type integer value for each listed action"),
+    cl::cat(ClangRefactorTestOptions),
+    cl::sub(ListRefactoringActionsSubcommand));
+}
+
+namespace initiateAndPerform {
+cl::list<std::string> InLocationRanges("in", cl::ZeroOrMore,
+                                       InRangeOptionDescription,
+                                       cl::cat(ClangRefactorTestOptions),
+                                       cl::sub(InitiateActionSubcommand));
+
+cl::list<std::string> AtLocations("at", cl::ZeroOrMore, AtOptionDescription,
+                                  cl::cat(ClangRefactorTestOptions),
+                                  cl::sub(InitiateActionSubcommand),
+                                  cl::sub(PerformActionSubcommand));
+
+cl::list<std::string> SelectedRanges("selected", cl::ZeroOrMore,
+                                     SelectedRangeOptionDescription,
+                                     cl::cat(ClangRefactorTestOptions),
+                                     cl::sub(InitiateActionSubcommand),
+                                     cl::sub(PerformActionSubcommand));
+
+cl::opt<std::string> ActionName("action", cl::Required,
+                                cl::desc("The name of the refactoring action"),
+                                cl::cat(ClangRefactorTestOptions),
+                                cl::sub(InitiateActionSubcommand),
+                                cl::sub(PerformActionSubcommand));
+
+cl::opt<bool> LocationAgnostic(
+    "location-agnostic",
+    cl::desc(
+        "Ignore the location of initiation when verifying result consistency"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(InitiateActionSubcommand));
+
+cl::opt<unsigned> CandidateIndex(
+    "candidate",
+    cl::desc(
+        "The index of the refactoring candidate which should be performed"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(PerformActionSubcommand));
+
+cl::opt<std::string> ContinuationFile(
+    "continuation-file",
+    cl::desc("The source file in which the continuation should run"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(PerformActionSubcommand));
+
+cl::opt<std::string> QueryResults(
+    "query-results", cl::desc("The indexer query results that should be passed "
+                              "into the continuation"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(PerformActionSubcommand));
+
+cl::opt<bool> EmitAssociatedInfo(
+    "emit-associated", cl::desc("Dump additional associated information"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(PerformActionSubcommand));
+}
+
+cl::opt<bool> Apply(
+    "apply",
+    cl::desc(
+        "Apply the changes and print the modified file to standard output"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(PerformActionSubcommand),
+    cl::sub(RenameInitiateSubcommand), cl::sub(RenameIndexedFileSubcommand));
+
+cl::opt<bool>
+    Diff("diff",
+         cl::desc("Display the replaced text in red when -apply is specified"),
+         cl::cat(ClangRefactorTestOptions), cl::sub(PerformActionSubcommand),
+         cl::sub(RenameInitiateSubcommand),
+         cl::sub(RenameIndexedFileSubcommand));
+
+cl::opt<int> Context("context", cl::desc("How many lines of context should be "
+                                         "displayed when -apply is specified"),
+                     cl::cat(ClangRefactorTestOptions),
+                     cl::sub(PerformActionSubcommand),
+                     cl::sub(RenameInitiateSubcommand),
+                     cl::sub(RenameIndexedFileSubcommand));
+
+static cl::opt<std::string> FileName(
+    cl::Positional, cl::desc("<filename>"), cl::Required,
+    cl::cat(ClangRefactorTestOptions), cl::sub(RenameInitiateSubcommand),
+    cl::sub(RenameInitiateUSRSubcommand), cl::sub(RenameIndexedFileSubcommand),
+    cl::sub(ListRefactoringActionsSubcommand),
+    cl::sub(InitiateActionSubcommand), cl::sub(PerformActionSubcommand));
+
+static cl::opt<bool> IgnoreFilenameForInitiationTU(
+    "ignore-filename-for-initiation-tu", cl::Optional,
+    cl::cat(ClangRefactorTestOptions), cl::sub(RenameIndexedFileSubcommand));
+
+static cl::list<std::string> CompilerArguments(
+    cl::ConsumeAfter, cl::desc("<arguments to be passed to the compiler>"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(RenameInitiateSubcommand),
+    cl::sub(RenameInitiateUSRSubcommand), cl::sub(RenameIndexedFileSubcommand),
+    cl::sub(ListRefactoringActionsSubcommand),
+    cl::sub(InitiateActionSubcommand), cl::sub(PerformActionSubcommand));
+
+static cl::opt<std::string> ImplementationTU(
+    "implementation-tu", cl::desc("The name of the implementation TU"),
+    cl::cat(ClangRefactorTestOptions), cl::sub(RenameInitiateSubcommand));
+}
+
+static const char *renameOccurrenceKindString(CXSymbolOccurrenceKind Kind,
+                                              bool IsLocal,
+                                              bool IsMacroExpansion) {
+  switch (Kind) {
+  case CXSymbolOccurrence_MatchingSymbol:
+    return IsMacroExpansion ? "macro" : IsLocal ? "rename local" : "rename";
+  case CXSymbolOccurrence_MatchingSelector:
+    assert(!IsLocal && "Objective-C selector renames must be global");
+    return IsMacroExpansion ? "selector in macro" : "selector";
+  case CXSymbolOccurrence_MatchingImplicitProperty:
+    assert(!IsLocal);
+    return IsMacroExpansion ? "implicit-property in macro"
+                            : "implicit-property";
+  case CXSymbolOccurrence_MatchingCommentString:
+    return "comment";
+  case CXSymbolOccurrence_MatchingDocCommentString:
+    return "documentation";
+  case CXSymbolOccurrence_MatchingFilename:
+    return "filename";
+  case CXSymbolOccurrence_MatchingStringLiteral:
+    return "string-literal";
+  case CXSymbolOccurrence_ExtractedDeclaration:
+    return "extracted-decl";
+  case CXSymbolOccurrence_ExtractedDeclaration_Reference:
+    return "extracted-decl-ref";
+  }
+}
+
+static int apply(ArrayRef<CXRefactoringReplacement> Replacements,
+                 StringRef Filename) {
+  // Assume that the replacements are sorted.
+  auto Result = MemoryBuffer::getFile(Filename);
+  if (!Result) {
+    errs() << "Failed to open " << Filename << "\n";
+    return 1;
+  }
+
+  raw_ostream &OS = outs();
+
+  int Context = opts::Context;
+
+  MemoryBuffer &Buffer = **Result;
+  std::vector<std::pair<StringRef, std::vector<CXRefactoringReplacement>>>
+      Lines;
+  for (auto I = line_iterator(Buffer, /*SkipBlanks=*/false),
+            E = line_iterator();
+       I != E; ++I)
+    Lines.push_back(
+        std::make_pair(*I, std::vector<CXRefactoringReplacement>()));
+  unsigned FlushedLine = 1;
+  auto FlushUntil = [&](unsigned Line) {
+    // Adjust the first flushed line if needed when printing in context mode.
+    if (FlushedLine == 1 && Context)
+      FlushedLine = std::max(int(Line) - Context, 1);
+    for (; FlushedLine < Line; ++FlushedLine) {
+      const auto &Line = Lines[FlushedLine - 1];
+      if (Line.second.empty()) {
+        OS << Line.first << "\n";
+        continue;
+      }
+
+      unsigned I = 0;
+      for (const CXRefactoringReplacement &Replacement : Line.second) {
+        OS << Line.first.substr(I, Replacement.Range.Begin.Column - 1 - I);
+        if (opts::Diff) {
+          OS.changeColor(raw_ostream::RED, false, true);
+          OS << Line.first.substr(Replacement.Range.Begin.Column - 1,
+                                  Replacement.Range.End.Column - 1 -
+                                      (Replacement.Range.Begin.Column - 1));
+        }
+        OS.changeColor(raw_ostream::GREEN);
+        OS << clang_getCString(Replacement.ReplacementString);
+        OS.resetColor();
+        I = Replacement.Range.End.Column - 1;
+      }
+      OS << Line.first.substr(I);
+      if (I < Line.first.size() || opts::Diff)
+        OS << "\n";
+    }
+  };
+
+  int EndLineMax = 0;
+  for (const CXRefactoringReplacement &Replacement : Replacements) {
+    EndLineMax = std::max(int(Replacement.Range.End.Line), EndLineMax);
+    unsigned StartingLine = Replacement.Range.Begin.Line;
+    FlushUntil(StartingLine);
+    if (Replacement.Range.End.Line == StartingLine) {
+      Lines[StartingLine - 1].second.push_back(Replacement);
+      continue;
+    }
+    // Multi-line replacements have to be split
+    for (unsigned I = StartingLine; I <= Replacement.Range.End.Line; ++I) {
+      CXRefactoringReplacement NewReplacement;
+      if (I == Replacement.Range.End.Line)
+        NewReplacement.ReplacementString = Replacement.ReplacementString;
+      else
+        // FIXME: This is a hack to workaround the fact that the API doesn't
+        // provide a way to create a null string. This should be fixed when
+        // upstreaming.
+        NewReplacement.ReplacementString = {0, 0};
+      NewReplacement.Range.Begin.Line = I;
+      NewReplacement.Range.Begin.Column =
+          I == StartingLine ? Replacement.Range.Begin.Column : 1;
+      NewReplacement.Range.End.Line = I;
+      NewReplacement.Range.End.Column = I == Replacement.Range.End.Line
+                                            ? Replacement.Range.End.Column
+                                            : Lines[I - 1].first.size() + 1;
+      NewReplacement.AssociatedData = nullptr;
+      Lines[I - 1].second.push_back(NewReplacement);
+    }
+  }
+  FlushUntil(Context ? std::min(int(Lines.size()), EndLineMax + Context) + 1
+                     : Lines.size() + 2);
+  // Print out a dividor when printing in the context mode.
+  if (Context) {
+    for (int I = 0; I < 80; ++I)
+      OS << '-';
+    OS << "\n";
+  }
+  return 0;
+}
+
+/// Converts the given renamed \p Occurrence into a string value that represents
+/// this occurrence.
+static std::string
+occurrenceToString(const CXSymbolOccurrence &Occurrence, bool IsLocal,
+                   const tooling::OldSymbolName &NewName,
+                   const tooling::OldSymbolName &ExpectedReplacementStrings,
+                   StringRef Filename) {
+  std::string Str;
+  llvm::raw_string_ostream OS(Str);
+  OS << renameOccurrenceKindString(Occurrence.Kind, IsLocal,
+                                   Occurrence.IsMacroExpansion)
+     << ' ';
+  if (!Filename.empty())
+    OS << '"' << Filename << "\" ";
+
+  bool FirstRange = true;
+  assert(NewName.size() >= Occurrence.NumNamePieces &&
+         "new name doesn't match the number of pieces");
+  for (unsigned J = 0; J != Occurrence.NumNamePieces; ++J) {
+    if (!FirstRange) // TODO
+      OS << ", ";
+
+    // Print the replacement string if it doesn't match the expected string.
+    if (NewName[J] != ExpectedReplacementStrings[J])
+      OS << '"' << NewName[J] << "\" ";
+
+    CXFileRange Range = Occurrence.NamePieces[J];
+    OS << Range.Begin.Line << ":" << Range.Begin.Column << " -> "
+       << Range.End.Line << ":" << Range.End.Column;
+    FirstRange = false;
+  }
+  return OS.str();
+}
+
+static CXCursorKind
+renameIndexedOccurrenceKindStringToKind(StringRef Str, CXCursorKind Default) {
+  return llvm::StringSwitch<CXCursorKind>(Str)
+      .Case("objc-im", CXCursor_ObjCInstanceMethodDecl)
+      .Case("objc-cm", CXCursor_ObjCClassMethodDecl)
+      .Case("objc-message", CXCursor_ObjCMessageExpr)
+      .Case("include", CXCursor_InclusionDirective)
+      .Case("objc-class", CXCursor_ObjCInterfaceDecl)
+      .Default(Default);
+}
+
+/// Parses the string passed as the -indexed-at argument.
+std::pair<CXRenamedIndexedSymbolLocation, unsigned>
+parseIndexedOccurrence(StringRef IndexedOccurrence,
+                       CXCursorKind DefaultCursorKind) {
+  StringRef LineColumnLoc = IndexedOccurrence;
+  CXCursorKind Kind = DefaultCursorKind;
+  unsigned SymbolIndex = 0;
+  if (LineColumnLoc.count(':') > 1) {
+    std::pair<StringRef, StringRef> Split = LineColumnLoc.split(':');
+    // The first value is either the kind or the symbol index.
+    if (Split.first.getAsInteger(10, SymbolIndex)) {
+      if (Split.second.count(':') > 1) {
+        std::pair<StringRef, StringRef> SecondSplit = Split.second.split(':');
+        if (SecondSplit.first.getAsInteger(10, SymbolIndex))
+          assert(false && "expected symbol index");
+        Split.second = SecondSplit.second;
+      }
+      Kind = renameIndexedOccurrenceKindStringToKind(Split.first, Kind);
+    }
+    LineColumnLoc = Split.second;
+  }
+  auto Loc = std::string("-:") + LineColumnLoc.str();
+  auto Location = ParsedSourceLocation::FromString(Loc);
+  return std::make_pair(
+      CXRenamedIndexedSymbolLocation{{Location.Line, Location.Column}, Kind},
+      SymbolIndex);
+}
+
+/// Compare the produced occurrences to the expected occurrences that were
+/// gathered at the first location. Return true if the occurrences are
+/// different.
+static bool compareOccurrences(ArrayRef<std::string> ExpectedReplacements,
+                               CXSymbolOccurrencesResult Occurrences,
+                               bool IsLocal,
+                               const tooling::OldSymbolName &NewSymbolName,
+                               bool PrintFilenames) {
+  unsigned NumFiles = clang_SymbolOccurrences_getNumFiles(Occurrences);
+  size_t ExpectedReplacementIndex = 0;
+  for (unsigned FileIndex = 0; FileIndex < NumFiles; ++FileIndex) {
+    CXSymbolOccurrencesInFile FileResult;
+    clang_SymbolOccurrences_getOccurrencesForFile(Occurrences, FileIndex,
+                                                  &FileResult);
+    StringRef Filename =
+        PrintFilenames ? clang_getCString(FileResult.Filename) : "";
+
+    for (unsigned I = 0; I != FileResult.NumOccurrences; ++I) {
+      std::string Replacement =
+          occurrenceToString(FileResult.Occurrences[I], IsLocal, NewSymbolName,
+                             NewSymbolName, Filename);
+      if (ExpectedReplacementIndex >= ExpectedReplacements.size() ||
+          Replacement != ExpectedReplacements[ExpectedReplacementIndex])
+        return true;
+      ++ExpectedReplacementIndex;
+    }
+  }
+  // Verify that all of the expected replacements were checked.
+  return ExpectedReplacementIndex != ExpectedReplacements.size();
+}
+
+struct ImplementationTUWrapper {
+  CXTranslationUnit TU = nullptr;
+
+  ImplementationTUWrapper() {}
+  ~ImplementationTUWrapper() { clang_disposeTranslationUnit(TU); }
+
+  ImplementationTUWrapper(const ImplementationTUWrapper &) = delete;
+  ImplementationTUWrapper &operator=(const ImplementationTUWrapper &) = delete;
+
+  bool load(CXRefactoringAction Action, CXIndex CIdx,
+            ArrayRef<const char *> Args);
+};
+
+bool ImplementationTUWrapper::load(CXRefactoringAction Action, CXIndex CIdx,
+                                   ArrayRef<const char *> Args) {
+  if (!clang_RefactoringAction_requiresImplementationTU(Action))
+    return false;
+  CXString USR =
+      clang_RefactoringAction_getUSRThatRequiresImplementationTU(Action);
+  outs() << "Implementation TU USR: '" << clang_getCString(USR) << "'\n";
+  clang_disposeString(USR);
+  if (!TU) {
+    CXErrorCode Err = clang_parseTranslationUnit2(
+        CIdx, opts::ImplementationTU.c_str(), Args.data(), Args.size(), 0, 0,
+        CXTranslationUnit_KeepGoing, &TU);
+    if (Err != CXError_Success) {
+      errs() << "error: failed to load implementation TU '"
+             << opts::ImplementationTU << "'\n";
+      return true;
+    }
+  }
+  CXErrorCode Err = clang_RefactoringAction_addImplementationTU(Action, TU);
+  if (Err != CXError_Success) {
+    errs() << "error: failed to add implementation TU '"
+           << opts::ImplementationTU << "'\n";
+    return true;
+  }
+  return false;
+}
+
+static bool reportNewNameError(CXErrorCode Err) {
+  std::string NewName = opts::RenameIndexedFileSubcommand
+                            ? opts::rename::IndexedNewNames[0]
+                            : opts::rename::NewName;
+  if (Err == CXError_RefactoringNameSizeMismatch)
+    errs() << "error: the number of strings in the new name '" << NewName
+           << "' doesn't match the the number of strings in the old name\n";
+  else if (Err == CXError_RefactoringNameInvalid)
+    errs() << "error: invalid new name '" << NewName << "'\n";
+  else
+    return true;
+  return false;
+}
+
+int rename(CXTranslationUnit TU, CXIndex CIdx, ArrayRef<const char *> Args) {
+  assert(!opts::RenameIndexedFileSubcommand);
+  // Contains the renamed source replacements for the first location. It is
+  // compared to replacements from follow-up renames to ensure that all renames
+  // give the same result.
+  std::vector<std::string> ExpectedReplacements;
+  // Should we print out the filenames. False by default, but true when multiple
+  // files are modified.
+  bool PrintFilenames = false;
+  ImplementationTUWrapper ImplementationTU;
+
+  auto RenameAt = [&](const ParsedSourceLocation &Location,
+                      const std::string &USR) -> int {
+    CXRefactoringAction RenamingAction;
+    CXErrorCode Err;
+    CXDiagnosticSet Diags = nullptr;
+    if (USR.empty()) {
+      CXSourceLocation Loc =
+          clang_getLocation(TU, clang_getFile(TU, Location.FileName.c_str()),
+                            Location.Line, Location.Column);
+      Err = clang_Refactoring_initiateAction(
+          TU, Loc, clang_getNullRange(), CXRefactor_Rename,
+          /*Options=*/nullptr, &RenamingAction, &Diags);
+    } else {
+      Err = clang_Refactoring_initiateActionOnDecl(
+          TU, USR.c_str(), CXRefactor_Rename, /*Options=*/nullptr,
+          &RenamingAction, nullptr);
+    }
+    if (Err != CXError_Success) {
+      errs() << "error: could not rename symbol "
+             << (USR.empty() ? "at the given location\n"
+                             : "with the given USR\n");
+      if (USR.empty()) {
+        unsigned NumDiags = clang_getNumDiagnosticsInSet(Diags);
+        for (unsigned DiagID = 0; DiagID < NumDiags; ++DiagID) {
+          CXDiagnostic Diag = clang_getDiagnosticInSet(Diags, DiagID);
+          CXString Spelling = clang_getDiagnosticSpelling(Diag);
+          errs() << clang_getCString(Spelling) << "\n";
+          clang_disposeString(Spelling);
+        }
+      }
+      clang_disposeDiagnosticSet(Diags);
+      return 1;
+    }
+    clang_disposeDiagnosticSet(Diags);
+
+    if (ImplementationTU.load(RenamingAction, CIdx, Args))
+      return 1;
+
+    Err = clang_Refactoring_initiateRenamingOperation(RenamingAction);
+    if (Err != CXError_Success) {
+      errs() << "error: failed to initiate the renaming operation!\n";
+      return 1;
+    }
+
+    bool IsLocal = clang_RefactoringAction_getInitiatedActionType(
+                       RenamingAction) == CXRefactor_Rename_Local;
+
+    unsigned NumSymbols = clang_RenamingOperation_getNumSymbols(RenamingAction);
+    if (opts::rename::DumpSymbols) {
+      outs() << "Renaming " << NumSymbols << " symbols\n";
+      for (unsigned I = 0; I < NumSymbols; ++I) {
+        CXString USR =
+            clang_RenamingOperation_getUSRForSymbol(RenamingAction, I);
+        outs() << "'" << clang_getCString(USR) << "'\n";
+        clang_disposeString(USR);
+      }
+    }
+
+    CXSymbolOccurrencesResult Occurrences;
+    Occurrences = clang_Refactoring_findSymbolOccurrencesInInitiationTU(
+        RenamingAction, Args.data(), Args.size(), 0, 0);
+
+    clang_RefactoringAction_dispose(RenamingAction);
+
+    // FIXME: This is a hack
+    LangOptions LangOpts;
+    LangOpts.ObjC1 = true;
+    tooling::OldSymbolName NewSymbolName(opts::rename::NewName, LangOpts);
+
+    if (ExpectedReplacements.empty()) {
+      if (opts::Apply) {
+        // FIXME: support --apply.
+      }
+
+      unsigned NumFiles = clang_SymbolOccurrences_getNumFiles(Occurrences);
+      if (NumFiles > 1)
+        PrintFilenames = true;
+      // Convert the occurrences to strings
+      for (unsigned FileIndex = 0; FileIndex < NumFiles; ++FileIndex) {
+        CXSymbolOccurrencesInFile FileResult;
+        clang_SymbolOccurrences_getOccurrencesForFile(Occurrences, FileIndex,
+                                                      &FileResult);
+        StringRef Filename =
+            PrintFilenames ? clang_getCString(FileResult.Filename) : "";
+        for (unsigned I = 0; I != FileResult.NumOccurrences; ++I)
+          ExpectedReplacements.push_back(
+              occurrenceToString(FileResult.Occurrences[I], IsLocal,
+                                 NewSymbolName, NewSymbolName, Filename));
+      }
+      clang_SymbolOccurrences_dispose(Occurrences);
+      return 0;
+    }
+    // Compare the produced occurrences to the expected occurrences that were
+    // gathered at the first location.
+    bool AreOccurrencesDifferent =
+        compareOccurrences(ExpectedReplacements, Occurrences, IsLocal,
+                           NewSymbolName, PrintFilenames);
+    clang_SymbolOccurrences_dispose(Occurrences);
+    if (!AreOccurrencesDifferent)
+      return 0;
+    errs() << "error: occurrences for a rename at " << Location.FileName << ":"
+           << Location.Line << ":" << Location.Column
+           << " differ to occurrences from the rename at the first location!\n";
+    return 1;
+  };
+
+  std::vector<ParsedSourceLocation> ParsedLocations;
+  for (const auto &I : enumerate(opts::rename::AtLocation)) {
+    auto Location = ParsedSourceLocation::FromString(I.value());
+    if (Location.FileName.empty()) {
+      errs()
+          << "error: The -at option must use the <file:line:column> format\n";
+      return 1;
+    }
+    ParsedLocations.push_back(Location);
+  }
+
+  if (opts::RenameInitiateUSRSubcommand) {
+    if (RenameAt(ParsedSourceLocation(), opts::rename::USR))
+      return 1;
+  } else {
+    assert(!ParsedLocations.empty() && "No -at locations");
+
+    for (const auto &Location : ParsedLocations) {
+      if (RenameAt(Location, ""))
+        return 1;
+    }
+  }
+
+  // Print the produced renamed replacements
+  if (opts::Apply)
+    return 0;
+  for (const auto &Replacement : ExpectedReplacements)
+    outs() << Replacement << "\n";
+  if (ExpectedReplacements.empty())
+    outs() << "no replacements found\n";
+  return 0;
+}
+
+int renameIndexedFile(CXIndex CIdx, ArrayRef<const char *> Args) {
+  assert(opts::RenameIndexedFileSubcommand);
+
+  // Compute the number of symbols.
+  unsigned NumSymbols = opts::rename::IndexedNames.size();
+
+  // Get the occurrences of a symbol.
+  CXCursorKind DefaultCursorKind = renameIndexedOccurrenceKindStringToKind(
+      opts::rename::IndexedSymbolKind, CXCursor_NotImplemented);
+  std::vector<std::vector<CXIndexedSymbolLocation>> IndexedOccurrences(
+      NumSymbols, std::vector<CXIndexedSymbolLocation>());
+  for (const auto &IndexedOccurrence : opts::rename::IndexedLocations) {
+    auto Occurrence =
+        parseIndexedOccurrence(IndexedOccurrence, DefaultCursorKind);
+    unsigned SymbolIndex = Occurrence.second;
+    assert(SymbolIndex < IndexedOccurrences.size() && "Invalid symbol index");
+    IndexedOccurrences[SymbolIndex].push_back(CXIndexedSymbolLocation{
+        Occurrence.first.Location, Occurrence.first.CursorKind});
+  }
+
+  // Create the indexed symbols.
+  std::vector<CXIndexedSymbol> IndexedSymbols;
+  for (const auto &I : llvm::enumerate(IndexedOccurrences)) {
+    const auto &Occurrences = I.value();
+    const char *Name =
+        opts::rename::IndexedNames[opts::rename::IndexedNames.size() < 2
+                                       ? 0
+                                       : I.index()]
+            .c_str();
+    IndexedSymbols.push_back({Occurrences.data(), (unsigned)Occurrences.size(),
+                              DefaultCursorKind, Name});
+  }
+
+  CXRefactoringOptionSet Options = nullptr;
+  if (opts::rename::AvoidTextual) {
+    Options = clang_RefactoringOptionSet_create();
+    clang_RefactoringOptionSet_add(Options,
+                                   CXRefactorOption_AvoidTextualMatches);
+  }
+
+  CXSymbolOccurrencesResult Occurrences;
+  CXErrorCode Err = clang_Refactoring_findSymbolOccurrencesInIndexedFile(
+      IndexedSymbols.data(), IndexedSymbols.size(), CIdx,
+      opts::rename::IndexedFileName.c_str(), Args.data(), Args.size(), 0, 0,
+      Options, &Occurrences);
+  if (Err != CXError_Success) {
+    if (reportNewNameError(Err))
+      errs() << "error: failed to perform indexed file rename\n";
+    return 1;
+  }
+
+  if (Options)
+    clang_RefactoringOptionSet_dispose(Options);
+
+  // Should we print out the filenames. False by default, but true when multiple
+  // files are modified.
+  bool PrintFilenames = false;
+  unsigned NumFiles = clang_SymbolOccurrences_getNumFiles(Occurrences);
+  if (NumFiles > 1)
+    PrintFilenames = true;
+
+  LangOptions LangOpts;
+  LangOpts.ObjC1 = true;
+  tooling::OldSymbolName ExpectedReplacementStrings(
+      opts::rename::IndexedNewNames[0], LangOpts);
+
+  // Print the occurrences.
+  bool HasReplacements = false;
+  for (unsigned FileIndex = 0; FileIndex < NumFiles; ++FileIndex) {
+    CXSymbolOccurrencesInFile FileResult;
+    clang_SymbolOccurrences_getOccurrencesForFile(Occurrences, FileIndex,
+                                                  &FileResult);
+    StringRef Filename =
+        PrintFilenames ? clang_getCString(FileResult.Filename) : "";
+    HasReplacements = FileResult.NumOccurrences;
+    for (unsigned I = 0; I != FileResult.NumOccurrences; ++I) {
+      unsigned SymbolIndex = FileResult.Occurrences[I].SymbolIndex;
+      const char *NewName =
+          opts::rename::IndexedNewNames[opts::rename::IndexedNewNames.size() < 2
+                                            ? 0
+                                            : SymbolIndex]
+              .c_str();
+      LangOptions LangOpts;
+      LangOpts.ObjC1 = true;
+      tooling::OldSymbolName NewSymbolName(NewName, LangOpts);
+
+      outs() << occurrenceToString(FileResult.Occurrences[I], /*IsLocal*/ false,
+                                   NewSymbolName, ExpectedReplacementStrings,
+                                   Filename)
+             << "\n";
+    }
+  }
+  if (!HasReplacements)
+    outs() << "no replacements found\n";
+  clang_SymbolOccurrences_dispose(Occurrences);
+  return 0;
+}
+
+/// Returns the last column number of a line in a file.
+static unsigned lastColumnForFile(StringRef Filename, unsigned LineNo) {
+  auto Buf = llvm::MemoryBuffer::getFile(Filename);
+  if (!Buf)
+    return 0;
+  unsigned LineCount = 1;
+  for (llvm::line_iterator Lines(**Buf, /*SkipBlanks=*/false);
+       !Lines.is_at_end(); ++Lines, ++LineCount) {
+    if (LineNo == LineCount)
+      return Lines->size() + 1;
+  }
+  return 0;
+}
+
+struct ParsedSourceLineRange : ParsedSourceLocation {
+  unsigned MaxColumn;
+
+  ParsedSourceLineRange() {}
+  ParsedSourceLineRange(const ParsedSourceLocation &Loc)
+      : ParsedSourceLocation(Loc), MaxColumn(Loc.Column) {}
+
+  static Optional<ParsedSourceLineRange> FromString(StringRef Str) {
+    std::pair<StringRef, StringRef> RangeSplit = Str.rsplit('-');
+    auto PSL = ParsedSourceLocation::FromString(RangeSplit.first);
+    ParsedSourceLineRange Result;
+    Result.FileName = std::move(PSL.FileName);
+    Result.Line = PSL.Line;
+    Result.Column = PSL.Column;
+    if (Result.FileName.empty())
+      return None;
+    if (RangeSplit.second == "end")
+      Result.MaxColumn = lastColumnForFile(Result.FileName, Result.Line);
+    else if (RangeSplit.second.getAsInteger(10, Result.MaxColumn))
+      return None;
+    if (Result.MaxColumn < Result.Column)
+      return None;
+    return Result;
+  }
+};
+
+struct OldParsedSourceRange {
+  ParsedSourceLocation Begin, End;
+
+  OldParsedSourceRange(const ParsedSourceLocation &Begin,
+                    const ParsedSourceLocation &End)
+      : Begin(Begin), End(End) {}
+
+  static Optional<OldParsedSourceRange> FromString(StringRef Str) {
+    std::pair<StringRef, StringRef> RangeSplit = Str.rsplit('-');
+    auto Begin = ParsedSourceLocation::FromString(RangeSplit.first);
+    if (Begin.FileName.empty())
+      return None;
+    std::string EndString = Begin.FileName + ":" + RangeSplit.second.str();
+    auto End = ParsedSourceLocation::FromString(EndString);
+    if (End.FileName.empty())
+      return None;
+    return OldParsedSourceRange(Begin, End);
+  }
+};
+
+int listRefactoringActions(CXTranslationUnit TU) {
+  auto Location =
+      ParsedSourceLocation::FromString(opts::listActions::AtLocation);
+  if (Location.FileName.empty()) {
+    errs() << "error: The -at option must use the <file:line:column> format\n";
+    return 1;
+  }
+  CXSourceRange Range;
+  if (!opts::listActions::SelectedRange.empty()) {
+    auto SelectionRange =
+        OldParsedSourceRange::FromString(opts::listActions::SelectedRange);
+    if (!SelectionRange) {
+      errs() << "error: The -selected option must use the "
+                "<file:line:column-line:column> format\n";
+      return 1;
+    }
+    auto Begin = SelectionRange.getValue().Begin;
+    auto End = SelectionRange.getValue().End;
+    CXFile File = clang_getFile(TU, Begin.FileName.c_str());
+    Range =
+        clang_getRange(clang_getLocation(TU, File, Begin.Line, Begin.Column),
+                       clang_getLocation(TU, File, End.Line, End.Column));
+  } else
+    Range = clang_getNullRange();
+  CXSourceLocation Loc =
+      clang_getLocation(TU, clang_getFile(TU, Location.FileName.c_str()),
+                        Location.Line, Location.Column);
+  CXRefactoringActionSet ActionSet;
+  CXRefactoringActionSetWithDiagnostics FailedActionSet;
+  CXErrorCode Err =
+      clang_Refactoring_findActionsWithInitiationFailureDiagnosicsAt(
+          TU, Loc, Range, /*Options=*/nullptr, &ActionSet, &FailedActionSet);
+  if (FailedActionSet.NumActions) {
+    errs() << "Failed to initiate " << FailedActionSet.NumActions
+           << " actions because:\n";
+    for (unsigned I = 0; I < FailedActionSet.NumActions; ++I) {
+      errs() << clang_getCString(clang_RefactoringActionType_getName(
+                    FailedActionSet.Actions[I].Action))
+             << ":";
+      CXDiagnosticSet Diags = FailedActionSet.Actions[I].Diagnostics;
+      unsigned NumDiags = clang_getNumDiagnosticsInSet(Diags);
+      for (unsigned DiagID = 0; DiagID < NumDiags; ++DiagID) {
+        CXDiagnostic Diag = clang_getDiagnosticInSet(Diags, DiagID);
+        CXString Spelling = clang_getDiagnosticSpelling(Diag);
+        errs() << ' ' << clang_getCString(Spelling);
+        clang_disposeString(Spelling);
+      }
+      errs() << "\n";
+    }
+  }
+  if (Err == CXError_RefactoringActionUnavailable)
+    errs() << "No refactoring actions are available at the given location\n";
+  if (Err != CXError_Success)
+    return 1;
+  // Print the list of refactoring actions.
+  outs() << "Found " << ActionSet.NumActions << " actions:\n";
+  for (unsigned I = 0; I < ActionSet.NumActions; ++I) {
+    outs() << clang_getCString(
+        clang_RefactoringActionType_getName(ActionSet.Actions[I]));
+    if (opts::listActions::DumpRawActionType)
+      outs() << "(" << ActionSet.Actions[I] << ")";
+    outs() << "\n";
+  }
+  clang_RefactoringActionSet_dispose(&ActionSet);
+  clang_RefactoringActionSetWithDiagnostics_dispose(&FailedActionSet);
+  return 0;
+}
+
+static std::string locationToString(CXSourceLocation Loc) {
+  unsigned Line, Column;
+  clang_getFileLocation(Loc, nullptr, &Line, &Column, nullptr);
+  std::string S;
+  llvm::raw_string_ostream OS(S);
+  OS << Line << ':' << Column;
+  return OS.str();
+}
+
+static std::string rangeToString(CXSourceRange Range) {
+  return locationToString(clang_getRangeStart(Range)) + " -> " +
+         locationToString(clang_getRangeEnd(Range));
+}
+
+static std::string
+refactoringCandidatesToString(CXRefactoringCandidateSet Candidates) {
+  std::string Results = "with multiple candidates:";
+  for (unsigned I = 0; I < Candidates.NumCandidates; ++I) {
+    Results += "\n";
+    Results += clang_getCString(Candidates.Candidates[I].Description);
+  }
+  return Results;
+}
+
+static void printEscaped(StringRef Str, raw_ostream &OS) {
+  size_t Pos = Str.find('\n');
+  OS << Str.substr(0, Pos);
+  if (Pos == StringRef::npos)
+    return;
+  OS << "\\n";
+  printEscaped(Str.substr(Pos + 1), OS);
+}
+
+bool printRefactoringReplacements(
+    CXRefactoringResult Result, CXRefactoringContinuation Continuation,
+    CXRefactoringContinuation CurrentContinuation) {
+  CXRefactoringReplacements Replacements =
+      clang_RefactoringResult_getSourceReplacements(Result);
+  if (Replacements.NumFileReplacementSets == 0) {
+    if (CurrentContinuation)
+      return false;
+    errs() << "error: no replacements produced!\n";
+    return true;
+  }
+  // Print out the produced results.
+  for (unsigned FileIndex = 0; FileIndex < Replacements.NumFileReplacementSets;
+       ++FileIndex) {
+    const CXRefactoringFileReplacementSet &FileSet =
+        Replacements.FileReplacementSets[FileIndex];
+    if (opts::Apply) {
+      apply(llvm::makeArrayRef(FileSet.Replacements, FileSet.NumReplacements),
+            clang_getCString(FileSet.Filename));
+      continue;
+    }
+    for (unsigned I = 0; I < FileSet.NumReplacements; ++I) {
+      const CXRefactoringReplacement &Replacement = FileSet.Replacements[I];
+
+      if (Continuation) {
+        // Always print the filenames in with continuations.
+        outs() << '"' << clang_getCString(FileSet.Filename) << "\" ";
+      }
+      outs() << '"';
+      printEscaped(clang_getCString(Replacement.ReplacementString), outs());
+      outs() << "\" ";
+      CXFileRange Range = Replacement.Range;
+      outs() << Range.Begin.Line << ":" << Range.Begin.Column << " -> "
+             << Range.End.Line << ":" << Range.End.Column;
+      if (opts::initiateAndPerform::EmitAssociatedInfo) {
+        CXRefactoringReplacementAssociatedSymbolOccurrences Info =
+            clang_RefactoringReplacement_getAssociatedSymbolOccurrences(
+                Replacement);
+        for (const CXSymbolOccurrence &SymbolOccurrence :
+             llvm::makeArrayRef(Info.AssociatedSymbolOccurrences,
+                                Info.NumAssociatedSymbolOccurrences)) {
+          outs() << " [Symbol " << renameOccurrenceKindString(
+                                       SymbolOccurrence.Kind, /*IsLocal*/ false,
+                                       SymbolOccurrence.IsMacroExpansion)
+                 << ' ' << SymbolOccurrence.SymbolIndex;
+          for (const auto &Piece :
+               llvm::makeArrayRef(SymbolOccurrence.NamePieces,
+                                  SymbolOccurrence.NumNamePieces)) {
+            outs() << ' ' << Piece.Begin.Line << ":" << Piece.Begin.Column
+                   << " -> " << Piece.End.Line << ":" << Piece.End.Column;
+          }
+          outs() << ']';
+        }
+      }
+      outs() << "\n";
+    }
+  }
+  return false;
+}
+
+/// Returns the last column number of a line in a file.
+static std::string queryResultsForFile(StringRef Filename, StringRef Name,
+                                       StringRef FileSubstitution) {
+  auto Buf = llvm::MemoryBuffer::getFile(Filename);
+  if (!Buf)
+    return "<invalid>";
+  StringRef Buffer = (*Buf)->getBuffer();
+  std::string Label = Name.str() + ":";
+  size_t I = Buffer.find(Label);
+  if (I == StringRef::npos)
+    return "<invalid>";
+  I = I + Label.size();
+  auto Result = Buffer.substr(I, Buffer.find('\n', I) - I);
+  std::string Sub1 = llvm::Regex("%s").sub(FileSubstitution, Result);
+  return llvm::Regex("%S").sub(llvm::sys::path::parent_path(FileSubstitution),
+                               Sub1);
+}
+
+static Optional<std::pair<unsigned, unsigned>>
+findSelectionLocInSource(StringRef Buffer, StringRef Label) {
+  size_t I = Buffer.find(Label);
+  if (I == StringRef::npos)
+    return None;
+  I = I + Label.size();
+  auto LocParts =
+      Buffer.substr(I, Buffer.find_first_of("\n/", I) - I).trim().split(":");
+  unsigned CurrentLine = Buffer.take_front(I).count('\n') + 1;
+  if (LocParts.second.empty())
+    return None;
+  StringRef LineString = LocParts.first;
+  unsigned Line, Column;
+  enum ExprKind { Literal, Add, Sub };
+  ExprKind Expr = LineString.startswith("+")
+                      ? Add
+                      : LineString.startswith("-") ? Sub : Literal;
+  if (LineString.drop_front(Expr != Literal ? 1 : 0).getAsInteger(10, Line))
+    return None;
+  if (Expr == Add)
+    Line += CurrentLine;
+  else if (Expr == Sub)
+    Line = CurrentLine - Line;
+  if (LocParts.second.getAsInteger(10, Column))
+    return None;
+  return std::make_pair(Line, Column);
+}
+
+static Optional<ParsedSourceLocation> selectionLocForFile(StringRef Filename,
+                                                          StringRef Name) {
+  auto Buf = llvm::MemoryBuffer::getFile(Filename);
+  if (!Buf)
+    return None;
+
+  StringRef Buffer = (*Buf)->getBuffer();
+  std::string Label = Name.str() + ":";
+  auto Start = findSelectionLocInSource(Buffer, Label);
+  if (!Start)
+    return None;
+  // Create the resulting source location.
+  // FIXME: Parse can be avoided.
+  std::string Str;
+  llvm::raw_string_ostream OS(Str);
+  OS << Filename << ":" << Start->first << ":" << Start->second;
+  return ParsedSourceLocation::FromString(OS.str());
+}
+
+static Optional<OldParsedSourceRange> selectionRangeForFile(StringRef Filename,
+                                                         StringRef Name) {
+  auto Buf = llvm::MemoryBuffer::getFile(Filename);
+  if (!Buf)
+    return None;
+
+  StringRef Buffer = (*Buf)->getBuffer();
+  std::string BeginLabel = Name.str() + "-begin:";
+  std::string EndLabel = Name.str() + "-end:";
+  auto Start = findSelectionLocInSource(Buffer, BeginLabel);
+  auto End = findSelectionLocInSource(Buffer, EndLabel);
+  if (!Start || !End)
+    return None;
+  // Create the resulting source range.
+  // FIXME: Parse can be avoided.
+  std::string Str;
+  llvm::raw_string_ostream OS(Str);
+  OS << Filename << ":" << Start->first << ":" << Start->second << "-"
+     << End->first << ":" << End->second;
+  return OldParsedSourceRange::FromString(OS.str());
+}
+
+bool performOperation(CXRefactoringAction Action, ArrayRef<const char *> Args,
+                      CXIndex CIdx) {
+  if (opts::initiateAndPerform::CandidateIndex.getNumOccurrences()) {
+    if (clang_RefactoringAction_selectRefactoringCandidate(
+            Action, opts::initiateAndPerform::CandidateIndex)) {
+      errs() << "error: failed to select the refactoring candidate!\n";
+      return true;
+    }
+  }
+  CXRefactoringOptionSet Options = nullptr;
+  CXString FailureReason;
+  CXRefactoringResult Result = clang_Refactoring_performOperation(
+      Action, Args.data(), Args.size(), nullptr, 0, Options, &FailureReason);
+  if (!Result) {
+    errs() << "error: failed to perform the refactoring operation";
+    if (const char *Reason = clang_getCString(FailureReason))
+      errs() << " (" << Reason << ')';
+    errs() << "!\n";
+    clang_disposeString(FailureReason);
+    return true;
+  }
+  CXRefactoringContinuation Continuation =
+      clang_RefactoringResult_getContinuation(Result);
+  bool AreReplacementsInvalid =
+      printRefactoringReplacements(Result, Continuation, Continuation);
+  clang_RefactoringResult_dispose(Result);
+  if (AreReplacementsInvalid) {
+    clang_RefactoringContinuation_dispose(Continuation);
+    return true;
+  }
+  if (!Continuation)
+    return false;
+  assert(clang_RefactoringContinuation_getNumIndexerQueries(Continuation) !=
+             0 &&
+         "Missing indexer queries?");
+  std::string QueryResults = queryResultsForFile(
+      opts::FileName, opts::initiateAndPerform::QueryResults,
+      /*FileSubstitution=*/opts::initiateAndPerform::ContinuationFile);
+  clang_RefactoringContinuation_loadSerializedIndexerQueryResults(
+      Continuation, /*Source=*/QueryResults.c_str());
+  CXDiagnosticSet Diags =
+      clang_RefactoringContinuation_verifyBeforeFinalizing(Continuation);
+  if (Diags) {
+    llvm::errs() << "error: continuation failed: ";
+    for (unsigned I = 0, E = clang_getNumDiagnosticsInSet(Diags); I != E; ++I) {
+      CXDiagnostic Diag = clang_getDiagnosticInSet(Diags, I);
+      CXString Spelling = clang_getDiagnosticSpelling(Diag);
+      errs() << clang_getCString(Spelling) << "\n";
+      clang_disposeString(Spelling);
+      clang_disposeDiagnostic(Diag);
+    }
+    clang_RefactoringContinuation_dispose(Continuation);
+    clang_disposeDiagnosticSet(Diags);
+    return true;
+  }
+  clang_RefactoringContinuation_finalizeEvaluationInInitationTU(Continuation);
+  // Load the continuation TU.
+  CXTranslationUnit ContinuationTU;
+  CXErrorCode Err = clang_parseTranslationUnit2(
+      CIdx, opts::initiateAndPerform::ContinuationFile.c_str(), Args.data(),
+      Args.size(), 0, 0, CXTranslationUnit_KeepGoing, &ContinuationTU);
+  if (Err != CXError_Success) {
+    errs() << "error: failed to load '"
+           << opts::initiateAndPerform::ContinuationFile.c_str() << "'\n";
+    clang_RefactoringContinuation_dispose(Continuation);
+    return true;
+  }
+  Result = clang_RefactoringContinuation_continueOperationInTU(
+      Continuation, ContinuationTU, &FailureReason);
+  if (!Result) {
+    errs() << "error: failed to perform the refactoring continuation";
+    if (const char *Reason = clang_getCString(FailureReason))
+      errs() << " (" << Reason << ')';
+    errs() << "!\n";
+    clang_disposeString(FailureReason);
+    clang_disposeTranslationUnit(ContinuationTU);
+    clang_RefactoringContinuation_dispose(Continuation);
+    return true;
+  }
+  // FIXME: Continuations can be chained in the future.
+  AreReplacementsInvalid =
+      printRefactoringReplacements(Result, Continuation, nullptr);
+  clang_RefactoringResult_dispose(Result);
+  clang_disposeTranslationUnit(ContinuationTU);
+  clang_RefactoringContinuation_dispose(Continuation);
+  return AreReplacementsInvalid;
+}
+
+int initiateAndPerformAction(CXTranslationUnit TU, ArrayRef<const char *> Args,
+                             CXIndex CIdx) {
+  std::vector<ParsedSourceLineRange> Ranges;
+  std::vector<OldParsedSourceRange> SelectionRanges;
+  for (const auto &Range : opts::initiateAndPerform::InLocationRanges) {
+    auto ParsedLineRange = ParsedSourceLineRange::FromString(Range);
+    if (!ParsedLineRange) {
+      errs()
+          << "error: The -in option must use the <file:line:column[-column]> "
+             "format\n";
+      return 1;
+    }
+    Ranges.push_back(ParsedLineRange.getValue());
+  }
+  for (const auto &Range : opts::initiateAndPerform::AtLocations) {
+    if (!StringRef(Range).contains(':')) {
+      auto ParsedLocation = selectionLocForFile(opts::FileName, Range);
+      if (!ParsedLocation) {
+        errs() << "error: The -at option must use the <file:line:column> "
+                  "format\n";
+        return 1;
+      }
+      Ranges.push_back(*ParsedLocation);
+      continue;
+    }
+    // TODO: Remove old location in arguments in favour of new testing
+    // locations.
+    auto ParsedLocation = ParsedSourceLocation::FromString(Range);
+    if (ParsedLocation.FileName.empty()) {
+      errs() << "error: The -at option must use the <file:line:column> "
+                "format\n";
+      return 1;
+    }
+    Ranges.push_back(ParsedLocation);
+  }
+  for (const auto &Range : opts::initiateAndPerform::SelectedRanges) {
+    auto ParsedRange = StringRef(Range).contains(':')
+                           ? OldParsedSourceRange::FromString(Range)
+                           : selectionRangeForFile(opts::FileName, Range);
+    if (!ParsedRange) {
+      errs() << "error: The -selected option must use the "
+                "<file:line:column-line:column> format or refer to the name of "
+                "the selection specifier in the source\n";
+      return 1;
+    }
+    SelectionRanges.push_back(ParsedRange.getValue());
+  }
+  if (Ranges.empty() && SelectionRanges.empty()) {
+    errs() << "error: -in or -at options must be specified at least once!";
+    return 1;
+  }
+  if (!Ranges.empty() && !SelectionRanges.empty()) {
+    errs() << "error: -in or -at options can't be used with -selected!";
+    return 1;
+  }
+
+  auto ActionTypeOrNone = StringSwitch<Optional<CXRefactoringActionType>>(
+                              opts::initiateAndPerform::ActionName)
+#define REFACTORING_OPERATION_ACTION(Name, Spelling, Command)                  \
+  .Case(Command, CXRefactor_##Name)
+#define REFACTORING_OPERATION_SUB_ACTION(Name, Parent, Spelling, Command)      \
+  .Case(Command, CXRefactor_##Parent##_##Name)
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+                              .Default(None);
+  if (!ActionTypeOrNone) {
+    errs() << "error: invalid action '" << opts::initiateAndPerform::ActionName
+           << "'\n";
+    return 1;
+  }
+  CXRefactoringActionType ActionType = *ActionTypeOrNone;
+
+  Optional<bool> Initiated;
+  Optional<std::string> InitiationFailureReason;
+  Optional<std::string> LocationCandidateInformation;
+  auto InitiateAndPerform =
+      [&](const ParsedSourceLocation &Location, unsigned Column,
+          Optional<OldParsedSourceRange> SelectionRange = None) -> bool {
+    CXSourceLocation Loc =
+        clang_getLocation(TU, clang_getFile(TU, Location.FileName.c_str()),
+                          Location.Line, Column);
+    CXSourceRange Range;
+    if (SelectionRange) {
+      auto Begin = SelectionRange.getValue().Begin;
+      auto End = SelectionRange.getValue().End;
+      CXFile File = clang_getFile(TU, Begin.FileName.c_str());
+      Range =
+          clang_getRange(clang_getLocation(TU, File, Begin.Line, Begin.Column),
+                         clang_getLocation(TU, File, End.Line, End.Column));
+    } else
+      Range = clang_getNullRange();
+    CXRefactoringAction Action;
+    CXString FailureReason;
+    CXErrorCode Err = clang_Refactoring_initiateActionAt(
+        TU, Loc, Range, ActionType, /*Options=*/nullptr, &Action,
+        &FailureReason);
+    std::string ReasonString;
+    if (const char *Reason = clang_getCString(FailureReason))
+      ReasonString = Reason;
+    clang_disposeString(FailureReason);
+    if (InitiationFailureReason.hasValue() &&
+        InitiationFailureReason.getValue() != ReasonString) {
+      errs() << "error: inconsistent results in a single action range!\n";
+      return true;
+    }
+    InitiationFailureReason = std::move(ReasonString);
+    if (Err == CXError_RefactoringActionUnavailable) {
+      if (Initiated.hasValue() && Initiated.getValue()) {
+        errs() << "error: inconsistent results in a single action range!\n";
+        return true;
+      }
+      Initiated = false;
+    } else if (Err != CXError_Success)
+      return true;
+    else if (Initiated.hasValue() && !Initiated.getValue()) {
+      errs() << "error: inconsistent results in a single action range!\n";
+      return true;
+    } else
+      Initiated = true;
+
+    CXRefactoringCandidateSet Candidates;
+    if (clang_RefactoringAction_getRefactoringCandidates(Action, &Candidates) ==
+            CXError_Success &&
+        Candidates.NumCandidates > 1) {
+      std::string CandidateString = refactoringCandidatesToString(Candidates);
+      if (LocationCandidateInformation) {
+        if (*LocationCandidateInformation != CandidateString) {
+          errs() << "error: inconsistent results in a single action range!\n";
+          return true;
+        }
+      } else
+        LocationCandidateInformation = CandidateString;
+    } else if (opts::InitiateActionSubcommand &&
+               !opts::initiateAndPerform::LocationAgnostic) {
+      CXSourceRange Range =
+          clang_RefactoringAction_getSourceRangeOfInterest(Action);
+      std::string LocationString =
+          std::string("at ") +
+          (!clang_Range_isNull(Range)
+               ? SelectionRange ? rangeToString(Range)
+                                : locationToString(clang_getRangeStart(Range))
+               : "<unknown>");
+      if (!LocationCandidateInformation.hasValue())
+        LocationCandidateInformation = LocationString;
+      else if (LocationCandidateInformation.getValue() != LocationString) {
+        errs() << "error: inconsistent results in a single action range!\n";
+        return true;
+      }
+    }
+
+    if (!*Initiated)
+      return false;
+
+    bool Failed = opts::PerformActionSubcommand
+                      ? performOperation(Action, Args, CIdx)
+                      : false;
+    clang_RefactoringAction_dispose(Action);
+    return Failed;
+  };
+
+  // Iterate over all of the possible locations and perform the initiation
+  // at each range.
+  for (const ParsedSourceLineRange &LineRange : Ranges) {
+    for (unsigned Column = LineRange.Column; Column <= LineRange.MaxColumn;
+         ++Column) {
+      if (InitiateAndPerform(LineRange, Column))
+        return 1;
+    }
+  }
+
+  for (const OldParsedSourceRange &SelectionRange : SelectionRanges) {
+    if (InitiateAndPerform(SelectionRange.Begin, SelectionRange.Begin.Column,
+                           SelectionRange))
+      return 1;
+  }
+
+  if (!Initiated.getValue()) {
+    errs() << "Failed to initiate the refactoring action";
+    if (InitiationFailureReason.hasValue() &&
+        !InitiationFailureReason.getValue().empty())
+      errs() << " (" << InitiationFailureReason.getValue() << ')';
+    errs() << "!\n";
+    return 1;
+  }
+  if (opts::InitiateActionSubcommand) {
+    outs() << "Initiated the '" << opts::initiateAndPerform::ActionName
+           << "' action";
+    if (!opts::initiateAndPerform::LocationAgnostic)
+      outs() << ' ' << LocationCandidateInformation.getValue();
+    outs() << "\n";
+  }
+  return 0;
+}
+
+struct MainTU {
+  CXIndex CIdx;
+  CXTranslationUnit TU = nullptr;
+
+  MainTU() {
+    CIdx = clang_createIndex(0, 0);
+  }
+  ~MainTU() {
+    if (TU)
+      clang_disposeTranslationUnit(TU);
+    clang_disposeIndex(CIdx);
+  }
+};
+
+int main(int argc, const char **argv) {
+  cl::HideUnrelatedOptions(opts::ClangRefactorTestOptions);
+
+  cl::ParseCommandLineOptions(argc, argv, "Clang refactoring test tool\n");
+  cl::PrintOptionValues();
+
+  MainTU MainTranslationUnit;
+
+  std::vector<const char *> Args;
+  for (const auto &Arg : opts::CompilerArguments) {
+    Args.push_back(Arg.c_str());
+  }
+  CXErrorCode Err = clang_parseTranslationUnit2(
+      MainTranslationUnit.CIdx,
+      opts::IgnoreFilenameForInitiationTU ? nullptr : opts::FileName.c_str(),
+      Args.data(), Args.size(), 0, 0, CXTranslationUnit_KeepGoing,
+      &MainTranslationUnit.TU);
+  if (Err != CXError_Success) {
+    errs() << "error: failed to load '" << opts::FileName << "'\n";
+    return 1;
+  }
+
+  if (opts::RenameInitiateSubcommand || opts::RenameInitiateUSRSubcommand)
+    return rename(MainTranslationUnit.TU, MainTranslationUnit.CIdx, Args);
+  else if (opts::RenameIndexedFileSubcommand)
+    return renameIndexedFile(MainTranslationUnit.CIdx, Args);
+  else if (opts::ListRefactoringActionsSubcommand)
+    return listRefactoringActions(MainTranslationUnit.TU);
+  else if (opts::InitiateActionSubcommand || opts::PerformActionSubcommand)
+    return initiateAndPerformAction(MainTranslationUnit.TU, Args,
+                                    MainTranslationUnit.CIdx);
+
+  return 0;
+}
diff --git a/tools/clang-refactor/CMakeLists.txt b/tools/clang-refactor/CMakeLists.txt
index d2029066b9..527751c344 100644
--- a/tools/clang-refactor/CMakeLists.txt
+++ b/tools/clang-refactor/CMakeLists.txt
@@ -19,6 +19,7 @@ target_link_libraries(clang-refactor
   clangTooling
   clangToolingCore
   clangToolingRefactor
+  clangToolingRefactoring
   )
 
 install(TARGETS clang-refactor RUNTIME DESTINATION bin)
diff --git a/tools/clang-rename/CMakeLists.txt b/tools/clang-rename/CMakeLists.txt
index 9689e1c680..46f39f2d0c 100644
--- a/tools/clang-rename/CMakeLists.txt
+++ b/tools/clang-rename/CMakeLists.txt
@@ -13,6 +13,7 @@ target_link_libraries(clang-rename
   clangTooling
   clangToolingCore
   clangToolingRefactor
+  clangToolingRefactoring
   )
 
 install(PROGRAMS clang-rename.py
diff --git a/tools/driver/CMakeLists.txt b/tools/driver/CMakeLists.txt
index 22a498422a..8293145ca9 100644
--- a/tools/driver/CMakeLists.txt
+++ b/tools/driver/CMakeLists.txt
@@ -32,6 +32,7 @@ add_clang_tool(clang
   driver.cpp
   cc1_main.cpp
   cc1as_main.cpp
+  apinotes_main.cpp
 
   DEPENDS
   ${tablegen_deps}
@@ -40,6 +41,7 @@ add_clang_tool(clang
 target_link_libraries(clang
   PRIVATE
   clangBasic
+  clangAPINotes
   clangCodeGen
   clangDriver
   clangFrontend
diff --git a/tools/driver/apinotes_main.cpp b/tools/driver/apinotes_main.cpp
index e69de29bb2..930dc39c3b 100644
--- a/tools/driver/apinotes_main.cpp
+++ b/tools/driver/apinotes_main.cpp
@@ -0,0 +1,154 @@
+//===-- api_notes.cpp - API Notes Driver ----------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file 
+/// This file provides conversion between the YAML (source) and binary forms 
+/// of API notes.
+///
+//===----------------------------------------------------------------------===//
+#include "clang/APINotes/APINotesYAMLCompiler.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/PrettyStackTrace.h"
+#include "llvm/Support/Signals.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/ADT/Triple.h"
+
+using namespace llvm;
+namespace api_notes = clang::api_notes;
+
+int cc1apinotes_main(ArrayRef<const char *> Argv, const char *Argv0,
+                     void *MainAddr) {
+
+  // Mark all our options with this category, everything else (except for
+  // -version and -help) will be hidden.
+  static cl::OptionCategory APINotesCategory("API Notes options");
+
+  static cl::opt<api_notes::ActionType>
+  Action(cl::desc("Mode:"), cl::init(api_notes::ActionType::None),
+         cl::values(
+                    clEnumValN(api_notes::ActionType::YAMLToBinary,
+                               "yaml-to-binary", 
+                               "Convert YAML to binary format"),
+                    clEnumValN(api_notes::ActionType::BinaryToYAML,
+                               "binary-to-yaml",
+                               "Convert binary format to YAML"),
+                    clEnumValN(api_notes::ActionType::Dump,
+                               "dump", 
+                               "Parse and dump the output")),
+         cl::cat(APINotesCategory));
+
+  static cl::opt<std::string>
+  InputFilename(cl::Positional, cl::desc("<input file>"),
+                cl::Required, cl::cat(APINotesCategory));
+
+  static cl::opt<std::string>
+  Target("target", cl::desc("Generate binary format for the given target"),
+                   cl::cat(APINotesCategory));
+
+  static cl::opt<std::string>
+  OutputFilename("o", cl::desc("Output file name"), cl::cat(APINotesCategory));
+
+  cl::HideUnrelatedOptions(APINotesCategory);
+
+  SmallVector<const char *, 4> Args;
+  Args.push_back(Argv0);
+  Args.append(Argv.begin(), Argv.end());
+  cl::ParseCommandLineOptions(Args.size(),
+                              Args.data(),
+                              "Clang API Notes Tool\n");
+
+  if (Action == clang::api_notes::ActionType::None) {
+    errs() << "action required\n";
+    cl::PrintHelpMessage();
+    return 1;
+  }
+
+  auto fileBufOrErr = MemoryBuffer::getFile(InputFilename);
+  if (std::error_code EC = fileBufOrErr.getError()) {
+    llvm::errs() << "\n Could not open input file: " + EC.message() << '\n';
+    return true;
+  }
+  StringRef input = fileBufOrErr.get()->getBuffer();
+
+  switch (Action) {
+  case api_notes::ActionType::None:
+    llvm_unreachable("handled above");
+
+  case api_notes::ActionType::YAMLToBinary: {
+    if (OutputFilename.empty()) {
+      errs() << "output file is required\n";
+      cl::PrintHelpMessage();
+      return 1;
+    }
+
+    api_notes::OSType targetOS = api_notes::OSType::Absent;
+    // TODO: Check that we've specified the target.
+    if (!Target.empty()) {
+      llvm::Triple target(llvm::Triple::normalize(Target));
+      switch (target.getOS()) {
+        case llvm::Triple::Darwin:
+        case llvm::Triple::MacOSX:
+          targetOS = api_notes::OSType::OSX;
+          break;
+        case llvm::Triple::IOS:
+          targetOS = api_notes::OSType::IOS;
+          break;
+        case llvm::Triple::WatchOS:
+          targetOS = api_notes::OSType::WatchOS;
+          break;
+        case llvm::Triple::TvOS:
+          targetOS = api_notes::OSType::TvOS;
+          break;
+        default:
+          errs() << "target is not supported\n";
+          return 1;
+      }
+    }
+    std::error_code EC;
+    llvm::raw_fd_ostream os(OutputFilename, EC,
+                            llvm::sys::fs::OpenFlags::F_None);
+
+    if (api_notes::compileAPINotes(input, /*sourceFile=*/nullptr, os, targetOS))
+      return 1;
+    
+    os.flush();
+
+    return os.has_error();
+  }
+
+  case api_notes::ActionType::BinaryToYAML: {
+    if (OutputFilename.empty()) {
+      errs() << "output file required\n";
+      cl::PrintHelpMessage();
+      return 1;
+    }
+
+    std::error_code EC;
+    llvm::raw_fd_ostream os(OutputFilename, EC,
+                            llvm::sys::fs::OpenFlags::F_None);
+
+    if (api_notes::decompileAPINotes(std::move(fileBufOrErr.get()), os))
+      return 1;
+    
+    os.flush();
+
+    return os.has_error();
+  }
+
+  case api_notes::ActionType::Dump:
+    return api_notes::parseAndDumpAPINotes(input);
+  }
+
+  return 1;
+}
+
diff --git a/tools/driver/driver.cpp b/tools/driver/driver.cpp
index fa757da953..761476c51e 100644
--- a/tools/driver/driver.cpp
+++ b/tools/driver/driver.cpp
@@ -205,6 +205,8 @@ extern int cc1_main(ArrayRef<const char *> Argv, const char *Argv0,
                     void *MainAddr);
 extern int cc1as_main(ArrayRef<const char *> Argv, const char *Argv0,
                       void *MainAddr);
+extern int cc1apinotes_main(ArrayRef<const char *> Argv, const char *Argv0,
+                            void *MainAddr);
 
 static void insertTargetAndModeArgs(const ParsedClangName &NameParts,
                                     SmallVectorImpl<const char *> &ArgVector,
@@ -309,6 +311,8 @@ static int ExecuteCC1Tool(ArrayRef<const char *> argv, StringRef Tool) {
     return cc1_main(argv.slice(2), argv[0], GetExecutablePathVP);
   if (Tool == "as")
     return cc1as_main(argv.slice(2), argv[0], GetExecutablePathVP);
+  if (Tool == "apinotes")
+    return cc1apinotes_main(argv.slice(2), argv[0], GetExecutablePathVP);
 
   // Reject unknown tools.
   llvm::errs() << "error: unknown integrated tool '" << Tool << "'\n";
diff --git a/tools/libclang/CIndexDiagnostic.cpp b/tools/libclang/CIndexDiagnostic.cpp
index 4e47b25a4b..9ac1819653 100644
--- a/tools/libclang/CIndexDiagnostic.cpp
+++ b/tools/libclang/CIndexDiagnostic.cpp
@@ -146,7 +146,20 @@ public:
 
   CXDiagnosticSetImpl *CurrentSet;
   CXDiagnosticSetImpl *MainSet;
-};  
+};
+
+class CXStoredDiagnosticSet : public CXDiagnosticSetImpl {
+  llvm::SmallVector<StoredDiagnostic, 2> Diags;
+
+public:
+  CXStoredDiagnosticSet(ArrayRef<StoredDiagnostic> Diags,
+                        const LangOptions &LangOpts)
+      : CXDiagnosticSetImpl(/*isManaged=*/true),
+        Diags(Diags.begin(), Diags.end()) {
+    for (const auto &Diag : this->Diags)
+      appendDiagnostic(llvm::make_unique<CXStoredDiagnostic>(Diag, LangOpts));
+  }
+};
 }
 
 CXDiagnosticSetImpl *cxdiag::lazyCreateDiags(CXTranslationUnit TU,
@@ -196,6 +209,11 @@ CXDiagnosticSetImpl *cxdiag::lazyCreateDiags(CXTranslationUnit TU,
   return static_cast<CXDiagnosticSetImpl*>(TU->Diagnostics);
 }
 
+CXDiagnosticSetImpl *cxdiag::createStoredDiags(ArrayRef<StoredDiagnostic> Diags,
+                                               const LangOptions &LangOpts) {
+  return new CXStoredDiagnosticSet(Diags, LangOpts);
+}
+
 //-----------------------------------------------------------------------------
 // C Interface Routines
 //-----------------------------------------------------------------------------
diff --git a/tools/libclang/CIndexDiagnostic.h b/tools/libclang/CIndexDiagnostic.h
index 9f406987eb..468f9bcde6 100644
--- a/tools/libclang/CIndexDiagnostic.h
+++ b/tools/libclang/CIndexDiagnostic.h
@@ -14,6 +14,7 @@
 #define LLVM_CLANG_TOOLS_LIBCLANG_CINDEXDIAGNOSTIC_H
 
 #include "clang-c/Index.h"
+#include "clang/Basic/LLVM.h"
 #include <memory>
 #include <vector>
 #include <assert.h>
@@ -158,6 +159,9 @@ struct CXStoredDiagnostic : public CXDiagnosticImpl {
 namespace cxdiag {
 CXDiagnosticSetImpl *lazyCreateDiags(CXTranslationUnit TU,
                                      bool checkIfChanged = false);
+
+CXDiagnosticSetImpl *createStoredDiags(ArrayRef<StoredDiagnostic> Diags,
+                                       const LangOptions &LangOpts);
 } // end namespace cxdiag
 
 } // end namespace clang
diff --git a/tools/libclang/CMakeLists.txt b/tools/libclang/CMakeLists.txt
index 4440637820..c16e7d3841 100644
--- a/tools/libclang/CMakeLists.txt
+++ b/tools/libclang/CMakeLists.txt
@@ -9,6 +9,7 @@ set(SOURCES
   CIndexInclusionStack.cpp
   CIndexUSRs.cpp
   CIndexer.cpp
+  CRefactor.cpp
   CXComment.cpp
   CXCursor.cpp
   CXIndexDataConsumer.cpp
@@ -35,12 +36,14 @@ set(SOURCES
 
 set(LIBS
   clangAST
+  clangAPINotes
   clangBasic
   clangFrontend
   clangIndex
   clangLex
   clangSema
   clangTooling
+  clangToolingRefactor
 )
 
 if (CLANG_ENABLE_ARCMT)
diff --git a/tools/libclang/CRefactor.cpp b/tools/libclang/CRefactor.cpp
index e69de29bb2..aa9667f51b 100644
--- a/tools/libclang/CRefactor.cpp
+++ b/tools/libclang/CRefactor.cpp
@@ -0,0 +1,1963 @@
+//===- CRefactor.cpp - Refactoring API hooks ------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the Clang-C refactoring library.
+//
+//===----------------------------------------------------------------------===//
+
+#include "CIndexDiagnostic.h"
+#include "CIndexer.h"
+#include "CLog.h"
+#include "CXCursor.h"
+#include "CXSourceLocation.h"
+#include "CXString.h"
+#include "CXTranslationUnit.h"
+#include "clang-c/Refactor.h"
+#include "clang/AST/ASTConsumer.h"
+#include "clang/Basic/DiagnosticCategories.h"
+#include "clang/Frontend/ASTUnit.h"
+#include "clang/Frontend/CompilerInstance.h"
+#include "clang/Frontend/CompilerInvocation.h"
+#include "clang/Frontend/Utils.h"
+#include "clang/Index/USRGeneration.h"
+#include "clang/Tooling/Refactor/IndexerQuery.h"
+#include "clang/Tooling/Refactor/RefactoringActionFinder.h"
+#include "clang/Tooling/Refactor/RefactoringActions.h"
+#include "clang/Tooling/Refactor/RefactoringOperation.h"
+#include "clang/Tooling/Refactor/RefactoringOptions.h"
+#include "clang/Tooling/Refactor/RenameIndexedFile.h"
+#include "clang/Tooling/Refactor/RenamingOperation.h"
+#include "clang/Tooling/Refactor/SymbolOccurrenceFinder.h"
+#include "clang/Tooling/Refactor/USRFinder.h"
+#include "clang/Tooling/Tooling.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/StringMap.h"
+#include <set>
+#include <vector>
+
+using namespace clang;
+using namespace clang::tooling;
+
+static RefactoringActionType
+translateRefactoringActionType(CXRefactoringActionType Action) {
+  switch (Action) {
+#define REFACTORING_ACTION(Name, Spelling)                                     \
+  case CXRefactor_##Name:                                                      \
+    return RefactoringActionType::Name;
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+  }
+}
+
+static CXRefactoringActionType
+translateRefactoringActionType(RefactoringActionType Action) {
+  switch (Action) {
+#define REFACTORING_ACTION(Name, Spelling)                                     \
+  case RefactoringActionType::Name:                                            \
+    return CXRefactor_##Name;
+#include "clang/Tooling/Refactor/RefactoringActions.def"
+  }
+}
+
+static CXSymbolOccurrenceKind
+translateOccurrenceKind(rename::OldSymbolOccurrence::OccurrenceKind Kind) {
+  switch (Kind) {
+  case rename::OldSymbolOccurrence::MatchingSymbol:
+    return CXSymbolOccurrence_MatchingSymbol;
+  case rename::OldSymbolOccurrence::MatchingSelector:
+    return CXSymbolOccurrence_MatchingSelector;
+  case rename::OldSymbolOccurrence::MatchingImplicitProperty:
+    return CXSymbolOccurrence_MatchingImplicitProperty;
+  case rename::OldSymbolOccurrence::MatchingComment:
+    return CXSymbolOccurrence_MatchingCommentString;
+  case rename::OldSymbolOccurrence::MatchingDocComment:
+    return CXSymbolOccurrence_MatchingDocCommentString;
+  case rename::OldSymbolOccurrence::MatchingFilename:
+    return CXSymbolOccurrence_MatchingFilename;
+  case rename::OldSymbolOccurrence::MatchingStringLiteral:
+    return CXSymbolOccurrence_MatchingStringLiteral;
+  }
+}
+
+namespace {
+
+// TODO: Remove
+class RenamingResult {
+  struct RenamedNameString {
+    CXString NewString;
+    unsigned OldLength;
+  };
+  typedef SmallVector<RenamedNameString, 4> SymbolNameInfo;
+  std::vector<SymbolNameInfo> NameInfo;
+
+  /// The set of files that have to be modified.
+  llvm::SmallVector<CXString, 2> Filenames;
+  llvm::SpecificBumpPtrAllocator<CXRefactoringReplacement_Old> Replacements;
+  std::vector<std::vector<CXRenamedSymbolOccurrence>> Occurrences;
+
+  void addOccurrence(const rename::OldSymbolOccurrence &RenamedOccurrence,
+                     const SourceManager &SM, const LangOptions &LangOpts) {
+    CXRefactoringReplacement_Old *OccurrenceReplacements =
+        Replacements.Allocate(RenamedOccurrence.locations().size());
+
+    unsigned I = 0;
+    const auto &SymbolNameInfo = NameInfo[RenamedOccurrence.SymbolIndex];
+    if (!RenamedOccurrence.IsMacroExpansion &&
+        RenamedOccurrence.Kind !=
+            rename::OldSymbolOccurrence::MatchingComment &&
+        RenamedOccurrence.Kind !=
+            rename::OldSymbolOccurrence::MatchingDocComment)
+      assert(RenamedOccurrence.locations().size() == SymbolNameInfo.size());
+    for (const auto &Location : RenamedOccurrence.locations()) {
+      CXSourceRange Range = cxloc::translateSourceRange(
+          SM, LangOpts,
+          CharSourceRange::getCharRange(RenamedOccurrence.getLocationRange(
+              Location, SymbolNameInfo[I].OldLength)));
+      CXFileLocation Begin, End;
+      clang_getFileLocation(clang_getRangeStart(Range), nullptr, &Begin.Line,
+                            &Begin.Column, nullptr);
+      clang_getFileLocation(clang_getRangeEnd(Range), nullptr, &End.Line,
+                            &End.Column, nullptr);
+
+      OccurrenceReplacements[I] = CXRefactoringReplacement_Old{
+          {Begin, End},
+          RenamedOccurrence.IsMacroExpansion ? cxstring::createNull()
+                                             : SymbolNameInfo[I].NewString};
+      ++I;
+    }
+
+    Occurrences.back().push_back(CXRenamedSymbolOccurrence{
+        OccurrenceReplacements, I,
+        translateOccurrenceKind(RenamedOccurrence.Kind),
+        RenamedOccurrence.IsMacroExpansion});
+  }
+
+public:
+  RenamingResult(ArrayRef<OldSymbolName> NewNames,
+                 ArrayRef<rename::Symbol> Symbols) {
+    assert(NewNames.size() == Symbols.size());
+    for (size_t I = 0, E = NewNames.size(); I != E; ++I) {
+      const auto &NewName = NewNames[I];
+      const auto &OldName = Symbols[I].Name;
+
+      assert(NewName.size() == OldName.size());
+      SymbolNameInfo Info;
+      for (size_t I = 0, E = NewName.size(); I != E; ++I)
+        Info.push_back(RenamedNameString{cxstring::createDup(NewName[I]),
+                                         (unsigned)OldName[I].size()});
+      NameInfo.push_back(std::move(Info));
+    }
+  }
+
+  // FIXME: Don't duplicate code, Use just one constructor.
+  RenamingResult(ArrayRef<OldSymbolName> NewNames,
+                 ArrayRef<OldSymbolName> OldNames) {
+    assert(NewNames.size() == OldNames.size());
+    for (size_t I = 0, E = NewNames.size(); I != E; ++I) {
+      const auto &NewName = NewNames[I];
+      const auto &OldName = OldNames[I];
+
+      assert(NewName.size() == OldName.size());
+      SymbolNameInfo Info;
+      for (size_t I = 0, E = NewName.size(); I != E; ++I)
+        Info.push_back(RenamedNameString{cxstring::createDup(NewName[I]),
+                                         (unsigned)OldName[I].size()});
+      NameInfo.push_back(std::move(Info));
+    }
+  }
+
+  ~RenamingResult() {
+    for (const auto &SymbolInfo : NameInfo)
+      for (const auto &NameString : SymbolInfo)
+        clang_disposeString(NameString.NewString);
+    for (const auto &Filename : Filenames)
+      clang_disposeString(Filename);
+  }
+
+  void
+  handleTUResults(CXTranslationUnit TU,
+                  llvm::MutableArrayRef<rename::OldSymbolOccurrence> Results) {
+    ASTUnit *Unit = cxtu::getASTUnit(TU);
+    assert(Unit && "Invalid TU");
+    auto &Ctx = Unit->getASTContext();
+
+    // Find the set of files that have to be modified and gather the indices of
+    // the occurrences for each file.
+    const SourceManager &SM = Ctx.getSourceManager();
+    typedef std::set<rename::OldSymbolOccurrence> OccurrenceSet;
+    llvm::StringMap<OccurrenceSet> FilenamesToSymbolOccurrences;
+    for (auto &Occurrence : Results) {
+      const std::pair<FileID, unsigned> DecomposedLocation =
+          SM.getDecomposedLoc(Occurrence.locations()[0]);
+      const FileEntry *Entry = SM.getFileEntryForID(DecomposedLocation.first);
+      assert(Entry && "Invalid file entry");
+      auto &FileOccurrences =
+          FilenamesToSymbolOccurrences
+              .try_emplace(Entry->getName(), OccurrenceSet())
+              .first->getValue();
+      FileOccurrences.insert(std::move(Occurrence));
+    }
+
+    // Create the filenames
+    for (const auto &FilenameCount : FilenamesToSymbolOccurrences)
+      Filenames.push_back(cxstring::createDup(FilenameCount.getKey()));
+
+    unsigned FileIndex = 0;
+    for (const auto &RenamedOccurrences : FilenamesToSymbolOccurrences) {
+      assert(clang_getCString(Filenames[FileIndex]) ==
+                 RenamedOccurrences.getKey() &&
+             "Unstable iteration order");
+      Occurrences.push_back(std::vector<CXRenamedSymbolOccurrence>());
+      for (const auto &Occurrence : RenamedOccurrences.getValue())
+        addOccurrence(Occurrence, SM, Ctx.getLangOpts());
+      ++FileIndex;
+    }
+  }
+
+  void addMainFilename(const SourceManager &SM) {
+    assert(Filenames.empty() && "Main filename should be added only once");
+    Filenames.push_back(cxstring::createDup(
+        SM.getFileEntryForID(SM.getMainFileID())->getName()));
+    Occurrences.push_back(std::vector<CXRenamedSymbolOccurrence>());
+  }
+
+  void
+  handleSingleFileTUResults(const ASTContext &Ctx,
+                            ArrayRef<rename::OldSymbolOccurrence> Occurrences) {
+    addMainFilename(Ctx.getSourceManager());
+    for (const auto &Occurrence : Occurrences)
+      addOccurrence(Occurrence, Ctx.getSourceManager(), Ctx.getLangOpts());
+  }
+
+  void
+  handleIndexedFileOccurrence(const rename::OldSymbolOccurrence &Occurrence,
+                              const SourceManager &SM,
+                              const LangOptions &LangOpts) {
+    if (Filenames.empty()) {
+      addMainFilename(SM);
+    }
+    addOccurrence(Occurrence, SM, LangOpts);
+  }
+
+  ArrayRef<CXRenamedSymbolOccurrence> getOccurrences(unsigned FileIndex) const {
+    return Occurrences[FileIndex];
+  }
+
+  ArrayRef<CXString> getFilenames() const { return Filenames; }
+};
+
+class SymbolOccurrencesResult {
+  struct SymbolNamePiece {
+    unsigned OldLength;
+  };
+  typedef SmallVector<SymbolNamePiece, 4> SymbolNameInfo;
+  std::vector<SymbolNameInfo> NameInfo;
+
+  /// The set of files that have to be modified.
+  llvm::SmallVector<CXString, 2> Filenames;
+  llvm::SpecificBumpPtrAllocator<CXFileRange> Ranges;
+  std::vector<std::vector<CXSymbolOccurrence>> SymbolOccurrences;
+
+  void addOccurrence(const rename::OldSymbolOccurrence &RenamedOccurrence,
+                     const SourceManager &SM, const LangOptions &LangOpts) {
+    ArrayRef<SourceLocation> Locations = RenamedOccurrence.locations();
+    CXFileRange *OccurrenceRanges = Ranges.Allocate(Locations.size());
+
+    unsigned I = 0;
+    const auto &SymbolNameInfo = NameInfo[RenamedOccurrence.SymbolIndex];
+    if (!RenamedOccurrence.IsMacroExpansion &&
+        RenamedOccurrence.Kind !=
+            rename::OldSymbolOccurrence::MatchingComment &&
+        RenamedOccurrence.Kind !=
+            rename::OldSymbolOccurrence::MatchingDocComment)
+      assert(Locations.size() == SymbolNameInfo.size());
+    for (const auto &Location : Locations) {
+      CXSourceRange Range = cxloc::translateSourceRange(
+          SM, LangOpts,
+          CharSourceRange::getCharRange(RenamedOccurrence.getLocationRange(
+              Location, SymbolNameInfo[I].OldLength)));
+      CXFileLocation Begin, End;
+      clang_getFileLocation(clang_getRangeStart(Range), nullptr, &Begin.Line,
+                            &Begin.Column, nullptr);
+      clang_getFileLocation(clang_getRangeEnd(Range), nullptr, &End.Line,
+                            &End.Column, nullptr);
+      OccurrenceRanges[I] = CXFileRange{Begin, End};
+      ++I;
+    }
+
+    SymbolOccurrences.back().push_back(CXSymbolOccurrence{
+        OccurrenceRanges, /*NumNamePieces=*/I,
+        translateOccurrenceKind(RenamedOccurrence.Kind),
+        RenamedOccurrence.IsMacroExpansion, RenamedOccurrence.SymbolIndex});
+  }
+
+public:
+  SymbolOccurrencesResult(ArrayRef<rename::Symbol> Symbols) {
+    for (const auto &Symbol : Symbols) {
+      const OldSymbolName &Name = Symbol.Name;
+      SymbolNameInfo Info;
+      for (size_t I = 0, E = Name.size(); I != E; ++I)
+        Info.push_back(SymbolNamePiece{(unsigned)Name[I].size()});
+      NameInfo.push_back(std::move(Info));
+    }
+  }
+
+  SymbolOccurrencesResult(ArrayRef<OldSymbolName> Names) {
+    for (const OldSymbolName &Name : Names) {
+      SymbolNameInfo Info;
+      for (size_t I = 0, E = Name.size(); I != E; ++I)
+        Info.push_back(SymbolNamePiece{(unsigned)Name[I].size()});
+      NameInfo.push_back(std::move(Info));
+    }
+  }
+
+  ~SymbolOccurrencesResult() {
+    for (const auto &Filename : Filenames)
+      clang_disposeString(Filename);
+  }
+
+  void
+  handleTUResults(CXTranslationUnit TU,
+                  llvm::MutableArrayRef<rename::OldSymbolOccurrence> Results) {
+    ASTUnit *Unit = cxtu::getASTUnit(TU);
+    assert(Unit && "Invalid TU");
+    auto &Ctx = Unit->getASTContext();
+
+    // Find the set of files that have to be modified and gather the indices of
+    // the occurrences for each file.
+    const SourceManager &SM = Ctx.getSourceManager();
+    typedef std::set<rename::OldSymbolOccurrence> OccurrenceSet;
+    llvm::StringMap<OccurrenceSet> FilenamesToSymbolOccurrences;
+    for (auto &Occurrence : Results) {
+      const std::pair<FileID, unsigned> DecomposedLocation =
+          SM.getDecomposedLoc(Occurrence.locations()[0]);
+      const FileEntry *Entry = SM.getFileEntryForID(DecomposedLocation.first);
+      assert(Entry && "Invalid file entry");
+      auto &FileOccurrences =
+          FilenamesToSymbolOccurrences
+              .try_emplace(Entry->getName(), OccurrenceSet())
+              .first->getValue();
+      FileOccurrences.insert(std::move(Occurrence));
+    }
+
+    // Create the filenames
+    for (const auto &FilenameCount : FilenamesToSymbolOccurrences)
+      Filenames.push_back(cxstring::createDup(FilenameCount.getKey()));
+
+    unsigned FileIndex = 0;
+    for (const auto &RenamedOccurrences : FilenamesToSymbolOccurrences) {
+      assert(clang_getCString(Filenames[FileIndex]) ==
+                 RenamedOccurrences.getKey() &&
+             "Unstable iteration order");
+      SymbolOccurrences.push_back(std::vector<CXSymbolOccurrence>());
+      for (const auto &Occurrence : RenamedOccurrences.getValue())
+        addOccurrence(Occurrence, SM, Ctx.getLangOpts());
+      ++FileIndex;
+    }
+  }
+
+  void addMainFilename(const SourceManager &SM) {
+    assert(Filenames.empty() && "Main filename should be added only once");
+    Filenames.push_back(cxstring::createDup(
+        SM.getFileEntryForID(SM.getMainFileID())->getName()));
+    SymbolOccurrences.push_back(std::vector<CXSymbolOccurrence>());
+  }
+
+  void
+  handleIndexedFileOccurrence(const rename::OldSymbolOccurrence &Occurrence,
+                              const SourceManager &SM,
+                              const LangOptions &LangOpts) {
+    if (Filenames.empty()) {
+      addMainFilename(SM);
+    }
+    addOccurrence(Occurrence, SM, LangOpts);
+  }
+
+  ArrayRef<CXSymbolOccurrence> getOccurrences(unsigned FileIndex) const {
+    return SymbolOccurrences[FileIndex];
+  }
+
+  ArrayRef<CXString> getFilenames() const { return Filenames; }
+};
+
+class RenamingAction {
+public:
+  LangOptions LangOpts;
+  IdentifierTable IDs;
+  // TODO: Remove
+  SmallVector<OldSymbolName, 4> NewNames;
+  SymbolOperation Operation;
+
+  RenamingAction(const LangOptions &LangOpts, SymbolOperation Operation)
+      : LangOpts(LangOpts), IDs(LangOpts), Operation(std::move(Operation)) {}
+
+  /// \brief Sets the new renaming name and returns CXError_Success on success.
+  // TODO: Remove
+  CXErrorCode setNewName(StringRef Name) {
+    OldSymbolName NewSymbolName(Name, LangOpts);
+    if (NewSymbolName.size() != Operation.symbols()[0].Name.size())
+      return CXError_RefactoringNameSizeMismatch;
+    if (!rename::isNewNameValid(NewSymbolName, Operation, IDs, LangOpts))
+      return CXError_RefactoringNameInvalid;
+    rename::determineNewNames(std::move(NewSymbolName), Operation, NewNames,
+                              LangOpts);
+    return CXError_Success;
+  }
+
+  // TODO: Remove
+  CXString usrForSymbolAt(unsigned Index) {
+    llvm::SmallVector<char, 128> Buff;
+    if (index::generateUSRForDecl(Operation.symbols()[Index].FoundDecl, Buff))
+      return cxstring::createNull();
+    return cxstring::createDup(StringRef(Buff.begin(), Buff.size()));
+  }
+
+  // TODO: Remove
+  CXString getUSRThatRequiresImplementationTU() {
+    llvm::SmallVector<char, 128> Buff;
+    if (!Operation.requiresImplementationTU() ||
+        index::generateUSRForDecl(Operation.declThatRequiresImplementationTU(),
+                                  Buff))
+      return cxstring::createNull();
+    return cxstring::createDup(StringRef(Buff.begin(), Buff.size()));
+  }
+
+  // TODO: Remove
+  RenamingResult *handlePrimaryTU(CXTranslationUnit TU, ASTUnit &Unit) {
+    // Perform the renaming.
+    if (NewNames.empty())
+      return nullptr;
+
+    const ASTContext &Context = Unit.getASTContext();
+    auto Occurrences = rename::findSymbolOccurrences(
+        Operation, Context.getTranslationUnitDecl());
+    auto *Result = new RenamingResult(NewNames, Operation.symbols());
+    Result->handleTUResults(TU, Occurrences);
+    return Result;
+  }
+
+  SymbolOccurrencesResult *findSymbolsInInitiationTU(CXTranslationUnit TU,
+                                                     ASTUnit &Unit) {
+    const ASTContext &Context = Unit.getASTContext();
+    auto Occurrences = rename::findSymbolOccurrences(
+        Operation, Context.getTranslationUnitDecl());
+    auto *Result = new SymbolOccurrencesResult(Operation.symbols());
+    Result->handleTUResults(TU, Occurrences);
+    return Result;
+  }
+};
+
+static bool isObjCSelectorKind(CXCursorKind Kind) {
+  return Kind == CXCursor_ObjCInstanceMethodDecl ||
+         Kind == CXCursor_ObjCClassMethodDecl ||
+         Kind == CXCursor_ObjCMessageExpr;
+}
+
+// TODO: Remove
+static bool isObjCSelector(const CXRenamedIndexedSymbol &Symbol) {
+  if (isObjCSelectorKind(Symbol.CursorKind))
+    return true;
+  for (const auto &Occurrence : llvm::makeArrayRef(
+           Symbol.IndexedLocations, Symbol.IndexedLocationCount)) {
+    if (isObjCSelectorKind(Occurrence.CursorKind))
+      return true;
+  }
+  return false;
+}
+
+static bool isObjCSelector(const CXIndexedSymbol &Symbol) {
+  if (isObjCSelectorKind(Symbol.CursorKind))
+    return true;
+  for (const auto &Occurrence : llvm::makeArrayRef(
+           Symbol.IndexedLocations, Symbol.IndexedLocationCount)) {
+    if (isObjCSelectorKind(Occurrence.CursorKind))
+      return true;
+  }
+  return false;
+}
+
+// New names are initialized and verified after the LangOptions are created.
+CXErrorCode computeNewNames(ArrayRef<CXRenamedIndexedSymbol> Symbols,
+                            ArrayRef<OldSymbolName> SymbolNames,
+                            const LangOptions &LangOpts,
+                            SmallVectorImpl<OldSymbolName> &NewNames) {
+  IdentifierTable IDs(LangOpts);
+  for (const auto &Symbol : Symbols) {
+    OldSymbolName NewSymbolName(Symbol.NewName, LangOpts);
+    if (NewSymbolName.size() != SymbolNames[0].size())
+      return CXError_RefactoringNameSizeMismatch;
+    if (!rename::isNewNameValid(NewSymbolName, isObjCSelector(Symbol), IDs,
+                                LangOpts))
+      return CXError_RefactoringNameInvalid;
+    NewNames.push_back(std::move(NewSymbolName));
+  }
+  return CXError_Success;
+}
+
+static rename::IndexedOccurrence::OccurrenceKind
+translateIndexedOccurrenceKind(CXCursorKind Kind) {
+  switch (Kind) {
+  case CXCursor_ObjCMessageExpr:
+    return rename::IndexedOccurrence::IndexedObjCMessageSend;
+  case CXCursor_InclusionDirective:
+    return rename::IndexedOccurrence::InclusionDirective;
+  default:
+    return rename::IndexedOccurrence::IndexedSymbol;
+  }
+}
+
+// TODO: Remove
+CXErrorCode performIndexedFileRename(
+    ArrayRef<CXRenamedIndexedSymbol> Symbols, StringRef Filename,
+    ArrayRef<const char *> Arguments, CXIndex CIdx,
+    MutableArrayRef<CXUnsavedFile> UnsavedFiles,
+    const RefactoringOptionSet *Options, CXRenamingResult &Result) {
+  Result = nullptr;
+
+  // Adjust the given command line arguments to ensure that any positional
+  // arguments in them are stripped.
+  std::vector<const char *> ClangToolArguments;
+  ClangToolArguments.push_back("--");
+  for (const auto &Arg : Arguments) {
+    // Remove the '-gmodules' option, as the -fmodules-format=obj isn't
+    // supported without the linked object reader.
+    if (StringRef(Arg) == "-gmodules")
+      continue;
+    ClangToolArguments.push_back(Arg);
+  }
+  int Argc = ClangToolArguments.size();
+  std::string ErrorMessage;
+  std::unique_ptr<CompilationDatabase> Compilations =
+      FixedCompilationDatabase::loadFromCommandLine(
+          Argc, ClangToolArguments.data(), ErrorMessage);
+  if (!Compilations) {
+    llvm::errs() << "CRefactor: Failed to load command line: " << ErrorMessage
+                 << "\n";
+    return CXError_Failure;
+  }
+
+  // Translate the symbols.
+  llvm::SmallVector<rename::IndexedSymbol, 4> IndexedSymbols;
+  for (const auto &Symbol : Symbols) {
+
+    // Parse the symbol name.
+    bool IsObjCSelector = false;
+    // Selectors have to be parsed.
+    if (isObjCSelector(Symbol))
+      IsObjCSelector = true;
+    // Ensure that we don't get selectors with incorrect symbol kind.
+    else if (StringRef(Symbol.Name).contains(':'))
+      return CXError_InvalidArguments;
+
+    std::vector<rename::IndexedOccurrence> IndexedOccurrences;
+    for (const auto &Loc : llvm::makeArrayRef(Symbol.IndexedLocations,
+                                              Symbol.IndexedLocationCount)) {
+      rename::IndexedOccurrence Result;
+      Result.Line = Loc.Location.Line;
+      Result.Column = Loc.Location.Column;
+      Result.Kind = translateIndexedOccurrenceKind(Loc.CursorKind);
+      IndexedOccurrences.push_back(Result);
+    }
+
+    IndexedSymbols.emplace_back(OldSymbolName(Symbol.Name, IsObjCSelector),
+                                IndexedOccurrences,
+                                /*IsObjCSelector=*/IsObjCSelector);
+  }
+
+  class ToolRunner final : public FrontendActionFactory,
+                           public rename::IndexedFileOccurrenceConsumer {
+    ArrayRef<CXRenamedIndexedSymbol> Symbols;
+    ArrayRef<rename::IndexedSymbol> IndexedSymbols;
+    const RefactoringOptionSet *Options;
+
+  public:
+    RenamingResult *Result;
+    CXErrorCode Err;
+
+    ToolRunner(ArrayRef<CXRenamedIndexedSymbol> Symbols,
+               ArrayRef<rename::IndexedSymbol> IndexedSymbols,
+               const RefactoringOptionSet *Options)
+        : Symbols(Symbols), IndexedSymbols(IndexedSymbols), Options(Options),
+          Result(nullptr), Err(CXError_Success) {}
+
+    clang::FrontendAction *create() override {
+      return new rename::IndexedFileOccurrenceProducer(IndexedSymbols, *this,
+                                                       Options);
+    }
+
+    void handleOccurrence(const rename::OldSymbolOccurrence &Occurrence,
+                          SourceManager &SM,
+                          const LangOptions &LangOpts) override {
+      if (Err != CXError_Success)
+        return;
+      if (!Result) {
+        SmallVector<OldSymbolName, 4> SymbolNames;
+        for (const auto &Symbol : IndexedSymbols)
+          SymbolNames.push_back(Symbol.Name);
+        SmallVector<OldSymbolName, 4> NewNames;
+        Err = computeNewNames(Symbols, SymbolNames, LangOpts, NewNames);
+        if (Err != CXError_Success)
+          return;
+        Result = new RenamingResult(NewNames, SymbolNames);
+      }
+      Result->handleIndexedFileOccurrence(Occurrence, SM, LangOpts);
+    }
+  };
+
+  auto Runner = llvm::make_unique<ToolRunner>(Symbols, IndexedSymbols, Options);
+
+  // Run a clang tool on the input file.
+  std::string Name = Filename.str();
+  ClangTool Tool(*Compilations, Name);
+  Tool.run(Runner.get());
+  if (Runner->Err != CXError_Success)
+    return Runner->Err;
+  Result = Runner->Result;
+  return CXError_Success;
+}
+
+CXErrorCode performIndexedSymbolSearch(
+    ArrayRef<CXIndexedSymbol> Symbols, StringRef Filename,
+    ArrayRef<const char *> Arguments, CXIndex CIdx,
+    MutableArrayRef<CXUnsavedFile> UnsavedFiles,
+    const RefactoringOptionSet *Options, CXSymbolOccurrencesResult &Result) {
+  Result = nullptr;
+
+  // Adjust the given command line arguments to ensure that any positional
+  // arguments in them are stripped.
+  std::vector<const char *> ClangToolArguments;
+  ClangToolArguments.push_back("--");
+  for (const auto &Arg : Arguments) {
+    // Remove the '-gmodules' option, as the -fmodules-format=obj isn't
+    // supported without the linked object reader.
+    if (StringRef(Arg) == "-gmodules")
+      continue;
+    ClangToolArguments.push_back(Arg);
+  }
+  int Argc = ClangToolArguments.size();
+  std::string ErrorMessage;
+  std::unique_ptr<CompilationDatabase> Compilations =
+      FixedCompilationDatabase::loadFromCommandLine(
+          Argc, ClangToolArguments.data(), ErrorMessage);
+  if (!Compilations) {
+    llvm::errs() << "CRefactor: Failed to load command line: " << ErrorMessage
+                 << "\n";
+    return CXError_Failure;
+  }
+
+  // Translate the symbols.
+  llvm::SmallVector<rename::IndexedSymbol, 4> IndexedSymbols;
+  for (const auto &Symbol : Symbols) {
+
+    // Parse the symbol name.
+    bool IsObjCSelector = false;
+    // Selectors have to be parsed.
+    if (isObjCSelector(Symbol))
+      IsObjCSelector = true;
+    // Ensure that we don't get selectors with incorrect symbol kind.
+    else if (StringRef(Symbol.Name).contains(':'))
+      return CXError_InvalidArguments;
+
+    std::vector<rename::IndexedOccurrence> IndexedOccurrences;
+    for (const auto &Loc : llvm::makeArrayRef(Symbol.IndexedLocations,
+                                              Symbol.IndexedLocationCount)) {
+      rename::IndexedOccurrence Result;
+      Result.Line = Loc.Location.Line;
+      Result.Column = Loc.Location.Column;
+      Result.Kind = translateIndexedOccurrenceKind(Loc.CursorKind);
+      IndexedOccurrences.push_back(Result);
+    }
+
+    IndexedSymbols.emplace_back(
+        OldSymbolName(Symbol.Name, IsObjCSelector), IndexedOccurrences,
+        /*IsObjCSelector=*/IsObjCSelector,
+        /*SearchForStringLiteralOccurrences=*/
+        Symbol.CursorKind == CXCursor_ObjCInterfaceDecl);
+  }
+
+  class ToolRunner final : public FrontendActionFactory,
+                           public rename::IndexedFileOccurrenceConsumer {
+    ArrayRef<rename::IndexedSymbol> IndexedSymbols;
+    const RefactoringOptionSet *Options;
+
+  public:
+    SymbolOccurrencesResult *Result;
+
+    ToolRunner(ArrayRef<rename::IndexedSymbol> IndexedSymbols,
+               const RefactoringOptionSet *Options)
+        : IndexedSymbols(IndexedSymbols), Options(Options), Result(nullptr) {}
+
+    clang::FrontendAction *create() override {
+      return new rename::IndexedFileOccurrenceProducer(IndexedSymbols, *this,
+                                                       Options);
+    }
+
+    void handleOccurrence(const rename::OldSymbolOccurrence &Occurrence,
+                          SourceManager &SM,
+                          const LangOptions &LangOpts) override {
+      if (!Result) {
+        SmallVector<OldSymbolName, 4> SymbolNames;
+        for (const auto &Symbol : IndexedSymbols)
+          SymbolNames.push_back(Symbol.Name);
+        Result = new SymbolOccurrencesResult(SymbolNames);
+      }
+      Result->handleIndexedFileOccurrence(Occurrence, SM, LangOpts);
+    }
+  };
+
+  auto Runner = llvm::make_unique<ToolRunner>(IndexedSymbols, Options);
+
+  // Run a clang tool on the input file.
+  std::string Name = Filename.str();
+  ClangTool Tool(*Compilations, Name);
+  for (const CXUnsavedFile &File : UnsavedFiles)
+    Tool.mapVirtualFile(File.Filename, StringRef(File.Contents, File.Length));
+  if (Tool.run(Runner.get()))
+    return CXError_Failure;
+  Result = Runner->Result;
+  return CXError_Success;
+}
+
+class RefactoringAction {
+  std::unique_ptr<RefactoringOperation> Operation;
+  std::unique_ptr<RenamingAction> Rename;
+
+  SmallVector<CXRefactoringCandidate, 2> RefactoringCandidates;
+  CXRefactoringCandidateSet CandidateSet = {nullptr, 0};
+  bool HasCandidateSet = false;
+
+public:
+  CXRefactoringActionType Type;
+  unsigned SelectedCandidate = 0;
+  CXTranslationUnit InitiationTU;
+  // TODO: Remove (no longer needed due to continuations).
+  CXTranslationUnit ImplementationTU;
+
+  RefactoringAction(std::unique_ptr<RefactoringOperation> Operation,
+                    CXRefactoringActionType Type,
+                    CXTranslationUnit InitiationTU)
+      : Operation(std::move(Operation)), Type(Type), InitiationTU(InitiationTU),
+        ImplementationTU(nullptr) {}
+
+  RefactoringAction(std::unique_ptr<RenamingAction> Rename,
+                    CXTranslationUnit InitiationTU)
+      : Rename(std::move(Rename)),
+        Type(this->Rename->Operation.isLocal() ? CXRefactor_Rename_Local
+                                               : CXRefactor_Rename),
+        InitiationTU(InitiationTU), ImplementationTU(nullptr) {}
+
+  ~RefactoringAction() {
+    for (const auto &Candidate : RefactoringCandidates)
+      clang_disposeString(Candidate.Description);
+  }
+
+  RefactoringOperation *getOperation() const { return Operation.get(); }
+
+  RenamingAction *getRenamingAction() const { return Rename.get(); }
+
+  CXRefactoringCandidateSet getRefactoringCandidates() {
+    if (HasCandidateSet)
+      return CandidateSet;
+    HasCandidateSet = true;
+    RefactoringOperation *Operation = getOperation();
+    if (!Operation)
+      return CandidateSet;
+    auto Candidates = Operation->getRefactoringCandidates();
+    if (Candidates.empty())
+      return CandidateSet;
+    for (const auto &Candidate : Candidates)
+      RefactoringCandidates.push_back({cxstring::createDup(Candidate)});
+    CandidateSet = {RefactoringCandidates.data(),
+                    (unsigned)RefactoringCandidates.size()};
+    return CandidateSet;
+  }
+
+  CXErrorCode selectCandidate(unsigned Index) {
+    RefactoringOperation *Operation = getOperation();
+    if (!Operation)
+      return CXError_InvalidArguments;
+    if (Index != 0 && Index >= getRefactoringCandidates().NumCandidates)
+      return CXError_InvalidArguments;
+    SelectedCandidate = Index;
+    return CXError_Success;
+  }
+};
+
+static bool operator==(const CXFileLocation &LHS, const CXFileLocation &RHS) {
+  return LHS.Line == RHS.Line && LHS.Column == RHS.Column;
+}
+
+static CXFileRange translateOffsetToRelativeRange(unsigned Offset,
+                                                  unsigned Size,
+                                                  StringRef Source) {
+  assert(Source.drop_front(Offset).take_front(Size).count('\n') == 0 &&
+         "Newlines in translated range?");
+  StringRef Prefix = Source.take_front(Offset);
+  unsigned StartLines = Prefix.count('\n') + 1;
+  if (StartLines > 1)
+    Offset -= Prefix.rfind('\n') + 1;
+  return CXFileRange{{StartLines, Offset + 1}, {StartLines, Offset + 1 + Size}};
+}
+
+class RefactoringResultWrapper {
+public:
+  CXRefactoringReplacements_Old Replacements; // TODO: Remove.
+  CXRefactoringReplacements SourceReplacements;
+  std::unique_ptr<RefactoringContinuation> Continuation;
+  llvm::BumpPtrAllocator Allocator;
+  CXTranslationUnit TU;
+
+  struct AssociatedReplacementInfo {
+    CXSymbolOccurrence *AssociatedSymbolOccurrences;
+    unsigned NumAssociatedSymbolOccurrences;
+  };
+
+  ~RefactoringResultWrapper() {
+    // TODO: Remove.
+    for (unsigned I = 0; I < Replacements.NumFileReplacementSets; ++I) {
+      const CXRefactoringFileReplacementSet_Old &FileSet =
+          Replacements.FileReplacementSets[I];
+      clang_disposeString(FileSet.Filename);
+      for (unsigned J = 0; J < FileSet.NumReplacements; ++J)
+        clang_disposeString(FileSet.Replacements[J].ReplacementString);
+      delete[] FileSet.Replacements;
+    }
+    delete[] Replacements.FileReplacementSets;
+
+    for (unsigned I = 0; I < SourceReplacements.NumFileReplacementSets; ++I) {
+      const CXRefactoringFileReplacementSet &FileSet =
+          SourceReplacements.FileReplacementSets[I];
+      clang_disposeString(FileSet.Filename);
+      for (unsigned J = 0; J < FileSet.NumReplacements; ++J)
+        clang_disposeString(FileSet.Replacements[J].ReplacementString);
+    }
+  }
+
+  RefactoringResultWrapper(
+      ArrayRef<RefactoringReplacement> Replacements,
+      ArrayRef<std::unique_ptr<RefactoringResultAssociatedSymbol>>
+          AssociatedSymbols,
+      std::unique_ptr<RefactoringContinuation> Continuation,
+      ASTContext &Context, CXTranslationUnit TU)
+      : Continuation(std::move(Continuation)), TU(TU) {
+    SourceManager &SM = Context.getSourceManager();
+
+    if (Replacements.empty()) {
+      assert(AssociatedSymbols.empty() && "Symbols without replacements??");
+      // TODO: Remove begin
+      this->Replacements.NumFileReplacementSets = 0;
+      this->Replacements.FileReplacementSets = nullptr;
+      // Remove end
+      this->SourceReplacements.NumFileReplacementSets = 0;
+      this->SourceReplacements.FileReplacementSets = nullptr;
+      return;
+    }
+    llvm::SmallDenseMap<const RefactoringResultAssociatedSymbol *, unsigned>
+        AssociatedSymbolToIndex;
+    for (const auto &Symbol : llvm::enumerate(AssociatedSymbols))
+      AssociatedSymbolToIndex[Symbol.value().get()] = Symbol.index();
+
+    // Find the set of files that have to be modified and gather the indices of
+    // the occurrences for each file.
+    llvm::DenseMap<const FileEntry *, std::vector<unsigned>>
+        FilesToReplacements;
+    for (const auto &Replacement : llvm::enumerate(Replacements)) {
+      SourceLocation Loc = Replacement.value().Range.getBegin();
+      const std::pair<FileID, unsigned> DecomposedLocation =
+          SM.getDecomposedLoc(Loc);
+      assert(DecomposedLocation.first.isValid() && "Invalid file!");
+      const FileEntry *Entry = SM.getFileEntryForID(DecomposedLocation.first);
+      FilesToReplacements.try_emplace(Entry, std::vector<unsigned>())
+          .first->second.push_back(Replacement.index());
+    }
+
+    // TODO: Remove
+    unsigned NumFiles = FilesToReplacements.size();
+    auto *FileReplacementSets =
+        new CXRefactoringFileReplacementSet_Old[NumFiles];
+
+    unsigned FileIndex = 0;
+    for (const auto &Entry : FilesToReplacements) {
+      CXRefactoringFileReplacementSet_Old &FileSet =
+          FileReplacementSets[FileIndex];
+      ++FileIndex;
+      ArrayRef<unsigned> ReplacementIndices = Entry.second;
+      FileSet.Filename = cxstring::createDup(Entry.first->getName());
+      FileSet.NumReplacements = ReplacementIndices.size();
+      auto *FileReplacements =
+          new CXRefactoringReplacement_Old[ReplacementIndices.size()];
+      FileSet.Replacements = FileReplacements;
+
+      unsigned NumRemoved = 0;
+      for (unsigned I = 0; I < FileSet.NumReplacements; ++I) {
+        const RefactoringReplacement &RefReplacement =
+            Replacements[ReplacementIndices[I]];
+        CXSourceRange Range = cxloc::translateSourceRange(
+            SM, Context.getLangOpts(),
+            CharSourceRange::getCharRange(RefReplacement.Range.getBegin(),
+                                          RefReplacement.Range.getEnd()));
+        CXFileLocation Begin, End;
+        clang_getFileLocation(clang_getRangeStart(Range), nullptr, &Begin.Line,
+                              &Begin.Column, nullptr);
+        clang_getFileLocation(clang_getRangeEnd(Range), nullptr, &End.Line,
+                              &End.Column, nullptr);
+
+        if (I && FileReplacements[I - NumRemoved - 1].Range.End == Begin) {
+          // Merge the previous and the current replacement.
+          FileReplacements[I - NumRemoved - 1].Range.End = End;
+          std::string Replacement =
+              std::string(clang_getCString(
+                  FileReplacements[I - NumRemoved - 1].ReplacementString)) +
+              RefReplacement.ReplacementString;
+          clang_disposeString(
+              FileReplacements[I - NumRemoved - 1].ReplacementString);
+          FileReplacements[I - NumRemoved - 1].ReplacementString =
+              cxstring::createDup(Replacement);
+          NumRemoved++;
+          continue;
+        }
+
+        CXRefactoringReplacement_Old &Replacement =
+            FileReplacements[I - NumRemoved];
+        Replacement.ReplacementString =
+            cxstring::createDup(RefReplacement.ReplacementString);
+        Replacement.Range.Begin = Begin;
+        Replacement.Range.End = End;
+      }
+      FileSet.NumReplacements -= NumRemoved;
+    }
+
+    this->Replacements.FileReplacementSets = FileReplacementSets;
+    this->Replacements.NumFileReplacementSets = NumFiles;
+
+    // TODO: Outdent.
+    {
+      unsigned NumFiles = FilesToReplacements.size();
+      auto *FileReplacementSets =
+          Allocator.Allocate<CXRefactoringFileReplacementSet>(NumFiles);
+      SourceReplacements.FileReplacementSets = FileReplacementSets;
+      SourceReplacements.NumFileReplacementSets = NumFiles;
+      unsigned FileIndex = 0;
+      for (const auto &Entry : FilesToReplacements) {
+        CXRefactoringFileReplacementSet &FileSet =
+            FileReplacementSets[FileIndex];
+        ++FileIndex;
+        ArrayRef<unsigned> ReplacementIndices = Entry.second;
+        FileSet.Filename = cxstring::createDup(Entry.first->getName());
+        FileSet.NumReplacements = ReplacementIndices.size();
+        auto *FileReplacements = Allocator.Allocate<CXRefactoringReplacement>(
+            ReplacementIndices.size());
+        FileSet.Replacements = FileReplacements;
+
+        unsigned NumRemoved = 0;
+        for (unsigned I = 0; I < FileSet.NumReplacements; ++I) {
+          const RefactoringReplacement &RefReplacement =
+              Replacements[ReplacementIndices[I]];
+          CXSourceRange Range = cxloc::translateSourceRange(
+              SM, Context.getLangOpts(),
+              CharSourceRange::getCharRange(RefReplacement.Range.getBegin(),
+                                            RefReplacement.Range.getEnd()));
+          CXFileLocation Begin, End;
+          clang_getFileLocation(clang_getRangeStart(Range), nullptr,
+                                &Begin.Line, &Begin.Column, nullptr);
+          clang_getFileLocation(clang_getRangeEnd(Range), nullptr, &End.Line,
+                                &End.Column, nullptr);
+
+          if (I && FileReplacements[I - NumRemoved - 1].Range.End == Begin) {
+            // Merge the previous and the current replacement.
+            FileReplacements[I - NumRemoved - 1].Range.End = End;
+            std::string Replacement =
+                std::string(clang_getCString(
+                    FileReplacements[I - NumRemoved - 1].ReplacementString)) +
+                RefReplacement.ReplacementString;
+            clang_disposeString(
+                FileReplacements[I - NumRemoved - 1].ReplacementString);
+            FileReplacements[I - NumRemoved - 1].ReplacementString =
+                cxstring::createDup(Replacement);
+            NumRemoved++;
+            continue;
+          }
+
+          CXRefactoringReplacement &Replacement =
+              FileReplacements[I - NumRemoved];
+          Replacement.ReplacementString =
+              cxstring::createDup(RefReplacement.ReplacementString);
+          Replacement.Range.Begin = Begin;
+          Replacement.Range.End = End;
+          unsigned NumAssociatedSymbols = RefReplacement.SymbolLocations.size();
+          if (!NumAssociatedSymbols) {
+            Replacement.AssociatedData = nullptr;
+            continue;
+          }
+          AssociatedReplacementInfo *AssociatedData =
+              Allocator.Allocate<AssociatedReplacementInfo>();
+          Replacement.AssociatedData = AssociatedData;
+          AssociatedData->AssociatedSymbolOccurrences =
+              Allocator.Allocate<CXSymbolOccurrence>(NumAssociatedSymbols);
+          AssociatedData->NumAssociatedSymbolOccurrences = NumAssociatedSymbols;
+          unsigned SymbolIndex = 0;
+          for (const auto &AssociatedSymbol : RefReplacement.SymbolLocations) {
+            unsigned Index = AssociatedSymbolToIndex[AssociatedSymbol.first];
+            const RefactoringReplacement::AssociatedSymbolLocation &Loc =
+                AssociatedSymbol.second;
+            CXFileRange *NamePieces =
+                Allocator.Allocate<CXFileRange>(Loc.Offsets.size());
+            assert(AssociatedSymbol.first->getName().size() ==
+                       Loc.Offsets.size() &&
+                   "mismatching symbol name and offsets");
+            for (const auto &Offset : llvm::enumerate(Loc.Offsets)) {
+              StringRef NamePiece =
+                  AssociatedSymbol.first->getName()[Offset.index()];
+              NamePieces[Offset.index()] = translateOffsetToRelativeRange(
+                  Offset.value(), NamePiece.size(),
+                  RefReplacement.ReplacementString);
+            }
+            AssociatedData->AssociatedSymbolOccurrences[SymbolIndex] =
+                CXSymbolOccurrence{
+                    NamePieces, (unsigned)Loc.Offsets.size(),
+                    Loc.IsDeclaration
+                        ? CXSymbolOccurrence_ExtractedDeclaration
+                        : CXSymbolOccurrence_ExtractedDeclaration_Reference,
+                    /*IsMacroExpansion=*/0, Index};
+            ++SymbolIndex;
+          }
+        }
+        FileSet.NumReplacements -= NumRemoved;
+      }
+    }
+  }
+};
+
+class RefactoringContinuationWrapper {
+public:
+  std::unique_ptr<RefactoringContinuation> Continuation;
+  struct QueryWrapper {
+    indexer::IndexerQuery *Query;
+    CXTranslationUnit TU;
+    std::vector<indexer::Indexed<PersistentDeclRef<Decl>>> DeclResults;
+    unsigned ConsumedResults = 0;
+
+    QueryWrapper(indexer::IndexerQuery *Query, CXTranslationUnit TU)
+        : Query(Query), TU(TU) {}
+  };
+  SmallVector<QueryWrapper, 4> Queries;
+  bool IsInitiationTUAbandoned = false;
+
+  RefactoringContinuationWrapper(
+      std::unique_ptr<RefactoringContinuation> Continuation,
+      CXTranslationUnit TU)
+      : Continuation(std::move(Continuation)) {
+    Queries.emplace_back(this->Continuation->getASTUnitIndexerQuery(), TU);
+    assert(Queries.back().Query && "Invalid ast query");
+    std::vector<indexer::IndexerQuery *> AdditionalQueries =
+        this->Continuation->getAdditionalIndexerQueries();
+    for (indexer::IndexerQuery *IQ : AdditionalQueries)
+      Queries.emplace_back(IQ, TU);
+  }
+};
+
+class RefactoringDiagnosticConsumer : public DiagnosticConsumer {
+  const ASTContext &Context;
+  DiagnosticConsumer *PreviousClient;
+  std::unique_ptr<DiagnosticConsumer> PreviousClientPtr;
+  llvm::SmallVector<StoredDiagnostic, 2> RenameDiagnostics;
+  llvm::SmallVector<StoredDiagnostic, 1> ContinuationDiagnostics;
+
+public:
+  RefactoringDiagnosticConsumer(ASTContext &Context) : Context(Context) {
+    PreviousClient = Context.getDiagnostics().getClient();
+    PreviousClientPtr = Context.getDiagnostics().takeClient();
+    Context.getDiagnostics().setClient(this, /*ShouldOwnClient=*/false);
+  }
+
+  ~RefactoringDiagnosticConsumer() {
+    if (PreviousClientPtr)
+      Context.getDiagnostics().setClient(PreviousClientPtr.release());
+    else
+      Context.getDiagnostics().setClient(PreviousClient,
+                                         /*ShouldOwnClient=*/false);
+  }
+
+  void HandleDiagnostic(DiagnosticsEngine::Level Level,
+                        const Diagnostic &Info) override {
+    unsigned Cat = DiagnosticIDs::getCategoryNumberForDiag(Info.getID());
+    if (Cat == diag::DiagCat_Rename_Issue)
+      RenameDiagnostics.push_back(StoredDiagnostic(Level, Info));
+    else if (Cat == diag::DiagCat_Refactoring_Continuation_Issue)
+      ContinuationDiagnostics.push_back(StoredDiagnostic(Level, Info));
+    else
+      assert(false && "Unhandled refactoring category");
+  }
+
+  CXDiagnosticSetImpl *createDiags() const {
+    if (RenameDiagnostics.empty() && ContinuationDiagnostics.empty())
+      return nullptr;
+    llvm::SmallVector<StoredDiagnostic, 2> AllDiagnostics;
+    for (const auto &D : RenameDiagnostics)
+      AllDiagnostics.push_back(D);
+    for (const auto &D : ContinuationDiagnostics)
+      AllDiagnostics.push_back(D);
+    return cxdiag::createStoredDiags(AllDiagnostics, Context.getLangOpts());
+  }
+
+  CXRefactoringActionSetWithDiagnostics createActionSet() const {
+    if (RenameDiagnostics.empty())
+      return {nullptr, 0};
+    CXRefactoringActionWithDiagnostics *Actions =
+        new CXRefactoringActionWithDiagnostics[1];
+    Actions[0].Action = CXRefactor_Rename;
+    Actions[0].Diagnostics =
+        cxdiag::createStoredDiags(RenameDiagnostics, Context.getLangOpts());
+    return {Actions, 1};
+  }
+};
+
+} // end anonymous namespace
+
+template <typename T>
+static T withRenamingAction(CXRefactoringAction Action, T DefaultValue,
+                            llvm::function_ref<T(RenamingAction &)> Callback) {
+  if (!Action)
+    return DefaultValue;
+  RenamingAction *Rename =
+      static_cast<RefactoringAction *>(Action)->getRenamingAction();
+  if (!Rename)
+    return DefaultValue;
+  return Callback(*Rename);
+}
+
+static enum CXIndexerQueryKind
+translateDeclPredicate(const indexer::DeclPredicate &Predicate) {
+  indexer::DeclEntity Entity;
+  if (Predicate == Entity.isDefined().Predicate)
+    return CXIndexerQuery_Decl_IsDefined;
+  return CXIndexerQuery_Unknown;
+}
+
+extern "C" {
+
+CXString
+clang_RefactoringActionType_getName(enum CXRefactoringActionType Action) {
+  return cxstring::createRef(
+      getRefactoringActionTypeName(translateRefactoringActionType(Action)));
+}
+
+void clang_RefactoringActionSet_dispose(CXRefactoringActionSet *Set) {
+  if (Set && Set->Actions)
+    delete[] Set->Actions;
+}
+
+void clang_RefactoringActionSetWithDiagnostics_dispose(
+    CXRefactoringActionSetWithDiagnostics *Set) {
+  if (Set && Set->Actions) {
+    for (auto &S : llvm::makeArrayRef(Set->Actions, Set->NumActions))
+      clang_disposeDiagnosticSet(S.Diagnostics);
+    delete[] Set->Actions;
+  }
+}
+
+CXRefactoringOptionSet clang_RefactoringOptionSet_create() {
+  return new RefactoringOptionSet;
+}
+
+CXRefactoringOptionSet
+clang_RefactoringOptionSet_createFromString(const char *String) {
+  RefactoringOptionSet *Result = new RefactoringOptionSet;
+  auto Options = RefactoringOptionSet::parse(String);
+  if (Options) {
+    *Result = std::move(*Options);
+    return Result;
+  }
+  llvm::handleAllErrors(Options.takeError(),
+                        [](const llvm::StringError &Error) {});
+  return clang_RefactoringOptionSet_create();
+}
+
+void clang_RefactoringOptionSet_add(CXRefactoringOptionSet Set,
+                                    enum CXRefactoringOption Option) {
+  if (!Set)
+    return;
+  switch (Option) {
+  case CXRefactorOption_AvoidTextualMatches:
+    static_cast<RefactoringOptionSet *>(Set)->add(
+        option::AvoidTextualMatches::getTrue());
+    break;
+  }
+}
+
+CXString clang_RefactoringOptionSet_toString(CXRefactoringOptionSet Set) {
+  if (!Set)
+    return cxstring::createNull();
+  std::string Result;
+  llvm::raw_string_ostream OS(Result);
+  static_cast<RefactoringOptionSet *>(Set)->print(OS);
+  return cxstring::createDup(OS.str());
+}
+
+void clang_RefactoringOptionSet_dispose(CXRefactoringOptionSet Set) {
+  if (Set)
+    delete static_cast<RefactoringOptionSet *>(Set);
+}
+
+enum CXErrorCode
+clang_Refactoring_findActionsAt(CXTranslationUnit TU, CXSourceLocation Location,
+                                CXSourceRange SelectionRange,
+                                CXRefactoringOptionSet Options,
+                                CXRefactoringActionSet *OutSet) {
+  return clang_Refactoring_findActionsWithInitiationFailureDiagnosicsAt(
+      TU, Location, SelectionRange, Options, OutSet, /*OutFailureSet=*/nullptr);
+}
+
+enum CXErrorCode clang_Refactoring_findActionsWithInitiationFailureDiagnosicsAt(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, CXRefactoringOptionSet Options,
+    CXRefactoringActionSet *OutSet,
+    CXRefactoringActionSetWithDiagnostics *OutFailureSet) {
+  LOG_FUNC_SECTION { *Log << TU << ' '; }
+  if (OutFailureSet) {
+    OutFailureSet->Actions = nullptr;
+    OutFailureSet->NumActions = 0;
+  }
+
+  if (!OutSet)
+    return CXError_InvalidArguments;
+
+  OutSet->Actions = nullptr;
+  OutSet->NumActions = 0;
+
+  if (cxtu::isNotUsableTU(TU)) {
+    LOG_BAD_TU(TU);
+    return CXError_InvalidArguments;
+  }
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);
+  if (!CXXUnit)
+    return CXError_InvalidArguments;
+
+  SourceLocation Loc = cxloc::translateSourceLocation(Location);
+  if (Loc.isInvalid())
+    return CXError_InvalidArguments;
+
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+  (void)Options; // FIXME: handle options
+  ASTContext &Context = CXXUnit->getASTContext();
+  RefactoringDiagnosticConsumer DiagConsumer(Context);
+  RefactoringActionSet ActionSet = findActionSetAt(
+      Loc, cxloc::translateCXSourceRange(SelectionRange), Context);
+  if (OutFailureSet)
+    *OutFailureSet = DiagConsumer.createActionSet();
+  if (ActionSet.Actions.empty())
+    return CXError_RefactoringActionUnavailable;
+
+  CXRefactoringActionType *Actions =
+      new CXRefactoringActionType[ActionSet.Actions.size()];
+  OutSet->Actions = Actions;
+  OutSet->NumActions = ActionSet.Actions.size();
+  for (const auto &Action : llvm::enumerate(ActionSet.Actions))
+    Actions[Action.index()] = translateRefactoringActionType(Action.value());
+  return CXError_Success;
+}
+
+void clang_RefactoringAction_dispose(CXRefactoringAction Action) {
+  if (Action)
+    delete static_cast<RefactoringAction *>(Action);
+}
+
+CXSourceRange
+clang_RefactoringAction_getSourceRangeOfInterest(CXRefactoringAction Action) {
+  if (Action) {
+    RefactoringOperation *Operation =
+        static_cast<RefactoringAction *>(Action)->getOperation();
+    if (Operation) {
+      ASTUnit *CXXUnit = cxtu::getASTUnit(
+          static_cast<RefactoringAction *>(Action)->InitiationTU);
+      if (const Stmt *S = Operation->getTransformedStmt()) {
+        SourceRange Range = S->getSourceRange();
+        if (const Stmt *Last = Operation->getLastTransformedStmt())
+          Range.setEnd(Last->getLocEnd());
+        return cxloc::translateSourceRange(CXXUnit->getASTContext(), Range);
+      } else if (const Decl *D = Operation->getTransformedDecl()) {
+        SourceRange Range = D->getSourceRange();
+        if (const Decl *Last = Operation->getLastTransformedDecl())
+          Range.setEnd(Last->getLocEnd());
+        return cxloc::translateSourceRange(CXXUnit->getASTContext(), Range);
+      }
+    }
+  }
+  return clang_getNullRange();
+}
+
+int clang_RefactoringAction_requiresImplementationTU(
+    CXRefactoringAction Action) {
+  return withRenamingAction<int>(Action, 0, [](RenamingAction &Action) {
+    return Action.Operation.requiresImplementationTU();
+  });
+}
+
+CXString clang_RefactoringAction_getUSRThatRequiresImplementationTU(
+    CXRefactoringAction Action) {
+  return withRenamingAction<CXString>(
+      Action, cxstring::createNull(), [](RenamingAction &Action) {
+        return Action.getUSRThatRequiresImplementationTU();
+      });
+}
+
+enum CXErrorCode
+clang_RefactoringAction_addImplementationTU(CXRefactoringAction Action,
+                                            CXTranslationUnit TU) {
+  if (!Action || !TU)
+    return CXError_InvalidArguments;
+  // Prohibit multiple additions of implementation TU.
+  if (static_cast<RefactoringAction *>(Action)->ImplementationTU)
+    return CXError_Failure;
+  static_cast<RefactoringAction *>(Action)->ImplementationTU = TU;
+  return CXError_Success;
+}
+
+enum CXErrorCode clang_RefactoringAction_getRefactoringCandidates(
+    CXRefactoringAction Action,
+    CXRefactoringCandidateSet *OutRefactoringCandidateSet) {
+  if (!Action || !OutRefactoringCandidateSet)
+    return CXError_InvalidArguments;
+  *OutRefactoringCandidateSet =
+      static_cast<RefactoringAction *>(Action)->getRefactoringCandidates();
+  return CXError_Success;
+}
+
+enum CXErrorCode
+clang_RefactoringAction_selectRefactoringCandidate(CXRefactoringAction Action,
+                                                   unsigned Index) {
+  if (!Action)
+    return CXError_InvalidArguments;
+  return static_cast<RefactoringAction *>(Action)->selectCandidate(Index);
+}
+
+// TODO: Remove.
+enum CXErrorCode clang_Refactoring_initiateActionAt(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, enum CXRefactoringActionType ActionType,
+    CXRefactoringOptionSet Options, CXRefactoringAction *OutAction,
+    CXString *OutFailureReason) {
+  CXDiagnosticSet Diags;
+  CXErrorCode Result = clang_Refactoring_initiateAction(
+      TU, Location, SelectionRange, ActionType, Options, OutAction, &Diags);
+  if (OutFailureReason && Diags && clang_getNumDiagnosticsInSet(Diags) == 1) {
+    CXString Spelling =
+        clang_getDiagnosticSpelling(clang_getDiagnosticInSet(Diags, 0));
+    *OutFailureReason = cxstring::createDup(clang_getCString(Spelling));
+    clang_disposeString(Spelling);
+  } else if (OutFailureReason)
+    *OutFailureReason = cxstring::createEmpty();
+  clang_disposeDiagnosticSet(Diags);
+  return Result;
+}
+
+enum CXErrorCode clang_Refactoring_initiateAction(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, enum CXRefactoringActionType ActionType,
+    CXRefactoringOptionSet Options, CXRefactoringAction *OutAction,
+    CXDiagnosticSet *OutDiagnostics) {
+  if (!OutAction)
+    return CXError_InvalidArguments;
+  *OutAction = nullptr;
+  if (OutDiagnostics)
+    *OutDiagnostics = nullptr;
+
+  if (cxtu::isNotUsableTU(TU)) {
+    LOG_BAD_TU(TU);
+    return CXError_InvalidArguments;
+  }
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);
+  if (!CXXUnit)
+    return CXError_InvalidArguments;
+
+  SourceLocation Loc = cxloc::translateSourceLocation(Location);
+  if (Loc.isInvalid())
+    return CXError_InvalidArguments;
+
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+
+  (void)Options; // FIXME: handle options
+  ASTContext &Context = CXXUnit->getASTContext();
+  RefactoringDiagnosticConsumer DiagConsumer(Context);
+  auto Operation = initiateRefactoringOperationAt(
+      Loc, cxloc::translateCXSourceRange(SelectionRange), Context,
+      translateRefactoringActionType(ActionType));
+  if (!Operation.Initiated) {
+    if (OutDiagnostics) {
+      if (!Operation.FailureReason.empty()) {
+        // TODO: Remove when other actions migrate to diagnostics.
+        StoredDiagnostic Diag(DiagnosticsEngine::Error, /*ID=*/0,
+                              Operation.FailureReason);
+        *OutDiagnostics =
+            cxdiag::createStoredDiags(Diag, Context.getLangOpts());
+      } else
+        *OutDiagnostics = DiagConsumer.createDiags();
+    }
+    return CXError_RefactoringActionUnavailable;
+  }
+  if (Operation.RefactoringOp)
+    *OutAction = new RefactoringAction(std::move(Operation.RefactoringOp),
+                                       ActionType, TU);
+  else
+    *OutAction = new RefactoringAction(
+        llvm::make_unique<RenamingAction>(CXXUnit->getLangOpts(),
+                                          std::move(*Operation.SymbolOp)),
+        TU);
+  return CXError_Success;
+}
+
+enum CXErrorCode clang_Refactoring_initiateActionOnDecl(
+    CXTranslationUnit TU, const char *DeclUSR,
+    enum CXRefactoringActionType ActionType, CXRefactoringOptionSet Options,
+    CXRefactoringAction *OutAction, CXString *OutFailureReason) {
+  if (!OutAction)
+    return CXError_InvalidArguments;
+  *OutAction = nullptr;
+  if (OutFailureReason)
+    *OutFailureReason = cxstring::createNull();
+
+  if (cxtu::isNotUsableTU(TU)) {
+    LOG_BAD_TU(TU);
+    return CXError_InvalidArguments;
+  }
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);
+  if (!CXXUnit)
+    return CXError_InvalidArguments;
+
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+
+  (void)Options; // FIXME: handle options
+  auto Operation = initiateRefactoringOperationOnDecl(
+      DeclUSR, CXXUnit->getASTContext(),
+      translateRefactoringActionType(ActionType));
+  if (!Operation.Initiated)
+    return CXError_RefactoringActionUnavailable;
+  // FIXME: Don't dupe with above
+  if (Operation.RefactoringOp)
+    *OutAction = new RefactoringAction(std::move(Operation.RefactoringOp),
+                                       ActionType, TU);
+  else
+    *OutAction = new RefactoringAction(
+        llvm::make_unique<RenamingAction>(CXXUnit->getLangOpts(),
+                                          std::move(*Operation.SymbolOp)),
+        TU);
+  return CXError_Success;
+}
+
+enum CXErrorCode
+clang_Refactoring_initiateRenamingOperation(CXRefactoringAction Action) {
+  if (!Action)
+    return CXError_InvalidArguments;
+  RefactoringAction *RefAction = static_cast<RefactoringAction *>(Action);
+  RenamingAction *Rename = RefAction->getRenamingAction();
+  if (!Rename)
+    return CXError_InvalidArguments;
+  // TODO
+  return CXError_Success;
+}
+
+CINDEX_LINKAGE
+enum CXErrorCode clang_Refactoring_findRenamedCursor(
+    CXTranslationUnit TU, CXSourceLocation Location,
+    CXSourceRange SelectionRange, CXCursor *OutCursor) {
+  if (!OutCursor)
+    return CXError_InvalidArguments;
+
+  if (cxtu::isNotUsableTU(TU)) {
+    LOG_BAD_TU(TU);
+    return CXError_InvalidArguments;
+  }
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);
+  if (!CXXUnit)
+    return CXError_InvalidArguments;
+  SourceLocation Loc = cxloc::translateSourceLocation(Location);
+  if (Loc.isInvalid())
+    return CXError_InvalidArguments;
+
+  const NamedDecl *ND = rename::getNamedDeclAt(CXXUnit->getASTContext(), Loc);
+  if (!ND) {
+    *OutCursor = cxcursor::MakeCXCursorInvalid(CXCursor_NoDeclFound, TU);
+    return CXError_RefactoringActionUnavailable;
+  }
+
+  *OutCursor = cxcursor::MakeCXCursor(ND, TU);
+  return CXError_Success;
+}
+
+enum CXErrorCode clang_RenamingOperation_setNewName(CXRefactoringAction Action,
+                                                    const char *NewName) {
+  return withRenamingAction<CXErrorCode>(
+      Action, CXError_InvalidArguments,
+      [=](RenamingAction &Action) -> CXErrorCode {
+        if (!NewName)
+          return CXError_InvalidArguments;
+        StringRef Name = NewName;
+        if (Name.empty())
+          return CXError_InvalidArguments;
+        return Action.setNewName(Name);
+      });
+}
+
+enum CXRefactoringActionType
+clang_RefactoringAction_getInitiatedActionType(CXRefactoringAction Action) {
+  return static_cast<RefactoringAction *>(Action)->Type;
+}
+
+unsigned clang_RenamingOperation_getNumSymbols(CXRefactoringAction Action) {
+  return withRenamingAction<unsigned>(Action, 0, [](RenamingAction &Action) {
+    return Action.Operation.symbols().size();
+  });
+}
+
+CXString clang_RenamingOperation_getUSRForSymbol(CXRefactoringAction Action,
+                                                 unsigned Index) {
+  return withRenamingAction<CXString>(
+      Action, cxstring::createNull(),
+      [=](RenamingAction &Action) { return Action.usrForSymbolAt(Index); });
+}
+
+CXRenamingResult clang_Refactoring_findRenamedOccurrencesInPrimaryTUs(
+    CXRefactoringAction Action, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles) {
+  if (!Action)
+    return nullptr;
+  RefactoringAction *RefAction = static_cast<RefactoringAction *>(Action);
+  RenamingAction *Rename = RefAction->getRenamingAction();
+  if (!Rename)
+    return nullptr;
+
+  // TODO: Handle implementation TU
+  if (cxtu::isNotUsableTU(RefAction->InitiationTU)) {
+    LOG_BAD_TU(RefAction->InitiationTU);
+    return nullptr;
+  }
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(RefAction->InitiationTU);
+  if (!CXXUnit)
+    return nullptr;
+
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+
+  return Rename->handlePrimaryTU(RefAction->InitiationTU, *CXXUnit);
+}
+
+CXSymbolOccurrencesResult clang_Refactoring_findSymbolOccurrencesInInitiationTU(
+    CXRefactoringAction Action, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles) {
+  if (!Action)
+    return nullptr;
+  RefactoringAction *RefAction = static_cast<RefactoringAction *>(Action);
+  RenamingAction *Rename = RefAction->getRenamingAction();
+  if (!Rename)
+    return nullptr;
+
+  if (cxtu::isNotUsableTU(RefAction->InitiationTU)) {
+    LOG_BAD_TU(RefAction->InitiationTU);
+    return nullptr;
+  }
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(RefAction->InitiationTU);
+  if (!CXXUnit)
+    return nullptr;
+
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+
+  return Rename->findSymbolsInInitiationTU(RefAction->InitiationTU, *CXXUnit);
+}
+
+CXErrorCode clang_Refactoring_findRenamedOccurrencesInIndexedFile(
+    const CXRenamedIndexedSymbol *Symbols, unsigned NumSymbols, CXIndex CIdx,
+    const char *Filename, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles, CXRefactoringOptionSet Options,
+    CXRenamingResult *OutResult) {
+  if (!OutResult)
+    return CXError_InvalidArguments;
+  if (!Symbols || !NumSymbols || !Filename)
+    return CXError_InvalidArguments;
+  return performIndexedFileRename(
+      llvm::makeArrayRef(Symbols, NumSymbols), StringRef(Filename),
+      llvm::makeArrayRef(CommandLineArgs, NumCommandLineArgs), CIdx,
+      MutableArrayRef<CXUnsavedFile>(UnsavedFiles, NumUnsavedFiles),
+      Options ? static_cast<RefactoringOptionSet *>(Options) : nullptr,
+      *OutResult);
+}
+
+CXErrorCode clang_Refactoring_findSymbolOccurrencesInIndexedFile(
+    const CXIndexedSymbol *Symbols, unsigned NumSymbols, CXIndex CIdx,
+    const char *Filename, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles, CXRefactoringOptionSet Options,
+    CXSymbolOccurrencesResult *OutResult) {
+  if (!OutResult)
+    return CXError_InvalidArguments;
+  if (!Symbols || !NumSymbols || !Filename)
+    return CXError_InvalidArguments;
+  return performIndexedSymbolSearch(
+      llvm::makeArrayRef(Symbols, NumSymbols), StringRef(Filename),
+      llvm::makeArrayRef(CommandLineArgs, NumCommandLineArgs), CIdx,
+      MutableArrayRef<CXUnsavedFile>(UnsavedFiles, NumUnsavedFiles),
+      Options ? static_cast<RefactoringOptionSet *>(Options) : nullptr,
+      *OutResult);
+}
+
+unsigned clang_RenamingResult_getNumModifiedFiles(CXRenamingResult Result) {
+  if (Result)
+    return static_cast<RenamingResult *>(Result)->getFilenames().size();
+  return 0;
+}
+
+void clang_RenamingResult_getResultForFile(CXRenamingResult Result,
+                                           unsigned FileIndex,
+                                           CXFileRenamingResult *OutResult) {
+  if (!Result ||
+      FileIndex >=
+          static_cast<RenamingResult *>(Result)->getFilenames().size()) {
+    OutResult->Filename = cxstring::createNull();
+    OutResult->NumOccurrences = 0;
+    OutResult->Occurrences = nullptr;
+    return;
+  }
+  auto &RenameResult = *static_cast<RenamingResult *>(Result);
+  OutResult->Filename = RenameResult.getFilenames()[FileIndex];
+  OutResult->NumOccurrences = RenameResult.getOccurrences(FileIndex).size();
+  OutResult->Occurrences = RenameResult.getOccurrences(FileIndex).data();
+}
+
+void clang_RenamingResult_dispose(CXRenamingResult Result) {
+  if (Result)
+    delete static_cast<RenamingResult *>(Result);
+}
+
+unsigned clang_SymbolOccurrences_getNumFiles(CXSymbolOccurrencesResult Result) {
+  if (Result)
+    return static_cast<SymbolOccurrencesResult *>(Result)
+        ->getFilenames()
+        .size();
+  return 0;
+}
+
+void clang_SymbolOccurrences_getOccurrencesForFile(
+    CXSymbolOccurrencesResult Result, unsigned FileIndex,
+    CXSymbolOccurrencesInFile *OutResult) {
+  if (!Result ||
+      FileIndex >= static_cast<SymbolOccurrencesResult *>(Result)
+                       ->getFilenames()
+                       .size()) {
+    OutResult->Filename = cxstring::createNull();
+    OutResult->NumOccurrences = 0;
+    OutResult->Occurrences = nullptr;
+    return;
+  }
+  auto &RenameResult = *static_cast<SymbolOccurrencesResult *>(Result);
+  OutResult->Filename = RenameResult.getFilenames()[FileIndex];
+  OutResult->NumOccurrences = RenameResult.getOccurrences(FileIndex).size();
+  OutResult->Occurrences = RenameResult.getOccurrences(FileIndex).data();
+}
+
+void clang_SymbolOccurrences_dispose(CXSymbolOccurrencesResult Result) {
+  if (Result)
+    delete static_cast<SymbolOccurrencesResult *>(Result);
+}
+
+CXRefactoringResult clang_Refactoring_performOperation(
+    CXRefactoringAction Action, const char *const *CommandLineArgs,
+    int NumCommandLineArgs, struct CXUnsavedFile *UnsavedFiles,
+    unsigned NumUnsavedFiles, CXRefactoringOptionSet Options,
+    CXString *OutFailureReason) {
+  if (OutFailureReason)
+    *OutFailureReason = cxstring::createNull();
+  if (!Action)
+    return nullptr;
+  RefactoringAction *RefAction = static_cast<RefactoringAction *>(Action);
+  if (!RefAction->getOperation())
+    return nullptr;
+
+  ASTUnit *CXXUnit = cxtu::getASTUnit(RefAction->InitiationTU);
+  if (!CXXUnit)
+    return nullptr;
+
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+
+  RefactoringOptionSet EmptyOptionSet;
+  const RefactoringOptionSet &OptionSet =
+      Options ? *static_cast<RefactoringOptionSet *>(Options) : EmptyOptionSet;
+  llvm::Expected<RefactoringResult> Result = RefAction->getOperation()->perform(
+      CXXUnit->getASTContext(), CXXUnit->getPreprocessor(), OptionSet,
+      RefAction->SelectedCandidate);
+  if (!Result) {
+    if (OutFailureReason) {
+      (void)!llvm::handleErrors(
+          Result.takeError(), [&](const RefactoringOperationError &Error) {
+            *OutFailureReason = cxstring::createDup(Error.FailureReason);
+          });
+    }
+    return nullptr;
+  }
+  return new RefactoringResultWrapper(
+      Result.get().Replacements, Result.get().AssociatedSymbols,
+      std::move(Result.get().Continuation), CXXUnit->getASTContext(),
+      RefAction->InitiationTU);
+}
+
+void clang_RefactoringResult_getReplacements(
+    CXRefactoringResult Result,
+    CXRefactoringReplacements_Old *OutReplacements) {
+  if (!OutReplacements)
+    return;
+  if (!Result) {
+    OutReplacements->FileReplacementSets = nullptr;
+    OutReplacements->NumFileReplacementSets = 0;
+    return;
+  }
+  *OutReplacements = static_cast<RefactoringResultWrapper *>(Result)->Replacements;
+}
+
+CXRefactoringReplacements
+clang_RefactoringResult_getSourceReplacements(CXRefactoringResult Result) {
+  if (!Result)
+    return CXRefactoringReplacements{nullptr, 0};
+  return static_cast<RefactoringResultWrapper *>(Result)->SourceReplacements;
+}
+
+CXRefactoringReplacementAssociatedSymbolOccurrences
+clang_RefactoringReplacement_getAssociatedSymbolOccurrences(
+    CXRefactoringReplacement Replacement) {
+  if (!Replacement.AssociatedData)
+    return CXRefactoringReplacementAssociatedSymbolOccurrences{nullptr, 0};
+  auto *Data =
+      static_cast<RefactoringResultWrapper::AssociatedReplacementInfo *>(
+          Replacement.AssociatedData);
+  return CXRefactoringReplacementAssociatedSymbolOccurrences{
+      Data->AssociatedSymbolOccurrences, Data->NumAssociatedSymbolOccurrences};
+}
+
+void clang_RefactoringResult_dispose(CXRefactoringResult Result) {
+  if (Result)
+    delete static_cast<RefactoringResultWrapper *>(Result);
+}
+
+CXRefactoringContinuation
+clang_RefactoringResult_getContinuation(CXRefactoringResult Result) {
+  if (!Result)
+    return nullptr;
+  auto *Wrapper = static_cast<RefactoringResultWrapper *>(Result);
+  if (!Wrapper->Continuation)
+    return nullptr;
+  return new RefactoringContinuationWrapper(std::move(Wrapper->Continuation),
+                                            Wrapper->TU);
+}
+
+enum CXErrorCode
+clang_RefactoringContinuation_loadSerializedIndexerQueryResults(
+    CXRefactoringContinuation Continuation, const char *Source) {
+  if (!Continuation)
+    return CXError_InvalidArguments;
+  auto *Wrapper = static_cast<RefactoringContinuationWrapper *>(Continuation);
+  llvm::SmallVector<indexer::IndexerQuery *, 4> Queries;
+  for (const auto &Query : Wrapper->Queries)
+    Queries.push_back(Query.Query);
+  auto Err = indexer::IndexerQuery::loadResultsFromYAML(Source, Queries);
+  if (Err) {
+    consumeError(std::move(Err));
+    return CXError_Failure;
+  }
+  return CXError_Success;
+}
+
+unsigned clang_RefactoringContinuation_getNumIndexerQueries(
+    CXRefactoringContinuation Continuation) {
+  if (Continuation)
+    return static_cast<RefactoringContinuationWrapper *>(Continuation)
+        ->Queries.size();
+  return 0;
+}
+
+CXIndexerQuery clang_RefactoringContinuation_getIndexerQuery(
+    CXRefactoringContinuation Continuation, unsigned Index) {
+  if (!Continuation)
+    return nullptr;
+  auto *Wrapper = static_cast<RefactoringContinuationWrapper *>(Continuation);
+  if (Index >= Wrapper->Queries.size())
+    return nullptr;
+  return &Wrapper->Queries[Index];
+}
+
+CXDiagnosticSet clang_RefactoringContinuation_verifyBeforeFinalizing(
+    CXRefactoringContinuation Continuation) {
+  if (!Continuation)
+    return nullptr;
+  auto *Wrapper = static_cast<RefactoringContinuationWrapper *>(Continuation);
+  CXTranslationUnit TU = Wrapper->Queries[0].TU;
+  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);
+  if (!CXXUnit)
+    return nullptr;
+  ASTContext &Context = CXXUnit->getASTContext();
+  RefactoringDiagnosticConsumer DiagConsumer(Context);
+  for (const auto &Query : Wrapper->Queries) {
+    if (Query.Query->verify(Context))
+      break;
+  }
+  return DiagConsumer.createDiags();
+}
+
+void clang_RefactoringContinuation_finalizeEvaluationInInitationTU(
+    CXRefactoringContinuation Continuation) {
+  if (!Continuation)
+    return;
+  auto *Wrapper = static_cast<RefactoringContinuationWrapper *>(Continuation);
+  Wrapper->Queries.clear();
+  Wrapper->Continuation->persistTUSpecificState();
+  Wrapper->IsInitiationTUAbandoned = true;
+}
+
+CXRefactoringResult clang_RefactoringContinuation_continueOperationInTU(
+    CXRefactoringContinuation Continuation, CXTranslationUnit TU,
+    CXString *OutFailureReason) {
+  if (!Continuation || !TU)
+    return nullptr;
+  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);
+  if (!CXXUnit)
+    return nullptr;
+  ASTUnit::ConcurrencyCheck Check(*CXXUnit);
+  const auto *Wrapper =
+      static_cast<RefactoringContinuationWrapper *>(Continuation);
+  if (!Wrapper->IsInitiationTUAbandoned) {
+    // FIXME: We can avoid conversions of TU-specific state if the given TU is
+    // the same as the initiation TU.
+    clang_RefactoringContinuation_finalizeEvaluationInInitationTU(Continuation);
+  }
+  auto Result =
+      Wrapper->Continuation->runInExternalASTUnit(CXXUnit->getASTContext());
+  if (!Result) {
+    if (OutFailureReason) {
+      (void)!llvm::handleErrors(
+          Result.takeError(), [&](const RefactoringOperationError &Error) {
+            *OutFailureReason = cxstring::createDup(Error.FailureReason);
+          });
+    }
+    return nullptr;
+  }
+  return new RefactoringResultWrapper(
+      Result.get().Replacements, Result.get().AssociatedSymbols,
+      std::move(Result.get().Continuation), CXXUnit->getASTContext(), TU);
+}
+
+void clang_RefactoringContinuation_dispose(
+    CXRefactoringContinuation Continuation) {
+  if (Continuation)
+    delete static_cast<RefactoringContinuationWrapper *>(Continuation);
+}
+
+enum CXIndexerQueryKind clang_IndexerQuery_getKind(CXIndexerQuery Query) {
+  if (!Query)
+    return CXIndexerQuery_Unknown;
+  const auto *IQ =
+      static_cast<RefactoringContinuationWrapper::QueryWrapper *>(Query)->Query;
+  if (const auto *DQ = dyn_cast<indexer::DeclarationsQuery>(IQ)) {
+    const indexer::detail::DeclPredicateNode &Node = DQ->getPredicateNode();
+    if (const auto *NP =
+            dyn_cast<indexer::detail::DeclPredicateNotPredicate>(&Node))
+      return translateDeclPredicate(
+          cast<indexer::detail::DeclPredicateNodePredicate>(NP->getChild())
+              .getPredicate());
+    return translateDeclPredicate(
+        cast<indexer::detail::DeclPredicateNodePredicate>(Node).getPredicate());
+  } else if (isa<indexer::ASTUnitForImplementationOfDeclarationQuery>(IQ))
+    return CXIndexerQuery_Decl_FileThatShouldImplement;
+  return CXIndexerQuery_Unknown;
+}
+
+unsigned clang_IndexerQuery_getNumCursors(CXIndexerQuery Query) {
+  if (!Query)
+    return 0;
+  const auto *IQ =
+      static_cast<RefactoringContinuationWrapper::QueryWrapper *>(Query)->Query;
+  if (const auto *DQ = dyn_cast<indexer::DeclarationsQuery>(IQ))
+    return DQ->getInputs().size();
+  else if (isa<indexer::ASTUnitForImplementationOfDeclarationQuery>(IQ))
+    return 1;
+  return 0;
+}
+
+CXCursor clang_IndexerQuery_getCursor(CXIndexerQuery Query,
+                                      unsigned CursorIndex) {
+  if (Query) {
+    const auto *Wrapper =
+        static_cast<RefactoringContinuationWrapper::QueryWrapper *>(Query);
+    const indexer::IndexerQuery *IQ = Wrapper->Query;
+    CXTranslationUnit TU = Wrapper->TU;
+    if (const auto *DQ = dyn_cast<indexer::DeclarationsQuery>(IQ)) {
+      if (CursorIndex < DQ->getInputs().size())
+        return cxcursor::MakeCXCursor(DQ->getInputs()[CursorIndex], TU);
+    } else if (const auto *ASTQuery = dyn_cast<
+                   indexer::ASTUnitForImplementationOfDeclarationQuery>(IQ)) {
+      if (CursorIndex == 0)
+        return cxcursor::MakeCXCursor(ASTQuery->getDecl(), TU);
+    }
+  }
+  return cxcursor::MakeCXCursorInvalid(CXCursor_InvalidCode);
+}
+
+enum CXIndexerQueryAction
+clang_IndexerQuery_consumeIntResult(CXIndexerQuery Query, unsigned CursorIndex,
+                                    int Value) {
+  if (!Query)
+    return CXIndexerQueryAction_None;
+  auto *Wrapper =
+      static_cast<RefactoringContinuationWrapper::QueryWrapper *>(Query);
+  auto *DQ = dyn_cast<indexer::DeclarationsQuery>(Wrapper->Query);
+  if (!DQ)
+    return CXIndexerQueryAction_None;
+  if (CursorIndex >= DQ->getInputs().size() ||
+      Wrapper->ConsumedResults == DQ->getInputs().size())
+    return CXIndexerQueryAction_None;
+  if (Wrapper->DeclResults.empty())
+    Wrapper->DeclResults.resize(DQ->getInputs().size(),
+                                indexer::Indexed<PersistentDeclRef<Decl>>(
+                                    PersistentDeclRef<Decl>::create(nullptr)));
+  // Filter the declarations!
+  bool IsNot = false;
+  if (isa<indexer::detail::DeclPredicateNotPredicate>(DQ->getPredicateNode()))
+    IsNot = true;
+  bool Result = IsNot ? !Value : !!Value;
+  Wrapper->DeclResults[CursorIndex] = indexer::Indexed<PersistentDeclRef<Decl>>(
+      PersistentDeclRef<Decl>::create(Result ? DQ->getInputs()[CursorIndex]
+                                             : nullptr),
+      Result ? indexer::QueryBoolResult::Yes : indexer::QueryBoolResult::No);
+  Wrapper->ConsumedResults++;
+  if (Wrapper->ConsumedResults == Wrapper->DeclResults.size()) {
+    // We've received all the results, pass them back to the query.
+    DQ->setOutput(std::move(Wrapper->DeclResults));
+  }
+  return CXIndexerQueryAction_None;
+}
+
+enum CXIndexerQueryAction
+clang_IndexerQuery_consumeFileResult(CXIndexerQuery Query, unsigned CursorIndex,
+                                     const char *Filename) {
+  if (!Query || !Filename)
+    return CXIndexerQueryAction_None;
+  auto *IQ =
+      static_cast<RefactoringContinuationWrapper::QueryWrapper *>(Query)->Query;
+  if (auto *ASTQuery =
+          dyn_cast<indexer::ASTUnitForImplementationOfDeclarationQuery>(IQ)) {
+    if (CursorIndex != 0)
+      return CXIndexerQueryAction_None;
+    ASTQuery->setResult(PersistentFileID(Filename));
+    return CXIndexerQueryAction_RunContinuationInTUThatHasThisFile;
+  }
+  return CXIndexerQueryAction_None;
+}
+}
diff --git a/tools/libclang/CXIndexDataConsumer.cpp b/tools/libclang/CXIndexDataConsumer.cpp
index 89ac23be73..2c0b64d846 100644
--- a/tools/libclang/CXIndexDataConsumer.cpp
+++ b/tools/libclang/CXIndexDataConsumer.cpp
@@ -1259,6 +1259,7 @@ static CXIdxEntityKind getEntityKindFromSymbolKind(SymbolKind K, SymbolLanguage
   case SymbolKind::Macro:
   case SymbolKind::ClassProperty:
   case SymbolKind::Using:
+  case SymbolKind::CommentTag:
     return CXIdxEntity_Unexposed;
 
   case SymbolKind::Enum: return CXIdxEntity_Enum;
diff --git a/tools/libclang/libclang.exports b/tools/libclang/libclang.exports
index bf95b97073..edc6393675 100644
--- a/tools/libclang/libclang.exports
+++ b/tools/libclang/libclang.exports
@@ -358,3 +358,57 @@ clang_EvalResult_isUnsignedInt
 clang_EvalResult_getAsDouble
 clang_EvalResult_getAsStr
 clang_EvalResult_dispose
+clang_RefactoringActionType_getName
+clang_RefactoringActionSet_dispose
+clang_RefactoringActionSetWithDiagnostics_dispose
+clang_RefactoringOptionSet_create
+clang_RefactoringOptionSet_createFromString
+clang_RefactoringOptionSet_add
+clang_RefactoringOptionSet_toString
+clang_RefactoringOptionSet_dispose
+clang_Refactoring_findActionsAt
+clang_Refactoring_findActionsWithInitiationFailureDiagnosicsAt
+clang_RefactoringAction_dispose
+clang_RefactoringAction_getSourceRangeOfInterest
+clang_RefactoringAction_getInitiatedActionType
+clang_RefactoringAction_requiresImplementationTU
+clang_RefactoringAction_getUSRThatRequiresImplementationTU
+clang_RefactoringAction_addImplementationTU
+clang_RefactoringAction_getRefactoringCandidates
+clang_RefactoringAction_selectRefactoringCandidate
+clang_Refactoring_initiateActionAt
+clang_Refactoring_initiateAction
+clang_Refactoring_initiateActionOnDecl
+clang_Refactoring_initiateRenamingOperation
+clang_RenamingOperation_setNewName
+clang_RenamingOperation_getNumSymbols
+clang_RenamingOperation_getUSRForSymbol
+clang_Refactoring_findRenamedCursor
+clang_Refactoring_findRenamedOccurrencesInPrimaryTUs
+clang_Refactoring_findSymbolOccurrencesInInitiationTU
+clang_Refactoring_findRenamedOccurrencesInIndexedFile
+clang_Refactoring_findSymbolOccurrencesInIndexedFile
+clang_RenamingResult_getNumModifiedFiles
+clang_RenamingResult_getResultForFile
+clang_RenamingResult_dispose
+clang_SymbolOccurrences_getNumFiles
+clang_SymbolOccurrences_getOccurrencesForFile
+clang_SymbolOccurrences_dispose
+clang_Refactoring_performOperation
+clang_RefactoringResult_getReplacements
+clang_RefactoringResult_getSourceReplacements
+clang_RefactoringReplacement_getAssociatedSymbolOccurrences
+clang_RefactoringResult_getContinuation
+clang_RefactoringResult_dispose
+clang_RefactoringContinuation_loadSerializedIndexerQueryResults
+clang_RefactoringContinuation_getNumIndexerQueries
+clang_RefactoringContinuation_getIndexerQuery
+clang_RefactoringContinuation_verifyBeforeFinalizing
+clang_RefactoringContinuation_finalizeEvaluationInInitationTU
+clang_RefactoringContinuation_continueOperationInTU
+clang_RefactoringContinuation_dispose
+clang_IndexerQuery_getKind
+clang_IndexerQuery_getNumCursors
+clang_IndexerQuery_getCursor
+clang_IndexerQuery_consumeIntResult
+clang_IndexerQuery_consumeFileResult
diff --git a/unittests/AST/DeclTest.cpp b/unittests/AST/DeclTest.cpp
index 87aeef47c6..67b80acf46 100644
--- a/unittests/AST/DeclTest.cpp
+++ b/unittests/AST/DeclTest.cpp
@@ -11,6 +11,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "MatchVerifier.h"
 #include "clang/ASTMatchers/ASTMatchFinder.h"
 #include "clang/Tooling/Tooling.h"
 #include "gtest/gtest.h"
@@ -57,3 +58,53 @@ TEST(Decl, CleansUpAPValues) {
       "constexpr _Complex __uint128_t c = 0xffffffffffffffff;",
       Args));
 }
+
+TEST(Decl, Availability) {
+  const char *CodeStr = "int x __attribute__((availability(macosx, "
+        "introduced=10.2, deprecated=10.8, obsoleted=10.10)));";
+  auto Matcher = varDecl(hasName("x"));
+  std::vector<std::string> Args = {"-target", "x86_64-apple-macosx10.9"};
+
+  class AvailabilityVerifier : public MatchVerifier<clang::VarDecl> {
+  public:
+    void verify(const MatchFinder::MatchResult &Result,
+                const clang::VarDecl &Node) override {
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 1)) !=
+          clang::AR_NotYetIntroduced) {
+        setFailure("failed introduced");
+      }
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 2)) !=
+          clang::AR_Available) {
+        setFailure("failed available (exact)");
+      }
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 3)) !=
+          clang::AR_Available) {
+        setFailure("failed available");
+      }
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 8)) !=
+          clang::AR_Deprecated) {
+        setFailure("failed deprecated (exact)");
+      }
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 9)) !=
+          clang::AR_Deprecated) {
+        setFailure("failed deprecated");
+      }
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 10)) !=
+          clang::AR_Unavailable) {
+        setFailure("failed obsoleted (exact)");
+      }
+      if (Node.getAvailability(nullptr, clang::VersionTuple(10, 11)) !=
+          clang::AR_Unavailable) {
+        setFailure("failed obsoleted");
+      }
+
+      if (Node.getAvailability() != clang::AR_Deprecated)
+        setFailure("did not default to target OS version");
+
+      setSuccess();
+    }
+  };
+
+  AvailabilityVerifier Verifier;
+  EXPECT_TRUE(Verifier.match(CodeStr, Matcher, Args, Lang_C));
+}
diff --git a/unittests/Lex/CMakeLists.txt b/unittests/Lex/CMakeLists.txt
index ea6f9fd234..61d337a473 100644
--- a/unittests/Lex/CMakeLists.txt
+++ b/unittests/Lex/CMakeLists.txt
@@ -14,6 +14,7 @@ target_link_libraries(LexTests
   clangAST
   clangBasic
   clangLex
+  clangAPINotes
   clangParse
   clangSema
   )
diff --git a/unittests/Rename/CMakeLists.txt b/unittests/Rename/CMakeLists.txt
index b625a7a691..b1ed1fea2d 100644
--- a/unittests/Rename/CMakeLists.txt
+++ b/unittests/Rename/CMakeLists.txt
@@ -24,4 +24,5 @@ target_link_libraries(ClangRenameTests
   clangTooling
   clangToolingCore
   clangToolingRefactor
+  clangToolingRefactoring
   )
diff --git a/unittests/Tooling/CMakeLists.txt b/unittests/Tooling/CMakeLists.txt
index 557d1007ae..8135d884eb 100644
--- a/unittests/Tooling/CMakeLists.txt
+++ b/unittests/Tooling/CMakeLists.txt
@@ -46,4 +46,5 @@ target_link_libraries(ToolingTests
   clangTooling
   clangToolingCore
   clangToolingRefactor
+  clangToolingRefactoring
   )
diff --git a/unittests/Tooling/RefactoringTest.cpp b/unittests/Tooling/RefactoringTest.cpp
index 41836f11ee..4b76c8f410 100644
--- a/unittests/Tooling/RefactoringTest.cpp
+++ b/unittests/Tooling/RefactoringTest.cpp
@@ -25,6 +25,9 @@
 #include "clang/Frontend/FrontendAction.h"
 #include "clang/Frontend/TextDiagnosticPrinter.h"
 #include "clang/Rewrite/Core/Rewriter.h"
+#include "clang/Tooling/Refactor/IndexerQuery.h"
+#include "clang/Tooling/Refactor/RefactoringOperation.h"
+#include "clang/Tooling/Refactor/RefactoringOptions.h"
 #include "clang/Tooling/Refactoring.h"
 #include "clang/Tooling/Refactoring/AtomicChange.h"
 #include "clang/Tooling/Tooling.h"
@@ -1090,6 +1093,51 @@ TEST(DeduplicateByFileTest, NonExistingFilePath) {
   EXPECT_TRUE(FileToReplaces.empty());
 }
 
+namespace {
+struct TestRefactoringValueOption final : OldRefactoringOption {
+  int Value;
+  TestRefactoringValueOption(int Value) : Value(Value) {}
+
+  static constexpr const char *Name = "test value option";
+};
+} // end anonymous namespace
+
+TEST(RefactoringOptionSet, AddGet) {
+  RefactoringOptionSet Options;
+  const TestRefactoringValueOption Kind(21);
+  const TestRefactoringValueOption DefaultKind(42);
+
+  EXPECT_EQ(Options.get<TestRefactoringValueOption>(), nullptr);
+  EXPECT_EQ(Options.get(DefaultKind).Value, DefaultKind.Value);
+
+  Options.add(Kind);
+
+  auto *Ptr = Options.get<TestRefactoringValueOption>();
+  ASSERT_TRUE(Ptr);
+  EXPECT_EQ(Ptr->Value, Kind.Value);
+  EXPECT_EQ(Options.get(DefaultKind).Value, Kind.Value);
+}
+
+namespace {
+struct TestRefactoringOption final : OldRefactoringOption {
+  int &Counter;
+  TestRefactoringOption(int &Counter) : Counter(Counter) {}
+  ~TestRefactoringOption() { ++Counter; }
+
+  static constexpr const char *Name = "test option";
+};
+} // end anonymous namespace
+
+TEST(RefactoringOptionSet, OptionDestroyed) {
+  int Counter = 0;
+  {
+    RefactoringOptionSet Options;
+    Options.add(TestRefactoringOption(Counter));
+    Options.add(TestRefactoringOption(Counter));
+  }
+  EXPECT_EQ(Counter, 3);
+}
+
 class AtomicChangeTest : public ::testing::Test {
   protected:
     void SetUp() override {
@@ -1295,6 +1343,128 @@ TEST_F(AtomicChangeTest, InsertAfterWithInvalidLocation) {
       Replacement(Context.Sources, SourceLocation(), 0, "b")));
 }
 
+namespace {
+
+class RefactoringOperationTest {
+  RefactoringActionType Type;
+  unsigned Line, Column;
+  bool Success = true;
+  std::function<void(const RefactoringResult &Result)> ResultHandler;
+
+public:
+  RefactoringOperationTest(
+      RefactoringActionType Type, unsigned Line, unsigned Column,
+      std::function<void(const RefactoringResult &Result)> ResultHandler)
+      : Type(Type), Line(Line), Column(Column),
+        ResultHandler(std::move(ResultHandler)) {}
+
+  bool runOver(StringRef Code) {
+    return runToolOnCode(new TestAction(this), Code);
+  }
+
+  bool succeeded() const { return Success; }
+
+  void run() {
+    assert(PP && Context && "Invalid state");
+    SourceLocation Loc = Context->getSourceManager().translateLineCol(
+        Context->getSourceManager().getMainFileID(), Line, Column);
+    if (Loc.isInvalid()) {
+      Success = false;
+      return;
+    }
+    RefactoringOperationResult Op =
+        initiateRefactoringOperationAt(Loc, SourceRange(), *Context, Type);
+    if (!Op.Initiated) {
+      Success = false;
+      return;
+    }
+    RefactoringOptionSet Options;
+    llvm::Expected<RefactoringResult> Result =
+        Op.RefactoringOp->perform(*Context, *PP, Options);
+    if (!Result) {
+      (void)!llvm::handleErrors(
+          Result.takeError(),
+          [&](const RefactoringOperationError &Error) { Success = false; });
+      return;
+    }
+    ResultHandler(Result.get());
+  }
+
+protected:
+  clang::Preprocessor *PP;
+  clang::ASTContext *Context;
+
+private:
+  class TestConsumer : public clang::ASTConsumer {
+  public:
+    TestConsumer(RefactoringOperationTest *Test) : Test(Test) {}
+
+    void HandleTranslationUnit(clang::ASTContext &Context) override {
+      Test->run();
+    }
+
+  private:
+    RefactoringOperationTest *Test;
+  };
+
+  class TestAction : public clang::ASTFrontendAction {
+  public:
+    TestAction(RefactoringOperationTest *Test) : Test(Test) {}
+
+    std::unique_ptr<clang::ASTConsumer>
+    CreateASTConsumer(clang::CompilerInstance &Compiler,
+                      llvm::StringRef) override {
+      Test->PP = &Compiler.getPreprocessor();
+      Test->Context = &Compiler.getASTContext();
+      return llvm::make_unique<TestConsumer>(Test);
+    }
+
+  private:
+    RefactoringOperationTest *Test;
+  };
+};
+
+} // end anonymous namespace
+
+TEST(RefactoringContinuation, ContinuationAndQueriesExist) {
+  using namespace clang::tooling::indexer;
+  using namespace clang::tooling::indexer::detail;
+  RefactoringOperationTest Test(
+      RefactoringActionType::ImplementDeclaredMethods, 2, 1,
+      [](const RefactoringResult &Result) {
+        EXPECT_TRUE(Result.Replacements.empty());
+        ASSERT_NE(Result.Continuation, nullptr);
+        RefactoringContinuation &Continuation = *Result.Continuation;
+
+        ASTProducerQuery *ASTQuery = Continuation.getASTUnitIndexerQuery();
+        ASSERT_NE(ASTQuery, nullptr);
+        EXPECT_TRUE(isa<ASTProducerQuery>(ASTQuery));
+        EXPECT_TRUE(isa<ASTUnitForImplementationOfDeclarationQuery>(ASTQuery));
+        EXPECT_FALSE(isa<DeclarationsQuery>(ASTQuery));
+
+        auto AdditionalQueries = Continuation.getAdditionalIndexerQueries();
+        ASSERT_EQ(AdditionalQueries.size(), (size_t)1);
+        EXPECT_FALSE(isa<ASTProducerQuery>(AdditionalQueries[0]));
+        EXPECT_FALSE(isa<ASTUnitForImplementationOfDeclarationQuery>(
+            AdditionalQueries[0]));
+        ASSERT_TRUE(isa<DeclarationsQuery>(AdditionalQueries[0]));
+
+        const DeclPredicateNode &Predicate =
+            cast<DeclarationsQuery>(AdditionalQueries[0])->getPredicateNode();
+        ASSERT_TRUE(isa<DeclPredicateNotPredicate>(Predicate));
+        const DeclPredicateNode &SubPredicate =
+            cast<DeclPredicateNotPredicate>(Predicate).getChild();
+        ASSERT_TRUE(isa<DeclPredicateNodePredicate>(SubPredicate));
+        EXPECT_EQ(cast<DeclPredicateNodePredicate>(SubPredicate).getPredicate(),
+                  DeclEntity().isDefined().Predicate);
+
+        ASTQuery->invalidateTUSpecificState();
+        AdditionalQueries[0]->invalidateTUSpecificState();
+      });
+  Test.runOver("class Foo {\nvoid method();\n};\n");
+  EXPECT_TRUE(Test.succeeded());
+}
+
 class ApplyAtomicChangesTest : public ::testing::Test {
 protected:
   ApplyAtomicChangesTest() : FilePath("file.cc") {
diff --git a/unittests/libclang/LibclangTest.cpp b/unittests/libclang/LibclangTest.cpp
index f2a96d6be6..d5a9cbf122 100644
--- a/unittests/libclang/LibclangTest.cpp
+++ b/unittests/libclang/LibclangTest.cpp
@@ -8,6 +8,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "clang-c/Index.h"
+#include "clang-c/Refactor.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/FileSystem.h"
 #include "llvm/Support/Path.h"
@@ -572,3 +573,71 @@ TEST_F(LibclangReparseTest, clang_parseTranslationUnit2FullArgv) {
   EXPECT_EQ(0U, clang_getNumDiagnostics(ClangTU));
   DisplayDiagnostics();
 }
+
+TEST(libclang, RefactoringAction) {
+  std::string Name =
+      clang_getCString(clang_RefactoringActionType_getName(CXRefactor_Rename));
+  EXPECT_EQ(Name, "Rename");
+}
+
+TEST_F(LibclangParseTest, RefactoringFindRenamedCursor) {
+  std::string Filename = "test.cpp";
+  WriteFile(Filename, "int renamable = 0;\n");
+
+  ClangTU = clang_parseTranslationUnit(Index, Filename.c_str(), nullptr, 0,
+                                       nullptr, 0, TUFlags);
+  CXSourceLocation Loc = clang_getLocation(
+      ClangTU, clang_getFile(ClangTU, Filename.c_str()), 1, 5);
+  CXSourceRange Range = clang_getRange(Loc, Loc);
+  CXCursor Cursor;
+  EXPECT_EQ(CXError_Success,
+            clang_Refactoring_findRenamedCursor(ClangTU, Loc, Range, &Cursor));
+  EXPECT_EQ(Cursor.kind, CXCursor_VarDecl);
+}
+
+TEST_F(LibclangParseTest, RefactoringRenameIndexedUnsavedFiles) {
+  std::string Filename = "test.cpp";
+  std::string PartialSource = "class Test { };\n";
+  WriteFile(Filename, PartialSource);
+  std::string FullSource = PartialSource + "Test t;\n";
+
+  CXIndexedSymbolLocation IndexedLocations[2] = {
+      {{1, 7}, CXCursor_DeclRefExpr}, {{2, 1}, CXCursor_DeclRefExpr}};
+  CXIndexedSymbol Symbols[1] = {
+      {IndexedLocations, 2, CXCursor_DeclRefExpr, /*Name=*/"Test"}};
+
+  CXIndex Idx = clang_createIndex(0, 0);
+
+  auto test = [&](CXUnsavedFile *File = nullptr) -> CXSymbolOccurrencesInFile {
+    CXSymbolOccurrencesResult Result;
+    CXErrorCode Err = clang_Refactoring_findSymbolOccurrencesInIndexedFile(
+        Symbols, 1, Idx, Filename.c_str(), nullptr, 0, File, File ? 1 : 0,
+        /*Options=*/nullptr, &Result);
+    EXPECT_EQ(CXError_Success, Err);
+    unsigned NumFiles = clang_SymbolOccurrences_getNumFiles(Result);
+    EXPECT_EQ(NumFiles, 1u);
+    CXSymbolOccurrencesInFile Occurrences;
+    clang_SymbolOccurrences_getOccurrencesForFile(Result, 0, &Occurrences);
+    return Occurrences;
+  };
+  CXSymbolOccurrencesInFile FileOccurrences = test();
+  EXPECT_EQ(FileOccurrences.NumOccurrences, 1u);
+  EXPECT_EQ(clang_getCString(FileOccurrences.Filename), Filename);
+  EXPECT_EQ(FileOccurrences.Occurrences[0].NumNamePieces, 1u);
+  EXPECT_EQ(FileOccurrences.Occurrences[0].NamePieces[0].Begin.Line, 1u);
+  EXPECT_EQ(FileOccurrences.Occurrences[0].NamePieces[0].Begin.Column, 7u);
+
+  CXUnsavedFile UnsavedFile = {Filename.c_str(), FullSource.c_str(),
+                               FullSource.size()};
+  CXSymbolOccurrencesInFile UnsavedFileOccurrences = test(&UnsavedFile);
+  EXPECT_EQ(UnsavedFileOccurrences.NumOccurrences, 2u);
+  EXPECT_EQ(clang_getCString(UnsavedFileOccurrences.Filename), Filename);
+  EXPECT_EQ(UnsavedFileOccurrences.Occurrences[0].NumNamePieces, 1u);
+  EXPECT_EQ(UnsavedFileOccurrences.Occurrences[0].NamePieces[0].Begin.Line, 1u);
+  EXPECT_EQ(UnsavedFileOccurrences.Occurrences[0].NamePieces[0].Begin.Column,
+            7u);
+  EXPECT_EQ(UnsavedFileOccurrences.Occurrences[1].NumNamePieces, 1u);
+  EXPECT_EQ(UnsavedFileOccurrences.Occurrences[1].NamePieces[0].Begin.Line, 2u);
+  EXPECT_EQ(UnsavedFileOccurrences.Occurrences[1].NamePieces[0].Begin.Column,
+            1u);
+}
diff --git a/utils/TableGen/ClangAttrEmitter.cpp b/utils/TableGen/ClangAttrEmitter.cpp
index b0e2ddd913..726709961a 100644
--- a/utils/TableGen/ClangAttrEmitter.cpp
+++ b/utils/TableGen/ClangAttrEmitter.cpp
@@ -1188,6 +1188,32 @@ namespace {
     }
   };
 
+  class AttrArgument : public SimpleArgument {
+  public:
+    AttrArgument(const Record &Arg, StringRef Attr)
+      : SimpleArgument(Arg, Attr, "Attr *")
+    {}
+
+    void writePCHReadDecls(raw_ostream &OS) const override {
+      OS << "    AttrVec vec;\n"
+            "    ReadAttributes(Record, vec);\n"
+            "    assert(vec.size() == 1);\n"
+            "    Attr *" << getLowerName() << " = vec.front();";
+    }
+
+    void writePCHWrite(raw_ostream &OS) const override {
+      OS << "    AddAttributes(SA->get" << getUpperName() << "());";
+    }
+
+    void writeDump(raw_ostream &OS) const override {}
+  
+    void writeDumpChildren(raw_ostream &OS) const override {
+      OS << "    dumpAttr(SA->get" << getUpperName() << "());\n";
+    }
+
+    void writeHasChildren(raw_ostream &OS) const override { OS << "true"; }
+  };
+
 } // end anonymous namespace
 
 static std::unique_ptr<Argument>
@@ -1237,6 +1263,8 @@ createArgument(const Record &Arg, StringRef Attr,
     Ptr = llvm::make_unique<VariadicExprArgument>(Arg, Attr);
   else if (ArgName == "VersionArgument")
     Ptr = llvm::make_unique<VersionArgument>(Arg, Attr);
+  else if (ArgName == "AttrArgument")
+    Ptr = llvm::make_unique<AttrArgument>(Arg, Attr);
 
   if (!Ptr) {
     // Search in reverse order so that the most-derived type is handled first.
diff --git a/utils/perf-training/lit.cfg b/utils/perf-training/lit.cfg
index 671d44f83b..1deb0809a9 100644
--- a/utils/perf-training/lit.cfg
+++ b/utils/perf-training/lit.cfg
@@ -8,7 +8,7 @@ import subprocess
 def getSysrootFlagsOnDarwin(config, lit_config):
     # On Darwin, support relocatable SDKs by providing Clang with a
     # default system root path.
-    if 'darwin' in config.target_triple:
+    if lit.util.isMacOSTriple(config.target_triple):
         try:
             out = subprocess.check_output(['xcrun', '--show-sdk-path']).strip()
             res = 0
diff --git a/utils/perf-training/order-files.lit.cfg b/utils/perf-training/order-files.lit.cfg
index 93904ec84a..2e7acc7800 100644
--- a/utils/perf-training/order-files.lit.cfg
+++ b/utils/perf-training/order-files.lit.cfg
@@ -9,7 +9,7 @@ import subprocess
 def getSysrootFlagsOnDarwin(config, lit_config):
     # On Darwin, support relocatable SDKs by providing Clang with a
     # default system root path.
-    if 'darwin' in config.target_triple:
+    if lit.util.isMacOSTriple(config.target_triple):
         try:
             out = subprocess.check_output(['xcrun', '--show-sdk-path']).strip()
             res = 0

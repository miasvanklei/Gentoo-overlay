--- b/examples/clang-interpreter/main.cpp
+++ a/examples/clang-interpreter/main.cpp
@@ -145,7 +145,7 @@
 
   // Create a compiler instance to handle the actual work.
   CompilerInstance Clang;
+  Clang.setInvocation(CI.release());
-  Clang.setInvocation(std::move(CI));
 
   // Create the compilers actual diagnostics engine.
   Clang.createDiagnostics();
--- b/include/clang/Frontend/ASTUnit.h
+++ a/include/clang/Frontend/ASTUnit.h
@@ -108,8 +108,8 @@
 
   /// Optional owned invocation, just used to make the invocation used in
   /// LoadFromCommandLine available.
+  IntrusiveRefCntPtr<CompilerInvocation> Invocation;
+
-  std::shared_ptr<CompilerInvocation> Invocation;
-
   // OnlyLocalDecls - when true, walking this AST should only visit declarations
   // that come from the AST itself, not from included precompiled headers.
   // FIXME: This is temporary; eventually, CIndex will always do this.
@@ -358,21 +358,22 @@
   }
   
   /// \brief Retrieve the allocator used to cache global code completions.
+  IntrusiveRefCntPtr<GlobalCodeCompletionAllocator>
-  std::shared_ptr<GlobalCodeCompletionAllocator>
   getCachedCompletionAllocator() {
     return CachedCompletionAllocator;
   }
 
   CodeCompletionTUInfo &getCodeCompletionTUInfo() {
     if (!CCTUInfo)
+      CCTUInfo.reset(new CodeCompletionTUInfo(
+                                            new GlobalCodeCompletionAllocator));
-      CCTUInfo = llvm::make_unique<CodeCompletionTUInfo>(
-          std::make_shared<GlobalCodeCompletionAllocator>());
     return *CCTUInfo;
   }
 
 private:
   /// \brief Allocator used to store cached code completions.
+  IntrusiveRefCntPtr<GlobalCodeCompletionAllocator>
+    CachedCompletionAllocator;
-  std::shared_ptr<GlobalCodeCompletionAllocator> CachedCompletionAllocator;
 
   std::unique_ptr<CodeCompletionTUInfo> CCTUInfo;
 
@@ -701,11 +702,11 @@
   /// remapped contents of that file.
   typedef std::pair<std::string, llvm::MemoryBuffer *> RemappedFile;
 
+  /// \brief Create a ASTUnit. Gets ownership of the passed CompilerInvocation. 
+  static ASTUnit *create(CompilerInvocation *CI,
+                         IntrusiveRefCntPtr<DiagnosticsEngine> Diags,
+                         bool CaptureDiagnostics,
+                         bool UserFilesAreVolatile);
-  /// \brief Create a ASTUnit. Gets ownership of the passed CompilerInvocation.
-  static std::unique_ptr<ASTUnit>
-  create(std::shared_ptr<CompilerInvocation> CI,
-         IntrusiveRefCntPtr<DiagnosticsEngine> Diags, bool CaptureDiagnostics,
-         bool UserFilesAreVolatile);
 
   /// \brief Create a ASTUnit from an AST file.
   ///
@@ -770,7 +771,7 @@
   /// created ASTUnit was passed in \p Unit then the caller can check that.
   ///
   static ASTUnit *LoadFromCompilerInvocationAction(
+      CompilerInvocation *CI,
-      std::shared_ptr<CompilerInvocation> CI,
       std::shared_ptr<PCHContainerOperations> PCHContainerOps,
       IntrusiveRefCntPtr<DiagnosticsEngine> Diags,
       FrontendAction *Action = nullptr, ASTUnit *Unit = nullptr,
@@ -797,7 +798,7 @@
   // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we
   // shouldn't need to specify them at construction time.
   static std::unique_ptr<ASTUnit> LoadFromCompilerInvocation(
+      CompilerInvocation *CI,
-      std::shared_ptr<CompilerInvocation> CI,
       std::shared_ptr<PCHContainerOperations> PCHContainerOps,
       IntrusiveRefCntPtr<DiagnosticsEngine> Diags, FileManager *FileMgr,
       bool OnlyLocalDecls = false, bool CaptureDiagnostics = false,
--- b/include/clang/Frontend/CompilerInstance.h
+++ a/include/clang/Frontend/CompilerInstance.h
@@ -70,7 +70,7 @@
 /// and a long form that takes explicit instances of any required objects.
 class CompilerInstance : public ModuleLoader {
   /// The options used in this compiler instance.
+  IntrusiveRefCntPtr<CompilerInvocation> Invocation;
-  std::shared_ptr<CompilerInvocation> Invocation;
 
   /// The diagnostics engine instance.
   IntrusiveRefCntPtr<DiagnosticsEngine> Diagnostics;
@@ -228,7 +228,7 @@
   }
 
   /// setInvocation - Replace the current invocation.
+  void setInvocation(CompilerInvocation *Value);
-  void setInvocation(std::shared_ptr<CompilerInvocation> Value);
 
   /// \brief Indicates whether we should (re)build the global module index.
   bool shouldBuildGlobalModuleIndex() const;
--- b/include/clang/Frontend/CompilerInvocation.h
+++ a/include/clang/Frontend/CompilerInvocation.h
@@ -51,7 +51,7 @@
                          bool DefaultDiagColor = true,
                          bool DefaultShowOpt = true);
 
+class CompilerInvocationBase : public RefCountedBase<CompilerInvocation> {
-class CompilerInvocationBase {
   void operator=(const CompilerInvocationBase &) = delete;
 
 public:
--- b/include/clang/Frontend/Utils.h
+++ a/include/clang/Frontend/Utils.h
@@ -184,10 +184,10 @@
 ///
 /// \return A CompilerInvocation, or 0 if none was built for the given
 /// argument vector.
+CompilerInvocation *
-std::unique_ptr<CompilerInvocation>
 createInvocationFromCommandLine(ArrayRef<const char *> Args,
+                            IntrusiveRefCntPtr<DiagnosticsEngine> Diags =
+                                IntrusiveRefCntPtr<DiagnosticsEngine>());
-                                IntrusiveRefCntPtr<DiagnosticsEngine> Diags =
-                                    IntrusiveRefCntPtr<DiagnosticsEngine>());
 
 /// Return the value of the last argument as an integer, or a default. If Diags
 /// is non-null, emits an error if the argument is given, but non-integral.
--- b/include/clang/Sema/CodeCompleteConsumer.h
+++ a/include/clang/Sema/CodeCompleteConsumer.h
@@ -509,18 +509,23 @@
 };
 
 /// \brief Allocator for a cached set of global code completions.
+class GlobalCodeCompletionAllocator
+  : public CodeCompletionAllocator,
+    public RefCountedBase<GlobalCodeCompletionAllocator>
+{
+
+};
-class GlobalCodeCompletionAllocator : public CodeCompletionAllocator {};
 
 class CodeCompletionTUInfo {
   llvm::DenseMap<const DeclContext *, StringRef> ParentNames;
+  IntrusiveRefCntPtr<GlobalCodeCompletionAllocator> AllocatorRef;
-  std::shared_ptr<GlobalCodeCompletionAllocator> AllocatorRef;
 
 public:
   explicit CodeCompletionTUInfo(
+      IntrusiveRefCntPtr<GlobalCodeCompletionAllocator> Allocator)
-      std::shared_ptr<GlobalCodeCompletionAllocator> Allocator)
       : AllocatorRef(std::move(Allocator)) {}
 
+  IntrusiveRefCntPtr<GlobalCodeCompletionAllocator> getAllocatorRef() const {
-  std::shared_ptr<GlobalCodeCompletionAllocator> getAllocatorRef() const {
     return AllocatorRef;
   }
   CodeCompletionAllocator &getAllocator() const {
@@ -960,8 +965,8 @@
   /// results to the given raw output stream.
   PrintingCodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts,
                                raw_ostream &OS)
+    : CodeCompleteConsumer(CodeCompleteOpts, false), OS(OS),
+      CCTUInfo(new GlobalCodeCompletionAllocator) {}
-      : CodeCompleteConsumer(CodeCompleteOpts, false), OS(OS),
-        CCTUInfo(std::make_shared<GlobalCodeCompletionAllocator>()) {}
 
   /// \brief Prints the finalized code-completion results.
   void ProcessCodeCompleteResults(Sema &S, CodeCompletionContext Context,
--- b/include/clang/Tooling/Tooling.h
+++ a/include/clang/Tooling/Tooling.h
@@ -69,8 +69,7 @@
 
   /// \brief Perform an action for an invocation.
   virtual bool
+  runInvocation(clang::CompilerInvocation *Invocation, FileManager *Files,
-  runInvocation(std::shared_ptr<clang::CompilerInvocation> Invocation,
-                FileManager *Files,
                 std::shared_ptr<PCHContainerOperations> PCHContainerOps,
                 DiagnosticConsumer *DiagConsumer) = 0;
 };
@@ -86,8 +85,7 @@
   ~FrontendActionFactory() override;
 
   /// \brief Invokes the compiler with a FrontendAction created by create().
+  bool runInvocation(clang::CompilerInvocation *Invocation, FileManager *Files,
-  bool runInvocation(std::shared_ptr<clang::CompilerInvocation> Invocation,
-                     FileManager *Files,
                      std::shared_ptr<PCHContainerOperations> PCHContainerOps,
                      DiagnosticConsumer *DiagConsumer) override;
 
@@ -263,7 +261,7 @@
 
   bool runInvocation(const char *BinaryName,
                      clang::driver::Compilation *Compilation,
+                     clang::CompilerInvocation *Invocation,
-                     std::shared_ptr<clang::CompilerInvocation> Invocation,
                      std::shared_ptr<PCHContainerOperations> PCHContainerOps);
 
   std::vector<std::string> CommandLine;
--- b/lib/ARCMigrate/ARCMT.cpp
+++ a/lib/ARCMigrate/ARCMT.cpp
@@ -271,7 +271,7 @@
   Diags->setClient(&errRec, /*ShouldOwnClient=*/false);
 
   std::unique_ptr<ASTUnit> Unit(ASTUnit::LoadFromCompilerInvocationAction(
+      CInvok.release(), PCHContainerOps, Diags));
-      std::move(CInvok), PCHContainerOps, Diags));
   if (!Unit) {
     errRec.FinishCapture();
     return true;
@@ -547,7 +547,7 @@
   ASTAction.reset(new ARCMTMacroTrackerAction(ARCMTMacroLocs));
 
   std::unique_ptr<ASTUnit> Unit(ASTUnit::LoadFromCompilerInvocationAction(
+      CInvok.release(), PCHContainerOps, Diags, ASTAction.get()));
-      std::move(CInvok), PCHContainerOps, Diags, ASTAction.get()));
   if (!Unit) {
     errRec.FinishCapture();
     return true;
--- b/lib/Frontend/ASTUnit.cpp
+++ a/lib/Frontend/ASTUnit.cpp
@@ -245,7 +245,7 @@
   // perform this operation here because we explicitly request that the
   // compiler instance *not* free these buffers for each invocation of the
   // parser.
+  if (Invocation.get() && OwnsRemappedFileBuffers) {
-  if (Invocation && OwnsRemappedFileBuffers) {
     PreprocessorOptions &PPOpts = Invocation->getPreprocessorOpts();
     for (const auto &RB : PPOpts.RemappedFileBuffers)
       delete RB.second;
@@ -348,7 +348,7 @@
   // Gather the set of global code completions.
   typedef CodeCompletionResult Result;
   SmallVector<Result, 8> Results;
+  CachedCompletionAllocator = new GlobalCodeCompletionAllocator;
-  CachedCompletionAllocator = std::make_shared<GlobalCodeCompletionAllocator>();
   CodeCompletionTUInfo CCTUInfo(CachedCompletionAllocator);
   TheSema->GatherGlobalCodeCompletions(*CachedCompletionAllocator,
                                        CCTUInfo, Results);
@@ -1048,7 +1048,10 @@
   llvm::CrashRecoveryContextCleanupRegistrar<CompilerInstance>
     CICleanup(Clang.get());
 
+  IntrusiveRefCntPtr<CompilerInvocation>
+    CCInvocation(new CompilerInvocation(*Invocation));
+
+  Clang->setInvocation(CCInvocation.get());
-  Clang->setInvocation(std::make_shared<CompilerInvocation>(*Invocation));
   OriginalSourceFile = Clang->getFrontendOpts().Inputs[0].getFile();
     
   // Set up diagnostics, capturing any diagnostics that would
@@ -1341,8 +1344,8 @@
     const CompilerInvocation &PreambleInvocationIn, bool AllowRebuild,
     unsigned MaxLines) {
 
+  IntrusiveRefCntPtr<CompilerInvocation>
+    PreambleInvocation(new CompilerInvocation(PreambleInvocationIn));
-  auto PreambleInvocation =
-      std::make_shared<CompilerInvocation>(PreambleInvocationIn);
   FrontendOptions &FrontendOpts = PreambleInvocation->getFrontendOpts();
   PreprocessorOptions &PreprocessorOpts
     = PreambleInvocation->getPreprocessorOpts();
@@ -1520,7 +1523,7 @@
   llvm::CrashRecoveryContextCleanupRegistrar<CompilerInstance>
     CICleanup(Clang.get());
 
+  Clang->setInvocation(&*PreambleInvocation);
-  Clang->setInvocation(std::move(PreambleInvocation));
   OriginalSourceFile = Clang->getFrontendOpts().Inputs[0].getFile();
   
   // Set up diagnostics, capturing all of the diagnostics produced.
@@ -1706,29 +1709,30 @@
   return Mod.FileName;
 }
 
+ASTUnit *ASTUnit::create(CompilerInvocation *CI,
+                         IntrusiveRefCntPtr<DiagnosticsEngine> Diags,
+                         bool CaptureDiagnostics,
+                         bool UserFilesAreVolatile) {
+  std::unique_ptr<ASTUnit> AST;
+  AST.reset(new ASTUnit(false));
-std::unique_ptr<ASTUnit>
-ASTUnit::create(std::shared_ptr<CompilerInvocation> CI,
-                IntrusiveRefCntPtr<DiagnosticsEngine> Diags,
-                bool CaptureDiagnostics, bool UserFilesAreVolatile) {
-  std::unique_ptr<ASTUnit> AST(new ASTUnit(false));
   ConfigureDiags(Diags, *AST, CaptureDiagnostics);
+  AST->Diagnostics = Diags;
+  AST->Invocation = CI;
+  AST->FileSystemOpts = CI->getFileSystemOpts();
   IntrusiveRefCntPtr<vfs::FileSystem> VFS =
       createVFSFromCompilerInvocation(*CI, *Diags);
   if (!VFS)
     return nullptr;
-  AST->Diagnostics = Diags;
-  AST->FileSystemOpts = CI->getFileSystemOpts();
-  AST->Invocation = std::move(CI);
   AST->FileMgr = new FileManager(AST->FileSystemOpts, VFS);
   AST->UserFilesAreVolatile = UserFilesAreVolatile;
   AST->SourceMgr = new SourceManager(AST->getDiagnostics(), *AST->FileMgr,
                                      UserFilesAreVolatile);
 
+  return AST.release();
-  return AST;
 }
 
 ASTUnit *ASTUnit::LoadFromCompilerInvocationAction(
+    CompilerInvocation *CI,
-    std::shared_ptr<CompilerInvocation> CI,
     std::shared_ptr<PCHContainerOperations> PCHContainerOps,
     IntrusiveRefCntPtr<DiagnosticsEngine> Diags, FrontendAction *Action,
     ASTUnit *Unit, bool Persistent, StringRef ResourceFilesPath,
@@ -1742,7 +1746,7 @@
   ASTUnit *AST = Unit;
   if (!AST) {
     // Create the AST unit.
+    OwnAST.reset(create(CI, Diags, CaptureDiagnostics, UserFilesAreVolatile));
-    OwnAST = create(CI, Diags, CaptureDiagnostics, UserFilesAreVolatile);
     AST = OwnAST.get();
     if (!AST)
       return nullptr;
@@ -1781,7 +1785,7 @@
   llvm::CrashRecoveryContextCleanupRegistrar<CompilerInstance>
     CICleanup(Clang.get());
 
+  Clang->setInvocation(CI);
-  Clang->setInvocation(std::move(CI));
   AST->OriginalSourceFile = Clang->getFrontendOpts().Inputs[0].getFile();
     
   // Set up diagnostics, capturing any diagnostics that would
@@ -1899,7 +1903,7 @@
 }
 
 std::unique_ptr<ASTUnit> ASTUnit::LoadFromCompilerInvocation(
+    CompilerInvocation *CI,
-    std::shared_ptr<CompilerInvocation> CI,
     std::shared_ptr<PCHContainerOperations> PCHContainerOps,
     IntrusiveRefCntPtr<DiagnosticsEngine> Diags, FileManager *FileMgr,
     bool OnlyLocalDecls, bool CaptureDiagnostics,
@@ -1916,7 +1920,7 @@
   AST->ShouldCacheCodeCompletionResults = CacheCodeCompletionResults;
   AST->IncludeBriefCommentsInCodeCompletion
     = IncludeBriefCommentsInCodeCompletion;
+  AST->Invocation = CI;
-  AST->Invocation = std::move(CI);
   AST->FileSystemOpts = FileMgr->getFileSystemOpts();
   AST->FileMgr = FileMgr;
   AST->UserFilesAreVolatile = UserFilesAreVolatile;
@@ -1948,8 +1952,8 @@
   assert(Diags.get() && "no DiagnosticsEngine was provided");
 
   SmallVector<StoredDiagnostic, 4> StoredDiagnostics;
+
+  IntrusiveRefCntPtr<CompilerInvocation> CI;
-
-  std::shared_ptr<CompilerInvocation> CI;
 
   {
 
@@ -1957,7 +1961,8 @@
                                       StoredDiagnostics);
 
     CI = clang::createInvocationFromCommandLine(
+                                           llvm::makeArrayRef(ArgBegin, ArgEnd),
+                                           Diags);
-        llvm::makeArrayRef(ArgBegin, ArgEnd), Diags);
     if (!CI)
       return nullptr;
   }
@@ -2328,7 +2333,8 @@
   CompletionTimer.setOutput("Code completion @ " + File + ":" +
                             Twine(Line) + ":" + Twine(Column));
 
+  IntrusiveRefCntPtr<CompilerInvocation>
+    CCInvocation(new CompilerInvocation(*Invocation));
-  auto CCInvocation = std::make_shared<CompilerInvocation>(*Invocation);
 
   FrontendOptions &FrontendOpts = CCInvocation->getFrontendOpts();
   CodeCompleteOptions &CodeCompleteOpts = FrontendOpts.CodeCompleteOpts;
@@ -2360,8 +2366,7 @@
   llvm::CrashRecoveryContextCleanupRegistrar<CompilerInstance>
     CICleanup(Clang.get());
 
+  Clang->setInvocation(&*CCInvocation);
-  auto &Inv = *CCInvocation;
-  Clang->setInvocation(std::move(CCInvocation));
   OriginalSourceFile = Clang->getFrontendOpts().Inputs[0].getFile();
     
   // Set up diagnostics, capturing any diagnostics produced.
@@ -2369,8 +2374,8 @@
   CaptureDroppedDiagnostics Capture(true, 
                                     Clang->getDiagnostics(), 
                                     StoredDiagnostics);
+  ProcessWarningOptions(Diag, CCInvocation->getDiagnosticOpts());
+  
-  ProcessWarningOptions(Diag, Inv.getDiagnosticOpts());
-
   // Create the target instance.
   Clang->setTarget(TargetInfo::CreateTargetInfo(
       Clang->getDiagnostics(), Clang->getInvocation().TargetOpts));
@@ -2426,7 +2431,7 @@
       if (!llvm::sys::fs::getUniqueID(MainPath, MainID)) {
         if (CompleteFileID == MainID && Line > 1)
           OverrideMainBuffer = getMainBufferWithPrecompiledPreamble(
+              PCHContainerOps, *CCInvocation, false, Line - 1);
-              PCHContainerOps, Inv, false, Line - 1);
       }
     }
   }
--- b/lib/Frontend/ChainedIncludesSource.cpp
+++ a/lib/Frontend/ChainedIncludesSource.cpp
@@ -147,7 +147,7 @@
 
     std::unique_ptr<CompilerInstance> Clang(
         new CompilerInstance(CI.getPCHContainerOperations()));
+    Clang->setInvocation(CInvok.release());
-    Clang->setInvocation(std::move(CInvok));
     Clang->setDiagnostics(Diags.get());
     Clang->setTarget(TargetInfo::CreateTargetInfo(
         Clang->getDiagnostics(), Clang->getInvocation().TargetOpts));
--- b/lib/Frontend/CompilerInstance.cpp
+++ a/lib/Frontend/CompilerInstance.cpp
@@ -66,9 +66,8 @@
   assert(OutputFiles.empty() && "Still output files in flight?");
 }
 
+void CompilerInstance::setInvocation(CompilerInvocation *Value) {
+  Invocation = Value;
-void CompilerInstance::setInvocation(
-    std::shared_ptr<CompilerInvocation> Value) {
-  Invocation = std::move(Value);
 }
 
 bool CompilerInstance::shouldBuildGlobalModuleIndex() const {
@@ -1020,8 +1019,8 @@
     = ImportingInstance.getPreprocessor().getHeaderSearchInfo().getModuleMap();
     
   // Construct a compiler invocation for creating this module.
+  IntrusiveRefCntPtr<CompilerInvocation> Invocation
+    (new CompilerInvocation(ImportingInstance.getInvocation()));
-  auto Invocation =
-      std::make_shared<CompilerInvocation>(ImportingInstance.getInvocation());
 
   PreprocessorOptions &PPOpts = Invocation->getPreprocessorOpts();
   
@@ -1077,8 +1076,7 @@
   // module.
   CompilerInstance Instance(ImportingInstance.getPCHContainerOperations(),
                             /*BuildingModule=*/true);
+  Instance.setInvocation(&*Invocation);
-  auto &Inv = *Invocation;
-  Instance.setInvocation(std::move(Invocation));
 
   Instance.createDiagnostics(new ForwardingDiagnosticConsumer(
                                    ImportingInstance.getDiagnosticClient()),
@@ -1100,7 +1098,7 @@
   // between all of the module CompilerInstances. Other than that, we don't
   // want to produce any dependency output from the module build.
   Instance.setModuleDepCollector(ImportingInstance.getModuleDepCollector());
+  Invocation->getDependencyOutputOpts() = DependencyOutputOptions();
-  Inv.getDependencyOutputOpts() = DependencyOutputOptions();
 
   // Get or create the module map that we'll use to build this module.
   std::string InferredModuleMapContent;
--- b/lib/Frontend/CompilerInvocation.cpp
+++ a/lib/Frontend/CompilerInvocation.cpp
@@ -60,11 +60,12 @@
     PreprocessorOpts(new PreprocessorOptions()) {}
 
 CompilerInvocationBase::CompilerInvocationBase(const CompilerInvocationBase &X)
+  : RefCountedBase<CompilerInvocation>(),
+    LangOpts(new LangOptions(*X.getLangOpts())),
+    TargetOpts(new TargetOptions(X.getTargetOpts())),
+    DiagnosticOpts(new DiagnosticOptions(X.getDiagnosticOpts())),
+    HeaderSearchOpts(new HeaderSearchOptions(X.getHeaderSearchOpts())),
+    PreprocessorOpts(new PreprocessorOptions(X.getPreprocessorOpts())) {}
-    : LangOpts(new LangOptions(*X.getLangOpts())),
-      TargetOpts(new TargetOptions(X.getTargetOpts())),
-      DiagnosticOpts(new DiagnosticOptions(X.getDiagnosticOpts())),
-      HeaderSearchOpts(new HeaderSearchOptions(X.getHeaderSearchOpts())),
-      PreprocessorOpts(new PreprocessorOptions(X.getPreprocessorOpts())) {}
 
 CompilerInvocationBase::~CompilerInvocationBase() {}
 
--- b/lib/Frontend/CreateInvocationFromCommandLine.cpp
+++ a/lib/Frontend/CreateInvocationFromCommandLine.cpp
@@ -30,9 +30,9 @@
 ///
 /// \return A CompilerInvocation, or 0 if none was built for the given
 /// argument vector.
+CompilerInvocation *
+clang::createInvocationFromCommandLine(ArrayRef<const char *> ArgList,
+                            IntrusiveRefCntPtr<DiagnosticsEngine> Diags) {
-std::unique_ptr<CompilerInvocation> clang::createInvocationFromCommandLine(
-    ArrayRef<const char *> ArgList,
-    IntrusiveRefCntPtr<DiagnosticsEngine> Diags) {
   if (!Diags.get()) {
     // No diagnostics engine was provided, so create our own diagnostics object
     // with the default options.
@@ -93,12 +93,12 @@
   }
 
   const ArgStringList &CCArgs = Cmd.getArguments();
+  std::unique_ptr<CompilerInvocation> CI(new CompilerInvocation());
-  auto CI = llvm::make_unique<CompilerInvocation>();
   if (!CompilerInvocation::CreateFromArgs(*CI,
                                      const_cast<const char **>(CCArgs.data()),
                                      const_cast<const char **>(CCArgs.data()) +
                                      CCArgs.size(),
                                      *Diags))
     return nullptr;
+  return CI.release();
-  return CI;
 }
--- b/lib/StaticAnalyzer/Frontend/ModelInjector.cpp
+++ a/lib/StaticAnalyzer/Frontend/ModelInjector.cpp
@@ -62,7 +62,8 @@
     return;
   }
 
+  IntrusiveRefCntPtr<CompilerInvocation> Invocation(
+      new CompilerInvocation(CI.getInvocation()));
-  auto Invocation = std::make_shared<CompilerInvocation>(CI.getInvocation());
 
   FrontendOptions &FrontendOpts = Invocation->getFrontendOpts();
   InputKind IK = IK_CXX; // FIXME
@@ -75,7 +76,7 @@
   // Modules are parsed by a separate CompilerInstance, so this code mimics that
   // behavior for models
   CompilerInstance Instance(CI.getPCHContainerOperations());
+  Instance.setInvocation(&*Invocation);
-  Instance.setInvocation(std::move(Invocation));
   Instance.createDiagnostics(
       new ForwardingDiagnosticConsumer(CI.getDiagnosticClient()),
       /*ShouldOwnClient=*/true);
--- b/lib/Tooling/Tooling.cpp
+++ a/lib/Tooling/Tooling.cpp
@@ -275,13 +275,13 @@
     Invocation->getPreprocessorOpts().addRemappedFile(It.getKey(),
                                                       Input.release());
   }
+  return runInvocation(BinaryName, Compilation.get(), Invocation.release(),
-  return runInvocation(BinaryName, Compilation.get(), std::move(Invocation),
                        std::move(PCHContainerOps));
 }
 
 bool ToolInvocation::runInvocation(
     const char *BinaryName, clang::driver::Compilation *Compilation,
+    clang::CompilerInvocation *Invocation,
-    std::shared_ptr<clang::CompilerInvocation> Invocation,
     std::shared_ptr<PCHContainerOperations> PCHContainerOps) {
   // Show the invocation, with -v.
   if (Invocation->getHeaderSearchOpts().Verbose) {
@@ -290,17 +290,17 @@
     llvm::errs() << "\n";
   }
 
+  return Action->runInvocation(Invocation, Files, std::move(PCHContainerOps),
+                               DiagConsumer);
-  return Action->runInvocation(std::move(Invocation), Files,
-                               std::move(PCHContainerOps), DiagConsumer);
 }
 
 bool FrontendActionFactory::runInvocation(
+    CompilerInvocation *Invocation, FileManager *Files,
-    std::shared_ptr<CompilerInvocation> Invocation, FileManager *Files,
     std::shared_ptr<PCHContainerOperations> PCHContainerOps,
     DiagnosticConsumer *DiagConsumer) {
   // Create a compiler instance to handle the actual work.
   clang::CompilerInstance Compiler(std::move(PCHContainerOps));
+  Compiler.setInvocation(Invocation);
-  Compiler.setInvocation(std::move(Invocation));
   Compiler.setFileManager(Files);
 
   // The FrontendAction can have lifetime requirements for Compiler or its
@@ -474,8 +474,7 @@
 public:
   ASTBuilderAction(std::vector<std::unique_ptr<ASTUnit>> &ASTs) : ASTs(ASTs) {}
 
+  bool runInvocation(CompilerInvocation *Invocation, FileManager *Files,
-  bool runInvocation(std::shared_ptr<CompilerInvocation> Invocation,
-                     FileManager *Files,
                      std::shared_ptr<PCHContainerOperations> PCHContainerOps,
                      DiagnosticConsumer *DiagConsumer) override {
     std::unique_ptr<ASTUnit> AST = ASTUnit::LoadFromCompilerInvocation(
--- b/tools/c-index-test/core_main.cpp
+++ a/tools/c-index-test/core_main.cpp
@@ -140,7 +140,8 @@
   ArgsWithProgName.append(Args.begin(), Args.end());
   IntrusiveRefCntPtr<DiagnosticsEngine>
     Diags(CompilerInstance::createDiagnostics(new DiagnosticOptions));
+  IntrusiveRefCntPtr<CompilerInvocation>
+    CInvok(createInvocationFromCommandLine(ArgsWithProgName, Diags));
-  auto CInvok = createInvocationFromCommandLine(ArgsWithProgName, Diags);
   if (!CInvok)
     return true;
 
@@ -152,7 +153,7 @@
 
   auto PCHContainerOps = std::make_shared<PCHContainerOperations>();
   std::unique_ptr<ASTUnit> Unit(ASTUnit::LoadFromCompilerInvocationAction(
+      CInvok.get(), PCHContainerOps, Diags, IndexAction.get()));
-      std::move(CInvok), PCHContainerOps, Diags, IndexAction.get()));
 
   if (!Unit)
     return true;
--- b/tools/clang-import-test/clang-import-test.cpp
+++ a/tools/clang-import-test/clang-import-test.cpp
@@ -157,7 +157,7 @@
   Inv->getCodeGenOpts().setDebugInfo(codegenoptions::FullDebugInfo);
   Inv->getTargetOpts().Triple = llvm::sys::getDefaultTargetTriple();
 
+  Ins->setInvocation(Inv.release());
-  Ins->setInvocation(std::move(Inv));
 
   TargetInfo *TI = TargetInfo::CreateTargetInfo(
       Ins->getDiagnostics(), Ins->getInvocation().TargetOpts);
--- b/tools/diagtool/ShowEnabledWarnings.cpp
+++ a/tools/diagtool/ShowEnabledWarnings.cpp
@@ -67,8 +67,8 @@
   SmallVector<const char *, 4> Args;
   Args.push_back("diagtool");
   Args.append(argv, argv + argc);
+  std::unique_ptr<CompilerInvocation> Invocation(
+      createInvocationFromCommandLine(Args, InterimDiags));
-  std::unique_ptr<CompilerInvocation> Invocation =
-      createInvocationFromCommandLine(Args, InterimDiags);
   if (!Invocation)
     return nullptr;
 
--- b/tools/libclang/CIndex.cpp
+++ a/tools/libclang/CIndex.cpp
@@ -68,14 +68,13 @@
 using namespace clang::cxtu;
 using namespace clang::cxindex;
 
+CXTranslationUnit cxtu::MakeCXTranslationUnit(CIndexer *CIdx, ASTUnit *AU) {
-CXTranslationUnit cxtu::MakeCXTranslationUnit(CIndexer *CIdx,
-                                              std::unique_ptr<ASTUnit> AU) {
   if (!AU)
     return nullptr;
   assert(CIdx);
   CXTranslationUnit D = new CXTranslationUnitImpl();
   D->CIdx = CIdx;
+  D->TheASTUnit = AU;
-  D->TheASTUnit = AU.release();
   D->StringPool = new cxstring::CXStringPool();
   D->Diagnostics = nullptr;
   D->OverridenCursorsPool = createOverridenCXCursorsPool();
@@ -3232,7 +3231,7 @@
       /*CaptureDiagnostics=*/true,
       /*AllowPCHWithCompilerErrors=*/true,
       /*UserFilesAreVolatile=*/true);
+  *out_TU = MakeCXTranslationUnit(CXXIdx, AU.release());
-  *out_TU = MakeCXTranslationUnit(CXXIdx, std::move(AU));
   return *out_TU ? CXError_Success : CXError_Failure;
 }
 
@@ -3384,7 +3383,7 @@
   if (isASTReadError(Unit ? Unit.get() : ErrUnit.get()))
     return CXError_ASTReadError;
 
+  *out_TU = MakeCXTranslationUnit(CXXIdx, Unit.release());
-  *out_TU = MakeCXTranslationUnit(CXXIdx, std::move(Unit));
   return *out_TU ? CXError_Success : CXError_Failure;
 }
 
--- b/tools/libclang/CIndexCodeCompletion.cpp
+++ a/tools/libclang/CIndexCodeCompletion.cpp
@@ -279,12 +279,13 @@
   SmallVector<const llvm::MemoryBuffer *, 1> TemporaryBuffers;
   
   /// \brief Allocator used to store globally cached code-completion results.
+  IntrusiveRefCntPtr<clang::GlobalCodeCompletionAllocator>
+    CachedCompletionAllocator;
+
-  std::shared_ptr<clang::GlobalCodeCompletionAllocator>
-      CachedCompletionAllocator;
-
   /// \brief Allocator used to store code completion results.
+  IntrusiveRefCntPtr<clang::GlobalCodeCompletionAllocator>
+    CodeCompletionAllocator;
+
-  std::shared_ptr<clang::GlobalCodeCompletionAllocator> CodeCompletionAllocator;
-
   /// \brief Context under which completion occurred.
   enum clang::CodeCompletionContext::Kind ContextKind;
   
@@ -314,15 +315,15 @@
 ///
 /// Used for debugging purposes only.
 static std::atomic<unsigned> CodeCompletionResultObjects;
+
-
 AllocatedCXCodeCompleteResults::AllocatedCXCodeCompleteResults(
     IntrusiveRefCntPtr<FileManager> FileMgr)
+    : CXCodeCompleteResults(),
+      DiagOpts(new DiagnosticOptions),
-    : CXCodeCompleteResults(), DiagOpts(new DiagnosticOptions),
       Diag(new DiagnosticsEngine(
           IntrusiveRefCntPtr<DiagnosticIDs>(new DiagnosticIDs), &*DiagOpts)),
       FileMgr(FileMgr), SourceMgr(new SourceManager(*Diag, *FileMgr)),
+      CodeCompletionAllocator(new clang::GlobalCodeCompletionAllocator),
-      CodeCompletionAllocator(
-          std::make_shared<clang::GlobalCodeCompletionAllocator>()),
       Contexts(CXCompletionContext_Unknown),
       ContainerKind(CXCursor_InvalidCode), ContainerIsIncomplete(1) {
   if (getenv("LIBCLANG_OBJTRACKING"))
--- b/tools/libclang/CXTranslationUnit.h
+++ a/tools/libclang/CXTranslationUnit.h
@@ -38,8 +38,7 @@
 namespace clang {
 namespace cxtu {
 
+CXTranslationUnitImpl *MakeCXTranslationUnit(CIndexer *CIdx, ASTUnit *AU);
-CXTranslationUnitImpl *MakeCXTranslationUnit(CIndexer *CIdx,
-                                             std::unique_ptr<ASTUnit> AU);
 
 static inline ASTUnit *getASTUnit(CXTranslationUnit TU) {
   if (!TU)
--- b/tools/libclang/Indexing.cpp
+++ a/tools/libclang/Indexing.cpp
@@ -476,19 +476,17 @@
   // present it will be unused.
   if (source_filename)
     Args->push_back(source_filename);
+
+  IntrusiveRefCntPtr<CompilerInvocation>
+    CInvok(createInvocationFromCommandLine(*Args, Diags));
-
-  std::shared_ptr<CompilerInvocation> CInvok =
-      createInvocationFromCommandLine(*Args, Diags);
 
   if (!CInvok)
     return CXError_Failure;
 
   // Recover resources if we crash before exiting this function.
+  llvm::CrashRecoveryContextCleanupRegistrar<CompilerInvocation,
+    llvm::CrashRecoveryContextReleaseRefCleanup<CompilerInvocation> >
+    CInvokCleanup(CInvok.get());
-  llvm::CrashRecoveryContextCleanupRegistrar<
-      std::shared_ptr<CompilerInvocation>,
-      llvm::CrashRecoveryContextDestructorCleanup<
-          std::shared_ptr<CompilerInvocation>>>
-      CInvokCleanup(&CInvok);
 
   if (CInvok->getFrontendOpts().Inputs.empty())
     return CXError_Failure;
@@ -520,14 +518,13 @@
   CInvok->getHeaderSearchOpts().ModuleFormat =
     CXXIdx->getPCHContainerOperations()->getRawReader().getFormat();
 
+  ASTUnit *Unit = ASTUnit::create(CInvok.get(), Diags, CaptureDiagnostics,
+                                  /*UserFilesAreVolatile=*/true);
-  auto Unit = ASTUnit::create(CInvok, Diags, CaptureDiagnostics,
-                              /*UserFilesAreVolatile=*/true);
   if (!Unit)
     return CXError_InvalidArguments;
 
-  auto *UPtr = Unit.get();
   std::unique_ptr<CXTUOwner> CXTU(
+      new CXTUOwner(MakeCXTranslationUnit(CXXIdx, Unit)));
-      new CXTUOwner(MakeCXTranslationUnit(CXXIdx, std::move(Unit))));
 
   // Recover resources if we crash before exiting this method.
   llvm::CrashRecoveryContextCleanupRegistrar<CXTUOwner>
@@ -586,16 +583,16 @@
       !PrecompilePreamble ? 0 : 2 - CreatePreambleOnFirstParse;
   DiagnosticErrorTrap DiagTrap(*Diags);
   bool Success = ASTUnit::LoadFromCompilerInvocationAction(
+      CInvok.get(), CXXIdx->getPCHContainerOperations(), Diags,
+      IndexAction.get(), Unit, Persistent, CXXIdx->getClangResourcesPath(),
-      std::move(CInvok), CXXIdx->getPCHContainerOperations(), Diags,
-      IndexAction.get(), UPtr, Persistent, CXXIdx->getClangResourcesPath(),
       OnlyLocalDecls, CaptureDiagnostics, PrecompilePreambleAfterNParses,
       CacheCodeCompletionResults,
       /*IncludeBriefCommentsInCodeCompletion=*/false,
       /*UserFilesAreVolatile=*/true);
   if (DiagTrap.hasErrorOccurred() && CXXIdx->getDisplayDiagnostics())
+    printDiagsToStderr(Unit);
-    printDiagsToStderr(UPtr);
 
+  if (isASTReadError(Unit))
-  if (isASTReadError(UPtr))
     return CXError_ASTReadError;
 
   if (!Success)
--- b/unittests/AST/ExternalASTSourceTest.cpp
+++ a/unittests/AST/ExternalASTSourceTest.cpp
@@ -49,14 +49,14 @@
   CompilerInstance Compiler;
   Compiler.createDiagnostics();
 
+  CompilerInvocation *Invocation = new CompilerInvocation;
-  auto Invocation = std::make_shared<CompilerInvocation>();
   Invocation->getPreprocessorOpts().addRemappedFile(
       "test.cc", MemoryBuffer::getMemBuffer(FileContents).release());
   const char *Args[] = { "test.cc" };
   CompilerInvocation::CreateFromArgs(*Invocation, Args,
                                      Args + array_lengthof(Args),
                                      Compiler.getDiagnostics());
+  Compiler.setInvocation(Invocation);
-  Compiler.setInvocation(std::move(Invocation));
 
   TestFrontendAction Action(Source);
   return Compiler.ExecuteAction(Action);
--- b/unittests/Frontend/CodeGenActionTest.cpp
+++ a/unittests/Frontend/CodeGenActionTest.cpp
@@ -41,7 +41,7 @@
 
 
 TEST(CodeGenTest, TestNullCodeGen) {
+  CompilerInvocation *Invocation = new CompilerInvocation;
-  auto Invocation = std::make_shared<CompilerInvocation>();
   Invocation->getPreprocessorOpts().addRemappedFile(
       "test.cc",
       MemoryBuffer::getMemBuffer("").release());
@@ -50,7 +50,7 @@
   Invocation->getFrontendOpts().ProgramAction = EmitLLVM;
   Invocation->getTargetOpts().Triple = "i386-unknown-linux-gnu";
   CompilerInstance Compiler;
+  Compiler.setInvocation(Invocation);
-  Compiler.setInvocation(std::move(Invocation));
   Compiler.createDiagnostics();
   EXPECT_TRUE(Compiler.hasDiagnostics());
 
--- b/unittests/Frontend/FrontendActionTest.cpp
+++ a/unittests/Frontend/FrontendActionTest.cpp
@@ -79,7 +79,7 @@
 };
 
 TEST(ASTFrontendAction, Sanity) {
+  CompilerInvocation *invocation = new CompilerInvocation;
-  auto invocation = std::make_shared<CompilerInvocation>();
   invocation->getPreprocessorOpts().addRemappedFile(
       "test.cc",
       MemoryBuffer::getMemBuffer("int main() { float x; }").release());
@@ -88,7 +88,7 @@
   invocation->getFrontendOpts().ProgramAction = frontend::ParseSyntaxOnly;
   invocation->getTargetOpts().Triple = "i386-unknown-linux-gnu";
   CompilerInstance compiler;
+  compiler.setInvocation(invocation);
-  compiler.setInvocation(std::move(invocation));
   compiler.createDiagnostics();
 
   TestASTFrontendAction test_action;
@@ -99,7 +99,7 @@
 }
 
 TEST(ASTFrontendAction, IncrementalParsing) {
+  CompilerInvocation *invocation = new CompilerInvocation;
-  auto invocation = std::make_shared<CompilerInvocation>();
   invocation->getPreprocessorOpts().addRemappedFile(
       "test.cc",
       MemoryBuffer::getMemBuffer("int main() { float x; }").release());
@@ -108,7 +108,7 @@
   invocation->getFrontendOpts().ProgramAction = frontend::ParseSyntaxOnly;
   invocation->getTargetOpts().Triple = "i386-unknown-linux-gnu";
   CompilerInstance compiler;
+  compiler.setInvocation(invocation);
-  compiler.setInvocation(std::move(invocation));
   compiler.createDiagnostics();
 
   TestASTFrontendAction test_action(/*enableIncrementalProcessing=*/true);
@@ -119,7 +119,7 @@
 }
 
 TEST(ASTFrontendAction, LateTemplateIncrementalParsing) {
+  CompilerInvocation *invocation = new CompilerInvocation;
-  auto invocation = std::make_shared<CompilerInvocation>();
   invocation->getLangOpts()->CPlusPlus = true;
   invocation->getLangOpts()->DelayedTemplateParsing = true;
   invocation->getPreprocessorOpts().addRemappedFile(
@@ -135,7 +135,7 @@
   invocation->getFrontendOpts().ProgramAction = frontend::ParseSyntaxOnly;
   invocation->getTargetOpts().Triple = "i386-unknown-linux-gnu";
   CompilerInstance compiler;
+  compiler.setInvocation(invocation);
-  compiler.setInvocation(std::move(invocation));
   compiler.createDiagnostics();
 
   TestASTFrontendAction test_action(/*enableIncrementalProcessing=*/true,
@@ -172,7 +172,7 @@
 };
 
 TEST(PreprocessorFrontendAction, EndSourceFile) {
+  CompilerInvocation *Invocation = new CompilerInvocation;
-  auto Invocation = std::make_shared<CompilerInvocation>();
   Invocation->getPreprocessorOpts().addRemappedFile(
       "test.cc",
       MemoryBuffer::getMemBuffer("int main() { float x; }").release());
@@ -181,7 +181,7 @@
   Invocation->getFrontendOpts().ProgramAction = frontend::ParseSyntaxOnly;
   Invocation->getTargetOpts().Triple = "i386-unknown-linux-gnu";
   CompilerInstance Compiler;
+  Compiler.setInvocation(Invocation);
-  Compiler.setInvocation(std::move(Invocation));
   Compiler.createDiagnostics();
 
   TestPPCallbacks *Callbacks = new TestPPCallbacks;
@@ -231,7 +231,7 @@
 };
 
 TEST(ASTFrontendAction, ExternalSemaSource) {
+  auto *Invocation = new CompilerInvocation;
-  auto Invocation = std::make_shared<CompilerInvocation>();
   Invocation->getLangOpts()->CPlusPlus = true;
   Invocation->getPreprocessorOpts().addRemappedFile(
       "test.cc", MemoryBuffer::getMemBuffer("void fooo();\n"
@@ -242,7 +242,7 @@
   Invocation->getFrontendOpts().ProgramAction = frontend::ParseSyntaxOnly;
   Invocation->getTargetOpts().Triple = "i386-unknown-linux-gnu";
   CompilerInstance Compiler;
+  Compiler.setInvocation(Invocation);
-  Compiler.setInvocation(std::move(Invocation));
   auto *TDC = new TypoDiagnosticConsumer;
   Compiler.createDiagnostics(TDC, /*ShouldOwnClient=*/true);
   Compiler.setExternalSemaSource(new TypoExternalSemaSource(Compiler));

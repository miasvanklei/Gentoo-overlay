--- a/include/llvm/ADT/DenseMapInfo.h
+++ b/include/llvm/ADT/DenseMapInfo.h
@@ -19,6 +19,7 @@
 #include <cstddef>
 #include <cstdint>
 #include <utility>
+#include <tuple>
 
 namespace llvm {
 
@@ -132,6 +133,20 @@
   }
 };
 
+/// Simplistic combination of 32-bit hash values into 32-bit hash values.
+static inline unsigned combineHashValue(unsigned a, unsigned b) {
+  uint64_t key = (uint64_t)a << 32 | (uint64_t)b;
+  key += ~(key << 32);
+  key ^= (key >> 22);
+  key += ~(key << 13);
+  key ^= (key >> 8);
+  key += (key << 3);
+  key ^= (key >> 15);
+  key += ~(key << 27);
+  key ^= (key >> 31);
+  return (unsigned)key;
+}
+
 // Provide DenseMapInfo for all pairs whose members have info.
 template<typename T, typename U>
 struct DenseMapInfo<std::pair<T, U> > {
@@ -148,17 +163,8 @@
                           SecondInfo::getTombstoneKey());
   }
   static unsigned getHashValue(const Pair& PairVal) {
-    uint64_t key = (uint64_t)FirstInfo::getHashValue(PairVal.first) << 32
-          | (uint64_t)SecondInfo::getHashValue(PairVal.second);
-    key += ~(key << 32);
-    key ^= (key >> 22);
-    key += ~(key << 13);
-    key ^= (key >> 8);
-    key += (key << 3);
-    key ^= (key >> 15);
-    key += ~(key << 27);
-    key ^= (key >> 31);
-    return (unsigned)key;
+    return combineHashValue(FirstInfo::getHashValue(PairVal.first),
+                            SecondInfo::getHashValue(PairVal.second));
   }
   static bool isEqual(const Pair &LHS, const Pair &RHS) {
     return FirstInfo::isEqual(LHS.first, RHS.first) &&
@@ -166,6 +172,59 @@
   }
 };
 
+template<typename ...Ts>
+struct DenseMapInfo<std::tuple<Ts...> > {
+  typedef std::tuple<Ts...> Tuple;
+
+  /// Helper class
+  template<unsigned N> struct UnsignedC { };
+
+  static inline Tuple getEmptyKey() {
+    return Tuple(DenseMapInfo<Ts>::getEmptyKey()...);
+  }
+
+  static inline Tuple getTombstoneKey() {
+    return Tuple(DenseMapInfo<Ts>::getTombstoneKey()...);
+  }
+
+  template<unsigned I>
+  static unsigned getHashValueImpl(const Tuple& values, std::false_type) {
+    typedef typename std::tuple_element<I, Tuple>::type EltType;
+    std::integral_constant<bool, I+1 == sizeof...(Ts)> atEnd;
+    return combineHashValue(
+             DenseMapInfo<EltType>::getHashValue(std::get<I>(values)),
+             getHashValueImpl<I+1>(values, atEnd));
+  }
+
+  template<unsigned I>
+  static unsigned getHashValueImpl(const Tuple& values, std::true_type) {
+    return 0;
+  }
+
+  static unsigned getHashValue(const std::tuple<Ts...>& values) {
+    std::integral_constant<bool, 0 == sizeof...(Ts)> atEnd;
+    return getHashValueImpl<0>(values, atEnd);
+  }
+
+  template<unsigned I>
+  static bool isEqualImpl(const Tuple &lhs, const Tuple &rhs, std::false_type) {
+    typedef typename std::tuple_element<I, Tuple>::type EltType;
+    std::integral_constant<bool, I+1 == sizeof...(Ts)> atEnd;
+    return DenseMapInfo<EltType>::isEqual(std::get<I>(lhs), std::get<I>(rhs))
+           && isEqualImpl<I+1>(lhs, rhs, atEnd);
+  }
+
+  template<unsigned I>
+  static bool isEqualImpl(const Tuple &lhs, const Tuple &rhs, std::true_type) {
+    return true;
+  }
+
+  static bool isEqual(const Tuple &lhs, const Tuple &rhs) {
+    std::integral_constant<bool, 0 == sizeof...(Ts)> atEnd;
+    return isEqualImpl<0>(lhs, rhs, atEnd);
+  }
+};
+
 // Provide DenseMapInfo for StringRefs.
 template <> struct DenseMapInfo<StringRef> {
   static inline StringRef getEmptyKey() {
--- a/include/llvm/ADT/Hashing.h
+++ b/include/llvm/ADT/Hashing.h
@@ -53,6 +53,7 @@
 #include <cassert>
 #include <cstring>
 #include <string>
+#include <tuple>
 #include <utility>
 
 namespace llvm {
@@ -656,6 +657,33 @@
   return hash_combine_range(arg.begin(), arg.end());
 }
 
+template<unsigned ...Indices>
+struct UnsignedConstantIndexSet { };
+
+template<unsigned I, unsigned N, unsigned ...Indices>
+struct MakeUnsignedConstantIndexSet {
+  typedef typename MakeUnsignedConstantIndexSet<I+1, N, Indices..., I>::Type
+    Type;
+};
+
+template<unsigned N, unsigned ...Indices>
+struct MakeUnsignedConstantIndexSet<N, N, Indices...> {
+  typedef UnsignedConstantIndexSet<Indices...> Type;
+};
+
+template <typename ...Ts, unsigned ...Indices>
+hash_code hash_value_tuple_helper(const std::tuple<Ts...> &arg,
+                                  UnsignedConstantIndexSet<Indices...> indices) {
+  return hash_combine(hash_value(std::get<Indices>(arg))...);
+}
+
+template <typename ...Ts>
+hash_code hash_value(const std::tuple<Ts...> &arg) {
+  return hash_value_tuple_helper(
+           arg,
+           typename MakeUnsignedConstantIndexSet<0, sizeof...(Ts)>::Type());
+}
+
 } // namespace llvm
 
 #endif
--- a/include/llvm/Bitcode/RecordLayout.h
+++ b/include/llvm/Bitcode/RecordLayout.h
@@ -0,0 +1,529 @@
+//===--- RecordLayout.h - Convenience wrappers for bitcode ------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file Convenience wrappers for the LLVM bitcode format and bitstream APIs.
+///
+/// This allows you to use a sort of DSL to declare and use bitcode abbrevs
+/// and records. Example:
+///
+/// \code
+///     using Metadata = BCRecordLayout<
+///       METADATA_ID, // ID
+///       BCFixed<16>, // Module format major version
+///       BCFixed<16>, // Module format minor version
+///       BCBlob // misc. version information
+///     >;
+///     unsigned MetadataAbbrevCode = Metadata::emitAbbrev(Out);
+///     Metadata::emitRecord(Out, ScratchRecord, MetadataAbbrevCode,
+///                          VERSION_MAJOR, VERSION_MINOR, extraData);
+/// \endcode
+///
+/// For details on the bitcode format, see
+///   http://llvm.org/docs/BitCodeFormat.html
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_BITCODE_RECORDLAYOUT_H
+#define LLVM_BITCODE_RECORDLAYOUT_H
+
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Bitcode/BitCodes.h"
+#include "llvm/Bitcode/BitstreamWriter.h"
+#include "llvm/Support/Compiler.h"
+#include "llvm/Support/MathExtras.h"
+
+namespace llvm {
+
+namespace impl {
+  /// Convenience base for all kinds of bitcode abbreviation fields.
+  ///
+  /// This just defines common properties queried by the metaprogramming.
+  template<bool COMPOUND = false>
+  class BCField {
+  public:
+    static const bool IS_COMPOUND = COMPOUND;
+
+    /// Asserts that the given data is a valid value for this field.
+    template<typename T>
+    static void assertValid(const T &data) {}
+
+    /// Converts a raw numeric representation of this value to its preferred
+    /// type.
+    template<typename T>
+    static T convert(T rawValue) {
+      return rawValue;
+    }
+  };
+} // end namespace impl
+
+
+/// Represents a literal operand in a bitcode record.
+///
+/// The value of a literal operand is the same for all instances of the record,
+/// so it is only emitted in the abbreviation definition.
+///
+/// Note that because this uses a compile-time template, you cannot have a
+/// literal operand that is fixed at run-time without dropping down to the
+/// raw LLVM APIs.
+template<uint64_t Value>
+class BCLiteral : public impl::BCField<> {
+public:
+  static void emitOp(llvm::BitCodeAbbrev &abbrev) {
+    abbrev.Add(llvm::BitCodeAbbrevOp(Value));
+  }
+
+  template<typename T>
+  static void assertValid(const T &data) {
+    assert(data == Value && "data value does not match declared literal value");
+  }
+};
+
+/// Represents a fixed-width value in a bitcode record.
+///
+/// Note that the LLVM bitcode format only supports unsigned values.
+template<unsigned Width>
+class BCFixed : public impl::BCField<> {
+public:
+  static_assert(Width <= 64, "fixed-width field is too large");
+
+  static void emitOp(llvm::BitCodeAbbrev &abbrev) {
+    abbrev.Add(llvm::BitCodeAbbrevOp(llvm::BitCodeAbbrevOp::Fixed, Width));
+  }
+
+  template<typename T>
+  static void assertValid(const T &data) {
+    assert(data >= 0 && "cannot encode signed integers");
+    assert(llvm::isUInt<Width>(data) &&
+           "data value does not fit in the given bit width");
+  }
+};
+
+/// Represents a variable-width value in a bitcode record.
+///
+/// The \p Width parameter should include the continuation bit.
+///
+/// Note that the LLVM bitcode format only supports unsigned values.
+template<unsigned Width>
+class BCVBR : public impl::BCField<> {
+  static_assert(Width >= 2, "width does not have room for continuation bit");
+
+public:
+  static void emitOp(llvm::BitCodeAbbrev &abbrev) {
+    abbrev.Add(llvm::BitCodeAbbrevOp(llvm::BitCodeAbbrevOp::VBR, Width));
+  }
+
+  template<typename T>
+  static void assertValid(const T &data) {
+    assert(data >= 0 && "cannot encode signed integers");
+  }
+};
+
+/// Represents a character encoded in LLVM's Char6 encoding.
+///
+/// This format is suitable for encoding decimal numbers (without signs or
+/// exponents) and C identifiers (without dollar signs), but not much else.
+///
+/// \sa http://llvm.org/docs/BitCodeFormat.html#char6-encoded-value
+class BCChar6 : public impl::BCField<> {
+public:
+  static void emitOp(llvm::BitCodeAbbrev &abbrev) {
+    abbrev.Add(llvm::BitCodeAbbrevOp(llvm::BitCodeAbbrevOp::Char6));
+  }
+
+  template<typename T>
+  static void assertValid(const T &data) {
+    assert(llvm::BitCodeAbbrevOp::isChar6(data) && "invalid Char6 data");
+  }
+
+  template<typename T>
+  char convert(T rawValue) {
+    return static_cast<char>(rawValue);
+  }
+};
+
+/// Represents an untyped blob of bytes.
+///
+/// If present, this must be the last field in a record.
+class BCBlob : public impl::BCField<true> {
+public:
+  static void emitOp(llvm::BitCodeAbbrev &abbrev) {
+    abbrev.Add(llvm::BitCodeAbbrevOp(llvm::BitCodeAbbrevOp::Blob));
+  }
+};
+
+/// Represents an array of some other type.
+///
+/// If present, this must be the last field in a record.
+template<typename Element>
+class BCArray : public impl::BCField<true> {
+  static_assert(!Element::IS_COMPOUND, "arrays can only contain scalar types");
+public:
+  static void emitOp(llvm::BitCodeAbbrev &abbrev) {
+    abbrev.Add(llvm::BitCodeAbbrevOp(llvm::BitCodeAbbrevOp::Array));
+    Element::emitOp(abbrev);
+  }
+};
+
+
+namespace impl {
+  /// Attaches the last field to an abbreviation.
+  ///
+  /// This is the base case for \c emitOps.
+  ///
+  /// \sa BCRecordLayout::emitAbbrev
+  template<typename Last>
+  static void emitOps(llvm::BitCodeAbbrev &abbrev) {
+    Last::emitOp(abbrev);
+  }
+
+  /// Attaches fields to an abbreviation.
+  ///
+  /// This is the recursive case for \c emitOps.
+  ///
+  /// \sa BCRecordLayout::emitAbbrev
+  template<typename First, typename Next, typename ...Rest>
+  static void emitOps(llvm::BitCodeAbbrev &abbrev) {
+    static_assert(!First::IS_COMPOUND,
+                  "arrays and blobs may not appear in the middle of a record");
+    First::emitOp(abbrev);
+    emitOps<Next, Rest...>(abbrev);
+  }
+
+
+  /// Helper class for dealing with a scalar element in the middle of a record.
+  ///
+  /// \sa BCRecordLayout
+  template<typename First, typename... Fields>
+  class BCRecordCoding {
+  public:
+    template <typename BufferTy, typename FirstData, typename... Data>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, FirstData data, Data... rest) {
+      static_assert(!First::IS_COMPOUND,
+                    "arrays and blobs may not appear in the middle of a record");
+      First::assertValid(data);
+      buffer.push_back(data);
+      BCRecordCoding<Fields...>::emit(out, buffer, abbrCode, rest...);
+    }
+
+    template <typename ElementTy, typename FirstData, typename... Data>
+    static void read(ArrayRef<ElementTy> buffer,
+                     FirstData &data, Data &&...rest) {
+      assert(!buffer.empty() && "too few elements in buffer");
+      data = First::convert(buffer.front());
+      BCRecordCoding<Fields...>::read(buffer.slice(1),
+                                      std::forward<Data>(rest)...);
+    }
+
+    template <typename ElementTy, typename... Data>
+    static void read(ArrayRef<ElementTy> buffer,
+                     NoneType, Data &&...rest) {
+      assert(!buffer.empty() && "too few elements in buffer");
+      BCRecordCoding<Fields...>::read(buffer.slice(1),
+                                      std::forward<Data>(rest)...);
+    }
+  };
+
+  /// Helper class for dealing with a scalar element at the end of a record.
+  ///
+  /// This has a separate implementation because up until now we've only been
+  /// \em building the record (into a data buffer), and now we need to hand it
+  /// off to the BitstreamWriter to be emitted.
+  ///
+  /// \sa BCRecordLayout
+  template<typename Last>
+  class BCRecordCoding<Last> {
+  public:
+    template <typename BufferTy, typename LastData>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, LastData data) {
+      static_assert(!Last::IS_COMPOUND,
+                    "arrays and blobs need special handling");
+      Last::assertValid(data);
+      buffer.push_back(data);
+      out.EmitRecordWithAbbrev(abbrCode, buffer);
+    }
+
+    template <typename ElementTy, typename LastData>
+    static void read(ArrayRef<ElementTy> buffer, LastData &data) {
+      assert(buffer.size() == 1 && "record data does not match layout");
+      data = Last::convert(buffer.front());
+    }
+
+    template <typename ElementTy>
+    static void read(ArrayRef<ElementTy> buffer, NoneType) {
+      assert(buffer.size() == 1 && "record data does not match layout");
+      (void)buffer;
+    }
+
+    template <typename ElementTy>
+    static void read(ArrayRef<ElementTy> buffer) = delete;
+  };
+
+  /// Helper class for dealing with an array at the end of a record.
+  ///
+  /// \sa BCRecordLayout::emitRecord
+  template<typename EleTy>
+  class BCRecordCoding<BCArray<EleTy>> {
+  public:
+    template <typename BufferTy>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, StringRef arrayData) {
+      // FIXME: validate array data.
+      out.EmitRecordWithArray(abbrCode, buffer, arrayData);
+    }
+
+    template <typename BufferTy, typename ArrayTy>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, const ArrayTy &arrayData) {
+#ifndef NDEBUG
+      for (auto &item : arrayData)
+        EleTy::assertValid(item);
+#endif
+      buffer.reserve(buffer.size() + arrayData.size());
+      std::copy(arrayData.begin(), arrayData.end(),
+                std::back_inserter(buffer));
+      out.EmitRecordWithAbbrev(abbrCode, buffer);
+    }
+
+    template <typename BufferTy, typename FirstData, typename ...RestData>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, FirstData firstData,
+                     RestData... restData) {
+      std::array<FirstData, 1+sizeof...(restData)> arrayData{ {
+        firstData,
+        restData...
+      } };
+      emit(out, buffer, abbrCode, arrayData);
+    }
+
+    template <typename BufferTy>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, NoneType) {
+      out.EmitRecordWithAbbrev(abbrCode, buffer);
+    }
+
+    template <typename ElementTy>
+    static void read(ArrayRef<ElementTy> buffer, ArrayRef<ElementTy> &rawData) {
+      rawData = buffer;
+    }
+
+    template <typename ElementTy, typename ArrayTy>
+    static void read(ArrayRef<ElementTy> buffer, ArrayTy &array) {
+      array.append(llvm::map_iterator(buffer.begin(), ElementTy::convert),
+                   llvm::map_iterator(buffer.end(), ElementTy::convert));
+    }
+
+    template <typename ElementTy>
+    static void read(ArrayRef<ElementTy> buffer, NoneType) {
+      (void)buffer;
+    }
+
+    template <typename ElementTy>
+    static void read(ArrayRef<ElementTy> buffer) = delete;
+  };
+
+  /// Helper class for dealing with a blob at the end of a record.
+  ///
+  /// \sa BCRecordLayout
+  template<>
+  class BCRecordCoding<BCBlob> {
+  public:
+    template <typename BufferTy>
+    static void emit(llvm::BitstreamWriter &out, BufferTy &buffer,
+                     unsigned abbrCode, StringRef blobData) {
+      out.EmitRecordWithBlob(abbrCode, buffer, blobData);
+    }
+
+    template <typename ElementTy>
+    static void read(ArrayRef<ElementTy> buffer) {
+      (void)buffer;
+    }
+
+    /// Blob data is not stored in the buffer if you are using the correct
+    /// accessor; this method should not be used.
+    template <typename ElementTy, typename DataTy>
+    static void read(ArrayRef<ElementTy> buffer, DataTy &data) = delete;
+  };
+
+  /// A type trait whose \c type field is the last of its template parameters.
+  template<typename First, typename ...Rest>
+  struct last_type {
+    using type = typename last_type<Rest...>::type;
+  };
+
+  template<typename Last>
+  struct last_type<Last> {
+    using type = Last;
+  };
+
+  /// A type trait whose \c value field is \c true if the last type is BCBlob.
+  template<typename ...Types>
+  using has_blob = std::is_same<BCBlob, typename last_type<int, Types...>::type>;
+
+  /// A type trait whose \c value field is \c true if the given type is a
+  /// BCArray (of any element kind).
+  template <typename T>
+  struct is_array {
+  private:
+    template <typename E>
+    static bool check(BCArray<E> *);
+    static int check(...);
+
+  public:
+    typedef bool value_type;
+    static constexpr bool value =
+      !std::is_same<decltype(check((T*)nullptr)),
+                    decltype(check(false))>::value;
+  };
+
+  /// A type trait whose \c value field is \c true if the last type is a
+  /// BCArray (of any element kind).
+  template<typename ...Types>
+  using has_array = is_array<typename last_type<int, Types...>::type>;
+} // end namespace impl
+
+/// Represents a single bitcode record type.
+///
+/// This class template is meant to be instantiated and then given a name,
+/// so that from then on that name can be used 
+template<typename IDField, typename... Fields>
+class BCGenericRecordLayout {
+  llvm::BitstreamWriter &Out;
+
+public:
+  /// The abbreviation code used for this record in the current block.
+  ///
+  /// Note that this is not the same as the semantic record code, which is the
+  /// first field of the record.
+  const unsigned AbbrevCode;
+
+  /// Create a layout and register it with the given bitstream writer.
+  explicit BCGenericRecordLayout(llvm::BitstreamWriter &out)
+    : Out(out), AbbrevCode(emitAbbrev(out)) {}
+
+  /// Emit a record to the bitstream writer, using the given buffer for scratch
+  /// space.
+  ///
+  /// Note that even fixed arguments must be specified here.
+  template <typename BufferTy, typename... Data>
+  void emit(BufferTy &buffer, unsigned recordID, Data... data) const {
+    emitRecord(Out, buffer, AbbrevCode, recordID, data...);
+  }
+
+  /// Registers this record's layout with the bitstream reader.
+  ///
+  /// \returns The abbreviation code for the newly-registered record type.
+  static unsigned emitAbbrev(llvm::BitstreamWriter &out) {
+    auto abbrev = std::make_shared<BitCodeAbbrev>();
+    impl::emitOps<IDField, Fields...>(*abbrev);
+    return out.EmitAbbrev(abbrev);
+  }
+
+  /// Emit a record identified by \p abbrCode to bitstream reader \p out, using
+  /// \p buffer for scratch space.
+  ///
+  /// Note that even fixed arguments must be specified here. Blobs are passed
+  /// as StringRefs, while arrays can be passed inline, as aggregates, or as
+  /// pre-encoded StringRef data. Skipped values and empty arrays should use
+  /// the special Nothing value.
+  template <typename BufferTy, typename... Data>
+  static void emitRecord(llvm::BitstreamWriter &out, BufferTy &buffer,
+                         unsigned abbrCode, unsigned recordID, Data... data) {
+    static_assert(sizeof...(data) <= sizeof...(Fields) ||
+                  impl::has_array<Fields...>::value,
+                  "Too many record elements");
+    static_assert(sizeof...(data) >= sizeof...(Fields),
+                  "Too few record elements");
+    buffer.clear();
+    impl::BCRecordCoding<IDField, Fields...>::emit(out, buffer, abbrCode,
+                                                   recordID, data...);
+  }
+
+  /// Extract record data from \p buffer into the given data fields.
+  ///
+  /// Note that even fixed arguments must be specified here. Pass \c Nothing
+  /// if you don't care about a particular parameter. Blob data is not included
+  /// in the buffer and should be handled separately by the caller.
+  template <typename ElementTy, typename... Data>
+  static void readRecord(ArrayRef<ElementTy> buffer, Data &&... data) {
+    static_assert(sizeof...(data) <= sizeof...(Fields),
+                  "Too many record elements");
+    static_assert(sizeof...(Fields) <=
+                  sizeof...(data) + impl::has_blob<Fields...>::value,
+                  "Too few record elements");
+    return impl::BCRecordCoding<Fields...>::read(buffer,
+                                                 std::forward<Data>(data)...);
+  }
+
+  /// Extract record data from \p buffer into the given data fields.
+  ///
+  /// Note that even fixed arguments must be specified here. Pass \c Nothing
+  /// if you don't care about a particular parameter. Blob data is not included
+  /// in the buffer and should be handled separately by the caller.
+  template <typename BufferTy, typename... Data>
+  static void readRecord(BufferTy &buffer, Data &&... data) {
+    return readRecord(llvm::makeArrayRef(buffer), std::forward<Data>(data)...);
+  }
+};
+
+/// A record with a fixed record code.
+template<unsigned RecordCode, typename... Fields>
+class BCRecordLayout : public BCGenericRecordLayout<BCLiteral<RecordCode>,
+                                                    Fields...> {
+  using Base = BCGenericRecordLayout<BCLiteral<RecordCode>, Fields...>;
+public:
+  enum : unsigned {
+    /// The record code associated with this layout.
+    Code = RecordCode
+  };
+
+  /// Create a layout and register it with the given bitstream writer.
+  explicit BCRecordLayout(llvm::BitstreamWriter &out) : Base(out) {}
+
+  /// Emit a record to the bitstream writer, using the given buffer for scratch
+  /// space.
+  ///
+  /// Note that even fixed arguments must be specified here.
+  template <typename BufferTy, typename... Data>
+  void emit(BufferTy &buffer, Data... data) const {
+    Base::emit(buffer, RecordCode, data...);
+  }
+
+  /// Emit a record identified by \p abbrCode to bitstream reader \p out, using
+  /// \p buffer for scratch space.
+  ///
+  /// Note that even fixed arguments must be specified here. Currently, arrays
+  /// and blobs can only be passed as StringRefs.
+  template <typename BufferTy, typename... Data>
+  static void emitRecord(llvm::BitstreamWriter &out, BufferTy &buffer,
+                         unsigned abbrCode, Data... data) {
+    Base::emitRecord(out, buffer, abbrCode, RecordCode, data...);
+  }
+};
+
+/// RAII object to pair entering and exiting a sub-block.
+class BCBlockRAII {
+  llvm::BitstreamWriter &Writer;
+public:
+  BCBlockRAII(llvm::BitstreamWriter &writer, unsigned blockID,
+              unsigned abbrevLen)
+    : Writer(writer) {
+    writer.EnterSubblock(blockID, abbrevLen);
+  }
+
+  ~BCBlockRAII() {
+    Writer.ExitBlock();
+  }
+};
+
+} // end namespace llvm
+
+#endif
--- a/lib/CodeGen/AsmPrinter/DwarfUnit.cp
+++ b/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
@@ -987,6 +989,13 @@
   if (!Name.empty())
     addString(Buffer, dwarf::DW_AT_name, Name);
 
+  // For Swift, mangled names are put into DW_AT_linkage_name; human-readable
+  // names are emitted put into DW_AT_name and the accelerator table.
+  if ((CTy->getRuntimeLang() == dwarf::DW_LANG_Swift ||
+       CTy->getRuntimeLang() == dwarf::DW_LANG_PLI) &&
+      CTy->getRawIdentifier())
+    addString(Buffer, dwarf::DW_AT_linkage_name, CTy->getIdentifier());
+
   if (Tag == dwarf::DW_TAG_enumeration_type ||
       Tag == dwarf::DW_TAG_class_type || Tag == dwarf::DW_TAG_structure_type ||
       Tag == dwarf::DW_TAG_union_type) {
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -938,7 +938,6 @@
     PATTERN "*.inc"
     # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by "*.def"
     PATTERN "CMakeFiles" EXCLUDE
-    PATTERN "config.h" EXCLUDE
     PATTERN ".svn" EXCLUDE
 
 
--- a/include/llvm/CodeGen/MachineBasicBlock.h
+++ b/include/llvm/CodeGen/MachineBasicBlock.h
@@ -225,6 +225,14 @@ class MachineBasicBlock
     return make_range(getFirstTerminator(), end());
   }
 
+  /// Returns a range that iterates over the phis in the basic block.
+  inline iterator_range<iterator> phis() {
+    return make_range(begin(), getFirstNonPHI());
+  }
+  inline iterator_range<const_iterator> phis() const {
+    return const_cast<MachineBasicBlock *>(this)->phis();
+  }
+
   // Machine-CFG iterators
   using pred_iterator = std::vector<MachineBasicBlock *>::iterator;
   using const_pred_iterator = std::vector<MachineBasicBlock *>::const_iterator;
--- a/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
+++ b/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
@@ -389,12 +389,8 @@ class SSAUpdaterImpl {
   /// FindExistingPHI - Look through the PHI nodes in a block to see if any of
   /// them match what is needed.
   void FindExistingPHI(BlkT *BB, BlockListTy *BlockList) {
-    for (typename BlkT::iterator BBI = BB->begin(), BBE = BB->end();
-         BBI != BBE; ++BBI) {
-      PhiT *SomePHI = Traits::InstrIsPHI(&*BBI);
-      if (!SomePHI)
-        break;
-      if (CheckIfPHIMatches(SomePHI)) {
+    for (auto &SomePHI : BB->phis()) {
+      if (CheckIfPHIMatches(&SomePHI)) {
         RecordMatchingPHIs(BlockList);
         break;
       }
--- a/lib/CodeGen/MachinePipeliner.cpp
+++ b/lib/CodeGen/MachinePipeliner.cpp
@@ -808,11 +808,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
   // because we don't know how to maintain subreg information in the
   // VMap structure.
   MachineBasicBlock *MBB = L.getHeader();
-  for (MachineBasicBlock::iterator BBI = MBB->instr_begin(),
-                                   BBE = MBB->getFirstNonPHI();
-       BBI != BBE; ++BBI)
-    for (unsigned i = 1; i != BBI->getNumOperands(); i += 2)
-      if (BBI->getOperand(i).getSubReg() != 0)
+  for (auto &PHI : MBB->phis())
+    for (unsigned i = 1; i != PHI.getNumOperands(); i += 2)
+      if (PHI.getOperand(i).getSubReg() != 0)
         return false;
 
   return true;
@@ -2924,10 +2922,8 @@ void SwingSchedulerDAG::splitLifetimes(MachineBasicBlock *KernelBB,
                                        MBBVectorTy &EpilogBBs,
                                        SMSchedule &Schedule) {
   const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();
-  for (MachineBasicBlock::iterator BBI = KernelBB->instr_begin(),
-                                   BBF = KernelBB->getFirstNonPHI();
-       BBI != BBF; ++BBI) {
-    unsigned Def = BBI->getOperand(0).getReg();
+  for (auto &PHI : KernelBB->phis()) {
+    unsigned Def = PHI.getOperand(0).getReg();
     // Check for any Phi definition that used as an operand of another Phi
     // in the same block.
     for (MachineRegisterInfo::use_instr_iterator I = MRI.use_instr_begin(Def),
@@ -2935,7 +2931,7 @@ void SwingSchedulerDAG::splitLifetimes(MachineBasicBlock *KernelBB,
          I != E; ++I) {
       if (I->isPHI() && I->getParent() == KernelBB) {
         // Get the loop carried definition.
-        unsigned LCDef = getLoopPhiReg(*BBI, KernelBB);
+        unsigned LCDef = getLoopPhiReg(PHI, KernelBB);
         if (!LCDef)
           continue;
         MachineInstr *MI = MRI.getVRegDef(LCDef);
@@ -3249,13 +3245,11 @@ void SwingSchedulerDAG::rewritePhiValues(MachineBasicBlock *NewBB,
                                          SMSchedule &Schedule,
                                          ValueMapTy *VRMap,
                                          InstrMapTy &InstrMap) {
-  for (MachineBasicBlock::iterator BBI = BB->instr_begin(),
-                                   BBE = BB->getFirstNonPHI();
-       BBI != BBE; ++BBI) {
+  for (auto &PHI : BB->phis()) {
     unsigned InitVal = 0;
     unsigned LoopVal = 0;
-    getPhiRegs(*BBI, BB, InitVal, LoopVal);
-    unsigned PhiDef = BBI->getOperand(0).getReg();
+    getPhiRegs(PHI, BB, InitVal, LoopVal);
+    unsigned PhiDef = PHI.getOperand(0).getReg();
 
     unsigned PhiStage =
         (unsigned)Schedule.stageScheduled(getSUnit(MRI.getVRegDef(PhiDef)));
@@ -3269,7 +3263,7 @@ void SwingSchedulerDAG::rewritePhiValues(MachineBasicBlock *NewBB,
           getPrevMapVal(StageNum - np, PhiStage, LoopVal, LoopStage, VRMap, BB);
       if (!NewVal)
         NewVal = InitVal;
-      rewriteScheduledInstr(NewBB, Schedule, InstrMap, StageNum - np, np, &*BBI,
+      rewriteScheduledInstr(NewBB, Schedule, InstrMap, StageNum - np, np, &PHI,
                             PhiDef, NewVal);
     }
   }
--- a/unittests/CodeGen/MachineInstrTest.cpp
+++ b/unittests/CodeGen/MachineInstrTest.cpp
@@ -8,6 +8,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
 #include "llvm/CodeGen/MachineFunction.h"
 #include "llvm/CodeGen/MachineModuleInfo.h"
 #include "llvm/CodeGen/TargetFrameLowering.h"
@@ -244,4 +245,71 @@ TEST(MachineInstrExpressionTraitTest, IsEqualAgreesWithGetHashValue) {
 
   checkHashAndIsEqualMatch(VD2PU, VD2PD);
 }
+
+TEST(MachineBasicBlockTest, PhiRange) {
+  auto MF = createMachineFunction();
+
+  // Create the main block.
+  auto BB = MF->CreateMachineBasicBlock();
+
+  // Create some predecessors of it.
+  auto BB1 = MF->CreateMachineBasicBlock();
+  BB1->addSuccessor(BB);
+  auto BB2 = MF->CreateMachineBasicBlock();
+  BB2->addSuccessor(BB);
+
+  // Make sure this doesn't crash if there are no phis.
+  for (auto &PN : BB->phis()) {
+    (void)PN;
+    ASSERT_TRUE(false) << "empty block should have no phis";
+  }
+
+  // Make it a cycle.
+  BB->addSuccessor(BB);
+
+  // Now insert some PHI nodes.
+  MCOperandInfo OpInfo[] = { { -1, 0, MCOI::OPERAND_UNKNOWN, 0} };
+  MCInstrDesc PHIMCID = {
+      TargetOpcode::PHI, 1, 1, 0, 0,
+      (1ULL << MCID::Pseudo) | (1ULL << MCID::Variadic), 0,
+      nullptr, nullptr, OpInfo, -1, nullptr};
+  auto P1 = BuildMI(*BB, BB->end(), DebugLoc(), PHIMCID, -101);
+  auto P2 = BuildMI(*BB, BB->end(), DebugLoc(), PHIMCID, -102);
+  auto P3 = BuildMI(*BB, BB->end(), DebugLoc(), PHIMCID, -103);
+
+  // A non-PHI node.
+  MCInstrDesc ImpDefMCID = {
+      TargetOpcode::IMPLICIT_DEF, 1, 1, 0, 0,
+      (1ULL << MCID::Pseudo), 0,
+      nullptr, nullptr, OpInfo, -1, nullptr};
+  BuildMI(*BB, BB->end(), DebugLoc(), ImpDefMCID, -104);
+
+  // Now wire up the incoming values that are interesting.
+  P1.addReg(-102).addMBB(BB);
+  P2.addReg(-101).addMBB(BB);
+  P3.addReg(-104).addMBB(BB);
+
+  // Finally, let's iterate them, which is the thing we're trying to test.
+  // We'll use this to wire up the rest of the incoming values.
+  for (auto &PN : BB->phis()) {
+    EXPECT_TRUE(PN.isPHI());
+    PN.addOperand(*MF, MachineOperand::CreateReg(-100, /*isDef*/ false));
+    PN.addOperand(*MF, MachineOperand::CreateMBB(BB1));
+    PN.addOperand(*MF, MachineOperand::CreateReg(-100, /*isDef*/ false));
+    PN.addOperand(*MF, MachineOperand::CreateMBB(BB2));
+  }
+
+  // Test that we can use const iterators and generally that the iterators
+  // behave like iterators.
+  MachineBasicBlock::const_iterator CI;
+  CI = BB->phis().begin();
+  EXPECT_NE(CI, BB->phis().end());
+
+  // And iterate a const range.
+  for (const auto &PN : const_cast<const MachineBasicBlock *>(BB)->phis()) {
+    EXPECT_EQ(BB, PN.getOperand(2).getMBB());
+    EXPECT_EQ(BB1, PN.getOperand(4).getMBB());
+    EXPECT_EQ(BB2, PN.getOperand(6).getMBB());
+  }
+}
 } // end namespace

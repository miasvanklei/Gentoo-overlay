--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/llvm-strings/CMakeLists.txt	2016-10-06 23:00:46.909275807 +0200
@@ -0,0 +1,9 @@
+set(LLVM_LINK_COMPONENTS
+  Object
+  Support
+  )
+
+add_llvm_tool(llvm-strings
+  llvm-strings.cpp
+  Error.cpp
+  )
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/llvm-strings/Error.cpp	2016-10-06 22:57:15.282265388 +0200
@@ -0,0 +1,57 @@
+//===- Error.cpp - system_error extensions for llvm-readobj -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This defines a new error_category for the llvm-readobj tool.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Error.h"
+#include "llvm/Support/ErrorHandling.h"
+
+using namespace llvm;
+
+namespace {
+// FIXME: This class is only here to support the transition to llvm::Error. It
+// will be removed once this transition is complete. Clients should prefer to
+// deal with the Error value directly, rather than converting to error_code.
+class _readobj_error_category : public std::error_category {
+public:
+  const char* name() const LLVM_NOEXCEPT override;
+  std::string message(int ev) const override;
+};
+} // namespace
+
+const char *_readobj_error_category::name() const LLVM_NOEXCEPT {
+  return "llvm.readobj";
+}
+
+std::string _readobj_error_category::message(int EV) const {
+  switch (static_cast<readobj_error>(EV)) {
+  case readobj_error::success: return "Success";
+  case readobj_error::file_not_found:
+    return "No such file.";
+  case readobj_error::unsupported_file_format:
+    return "The file was not recognized as a valid object file.";
+  case readobj_error::unrecognized_file_format:
+    return "Unrecognized file type.";
+  case readobj_error::unsupported_obj_file_format:
+    return "Unsupported object file format.";
+  case readobj_error::unknown_symbol:
+    return "Unknown symbol.";
+  }
+  llvm_unreachable("An enumerator of readobj_error does not have a message "
+                   "defined.");
+}
+
+namespace llvm {
+const std::error_category &readobj_category() {
+  static _readobj_error_category o;
+  return o;
+}
+} // namespace llvm
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/llvm-strings/Error.h	2016-10-06 22:57:35.157266366 +0200
@@ -0,0 +1,35 @@
+//===- Error.h - system_error extensions for llvm-readobj -------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This declares a new error_category for the llvm-readobj tool.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TOOLS_LLVM_READOBJ_ERROR_H
+#define LLVM_TOOLS_LLVM_READOBJ_ERROR_H
+
+#include <system_error>
+
+namespace llvm {
+const std::error_category &readobj_category();
+
+enum class readobj_error {
+  success = 0,
+  file_not_found,
+  unsupported_file_format,
+  unrecognized_file_format,
+  unsupported_obj_file_format,
+  unknown_symbol
+};
+
+inline std::error_code make_error_code(readobj_error e) {
+  return std::error_code(static_cast<int>(e), readobj_category());
+}
+}
+#endif
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/llvm-strings/llvm-strings.cpp	2016-10-06 22:56:37.307263518 +0200
@@ -0,0 +1,271 @@
+#include "llvm/Object/Archive.h"
+#include "llvm/Object/MachO.h"
+#include "llvm/Object/MachOUniversal.h"
+#include "llvm/Object/ObjectFile.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Format.h"
+#include "llvm/Support/ManagedStatic.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/PrettyStackTrace.h"
+#include "llvm/Support/Signals.h"
+#include "llvm/Support/raw_ostream.h"
+#include "Error.h"
+#include <cstdint>
+#include <string>
+
+using namespace llvm;
+using namespace object;
+// bool -a --all scan the entire file
+static cl::opt<bool> ScanEntireFile("all", cl::desc("Scan the entire file"),
+                                    cl::init(true));
+static cl::alias ScanEntireFileShort("a", cl::aliasopt(ScanEntireFile));
+
+// bool -d --data scan only the data sections
+static cl::opt<bool>
+    ScanSectionDataOnly("data", cl::desc("Scan the data sections only"),
+                        cl::init(false));
+static cl::alias ScanSectionDataOnlyShort("d",
+                                          cl::aliasopt(ScanSectionDataOnly));
+
+// bool -f  print-file-name
+static cl::opt<bool> PrintFileName("print-file-name",
+                                   cl::desc("Print the name of the file"),
+                                   cl::init(false));
+static cl::alias PrintFileNameShort("f", cl::aliasopt(PrintFileName));
+
+// bool -w --include-all-whitespace
+static cl::opt<bool>
+    IncludeAllWhiteSpace("include-all-whitespace",
+                         cl::desc("Include all whitespace as valid"),
+                         cl::init(false));
+static cl::alias IncludeAllWhiteSpaceShort("w",
+                                           cl::aliasopt(IncludeAllWhiteSpace));
+
+// int -n --bytes
+static cl::opt<int> LeastLength("bytes",
+                                cl::desc("Print the string having length:"),
+                                cl::init(4));
+static cl::alias LeastLengthShort("n", cl::aliasopt(LeastLength));
+
+enum RadixTy { octal = 8, decimal = 10, hexadecimal = 16 };
+static cl::opt<RadixTy>
+    Radix("-radix",
+          cl::desc("Print size in radix. Only 8, 10, and 16 are valid"),
+          cl::values(clEnumValN(octal, "o", "Print size in octal"),
+                     clEnumValN(decimal, "d", "Print size in decimal"),
+                     clEnumValN(hexadecimal, "x", "Print size in hexadecimal"),
+                     clEnumValEnd),
+          cl::init(decimal));
+
+static cl::alias RadixShort("t", cl::aliasopt(Radix));
+
+// alias -o alias for --radix=o
+static cl::opt<bool> RadixOctal("o", cl::desc("Print size in octal:"),
+                                cl::init(false));
+static bool PrintAddress = false;
+
+// FIXME string -T specify binary file format
+
+// enum -e s,S,b,l,B,L encoding
+enum EncodingTy { U8 = 8, U16 = 16, U32 = 32 };
+static cl::opt<EncodingTy> Encoding(
+    "encoding", cl::desc("Print string in encoding:"),
+    cl::values(clEnumValN(U8, "s", "7-bit"), clEnumValN(U8, "S", "8-bit"),
+               clEnumValN(U16, "b", "16-bit"), clEnumValN(U16, "l", "16-bit"),
+               clEnumValN(U32, "B", "32-bit"), clEnumValN(U32, "L", "32-bit"),
+               clEnumValEnd),
+    cl::init(U8));
+static cl::alias EncodingShort("e", cl::aliasopt(Encoding));
+
+// input files
+static cl::list<std::string>
+    InputFilenames(cl::Positional, cl::desc("<input files>"), cl::ZeroOrMore);
+
+static const char *ToolName;
+
+namespace llvm {
+
+LLVM_ATTRIBUTE_NORETURN void reportError(Twine Msg) {
+  errs() << "\nError reading file: " << Msg << ".\n";
+  errs().flush();
+  exit(1);
+}
+
+void error(Error EC) {
+  if (!EC)
+    return;
+  handleAllErrors(std::move(EC),
+                  [&](const ErrorInfoBase &EI) { reportError(EI.message()); });
+}
+
+void error(std::error_code EC) {
+  if (!EC)
+    return;
+  reportError(EC.message());
+}
+
+bool relocAddressLess(RelocationRef a, RelocationRef b) {
+  return a.getOffset() < b.getOffset();
+}
+
+} // namespace llvm
+
+static void reportError(StringRef Input, std::error_code EC) {
+  if (Input == "-")
+    Input = "<stdin>";
+
+  reportError(Twine(Input) + ": " + EC.message());
+}
+
+namespace {
+
+template <RadixTy Radix> inline void printAddress(unsigned long long N);
+
+template <> inline void printAddress<RadixTy::octal>(unsigned long long N) {
+  outs() << format("%.8" PRIo64 "", N) << ' ';
+}
+
+template <> inline void printAddress<RadixTy::decimal>(unsigned long long N) {
+  outs() << format("%.8" PRIu64 "", N) << ' ';
+}
+
+template <>
+inline void printAddress<RadixTy::hexadecimal>(unsigned long long N) {
+  outs() << format("%.4" PRIx64 "", N) << ' ';
+}
+
+bool inline isGraph(int C) {
+  return (C <= 255 && C >= 0 && (C == '\t' || ::isprint(C) ||
+                                 (IncludeAllWhiteSpace && ::isspace(C))));
+}
+
+template <typename CharType, RadixTy Radix>
+void printStrings(StringRef file, const CharType *BeginPos,
+                  const CharType *EndPos) {
+  const CharType *Pos = BeginPos, *WordPos = BeginPos;
+  if (EndPos <= BeginPos)
+    return;
+  int Count = 0;
+  CharType CH;
+  std::vector<CharType> Buffer;
+  Buffer.resize(LeastLength);
+  while (Pos + sizeof(CharType) <= EndPos) {
+    CH = *Pos++;
+    if (!isGraph(CH)) {
+      if (Count >= LeastLength)
+        outs() << "\n";
+      Count = 0;
+      WordPos = Pos;
+      continue;
+    }
+    if (Count < LeastLength)
+      Buffer[Count] = CH;
+    if (++Count == LeastLength) {
+      if (PrintFileName)
+        outs() << file << ": ";
+      if (PrintAddress)
+        printAddress<Radix>(WordPos - BeginPos);
+      for (CharType C : Buffer)
+        outs() << (char)C;
+    } else if (Count > LeastLength) {
+      outs() << (char)CH;
+    }
+  }
+}
+
+template <typename CharType>
+inline void printStrings(StringRef file, const CharType *BeginPos,
+                         const CharType *EndPos, RadixTy Radix) {
+  switch (Radix) {
+  case RadixTy::decimal:
+    printStrings<CharType, RadixTy::decimal>(file, BeginPos, EndPos);
+    break;
+  case RadixTy::hexadecimal:
+    printStrings<CharType, RadixTy::hexadecimal>(file, BeginPos, EndPos);
+    break;
+  case RadixTy::octal:
+    printStrings<CharType, RadixTy::octal>(file, BeginPos, EndPos);
+    break;
+  }
+}
+
+} // anonymous namespace
+
+static inline void printStrings(StringRef file, const char *BeginPos,
+                                const char *EndPos, RadixTy Radix) {
+  switch (Encoding) {
+  case U8:
+    printStrings<char>(file, BeginPos, EndPos, Radix);
+    break;
+  case U16:
+    printStrings<char16_t>(file, reinterpret_cast<const char16_t *>(BeginPos),
+                           reinterpret_cast<const char16_t *>(EndPos), Radix);
+    break;
+  case U32:
+    printStrings<char32_t>(file, reinterpret_cast<const char32_t *>(BeginPos),
+                           reinterpret_cast<const char32_t *>(EndPos), Radix);
+    break;
+  }
+}
+
+static void printFileObjectStrings(ObjectFile *Obj) {
+  for (const SectionRef &Section : Obj->sections())
+    if (Section.isData()) {
+      uint64_t size = Section.getSize();
+      uint64_t addr = Section.getAddress();
+      printStrings(Obj->getFileName(), (const char *)addr,
+                   (const char *)addr + size, Radix);
+    }
+}
+
+static void printBinaryFileStrings(StringRef File) {
+
+  // Attempt to open the binary.
+  Expected<OwningBinary<Binary>> BinaryOrErr = createBinary(File);
+  if (!BinaryOrErr)
+    reportError(File, errorToErrorCode(BinaryOrErr.takeError()));
+  Binary &Binary = *BinaryOrErr.get().getBinary();
+
+  if (ObjectFile *Obj = dyn_cast<ObjectFile>(&Binary))
+    printFileObjectStrings(Obj);
+  else
+    reportError(File, make_error_code(readobj_error::unrecognized_file_format));
+}
+
+static void printRawFileStrings(StringRef file) {
+  ErrorOr<std::unique_ptr<MemoryBuffer>> BufferOrErr =
+      MemoryBuffer::getFileOrSTDIN(file);
+  if (std::error_code EC = BufferOrErr.getError()) {
+    errs() << ToolName << ": " << file << ": " << EC.message() << ".\n";
+  } else {
+    printStrings(file, (*BufferOrErr)->getBufferStart(),
+                 (*BufferOrErr)->getBufferEnd(), Radix);
+  }
+}
+
+int main(int argc, char *argv[]) {
+  // Print a stack trace if we signal out.
+  sys::PrintStackTraceOnErrorSignal(argv[0]);
+  PrettyStackTraceProgram X(argc, argv);
+
+  llvm_shutdown_obj Y; // Call llvm_shutdown() on exit.
+  cl::ParseCommandLineOptions(argc, argv, "llvm object string dumper\n");
+
+  ToolName = argv[0];
+  if (RadixOctal.getNumOccurrences() || Radix.getNumOccurrences())
+    PrintAddress = true;
+  if (RadixOctal)
+    Radix = octal;
+  if (ScanSectionDataOnly.getNumOccurrences())
+    ScanSectionDataOnly = true;
+  if (LeastLength <= 0)
+    LeastLength = 1;
+
+  if (InputFilenames.size() == 0)
+    InputFilenames.push_back("-");
+
+  std::for_each(InputFilenames.begin(), InputFilenames.end(),
+                ScanSectionDataOnly ? printBinaryFileStrings
+                                    : printRawFileStrings);
+}

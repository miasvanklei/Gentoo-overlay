diff --git a/ELF/Config.h b/ELF/Config.h
index a46a8a8..5157bbf 100644
--- a/ELF/Config.h
+++ b/ELF/Config.h
@@ -62,6 +62,7 @@ struct VersionDefinition {
   llvm::StringRef Name;
   size_t Id;
   std::vector<SymbolVersion> Globals;
+  std::vector<SymbolVersion> Locals;
   size_t NameOff; // Offset in string table.
 }; 
 
diff --git a/ELF/Symbols.h b/ELF/Symbols.h
index 192433e..aec12e9 100644
--- a/ELF/Symbols.h
+++ b/ELF/Symbols.h
@@ -406,6 +406,9 @@ struct Symbol {
   // Version definition index.
   uint16_t VersionId;
 
+  // If a symbol has been processed.
+  bool VersionScriptProcessed = false;
+
   // Symbol visibility. This is the computed minimum visibility of all
   // observed non-DSO symbols.
   unsigned Visibility : 2;
diff --git a/ELF/SymbolTable.cpp b/ELF/SymbolTable.cpp
index d7e7a94..064285b 100644
--- a/ELF/SymbolTable.cpp
+++ b/ELF/SymbolTable.cpp
@@ -635,15 +635,21 @@ SymbolTable<ELFT>::findAllDemangled(StringRef GlobPat) {
 // but just specifies symbols visibilities. We assume that the script was
 // in the form of { global: foo; bar; local *; }. So, local is default.
 // In this function, we make specified symbols global.
-template <class ELFT> void SymbolTable<ELFT>::handleAnonymousVersion() {
-  for (SymbolVersion &Ver : Config->VersionScriptGlobals) {
+template <class ELFT> void SymbolTable<ELFT>::handleAnonymousVersion(
+            std::vector<SymbolVersion> &symbolversions, size_t Version) {
+  for (SymbolVersion &Ver : symbolversions) {
     if (hasWildcard(Ver.Name)) {
-      for (SymbolBody *B : findAll(Ver.Name))
-        B->symbol()->VersionId = VER_NDX_GLOBAL;
-      continue;
+      for (SymbolBody *B : findAll(Ver.Name)) {
+         if (Version == VER_NDX_GLOBAL)
+           B->symbol()->VersionScriptProcessed = true;
+         else if (!B->symbol()->VersionScriptProcessed)
+           B->symbol()->VersionId = Version;
+      }
+    }
+    else if (SymbolBody *B = find(Ver.Name)) {
+      B->symbol()->VersionId = Version;
+      B->symbol()->VersionScriptProcessed = true;
     }
-    if (SymbolBody *B = find(Ver.Name))
-      B->symbol()->VersionId = VER_NDX_GLOBAL;
   }
 }
 
@@ -697,10 +703,16 @@ void SymbolTable<ELFT>::assignWildcardVersion(SymbolVersion Ver,
 // member of symbols.
 template <class ELFT> void SymbolTable<ELFT>::scanVersionScript() {
   // Handle edge cases first.
-  if (!Config->VersionScriptGlobals.empty()) {
-    handleAnonymousVersion();
+  bool gresult = !Config->VersionScriptGlobals.empty();
+  bool lresult = !Config->VersionScriptLocals.empty();
+
+  if (lresult)
+    handleAnonymousVersion(Config->VersionScriptGlobals, VER_NDX_GLOBAL);
+  if (gresult)
+    handleAnonymousVersion(Config->VersionScriptLocals, VER_NDX_LOCAL);
+
+  if (gresult || lresult)
     return;
-  }
 
   if (Config->VersionDefinitions.empty())
     return;
@@ -711,21 +723,23 @@ template <class ELFT> void SymbolTable<ELFT>::scanVersionScript() {
 
   // First, we assign versions to exact matching symbols,
   // i.e. version definitions not containing any glob meta-characters.
-  for (SymbolVersion &Ver : Config->VersionScriptLocals)
-    assignExactVersion(Ver, VER_NDX_LOCAL, "local");
-  for (VersionDefinition &V : Config->VersionDefinitions)
+  for (VersionDefinition &V : Config->VersionDefinitions) {
     for (SymbolVersion &Ver : V.Globals)
       assignExactVersion(Ver, V.Id, V.Name);
+    for (SymbolVersion &Ver : V.Locals)
+      assignExactVersion(Ver, VER_NDX_LOCAL, "local");
+  }
 
   // Next, we assign versions to fuzzy matching symbols,
   // i.e. version definitions containing glob meta-characters.
   // Note that because the last match takes precedence over previous matches,
   // we iterate over the definitions in the reverse order.
-  for (SymbolVersion &Ver : Config->VersionScriptLocals)
-    assignWildcardVersion(Ver, VER_NDX_LOCAL);
-  for (VersionDefinition &V : llvm::reverse(Config->VersionDefinitions))
+  for (VersionDefinition &V : llvm::reverse(Config->VersionDefinitions)) {
     for (SymbolVersion &Ver : V.Globals)
       assignWildcardVersion(Ver, V.Id);
+    for (SymbolVersion &Ver : V.Locals)
+      assignWildcardVersion(Ver, VER_NDX_LOCAL);
+  }
 }
 
 template class elf::SymbolTable<ELF32LE>;
diff --git a/ELF/SymbolTable.h b/ELF/SymbolTable.h
index 2bf9abc..fc97d8e 100644
--- a/ELF/SymbolTable.h
+++ b/ELF/SymbolTable.h
@@ -102,7 +102,7 @@ private:
   std::vector<SymbolBody *> findAllDemangled(StringRef GlobPat);
 
   void initDemangledSyms();
-  void handleAnonymousVersion();
+  void handleAnonymousVersion(std::vector<SymbolVersion> &symbolversions, size_t Version);
   void assignExactVersion(SymbolVersion Ver, uint16_t VersionId,
                           StringRef VersionName);
   void assignWildcardVersion(SymbolVersion Ver, uint16_t VersionId);
diff --git a/ELF/LinkerScript.cpp b/ELF/LinkerScript.cpp
index a9a5a0b..39c1ad2 100644
--- a/ELF/LinkerScript.cpp
+++ b/ELF/LinkerScript.cpp
@@ -1827,14 +1827,8 @@ void ScriptParser::readAnonymousDeclaration() {
     Config->VersionScriptGlobals = readSymbols();
 
   // Next, read local symbols.
-  if (consume("local:")) {
-    if (consume("*")) {
-      Config->DefaultSymbolVersion = VER_NDX_LOCAL;
-      expect(";");
-    } else {
-      setError("local symbol list for anonymous version is not supported");
-    }
-  }
+  if (consume("local:"))
+    Config->VersionScriptLocals = readSymbols();
   expect("}");
   expect(";");
 }
@@ -1851,15 +1845,9 @@ void ScriptParser::readVersionDeclaration(StringRef VerStr) {
     Config->VersionDefinitions.back().Globals = readSymbols();
 
   // Read local symbols.
-  if (consume("local:")) {
-    if (consume("*")) {
-      Config->DefaultSymbolVersion = VER_NDX_LOCAL;
-      expect(";");
-    } else {
-      for (SymbolVersion V : readSymbols())
-        Config->VersionScriptLocals.push_back(V);
-    }
-  }
+  if (consume("local:"))
+    Config->VersionDefinitions.back().Locals = readSymbols();
+
   expect("}");
 
   // Each version may have a parent version. For example, "Ver2"

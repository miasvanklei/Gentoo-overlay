--- a/ELF/DriverUtils.cpp	2016-07-16 21:16:15.000000000 +0200
+++ b/ELF/DriverUtils.cpp	2016-10-05 23:14:28.135320326 +0200
@@ -119,6 +119,19 @@ opt::InputArgList ELFOptTable::parse(ArrayRef<const char *> Argv) {
 void elf::printHelp(const char *Argv0) {
   ELFOptTable Table;
   Table.PrintHelp(outs(), Argv0, "lld", false);
+  outs() << "\n";
+
+  // Scripts generated by Libtool versions up to at least 2.4.6 (the most
+  // recent version as of March 2017) expect /supported targets:.* elf/ in
+  // a message for the -help option. If it doesn't match, the scripts
+  // assume that the linker doesn't support very basic features such as
+  // shared libraries. Therefore, we need to print out at least "elf".
+  // Here, we print out all the targets that we support.
+  outs() << Argv0 << ": supported targets: "
+         << "elf32-i386 elf32-iamcu elf32-littlearm elf32-powerpc "
+         << "elf32-tradbigmips elf32-tradlittlemips elf32-x86-64 "
+         << "elf64-amdgpu elf64-littleaarch64 elf64-powerpc "
+         << "elf64-tradbigmips elf64-tradlittlemips elf64-x86-64\n";
 }
 
 // Reconstructs command line arguments so that so that you can re-run
--- a/lib/Config/Version.cpp	2016-11-08 21:30:51.463263010 +0100
+++ b/lib/Config/Version.cpp	2016-11-08 21:35:24.520637918 +0100
@@ -39,5 +39,5 @@
 
 // Returns a version string, e.g., "LLD 4.0 (lld/trunk 284614)".
 std::string lld::getLLDVersion() {
-  return "LLD " + std::string(LLD_VERSION_STRING) + getRepository();
+  return "LLD " + std::string(LLD_VERSION_STRING) + getRepository() + " (compatible with GNU linkers)";
 }
--- a/ELF/InputFiles.cpp	2016-11-11 19:48:19.308726806 +0100
+++ b/ELF/InputFiles.cpp	2016-11-11 19:53:59.125750362 +0100
@@ -165,14 +165,17 @@
 }
 
 Optional<MemoryBufferRef> elf::readFile(StringRef Path) {
-  if (Config->Verbose)
-    outs() << Path << "\n";
+  StringRef attempt = "attempt to open ";
 
   auto MBOrErr = MemoryBuffer::getFile(Path);
   if (auto EC = MBOrErr.getError()) {
-    error(EC, "cannot open " + Path);
+    error(EC, attempt + Path + " failed");
     return None;
   }
+  else
+    if (Config->Verbose)
+      outs() << attempt << Path << " succeeded\n";
+
   std::unique_ptr<MemoryBuffer> &MB = *MBOrErr;
   MemoryBufferRef MBRef = MB->getMemBufferRef();
   OwningMBs.push_back(std::move(MB)); // take MB ownership

diff --git a/src/Haskell/Ide/Engine/Plugin/Package.hs b/src/Haskell/Ide/Engine/Plugin/Package.hs
index 7076295b..6bee7dfe 100644
--- a/src/Haskell/Ide/Engine/Plugin/Package.hs
+++ b/src/Haskell/Ide/Engine/Plugin/Package.hs
@@ -17,6 +17,7 @@ import           Data.Bitraversable
 import qualified Data.ByteString as B
 import           Data.Foldable
 import           Data.List
+import qualified Data.Set                      as S
 import qualified Data.HashMap.Strict           as HM
 import qualified Data.Text                     as T
 import qualified Data.Text.Encoding            as T
@@ -301,7 +302,7 @@ editCabalPackage file modulePath pkgName fileMap = do
             -- Add it to the bottom of the dependencies list
             -- TODO: we could sort the depencies and then insert it,
             -- or insert it in order iff the list is already sorted.
-            newDeps = oldDeps ++ [Dependency (mkPackageName (T.unpack dep)) anyVersion]
+            newDeps = oldDeps ++ [Dependency (mkPackageName (T.unpack dep)) anyVersion S.empty]
 
 -- | Provide a code action to add a package to the local package.yaml or cabal file.
 -- Reads from diagnostics the unknown import module path and searches for it on Hoogle.
diff --git a/src/Haskell/Ide/Engine/Support/HieExtras.hs b/src/Haskell/Ide/Engine/Support/HieExtras.hs
index 7b32d124..65fffc45 100644
--- a/src/Haskell/Ide/Engine/Support/HieExtras.hs
+++ b/src/Haskell/Ide/Engine/Support/HieExtras.hs
@@ -331,7 +331,7 @@ gotoModule rfm mn = do
         flushFinderCaches env
         findImportedModule env mn Nothing
       case fr of
-        Found (ModLocation (Just src) _ _) _ -> do
+        Found (ModLocation (Just src) _ _ _) _ -> do
           fp <- reverseMapFile rfm src
 
           let r = Range (Position 0 0) (Position 0 0)
diff --git a/src/Haskell/Ide/Engine/Plugin/Build.hs b/src/Haskell/Ide/Engine/Plugin/Build.hs
index 724bc773..ea16e40b 100644
--- a/src/Haskell/Ide/Engine/Plugin/Build.hs
+++ b/src/Haskell/Ide/Engine/Plugin/Build.hs
@@ -287,7 +287,7 @@ configureStack stackExe = do
     _manyPackages -> readProcess stackExe ["build"] ""
 
 configureCabal :: FilePath -> IO String
-configureCabal cabalExe = readProcess cabalExe ["new-configure"] ""
+configureCabal cabalExe = readProcess cabalExe ["v1-configure"] ""
 
 -----------------------------------------------
 
@@ -368,7 +368,7 @@ buildDirectory = CmdSync $ \(BP m dd c s f mbDir) -> withCommonArgs (CommonParam
   liftIO $ case caMode ca of
     CabalMode -> do
       -- for cabal specifying directory have no sense
-      _ <- readProcess (caCabal ca) ["new-build"] ""
+      _ <- readProcess (caCabal ca) ["v1-build"] ""
       return $ IdeResultOk ()
     StackMode ->
       case mbDir of
@@ -406,7 +406,7 @@ buildTarget = CmdSync $ \(BT m dd c s f component package' compType) -> withComm
   ca <- ask
   liftIO $ case caMode ca of
     CabalMode -> do
-      _ <- readProcess (caCabal ca) ["new-build", T.unpack $ fromMaybe "" component] ""
+      _ <- readProcess (caCabal ca) ["v1-build", T.unpack $ fromMaybe "" component] ""
       return $ IdeResultOk ()
     StackMode ->
       case (package', component) of
@@ -457,8 +457,9 @@ listCabalTargets distDir' dir =
     absDir <- liftIO $ makeAbsolute dir
     return $ Package pkgName' absDir comps
   where
--- # if MIN_VERSION_Cabal(2,0,0)
-#if MIN_VERSION_Cabal(1,24,0)
+#if MIN_VERSION_Cabal(3,0,0)
+    fixupLibraryEntrypoint _n (ChLibName e) = ChLibName e
+#elif MIN_VERSION_Cabal(1,24,0)
     fixupLibraryEntrypoint _n ChLibName = ChLibName
 #else
     fixupLibraryEntrypoint n (ChLibName "") = ChLibName n
@@ -500,9 +501,14 @@ getStackLocalPackages stackYamlFile = withBinaryFileContents stackYamlFile $ \co
 
 compToJSON :: ChComponentName -> Value
 compToJSON ChSetupHsName = object ["type" .= ("setupHs" :: T.Text)]
-#if MIN_VERSION_Cabal(1,24,0)
+#if MIN_VERSION_Cabal(3,0,0)
+compToJSON (ChLibName ChMainLibName) = object ["type" .= ("library" :: T.Text)]
+compToJSON (ChLibName (ChSubLibName n))    = object ["type" .= ("library" :: T.Text), "name" .= n]
+#else
 compToJSON ChLibName        = object ["type" .= ("library" :: T.Text)]
 compToJSON (ChSubLibName n) = object ["type" .= ("library" :: T.Text), "name" .= n]
+#endif
+#if MIN_VERSION_Cabal(1,24,0)
 compToJSON (ChFLibName   n) = object ["type" .= ("library" :: T.Text), "name" .= n]
 #else
 compToJSON (ChLibName   n) = object ["type" .= ("library" :: T.Text), "name" .= n]

--- a/coreclr-1.1.1/CMakeLists.txt
+++ b/coreclr-1.1.1/CMakeLists.txt
@@ -132,6 +132,16 @@ if(CMAKE_SYSTEM_NAME STREQUAL Linux)
         clr_unknown_arch()
     endif()
     set(CLR_CMAKE_PLATFORM_LINUX 1)
+
+    # Detect Alpine Linux
+    SET(OS_RELEASE_FILENAME "/etc/os-release")
+    if (EXISTS ${OS_RELEASE_FILENAME})
+        file(READ ${OS_RELEASE_FILENAME} OS_RELEASE)
+        string(FIND "${OS_RELEASE}" "ID=gentoo" CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+        if(CLR_CMAKE_PLATFORM_GENTOO_LINUX EQUAL -1)
+            unset(CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+        endif(CLR_CMAKE_PLATFORM_GENTOO_LINUX EQUAL -1)
+    endif(EXISTS ${OS_RELEASE_FILENAME})
 endif(CMAKE_SYSTEM_NAME STREQUAL Linux)
 
 if(CMAKE_SYSTEM_NAME STREQUAL Darwin)
--- a/coreclr-1.1.1/clrdefinitions.cmake
+++ b/coreclr-1.1.1/clrdefinitions.cmake
@@ -61,6 +61,12 @@ if (CLR_CMAKE_PLATFORM_UNIX)
 
 endif(CLR_CMAKE_PLATFORM_UNIX)
 
+if(CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+  # Alpine Linux doesn't have fixed stack limit, this define disables some stack pointer
+  # sanity checks in debug / checked build that rely on a fixed stack limit
+  add_definitions(-DNO_FIXED_STACK_LIMIT)
+endif(CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+
 add_definitions(-D_BLD_CLR)
 add_definitions(-DDEBUGGING_SUPPORTED)
 add_definitions(-DPROFILING_SUPPORTED)
--- a/coreclr-1.1.1/src/pal/src/CMakeLists.txt
+++ b/coreclr-1.1.1/src/pal/src/CMakeLists.txt
@@ -2,13 +2,6 @@ cmake_minimum_required(VERSION 2.8.12.2)
 
 include_directories(SYSTEM /usr/local/include)
 
-# set kernel version to detect Alpine
-EXEC_PROGRAM(uname ARGS -v OUTPUT_VARIABLE CMAKE_SYSTEM_KERNEL_VERSION)
-string(FIND "${CMAKE_SYSTEM_KERNEL_VERSION}" "Alpine" PAL_SYSTEM_ALPINE)
-if(PAL_SYSTEM_ALPINE EQUAL -1)
-    unset(PAL_SYSTEM_ALPINE)
-endif()
-
 include(configure.cmake)
 
 project(coreclrpal)
@@ -70,6 +63,16 @@ elseif(PAL_CMAKE_PLATFORM_ARCH_ARM64)
   add_definitions(-D_WIN64=1)
 endif()
 
+if(CMAKE_SYSTEM_NAME STREQUAL Linux AND NOT CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+  # Currently the _xstate is not available on Alpine Linux
+  add_definitions(-DXSTATE_SUPPORTED)
+endif(CMAKE_SYSTEM_NAME STREQUAL Linux AND NOT CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+
+if(CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+  # Setting RLIMIT_NOFILE breaks debugging of coreclr on Alpine Linux for some reason
+  add_definitions(-DDONT_SET_RLIMIT_NOFILE)
+endif(CLR_CMAKE_PLATFORM_GENTOO_LINUX)
+
 # turn off capability to remove unused functions (which was enabled in debug build with sanitizers)
 set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG} -Wl,--no-gc-sections")
 
@@ -252,7 +255,7 @@ if(CMAKE_SYSTEM_NAME STREQUAL Linux)
     find_library(UNWIND_ARCH NAMES unwind-x86_64)
   endif()
 
-  if(PAL_SYSTEM_ALPINE)
+  if(CLR_CMAKE_PLATFORM_GENTOO_LINUX)
     find_library(INTL intl)
   endif()
 
--- a/coreclr-1.1.1/src/pal/src/exception/seh-unwind.cpp
+++ b/coreclr-1.1.1/src/pal/src/exception/seh-unwind.cpp
@@ -221,15 +221,34 @@ static void GetContextPointers(unw_cursor_t *cursor, unw_context_t *unwContext,
 #endif
 }
 
+extern int g_common_signal_handler_context_locvar_offset;
+
 BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextPointers)
 {
     int st;
     unw_context_t unwContext;
     unw_cursor_t cursor;
 
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(_ARM64_) || defined(_ARM_)
-    DWORD64 curPc;
-#endif
+    DWORD64 curPc = CONTEXTGetPC(context);
+
+#ifndef __APPLE__
+    // Check if the PC is the return address from the SEHProcessException in the common_signal_handler.
+    // If that's the case, extract its local variable containing the native_context_t of the hardware
+    // exception and return that. This skips the hardware signal handler trampoline that the libunwind
+    // cannot cross on some systems.
+    if ((void*)curPc == g_SEHProcessExceptionReturnAddress)
+    {
+        ULONG contextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT | CONTEXT_EXCEPTION_ACTIVE;
+
+    #if defined(_AMD64_)
+        contextFlags |= CONTEXT_XSTATE;
+    #endif
+        size_t nativeContext = *(size_t*)(CONTEXTGetFP(context) + g_common_signal_handler_context_locvar_offset);
+        CONTEXTFromNativeContext((const native_context_t *)nativeContext, context, contextFlags);
+
+        return TRUE;
+    }
+#endif
 
     if ((context->ContextFlags & CONTEXT_EXCEPTION_ACTIVE) != 0)
     {
@@ -240,7 +259,7 @@ BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextP
         // So we compensate it by incrementing the PC before passing it to the unwinder.
         // Without it, the unwinder would not find unwind info if the hardware exception
         // happened in the first instruction of a function.
-        CONTEXTSetPC(context, CONTEXTGetPC(context) + 1);
+        CONTEXTSetPC(context, curPc + 1);
     }
 
 #if !UNWIND_CONTEXT_IS_UCONTEXT_T
@@ -264,18 +283,6 @@ BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextP
     WinContextToUnwindCursor(context, &cursor);
 #endif
 
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__)  || defined(_ARM64_) || defined(_ARM_)
-    // FreeBSD, NetBSD and OSX appear to do two different things when unwinding
-    // 1: If it reaches where it cannot unwind anymore, say a 
-    // managed frame.  It wil return 0, but also update the $pc
-    // 2: If it unwinds all the way to _start it will return
-    // 0 from the step, but $pc will stay the same.
-    // The behaviour of libunwind from nongnu.org is to null the PC
-    // So we bank the original PC here, so we can compare it after
-    // the step
-    curPc = CONTEXTGetPC(context);
-#endif
-
     st = unw_step(&cursor);
     if (st < 0)
     {
@@ -303,12 +310,18 @@ BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextP
     // Update the passed in windows context to reflect the unwind
     //
     UnwindContextToWinContext(&cursor, context);
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__)  || defined(_ARM64_) || defined(_ARM_)
+
+    // FreeBSD, NetBSD, OSX and Alpine appear to do two different things when unwinding
+    // 1: If it reaches where it cannot unwind anymore, say a 
+    // managed frame.  It will return 0, but also update the $pc
+    // 2: If it unwinds all the way to _start it will return
+    // 0 from the step, but $pc will stay the same.
+    // So we detect that here and set the $pc to NULL in that case.
+    // This is the default behavior of the libunwind on Linux.
     if (st == 0 && CONTEXTGetPC(context) == curPc)
     {
         CONTEXTSetPC(context, 0);
     }
-#endif
 
     if (contextPointers != NULL)
     {
--- a/coreclr-1.1.1/src/pal/src/exception/seh.cpp
+++ b/coreclr-1.1.1/src/pal/src/exception/seh.cpp
@@ -88,6 +88,10 @@ PHARDWARE_EXCEPTION_SAFETY_CHECK_FUNCTION g_safeExceptionCheckFunction = NULL;
 
 PGET_GCMARKER_EXCEPTION_CODE g_getGcMarkerExceptionCode = NULL;
 
+// Return address of the SEHProcessException, which is used to enable walking over
+// the signal handler trampoline on some Unixes where the libunwind cannot do that.
+void* g_SEHProcessExceptionReturnAddress = NULL;
+
 /* Internal function definitions **********************************************/
 
 /*++
@@ -245,6 +249,8 @@ Return value:
 BOOL
 SEHProcessException(PAL_SEHException* exception)
 {
+    g_SEHProcessExceptionReturnAddress = __builtin_return_address(0);
+
     CONTEXT* contextRecord = exception->GetContextRecord();
     EXCEPTION_RECORD* exceptionRecord = exception->GetExceptionRecord();
 
--- a/coreclr-1.1.1/src/pal/src/exception/signal.cpp
+++ b/coreclr-1.1.1/src/pal/src/exception/signal.cpp
@@ -100,6 +100,10 @@ static bool registered_sigterm_handler = false;
 struct sigaction g_previous_activation;
 #endif
 
+// Offset of the local variable containing native context in the common_signal_handler function.
+// This offset is relative to the frame pointer.
+int g_common_signal_handler_context_locvar_offset = 0;
+
 /* public function definitions ************************************************/
 
 /*++
@@ -582,6 +586,7 @@ Parameters :
     the "pointers" parameter should contain a valid exception record pointer,
     but the ContextRecord pointer will be overwritten.
 --*/
+__attribute__((noinline))
 static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...)
 {
     sigset_t signal_set;
@@ -590,6 +595,7 @@ static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext
     native_context_t *ucontext;
 
     ucontext = (native_context_t *)sigcontext;
+    g_common_signal_handler_context_locvar_offset = (int)((char*)&ucontext - (char*)__builtin_frame_address(0));
 
     AllocateExceptionRecords(&exceptionRecord, &contextRecord);
 
--- a/coreclr-1.1.1/src/pal/src/include/pal/context.h
+++ b/coreclr-1.1.1/src/pal/src/include/pal/context.h
@@ -139,6 +139,8 @@ typedef ucontext_t native_context_t;
 /////////////////////
 // Extended state
 
+#ifdef XSTATE_SUPPORTED
+
 inline _fpx_sw_bytes *FPREG_FpxSwBytes(const ucontext_t *uc)
 {
     // Bytes 464..511 in the FXSAVE format are available for software to use for any purpose. In this case, they are used to
@@ -185,6 +187,8 @@ inline void *FPREG_Xstate_Ymmh(const ucontext_t *uc)
     return reinterpret_cast<_xstate *>(FPREG_Fpstate(uc))->ymmh.ymmh_space;
 }
 
+#endif // XSTATE_SUPPORTED
+
 /////////////////////
 
 #else // BIT64
@@ -468,6 +472,19 @@ inline static void CONTEXTSetPC(LPCONTEXT pContext, DWORD64 pc)
 #endif
 }
 
+inline static DWORD64 CONTEXTGetFP(LPCONTEXT pContext)
+{
+#if defined(_AMD64_)
+    return pContext->Rbp;
+#elif defined(_ARM_)
+    return pContext->R7;
+#elif defined(_ARM64_)
+    return pContext->X29;
+#else
+#error don't know how to get the frame pointer for this architecture
+#endif
+}
+
 /*++
 Function :
     CONTEXT_CaptureContext
--- a/coreclr-1.1.1/src/pal/src/init/pal.cpp
+++ b/coreclr-1.1.1/src/pal/src/init/pal.cpp
@@ -992,6 +992,7 @@ Return value:
 --*/
 static BOOL INIT_IncreaseDescriptorLimit(void)
 {
+#ifndef DONT_SET_RLIMIT_NOFILE
     struct rlimit rlp;
     int result;
     
@@ -1008,7 +1009,7 @@ static BOOL INIT_IncreaseDescriptorLimit(void)
     {
         return FALSE;
     }
-
+#endif // !DONT_SET_RLIMIT_NOFILE
     return TRUE;
 }
 
--- a/coreclr-1.1.1/src/pal/src/thread/context.cpp
+++ b/coreclr-1.1.1/src/pal/src/thread/context.cpp
@@ -467,13 +467,13 @@ void CONTEXTToNativeContext(CONST CONTEXT *lpContext, native_context_t *native)
     }
 
     // TODO: Enable for all Unix systems
-#if defined(_AMD64_) && defined(__linux__)
+#if defined(_AMD64_) && defined(XSTATE_SUPPORTED)
     if ((lpContext->ContextFlags & CONTEXT_XSTATE) == CONTEXT_XSTATE)
     {
         _ASSERTE(FPREG_HasExtendedState(native));
         memcpy_s(FPREG_Xstate_Ymmh(native), sizeof(M128A) * 16, lpContext->VectorRegister, sizeof(M128A) * 16);
     }
-#endif // _AMD64_
+#endif //_AMD64_ && XSTATE_SUPPORTED
 }
 
 /*++
@@ -564,22 +564,24 @@ void CONTEXTFromNativeContext(const native_context_t *native, LPCONTEXT lpContex
 #endif
     }
 
-    // TODO: Enable for all Unix systems
-#if defined(_AMD64_) && defined(__linux__)
+#ifdef _AMD64_
     if ((contextFlags & CONTEXT_XSTATE) == CONTEXT_XSTATE)
     {
+    // TODO: Enable for all Unix systems
+#if XSTATE_SUPPORTED
         if (FPREG_HasExtendedState(native))
         {
             memcpy_s(lpContext->VectorRegister, sizeof(M128A) * 16, FPREG_Xstate_Ymmh(native), sizeof(M128A) * 16);
         }
         else
+#endif // XSTATE_SUPPORTED
         {
             // Reset the CONTEXT_XSTATE bit(s) so it's clear that the extended state data in
             // the CONTEXT is not valid.
             const ULONG xstateFlags = CONTEXT_XSTATE & ~(CONTEXT_CONTROL & CONTEXT_INTEGER);
             lpContext->ContextFlags &= ~xstateFlags;
         }
-    } 
+    }
 #endif // _AMD64_
 }
 
--- a/coreclr-1.1.1/src/vm/stackwalk.cpp
+++ b/coreclr-1.1.1/src/vm/stackwalk.cpp
@@ -2560,7 +2560,9 @@ StackWalkAction StackFrameIterator::NextRaw(void)
         // to recover from AVs during profiler stackwalk.)
 
         PTR_VOID newSP = PTR_VOID((TADDR)GetRegdisplaySP(m_crawl.pRD));
+#ifndef NO_FIXED_STACK_LIMIT
         FAIL_IF_SPECULATIVE_WALK(newSP >= m_crawl.pThread->GetCachedStackLimit());
+#endif // !NO_FIXED_STACK_LIMIT
         FAIL_IF_SPECULATIVE_WALK(newSP < m_crawl.pThread->GetCachedStackBase());
 
 #undef FAIL_IF_SPECULATIVE_WALK
--- a/coreclr-1.1.1/src/vm/threads.cpp
+++ b/coreclr-1.1.1/src/vm/threads.cpp
@@ -8245,7 +8245,9 @@ void CheckRegDisplaySP (REGDISPLAY *pRD)
 {
     if (pRD->SP && pRD->_pThread)
     {
+#ifndef NO_FIXED_STACK_LIMIT
         _ASSERTE(PTR_VOID(pRD->SP) >= pRD->_pThread->GetCachedStackLimit());
+#endif // NO_FIXED_STACK_LIMIT
         _ASSERTE(PTR_VOID(pRD->SP) <  pRD->_pThread->GetCachedStackBase());
     }
 }
--- a/coreclr-1.1.1/src/dlls/mscoree/coreclr/CMakeLists.txt     2017-07-05 21:17:15.951003739 +0200
+++ b/coreclr-1.1.1/src/dlls/mscoree/coreclr/CMakeLists.txt     2017-07-05 21:16:23.559001159 +0200
@@ -58,7 +58,7 @@
 add_custom_target(coreclr_exports DEPENDS ${EXPORTS_FILE})
 add_dependencies(coreclr coreclr_exports)
 
-set_property(TARGET coreclr APPEND_STRING PROPERTY LINK_FLAGS ${EXPORTS_LINKER_OPTION})
+set_property(TARGET coreclr APPEND_STRING PROPERTY LINK_FLAGS "${EXPORTS_LINKER_OPTION} -Wl,-nostrip")
 set_property(TARGET coreclr APPEND_STRING PROPERTY LINK_DEPENDS ${EXPORTS_FILE})
 
 if (CLR_CMAKE_PLATFORM_UNIX)
--- a/coreclr-1.1.1/src/dlls/mscordac/CMakeLists.txt    2017-07-05 22:10:15.466160280 +0200
+++ b/coreclr-1.1.1/src/dlls/mscordac/CMakeLists.txt    2017-07-05 22:09:46.426158850 +0200
@@ -60,7 +60,7 @@
     add_custom_target(mscordaccore_exports DEPENDS ${EXPORTS_FILE})
     add_dependencies(mscordaccore mscordaccore_exports)
 
-    set_property(TARGET mscordaccore APPEND_STRING PROPERTY LINK_FLAGS ${EXPORTS_LINKER_OPTION})
+    set_property(TARGET mscordaccore APPEND_STRING PROPERTY LINK_FLAGS "${EXPORTS_LINKER_OPTION} -Wl,-z,muldefs")
     set_property(TARGET mscordaccore APPEND_STRING PROPERTY LINK_DEPENDS ${EXPORTS_FILE})
 endif(CLR_CMAKE_PLATFORM_UNIX)

--- a/coreclr-1.1.1/src/pal/src/CMakeLists.txt  2017-07-05 18:04:02.409432938 +0200
+++ b/coreclr-1.1.1/src/pal/src/CMakeLists.txt  2017-07-05 18:04:49.217435242 +0200
@@ -249,7 +249,7 @@
   find_library(UNWIND_GENERIC NAMES unwind-generic)
 
   target_link_libraries(coreclrpal
-    gcc_s
+    unwind
     pthread
     rt
     dl
--- a/coreclr-1.1.1/src/pal/inc/unixasmmacrosamd64.inc
+++ b/coreclr-1.1.1/src/pal/inc/unixasmmacrosamd64.inc
@@ -8,7 +8,7 @@
 #if defined(__APPLE__)
         .cfi_personality 0x9b, C_FUNC(\Handler) // 0x9b == DW_EH_PE_indirect | DW_EH_PE_pcrel | DW_EH_PE_sdata4
 #else
-        .cfi_personality 0, C_FUNC(\Handler) // 0 == DW_EH_PE_absptr
+        .cfi_personality 0x1b, C_FUNC(\Handler) // 0x1b == DW_EH_PE_pcrel | DW_EH_PE_sdata4
 #endif
         .endif
 .endm

--- a/drivers/usb/typec/tcpm/fusb302.c
+++ b/drivers/usb/typec/tcpm/fusb302.c
@@ -9,6 +9,7 @@
 #include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/extcon.h>
+#include <linux/extcon-provider.h>
 #include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
@@ -27,8 +28,11 @@
 #include <linux/types.h>
 #include <linux/usb.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/typec_dp.h>
+#include <linux/usb/typec_altmode.h>
 #include <linux/usb/tcpm.h>
 #include <linux/usb/pd.h>
+#include <linux/usb/pd_vdo.h>
 #include <linux/workqueue.h>
 
 #include "fusb302_reg.h"
@@ -109,6 +113,10 @@ struct fusb302_chip {
 	enum typec_cc_status cc2;
 	u32 snk_pdo[PDO_MAX_OBJECTS];
 
+	/* connector HW presence */
+	bool usb_ss_present;
+	bool dp_present;
+
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;
 	/* lock for log buffer access */
@@ -230,6 +238,158 @@ static void fusb302_debugfs_exit(const struct fusb302_chip *chip) { }
 
 #endif
 
+/*
+* Extcon notifications
+*/
+
+static const unsigned int supported_cables[] = { EXTCON_USB, EXTCON_USB_HOST,
+						EXTCON_DISP_DP, EXTCON_NONE };
+
+static struct extcon_dev *fusb302_extcon_register(struct fusb302_chip *chip)
+{
+	struct extcon_dev *extcon;
+	int ret = 0;
+
+	extcon = devm_extcon_dev_allocate(chip->dev, supported_cables);
+	if (IS_ERR(extcon)) {
+		dev_info(chip->dev, "extcon allocation failed\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	ret = devm_extcon_dev_register(chip->dev, extcon);
+	if (ret < 0) {
+		dev_info(chip->dev, "extcon registration failed, ret=%d\n",
+			 ret);
+		return ERR_PTR(ret);
+	}
+
+	extcon_set_property_capability(extcon, EXTCON_USB,
+						EXTCON_PROP_USB_VBUS);
+	extcon_set_property_capability(extcon, EXTCON_USB_HOST,
+						EXTCON_PROP_USB_VBUS);
+
+	if (chip->usb_ss_present) {
+		extcon_set_property_capability(extcon, EXTCON_USB,
+						EXTCON_PROP_USB_TYPEC_POLARITY);
+		extcon_set_property_capability(extcon, EXTCON_USB_HOST,
+						EXTCON_PROP_USB_TYPEC_POLARITY);
+		extcon_set_property_capability(extcon, EXTCON_USB,
+						EXTCON_PROP_USB_SS);
+		extcon_set_property_capability(extcon, EXTCON_USB_HOST,
+						EXTCON_PROP_USB_SS);
+	}
+
+	if (chip->dp_present) {
+		extcon_set_property_capability(extcon, EXTCON_DISP_DP,
+						EXTCON_PROP_USB_TYPEC_POLARITY);
+		extcon_set_property_capability(extcon, EXTCON_DISP_DP,
+						EXTCON_PROP_USB_SS);
+		extcon_set_property_capability(extcon, EXTCON_DISP_DP,
+						EXTCON_PROP_DISP_HPD);
+	}
+
+	return extcon;
+}
+
+static void fusb302_extcon_vbus_notify(struct fusb302_chip *chip,
+						bool vbus_present)
+{
+	struct extcon_dev *edev = chip->extcon;
+	union extcon_property_value prop_val;
+
+	if (!edev)
+		return;
+
+	prop_val.intval = vbus_present;
+	extcon_set_property(edev, EXTCON_USB, EXTCON_PROP_USB_VBUS,
+			prop_val);
+	extcon_set_property(edev, EXTCON_USB_HOST, EXTCON_PROP_USB_VBUS,
+			prop_val);
+	extcon_sync(edev, EXTCON_USB);
+	extcon_sync(edev, EXTCON_USB_HOST);
+}
+
+static void fusb302_extcon_roles_notify(struct fusb302_chip *chip,
+					bool connected, bool host)
+{
+	struct extcon_dev *edev = chip->extcon;
+	union extcon_property_value prop_val;
+
+	if (!edev)
+		return;
+
+	extcon_set_state(edev, EXTCON_USB, connected && !host);
+	extcon_set_state(edev, EXTCON_USB_HOST, connected && host);
+
+	if (chip->usb_ss_present) {
+		prop_val.intval = connected;
+		extcon_set_property(edev, EXTCON_USB, EXTCON_PROP_USB_SS,
+				prop_val);
+		extcon_set_property(edev, EXTCON_USB_HOST, EXTCON_PROP_USB_SS,
+				prop_val);
+	}
+
+	extcon_sync(edev, EXTCON_USB);
+	extcon_sync(edev, EXTCON_USB_HOST);
+}
+
+static void fusb302_extcon_polarity_notify(struct fusb302_chip *chip, bool flip)
+{
+	struct extcon_dev *edev = chip->extcon;
+	union extcon_property_value prop_val;
+
+	if (!edev)
+		return;
+
+	prop_val.intval = flip;
+
+	if (chip->usb_ss_present) {
+		extcon_set_property(edev, EXTCON_USB,
+					EXTCON_PROP_USB_TYPEC_POLARITY, prop_val);
+		extcon_set_property(edev, EXTCON_USB_HOST,
+					EXTCON_PROP_USB_TYPEC_POLARITY, prop_val);
+		extcon_sync(edev, EXTCON_USB);
+		extcon_sync(edev, EXTCON_USB_HOST);
+	}
+
+	if (chip->dp_present) {
+		extcon_set_property(edev, EXTCON_DISP_DP,
+					EXTCON_PROP_USB_TYPEC_POLARITY, prop_val);
+		extcon_sync(edev, EXTCON_DISP_DP);
+	}
+}
+
+static void fusb302_extcon_dp_notify(struct fusb302_chip *chip, bool dp,
+					bool dp_hpd, bool usb_ss)
+{
+	struct extcon_dev *edev = chip->extcon;
+	union extcon_property_value prop_val;
+
+	if (!edev || !chip->dp_present)
+		return;
+
+	extcon_set_state(edev, EXTCON_DISP_DP, dp);
+
+	prop_val.intval = usb_ss;
+
+	if (chip->usb_ss_present) {
+		extcon_set_property(edev, EXTCON_USB, EXTCON_PROP_USB_SS,
+					prop_val);
+		extcon_set_property(edev, EXTCON_USB_HOST, EXTCON_PROP_USB_SS,
+					prop_val);
+		extcon_sync(edev, EXTCON_USB);
+		extcon_sync(edev, EXTCON_USB_HOST);
+	}
+
+	extcon_set_property(edev, EXTCON_DISP_DP, EXTCON_PROP_USB_SS, prop_val);
+
+	prop_val.intval = dp_hpd;
+	extcon_set_property(edev, EXTCON_DISP_DP, EXTCON_PROP_DISP_HPD,
+				prop_val);
+
+	extcon_sync(edev, EXTCON_DISP_DP);
+}
+
 static int fusb302_i2c_write(struct fusb302_chip *chip,
 			     u8 address, u8 data)
 {
@@ -716,6 +876,11 @@ static int tcpm_get_cc(struct tcpc_dev *dev, enum typec_cc_status *cc1,
 static int tcpm_set_polarity(struct tcpc_dev *dev,
 			     enum typec_cc_polarity polarity)
 {
+	struct fusb302_chip *chip =
+		container_of(dev, struct fusb302_chip, tcpc_dev);
+
+	fusb302_extcon_polarity_notify(chip, polarity == TYPEC_POLARITY_CC2);
+
 	return 0;
 }
 
@@ -771,6 +936,7 @@ static int tcpm_set_vbus(struct tcpc_dev *dev, bool on, bool charge)
 		}
 		chip->vbus_on = on;
 		fusb302_log(chip, "vbus := %s", on ? "On" : "Off");
+		fusb302_extcon_vbus_notify(chip, on);
 	}
 	if (chip->charge_on == charge)
 		fusb302_log(chip, "charge is already %s",
@@ -900,6 +1066,7 @@ static int tcpm_set_roles(struct tcpc_dev *dev, bool attached,
 			    ret);
 		goto done;
 	}
+	fusb302_extcon_roles_notify(chip, attached, data == TYPEC_HOST);
 	fusb302_log(chip, "pd header := %s, %s", typec_role_name[pwr],
 		    typec_data_role_name[data]);
 done:
@@ -1046,6 +1213,48 @@ static int tcpm_pd_transmit(struct tcpc_dev *dev, enum tcpm_transmit_type type,
 	return ret;
 }
 
+static int tcpm_altmode_notify(struct tcpc_dev *dev,
+					struct typec_altmode *altmode,
+					unsigned long conf, void *data)
+{
+	struct fusb302_chip *chip =
+		container_of(dev, struct fusb302_chip, tcpc_dev);
+	struct typec_displayport_data *dp_data;
+	bool usb_ss = false;
+	bool dp_hpd = false;
+	u8 assignement = 0;
+
+	mutex_lock(&chip->lock);
+
+	if (altmode->svid == USB_TYPEC_DP_SID) {
+		dp_data = (struct typec_displayport_data *)data;
+		fusb302_log(chip, "DP altmode notify, conf=0x%x, status=0x%x",
+				conf, dp_data->status);
+
+		if (conf >= TYPEC_STATE_MODAL) {
+			assignement = conf - TYPEC_STATE_MODAL;
+			usb_ss = !!(BIT(assignement) & (BIT(DP_PIN_ASSIGN_B) |
+							BIT(DP_PIN_ASSIGN_D) |
+							BIT(DP_PIN_ASSIGN_F)));
+			dp_hpd = !!(dp_data->status & DP_STATUS_HPD_STATE);
+			fusb302_extcon_dp_notify(chip, true, dp_hpd, usb_ss);
+			fusb302_log(chip,
+				"DP altmode configured, pin_assignement=%d, "
+				"usb_ss=%d, dp_hpd=%d",
+				assignement, usb_ss, dp_hpd);
+		} else {
+			fusb302_extcon_dp_notify(chip, false, false, true);
+			fusb302_log(chip, "DP altmode configure");
+		}
+	} else {
+		fusb302_log(chip, "altmode notify, conf=0x%x", conf);
+	}
+
+	mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
 static enum typec_cc_status fusb302_bc_lvl_to_cc(u8 bc_lvl)
 {
 	if (bc_lvl == FUSB_REG_STATUS0_BC_LVL_1230_MAX)
@@ -1119,6 +1328,7 @@ static void init_tcpc_dev(struct tcpc_dev *fusb302_tcpc_dev)
 	fusb302_tcpc_dev->set_roles = tcpm_set_roles;
 	fusb302_tcpc_dev->start_toggling = tcpm_start_toggling;
 	fusb302_tcpc_dev->pd_transmit = tcpm_pd_transmit;
+	fusb302_tcpc_dev->altmode_notify = tcpm_altmode_notify;
 }
 
 static const char * const cc_polarity_name[] = {
@@ -1656,6 +1866,29 @@ static const struct property_entry port_props[] = {
 	{ }
 };
 
+static int fusb302_register_port_dp_altmode(struct tcpm_port *port)
+{
+	u8 assignments = BIT(DP_PIN_ASSIGN_C) | BIT(DP_PIN_ASSIGN_D) |
+			BIT(DP_PIN_ASSIGN_E);
+	struct typec_altmode_desc dp_altmode_desc = {
+		.svid = USB_SID_DISPLAYPORT,
+		.mode = USB_TYPEC_DP_MODE,
+		.vdo = DP_CAP_DFP_D | DP_CAP_DP_SIGNALING | DP_CAP_RECEPTACLE |
+				(assignments << 8) | (assignments << 16),
+		.roles = TYPEC_PORT_DRD
+	};
+	int ret = 0;
+
+	struct typec_altmode *altmode =
+		tcpm_register_port_altmode(port, &dp_altmode_desc);
+	if (IS_ERR(altmode))
+		ret = PTR_ERR(altmode);
+	else
+		altmode->desc = "DisplayPort";
+
+	return ret;
+}
+
 static struct fwnode_handle *fusb302_fwnode_get(struct device *dev)
 {
 	struct fwnode_handle *fwnode;
@@ -1673,6 +1906,8 @@ static int fusb302_probe(struct i2c_client *client,
 	struct fusb302_chip *chip;
 	struct i2c_adapter *adapter = client->adapter;
 	struct device *dev = &client->dev;
+	struct fwnode_handle *usb_ss_fwnode;
+	struct fwnode_handle *dp_fwnode;
 	const char *name;
 	int ret = 0;
 
@@ -1700,6 +1935,20 @@ static int fusb302_probe(struct i2c_client *client,
 		chip->extcon = extcon_get_extcon_dev(name);
 		if (!chip->extcon)
 			return -EPROBE_DEFER;
+	} else if (device_property_read_bool(dev, "extcon")) {
+		chip->extcon = extcon_get_edev_by_phandle(dev, 0);
+		if (IS_ERR(chip->extcon)) {
+			if (PTR_ERR(chip->extcon) != -EPROBE_DEFER)
+				dev_err(dev,
+					"Invalid or missing extcon device\n");
+			return PTR_ERR(chip->extcon);
+		}
+	} else {
+		chip->extcon = fusb302_extcon_register(chip);
+		if (IS_ERR(chip->extcon)) {
+			dev_err(dev, "Cannot create extcon, ret=%d\n", ret);
+			return PTR_ERR(chip->extcon);
+		}
 	}
 
 	chip->vbus = devm_regulator_get(chip->dev, "vbus");
@@ -1730,15 +1979,32 @@ static int fusb302_probe(struct i2c_client *client,
 		goto destroy_workqueue;
 	}
 
+	usb_ss_fwnode = fwnode_graph_get_remote_node(chip->tcpc_dev.fwnode , 1, 0);
+	chip->usb_ss_present = usb_ss_fwnode != NULL;
+	fwnode_handle_put(usb_ss_fwnode);
+
+	dp_fwnode = fwnode_graph_get_remote_node(chip->tcpc_dev.fwnode , 2, 0);
+	chip->dp_present = dp_fwnode != NULL;
+	fwnode_handle_put(dp_fwnode);
+
 	chip->tcpm_port = tcpm_register_port(&client->dev, &chip->tcpc_dev);
 	if (IS_ERR(chip->tcpm_port)) {
 		fwnode_handle_put(chip->tcpc_dev.fwnode);
 		ret = PTR_ERR(chip->tcpm_port);
 		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "cannot register tcpm port, ret=%d", ret);
+			dev_err(dev, "cannot register tcpm port, ret=%d\n", ret);
 		goto destroy_workqueue;
 	}
 
+	if(chip->dp_present) {
+		if(fusb302_register_port_dp_altmode(chip->tcpm_port) < 0)
+			dev_err(dev,
+				"cannot register DisplayPort altmode, ret=%d\n",
+				ret);
+		else
+			dev_info(dev, "DisplayPort altmode registered");
+	}
+
 	ret = request_irq(chip->gpio_int_n_irq, fusb302_irq_intn,
 			  IRQF_ONESHOT | IRQF_TRIGGER_LOW,
 			  "fsc_interrupt_int_n", chip);
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -315,6 +315,7 @@ struct tcpm_port {
 	struct pd_mode_data mode_data;
 	struct typec_altmode *partner_altmode[ALTMODE_DISCOVERY_MAX];
 	struct typec_altmode *port_altmode[ALTMODE_DISCOVERY_MAX];
+	int altmodes;
 
 	/* Deadline in jiffies to exit src_try_wait state */
 	unsigned long max_wait;
@@ -1044,7 +1045,7 @@ static void svdm_consume_modes(struct tcpm_port *port, const __le32 *payload,
 		paltmode->mode = i;
 		paltmode->vdo = le32_to_cpu(payload[i]);
 
-		tcpm_log(port, " Alternate mode %d: SVID 0x%04x, VDO %d: 0x%08x",
+		tcpm_log(port, "Alternate mode %d: SVID 0x%04x, VDO %d: 0x%08x",
 			 pmdata->altmodes, paltmode->svid,
 			 paltmode->mode, paltmode->vdo);
 
@@ -1548,10 +1549,24 @@ static int tcpm_altmode_vdm(struct typec_altmode *altmode,
 	return 0;
 }
 
+static int tcpm_altmode_notify(struct typec_altmode *altmode,
+					unsigned long conf, void *data)
+{
+	struct tcpm_port *port = typec_altmode_get_drvdata(altmode);
+
+	if (port->tcpc->altmode_notify) {
+		return port->tcpc->altmode_notify(port->tcpc, altmode, conf,
+						  data);
+	}
+
+	return 0;
+}
+
 static const struct typec_altmode_ops tcpm_altmode_ops = {
 	.enter = tcpm_altmode_enter,
 	.exit = tcpm_altmode_exit,
 	.vdm = tcpm_altmode_vdm,
+	.notify = tcpm_altmode_notify
 };
 
 /*
@@ -4809,6 +4824,30 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 }
 EXPORT_SYMBOL_GPL(tcpm_register_port);
 
+struct typec_altmode *
+tcpm_register_port_altmode(struct tcpm_port *port,
+				const struct typec_altmode_desc *desc)
+{
+	struct typec_altmode *alt;
+
+	if (port->altmodes >= ALTMODE_DISCOVERY_MAX)
+		return ERR_PTR(-EINVAL);
+
+	mutex_lock(&port->lock);
+
+	alt = typec_port_register_altmode(port->typec_port, desc);
+	if (!IS_ERR(alt)) {
+		alt->ops = &tcpm_altmode_ops;
+		typec_altmode_set_drvdata(alt, port);
+		port->port_altmode[port->altmodes++] = alt;
+	}
+
+	mutex_unlock(&port->lock);
+
+	return alt;
+}
+EXPORT_SYMBOL_GPL(tcpm_register_port_altmode);
+
 void tcpm_unregister_port(struct tcpm_port *port)
 {
 	int i;
--- a/include/linux/usb/tcpm.h
+++ b/include/linux/usb/tcpm.h
@@ -103,12 +103,17 @@ struct tcpc_dev {
 	int (*set_auto_vbus_discharge_threshold)(struct tcpc_dev *dev, enum typec_pwr_opmode mode,
 						 bool pps_active, u32 requested_vbus_voltage);
 	bool (*is_vbus_vsafe0v)(struct tcpc_dev *dev);
 	void (*set_partner_usb_comm_capable)(struct tcpc_dev *dev, bool enable);
+	int (*altmode_notify)(struct tcpc_dev *dev,
+			      struct typec_altmode *altmode, unsigned long conf,
+			      void *data);
 };
 
 struct tcpm_port;
 
 struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc);
 void tcpm_unregister_port(struct tcpm_port *port);
+struct typec_altmode *tcpm_register_port_altmode(struct tcpm_port *port,
+			   const struct typec_altmode_desc *desc);
 
 void tcpm_vbus_change(struct tcpm_port *port);
 void tcpm_cc_change(struct tcpm_port *port);

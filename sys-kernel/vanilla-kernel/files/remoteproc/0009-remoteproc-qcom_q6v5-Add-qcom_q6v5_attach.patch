From 78f9348c4a436c80e775353d45539e5aeb57227d Mon Sep 17 00:00:00 2001
From: Stephan Gerhold <stephan.gerhold@linaro.org>
Date: Tue, 5 Aug 2025 17:44:32 +0200
Subject: [PATCH 087/150] remoteproc: qcom_q6v5: Add qcom_q6v5_attach()

Implement qcom_q6v5_attach(), which can be used by q6v5 remoteproc drivers
to attach to a remoteproc that is already running during boot. It is
essentially the same as qcom_q6v5_prepare(), except that we skip setting up
the proxy votes, since we expect that handover has already happened.

Signed-off-by: Stephan Gerhold <stephan.gerhold@linaro.org>
Signed-off-by: Abel Vesa <abel.vesa@oss.qualcomm.com>
---
 drivers/remoteproc/qcom_q6v5.c | 44 ++++++++++++++++++++++++++++------
 drivers/remoteproc/qcom_q6v5.h |  1 +
 2 files changed, 38 insertions(+), 7 deletions(-)

diff --git a/drivers/remoteproc/qcom_q6v5.c b/drivers/remoteproc/qcom_q6v5.c
index d4d978cca..94c75d9cc 100644
--- a/drivers/remoteproc/qcom_q6v5.c
+++ b/drivers/remoteproc/qcom_q6v5.c
@@ -36,6 +36,25 @@ static int q6v5_load_state_toggle(struct qcom_q6v5 *q6v5, bool enable)
 	return ret;
 }
 
+static int q6v5_init(struct qcom_q6v5 *q6v5, bool handover_issued)
+{
+	int ret;
+
+	/* Always send correct load state in case it was not done before */
+	ret = q6v5_load_state_toggle(q6v5, true);
+	if (ret)
+		return ret;
+
+	reinit_completion(&q6v5->start_done);
+	reinit_completion(&q6v5->stop_done);
+
+	q6v5->running = true;
+	q6v5->handover_issued = handover_issued;
+
+	enable_irq(q6v5->handover_irq);
+	return 0;
+}
+
 /**
  * qcom_q6v5_prepare() - reinitialize the qcom_q6v5 context before start
  * @q6v5:	reference to qcom_q6v5 context to be reinitialized
@@ -52,23 +71,34 @@ int qcom_q6v5_prepare(struct qcom_q6v5 *q6v5)
 		return ret;
 	}
 
-	ret = q6v5_load_state_toggle(q6v5, true);
+	ret = q6v5_init(q6v5, false);
 	if (ret) {
 		icc_set_bw(q6v5->path, 0, 0);
 		return ret;
 	}
 
-	reinit_completion(&q6v5->start_done);
-	reinit_completion(&q6v5->stop_done);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(qcom_q6v5_prepare);
 
-	q6v5->running = true;
-	q6v5->handover_issued = false;
+/**
+ * qcom_q6v5_attach() - attach to already running qcom_q6v5 remoteproc
+ * @q6v5:	reference to qcom_q6v5 context to be attached
+ *
+ * Return: 0 on success, negative errno on failure
+ */
+int qcom_q6v5_attach(struct qcom_q6v5 *q6v5)
+{
+	int ret;
 
-	enable_irq(q6v5->handover_irq);
+	ret = q6v5_init(q6v5, true);
+	if (ret)
+		return ret;
 
+	complete(&q6v5->start_done);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(qcom_q6v5_prepare);
+EXPORT_SYMBOL_GPL(qcom_q6v5_attach);
 
 /**
  * qcom_q6v5_unprepare() - unprepare the qcom_q6v5 context after stop
diff --git a/drivers/remoteproc/qcom_q6v5.h b/drivers/remoteproc/qcom_q6v5.h
index 59970adb0..f034bb628 100644
--- a/drivers/remoteproc/qcom_q6v5.h
+++ b/drivers/remoteproc/qcom_q6v5.h
@@ -50,6 +50,7 @@ void qcom_q6v5_deinit(struct qcom_q6v5 *q6v5);
 void qcom_q6v5_read_smp2p_state(struct qcom_q6v5 *q6v5);
 
 int qcom_q6v5_prepare(struct qcom_q6v5 *q6v5);
+int qcom_q6v5_attach(struct qcom_q6v5 *q6v5);
 int qcom_q6v5_unprepare(struct qcom_q6v5 *q6v5);
 int qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5, struct qcom_sysmon *sysmon);
 int qcom_q6v5_wait_for_start(struct qcom_q6v5 *q6v5, int timeout);
-- 
2.52.0


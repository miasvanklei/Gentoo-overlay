--- a/src/bootstrap/compile.rs	2018-05-11 10:28:37.177954138 +0200
+++ b/src/bootstrap/compile.rs	2018-05-11 10:28:50.624806862 +0200
@@ -651,11 +651,6 @@
                 println!("Building stage{} codegen artifacts ({} -> {}, {})",
                          compiler.stage, &compiler.host, target, self.backend);
 
-                // Pass down configuration from the LLVM build into the build of
-                // librustc_llvm and librustc_trans.
-                if build.is_rust_llvm(target) {
-                    cargo.env("LLVM_RUSTLLVM", "1");
-                }
                 cargo.env("LLVM_CONFIG", &llvm_config);
                 if self.backend != "emscripten" {
                     let target_config = build.config.target_config.get(&target);
--- a/src/bootstrap/test.rs	2018-05-11 10:28:09.115262493 +0200
+++ b/src/bootstrap/test.rs	2018-05-11 10:28:27.943055283 +0200
@@ -928,9 +928,7 @@
             });
             let llvm_version = output(Command::new(&llvm_config).arg("--version"));
             cmd.arg("--llvm-version").arg(llvm_version);
-            if !build.is_rust_llvm(target) {
-                cmd.arg("--system-llvm");
-            }
+            cmd.arg("--system-llvm");
 
             // Only pass correct values for these flags for the `run-make` suite as it
             // requires that a C++ compiler was configured which isn't always the case.
--- a/src/bootstrap/lib.rs	2018-05-11 10:27:36.745617019 +0200
+++ b/src/bootstrap/lib.rs	2018-05-11 10:27:58.296380986 +0200
@@ -533,16 +533,6 @@
         self.out.join(&*target).join("crate-docs")
     }
 
-    /// Returns true if no custom `llvm-config` is set for the specified target.
-    ///
-    /// If no custom `llvm-config` was specified then Rust's llvm will be used.
-    fn is_rust_llvm(&self, target: Interned<String>) -> bool {
-        match self.config.target_config.get(&target) {
-            Some(ref c) => c.llvm_config.is_none(),
-            None => true
-        }
-    }
-
     /// Returns the path to `FileCheck` binary for the specified target
     fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {
         let target_config = self.config.target_config.get(&target);
--- a/src/rustllvm/PassWrapper.cpp	2018-05-11 10:29:27.055407858 +0200
+++ b/src/rustllvm/PassWrapper.cpp	2018-05-11 10:29:57.226077416 +0200
@@ -296,7 +296,6 @@
   report_fatal_error("Bad RelocModel.");
 }
 
-#if LLVM_RUSTLLVM
 /// getLongestEntryLength - Return the length of the longest entry in the table.
 ///
 static size_t getLongestEntryLength(ArrayRef<SubtargetFeatureKV> Table) {
@@ -341,17 +340,6 @@
          "target-feature=+feature1,-feature2\n\n");
 }
 
-#else
-
-extern "C" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef) {
-  printf("Target CPU help is not supported by this LLVM version.\n\n");
-}
-
-extern "C" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef) {
-  printf("Target features help is not supported by this LLVM version.\n\n");
-}
-#endif
-
 extern "C" LLVMTargetMachineRef LLVMRustCreateTargetMachine(
     const char *TripleStr, const char *CPU, const char *Feature,
     LLVMRustCodeModel RustCM, LLVMRustRelocMode RustReloc,
--- a/src/rustllvm/RustWrapper.cpp	2018-05-11 10:30:44.937554859 +0200
+++ b/src/rustllvm/RustWrapper.cpp	2018-05-11 10:31:06.913314173 +0200
@@ -565,7 +565,7 @@
   if (isSet(Flags & LLVMRustDIFlags::FlagBitField)) {
     Result |= DINode::DIFlags::FlagBitField;
   }
-#if LLVM_RUSTLLVM || LLVM_VERSION_GE(4, 0)
+#if LLVM_VERSION_GE(4, 0)
   if (isSet(Flags & LLVMRustDIFlags::FlagNoReturn)) {
     Result |= DINode::DIFlags::FlagNoReturn;
   }
--- a/src/librustc_llvm/build.rs	2018-05-11 10:31:24.061126360 +0200
+++ b/src/librustc_llvm/build.rs	2018-05-11 10:31:42.725921936 +0200
@@ -146,11 +146,6 @@
         cfg.define(&flag, None);
     }
 
-    println!("cargo:rerun-if-changed-env=LLVM_RUSTLLVM");
-    if env::var_os("LLVM_RUSTLLVM").is_some() {
-        cfg.define("LLVM_RUSTLLVM", None);
-    }
-
     build_helper::rerun_if_changed_anything_in_dir(Path::new("../rustllvm"));
     cfg.file("../rustllvm/PassWrapper.cpp")
        .file("../rustllvm/RustWrapper.cpp")

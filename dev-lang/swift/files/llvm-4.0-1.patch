diff --git a/tools/driver/autolink_extract_main.cpp b/tools/driver/autolink_extract_main.cpp
index c4c38c7..b0367dd 100644
--- a/tools/driver/autolink_extract_main.cpp
+++ b/tools/driver/autolink_extract_main.cpp
@@ -147,7 +147,7 @@ static bool extractLinkerFlags(const llvm::object::Binary *Bin,
     extractLinkerFlagsFromObjectFile(ObjectFile, LinkerFlags);
     return false;
   } else if (auto *Archive = llvm::dyn_cast<llvm::object::Archive>(Bin)) {
-    llvm::Error Error;
+    llvm::Error Error = llvm::Error::success();
     for (const auto &Child : Archive->children(Error)) {
       auto ChildBinary = Child.getAsBinary();
       // FIXME: BinaryFileName below should instead be ld-style names for
diff --git a/tools/driver/modulewrap_main.cpp b/tools/driver/modulewrap_main.cpp
index 9c4e3fa..8fe4933 100644
--- a/tools/driver/modulewrap_main.cpp
+++ b/tools/driver/modulewrap_main.cpp
@@ -143,9 +143,7 @@ int modulewrap_main(ArrayRef<const char *> Args, const char *Argv0,
   }
 
   // Superficially verify that the input is a swift module file.
-  llvm::BitstreamReader Reader((unsigned char *)(*ErrOrBuf)->getBufferStart(),
-                               (unsigned char *)(*ErrOrBuf)->getBufferEnd());
-  llvm::BitstreamCursor Cursor(Reader);
+  llvm::BitstreamCursor Cursor(ErrOrBuf.get()->getMemBufferRef());
   for (unsigned char Byte : serialization::MODULE_SIGNATURE)
     if (Cursor.AtEndOfStream() || Cursor.Read(8) != Byte) {
       Instance.getDiags().diagnose(SourceLoc(), diag::error_parse_input_file,
diff --git a/lib/Serialization/DeserializeSIL.cpp b/lib/Serialization/DeserializeSIL.cpp
index 9b125e5..a1d2d26 100644
--- a/lib/Serialization/DeserializeSIL.cpp
+++ b/lib/Serialization/DeserializeSIL.cpp
@@ -105,7 +105,7 @@ SILDeserializer::SILDeserializer(ModuleFile *MF, SILModule &M,
   SILCursor = MF->getSILCursor();
   SILIndexCursor = MF->getSILIndexCursor();
   // Early return if either sil block or sil index block does not exist.
-  if (!SILCursor.getBitStreamReader() || !SILIndexCursor.getBitStreamReader())
+  if (SILCursor.AtEndOfStream() || SILIndexCursor.AtEndOfStream())
     return;
 
   // Load any abbrev records at the start of the block.
diff --git a/lib/Frontend/SerializedDiagnosticConsumer.cpp b/lib/Frontend/SerializedDiagnosticConsumer.cpp
index a718664..ff9fd1c 100644
--- a/lib/Frontend/SerializedDiagnosticConsumer.cpp
+++ b/lib/Frontend/SerializedDiagnosticConsumer.cpp
@@ -341,7 +341,7 @@ static void addRangeLocationAbbrev(llvm::BitCodeAbbrev *Abbrev) {
 }
 
 void SerializedDiagnosticConsumer::emitBlockInfoBlock() {
-  State->Stream.EnterBlockInfoBlock(3);
+  State->Stream.EnterBlockInfoBlock();
 
   using namespace llvm;
   llvm::BitstreamWriter &Stream = State->Stream;
diff --git a/include/swift/Serialization/ModuleFile.h b/include/swift/Serialization/ModuleFile.h
index 2b2fb5a..aa19e72 100644
--- a/include/swift/Serialization/ModuleFile.h
+++ b/include/swift/Serialization/ModuleFile.h
@@ -31,7 +31,6 @@
 
 namespace llvm {
   class BitstreamCursor;
-  class BitstreamReader;
   class MemoryBuffer;
   template <typename Info> class OnDiskIterableChainedHashTable;
 }
@@ -56,12 +55,6 @@ class ModuleFile : public LazyMemberLoader {
   std::unique_ptr<llvm::MemoryBuffer> ModuleInputBuffer;
   std::unique_ptr<llvm::MemoryBuffer> ModuleDocInputBuffer;
 
-  /// The reader attached to \c ModuleInputBuffer.
-  llvm::BitstreamReader ModuleInputReader;
-
-  /// The reader attached to \c ModuleDocInputBuffer.
-  llvm::BitstreamReader ModuleDocInputReader;
-
   /// The cursor used to lazily load things from the file.
   llvm::BitstreamCursor DeclTypeCursor;
 
diff --git a/lib/IRGen/IRGen.cpp b/lib/IRGen/IRGen.cpp
index 61d2233..91035c7 100644
--- a/lib/IRGen/IRGen.cpp
+++ b/lib/IRGen/IRGen.cpp
@@ -30,7 +30,7 @@
 #include "swift/LLVMPasses/Passes.h"
 #include "clang/Basic/TargetInfo.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
-#include "llvm/Bitcode/ReaderWriter.h"
+#include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/CodeGen/BasicTTIImpl.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DataLayout.h"
diff --git a/lib/Serialization/ModuleFile.cpp b/lib/Serialization/ModuleFile.cpp
index 53ead90..25824c0 100644
--- a/lib/Serialization/ModuleFile.cpp
+++ b/lib/Serialization/ModuleFile.cpp
@@ -55,7 +55,7 @@ static bool enterTopLevelModuleBlock(llvm::BitstreamCursor &cursor,
 
   if (next.ID == llvm::bitc::BLOCKINFO_BLOCK_ID) {
     if (shouldReadBlockInfo) {
-      if (cursor.ReadBlockInfoBlock())
+      if (!cursor.ReadBlockInfoBlock())
         return false;
     } else {
       if (cursor.SkipBlock())
@@ -77,23 +77,25 @@ static bool enterTopLevelModuleBlock(llvm::BitstreamCursor &cursor,
 static bool readOptionsBlock(llvm::BitstreamCursor &cursor,
                              SmallVectorImpl<uint64_t> &scratch,
                              ExtendedValidationInfo &extendedInfo) {
-  auto next = cursor.advance();
-  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
-    if (next.Kind == llvm::BitstreamEntry::Error)
+  while (!cursor.AtEndOfStream()) {
+    auto entry = cursor.advance();
+    if (entry.Kind == llvm::BitstreamEntry::EndBlock)
+      break;
+
+    if (entry.Kind == llvm::BitstreamEntry::Error)
       return false;
 
-    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
+    if (entry.Kind == llvm::BitstreamEntry::SubBlock) {
       // Unknown metadata sub-block, possibly for use by a future version of
       // the module format.
       if (cursor.SkipBlock())
         return false;
-      next = cursor.advance();
       continue;
     }
 
     scratch.clear();
     StringRef blobData;
-    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    unsigned kind = cursor.readRecord(entry.ID, scratch, &blobData);
     switch (kind) {
     case options_block::SDK_PATH:
       extendedInfo.setSDKPath(blobData);
@@ -119,8 +121,6 @@ static bool readOptionsBlock(llvm::BitstreamCursor &cursor,
       // module format.
       break;
     }
-
-    next = cursor.advance();
   }
 
   return true;
@@ -135,15 +135,18 @@ validateControlBlock(llvm::BitstreamCursor &cursor,
   ValidationInfo result;
   bool versionSeen = false;
 
-  auto next = cursor.advance();
-  while (next.Kind != llvm::BitstreamEntry::EndBlock) {
-    if (next.Kind == llvm::BitstreamEntry::Error) {
+  while (!cursor.AtEndOfStream()) {
+    auto entry = cursor.advance();
+    if (entry.Kind == llvm::BitstreamEntry::EndBlock)
+      break;
+
+    if (entry.Kind == llvm::BitstreamEntry::Error) {
       result.status = Status::Malformed;
       return result;
     }
 
-    if (next.Kind == llvm::BitstreamEntry::SubBlock) {
-      if (next.ID == OPTIONS_BLOCK_ID && extendedInfo) {
+    if (entry.Kind == llvm::BitstreamEntry::SubBlock) {
+      if (entry.ID == OPTIONS_BLOCK_ID && extendedInfo) {
         cursor.EnterSubBlock(OPTIONS_BLOCK_ID);
         if (!readOptionsBlock(cursor, scratch, *extendedInfo)) {
           result.status = Status::Malformed;
@@ -157,13 +160,12 @@ validateControlBlock(llvm::BitstreamCursor &cursor,
           return result;
         }
       }
-      next = cursor.advance();
       continue;
     }
 
     scratch.clear();
     StringRef blobData;
-    unsigned kind = cursor.readRecord(next.ID, scratch, &blobData);
+    unsigned kind = cursor.readRecord(entry.ID, scratch, &blobData);
     switch (kind) {
     case control_block::METADATA: {
       if (versionSeen) {
@@ -209,8 +211,6 @@ validateControlBlock(llvm::BitstreamCursor &cursor,
       // module format.
       break;
     }
-
-    next = cursor.advance();
   }
 
   return result;
@@ -232,31 +232,29 @@ ValidationInfo serialization::validateSerializedAST(
       reinterpret_cast<uintptr_t>(data.data()) % 4 != 0)
     return result;
 
-  llvm::BitstreamReader reader(reinterpret_cast<const uint8_t *>(data.begin()),
-                               reinterpret_cast<const uint8_t *>(data.end()));
-  llvm::BitstreamCursor cursor(reader);
+  llvm::BitstreamCursor cursor(data);
   SmallVector<uint64_t, 32> scratch;
 
   if (!checkModuleSignature(cursor) ||
       !enterTopLevelModuleBlock(cursor, MODULE_BLOCK_ID, false))
     return result;
 
-  auto topLevelEntry = cursor.advance();
-  while (topLevelEntry.Kind == llvm::BitstreamEntry::SubBlock) {
+  llvm::BitstreamEntry topLevelEntry;
+
+  while (!cursor.AtEndOfStream()) {
+    topLevelEntry = cursor.advance(AF_DontPopBlockAtEnd);
+
     if (topLevelEntry.ID == CONTROL_BLOCK_ID) {
       cursor.EnterSubBlock(CONTROL_BLOCK_ID);
       result = validateControlBlock(cursor, scratch, extendedInfo);
       if (result.status == Status::Malformed)
         return result;
-
     } else {
       if (cursor.SkipBlock()) {
         result.status = Status::Malformed;
         return result;
       }
     }
-
-    topLevelEntry = cursor.advance(AF_DontPopBlockAtEnd);
   }
 
   if (topLevelEntry.Kind == llvm::BitstreamEntry::EndBlock) {
@@ -699,18 +697,6 @@ static Optional<swift::LibraryKind> getActualLibraryKind(unsigned rawKind) {
   return None;
 }
 
-static const uint8_t *getStartBytePtr(llvm::MemoryBuffer *buffer) {
-  if (!buffer)
-    return nullptr;
-  return reinterpret_cast<const uint8_t *>(buffer->getBufferStart());
-}
-
-static const uint8_t *getEndBytePtr(llvm::MemoryBuffer *buffer) {
-  if (!buffer)
-    return nullptr;
-  return reinterpret_cast<const uint8_t *>(buffer->getBufferEnd());
-}
-
 static bool areCompatibleArchitectures(const llvm::Triple &moduleTarget,
                                        const llvm::Triple &ctxTarget) {
   if (moduleTarget.getArch() == ctxTarget.getArch())
@@ -764,17 +750,13 @@ ModuleFile::ModuleFile(
     serialization::ExtendedValidationInfo *extInfo)
     : ModuleInputBuffer(std::move(moduleInputBuffer)),
       ModuleDocInputBuffer(std::move(moduleDocInputBuffer)),
-      ModuleInputReader(getStartBytePtr(this->ModuleInputBuffer.get()),
-                        getEndBytePtr(this->ModuleInputBuffer.get())),
-      ModuleDocInputReader(getStartBytePtr(this->ModuleDocInputBuffer.get()),
-                           getEndBytePtr(this->ModuleDocInputBuffer.get())),
       DeserializedTypeCallback([](Type ty) {}) {
   assert(getStatus() == Status::Valid);
   Bits.IsFramework = isFramework;
 
   PrettyModuleFileDeserialization stackEntry(*this);
 
-  llvm::BitstreamCursor cursor{ModuleInputReader};
+  llvm::BitstreamCursor cursor{ModuleInputBuffer->getMemBufferRef()};
 
   if (!checkModuleSignature(cursor) ||
       !enterTopLevelModuleBlock(cursor, MODULE_BLOCK_ID)) {
@@ -787,8 +769,12 @@ ModuleFile::ModuleFile(
   bool hasValidControlBlock = false;
   SmallVector<uint64_t, 64> scratch;
 
-  auto topLevelEntry = cursor.advance();
-  while (topLevelEntry.Kind == llvm::BitstreamEntry::SubBlock) {
+  llvm::BitstreamEntry topLevelEntry;
+
+  while (!cursor.AtEndOfStream()) {
+    topLevelEntry = cursor.advance(AF_DontPopBlockAtEnd);
+    if (topLevelEntry.Kind != llvm::BitstreamEntry::SubBlock)
+      break;
     switch (topLevelEntry.ID) {
     case CONTROL_BLOCK_ID: {
       cursor.EnterSubBlock(CONTROL_BLOCK_ID);
@@ -984,8 +970,6 @@ ModuleFile::ModuleFile(
       }
       break;
     }
-
-    topLevelEntry = cursor.advance(AF_DontPopBlockAtEnd);
   }
 
   if (topLevelEntry.Kind != llvm::BitstreamEntry::EndBlock) {
@@ -996,15 +980,18 @@ ModuleFile::ModuleFile(
   if (!this->ModuleDocInputBuffer)
     return;
 
-  llvm::BitstreamCursor docCursor{ModuleDocInputReader};
+  llvm::BitstreamCursor docCursor{ModuleDocInputBuffer->getMemBufferRef()};
   if (!checkModuleDocSignature(docCursor) ||
       !enterTopLevelModuleBlock(docCursor, MODULE_DOC_BLOCK_ID)) {
     error(Status::MalformedDocumentation);
     return;
   }
 
-  topLevelEntry = docCursor.advance();
-  while (topLevelEntry.Kind == llvm::BitstreamEntry::SubBlock) {
+  while (!docCursor.AtEndOfStream()) {
+    topLevelEntry = docCursor.advance(AF_DontPopBlockAtEnd);
+    if (topLevelEntry.Kind != llvm::BitstreamEntry::SubBlock)
+      break;
+
     switch (topLevelEntry.ID) {
     case COMMENT_BLOCK_ID: {
       if (!hasValidControlBlock || !readCommentBlock(docCursor)) {
@@ -1023,8 +1010,6 @@ ModuleFile::ModuleFile(
       }
       break;
     }
-
-    topLevelEntry = docCursor.advance(AF_DontPopBlockAtEnd);
   }
 
   if (topLevelEntry.Kind != llvm::BitstreamEntry::EndBlock) {

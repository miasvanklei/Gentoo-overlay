diff --git a/cmake/modules/SwiftSharedCMakeConfig.cmake b/cmake/modules/SwiftSharedCMakeConfig.cmake
index 1c38d21ffb..7586b66648 100644
--- a/cmake/modules/SwiftSharedCMakeConfig.cmake
+++ b/cmake/modules/SwiftSharedCMakeConfig.cmake
@@ -73,6 +73,7 @@ macro(swift_common_standalone_build_config_llvm product is_cross_compiling)
   if ("${SWIFT_TABLEGEN_EXE}" STREQUAL "SWIFT_TABLEGEN_EXE-NOTFOUND")
     message(FATAL_ERROR "Failed to find tablegen in ${${product}_NATIVE_LLVM_TOOLS_PATH}")
   endif()
+  set(SWIFT_TABLEGEN_TARGET "${SWIFT_TABLEGEN_EXE}")
 
   include(AddLLVM)
   include(AddSwiftTableGen) # This imports TableGen from LLVM.
@@ -220,6 +221,7 @@ macro(swift_common_unified_build_config product)
   set(${product}_NATIVE_CLANG_TOOLS_PATH "${CMAKE_BINARY_DIR}/bin")
   set(LLVM_PACKAGE_VERSION ${PACKAGE_VERSION})
   set(SWIFT_TABLEGEN_EXE llvm-tblgen)
+  set(SWIFT_TABLEGEN_TARGET "${SWIFT_TABLEGEN_EXE}")
   set(LLVM_CMAKE_DIR "${CMAKE_SOURCE_DIR}/cmake/modules")
 
   # If cmark was checked out into tools/cmark, expect to build it as
diff --git a/include/swift/Basic/Dwarf.h b/include/swift/Basic/Dwarf.h
index 08e8bc0914..baac0354c3 100644
--- a/include/swift/Basic/Dwarf.h
+++ b/include/swift/Basic/Dwarf.h
@@ -17,7 +17,7 @@
 #ifndef SWIFT_BASIC_DWARF_H
 #define SWIFT_BASIC_DWARF_H
 
-#include "llvm/Support/Dwarf.h"
+#include "llvm/BinaryFormat/Dwarf.h"
 
 namespace swift {
   /// The DWARF version emitted by the Swift compiler.
diff --git a/include/swift/Basic/STLExtras.h b/include/swift/Basic/STLExtras.h
index e6d1ec631a..8587af40af 100644
--- a/include/swift/Basic/STLExtras.h
+++ b/include/swift/Basic/STLExtras.h
@@ -392,7 +392,7 @@ makeFilterRange(Range range, Predicate pred) {
   return FilterRange<Range, Predicate>(range, pred);
 }
 
-/// An iterator that transforms the result of an underlying forward
+/// An iterator that transforms the result of an underlying bidirectional
 /// iterator with a given operation.
 ///
 /// \tparam Iterator the underlying iterator.
@@ -411,7 +411,7 @@ class TransformIterator {
   using OpTraits = function_traits<Operation>;
 
 public:
-  using iterator_category = std::forward_iterator_tag;
+  using iterator_category = std::bidirectional_iterator_tag;
   using value_type = typename OpTraits::result_type;
   using reference = value_type;
   using pointer = void; // FIXME: Should provide a pointer proxy.
@@ -438,6 +438,17 @@ public:
     return old;
   }
 
+  TransformIterator &operator--() {
+    --Current;
+    return *this;
+  }
+
+  TransformIterator operator--(int) {
+    TransformIterator old = *this;
+    --*this;
+    return old;
+  }
+
   friend bool operator==(TransformIterator lhs, TransformIterator rhs) {
     return lhs.Current == rhs.Current;
   }
diff --git a/include/swift/Option/Options.h b/include/swift/Option/Options.h
index 0244f09158..bf5137d715 100644
--- a/include/swift/Option/Options.h
+++ b/include/swift/Option/Options.h
@@ -38,8 +38,9 @@ namespace options {
 
   enum ID {
     OPT_INVALID = 0, // This is not an option ID.
-#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM, \
-               HELPTEXT, METAVAR) OPT_##ID,
+#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,  \
+               HELPTEXT, METAVAR, VALUES)                                      \
+  OPT_##ID,
 #include "swift/Option/Options.inc"
     LastOption
 #undef OPTION
diff --git a/include/swift/SIL/Dominance.h b/include/swift/SIL/Dominance.h
index 9d1fd41afe..16ea2ca979 100644
--- a/include/swift/SIL/Dominance.h
+++ b/include/swift/SIL/Dominance.h
@@ -21,16 +21,19 @@
 #include "llvm/Support/GenericDomTree.h"
 #include "swift/SIL/CFG.h"
 
-extern template class llvm::DominatorTreeBase<swift::SILBasicBlock>;
-extern template class llvm::DominatorBase<swift::SILBasicBlock>;
+extern template class llvm::DominatorTreeBase<swift::SILBasicBlock, false>;
+extern template class llvm::DominatorTreeBase<swift::SILBasicBlock, true>;
 extern template class llvm::DomTreeNodeBase<swift::SILBasicBlock>;
 
 namespace swift {
 
+using DominatorTreeBase = llvm::DominatorTreeBase<swift::SILBasicBlock, false>;
+using PostDominatorTreeBase = llvm::DominatorTreeBase<swift::SILBasicBlock, true>;
 using DominanceInfoNode = llvm::DomTreeNodeBase<SILBasicBlock>;
 
 /// A class for computing basic dominance information.
-class DominanceInfo : public llvm::DominatorTreeBase<SILBasicBlock> {
+class DominanceInfo : public DominatorTreeBase {
+  using super = DominatorTreeBase;
 public:
   DominanceInfo(SILFunction *F);
 
@@ -64,7 +67,7 @@ public:
     return getNode(&F->front()) != nullptr;
   }
   void reset() {
-    llvm::DominatorTreeBase<SILBasicBlock>::reset();
+    super::reset();
   }
 };
 
@@ -124,7 +127,8 @@ public:
 };
 
 /// A class for computing basic post-dominance information.
-class PostDominanceInfo : public llvm::DominatorTreeBase<SILBasicBlock> {
+class PostDominanceInfo : public PostDominatorTreeBase {
+  using super = PostDominatorTreeBase;
 public:
   PostDominanceInfo(SILFunction *F);
 
@@ -160,7 +164,7 @@ public:
 
   bool isValid(SILFunction *F) const { return getNode(&F->front()) != nullptr; }
 
-  using DominatorTreeBase::properlyDominates;
+  using super::properlyDominates;
 };
 
 
diff --git a/include/swift/SIL/SILBasicBlock.h b/include/swift/SIL/SILBasicBlock.h
index 1cdab0e68e..67dc54b1aa 100644
--- a/include/swift/SIL/SILBasicBlock.h
+++ b/include/swift/SIL/SILBasicBlock.h
@@ -353,6 +353,11 @@ public:
   /// Returns true if this instruction only contains a branch instruction.
   bool isTrampoline() const;
 
+  /// Returns true if it is legal to hoist instructions into this block.
+  ///
+  /// Used by llvm::LoopInfo.
+  bool isLegalToHoistInto() const;
+
   //===--------------------------------------------------------------------===//
   // Debugging
   //===--------------------------------------------------------------------===//
diff --git a/include/swift/SIL/SILInstruction.h b/include/swift/SIL/SILInstruction.h
index 83a97b01fb..7db5bbfb14 100644
--- a/include/swift/SIL/SILInstruction.h
+++ b/include/swift/SIL/SILInstruction.h
@@ -1939,7 +1939,7 @@ public:
 /// IntegerLiteralInst - Encapsulates an integer constant, as defined originally
 /// by an IntegerLiteralExpr.
 class IntegerLiteralInst final : public LiteralInst,
-    private llvm::TrailingObjects<IntegerLiteralInst, llvm::integerPart> {
+    private llvm::TrailingObjects<IntegerLiteralInst, llvm::APInt::WordType> {
   friend TrailingObjects;
   friend SILBuilder;
 
@@ -1969,7 +1969,7 @@ public:
 /// FloatLiteralInst - Encapsulates a floating point constant, as defined
 /// originally by a FloatLiteralExpr.
 class FloatLiteralInst final : public LiteralInst,
-    private llvm::TrailingObjects<FloatLiteralInst, llvm::integerPart> {
+    private llvm::TrailingObjects<FloatLiteralInst, llvm::APInt::WordType> {
   friend TrailingObjects;
   friend SILBuilder;
 
diff --git a/lib/AST/Builtins.cpp b/lib/AST/Builtins.cpp
index 70b299aff9..7477ff374d 100644
--- a/lib/AST/Builtins.cpp
+++ b/lib/AST/Builtins.cpp
@@ -46,9 +46,9 @@ bool BuiltinInfo::isReadNone() const {
 
 bool IntrinsicInfo::hasAttribute(llvm::Attribute::AttrKind Kind) const {
   // FIXME: We should not be relying on the global LLVM context.
-  llvm::AttributeSet attrs
-    = llvm::Intrinsic::getAttributes(getGlobalLLVMContext(), ID);
-  return (attrs.hasAttribute(llvm::AttributeSet::FunctionIndex, Kind));
+  llvm::AttributeList attrs =
+      llvm::Intrinsic::getAttributes(getGlobalLLVMContext(), ID);
+  return (attrs.hasAttribute(llvm::AttributeList::FunctionIndex, Kind));
 }
 
 Type swift::getBuiltinType(ASTContext &Context, StringRef Name) {
@@ -1288,10 +1288,10 @@ getSwiftFunctionTypeForIntrinsic(unsigned iid, ArrayRef<Type> TypeArgs,
   }
   
   // Translate LLVM function attributes to Swift function attributes.
-  llvm::AttributeSet attrs =
+  llvm::AttributeList attrs =
       llvm::Intrinsic::getAttributes(getGlobalLLVMContext(), ID);
   Info = FunctionType::ExtInfo();
-  if (attrs.hasAttribute(llvm::AttributeSet::FunctionIndex,
+  if (attrs.hasAttribute(llvm::AttributeList::FunctionIndex,
                          llvm::Attribute::NoReturn))
     ResultTy = Context.getNeverType();
   
diff --git a/lib/Basic/Platform.cpp b/lib/Basic/Platform.cpp
index 9f3cbf242e..9297cc3951 100644
--- a/lib/Basic/Platform.cpp
+++ b/lib/Basic/Platform.cpp
@@ -88,6 +88,7 @@ StringRef swift::getPlatformNameForTriple(const llvm::Triple &triple) {
   switch (triple.getOS()) {
   case llvm::Triple::UnknownOS:
     llvm_unreachable("unknown OS");
+  case llvm::Triple::Ananas:
   case llvm::Triple::CloudABI:
   case llvm::Triple::DragonFly:
   case llvm::Triple::Fuchsia:
diff --git a/lib/ClangImporter/ClangAdapter.cpp b/lib/ClangImporter/ClangAdapter.cpp
index 21a5aaa5f0..08e7397b89 100644
--- a/lib/ClangImporter/ClangAdapter.cpp
+++ b/lib/ClangImporter/ClangAdapter.cpp
@@ -389,7 +389,6 @@ OmissionTypeName importer::getClangTypeNameForOmission(clang::ASTContext &ctx,
     case clang::BuiltinType::OCLEvent:
     case clang::BuiltinType::OCLClkEvent:
     case clang::BuiltinType::OCLQueue:
-    case clang::BuiltinType::OCLNDRange:
     case clang::BuiltinType::OCLReserveID:
       return OmissionTypeName();
 
diff --git a/lib/ClangImporter/ClangDiagnosticConsumer.cpp b/lib/ClangImporter/ClangDiagnosticConsumer.cpp
index 539f135a2a..47b399fd40 100644
--- a/lib/ClangImporter/ClangDiagnosticConsumer.cpp
+++ b/lib/ClangImporter/ClangDiagnosticConsumer.cpp
@@ -36,40 +36,36 @@ namespace {
          callback(fn) {}
 
   private:
-    void emitDiagnosticMessage(clang::SourceLocation Loc,
+    void emitDiagnosticMessage(clang::FullSourceLoc Loc,
                                clang::PresumedLoc PLoc,
                                clang::DiagnosticsEngine::Level Level,
                                StringRef Message,
                                ArrayRef<clang::CharSourceRange> Ranges,
-                               const clang::SourceManager *SM,
                                clang::DiagOrStoredDiag Info) override {
-      StringRef bufName = StringRef(SM->getBufferName(Loc));
+      StringRef bufName = StringRef(Loc.getManager().getBufferName(Loc));
       if (bufName == ClangImporter::Implementation::moduleImportBufferName ||
           bufName == ClangImporter::Implementation::bridgingHeaderBufferName) {
         return;
       }
-      callback(clang::FullSourceLoc(Loc, *SM), Level, Message);
+      callback(Loc, Level, Message);
     }
 
-    void emitDiagnosticLoc(clang::SourceLocation Loc, clang::PresumedLoc PLoc,
+    void emitDiagnosticLoc(clang::FullSourceLoc Loc, clang::PresumedLoc PLoc,
                            clang::DiagnosticsEngine::Level Level,
-                           ArrayRef<clang::CharSourceRange> Ranges,
-                           const clang::SourceManager &SM) override {}
+                           ArrayRef<clang::CharSourceRange> Ranges) override {}
 
-    void emitCodeContext(clang::SourceLocation Loc,
+    void emitCodeContext(clang::FullSourceLoc Loc,
                          clang::DiagnosticsEngine::Level Level,
                          SmallVectorImpl<clang::CharSourceRange>& Ranges,
-                         ArrayRef<clang::FixItHint> Hints,
-                         const clang::SourceManager &SM) override {}
+                         ArrayRef<clang::FixItHint> Hints) override {}
 
-    void emitNote(clang::SourceLocation Loc, StringRef Message,
-                  const clang::SourceManager *SM) override {
+    void emitNote(clang::FullSourceLoc Loc, StringRef Message) override {
       // We get invalid note locations when trying to describe where a module
       // is imported and the actual location is in Swift.
       if (Loc.isInvalid())
         return;
       emitDiagnosticMessage(Loc, {}, clang::DiagnosticsEngine::Note, Message,
-                            {}, SM, {});
+                            {}, {});
     }
   };
 } // end anonymous namespace
@@ -228,8 +224,9 @@ void ClangDiagnosticConsumer::HandleDiagnostic(
     auto clangCI = ImporterImpl.getClangInstance();
     ClangDiagRenderer renderer(clangCI->getLangOpts(),
                                &clangCI->getDiagnosticOpts(), emitDiag);
-    renderer.emitDiagnostic(clangDiag.getLocation(), clangDiagLevel, message,
-                            clangDiag.getRanges(), clangDiag.getFixItHints(),
-                            &clangDiag.getSourceManager());
+    clang::FullSourceLoc clangDiagLoc(clangDiag.getLocation(),
+                                      clangDiag.getSourceManager());
+    renderer.emitDiagnostic(clangDiagLoc, clangDiagLevel, message,
+                            clangDiag.getRanges(), clangDiag.getFixItHints());
   }
 }
diff --git a/lib/ClangImporter/ClangImporter.cpp b/lib/ClangImporter/ClangImporter.cpp
index 81fc6238b5..73ea32c22c 100644
--- a/lib/ClangImporter/ClangImporter.cpp
+++ b/lib/ClangImporter/ClangImporter.cpp
@@ -160,8 +160,7 @@ namespace {
     CreateASTConsumer(clang::CompilerInstance &CI, StringRef InFile) override {
       return llvm::make_unique<HeaderParsingASTConsumer>(Impl);
     }
-    bool BeginSourceFileAction(clang::CompilerInstance &CI,
-                               StringRef Filename) override {
+    bool BeginSourceFileAction(clang::CompilerInstance &CI) override {
       // Prefer frameworks over plain headers.
       // We add search paths here instead of when building the initial invocation
       // so that (a) we use the same code as search paths for imported modules,
@@ -749,7 +748,7 @@ bool ClangImporter::canReadPCH(StringRef PCHFilename) {
                         PP.getBuiltinInfo());
 
   std::unique_ptr<clang::ASTReader> Reader(new clang::ASTReader(
-      PP, ctx, CI.getPCHContainerReader(),
+      PP, &ctx, CI.getPCHContainerReader(),
       CI.getFrontendOpts().ModuleFileExtensions,
       CI.getHeaderSearchOpts().Sysroot,
       /*DisableValidation*/ false,
@@ -1266,7 +1265,7 @@ std::string ClangImporter::getBridgingHeaderContents(StringRef headerPath,
   invocation->getFrontendOpts().DisableFree = false;
   invocation->getFrontendOpts().Inputs.clear();
   invocation->getFrontendOpts().Inputs.push_back(
-      clang::FrontendInputFile(headerPath, clang::IK_ObjC));
+      clang::FrontendInputFile(headerPath, clang::InputKind::ObjC));
 
   invocation->getPreprocessorOpts().resetNonModularOptions();
 
@@ -1312,7 +1311,7 @@ ClangImporter::emitBridgingPCH(StringRef headerPath,
   invocation->getFrontendOpts().DisableFree = false;
   invocation->getFrontendOpts().Inputs.clear();
   invocation->getFrontendOpts().Inputs.push_back(
-      clang::FrontendInputFile(headerPath, clang::IK_ObjC));
+      clang::FrontendInputFile(headerPath, clang::InputKind::ObjC));
   invocation->getFrontendOpts().OutputFile = outputPCHPath;
   invocation->getFrontendOpts().ProgramAction = clang::frontend::GeneratePCH;
   invocation->getPreprocessorOpts().resetNonModularOptions();
diff --git a/lib/ClangImporter/IAMInference.cpp b/lib/ClangImporter/IAMInference.cpp
index 6645ff89fc..6d4a3db600 100644
--- a/lib/ClangImporter/IAMInference.cpp
+++ b/lib/ClangImporter/IAMInference.cpp
@@ -173,7 +173,7 @@ static clang::Module *getSubmodule(const clang::NamedDecl *decl, clang::Sema &cl
     return m;
   if (auto m = clangSema.getPreprocessor().getCurrentModule())
     return m;
-  if (auto m = clangSema.getPreprocessor().getCurrentSubmodule())
+  if (auto m = clangSema.getPreprocessor().getCurrentLexerSubmodule())
     return m;
 
   return nullptr;
diff --git a/lib/ClangImporter/ImportDecl.cpp b/lib/ClangImporter/ImportDecl.cpp
index 4bb58700fa..ef04e35e62 100644
--- a/lib/ClangImporter/ImportDecl.cpp
+++ b/lib/ClangImporter/ImportDecl.cpp
@@ -4384,12 +4384,12 @@ namespace {
       result->setCheckedInheritanceClause();
 
       // Add inferred attributes.
-#define INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeSet)        \
-      if (name.str().equals(#ClassName) &&                              \
-          result->getParentModule()->getName().str().equals(#ModuleName)) {  \
-        using namespace inferred_attributes;                            \
-        addInferredAttributes(result, AttributeSet);                    \
-      }
+#define INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeList)               \
+  if (name.str().equals(#ClassName) &&                                         \
+      result->getParentModule()->getName().str().equals(#ModuleName)) {        \
+    using namespace inferred_attributes;                                       \
+    addInferredAttributes(result, AttributeList);                               \
+  }
 #include "InferredAttributes.def"
 
       result->setMemberLoader(&Impl, 0);
diff --git a/lib/ClangImporter/ImportName.cpp b/lib/ClangImporter/ImportName.cpp
index 4506c950a7..2406d5dc34 100644
--- a/lib/ClangImporter/ImportName.cpp
+++ b/lib/ClangImporter/ImportName.cpp
@@ -497,7 +497,7 @@ static bool moduleIsInferImportAsMember(const clang::NamedDecl *decl,
     submodule = m;
   } else if (auto m = clangSema.getPreprocessor().getCurrentModule()) {
     submodule = m;
-  } else if (auto m = clangSema.getPreprocessor().getCurrentSubmodule()) {
+  } else if (auto m = clangSema.getPreprocessor().getCurrentLexerSubmodule()) {
     submodule = m;
   } else {
     return false;
@@ -1337,6 +1337,7 @@ ImportedName NameImporter::importNameImpl(const clang::NamedDecl *D,
   case clang::DeclarationName::CXXLiteralOperatorName:
   case clang::DeclarationName::CXXOperatorName:
   case clang::DeclarationName::CXXUsingDirective:
+  case clang::DeclarationName::CXXDeductionGuideName:
     // Handling these is part of C++ interoperability.
     llvm_unreachable("unhandled C++ interoperability");
 
diff --git a/lib/ClangImporter/ImportType.cpp b/lib/ClangImporter/ImportType.cpp
index 28771e719b..e680187928 100644
--- a/lib/ClangImporter/ImportType.cpp
+++ b/lib/ClangImporter/ImportType.cpp
@@ -288,7 +288,6 @@ namespace {
       case clang::BuiltinType::OCLEvent:
       case clang::BuiltinType::OCLClkEvent:
       case clang::BuiltinType::OCLQueue:
-      case clang::BuiltinType::OCLNDRange:
       case clang::BuiltinType::OCLReserveID:
         return Type();
 
diff --git a/lib/ClangImporter/ImporterImpl.h b/lib/ClangImporter/ImporterImpl.h
index 584902ea54..8450a691df 100644
--- a/lib/ClangImporter/ImporterImpl.h
+++ b/lib/ClangImporter/ImporterImpl.h
@@ -375,7 +375,8 @@ public:
   /// Multiple macro definitions can map to the same declaration if the
   /// macros are identically defined.
   llvm::DenseMap<Identifier,
-                 SmallVector<std::pair<clang::MacroInfo *, ValueDecl *>, 2>>
+                 SmallVector<std::pair<const clang::MacroInfo *, ValueDecl *>,
+                             2>>
     ImportedMacros;
 
   // Mapping from macro to value for macros that expand to constant values.
diff --git a/lib/ClangImporter/InferredAttributes.def b/lib/ClangImporter/InferredAttributes.def
index 3eaa8e4139..e61f604fdf 100644
--- a/lib/ClangImporter/InferredAttributes.def
+++ b/lib/ClangImporter/InferredAttributes.def
@@ -16,16 +16,16 @@
 // This fine enumerates the modules, classes, and attributes that will
 // be inferred by the Clang importer using the macro:
 //
-//   INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeSet)
+//   INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeList)
 //
 // ModuleName is the name of a module, i.e., CoreData.
 // ClassName is the name of the class, i.e., NSManagedObject
-// AttributeSet is an OR of attribute names, i.e., requires_stored_property_inits
+// AttributeList is an OR of attribute names, i.e., requires_stored_property_inits
 //
 //===----------------------------------------------------------------------===//
 
 #ifndef INFERRED_ATTRIBUTES
-#  define INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeSet)
+#  define INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeList)
 #endif
 
 INFERRED_ATTRIBUTES(CoreData, NSManagedObject, requires_stored_property_inits)
diff --git a/lib/Driver/Driver.cpp b/lib/Driver/Driver.cpp
index 42a46406e8..10f5251249 100644
--- a/lib/Driver/Driver.cpp
+++ b/lib/Driver/Driver.cpp
@@ -173,8 +173,7 @@ static void validateArgs(DiagnosticEngine &diags, const ArgList &Args) {
                      diag::verify_debug_info_requires_debug_option);
   }
 
-  for (const Arg *A : make_range(Args.filtered_begin(options::OPT_D),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(options::OPT_D)) {
     StringRef name = A->getValue();
     if (name.find('=') != StringRef::npos)
       diags.diagnose(SourceLoc(),
@@ -840,8 +839,7 @@ Driver::parseArgStrings(ArrayRef<const char *> Args) {
   }
 
   // Check for unknown arguments.
-  for (const Arg *A : make_range(ArgList->filtered_begin(options::OPT_UNKNOWN),
-       ArgList->filtered_end())) {
+  for (const Arg *A :  ArgList->filtered(options::OPT_UNKNOWN)) {
     Diags.diagnose(SourceLoc(), diag::error_unknown_arg,
                    A->getAsString(*ArgList));
   }
diff --git a/lib/Frontend/CompilerInvocation.cpp b/lib/Frontend/CompilerInvocation.cpp
index 94e9196cd0..13a4f3966f 100644
--- a/lib/Frontend/CompilerInvocation.cpp
+++ b/lib/Frontend/CompilerInvocation.cpp
@@ -270,9 +270,7 @@ static bool ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,
       assert(!Args.hasArg(OPT_INPUT) && "mixing -filelist with inputs");
     }
   } else {
-    for (const Arg *A : make_range(Args.filtered_begin(OPT_INPUT,
-                                                       OPT_primary_file),
-                                   Args.filtered_end())) {
+    for (const Arg *A : Args.filtered(OPT_INPUT, OPT_primary_file)) {
       if (A->getOption().matches(OPT_INPUT)) {
         Opts.InputFilenames.push_back(A->getValue());
       } else if (A->getOption().matches(OPT_primary_file)) {
@@ -883,13 +881,11 @@ static bool ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,
       !Opts.PrimaryInput && !Opts.ModuleOutputPath.empty();
   }
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_import_module),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_import_module)) {
     Opts.ImplicitImportModuleNames.push_back(A->getValue());
   }
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_Xllvm),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_Xllvm)) {
     Opts.LLVMArgs.push_back(A->getValue());
   }
 
@@ -1080,8 +1076,7 @@ static bool ParseLangArgs(LangOptions &Opts, ArgList &Args,
     Opts.MaxCircularityDepth = threshold;
   }
   
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_D),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_D)) {
     Opts.addCustomConditionalCompilationFlag(A->getValue());
   }
 
@@ -1176,8 +1171,7 @@ static bool ParseClangImporterArgs(ClangImporterOptions &Opts,
   if (const Arg *A = Args.getLastArg(OPT_index_store_path))
     Opts.IndexStorePath = A->getValue();
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_Xcc),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_Xcc)) {
     Opts.ExtraArgs.push_back(A->getValue());
   }
 
@@ -1227,19 +1221,16 @@ static bool ParseSearchPathArgs(SearchPathOptions &Opts,
     return fullPath.str();
   };
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_I),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_I)) {
     Opts.ImportSearchPaths.push_back(resolveSearchPath(A->getValue()));
   }
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_F, OPT_Fsystem),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_F, OPT_Fsystem)) {
     Opts.FrameworkSearchPaths.push_back({resolveSearchPath(A->getValue()),
                            /*isSystem=*/A->getOption().getID() == OPT_Fsystem});
   }
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_L),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_L)) {
     Opts.LibrarySearchPaths.push_back(resolveSearchPath(A->getValue()));
   }
 
@@ -1080,8 +1076,7 @@ static bool ParseLangArgs(LangOptions &Opts, ArgList &Args,
     Opts.MaxCircularityDepth = threshold;
   }
   
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_D),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_D)) {
     Opts.addCustomConditionalCompilationFlag(A->getValue());
   }
 
@@ -1560,8 +1551,7 @@ static bool ParseIRGenArgs(IRGenOptions &Opts, ArgList &Args,
   }
 
 
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_l, OPT_framework),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_l, OPT_framework)) {
     LibraryKind Kind;
     if (A->getOption().matches(OPT_l)) {
       Kind = LibraryKind::Library;
@@ -1617,14 +1607,11 @@ static bool ParseIRGenArgs(IRGenOptions &Opts, ArgList &Args,
   if (Args.hasArg(OPT_use_jit))
     Opts.UseJIT = true;
   
-  for (const Arg *A : make_range(Args.filtered_begin(OPT_verify_type_layout),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_verify_type_layout)) {
     Opts.VerifyTypeLayoutNames.push_back(A->getValue());
   }
 
-  for (const Arg *A : make_range(Args.filtered_begin(
-                                   OPT_disable_autolink_framework),
-                                 Args.filtered_end())) {
+  for (const Arg *A : Args.filtered(OPT_disable_autolink_framework)) {
     Opts.DisableAutolinkFrameworks.push_back(A->getValue());
   }
 
@@ -1646,16 +1633,15 @@ static bool ParseIRGenArgs(IRGenOptions &Opts, ArgList &Args,
     // Keep track of backend options so we can embed them in a separate data
     // section and use them when building from the bitcode. This can be removed
     // when all the backend options are recorded in the IR.
-    for (ArgList::const_iterator A = Args.begin(), AE = Args.end();
-         A != AE; ++ A) {
+    for (const Arg *A : Args) {
       // Do not encode output and input.
-      if ((*A)->getOption().getID() == options::OPT_o ||
-          (*A)->getOption().getID() == options::OPT_INPUT ||
-          (*A)->getOption().getID() == options::OPT_primary_file ||
-          (*A)->getOption().getID() == options::OPT_embed_bitcode)
+      if (A->getOption().getID() == options::OPT_o ||
+          A->getOption().getID() == options::OPT_INPUT ||
+          A->getOption().getID() == options::OPT_primary_file ||
+          A->getOption().getID() == options::OPT_embed_bitcode)
         continue;
       ArgStringList ASL;
-      (*A)->render(Args, ASL);
+      A->render(Args, ASL);
       for (ArgStringList::iterator it = ASL.begin(), ie = ASL.end();
           it != ie; ++ it) {
         StringRef ArgStr(*it);
@@ -1760,8 +1746,7 @@ bool CompilerInvocation::parseArgs(ArrayRef<const char *> Args,
   }
 
   if (ParsedArgs.hasArg(OPT_UNKNOWN)) {
-    for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_UNKNOWN),
-                                   ParsedArgs.filtered_end())) {
+    for (const Arg *A : ParsedArgs.filtered(OPT_UNKNOWN)) {
       Diags.diagnose(SourceLoc(), diag::error_unknown_arg,
                      A->getAsString(ParsedArgs));
     }
diff --git a/lib/IRGen/CallEmission.h b/lib/IRGen/CallEmission.h
index 1b30f9a9f9..33a0edcde4 100644
--- a/lib/IRGen/CallEmission.h
+++ b/lib/IRGen/CallEmission.h
@@ -36,7 +36,7 @@ public:
 
 private:
   /// The function attributes for the call.
-  llvm::AttributeSet Attrs;
+  llvm::AttributeList Attrs;
   
   /// The builtin/special arguments to pass to the call.
   SmallVector<llvm::Value*, 8> Args;
@@ -57,8 +57,8 @@ private:
   void emitToUnmappedExplosion(Explosion &out);
   llvm::CallSite emitCallSite();
   llvm::CallSite emitInvoke(llvm::CallingConv::ID cc, llvm::Value *fn,
-                            ArrayRef<llvm::Value*> args,
-                            const llvm::AttributeSet &attrs);
+                            ArrayRef<llvm::Value *> args,
+                            const llvm::AttributeList &attrs);
 
 public:
   CallEmission(IRGenFunction &IGF, const Callee &callee)
diff --git a/lib/IRGen/GenBuiltin.cpp b/lib/IRGen/GenBuiltin.cpp
index 4dfd7a3f20..1fae392c6d 100644
--- a/lib/IRGen/GenBuiltin.cpp
+++ b/lib/IRGen/GenBuiltin.cpp
@@ -386,8 +386,9 @@ if (Builtin.ID == BuiltinValueKind::id) { \
       BuiltinName = BuiltinName.drop_front(strlen("_singlethread"));
     assert(BuiltinName.empty() && "Mismatch with sema");
     
-    IGF.Builder.CreateFence(ordering,
-                      isSingleThread ? llvm::SingleThread : llvm::CrossThread);
+    IGF.Builder.CreateFence(ordering, isSingleThread
+                                          ? llvm::SyncScope::SingleThread
+                                          : llvm::SyncScope::System);
     return;
   }
 
@@ -436,10 +437,10 @@ if (Builtin.ID == BuiltinValueKind::id) { \
 
     pointer = IGF.Builder.CreateBitCast(pointer,
                                   llvm::PointerType::getUnqual(cmp->getType()));
-    llvm::Value *value = IGF.Builder.CreateAtomicCmpXchg(pointer, cmp, newval,
-                                                         successOrdering,
-                                                         failureOrdering,
-                                                         isSingleThread ? llvm::SingleThread : llvm::CrossThread);
+    llvm::Value *value = IGF.Builder.CreateAtomicCmpXchg(
+        pointer, cmp, newval, successOrdering, failureOrdering,
+        isSingleThread ? llvm::SyncScope::SingleThread
+                       : llvm::SyncScope::System);
     cast<llvm::AtomicCmpXchgInst>(value)->setVolatile(isVolatile);
     cast<llvm::AtomicCmpXchgInst>(value)->setWeak(isWeak);
 
@@ -504,9 +505,10 @@ if (Builtin.ID == BuiltinValueKind::id) { \
 
     pointer = IGF.Builder.CreateBitCast(pointer,
                                   llvm::PointerType::getUnqual(val->getType()));
-    llvm::Value *value = IGF.Builder.CreateAtomicRMW(SubOpcode, pointer, val,
-                                                      ordering,
-                      isSingleThread ? llvm::SingleThread : llvm::CrossThread);
+    llvm::Value *value = IGF.Builder.CreateAtomicRMW(
+        SubOpcode, pointer, val, ordering,
+        isSingleThread ? llvm::SyncScope::SingleThread
+                       : llvm::SyncScope::System);
     cast<AtomicRMWInst>(value)->setVolatile(isVolatile);
 
     if (origTy->isPointerTy())
@@ -558,8 +560,8 @@ if (Builtin.ID == BuiltinValueKind::id) { \
     if (Builtin.ID == BuiltinValueKind::AtomicLoad) {
       auto load = IGF.Builder.CreateLoad(pointer,
                                          valueTI.getBestKnownAlignment());
-      load->setAtomic(ordering,
-                      isSingleThread ? llvm::SingleThread : llvm::CrossThread);
+      load->setAtomic(ordering, isSingleThread ? llvm::SyncScope::SingleThread
+                                               : llvm::SyncScope::System);
       load->setVolatile(isVolatile);
 
       llvm::Value *value = load;
@@ -573,8 +575,8 @@ if (Builtin.ID == BuiltinValueKind::id) { \
         value = IGF.Builder.CreateBitCast(value, valueTy);
       auto store = IGF.Builder.CreateStore(value, pointer,
                                            valueTI.getBestKnownAlignment());
-      store->setAtomic(ordering,
-                       isSingleThread ? llvm::SingleThread : llvm::CrossThread);
+      store->setAtomic(ordering, isSingleThread ? llvm::SyncScope::SingleThread
+                                                : llvm::SyncScope::System);
       store->setVolatile(isVolatile);
       return;
     } else {
diff --git a/lib/IRGen/GenCall.cpp b/lib/IRGen/GenCall.cpp
index fac359ee38..7b0bde9cb2 100644
--- a/lib/IRGen/GenCall.cpp
+++ b/lib/IRGen/GenCall.cpp
@@ -76,7 +76,7 @@ static void addDereferenceableAttributeToBuilder(IRGenModule &IGM,
 }
 
 static void addIndirectValueParameterAttributes(IRGenModule &IGM,
-                                                llvm::AttributeSet &attrs,
+                                                llvm::AttributeList &attrs,
                                                 const TypeInfo &ti,
                                                 unsigned argIndex) {
   llvm::AttrBuilder b;
@@ -86,14 +86,13 @@ static void addIndirectValueParameterAttributes(IRGenModule &IGM,
   // The parameter must reference dereferenceable memory of the type.
   addDereferenceableAttributeToBuilder(IGM, b, ti);
 
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, argIndex+1, b);
-  attrs = attrs.addAttributes(IGM.LLVMContext, argIndex+1, resultAttrs);
+  attrs = attrs.addAttributes(IGM.LLVMContext,
+                              argIndex + llvm::AttributeList::FirstArgIndex, b);
 }
 
 static void addInoutParameterAttributes(IRGenModule &IGM,
-                                        llvm::AttributeSet &attrs,
-                                        const TypeInfo &ti,
-                                        unsigned argIndex,
+                                        llvm::AttributeList &attrs,
+                                        const TypeInfo &ti, unsigned argIndex,
                                         bool aliasable) {
   llvm::AttrBuilder b;
   // Aliasing inouts is unspecified, but we still want aliasing to be memory-
@@ -103,8 +102,8 @@ static void addInoutParameterAttributes(IRGenModule &IGM,
   // The inout must reference dereferenceable memory of the type.
   addDereferenceableAttributeToBuilder(IGM, b, ti);
 
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, argIndex+1, b);
-  attrs = attrs.addAttributes(IGM.LLVMContext, argIndex+1, resultAttrs);
+  attrs = attrs.addAttributes(IGM.LLVMContext,
+                              argIndex + llvm::AttributeList::FirstArgIndex, b);
 }
 
 static llvm::CallingConv::ID getFreestandingConvention(IRGenModule &IGM) {
@@ -133,38 +132,29 @@ llvm::CallingConv::ID irgen::expandCallingConv(IRGenModule &IGM,
 }
 
 static void addIndirectResultAttributes(IRGenModule &IGM,
-                                        llvm::AttributeSet &attrs,
-                                        unsigned paramIndex,
-                                        bool allowSRet) {
-  static const llvm::Attribute::AttrKind attrKindsWithSRet[] = {
-    llvm::Attribute::StructRet,
-    llvm::Attribute::NoAlias,
-    llvm::Attribute::NoCapture,
-  };
-  static const llvm::Attribute::AttrKind attrKindsWithoutSRet[] = {
-    llvm::Attribute::NoAlias,
-    llvm::Attribute::NoCapture,
-  };
-  auto resultAttrs =
-    llvm::AttributeSet::get(IGM.LLVMContext, paramIndex + 1,
-                            (allowSRet ? makeArrayRef(attrKindsWithSRet)
-                                       : makeArrayRef(attrKindsWithoutSRet)));
-  attrs = attrs.addAttributes(IGM.LLVMContext, paramIndex + 1, resultAttrs);
+                                        llvm::AttributeList &attrs,
+                                        unsigned paramIndex, bool allowSRet) {
+  llvm::AttrBuilder b;
+  b.addAttribute(llvm::Attribute::NoAlias);
+  b.addAttribute(llvm::Attribute::NoCapture);
+  if (allowSRet)
+    b.addAttribute(llvm::Attribute::StructRet);
+  attrs = attrs.addAttributes(IGM.LLVMContext,
+                              paramIndex + llvm::AttributeList::FirstArgIndex,
+                              b);
 }
 
-void IRGenModule::addSwiftSelfAttributes(llvm::AttributeSet &attrs,
+void IRGenModule::addSwiftSelfAttributes(llvm::AttributeList &attrs,
                                          unsigned argIndex) {
   if (!UseSwiftCC)
     return;
-  static const llvm::Attribute::AttrKind attrKinds[] = {
-    llvm::Attribute::SwiftSelf,
-  };
-  auto argAttrs =
-      llvm::AttributeSet::get(this->LLVMContext, argIndex + 1, attrKinds);
-  attrs = attrs.addAttributes(this->LLVMContext, argIndex + 1, argAttrs);
+  llvm::AttrBuilder b;
+  b.addAttribute(llvm::Attribute::SwiftSelf);
+  attrs = attrs.addAttributes(this->LLVMContext,
+                              argIndex + llvm::AttributeList::FirstArgIndex, b);
 }
 
-void IRGenModule::addSwiftErrorAttributes(llvm::AttributeSet &attrs,
+void IRGenModule::addSwiftErrorAttributes(llvm::AttributeList &attrs,
                                           unsigned argIndex) {
   // Don't add the swifterror attribute on ABI that don't pass it in a register.
   // We create a shadow stack location of the swifterror parameter for the
@@ -173,38 +163,31 @@ void IRGenModule::addSwiftErrorAttributes(llvm::AttributeSet &attrs,
   if (!UseSwiftCC || !this->IsSwiftErrorInRegister)
     return;
 
-  static const llvm::Attribute::AttrKind attrKinds[] = {
-    llvm::Attribute::SwiftError,
-  };
-  auto argAttrs =
-      llvm::AttributeSet::get(this->LLVMContext, argIndex + 1, attrKinds);
-  attrs = attrs.addAttributes(this->LLVMContext, argIndex + 1, argAttrs);
+  llvm::AttrBuilder b;
+  b.addAttribute(llvm::Attribute::SwiftError);
+  attrs = attrs.addAttributes(this->LLVMContext,
+                              argIndex + llvm::AttributeList::FirstArgIndex, b);
 }
 
 void irgen::addByvalArgumentAttributes(IRGenModule &IGM,
-                                       llvm::AttributeSet &attrs,
-                                       unsigned argIndex,
-                                       Alignment align) {
+                                       llvm::AttributeList &attrs,
+                                       unsigned argIndex, Alignment align) {
   llvm::AttrBuilder b;
   b.addAttribute(llvm::Attribute::ByVal);
   b.addAttribute(llvm::Attribute::getWithAlignment(IGM.LLVMContext,
                                                    align.getValue()));
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, argIndex+1, b);
   attrs = attrs.addAttributes(IGM.LLVMContext,
-                              argIndex+1,
-                              resultAttrs);
+                              argIndex + llvm::AttributeList::FirstArgIndex, b);
 }
 
-void irgen::addExtendAttribute(IRGenModule &IGM,
-                               llvm::AttributeSet &attrs,
+void irgen::addExtendAttribute(IRGenModule &IGM, llvm::AttributeList &attrs,
                                unsigned index, bool signExtend) {
   llvm::AttrBuilder b;
   if (signExtend)
     b.addAttribute(llvm::Attribute::SExt);
   else
     b.addAttribute(llvm::Attribute::ZExt);
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, index, b);
-  attrs = attrs.addAttributes(IGM.LLVMContext, index, resultAttrs);
+  attrs = attrs.addAttributes(IGM.LLVMContext, index, b);
 }
 
 namespace {
@@ -213,7 +196,7 @@ namespace {
     CanSILFunctionType FnType;
   public:
     SmallVector<llvm::Type*, 8> ParamIRTypes;
-    llvm::AttributeSet Attrs;
+    llvm::AttributeList Attrs;
     ForeignFunctionInfo ForeignInfo;
     bool CanUseSRet = true;
     bool CanUseError = true;
@@ -521,6 +504,7 @@ namespace {
       case clang::Type::RValueReference:
       case clang::Type::MemberPointer:
       case clang::Type::Auto:
+      case clang::Type::DeducedTemplateSpecialization:
         llvm_unreachable("C++ type in ABI lowering?");
 
       case clang::Type::Pipe:
@@ -658,7 +642,6 @@ namespace {
       case clang::BuiltinType::OCLEvent:
       case clang::BuiltinType::OCLClkEvent:
       case clang::BuiltinType::OCLQueue:
-      case clang::BuiltinType::OCLNDRange:
       case clang::BuiltinType::OCLReserveID:
         llvm_unreachable("OpenCL type in ABI lowering");
 
@@ -906,7 +889,7 @@ llvm::Type *SignatureExpansion::expandExternalSignatureTypes() {
     bool signExt = clangResultTy->hasSignedIntegerRepresentation();
     assert((signExt || clangResultTy->hasUnsignedIntegerRepresentation()) &&
            "Invalid attempt to add extension attribute to argument!");
-    addExtendAttribute(IGM, Attrs, llvm::AttributeSet::ReturnIndex, signExt);
+    addExtendAttribute(IGM, Attrs, llvm::AttributeList::ReturnIndex, signExt);
   }
 
   // If we return indirectly, that is the first parameter type.
@@ -936,7 +919,8 @@ llvm::Type *SignatureExpansion::expandExternalSignatureTypes() {
       bool signExt = paramTys[i]->hasSignedIntegerRepresentation();
       assert((signExt || paramTys[i]->hasUnsignedIntegerRepresentation()) &&
              "Invalid attempt to add extension attribute to argument!");
-      addExtendAttribute(IGM, Attrs, getCurParamIndex()+1, signExt);
+      addExtendAttribute(IGM, Attrs, getCurParamIndex() +
+                         llvm::AttributeList::FirstArgIndex, signExt);
       LLVM_FALLTHROUGH;
     }
     case clang::CodeGen::ABIArgInfo::Direct: {
@@ -1311,8 +1295,8 @@ void CallEmission::emitToUnmappedMemory(Address result) {
 // FIXME: This doesn't belong on IGF.
 llvm::CallSite CallEmission::emitInvoke(llvm::CallingConv::ID convention,
                                         llvm::Value *fn,
-                                        ArrayRef<llvm::Value*> args,
-                                        const llvm::AttributeSet &attrs) {
+                                        ArrayRef<llvm::Value *> args,
+                                        const llvm::AttributeList &attrs) {
   // TODO: exceptions!
   llvm::CallInst *call = IGF.Builder.CreateCall(fn, args);
   call->setAttributes(attrs);
@@ -1345,9 +1329,8 @@ llvm::CallSite CallEmission::emitCallSite() {
       Args[i] = IGF.coerceValue(Args[i], paramTy, IGF.IGM.DataLayout);
   }
 
-  llvm::CallSite call = emitInvoke(cc, fnPtr, Args,
-                                   llvm::AttributeSet::get(fnPtr->getContext(),
-                                                           Attrs));
+  llvm::CallSite call = emitInvoke(
+      cc, fnPtr, Args, llvm::AttributeList::get(fnPtr->getContext(), Attrs));
   Args.clear();
 
   // Return.
@@ -1499,7 +1482,8 @@ void CallEmission::setFromCallee() {
     // TODO: Add swift_error attribute.
     assert(LastArgWritten > 0);
     Args[--LastArgWritten] = errorResultSlot.getAddress();
-    addAttribute(LastArgWritten + 1, llvm::Attribute::NoCapture);
+    addAttribute(LastArgWritten + llvm::AttributeList::FirstArgIndex,
+                 llvm::Attribute::NoCapture);
     IGF.IGM.addSwiftErrorAttributes(Attrs, LastArgWritten);
 
     // Fill in the context pointer if necessary.
diff --git a/lib/IRGen/GenCall.h b/lib/IRGen/GenCall.h
index 3c7153b539..c4576689fc 100644
--- a/lib/IRGen/GenCall.h
+++ b/lib/IRGen/GenCall.h
@@ -24,7 +24,7 @@
 #include "llvm/IR/CallingConv.h"
 
 namespace llvm {
-  class AttributeSet;
+  class AttributeList;
   class Twine;
   class Type;
   class Value;
@@ -70,15 +70,15 @@ namespace irgen {
 
   /// Add function attributes to an attribute set for a byval argument.
   void addByvalArgumentAttributes(IRGenModule &IGM,
-                                  llvm::AttributeSet &attrs,
+                                  llvm::AttributeList &attrs,
                                   unsigned argIndex,
                                   Alignment align);
 
   /// Add signext or zeroext attribute set for an argument that needs
   /// extending.
-  void addExtendAttribute(IRGenModule &IGM, llvm::AttributeSet &attrs,
+  void addExtendAttribute(IRGenModule &IGM, llvm::AttributeList &attrs,
                           unsigned index, bool signExtend);
-  
+
   /// Can a series of values be simply pairwise coerced to (or from) an
   /// explosion schema, or do they need to traffic through memory?
   bool canCoerceToSchema(IRGenModule &IGM,
diff --git a/lib/IRGen/GenCoverage.cpp b/lib/IRGen/GenCoverage.cpp
index 0d87402a1c..b60d5f4556 100644
--- a/lib/IRGen/GenCoverage.cpp
+++ b/lib/IRGen/GenCoverage.cpp
@@ -32,12 +32,9 @@ using namespace irgen;
 using llvm::coverage::CovMapVersion;
 using llvm::coverage::CounterMappingRegion;
 
-static bool isMachO(IRGenModule &IGM) {
-  return SwiftTargetInfo::get(IGM).OutputObjectFormat == llvm::Triple::MachO;
-}
-
-static StringRef getCoverageSection(IRGenModule &IGM) {
-  return llvm::getInstrProfCoverageSectionName(isMachO(IGM));
+static std::string getCoverageSection(IRGenModule &IGM) {
+  return llvm::getInstrProfSectionName(llvm::IPSK_covmap,
+                                       IGM.Triple.getObjectFormat());
 }
 
 void IRGenModule::emitCoverageMapping() {
@@ -169,7 +166,8 @@ void IRGenModule::emitCoverageMapping() {
   auto CovData = new llvm::GlobalVariable(
       *getModule(), CovDataTy, true, llvm::GlobalValue::InternalLinkage,
       CovDataVal, llvm::getCoverageMappingVarName());
-  CovData->setSection(getCoverageSection(*this));
+  std::string CovSection = getCoverageSection(*this);
+  CovData->setSection(CovSection);
   CovData->setAlignment(8);
   addUsedGlobal(CovData);
 }
diff --git a/lib/IRGen/GenDecl.cpp b/lib/IRGen/GenDecl.cpp
index 13514b9141..aede54d3d6 100644
--- a/lib/IRGen/GenDecl.cpp
+++ b/lib/IRGen/GenDecl.cpp
@@ -485,7 +485,7 @@ void IRGenModule::emitSourceFile(SourceFile &SF, unsigned StartElem) {
 ///
 /// We use this when Clang code generation might populate the list.
 static void collectGlobalList(IRGenModule &IGM,
-                              SmallVectorImpl<llvm::WeakVH> &list,
+                              SmallVectorImpl<llvm::WeakTrackingVH> &list,
                               StringRef name) {
   if (auto *existing = IGM.Module.getGlobalVariable(name)) {
     auto *globals = cast<llvm::ConstantArray>(existing->getInitializer());
@@ -497,7 +497,7 @@ static void collectGlobalList(IRGenModule &IGM,
   }
 
   std::for_each(list.begin(), list.end(),
-                [](const llvm::WeakVH &global) {
+                [](const llvm::WeakTrackingVH &global) {
     assert(!isa<llvm::GlobalValue>(global) ||
            !cast<llvm::GlobalValue>(global)->isDeclaration() &&
            "all globals in the 'used' list must be definitions");
@@ -508,7 +508,7 @@ static void collectGlobalList(IRGenModule &IGM,
 /// list of values.  Generally these lists are for various LLVM
 /// metadata or runtime purposes.
 static llvm::GlobalVariable *
-emitGlobalList(IRGenModule &IGM, ArrayRef<llvm::WeakVH> handles,
+emitGlobalList(IRGenModule &IGM, ArrayRef<llvm::WeakTrackingVH> handles,
                StringRef name, StringRef section,
                llvm::GlobalValue::LinkageTypes linkage,
                llvm::Type *eltTy,
@@ -644,7 +644,7 @@ void IRGenModule::emitRuntimeRegistration() {
       }
     }
     
-    for (llvm::WeakVH &ObjCClass : ObjCClasses) {
+    for (llvm::WeakTrackingVH &ObjCClass : ObjCClasses) {
       RegIGF.Builder.CreateCall(getInstantiateObjCClassFn(), {ObjCClass});
     }
       
@@ -1538,7 +1538,7 @@ llvm::Function *swift::irgen::createFunction(IRGenModule &IGM,
                                              LinkInfo &linkInfo,
                                              llvm::FunctionType *fnType,
                                              llvm::CallingConv::ID cc,
-                                             const llvm::AttributeSet &attrs,
+                                             const llvm::AttributeList &attrs,
                                              llvm::Function *insertBefore) {
   auto name = linkInfo.getName();
 
@@ -1567,12 +1567,12 @@ llvm::Function *swift::irgen::createFunction(IRGenModule &IGM,
     IGM.Module.getFunctionList().push_back(fn);
  }
 
-  auto initialAttrs = IGM.constructInitialAttributes();
-  // Merge initialAttrs with attrs.
-  auto updatedAttrs = attrs.addAttributes(IGM.getLLVMContext(),
-                        llvm::AttributeSet::FunctionIndex, initialAttrs);
-  if (!updatedAttrs.isEmpty())
-    fn->setAttributes(updatedAttrs);
+  if (!attrs.isEmpty())
+    fn->setAttributes(attrs);
+  // Merge initial attributes with attrs.
+  llvm::AttrBuilder b;
+  IGM.constructInitialFnAttributes(b);
+  fn->addAttributes(llvm::AttributeList::FunctionIndex, b);
 
   // Everything externally visible is considered used in Swift.
   // That mostly means we need to be good at not marking things external.
@@ -1895,7 +1895,7 @@ llvm::Function *IRGenModule::getAddrOfSILFunction(SILFunction *f,
     IRGen.addLazyFunction(f);
   }
 
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   llvm::FunctionType *fnType = getFunctionType(f->getLoweredFunctionType(),
                                                attrs);
 
@@ -1903,12 +1903,14 @@ llvm::Function *IRGenModule::getAddrOfSILFunction(SILFunction *f,
 
   if (f->getInlineStrategy() == NoInline) {
     attrs = attrs.addAttribute(fnType->getContext(),
-                llvm::AttributeSet::FunctionIndex, llvm::Attribute::NoInline);
+                               llvm::AttributeList::FunctionIndex,
+                               llvm::Attribute::NoInline);
   }
   if (isReadOnlyFunction(f)) {
     attrs = attrs.addAttribute(fnType->getContext(),
-                llvm::AttributeSet::FunctionIndex, llvm::Attribute::ReadOnly);
+                               llvm::AttributeList::FunctionIndex,
+                               llvm::Attribute::ReadOnly);
   }
   fn = createFunction(*this, link, fnType, cc, attrs, insertBefore);
 
@@ -2511,7 +2513,7 @@ IRGenModule::getAddrOfTypeMetadataAccessFunction(CanType type,
 
   auto fnType = llvm::FunctionType::get(TypeMetadataPtrTy, false);
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -2536,7 +2538,7 @@ IRGenModule::getAddrOfGenericTypeMetadataAccessFunction(
 
   auto fnType = llvm::FunctionType::get(TypeMetadataPtrTy, genericArgs, false);
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -2851,7 +2853,7 @@ llvm::Function *IRGenModule::getAddrOfValueWitness(CanType abstractType,
       cast<llvm::PointerType>(getValueWitnessTy(index))
         ->getElementType());
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -3007,7 +3009,9 @@ void IRGenModule::emitExtension(ExtensionDecl *ext) {
 Address IRGenFunction::createAlloca(llvm::Type *type,
                                     Alignment alignment,
                                     const llvm::Twine &name) {
-  llvm::AllocaInst *alloca = new llvm::AllocaInst(type, name, AllocaIP);
+  llvm::AllocaInst *alloca =
+      new llvm::AllocaInst(type, IGM.DataLayout.getAllocaAddrSpace(), name,
+                           AllocaIP);
   alloca->setAlignment(alignment.getValue());
   return Address(alloca, alignment);
 }
@@ -3017,9 +3021,9 @@ Address IRGenFunction::createAlloca(llvm::Type *type,
                                     llvm::Value *ArraySize,
                                     Alignment alignment,
                                     const llvm::Twine &name) {
-  llvm::AllocaInst *alloca = new llvm::AllocaInst(type, ArraySize,
-                                                  alignment.getValue(), name,
-                                                  AllocaIP);
+  llvm::AllocaInst *alloca =
+      new llvm::AllocaInst(type, IGM.DataLayout.getAllocaAddrSpace(), ArraySize,
+                           alignment.getValue(), name, AllocaIP);
   return Address(alloca, alignment);
 }
 
@@ -3326,7 +3330,7 @@ IRGenModule::getAddrOfGenericWitnessTableInstantiationFunction(
                                           Int8PtrPtrTy },
                                         /*varargs*/ false);
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -3374,7 +3378,7 @@ IRGenModule::getAddrOfWitnessTableAccessFunction(
   }
 
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -3396,7 +3400,7 @@ IRGenModule::getAddrOfWitnessTableLazyAccessFunction(
     = llvm::FunctionType::get(WitnessTablePtrTy, false);
 
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -3447,7 +3451,7 @@ IRGenModule::getAddrOfAssociatedTypeMetadataAccessFunction(
 
   auto fnType = getAssociatedTypeMetadataAccessFunctionTy();
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
@@ -3470,7 +3474,7 @@ IRGenModule::getAddrOfAssociatedTypeWitnessTableAccessFunction(
 
   auto fnType = getAssociatedTypeWitnessTableAccessFunctionTy();
   LinkInfo link = LinkInfo::get(*this, entity, forDefinition);
-  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeSet());
+  entry = createFunction(*this, link, fnType, DefaultCC, llvm::AttributeList());
   return entry;
 }
 
diff --git a/lib/IRGen/GenDecl.h b/lib/IRGen/GenDecl.h
index b9c2dba988..a9f0425c1e 100644
--- a/lib/IRGen/GenDecl.h
+++ b/lib/IRGen/GenDecl.h
@@ -22,7 +22,7 @@
 #include "IRGen.h"
 
 namespace llvm {
-  class AttributeSet;
+  class AttributeList;
   class Function;
   class FunctionType;
 }
@@ -35,7 +35,7 @@ namespace irgen {
                                  LinkInfo &linkInfo,
                                  llvm::FunctionType *fnType,
                                  llvm::CallingConv::ID cc,
-                                 const llvm::AttributeSet &attrs,
+                                 const llvm::AttributeList &attrs,
                                  llvm::Function *insertBefore = nullptr);
 
 
diff --git a/lib/IRGen/GenEnum.cpp b/lib/IRGen/GenEnum.cpp
index 838c370bcd..85cfb9c5eb 100644
--- a/lib/IRGen/GenEnum.cpp
+++ b/lib/IRGen/GenEnum.cpp
@@ -3231,9 +3231,9 @@ namespace {
       auto call = IGF.Builder.CreateCall(IGF.IGM.getGetEnumCaseMultiPayloadFn(),
                                          {addr.getAddress(), metadata});
       call->setDoesNotThrow();
-      call->addAttribute(llvm::AttributeSet::FunctionIndex,
+      call->addAttribute(llvm::AttributeList::FunctionIndex,
                          llvm::Attribute::ReadOnly);
-      
+
       return call;
     }
 
@@ -5985,10 +5985,10 @@ irgen::interleaveSpareBits(IRGenModule &IGM, const SpareBitVector &spareBits,
                            unsigned bits,
                            unsigned spareValue, unsigned occupiedValue) {
   // FIXME: endianness.
-  SmallVector<llvm::integerPart, 2> valueParts;
+  SmallVector<llvm::APInt::WordType, 2> valueParts;
   valueParts.push_back(0);
 
-  llvm::integerPart valueBit = 1;
+  llvm::APInt::WordType valueBit = 1;
   auto advanceValueBit = [&]{
     valueBit <<= 1;
     if (valueBit == 0) {
diff --git a/lib/IRGen/GenFunc.cpp b/lib/IRGen/GenFunc.cpp
index bc818d68c7..0979993309 100644
--- a/lib/IRGen/GenFunc.cpp
+++ b/lib/IRGen/GenFunc.cpp
@@ -618,7 +618,7 @@ getFuncSignatureInfoForLowered(IRGenModule &IGM, CanSILFunctionType type) {
 
 llvm::FunctionType *
 IRGenModule::getFunctionType(CanSILFunctionType type,
-                             llvm::AttributeSet &attrs,
+                             llvm::AttributeList &attrs,
                              ForeignFunctionInfo *foreignInfo) {
   auto &sigInfo = getFuncSignatureInfoForLowered(*this, type);
   Signature sig = sigInfo.getSignature(*this);
@@ -738,18 +738,13 @@ static unsigned findSinglePartiallyAppliedParameterIndexIgnoringEmptyTypes(
 /// If 'layout' is null, there is a single captured value of
 /// Swift-refcountable type that is being used directly as the
 /// context object.
-static llvm::Function *emitPartialApplicationForwarder(IRGenModule &IGM,
-                                   llvm::Function *staticFnPtr,
-                                   bool calleeHasContext,
-                                   llvm::Type *fnTy,
-                                   const llvm::AttributeSet &origAttrs,
-                                   CanSILFunctionType origType,
-                                   CanSILFunctionType substType,
-                                   CanSILFunctionType outType,
-                                   SubstitutionList subs,
-                                   HeapLayout const *layout,
-                                   ArrayRef<ParameterConvention> conventions) {
-  llvm::AttributeSet outAttrs;
+static llvm::Function *emitPartialApplicationForwarder(
+    IRGenModule &IGM, llvm::Function *staticFnPtr, bool calleeHasContext,
+    llvm::Type *fnTy, const llvm::AttributeList &origAttrs,
+    CanSILFunctionType origType, CanSILFunctionType substType,
+    CanSILFunctionType outType, SubstitutionList subs, HeapLayout const *layout,
+    ArrayRef<ParameterConvention> conventions) {
+  llvm::AttributeList outAttrs;
 
   llvm::FunctionType *fwdTy = IGM.getFunctionType(outType, outAttrs);
   SILFunctionConventions outConv(outType, IGM.getSILModule());
@@ -768,11 +763,11 @@ static llvm::Function *emitPartialApplicationForwarder(IRGenModule &IGM,
   fwd->setCallingConv(
       expandCallingConv(IGM, SILFunctionTypeRepresentation::Thick));
 
-  auto initialAttrs = IGM.constructInitialAttributes();
-  // Merge initialAttrs with outAttrs.
-  auto updatedAttrs = outAttrs.addAttributes(IGM.getLLVMContext(),
-                        llvm::AttributeSet::FunctionIndex, initialAttrs);
-  fwd->setAttributes(updatedAttrs);
+  fwd->setAttributes(outAttrs);
+  // Merge initial attributes with outAttrs.
+  llvm::AttrBuilder b;
+  IGM.constructInitialFnAttributes(b);
+  fwd->addAttributes(llvm::AttributeList::FunctionIndex, b);
 
   IRGenFunction subIGF(IGM, fwd);
   if (IGM.DebugInfo)
@@ -1489,7 +1484,7 @@ void irgen::emitFunctionPartialApplication(IRGenFunction &IGF,
     assert(bindings.empty());
     assert(args.size() == 1);
 
-    llvm::AttributeSet attrs;
+    llvm::AttributeList attrs;
     auto fnPtrTy = IGF.IGM.getFunctionType(origType, attrs)
       ->getPointerTo();
 
@@ -1570,7 +1565,7 @@ void irgen::emitFunctionPartialApplication(IRGenFunction &IGF,
   assert(args.empty() && "unused args in partial application?!");
   
   // Create the forwarding stub.
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   auto fnPtrTy = IGF.IGM.getFunctionType(origType, attrs)
     ->getPointerTo();
 
diff --git a/lib/IRGen/GenHeap.cpp b/lib/IRGen/GenHeap.cpp
index c1421e1f6e..45587728fe 100644
--- a/lib/IRGen/GenHeap.cpp
+++ b/lib/IRGen/GenHeap.cpp
@@ -1249,9 +1249,9 @@ llvm::Constant *IRGenModule::getFixLifetimeFn() {
   // Don't inline the function, so it stays as a signal to the ARC passes.
   // The ARC passes will remove references to the function when they're
   // no longer needed.
-  fixLifetime->addAttribute(llvm::AttributeSet::FunctionIndex,
+  fixLifetime->addAttribute(llvm::AttributeList::FunctionIndex,
                             llvm::Attribute::NoInline);
-  
+
   // Give the function an empty body.
   auto entry = llvm::BasicBlock::Create(LLVMContext, "", fixLifetime);
   llvm::ReturnInst::Create(LLVMContext, entry);
diff --git a/lib/IRGen/GenMeta.cpp b/lib/IRGen/GenMeta.cpp
index 8b76bfd938..50ce8286bb 100644
--- a/lib/IRGen/GenMeta.cpp
+++ b/lib/IRGen/GenMeta.cpp
@@ -345,9 +345,9 @@ static llvm::Value *emitForeignTypeMetadataRef(IRGenFunction &IGF,
   llvm::Value *candidate = IGF.IGM.getAddrOfForeignTypeMetadataCandidate(type);
   auto call = IGF.Builder.CreateCall(IGF.IGM.getGetForeignTypeMetadataFn(),
                                 candidate);
-  call->addAttribute(llvm::AttributeSet::FunctionIndex,
+  call->addAttribute(llvm::AttributeList::FunctionIndex,
                      llvm::Attribute::NoUnwind);
-  call->addAttribute(llvm::AttributeSet::FunctionIndex,
+  call->addAttribute(llvm::AttributeList::FunctionIndex,
                      llvm::Attribute::ReadNone);
   return call;
 }
@@ -397,7 +397,7 @@ static llvm::Value *emitNominalMetadataRef(IRGenFunction &IGF,
 
   auto result = IGF.Builder.CreateCall(accessor, genericArgs.Values);
   result->setDoesNotThrow();
-  result->addAttribute(llvm::AttributeSet::FunctionIndex,
+  result->addAttribute(llvm::AttributeList::FunctionIndex,
                        llvm::Attribute::ReadNone);
 
   IGF.setScopedLocalTypeData(theType, LocalTypeDataKind::forTypeMetadata(),
@@ -1186,7 +1186,7 @@ static llvm::Value *emitGenericMetadataAccessFunction(IRGenFunction &IGF,
   auto result = IGF.Builder.CreateCall(IGF.IGM.getGetGenericMetadataFn(),
                                        {metadata, arguments});
   result->setDoesNotThrow();
-  result->addAttribute(llvm::AttributeSet::FunctionIndex,
+  result->addAttribute(llvm::AttributeList::FunctionIndex,
                        llvm::Attribute::ReadOnly);
 
   IGF.Builder.CreateLifetimeEnd(argsBuffer,
@@ -1559,7 +1559,7 @@ namespace {
 
         auto result = IGF.Builder.CreateCall(accessor, args);
         result->setDoesNotThrow();
-        result->addAttribute(llvm::AttributeSet::FunctionIndex,
+        result->addAttribute(llvm::AttributeList::FunctionIndex,
                              llvm::Attribute::ReadNone);
 
         return result;
@@ -4518,7 +4518,7 @@ emitHeapMetadataRefForUnknownHeapObject(IRGenFunction &IGF,
                                          object->getName() + ".Type");
   metadata->setCallingConv(llvm::CallingConv::C);
   metadata->setDoesNotThrow();
-  metadata->addAttribute(llvm::AttributeSet::FunctionIndex,
+  metadata->addAttribute(llvm::AttributeList::FunctionIndex,
                          llvm::Attribute::ReadOnly);
   return metadata;
 }
@@ -4657,7 +4657,7 @@ llvm::Value *irgen::emitVirtualMethodValue(IRGenFunction &IGF,
 
   // Use the type of the method we were type-checked against, not the
   // type of the overridden method.
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   auto fnTy = IGF.IGM.getFunctionType(methodType, attrs)->getPointerTo();
 
   auto declaringClass = cast<ClassDecl>(overridden.getDecl()->getDeclContext());
diff --git a/lib/IRGen/GenObjC.cpp b/lib/IRGen/GenObjC.cpp
index 6f3544e37e..994d8ac922 100644
--- a/lib/IRGen/GenObjC.cpp
+++ b/lib/IRGen/GenObjC.cpp
@@ -677,7 +677,7 @@ CallEmission irgen::prepareObjCMethodRootCall(IRGenFunction &IGF,
          "objc method call must be to a func/initializer/getter/setter/dtor");
 
   ForeignFunctionInfo foreignInfo;
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   auto fnTy = IGF.IGM.getFunctionType(origFnType, attrs, &foreignInfo);
   bool indirectResult = foreignInfo.ClangInfo->getReturnInfo().isIndirect();
   if (kind != ObjCMessageKind::Normal)
@@ -787,8 +787,8 @@ static llvm::Function *emitObjCPartialApplicationForwarder(IRGenModule &IGM,
  
   assert(resultType->getRepresentation()
            == SILFunctionType::Representation::Thick);
- 
-  llvm::AttributeSet attrs;
+
+  llvm::AttributeList attrs;
   llvm::FunctionType *fwdTy = IGM.getFunctionType(resultType, attrs);
   // FIXME: Give the thunk a real name.
   // FIXME: Maybe cache the thunk by function and closure types?
@@ -799,11 +799,11 @@ static llvm::Function *emitObjCPartialApplicationForwarder(IRGenModule &IGM,
   fwd->setCallingConv(
       expandCallingConv(IGM, SILFunctionTypeRepresentation::Thick));
 
-  auto initialAttrs = IGM.constructInitialAttributes();
-  // Merge initialAttrs with attrs.
-  auto updatedAttrs = attrs.addAttributes(IGM.getLLVMContext(),
-                        llvm::AttributeSet::FunctionIndex, initialAttrs);
-  fwd->setAttributes(updatedAttrs);
+  fwd->setAttributes(attrs);
+  // Merge initial attributes with attrs.
+  llvm::AttrBuilder b;
+  IGM.constructInitialFnAttributes(b);
+  fwd->addAttributes(llvm::AttributeList::FunctionIndex, b);
   
   IRGenFunction subIGF(IGM, fwd);
   if (IGM.DebugInfo)
diff --git a/lib/IRGen/GenOpaque.cpp b/lib/IRGen/GenOpaque.cpp
index 0a17ba0f3b..d013dec00f 100644
--- a/lib/IRGen/GenOpaque.cpp
+++ b/lib/IRGen/GenOpaque.cpp
@@ -349,27 +349,23 @@ llvm::Value *IRGenFunction::emitValueWitnessForLayout(SILType type,
 static void setHelperAttributesForAggResult(llvm::CallInst *call,
                                             bool isFormalResult = true) {
   // Set as nounwind.
-  auto attrs = llvm::AttributeSet::get(call->getContext(),
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
-
-  attrs = attrs.addAttribute(call->getContext(), 1, llvm::Attribute::NoAlias);
+  auto attrs = llvm::AttributeList::get(call->getContext(),
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
+  call->setAttributes(attrs);
+  call->addParamAttr(0, llvm::Attribute::NoAlias);
 
   // Only set 'sret' if this is also the formal result.
-  if (isFormalResult) {
-    attrs = attrs.addAttribute(call->getContext(), 1,
-                               llvm::Attribute::StructRet);
-  }
-
-  call->setAttributes(attrs);
+  if (isFormalResult)
+    call->addParamAttr(0, llvm::Attribute::StructRet);
 }
 
 /// Given a call to a helper function, set attributes appropriately.
 static void setHelperAttributes(llvm::CallInst *call) {
   // Set as nounwind.
-  auto attrs = llvm::AttributeSet::get(call->getContext(),
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
+  auto attrs = llvm::AttributeList::get(call->getContext(),
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
 
   call->setAttributes(attrs);
 }
diff --git a/lib/IRGen/IRGenDebugInfo.cpp b/lib/IRGen/IRGenDebugInfo.cpp
index 5676f97a23..7e7d336ce9 100644
--- a/lib/IRGen/IRGenDebugInfo.cpp
+++ b/lib/IRGen/IRGenDebugInfo.cpp
@@ -1517,7 +1517,7 @@ IRGenDebugInfoImpl::IRGenDebugInfoImpl(const IRGenOptions &Opts,
   llvm::sys::path::remove_filename(AbsMainFile);
   MainModule = getOrCreateModule(IGM.getSwiftModule(), TheCU, Opts.ModuleName,
                                  AbsMainFile);
-  DBuilder.createImportedModule(MainFile, MainModule, 1);
+  DBuilder.createImportedModule(MainFile, MainModule, MainFile, 0);
 
   // Macro definitions that were defined by the user with "-Xcc -D" on the
   // command line. This does not include any macros defined by ClangImporter.
@@ -1548,7 +1548,8 @@ void IRGenDebugInfoImpl::finalize() {
                                            ModuleDecl::ImportFilter::All);
   for (auto M : ModuleWideImports)
     if (!ImportedModules.count(M.second))
-      DBuilder.createImportedModule(MainFile, getOrCreateModule(M), 0);
+      DBuilder.createImportedModule(MainFile, getOrCreateModule(M), MainFile,
+                                    0);
 
   // Finalize all replaceable forward declarations.
   for (auto &Ty : ReplaceMap) {
@@ -1719,7 +1720,8 @@ void IRGenDebugInfoImpl::emitImport(ImportDecl *D) {
   ModuleDecl::ImportedModule Imported = {D->getModulePath(), M};
   auto DIMod = getOrCreateModule(Imported);
   auto L = getDebugLoc(*this, D);
-  DBuilder.createImportedModule(getOrCreateFile(L.Filename), DIMod, L.Line);
+  auto *File = getOrCreateFile(L.Filename);
+  DBuilder.createImportedModule(File, DIMod, File, L.Line);
   ImportedModules.insert(Imported.second);
 }
 
diff --git a/lib/IRGen/IRGenFunction.cpp b/lib/IRGen/IRGenFunction.cpp
index 1d726bf1af..a85ab7d2c5 100644
--- a/lib/IRGen/IRGenFunction.cpp
+++ b/lib/IRGen/IRGenFunction.cpp
@@ -151,10 +151,10 @@ llvm::Value *IRGenFunction::emitVerifyEndOfLifetimeCall(llvm::Value *object,
 void IRGenFunction::emitAllocBoxCall(llvm::Value *typeMetadata,
                                       llvm::Value *&box,
                                       llvm::Value *&valueAddress) {
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
-  
+  auto attrs = llvm::AttributeList::get(IGM.LLVMContext,
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
+
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getAllocBoxFn(), typeMetadata);
   call->setAttributes(attrs);
@@ -168,9 +168,9 @@ void IRGenFunction::emitMakeBoxUniqueCall(llvm::Value *box,
                                           llvm::Value *alignMask,
                                           llvm::Value *&outBox,
                                           llvm::Value *&outValueAddress) {
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
+  auto attrs = llvm::AttributeList::get(IGM.LLVMContext,
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
 
   llvm::CallInst *call = Builder.CreateCall(IGM.getMakeBoxUniqueFn(),
                                             {box, typeMetadata, alignMask});
@@ -183,9 +183,9 @@ void IRGenFunction::emitMakeBoxUniqueCall(llvm::Value *box,
 
 void IRGenFunction::emitDeallocBoxCall(llvm::Value *box,
                                         llvm::Value *typeMetadata) {
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
+  auto attrs = llvm::AttributeList::get(IGM.LLVMContext,
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
 
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getDeallocBoxFn(), box);
@@ -199,9 +199,8 @@ llvm::Value *IRGenFunction::emitProjectBoxCall(llvm::Value *box,
     llvm::Attribute::NoUnwind,
     llvm::Attribute::ReadNone,
   };
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       attrKinds);
+  auto attrs = llvm::AttributeList::get(
+      IGM.LLVMContext, llvm::AttributeList::FunctionIndex, attrKinds);
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getProjectBoxFn(), box);
   call->setCallingConv(IGM.DefaultCC);
@@ -210,12 +209,9 @@ llvm::Value *IRGenFunction::emitProjectBoxCall(llvm::Value *box,
 }
 
 llvm::Value *IRGenFunction::emitAllocEmptyBoxCall() {
-  llvm::Attribute::AttrKind attrKinds[] = {
-    llvm::Attribute::NoUnwind,
-  };
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       attrKinds);
+  auto attrs = llvm::AttributeList::get(IGM.LLVMContext,
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getAllocEmptyBoxFn(), {});
   call->setCallingConv(IGM.DefaultCC);
diff --git a/lib/IRGen/IRGenModule.cpp b/lib/IRGen/IRGenModule.cpp
index f2d24dd5a5..40f8fc01f9 100644
--- a/lib/IRGen/IRGenModule.cpp
+++ b/lib/IRGen/IRGenModule.cpp
@@ -468,18 +468,8 @@ llvm::Constant *swift::getRuntimeFn(llvm::Module &Module,
     }
     // FIXME: getting attributes here without setting them does
     // nothing. This cannot be fixed until the attributes are correctly specified.
-    fn->getAttributes().
-      addAttributes(Module.getContext(),
-                    llvm::AttributeSet::FunctionIndex,
-                    llvm::AttributeSet::get(Module.getContext(),
-                                            llvm::AttributeSet::FunctionIndex,
-                                            buildFnAttr));
-    fn->getAttributes().
-      addAttributes(Module.getContext(),
-                    llvm::AttributeSet::ReturnIndex,
-                    llvm::AttributeSet::get(Module.getContext(),
-                                            llvm::AttributeSet::ReturnIndex,
-                                            buildRetAttr));
+    //fn->addAttributes(llvm::AttributeList::FunctionIndex, buildFnAttr);
+    //fn->addAttributes(llvm::AttributeList::ReturnIndex, buildRetAttr);
   }
 
   return cache;
@@ -506,7 +496,7 @@ llvm::Constant *swift::getWrapperFn(llvm::Module &Module,
   auto *fun = dyn_cast<llvm::Function>(fn);
   assert(fun && "Wrapper should be an llvm::Function");
   // Do not inline wrappers, because this would result in a code size increase.
-  fun->addAttribute(llvm::AttributeSet::FunctionIndex,
+  fun->addAttribute(llvm::AttributeList::FunctionIndex,
                     llvm::Attribute::NoInline);
   assert(fun->hasFnAttribute(llvm::Attribute::NoInline) &&
          "Wrappers should not be inlined");
@@ -776,33 +766,26 @@ void IRGenerator::addClassForEagerInitialization(ClassDecl *ClassDecl) {
   ClassesForEagerInitialization.push_back(ClassDecl);
 }
 
-llvm::AttributeSet IRGenModule::getAllocAttrs() {
+llvm::AttributeList IRGenModule::getAllocAttrs() {
   if (AllocAttrs.isEmpty()) {
-    AllocAttrs = llvm::AttributeSet::get(LLVMContext,
-                                         llvm::AttributeSet::ReturnIndex,
-                                         llvm::Attribute::NoAlias);
-    AllocAttrs = AllocAttrs.addAttribute(LLVMContext,
-                               llvm::AttributeSet::FunctionIndex,
-                               llvm::Attribute::NoUnwind);
+    AllocAttrs =
+        llvm::AttributeList::get(LLVMContext, llvm::AttributeList::ReturnIndex,
+                                 llvm::Attribute::NoAlias);
+    AllocAttrs =
+        AllocAttrs.addAttribute(LLVMContext, llvm::AttributeList::FunctionIndex,
+                                llvm::Attribute::NoUnwind);
   }
   return AllocAttrs;
 }
 
-/// Construct initial attributes from options.
-llvm::AttributeSet IRGenModule::constructInitialAttributes() {
-  llvm::AttributeSet attrsUpdated;
+/// Construct initial function attributes from options.
+void IRGenModule::constructInitialFnAttributes(llvm::AttrBuilder &Attrs) {
   // Add DisableFPElim. 
   if (!IRGen.Opts.DisableFPElim) {
-    attrsUpdated = attrsUpdated.addAttribute(LLVMContext,
-                     llvm::AttributeSet::FunctionIndex,
-                     "no-frame-pointer-elim", "false");
+    Attrs.addAttribute("no-frame-pointer-elim", "false");
   } else {
-    attrsUpdated = attrsUpdated.addAttribute(
-        LLVMContext, llvm::AttributeSet::FunctionIndex,
-        "no-frame-pointer-elim", "true");
-    attrsUpdated = attrsUpdated.addAttribute(
-        LLVMContext, llvm::AttributeSet::FunctionIndex,
-        "no-frame-pointer-elim-non-leaf");
+    Attrs.addAttribute("no-frame-pointer-elim", "true");
+    Attrs.addAttribute("no-frame-pointer-elim-non-leaf");
   }
 
   // Add target-cpu and target-features if they are non-null.
@@ -811,8 +794,7 @@ llvm::AttributeSet IRGenModule::constructInitialAttributes() {
 
   std::string &CPU = ClangOpts.CPU;
   if (CPU != "")
-    attrsUpdated = attrsUpdated.addAttribute(LLVMContext,
-                     llvm::AttributeSet::FunctionIndex, "target-cpu", CPU);
+    Attrs.addAttribute("target-cpu", CPU);
 
   std::vector<std::string> Features = ClangOpts.Features;
   if (!Features.empty()) {
@@ -824,11 +806,15 @@ llvm::AttributeSet IRGenModule::constructInitialAttributes() {
     }, [&]{
       allFeatures.push_back(',');
     });
-    attrsUpdated = attrsUpdated.addAttribute(LLVMContext,
-                     llvm::AttributeSet::FunctionIndex, "target-features",
-                     allFeatures);
+    Attrs.addAttribute("target-features", allFeatures);
   }
-  return attrsUpdated;
+}
+
+llvm::AttributeList IRGenModule::constructInitialAttributes() {
+  llvm::AttrBuilder b;
+  constructInitialFnAttributes(b);
+  return llvm::AttributeList::get(LLVMContext,
+                                  llvm::AttributeList::FunctionIndex, b);
 }
 
 llvm::Constant *IRGenModule::getSize(Size size) {
@@ -966,21 +952,17 @@ static bool replaceModuleFlagsEntry(llvm::LLVMContext &Ctx,
 }
 
 void IRGenModule::emitAutolinkInfo() {
-
-  // FIXME: This constant should be vended by LLVM somewhere.
-  static const char * const LinkerOptionsFlagName = "Linker Options";
-
   // Collect the linker options already in the module (from ClangCodeGen).
-  auto *LinkerOptions = Module.getModuleFlag(LinkerOptionsFlagName);
-  if (LinkerOptions)
-    for (const auto &LinkOption : cast<llvm::MDNode>(LinkerOptions)->operands())
-      AutolinkEntries.push_back(LinkOption);
+  // FIXME: This constant should be vended by LLVM somewhere.
+  auto *Metadata = Module.getOrInsertNamedMetadata("llvm.linker.options");
+  for (llvm::MDNode *LinkOption : Metadata->operands())
+    AutolinkEntries.push_back(LinkOption);
 
   // Remove duplicates.
-  llvm::SmallPtrSet<llvm::Metadata*, 4> knownAutolinkEntries;
+  llvm::SmallPtrSet<llvm::MDNode *, 4> knownAutolinkEntries;
   AutolinkEntries.erase(std::remove_if(AutolinkEntries.begin(),
                                        AutolinkEntries.end(),
-                                       [&](llvm::Metadata *entry) -> bool {
+                                       [&](llvm::MDNode *entry) -> bool {
                                          return !knownAutolinkEntries.insert(
                                                    entry).second;
                                        }),
@@ -989,21 +971,12 @@ void IRGenModule::emitAutolinkInfo() {
   if ((TargetInfo.OutputObjectFormat == llvm::Triple::COFF &&
        !Triple.isOSCygMing()) ||
       TargetInfo.OutputObjectFormat == llvm::Triple::MachO || Triple.isPS4()) {
-    llvm::LLVMContext &ctx = Module.getContext();
-
-    if (!LinkerOptions) {
-      // Create a new linker flag entry.
-      Module.addModuleFlag(llvm::Module::AppendUnique, LinkerOptionsFlagName,
-                           llvm::MDNode::get(ctx, AutolinkEntries));
-    } else {
-      // Replace the old linker flag entry.
-      bool FoundOldEntry = replaceModuleFlagsEntry(
-          ctx, Module, LinkerOptionsFlagName, llvm::Module::AppendUnique,
-          llvm::MDNode::get(ctx, AutolinkEntries));
-
-      (void)FoundOldEntry;
-      assert(FoundOldEntry && "Could not replace old linker options entry?");
-    }
+
+    // On platforms that support autolinking, continue to use the metadata.
+    Metadata->clearOperands();
+    for (auto *Entry : AutolinkEntries)
+      Metadata->addOperand(Entry);
+
   } else {
     assert((TargetInfo.OutputObjectFormat == llvm::Triple::ELF ||
             Triple.isOSCygMing()) &&
diff --git a/lib/IRGen/IRGenModule.h b/lib/IRGen/IRGenModule.h
index 34e154a37f..3e916449ec 100644
--- a/lib/IRGen/IRGenModule.h
+++ b/lib/IRGen/IRGenModule.h
@@ -57,7 +57,7 @@ namespace llvm {
   class StructType;
   class StringRef;
   class Type;
-  class AttributeSet;
+  class AttributeList;
 }
 namespace clang {
   class ASTContext;
@@ -726,7 +726,7 @@ private:
   /// present in the object file; bitcast to i8*. This is used for
   /// forcing visibility of symbols which may otherwise be optimized
   /// out.
-  SmallVector<llvm::WeakVH, 4> LLVMUsed;
+  SmallVector<llvm::WeakTrackingVH, 4> LLVMUsed;
 
   /// LLVMCompilerUsed - List of global values which are required to be
   /// present in the object file; bitcast to i8*. This is used for
@@ -734,21 +734,18 @@ private:
   /// out.
   ///
   /// Similar to LLVMUsed, but emitted as llvm.compiler.used.
-  SmallVector<llvm::WeakVH, 4> LLVMCompilerUsed;
+  SmallVector<llvm::WeakTrackingVH, 4> LLVMCompilerUsed;
 
   /// Metadata nodes for autolinking info.
-  ///
-  /// This is typed using llvm::Value instead of llvm::MDNode because it
-  /// needs to be used to produce another MDNode during finalization.
-  SmallVector<llvm::Metadata *, 32> AutolinkEntries;
+  SmallVector<llvm::MDNode *, 32> AutolinkEntries;
 
   /// List of Objective-C classes, bitcast to i8*.
-  SmallVector<llvm::WeakVH, 4> ObjCClasses;
+  SmallVector<llvm::WeakTrackingVH, 4> ObjCClasses;
   /// List of Objective-C classes that require nonlazy realization, bitcast to
   /// i8*.
-  SmallVector<llvm::WeakVH, 4> ObjCNonLazyClasses;
+  SmallVector<llvm::WeakTrackingVH, 4> ObjCNonLazyClasses;
   /// List of Objective-C categories, bitcast to i8*.
-  SmallVector<llvm::WeakVH, 4> ObjCCategories;
+  SmallVector<llvm::WeakTrackingVH, 4> ObjCCategories;
   /// List of protocol conformances to generate records for.
   SmallVector<NormalProtocolConformance *, 4> ProtocolConformances;
   /// List of nominal types to generate type metadata records for.
@@ -761,10 +758,10 @@ private:
   /// The interesting global variables relating to an ObjC protocol.
   struct ObjCProtocolPair {
     /// The global variable that contains the protocol record.
-    llvm::WeakVH record;
+    llvm::WeakTrackingVH record;
     /// The global variable that contains the indirect reference to the
     /// protocol record.
-    llvm::WeakVH ref;
+    llvm::WeakTrackingVH ref;
   };
 
   llvm::DenseMap<ProtocolDecl*, ObjCProtocolPair> ObjCProtocols;
@@ -868,7 +865,7 @@ public:
   ClassDecl *getObjCRuntimeBaseClass(Identifier name, Identifier objcName);
   llvm::Module *getModule() const;
   llvm::Module *releaseModule();
-  llvm::AttributeSet getAllocAttrs();
+  llvm::AttributeList getAllocAttrs();
 
 private:
   llvm::Constant *EmptyTupleMetadata = nullptr;
@@ -877,7 +874,7 @@ private:
   llvm::Constant *ObjCISAMaskPtr = nullptr;
   Optional<llvm::Value*> ObjCRetainAutoreleasedReturnValueMarker;
   llvm::DenseMap<Identifier, ClassDecl*> SwiftRootClasses;
-  llvm::AttributeSet AllocAttrs;
+  llvm::AttributeList AllocAttrs;
 
 #define FUNCTION_ID(Id)             \
 public:                             \
@@ -916,7 +913,8 @@ public:
   /// invalid.
   bool finalize();
 
-  llvm::AttributeSet constructInitialAttributes();
+  void constructInitialFnAttributes(llvm::AttrBuilder &Attrs);
+  llvm::AttributeList constructInitialAttributes();
 
   void emitProtocolDecl(ProtocolDecl *D);
   void emitEnumDecl(EnumDecl *D);
@@ -936,7 +934,7 @@ public:
   void finishEmitAfterTopLevel();
 
   llvm::FunctionType *getFunctionType(CanSILFunctionType type,
-                                      llvm::AttributeSet &attrs,
+                                      llvm::AttributeList &attrs,
                                       ForeignFunctionInfo *foreignInfo=nullptr);
   ForeignFunctionInfo getForeignFunctionInfo(CanSILFunctionType type);
 
@@ -1040,10 +1038,10 @@ public:
   void setTrueConstGlobal(llvm::GlobalVariable *var);
 
   /// Add the swiftself attribute.
-  void addSwiftSelfAttributes(llvm::AttributeSet &attrs, unsigned argIndex);
+  void addSwiftSelfAttributes(llvm::AttributeList &attrs, unsigned argIndex);
 
   /// Add the swifterror attribute.
-  void addSwiftErrorAttributes(llvm::AttributeSet &attrs, unsigned argIndex);
+  void addSwiftErrorAttributes(llvm::AttributeList &attrs, unsigned argIndex);
 
 private:
   llvm::Constant *getAddrOfLLVMVariable(LinkEntity entity,
diff --git a/lib/IRGen/IRGenSIL.cpp b/lib/IRGen/IRGenSIL.cpp
index 8efbd076c7..165f0a8d85 100644
--- a/lib/IRGen/IRGenSIL.cpp
+++ b/lib/IRGen/IRGenSIL.cpp
@@ -2080,7 +2080,7 @@ static CallEmission getCallEmissionForLoweredValue(IRGenSILFunction &IGF,
     }
 
     // Cast the callee pointer to the right function type.
-    llvm::AttributeSet attrs;
+    llvm::AttributeList attrs;
     llvm::FunctionType *fnTy =
       IGF.IGM.getFunctionType(origCalleeType, attrs, &foreignInfo);
     calleeFn = IGF.Builder.CreateBitCast(calleeFn, fnTy->getPointerTo());
@@ -2100,8 +2100,9 @@ static CallEmission getCallEmissionForLoweredValue(IRGenSILFunction &IGF,
                                            foreignInfo);
   CallEmission callEmission(IGF, callee);
   if (IGF.CurSILFn->isThunk())
-    callEmission.addAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::NoInline);
-  
+    callEmission.addAttribute(llvm::AttributeList::FunctionIndex,
+                              llvm::Attribute::NoInline);
+
   return callEmission;
 }
 
diff --git a/lib/IRGen/Signature.h b/lib/IRGen/Signature.h
index 9c7d0bd0fc..d4a3d0237c 100644
--- a/lib/IRGen/Signature.h
+++ b/lib/IRGen/Signature.h
@@ -49,7 +49,7 @@ public:
 /// A signature represents something which can actually be called.
 class Signature {
   llvm::FunctionType *Type = nullptr;
-  llvm::AttributeSet Attributes;
+  llvm::AttributeList Attributes;
   ForeignFunctionInfo ForeignInfo;
 
 public:
@@ -64,7 +64,7 @@ public:
     return Type;
   }
 
-  llvm::AttributeSet getAttributes() const {
+  llvm::AttributeList getAttributes() const {
     assert(isValid());
     return Attributes;
   }
diff --git a/lib/LLVMPasses/ARCEntryPointBuilder.h b/lib/LLVMPasses/ARCEntryPointBuilder.h
index 144e92e76c..32392cb019 100644
--- a/lib/LLVMPasses/ARCEntryPointBuilder.h
+++ b/lib/LLVMPasses/ARCEntryPointBuilder.h
@@ -45,7 +45,7 @@ class ARCEntryPointBuilder {
   using CallInst = llvm::CallInst;
   using Value = llvm::Value;
   using Module = llvm::Module;
-  using AttributeSet = llvm::AttributeSet;
+  using AttributeList = llvm::AttributeList;
   using Attribute = llvm::Attribute;
   using APInt = llvm::APInt;
   
@@ -266,12 +266,12 @@ private:
     
     auto *ObjectPtrTy = getObjectPtrTy();
     auto &M = getModule();
-    auto AttrList = AttributeSet::get(M.getContext(), 1, Attribute::NoCapture);
+    auto AttrList = AttributeList::get(M.getContext(), 1, Attribute::NoCapture);
     AttrList = AttrList.addAttribute(
-        M.getContext(), AttributeSet::FunctionIndex, Attribute::NoUnwind);
+        M.getContext(), AttributeList::FunctionIndex, Attribute::NoUnwind);
     CheckUnowned = M.getOrInsertFunction("swift_checkUnowned", AttrList,
                                          Type::getVoidTy(M.getContext()),
-                                         ObjectPtrTy, nullptr);
+                                         ObjectPtrTy);
     if (llvm::Triple(M.getTargetTriple()).isOSBinFormatCOFF() &&
         !llvm::Triple(M.getTargetTriple()).isOSCygMing())
       if (auto *F = llvm::dyn_cast<llvm::Function>(CheckUnowned.get()))
diff --git a/lib/LLVMPasses/LLVMMergeFunctions.cpp b/lib/LLVMPasses/LLVMMergeFunctions.cpp
index 5185bc3440..25feb51bfc 100644
--- a/lib/LLVMPasses/LLVMMergeFunctions.cpp
+++ b/lib/LLVMPasses/LLVMMergeFunctions.cpp
@@ -37,6 +37,7 @@
 #include "llvm/ADT/SmallSet.h"
 #include "llvm/ADT/Statistic.h"
 #include "llvm/ADT/Hashing.h"
+#include "llvm/IR/Attributes.h"
 #include "llvm/IR/CallSite.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DataLayout.h"
@@ -366,7 +367,7 @@ private:
 
   /// A work queue of functions that may have been modified and should be
   /// analyzed again.
-  std::vector<WeakVH> Deferred;
+  std::vector<WeakTrackingVH> Deferred;
 
   /// The set of all distinct functions. Use the insert() and remove() methods
   /// to modify it. The map allows efficient lookup and deferring of Functions.
@@ -389,7 +390,7 @@ private:
 
   /// Checks the rules of order relation introduced among functions set.
   /// Returns true, if sanity check has been passed, and false if failed.
-  bool doSanityCheck(std::vector<WeakVH> &Worklist);
+  bool doSanityCheck(std::vector<WeakTrackingVH> &Worklist);
 
   /// Updates the numUnhandledCallees of all user functions of the equivalence
   /// class containing \p FE by \p Delta.
@@ -434,7 +435,7 @@ llvm::ModulePass *swift::createSwiftMergeFunctionsPass() {
   return new SwiftMergeFunctions();
 }
 
-bool SwiftMergeFunctions::doSanityCheck(std::vector<WeakVH> &Worklist) {
+bool SwiftMergeFunctions::doSanityCheck(std::vector<WeakTrackingVH> &Worklist) {
   if (const unsigned Max = NumFunctionsForSanityCheck) {
     unsigned TripleNumber = 0;
     bool Valid = true;
@@ -442,10 +443,12 @@ bool SwiftMergeFunctions::doSanityCheck(std::vector<WeakVH> &Worklist) {
     dbgs() << "MERGEFUNC-SANITY: Started for first " << Max << " functions.\n";
 
     unsigned i = 0;
-    for (std::vector<WeakVH>::iterator I = Worklist.begin(), E = Worklist.end();
+    for (std::vector<WeakTrackingVH>::iterator I = Worklist.begin(),
+                                               E = Worklist.end();
          I != E && i < Max; ++I, ++i) {
       unsigned j = i;
-      for (std::vector<WeakVH>::iterator J = I; J != E && j < Max; ++J, ++j) {
+      for (std::vector<WeakTrackingVH>::iterator J = I; J != E && j < Max;
+           ++J, ++j) {
         Function *F1 = cast<Function>(*I);
         Function *F2 = cast<Function>(*J);
         int Res1 = SwiftFunctionComparator(F1, F2, &GlobalNumbers).
@@ -466,7 +469,7 @@ bool SwiftMergeFunctions::doSanityCheck(std::vector<WeakVH> &Worklist) {
           continue;
 
         unsigned k = j;
-        for (std::vector<WeakVH>::iterator K = J; K != E && k < Max;
+        for (std::vector<WeakTrackingVH>::iterator K = J; K != E && k < Max;
              ++k, ++K, ++TripleNumber) {
           if (K == J)
             continue;
@@ -584,12 +587,12 @@ bool SwiftMergeFunctions::runOnModule(Module &M) {
     // consider merging it. Otherwise it is dropped and never considered again.
     if ((I != S && std::prev(I)->first == I->first) ||
         (std::next(I) != IE && std::next(I)->first == I->first) ) {
-      Deferred.push_back(WeakVH(F));
+      Deferred.push_back(WeakTrackingVH(F));
     }
   }
 
   do {
-    std::vector<WeakVH> Worklist;
+    std::vector<WeakTrackingVH> Worklist;
     Deferred.swap(Worklist);
 
     DEBUG(dbgs() << "======\nbuild tree: worklist-size=" << Worklist.size() <<
@@ -599,10 +602,10 @@ bool SwiftMergeFunctions::runOnModule(Module &M) {
     SmallVector<FunctionEntry *, 8> FuncsToMerge;
 
     // Insert all candidates into the Worklist.
-    for (std::vector<WeakVH>::iterator I = Worklist.begin(),
-           E = Worklist.end(); I != E; ++I) {
-      if (!*I) continue;
-      Function *F = cast<Function>(*I);
+    for (WeakTrackingVH &I : Worklist) {
+      if (!I)
+        continue;
+      Function *F = cast<Function>(I);
       FunctionEntry *FE = getEntry(F);
       assert(!isInEquivalenceClass(FE));
 
@@ -1047,14 +1050,11 @@ bool SwiftMergeFunctions::replaceDirectCallers(Function *Old, Function *New,
 
   for (CallInst *CI : Callers) {
     auto &Context = New->getContext();
-    auto NewFuncAttrs = New->getAttributes();
-    auto CallSiteAttrs = CI->getAttributes();
-
-    CallSiteAttrs = CallSiteAttrs.addAttributes(
-        Context, AttributeSet::ReturnIndex, NewFuncAttrs.getRetAttributes());
+    auto NewPAL = New->getAttributes();
 
     SmallVector<Type *, 8> OldParamTypes;
     SmallVector<Value *, 16> NewArgs;
+    SmallVector<AttributeSet, 8> NewArgAttrs;
     IRBuilder<> Builder(CI);
 
     FunctionType *NewFuncTy = New->getFunctionType();
@@ -1063,10 +1063,7 @@ bool SwiftMergeFunctions::replaceDirectCallers(Function *Old, Function *New,
     
     // Add the existing parameters.
     for (Value *OldArg : CI->arg_operands()) {
-      AttributeSet Attrs = NewFuncAttrs.getParamAttributes(ParamIdx);
-      if (Attrs.getNumSlots())
-        CallSiteAttrs = CallSiteAttrs.addAttributes(Context, ParamIdx, Attrs);
-
+      NewArgAttrs.push_back(NewPAL.getParamAttributes(ParamIdx));
       NewArgs.push_back(OldArg);
       OldParamTypes.push_back(OldArg->getType());
       ++ParamIdx;
@@ -1090,8 +1087,11 @@ bool SwiftMergeFunctions::replaceDirectCallers(Function *Old, Function *New,
     Value *Callee = ConstantExpr::getBitCast(New, FPtrType);
     CallInst *NewCI = Builder.CreateCall(Callee, NewArgs);
     NewCI->setCallingConv(CI->getCallingConv());
-    NewCI->setAttributes(CallSiteAttrs);
-
+    // Don't transfer attributes from the function to the callee. Function
+    // attributes typically aren't relevant to the calling convention or ABI.
+    NewCI->setAttributes(AttributeList::get(Context, /*FnAttrs=*/AttributeSet(),
+                                            NewPAL.getRetAttributes(),
+                                            NewArgAttrs));
     CI->replaceAllUsesWith(NewCI);
     CI->eraseFromParent();
   }
diff --git a/lib/Option/Options.cpp b/lib/Option/Options.cpp
index bb4baa07f1..639a332000 100644
--- a/lib/Option/Options.cpp
+++ b/lib/Option/Options.cpp
@@ -24,10 +24,10 @@ using namespace llvm::opt;
 #undef PREFIX
 
 static const OptTable::Info InfoTable[] = {
-#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM, \
-HELPTEXT, METAVAR)   \
-{ PREFIX, NAME, HELPTEXT, METAVAR, OPT_##ID, Option::KIND##Class, PARAM, \
-FLAGS, OPT_##GROUP, OPT_##ALIAS, ALIASARGS },
+#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,  \
+               HELPTEXT, METAVAR, VALUES)                                      \
+  {PREFIX, NAME,  HELPTEXT,    METAVAR,     OPT_##ID,  Option::KIND##Class,    \
+   PARAM,  FLAGS, OPT_##GROUP, OPT_##ALIAS, ALIASARGS, VALUES},
 #include "swift/Option/Options.inc"
 #undef OPTION
 };
diff --git a/lib/SIL/Dominance.cpp b/lib/SIL/Dominance.cpp
index b56c8dce20..1fdaf8c8be 100644
--- a/lib/SIL/Dominance.cpp
+++ b/lib/SIL/Dominance.cpp
@@ -19,15 +19,23 @@
 
 using namespace swift;
 
-template class llvm::DominatorTreeBase<SILBasicBlock>;
-template class llvm::DominatorBase<SILBasicBlock>;
+template class llvm::DominatorTreeBase<SILBasicBlock, false>;
+template class llvm::DominatorTreeBase<SILBasicBlock, true>;
 template class llvm::DomTreeNodeBase<SILBasicBlock>;
+using SILDomTree = llvm::DomTreeBase<SILBasicBlock>;
+using SILPostDomTree = llvm::PostDomTreeBase<SILBasicBlock>;
+template void
+llvm::DomTreeBuilder::Calculate<SILDomTree, swift::SILFunction>(
+    SILDomTree &DT, swift::SILFunction &F);
+template void
+llvm::DomTreeBuilder::Calculate<SILPostDomTree, swift::SILFunction>(
+    SILPostDomTree &DT, swift::SILFunction &F);
 
 /// Compute the immediate-dominators map.
 DominanceInfo::DominanceInfo(SILFunction *F)
-    : DominatorTreeBase(/*isPostDom*/ false) {
-      assert(!F->isExternalDeclaration() &&
-             "Make sure the function is a definition and not a declaration.");
+    : DominatorTreeBase() {
+  assert(!F->isExternalDeclaration() &&
+         "Make sure the function is a definition and not a declaration.");
   recalculate(*F);
 }
 
@@ -81,7 +86,7 @@ void DominanceInfo::verify() const {
 
 /// Compute the immediate-post-dominators map.
 PostDominanceInfo::PostDominanceInfo(SILFunction *F)
-  : DominatorTreeBase(/*isPostDom*/ true) {
+   : PostDominatorTreeBase() {
   assert(!F->isExternalDeclaration() &&
          "Cannot construct a post dominator tree for a declaration");
   recalculate(*F);
diff --git a/lib/SIL/SILBasicBlock.cpp b/lib/SIL/SILBasicBlock.cpp
index 0dd43906be..d69ae25717 100644
--- a/lib/SIL/SILBasicBlock.cpp
+++ b/lib/SIL/SILBasicBlock.cpp
@@ -355,3 +355,7 @@ bool SILBasicBlock::isTrampoline() const {
     return false;
   return begin() == Branch->getIterator();
 }
+
+bool SILBasicBlock::isLegalToHoistInto() const {
+  return true;
+}
diff --git a/lib/SIL/SILInstructions.cpp b/lib/SIL/SILInstructions.cpp
index 4e231d068f..4e435b53b2 100644
--- a/lib/SIL/SILInstructions.cpp
+++ b/lib/SIL/SILInstructions.cpp
@@ -547,7 +547,8 @@ const BuiltinInfo &BuiltinInst::getBuiltinInfo() const {
 }
 
 static unsigned getWordsForBitWidth(unsigned bits) {
-  return (bits + llvm::integerPartWidth - 1)/llvm::integerPartWidth;
+  return ((bits + llvm::APInt::APINT_BITS_PER_WORD - 1)
+          / llvm::APInt::APINT_BITS_PER_WORD);
 }
 
 template<typename INST>
@@ -559,7 +560,7 @@ template<typename INST>
 static void *allocateLiteralInstWithBitSize(SILFunction &F, unsigned bits) {
   unsigned words = getWordsForBitWidth(bits);
   return F.getModule().allocateInst(
-      sizeof(INST) + sizeof(llvm::integerPart)*words, alignof(INST));
+      sizeof(INST) + sizeof(llvm::APInt::WordType)*words, alignof(INST));
 }
 
 IntegerLiteralInst::IntegerLiteralInst(SILDebugLocation Loc, SILType Ty,
@@ -567,7 +568,7 @@ IntegerLiteralInst::IntegerLiteralInst(SILDebugLocation Loc, SILType Ty,
     : LiteralInst(ValueKind::IntegerLiteralInst, Loc, Ty),
       numBits(Value.getBitWidth()) {
   std::uninitialized_copy_n(Value.getRawData(), Value.getNumWords(),
-                            getTrailingObjects<llvm::integerPart>());
+                            getTrailingObjects<llvm::APInt::WordType>());
 }
 
 IntegerLiteralInst *IntegerLiteralInst::create(SILDebugLocation Loc,
@@ -603,7 +604,7 @@ IntegerLiteralInst *IntegerLiteralInst::create(IntegerLiteralExpr *E,
 
 /// getValue - Return the APInt for the underlying integer literal.
 APInt IntegerLiteralInst::getValue() const {
-  return APInt(numBits, {getTrailingObjects<llvm::integerPart>(),
+  return APInt(numBits, {getTrailingObjects<llvm::APInt::WordType>(),
                          getWordsForBitWidth(numBits)});
 }
 
@@ -612,7 +613,7 @@ FloatLiteralInst::FloatLiteralInst(SILDebugLocation Loc, SILType Ty,
     : LiteralInst(ValueKind::FloatLiteralInst, Loc, Ty),
       numBits(Bits.getBitWidth()) {
         std::uninitialized_copy_n(Bits.getRawData(), Bits.getNumWords(),
-                                  getTrailingObjects<llvm::integerPart>());
+                                  getTrailingObjects<llvm::APInt::WordType>());
 }
 
 FloatLiteralInst *FloatLiteralInst::create(SILDebugLocation Loc, SILType Ty,
@@ -642,7 +643,7 @@ FloatLiteralInst *FloatLiteralInst::create(FloatLiteralExpr *E,
 }
 
 APInt FloatLiteralInst::getBits() const {
-  return APInt(numBits, {getTrailingObjects<llvm::integerPart>(),
+  return APInt(numBits, {getTrailingObjects<llvm::APInt::WordType>(),
                          getWordsForBitWidth(numBits)});
 }
 
diff --git a/lib/SILOptimizer/SILCombiner/SILCombinerMiscVisitors.cpp b/lib/SILOptimizer/SILCombiner/SILCombinerMiscVisitors.cpp
index 94d166d14e..8301cd8666 100644
--- a/lib/SILOptimizer/SILCombiner/SILCombinerMiscVisitors.cpp
+++ b/lib/SILOptimizer/SILCombiner/SILCombinerMiscVisitors.cpp
@@ -28,6 +28,7 @@
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
+#include "llvm/Support/CommandLine.h"
 
 using namespace swift;
 using namespace swift::PatternMatch;
diff --git a/lib/SILOptimizer/Transforms/StackPromotion.cpp b/lib/SILOptimizer/Transforms/StackPromotion.cpp
index f31b42ae36..7a4590157d 100644
--- a/lib/SILOptimizer/Transforms/StackPromotion.cpp
+++ b/lib/SILOptimizer/Transforms/StackPromotion.cpp
@@ -10,7 +10,6 @@
 //
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "stack-promotion"
 #include "swift/SILOptimizer/PassManager/Passes.h"
 #include "swift/SILOptimizer/PassManager/Transforms.h"
 #include "swift/SILOptimizer/Analysis/EscapeAnalysis.h"
@@ -22,6 +21,8 @@
 #include "llvm/Support/GenericDomTreeConstruction.h"
 #include "llvm/ADT/Statistic.h"
 
+#define DEBUG_TYPE "stack-promotion"
+
 STATISTIC(NumStackPromoted, "Number of objects promoted to the stack");
 
 using namespace swift;
@@ -51,7 +52,7 @@ class StackPromoter {
   //
   // We want to get bb2 as immediate post-dominator of bb1. This is not the case
   // with the regular post-dominator tree.
-  llvm::DominatorTreeBase<SILBasicBlock> PostDomTree;
+  PostDominatorTreeBase PostDomTree;
 
   bool PostDomTreeValid;
 
@@ -158,7 +159,7 @@ class StackPromoter {
     if (!PostDomTreeValid) {
       // The StackPromoter acts as a "graph" for which the post-dominator-tree
       // is calculated.
-      PostDomTree.recalculate(*this);
+      PostDomTree.recalculate(*F);
       PostDomTreeValid = true;
     }
   }
@@ -167,7 +168,7 @@ public:
 
   StackPromoter(SILFunction *F, EscapeAnalysis::ConnectionGraph *ConGraph,
                 DominanceInfo *DT, EscapeAnalysis *EA) :
-    F(F), ConGraph(ConGraph), DT(DT), EA(EA), PostDomTree(true),
+    F(F), ConGraph(ConGraph), DT(DT), EA(EA),
     PostDomTreeValid(false) { }
 
   SILFunction *getFunction() const { return F; }
diff --git a/test/ClangImporter/MixedSource/mixed-target-using-module.swift b/test/ClangImporter/MixedSource/mixed-target-using-module.swift
index a52bd422ef..d1661865ad 100644
--- a/test/ClangImporter/MixedSource/mixed-target-using-module.swift
+++ b/test/ClangImporter/MixedSource/mixed-target-using-module.swift
@@ -4,8 +4,7 @@
 
 // REQUIRES: objc_interop
 
-// CHECK-AUTOLINK: !{{[0-9]+}} = !{i32 {{[0-9]+}}, !"Linker Options", ![[LINK_LIST:[0-9]+]]}
-// CHECK-AUTOLINK: ![[LINK_LIST]] = !{
+// CHECK-AUTOLINK: !llvm.linker.options = !{
 // CHECK-AUTOLINK-NOT: metadata !"-framework", metadata !"Mixed"
 
 // CHECK-WRONG-NAME: underlying Objective-C module 'WrongName' not found
diff --git a/test/ClangImporter/autolinking.swift b/test/ClangImporter/autolinking.swift
index de873500ce..6e3f9380d8 100644
--- a/test/ClangImporter/autolinking.swift
+++ b/test/ClangImporter/autolinking.swift
@@ -27,8 +27,7 @@ import UsesSubmodule
 _ = LinkFramework.IComeFromLinkFramework
 UsesSubmodule.useSomethingFromSubmodule()
 
-// CHECK: !{{[0-9]+}} = !{i32 6, !"Linker Options", ![[LINK_LIST:[0-9]+]]}
-// CHECK: ![[LINK_LIST]] = !{
+// CHECK: !llvm.linker.options = !{
 
 // CHECK-DAG: !{{[0-9]+}} = !{!"-lLock"}
 // CHECK-DAG: !{{[0-9]+}} = !{!"-lStock"}
diff --git a/test/ClangImporter/requires.swift b/test/ClangImporter/requires.swift
index e0f979ab9f..9b823f4d24 100644
--- a/test/ClangImporter/requires.swift
+++ b/test/ClangImporter/requires.swift
@@ -3,5 +3,7 @@
 import Requires.Swift // OK
 import Requires.NotSwift
 // CHECK-NOT: error
+// CHECK: error: module 'Requires.NotSwift' is incompatible with feature 'swift'
+// CHECK-NOT: error
 // CHECK: error: no such module 'Requires.NotSwift'
 // CHECK-NOT: error
diff --git a/test/DebugInfo/ImportClangSubmodule.swift b/test/DebugInfo/ImportClangSubmodule.swift
index 6c6b8093fb..008424fb14 100644
--- a/test/DebugInfo/ImportClangSubmodule.swift
+++ b/test/DebugInfo/ImportClangSubmodule.swift
@@ -22,7 +22,8 @@
 // CHECK-SAME:                              {{..}}-DFOO=foo{{..}}
 // CHECK-SAME:                              {{..}}-UBAR{{..}}
 
-// CHECK: !DIImportedEntity({{.*}}, entity: ![[SUBMODULE]], line: [[@LINE+1]])
+// CHECK: !DIImportedEntity({{.*}}, entity: ![[SUBMODULE]], file:
+// CHECK-SAME:              line: [[@LINE+1]])
 import ClangModule.SubModule
 // CHECK: !DIImportedEntity({{.*}}, entity: ![[OTHERSUBMODULE]],
 // CHECK-SAME:              line: [[@LINE+1]])
@@ -32,10 +33,10 @@ import OtherClangModule.SubModule
 // submodule's top-level-module, even if we didn't ask for it.
 // CHECK-NOT: !DIImportedEntity({{.*}}, entity: ![[SUBMODULE]]
 // CHECK-NOT: !DIImportedEntity({{.*}}, entity: ![[OTHERSUBMODULE]]
-// CHECK: !DIImportedEntity({{.*}}, entity: ![[CLANGMODULE]])
+// CHECK: !DIImportedEntity({{.*}}, entity: ![[CLANGMODULE]]
 // CHECK-NOT: !DIImportedEntity({{.*}}, entity: ![[SUBMODULE]]
 // CHECK-NOT: !DIImportedEntity({{.*}}, entity: ![[OTHERSUBMODULE]]
-// CHECK: !DIImportedEntity({{.*}}, entity: ![[OTHERCLANGMODULE]])
+// CHECK: !DIImportedEntity({{.*}}, entity: ![[OTHERCLANGMODULE]]
 // CHECK-NOT: !DIImportedEntity({{.*}}, entity: ![[SUBMODULE]]
 // CHECK-NOT: !DIImportedEntity({{.*}}, entity: ![[OTHERSUBMODULE]]
 
diff --git a/test/DebugInfo/basic.swift b/test/DebugInfo/basic.swift
index 5ad5134dca..4f9673aa2e 100644
--- a/test/DebugInfo/basic.swift
+++ b/test/DebugInfo/basic.swift
@@ -79,7 +79,7 @@ func foo(_ a: Int64, _ b: Int64) -> Int64 {
 // CHECK-DAG: ![[INT64:.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: "Int64", {{.*}}, identifier: "_T0s5Int64VD")
 // CHECK-DAG: ![[PARAMTYPES]] = !{![[INT64]], ![[INT64]], ![[INT64]]}
 // Import of the main module with the implicit name.
-// CHECK-DAG: !DIImportedEntity(tag: DW_TAG_imported_module, scope: ![[MAINFILE]], entity: ![[MAINMODULE:[0-9]+]], line: 1)
+// CHECK-DAG: !DIImportedEntity(tag: DW_TAG_imported_module, scope: ![[MAINFILE]], entity: ![[MAINMODULE:[0-9]+]], file: ![[MAINFILE]], line: 1)
 // CHECK-DAG: ![[MAINMODULE]] = !DIModule({{.*}}, name: "basic"
 
 // DWARF Version
diff --git a/test/DebugInfo/inlined-generics.swift b/test/DebugInfo/inlined-generics.swift
index 21569112fa..9ec85592ae 100644
--- a/test/DebugInfo/inlined-generics.swift
+++ b/test/DebugInfo/inlined-generics.swift
@@ -12,7 +12,7 @@ func foo1<T:P>(_ t: T, _ dt: T.DT1) -> T.DT1 {
 
 // CHECK: define {{.*}}@_T04main4foo2yxAA1PRzlF
 public func foo2<S:P>(_ s: S) {
-  // CHECK: call void @llvm.dbg.value(metadata %swift.type* %S.DT1, i64 0,
+  // CHECK: call void @llvm.dbg.value(metadata %swift.type* %S.DT1,
   // CHECK-SAME:                     metadata ![[META:[0-9]+]]
   foo1(s, s.getDT())
   // T.DT1 should get substituted with S.DT1.
diff --git a/test/DebugInfo/letclause.swift b/test/DebugInfo/letclause.swift
index 2dd62f116b..24e593109b 100644
--- a/test/DebugInfo/letclause.swift
+++ b/test/DebugInfo/letclause.swift
@@ -7,7 +7,7 @@ func peek() -> Symbol? { return Symbol() }
 func foo() {
 // CHECK: define {{.*}}foo
 // CHECK: call void @llvm.dbg.value(metadata i{{.*}} 0,
-// CHECK-SAME:                        metadata ![[S:.*]], metadata !{{[0-9]+}})
+// CHECK-SAME:                      metadata ![[S:.*]], metadata !{{[0-9]+}})
 // CHECK: ![[S]] = !DILocalVariable(name: "s"
 // CHECK-SAME:                      line: [[@LINE+1]],
   while let s = peek() {
diff --git a/test/DebugInfo/linetable.swift b/test/DebugInfo/linetable.swift
index f9ba1c22a7..d21b0a08f7 100644
--- a/test/DebugInfo/linetable.swift
+++ b/test/DebugInfo/linetable.swift
@@ -52,7 +52,6 @@ func main(_ x: Int64) -> Void
 // ASM-CHECK: {{^_?_T09linetable4mainys5Int64VFyycfU_Tf2in_n:}}
 // ASM-CHECK-NOT: retq
 // The end-of-prologue should have a valid location (0 is ok, too).
-// ASM-CHECK: .loc [[FILEID]] 0 {{[0-9]+}} prologue_end
-// ASM-CHECK: .loc [[FILEID]] 34 {{[0-9]+}}
+// ASM-CHECK: .loc [[FILEID]] {{0|34}} {{[0-9]+}} prologue_end
 
 main(30)
diff --git a/test/DebugInfo/liverange-extension-vector.swift b/test/DebugInfo/liverange-extension-vector.swift
index d4d35678b5..7320a1c4a4 100644
--- a/test/DebugInfo/liverange-extension-vector.swift
+++ b/test/DebugInfo/liverange-extension-vector.swift
@@ -9,7 +9,7 @@ func getInt32() -> Int32 { return -1 }
 public func rangeExtension(x: Int32, y: Int32) {
   let p = int2(x, y)
   // CHECK: define {{.*}}rangeExtension
-  // CHECK: llvm.dbg.value(metadata <2 x i32> %[[P:.*]], i64 0, metadata
+  // CHECK: llvm.dbg.value(metadata <2 x i32> %[[P:.*]], metadata {{.*}}, metadata
   use(p)
   // CHECK: asm sideeffect "", "r"{{.*}}[[P]]
 }
diff --git a/test/DebugInfo/liverange-extension.swift b/test/DebugInfo/liverange-extension.swift
index d20277f377..e7d2bfea46 100644
--- a/test/DebugInfo/liverange-extension.swift
+++ b/test/DebugInfo/liverange-extension.swift
@@ -7,21 +7,21 @@ func getInt32() -> Int32 { return -1 }
 public func rangeExtension(_ b: Bool) {
   // CHECK: define {{.*}}rangeExtension
   let i = getInt32()
-  // CHECK: llvm.dbg.value(metadata i32 [[I:.*]], i64 0, metadata
+  // CHECK: llvm.dbg.value(metadata i32 [[I:.*]], metadata {{.*}}, metadata
   use(i)
   if b {
     let j = getInt32()
-    // CHECK: llvm.dbg.value(metadata i32 [[I]], i64 0, metadata
-    // CHECK: llvm.dbg.value(metadata i32 [[J:.*]], i64 0, metadata
+    // CHECK: llvm.dbg.value(metadata i32 [[I]], metadata {{.*}}, metadata
+    // CHECK: llvm.dbg.value(metadata i32 [[J:.*]], metadata {{.*}}, metadata
     use(j)
     // CHECK-DAG: {{(asm sideeffect "", "r".*)|(zext i32)}} [[J]]
     // CHECK-DAG: asm sideeffect "", "r"
   }
   let z = getInt32()
   use(z)
-  // CHECK-NOT: llvm.dbg.value(metadata i32 [[J]], i64 0, metadata
-  // CHECK-DAG: llvm.dbg.value(metadata i32 [[I]], i64 0, metadata
-  // CHECK-DAG: llvm.dbg.value(metadata i32 [[Z:.*]], i64 0, metadata
+  // CHECK-NOT: llvm.dbg.value(metadata i32 [[J]], metadata {{.*}}, metadata
+  // CHECK-DAG: llvm.dbg.value(metadata i32 [[I]], metadata {{.*}}, metadata
+  // CHECK-DAG: llvm.dbg.value(metadata i32 [[Z:.*]], metadata {{.*}}, metadata
   // CHECK-DAG: {{(asm sideeffect "", "r".*)|(zext i32)}} [[I]]
   // CHECK-DAG: asm sideeffect "", "r"
 }
diff --git a/test/IRGen/autolink-coff.swift b/test/IRGen/autolink-coff.swift
index a1c1bac801..8fea43263d 100644
--- a/test/IRGen/autolink-coff.swift
+++ b/test/IRGen/autolink-coff.swift
@@ -15,8 +15,7 @@
 import module
 #endif
 
-// CHECK-MSVC-IR: !{{[0-9]+}} = !{i32 {{[0-9]+}}, !"Linker Options", [[NODE:![0-9]+]]}
-// CHECK-MSVC-IR: [[NODE]] = !{[[LIST:![0-9]+]]}
+// CHECK-MSVC-IR: !llvm.linker.options = !{[[LIST:![0-9]+]]}
 // CHECK-MSVC-IR: [[LIST]] = !{!"/DEFAULTLIB:module.lib"}
 
 // CHECK-MSVC-ASM: .section .drectve
diff --git a/test/IRGen/autolink-psei.swift b/test/IRGen/autolink-psei.swift
index 392b15c3a2..98560fedd1 100644
--- a/test/IRGen/autolink-psei.swift
+++ b/test/IRGen/autolink-psei.swift
@@ -7,7 +7,6 @@
 import module
 #endif
 
-// CHECK-IR: !{{[0-9]+}} = !{i32 {{[0-9]+}}, !"Linker Options", [[NODE:![0-9]+]]}
-// CHECK-IR: [[NODE]] = !{[[LIST:![0-9]+]]}
+// CHECK-IR: !llvm.linker.options = !{[[LIST:![0-9]+]]}
 // CHECK-IR: [[LIST]] = !{!"\01module"}
 
diff --git a/test/IRGen/builtins.swift b/test/IRGen/builtins.swift
index 3957411778..b246c9a6a5 100644
--- a/test/IRGen/builtins.swift
+++ b/test/IRGen/builtins.swift
@@ -265,7 +265,7 @@ func fence_test() {
   // CHECK: fence acquire
   Builtin.fence_acquire()
 
-  // CHECK: fence singlethread acq_rel
+  // CHECK: fence syncscope("singlethread") acq_rel
   Builtin.fence_acqrel_singlethread()
 }
 
@@ -286,7 +286,7 @@ func cmpxchg_test(_ ptr: Builtin.RawPointer, a: Builtin.Int32, b: Builtin.Int32)
   // CHECK: store i1 [[Y_SUCCESS]], i1* {{.*}}, align 1
   var (y, ySuccess) = Builtin.cmpxchg_monotonic_monotonic_volatile_Int32(ptr, a, b)
 
-  // CHECK: [[X_RES:%.*]] = cmpxchg volatile i32* {{.*}}, i32 {{.*}}, i32 {{.*}} singlethread acquire monotonic
+  // CHECK: [[X_RES:%.*]] = cmpxchg volatile i32* {{.*}}, i32 {{.*}}, i32 {{.*}} syncscope("singlethread") acquire monotonic
   // CHECK: [[X_VAL:%.*]] = extractvalue { i32, i1 } [[X_RES]], 0
   // CHECK: [[X_SUCCESS:%.*]] = extractvalue { i32, i1 } [[X_RES]], 1
   // CHECK: store i32 [[X_VAL]], i32* {{.*}}, align 4
@@ -318,11 +318,11 @@ func atomicrmw_test(_ ptr: Builtin.RawPointer, a: Builtin.Int32,
   // CHECK: atomicrmw volatile max i32* {{.*}}, i32 {{.*}} monotonic
   var y = Builtin.atomicrmw_max_monotonic_volatile_Int32(ptr, a)
   
-  // CHECK: atomicrmw volatile xchg i32* {{.*}}, i32 {{.*}} singlethread acquire
+  // CHECK: atomicrmw volatile xchg i32* {{.*}}, i32 {{.*}} syncscope("singlethread") acquire
   var x = Builtin.atomicrmw_xchg_acquire_volatile_singlethread_Int32(ptr, a)
   
   // rdar://12939803 - ER: support atomic cmpxchg/xchg with pointers
-  // CHECK: atomicrmw volatile xchg i64* {{.*}}, i64 {{.*}} singlethread acquire
+  // CHECK: atomicrmw volatile xchg i64* {{.*}}, i64 {{.*}} syncscope("singlethread") acquire
   var w = Builtin.atomicrmw_xchg_acquire_volatile_singlethread_RawPointer(ptr, ptr2)
 
 }
@@ -790,9 +790,9 @@ func unsafeGuaranteedEnd_test(_ x: Builtin.Int8) {
 func atomicload(_ p: Builtin.RawPointer) {
   // CHECK: [[A:%.*]] = load atomic i8*, i8** {{%.*}} unordered, align 8
   let a: Builtin.RawPointer = Builtin.atomicload_unordered_RawPointer(p)
-  // CHECK: [[B:%.*]] = load atomic i32, i32* {{%.*}} singlethread monotonic, align 4
+  // CHECK: [[B:%.*]] = load atomic i32, i32* {{%.*}} syncscope("singlethread") monotonic, align 4
   let b: Builtin.Int32 = Builtin.atomicload_monotonic_singlethread_Int32(p)
-  // CHECK: [[C:%.*]] = load atomic volatile i64, i64* {{%.*}} singlethread acquire, align 8
+  // CHECK: [[C:%.*]] = load atomic volatile i64, i64* {{%.*}} syncscope("singlethread") acquire, align 8
   let c: Builtin.Int64 =
     Builtin.atomicload_acquire_volatile_singlethread_Int64(p)
   // CHECK: [[D0:%.*]] = load atomic volatile i32, i32* {{%.*}} seq_cst, align 4
@@ -801,9 +801,9 @@ func atomicload(_ p: Builtin.RawPointer) {
 
   // CHECK: store atomic i8* [[A]], i8** {{%.*}} unordered, align 8
   Builtin.atomicstore_unordered_RawPointer(p, a)
-  // CHECK: store atomic i32 [[B]], i32* {{%.*}} singlethread monotonic, align 4
+  // CHECK: store atomic i32 [[B]], i32* {{%.*}} syncscope("singlethread") monotonic, align 4
   Builtin.atomicstore_monotonic_singlethread_Int32(p, b)
-  // CHECK: store atomic volatile i64 [[C]], i64* {{%.*}} singlethread release, align 8
+  // CHECK: store atomic volatile i64 [[C]], i64* {{%.*}} syncscope("singlethread") release, align 8
   Builtin.atomicstore_release_volatile_singlethread_Int64(p, c)
   // CHECK: [[D1:%.*]] = bitcast float [[D]] to i32
   // CHECK: store atomic volatile i32 [[D1]], i32* {{.*}} seq_cst, align 4
diff --git a/test/IRGen/clang_inline.swift b/test/IRGen/clang_inline.swift
index 37295f29c3..3b15ac4d70 100644
--- a/test/IRGen/clang_inline.swift
+++ b/test/IRGen/clang_inline.swift
@@ -27,7 +27,7 @@ class CallStaticInline {
 }
 
 // CHECK-LABEL: define internal i32 @zero()
-// CHECK:         [[INLINEHINT_SSP_UWTABLE:#[0-9]+]] {
+// CHECK-SAME:         [[INLINEHINT_SSP_UWTABLE:#[0-9]+]] {
 
 // CHECK-LABEL: define hidden swiftcc i64 @_T012clang_inline17CallStaticInline2C10ReturnZeros5Int64VyF(%T12clang_inline17CallStaticInline2C* swiftself) {{.*}} {
 class CallStaticInline2 {
@@ -35,7 +35,7 @@ class CallStaticInline2 {
 }
 
 // CHECK-LABEL: define internal i32 @wrappedZero()
-// CHECK:         [[INLINEHINT_SSP_UWTABLE:#[0-9]+]] {
+// CHECK-SAME:         [[INLINEHINT_SSP_UWTABLE:#[0-9]+]] {
 
 // CHECK-LABEL: define hidden swiftcc i32 @_T012clang_inline10testExterns5Int32VyF() {{.*}} {
 func testExtern() -> CInt {
@@ -43,16 +43,16 @@ func testExtern() -> CInt {
 }
 
 // CHECK-LABEL: define internal i32 @wrappedGetInt()
-// CHECK:         [[INLINEHINT_SSP_UWTABLE:#[0-9]+]] {
+// CHECK-SAME:         [[INLINEHINT_SSP_UWTABLE:#[0-9]+]] {
 
-// CHECK-LABEL: define hidden swiftcc i32 @_T012clang_inline16testAlwaysInlines5Int32VyF()
-// CHECK:       [[SSP:#[0-9]+]] {
-// NEGATIVE-NOT: @alwaysInlineNumber
-// CHECK:   ret i32 17
+// CHECK-LABEL: define hidden swiftcc i32 @_T012clang_inline16testAlwaysInlines5Int32VyF() {{.*}} {
 func testAlwaysInline() -> CInt {
   return alwaysInlineNumber()
 }
 
+// CHECK-LABEL: define internal i32 @alwaysInlineNumber()
+// CHECK-SAME:         [[ALWAYS_INLINE:#[0-9]+]] {
+
 // CHECK-LABEL: define hidden swiftcc i32 @_T012clang_inline20testInlineRedeclareds5Int32VyF() {{.*}} {
 func testInlineRedeclared() -> CInt {
   return zeroRedeclared()
diff --git a/test/IRGen/class_stack_alloc.sil b/test/IRGen/class_stack_alloc.sil
index 076c13ec8f..5baab4a73b 100644
--- a/test/IRGen/class_stack_alloc.sil
+++ b/test/IRGen/class_stack_alloc.sil
@@ -36,7 +36,7 @@ sil_vtable BigClass {}
 // CHECK-NEXT: [[R:%[0-9]+]] = bitcast %swift.refcounted* %reference.new to %[[C]]*
 // CHECK-NEXT: call {{.*}} @swift_rt_swift_release {{.*}} [[R]])
 // CHECK-NEXT: [[O2:%[0-9]+]] = bitcast %[[C]]* [[R]] to i8*
-// CHECK-NEXT: call void @llvm.lifetime.end(i64 -1, i8* [[O2]])
+// CHECK-NEXT: call void @llvm.lifetime.end.p0i8(i64 -1, i8* [[O2]])
 // CHECK-NEXT: ret void
 sil @simple_promote : $@convention(thin) () -> () {
 bb0:
@@ -88,7 +88,7 @@ bb0:
 // CHECK-NEXT: call {{.*}} @swift_setDeallocating {{.*}}(%[[C]]* [[R]])
 // CHECK-NEXT: call swiftcc void @not_inlined_destructor(%[[C]]* [[R]])
 // CHECK-NEXT: [[O2:%[0-9]+]] = bitcast %[[C]]* [[R]] to i8*
-// CHECK-NEXT: call void @llvm.lifetime.end(i64 -1, i8* [[O2]])
+// CHECK-NEXT: call void @llvm.lifetime.end.p0i8(i64 -1, i8* [[O2]])
 // CHECK-NEXT: ret void
 sil @promoted_with_devirtualized_release : $@convention(thin) () -> () {
 bb0:
@@ -110,7 +110,7 @@ bb0:
 // CHECK-NEXT: [[R:%[0-9]+]] = bitcast %swift.refcounted* %reference.new to %[[C]]*
 // CHECK-NOT: call
 // CHECK: [[O2:%[0-9]+]] = bitcast %[[C]]* [[R]] to i8*
-// CHECK-NEXT: call void @llvm.lifetime.end(i64 -1, i8* [[O2]])
+// CHECK-NEXT: call void @llvm.lifetime.end.p0i8(i64 -1, i8* [[O2]])
 // CHECK-NEXT: ret void
 sil @promoted_with_inlined_devirtualized_release : $@convention(thin) () -> () {
 bb0:
diff --git a/test/IRGen/dependent-library.swift b/test/IRGen/dependent-library.swift
index 4c27b5ef2b..e1786a1955 100644
--- a/test/IRGen/dependent-library.swift
+++ b/test/IRGen/dependent-library.swift
@@ -1,7 +1,6 @@
 // RUN: %swift -target i686-unknown-windows-msvc -emit-ir -parse-as-library -parse-stdlib -module-name dependent -autolink-library oldnames -autolink-library msvcrt %s -o - | %FileCheck %s
 
-// CHECK: !{i32 6, !"Linker Options", ![[options:[0-9]+]]}
-// CHECK: ![[options]] = !{![[oldnames:[0-9]+]], ![[msvcrtd:[0-9]+]]}
+// CHECK: !llvm.linker.options = !{![[oldnames:[0-9]+]], ![[msvcrtd:[0-9]+]]}
 // CHECK: ![[oldnames]] = !{!"/DEFAULTLIB:oldnames.lib"}
 // CHECK: ![[msvcrtd]] = !{!"/DEFAULTLIB:msvcrt.lib"}
 
diff --git a/test/IRGen/exclusivity.sil b/test/IRGen/exclusivity.sil
index 7ed2b5ec71..92b1e71915 100644
--- a/test/IRGen/exclusivity.sil
+++ b/test/IRGen/exclusivity.sil
@@ -23,7 +23,7 @@ bb0(%0 : $A):
   %3 = ref_element_addr %0 : $A, #A.x
 
   // CHECK: [[T0:%.*]] = bitcast [[BUFFER_T]]* [[SCRATCH0]] to i8*
-  // CHECK: call void @llvm.lifetime.start(i64 -1, i8* [[T0]])
+  // CHECK: call void @llvm.lifetime.start.p0i8(i64 -1, i8* [[T0]])
   // CHECK: [[T0:%.*]] = bitcast [[INT:%TSi]]* [[PROP]] to i8*
   // CHECK-SWIFT3: call void @swift_beginAccess(i8* [[T0]], [[BUFFER_T]]* [[SCRATCH0]], [[SIZE_T:i32|i64]] 16, i8* null)
   // CHECK-SWIFT4: call void @swift_beginAccess(i8* [[T0]], [[BUFFER_T]]* [[SCRATCH0]], [[SIZE_T:i32|i64]] 0, i8* null)
@@ -35,7 +35,7 @@ bb0(%0 : $A):
 
   // CHECK: call void @swift_endAccess([[BUFFER_T]]* [[SCRATCH0]])
   // CHECK: [[T0:%.*]] = bitcast [[BUFFER_T]]* [[SCRATCH0]] to i8*
-  // CHECK: call void @llvm.lifetime.end(i64 -1, i8* [[T0]])
+  // CHECK: call void @llvm.lifetime.end.p0i8(i64 -1, i8* [[T0]])
   end_access %4 : $*Int
 
   %9 = function_ref @changeInt : $@convention(thin) (@inout Int) -> ()
@@ -44,7 +44,7 @@ bb0(%0 : $A):
   %11 = ref_element_addr %0 : $A, #A.x
 
   // CHECK: [[T0:%.*]] = bitcast [[BUFFER_T]]* [[SCRATCH1]] to i8*
-  // CHECK: call void @llvm.lifetime.start(i64 -1, i8* [[T0]])
+  // CHECK: call void @llvm.lifetime.start.p0i8(i64 -1, i8* [[T0]])
   // CHECK: [[T0:%.*]] = bitcast [[INT:%TSi]]* [[PROP]] to i8*
   // CHECK-SWIFT3: call void @swift_beginAccess(i8* [[T0]], [[BUFFER_T]]* [[SCRATCH1]], [[SIZE_T:i32|i64]] 17, i8* null)
   // CHECK-SWIFT4: call void @swift_beginAccess(i8* [[T0]], [[BUFFER_T]]* [[SCRATCH1]], [[SIZE_T:i32|i64]] 1, i8* null)
@@ -55,7 +55,7 @@ bb0(%0 : $A):
 
   // CHECK: call void @swift_endAccess([[BUFFER_T]]* [[SCRATCH1]])
   // CHECK: [[T0:%.*]] = bitcast [[BUFFER_T]]* [[SCRATCH1]] to i8*
-  // CHECK: call void @llvm.lifetime.end(i64 -1, i8* [[T0]])
+  // CHECK: call void @llvm.lifetime.end.p0i8(i64 -1, i8* [[T0]])
   end_access %12 : $*Int
   destroy_value %0 : $A
   return %5 : $Int
diff --git a/test/IRGen/lifetime.sil b/test/IRGen/lifetime.sil
index 4720969b28..ebb511cda9 100644
--- a/test/IRGen/lifetime.sil
+++ b/test/IRGen/lifetime.sil
@@ -26,7 +26,7 @@ bb0(%x : $*T):
 // CHECK-NEXT: [[SIZE_WITNESS:%.*]] = load i8*, i8** [[SIZE_WITNESS_ADDR]]
 // CHECK-NEXT: [[SIZE:%.*]] = ptrtoint i8* [[SIZE_WITNESS]]
 // CHECK-NEXT: [[Y_ALLOCA:%.*]] = alloca i8, {{.*}} [[SIZE]], align 16
-// CHECK-NEXT: call void @llvm.lifetime.start({{(i32|i64)}} -1, i8* [[Y_ALLOCA]])
+// CHECK-NEXT: call void @llvm.lifetime.start.p0i8({{(i32|i64)}} -1, i8* [[Y_ALLOCA]])
 // CHECK-NEXT: [[Y_TMP:%.*]] = bitcast i8* [[Y_ALLOCA]] to %swift.opaque*
 //   Copy 'x' into 'y'.
 // CHECK-NEXT: [[T3:%.*]] = getelementptr inbounds i8*, i8** [[VWT]], i32 6
@@ -41,7 +41,7 @@ bb0(%x : $*T):
 //   Destroy 'x'.
 // CHECK-NEXT: call void [[DESTROY_FN]]([[OPAQUE]]* [[X]], [[TYPE]]* %T)
 // CHECK-NEXT: [[YBUFLIFE:%.*]] = bitcast [[OPAQUE]]* [[Y_TMP]] to i8*
-// CHECK-NEXT: call void @llvm.lifetime.end({{(i32|i64)}} -1, i8* [[YBUFLIFE]])
+// CHECK-NEXT: call void @llvm.lifetime.end.p0i8({{(i32|i64)}} -1, i8* [[YBUFLIFE]])
 //   Return.
 // CHECK-NEXT: ret void
 
@@ -65,7 +65,7 @@ bb0(%x : $*T):
 // CHECK-NEXT: [[SIZE_WITNESS:%.*]] = load i8*, i8** [[SIZE_WITNESS_ADDR]]
 // CHECK-NEXT: [[SIZE:%.*]] = ptrtoint i8* [[SIZE_WITNESS]]
 // CHECK-NEXT: [[Y_ALLOCA:%.*]] = alloca i8, {{.*}} [[SIZE]], align 16
-// CHECK-NEXT: call void @llvm.lifetime.start({{(i32|i64)}} -1, i8* [[Y_ALLOCA]])
+// CHECK-NEXT: call void @llvm.lifetime.start.p0i8({{(i32|i64)}} -1, i8* [[Y_ALLOCA]])
 // CHECK-NEXT: [[Y_TMP:%.*]] = bitcast i8* [[Y_ALLOCA]] to %swift.opaque*
 //   Copy 'x' into 'y'.
 // CHECK-NEXT: [[T3:%.*]] = getelementptr inbounds i8*, i8** [[VWT]], i32 6
@@ -85,7 +85,7 @@ bb0(%x : $*T):
 //   Destroy 'y'.
 // CHECK-NEXT: call void [[DESTROY_FN]]([[OPAQUE]]* [[Y_TMP]], [[TYPE]]* %T)
 // CHECK-NEXT: [[YBUFLIFE:%.*]] = bitcast [[OPAQUE]]* [[Y_TMP]] to i8*
-// CHECK-NEXT: call void @llvm.lifetime.end({{(i32|i64)}} -1, i8* [[YBUFLIFE]])
+// CHECK-NEXT: call void @llvm.lifetime.end.p0i8({{(i32|i64)}} -1, i8* [[YBUFLIFE]])
 //   Return.
 // CHECK-NEXT: ret void
 
@@ -102,9 +102,9 @@ bb0(%x : $*Builtin.Int64):
 // CHECK-LABEL: define{{( protected)?}} swiftcc void @fixed_size(i64* noalias nocapture dereferenceable(8))
 // CHECK:         [[XBUF:%.*]] = alloca i64
 // CHECK-NEXT:    [[XBUFLIFE:%.*]] = bitcast i64* [[XBUF]] to i8*
-// CHECK-NEXT:    call void @llvm.lifetime.start({{(i32|i64)}} 8, i8* [[XBUFLIFE]])
+// CHECK-NEXT:    call void @llvm.lifetime.start.p0i8({{(i32|i64)}} 8, i8* [[XBUFLIFE]])
 // CHECK-NEXT:    load
 // CHECK-NEXT:    store
 // CHECK-NEXT:    [[XBUFLIFE:%.*]] = bitcast i64* [[XBUF]] to i8*
-// CHECK-NEXT:    call void @llvm.lifetime.end({{(i32|i64)}} 8, i8* [[XBUFLIFE]])
+// CHECK-NEXT:    call void @llvm.lifetime.end.p0i8({{(i32|i64)}} 8, i8* [[XBUFLIFE]])
 
diff --git a/test/IRGen/linker_options_objc.swift b/test/IRGen/linker_options_objc.swift
index 1546ce07fb..5dda6bfc1a 100644
--- a/test/IRGen/linker_options_objc.swift
+++ b/test/IRGen/linker_options_objc.swift
@@ -10,6 +10,6 @@ import Empty
 // Check that libobjc is always autolinked together with libswiftCore on
 // platforms that support Objective-C.
 
-// CHECK: !{{.*}} = !{i32 6, !"Linker Options", !{{.*}}}
+// CHECK: !llvm.linker.options =
 // CHECK-DAG: !{{.*}} = !{!"-lswiftCore"}
 // CHECK-DAG: !{{.*}} = !{!"-lobjc"}
diff --git a/test/IRGen/objc.swift b/test/IRGen/objc.swift
index d953fba58b..20bf5c47eb 100644
--- a/test/IRGen/objc.swift
+++ b/test/IRGen/objc.swift
@@ -141,7 +141,7 @@ class WeakObjC {
 // rdar://17528908
 // CHECK:  i32 1, !"Objective-C Version", i32 2}
 // CHECK:  i32 1, !"Objective-C Image Info Version", i32 0}
-// CHECK:  i32 1, !"Objective-C Image Info Section", !"__DATA, __objc_imageinfo, regular, no_dead_strip"}
+// CHECK:  i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"}
 //   1280 == (5 << 8).  5 is the Swift ABI version.
 // CHECK:  i32 4, !"Objective-C Garbage Collection", i32 1280}
 // CHECK:  i32 1, !"Swift Version", i32 5}
diff --git a/test/IRGen/objc_globals.swift b/test/IRGen/objc_globals.swift
index 89aa369661..3ab1ae8a16 100644
--- a/test/IRGen/objc_globals.swift
+++ b/test/IRGen/objc_globals.swift
@@ -11,8 +11,8 @@ func blackHole<T>(_ t: T) { }
 
 // CHECK-LABEL: @"OBJC_CLASS_$_NSNumber" = external global %objc_class
 // CHECK: @"OBJC_CLASS_$_NSString" = external global {{%.*}}, align
-// CHECK: @"OBJC_CLASSLIST_REFERENCES_$_{{.*}}" = private global %struct._class_t* bitcast (%objc_class* @"OBJC_CLASS_$_NSNumber" to %struct._class_t*), section "__DATA, __objc_classrefs, regular, no_dead_strip"
-// CHECK: @"OBJC_CLASSLIST_REFERENCES_$_{{.*}}" = private global %struct._class_t* bitcast (%objc_class* @"OBJC_CLASS_$_NSString" to %struct._class_t*), section "__DATA, __objc_classrefs, regular, no_dead_strip"
+// CHECK: @"OBJC_CLASSLIST_REFERENCES_$_{{.*}}" = private global %struct._class_t* bitcast (%objc_class* @"OBJC_CLASS_$_NSNumber" to %struct._class_t*), section "__DATA,__objc_classrefs,regular,no_dead_strip"
+// CHECK: @"OBJC_CLASSLIST_REFERENCES_$_{{.*}}" = private global %struct._class_t* bitcast (%objc_class* @"OBJC_CLASS_$_NSString" to %struct._class_t*), section "__DATA,__objc_classrefs,regular,no_dead_strip"
 
 public func testLiterals() {
   blackHole(gadget.giveMeASelector())
diff --git a/test/IRGen/sanitize_coverage.swift b/test/IRGen/sanitize_coverage.swift
index 54b6f35809..4021dd29b3 100644
--- a/test/IRGen/sanitize_coverage.swift
+++ b/test/IRGen/sanitize_coverage.swift
@@ -3,9 +3,6 @@
 // RUN: %target-swift-frontend -assume-parsing-unqualified-ownership-sil -emit-ir -sanitize=address -sanitize-coverage=bb %s | %FileCheck %s -check-prefix=SANCOV
 // RUN: %target-swift-frontend -assume-parsing-unqualified-ownership-sil -emit-ir -sanitize=address -sanitize-coverage=edge %s | %FileCheck %s -check-prefix=SANCOV
 // RUN: %target-swift-frontend -assume-parsing-unqualified-ownership-sil -emit-ir -sanitize=address -sanitize-coverage=edge,trace-cmp %s | %FileCheck %s -check-prefix=SANCOV -check-prefix=SANCOV_TRACE_CMP
-// RUN: %target-swift-frontend -assume-parsing-unqualified-ownership-sil -emit-ir -sanitize=address -sanitize-coverage=edge,trace-bb %s | %FileCheck %s -check-prefix=SANCOV -check-prefix=SANCOV_TRACE_BB
-// RUN: %target-swift-frontend -assume-parsing-unqualified-ownership-sil -emit-ir -sanitize=address -sanitize-coverage=edge,indirect-calls %s | %FileCheck %s -check-prefix=SANCOV -check-prefix=SANCOV_INDIRECT_CALLS
-// RUN: %target-swift-frontend -assume-parsing-unqualified-ownership-sil -emit-ir -sanitize=address -sanitize-coverage=edge,8bit-counters %s | %FileCheck %s -check-prefix=SANCOV -check-prefix=SANCOV_8BIT_COUNTERS
 
 import Darwin
 
@@ -28,6 +25,3 @@ test()
 // SANCOV: call void @__sanitizer_cov
 
 // SANCOV_TRACE_CMP: call void @__sanitizer_cov_trace_cmp
-// SANCOV_TRACE_BB: call void @__sanitizer_cov_trace_basic_block
-// SANCOV_INDIRECT_CALLS: call void @__sanitizer_cov_indir_call16
-// SANCOV_8BIT_COUNTERS: @__sancov_gen_cov_counter
diff --git a/test/IRGen/tail_alloc.sil b/test/IRGen/tail_alloc.sil
index 4c5ad1c767..fef3c59ce3 100644
--- a/test/IRGen/tail_alloc.sil
+++ b/test/IRGen/tail_alloc.sil
@@ -22,7 +22,7 @@ sil_vtable TestClass {}
 // CHECK-NEXT: %reference.new = call %swift.refcounted* @swift_initStackObject(%swift.type* [[M]], %swift.refcounted* [[O]])
 // CHECK-NEXT: [[R:%[0-9]+]] = bitcast %swift.refcounted* %reference.new to %[[C:.*TestClass.*]]*
 // CHECK-NEXT: [[O2:%[0-9]+]] = bitcast %[[C]]* [[R]] to i8*
-// CHECK-NEXT: call void @llvm.lifetime.end(i64 -1, i8* [[O2]])
+// CHECK-NEXT: call void @llvm.lifetime.end.p0i8(i64 -1, i8* [[O2]])
 // CHECK-NEXT: ret void
 sil @alloc_on_stack : $@convention(thin) () -> () {
 bb0:
diff --git a/test/Interpreter/availability_host_os.swift b/test/Interpreter/availability_host_os.swift
index 6bc9449dd5..697128bab3 100644
--- a/test/Interpreter/availability_host_os.swift
+++ b/test/Interpreter/availability_host_os.swift
@@ -1,7 +1,11 @@
 // Note: This deliberately uses the script interpreter rather than build/run.
 // RUN: %swift_driver -import-objc-header %S/Inputs/availability_host_os.h -DFAIL -Xfrontend -verify %s
 // RUN: %swift_driver -import-objc-header %S/Inputs/availability_host_os.h %s | %FileCheck %s
-// RUN: not %swift -typecheck -import-objc-header %S/Inputs/availability_host_os.h %s 2>&1 | %FileCheck -check-prefix=CHECK-NOT-INFERRED %s
+
+// This check is disabled for now because LLVM has started inferring the current
+// OS for the default target triple all the time. rdar://problem/29948658 tracks
+// deciding whether that's the right behavior.
+// RUN-DISABLED: not %swift -typecheck -import-objc-header %S/Inputs/availability_host_os.h %s 2>&1 | %FileCheck -check-prefix=CHECK-NOT-INFERRED %s
 
 // REQUIRES: OS=macosx
 // REQUIRES: executable_test
diff --git a/test/Misc/target-cpu.swift b/test/Misc/target-cpu.swift
index 0a75f95982..5c2f3b0665 100644
--- a/test/Misc/target-cpu.swift
+++ b/test/Misc/target-cpu.swift
@@ -8,7 +8,7 @@
 // APPLETVTARGETCPU2: "-target-cpu" "swift"
 
 // RUN: not %swift -typecheck -target armv7-apple-tvos9 -Xcc -### %s 2>&1 | %FileCheck -check-prefix=APPLETVTARGETCPU3 %s
-// APPLETVTARGETCPU3: "-target-cpu" "cortex-a8"
+// APPLETVTARGETCPU3: "-target-cpu" "generic"
 
 // RUN: not %swift -typecheck -target armv7k-apple-watchos2 -Xcc -### %s 2>&1 | %FileCheck -check-prefix=WATCHTARGETCPU1 %s
 // WATCHTARGETCPU1: "-target-cpu" "cortex-a7"
@@ -20,7 +20,7 @@
 // TARGETCPU2: "-target-cpu" "swift"
 
 // RUN: not %swift -typecheck -target armv7-apple-ios7 -Xcc -### %s 2>&1 | %FileCheck -check-prefix=TARGETCPU3 %s
-// TARGETCPU3: "-target-cpu" "cortex-a8"
+// TARGETCPU3: "-target-cpu" "generic"
 
 // RUN: not %swift -typecheck -target i386-apple-ios7 -Xcc -### %s 2>&1 | %FileCheck -check-prefix=SIMULATOR_CPU %s
 // SIMULATOR_CPU: "-target-cpu" "yonah"
diff --git a/test/Serialization/autolinking.swift b/test/Serialization/autolinking.swift
index 71bae637bc..ca3209f7cf 100644
--- a/test/Serialization/autolinking.swift
+++ b/test/Serialization/autolinking.swift
@@ -29,13 +29,11 @@
 
 import someModule
 
-// CHECK: !{{[0-9]+}} = !{i32 6, !"Linker Options", ![[LINK_LIST:[0-9]+]]}
-// CHECK: ![[LINK_LIST]] = !{
+// CHECK: !llvm.linker.options = !{
 // CHECK-DAG: !{{[0-9]+}} = !{!"-lmagic"}
 // CHECK-DAG: !{{[0-9]+}} = !{!"-lmodule"}
 
-// FRAMEWORK: !{{[0-9]+}} = !{i32 6, !"Linker Options", ![[LINK_LIST:[0-9]+]]}
-// FRAMEWORK: ![[LINK_LIST]] = !{
+// FRAMEWORK: !llvm.linker.options = !{
 // FRAMEWORK-DAG: !{{[0-9]+}} = !{!"-lmagic"}
 // FRAMEWORK-DAG: !{{[0-9]+}} = !{!"-lmodule"}
 // FRAMEWORK-DAG: !{{[0-9]+}} = !{!"-framework", !"someModule"}
diff --git a/test/SourceKit/lit.local.cfg b/test/SourceKit/lit.local.cfg
index 15100e3caa..2e93cd9128 100644
--- a/test/SourceKit/lit.local.cfg
+++ b/test/SourceKit/lit.local.cfg
@@ -5,17 +5,12 @@ elif 'OS=linux-gnu' in config.available_features and 'LinuxDistribution=Ubuntu-1
     config.unsupported = True
 
 else:
-    config.sourcekitd_test = config.inferSwiftBinary('sourcekitd-test')
-    config.complete_test = config.inferSwiftBinary('complete-test')
-
-    def sed_clean(x):
-        sed_cmd = "grep -v 'key.hash: \"0\"'"
-        sed_cmd += " | sed -e 's/key.filepath: \".*[/\\\\]\\(.*\\)\\.swiftmodule\"/key.filepath: \\1.swiftmodule/g'"
-        sed_cmd += " | sed -e 's/key.filepath: \".*[/\\\\]\\(.*\\)\\.swift\"/key.filepath: \\1.swift/g'"
-        sed_cmd += " | sed -e 's/key.filepath: \".*[/\\\\]\\(.*\\)-[0-9A-Z]*\\.pcm\"/key.filepath: \\1.pcm/g'"
-        sed_cmd += " | sed -e 's/ file=\\\\\".*[/\\\\]\\(.*\\)\\.h\\\\\"/ file=\\1.h/g'"
-        sed_cmd += " | sed -e 's/key.hash: \".*\"/key.hash: <hash>/g'"
-        return sed_cmd
+    sed_clean = r"grep -v 'key.hash: \"0\"'"
+    sed_clean += r" | sed -e 's/key.filepath: \".*[/\\\\]\\(.*\\)\\.swiftmodule\"/key.filepath: \\1.swiftmodule/g'"
+    sed_clean += r" | sed -e 's/key.filepath: \".*[/\\\\]\\(.*\\)\\.swift\"/key.filepath: \\1.swift/g'"
+    sed_clean += r" | sed -e 's/key.filepath: \".*[/\\\\]\\(.*\\)-[0-9A-Z]*\\.pcm\"/key.filepath: \\1.pcm/g'"
+    sed_clean += r" | sed -e 's/ file=\\\\\".*[/\\\\]\\(.*\\)\\.h\\\\\"/ file=\\1.h/g'"
+    sed_clean += r" | sed -e 's/key.hash: \".*\"/key.hash: <hash>/g'"
 
     config.substitutions.append( ('%sourcekitd-test', config.sourcekitd_test) )
     config.substitutions.append( ('%complete-test', config.complete_test) )
diff --git a/test/api-digester/lit.local.cfg b/test/api-digester/lit.local.cfg
index bae02b6d8d..92e6a855c6 100644
--- a/test/api-digester/lit.local.cfg
+++ b/test/api-digester/lit.local.cfg
@@ -2,5 +2,4 @@ if 'OS=macosx' not in config.available_features:
     config.unsupported = True
 
 else:
-    config.swift_api_digester = config.inferSwiftBinary('swift-api-digester')
     config.substitutions.append(('%api-digester', config.swift_api_digester))
diff --git a/test/lit.cfg b/test/lit.cfg
index 380e714af0..ee1f4f16d8 100644
--- a/test/lit.cfg
+++ b/test/lit.cfg
@@ -33,6 +33,10 @@ import lit
 import lit.formats
 import lit.util
 
+import site
+site.addsitedir(os.path.dirname(__file__))
+import swift_test
+
 #
 # Helper functions.
 #
@@ -134,48 +138,6 @@ if config.test_exec_root is None:
 
 ###
 
-class SwiftTest(lit.formats.ShTest, object):
-    def __init__(self, coverage_mode=None, execute_external=True):
-        super(SwiftTest, self).__init__(execute_external=execute_external)
-        if coverage_mode == "FALSE":
-            self.coverage_mode = None
-        else:
-            self.coverage_mode = coverage_mode
-        self.skipped_tests = set()
-
-    def before_test(self, test, litConfig):
-        if self.coverage_mode:
-            # FIXME: The compiler crashers run so fast they fill up the
-            # merger's queue (and therefore the build bot's disk)
-            if 'crasher' in test.getSourcePath():
-                test.config.environment["LLVM_PROFILE_FILE"] = os.devnull
-                self.skipped_tests.add(test.getSourcePath())
-                return
-
-            _, tmp_base = lit.TestRunner.getTempPaths(test)
-            if self.coverage_mode == "NOT_MERGED":
-                profdir = tmp_base + '.profdir'
-                if not os.path.exists(profdir):
-                    os.makedirs(profdir)
-
-                test.config.environment["LLVM_PROFILE_FILE"] = \
-                    os.path.join(profdir, "swift-%p.profraw")
-            else:
-                test.config.environment["LLVM_PROFILE_FILE"] = \
-                    os.path.join(config.swift_test_results_dir,
-                                 "swift-%4m.profraw")
-
-    def after_test(self, test, litConfig, result):
-        if test.getSourcePath() in self.skipped_tests:
-            self.skipped_tests.remove(test.getSourcePath())
-        return result
-
-
-    def execute(self, test, litConfig):
-        self.before_test(test, litConfig)
-        result = super(SwiftTest, self).execute(test, litConfig)
-        return self.after_test(test, litConfig, result)
-
 # name: The name of this test suite.
 config.name = 'Swift(%s)' % config.variant_suffix[1:]
 
@@ -185,7 +147,7 @@ if platform.system() == 'Darwin':
     config.environment['TOOLCHAINS'] = 'default'
 
 # testFormat: The test format to use to interpret tests.
-config.test_format = SwiftTest(coverage_mode=config.coverage_mode)
+config.test_format = swift_test.SwiftTest(coverage_mode=config.coverage_mode)
 
 # suffixes: A list of file extensions to treat as test files.
 config.suffixes = ['.swift', '.ll', '.sil', '.gyb', '.m', '.test-sh']
@@ -269,9 +231,6 @@ if 'gmalloc' in lit_config.params:
     config.environment['MALLOC_LOG_FILE'] = '/dev/null'
     config.available_features.add('gmalloc')
 
-# Make inferSwiftBinary() available to be used later on.
-config.inferSwiftBinary = inferSwiftBinary
-
 config.swift = inferSwiftBinary('swift')
 config.swiftc = inferSwiftBinary('swiftc')
 config.sil_opt = inferSwiftBinary('sil-opt')
@@ -292,6 +251,9 @@ config.llvm_profdata = inferSwiftBinary('llvm-profdata')
 config.llvm_cov = inferSwiftBinary('llvm-cov')
 config.filecheck = inferSwiftBinary('FileCheck')
 config.llvm_dwarfdump = inferSwiftBinary('llvm-dwarfdump')
+config.sourcekitd_test = inferSwiftBinary('sourcekitd-test')
+config.complete_test = inferSwiftBinary('complete-test')
+config.swift_api_digester = inferSwiftBinary('swift-api-digester')
 
 config.swift_utils = os.path.join(config.swift_src_root, 'utils')
 config.line_directive = os.path.join(config.swift_utils, 'line-directive')
diff --git a/tools/SourceKit/tools/sourcekitd-test/TestOptions.cpp b/tools/SourceKit/tools/sourcekitd-test/TestOptions.cpp
index 24c23967c2..9087b222b5 100644
--- a/tools/SourceKit/tools/sourcekitd-test/TestOptions.cpp
+++ b/tools/SourceKit/tools/sourcekitd-test/TestOptions.cpp
@@ -26,9 +26,9 @@ namespace {
 // Create enum with OPT_xxx values for each option in Options.td.
 enum Opt {
   OPT_INVALID = 0,
-#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM, \
-               HELP, META) \
-          OPT_##ID,
+#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,  \
+               HELP, META, VALUES)                                             \
+  OPT_##ID,
 #include "Options.inc"
   LastOption
 #undef OPTION
@@ -41,10 +41,12 @@ enum Opt {
 
 // Create table mapping all options defined in Options.td.
 static const llvm::opt::OptTable::Info InfoTable[] = {
-#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM, \
-               HELPTEXT, METAVAR)   \
-  { PREFIX, NAME, HELPTEXT, METAVAR, OPT_##ID, llvm::opt::Option::KIND##Class, \
-    PARAM, FLAGS, OPT_##GROUP, OPT_##ALIAS, ALIASARGS },
+#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,  \
+               HELPTEXT, METAVAR, VALUES)                                      \
+  {PREFIX,      NAME,      HELPTEXT,                                           \
+   METAVAR,     OPT_##ID,  llvm::opt::Option::KIND##Class,                     \
+   PARAM,       FLAGS,     OPT_##GROUP,                                        \
+   OPT_##ALIAS, ALIASARGS, VALUES},
 #include "Options.inc"
 #undef OPTION
 };
diff --git a/tools/SourceKit/tools/sourcekitd/bin/XPC/Client/tracer.cpp b/tools/SourceKit/tools/sourcekitd/bin/XPC/Client/tracer.cpp
index bc422c1793..7cd5a50cca 100644
--- a/tools/SourceKit/tools/sourcekitd/bin/XPC/Client/tracer.cpp
+++ b/tools/SourceKit/tools/sourcekitd/bin/XPC/Client/tracer.cpp
@@ -121,16 +121,6 @@ struct OpRec {
   trace::StringPairs FileMap;
 };
 
-template <typename U>
-struct llvm::yaml::SequenceTraits<std::vector<U>> {
-  static size_t size(IO &Io, std::vector<U> &Vec) {
-    return Vec.size();
-  }
-  static U &element(IO &Io, std::vector<U> &Vec, size_t Index) {
-    return Vec[Index];
-  }
-};
-
 template <>
 struct llvm::yaml::MappingTraits<OpRec> {
   static void mapping(IO &Io, OpRec &Rec) {
diff --git a/tools/SourceKit/tools/sourcekitd/bin/XPC/Service/XpcTracing.cpp b/tools/SourceKit/tools/sourcekitd/bin/XPC/Service/XpcTracing.cpp
index e64fd8440e..aa2b857f32 100644
--- a/tools/SourceKit/tools/sourcekitd/bin/XPC/Service/XpcTracing.cpp
+++ b/tools/SourceKit/tools/sourcekitd/bin/XPC/Service/XpcTracing.cpp
@@ -63,16 +63,6 @@ static void append(xpc_object_t Contents, const StringPairs &Files) {
                 });
 }
 
-template <typename U>
-struct llvm::yaml::SequenceTraits<std::vector<U>> {
-  static size_t size(IO &Io, std::vector<U> &Vector) {
-    return Vector.size();
-  }
-  static U &element(IO &Io, std::vector<U> &Vector, size_t Index) {
-    return Vector[Index];
-  }
-};
-
 template <>
 struct llvm::yaml::MappingTraits<SwiftArguments> {
   static void mapping(IO &Io, SwiftArguments &Args) {
diff --git a/tools/driver/autolink_extract_main.cpp b/tools/driver/autolink_extract_main.cpp
index 93bbcf684e..23bbd9c13e 100644
--- a/tools/driver/autolink_extract_main.cpp
+++ b/tools/driver/autolink_extract_main.cpp
@@ -73,8 +73,7 @@ public:
     }
 
     if (ParsedArgs.hasArg(OPT_UNKNOWN)) {
-      for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_UNKNOWN),
-                                     ParsedArgs.filtered_end())) {
+      for (const Arg *A : ParsedArgs.filtered(OPT_UNKNOWN)) {
         Diags.diagnose(SourceLoc(), diag::error_unknown_arg,
                        A->getAsString(ParsedArgs));
       }
@@ -89,8 +88,7 @@ public:
       return 1;
     }
 
-    for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_INPUT),
-                                   ParsedArgs.filtered_end())) {
+    for (const Arg *A : ParsedArgs.filtered(OPT_INPUT)) {
       InputFilenames.push_back(A->getValue());
     }
 
diff --git a/tools/driver/modulewrap_main.cpp b/tools/driver/modulewrap_main.cpp
index fcd7c25445..23bc5efeaa 100644
--- a/tools/driver/modulewrap_main.cpp
+++ b/tools/driver/modulewrap_main.cpp
@@ -74,8 +74,7 @@ public:
       TargetTriple = llvm::Triple(llvm::sys::getDefaultTargetTriple());
 
     if (ParsedArgs.hasArg(OPT_UNKNOWN)) {
-      for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_UNKNOWN),
-                                     ParsedArgs.filtered_end())) {
+      for (const Arg *A : ParsedArgs.filtered(OPT_UNKNOWN)) {
         Diags.diagnose(SourceLoc(), diag::error_unknown_arg,
                        A->getAsString(ParsedArgs));
       }
@@ -89,8 +88,7 @@ public:
       return 1;
     }
 
-    for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_INPUT),
-                                   ParsedArgs.filtered_end())) {
+    for (const Arg *A : ParsedArgs.filtered(OPT_INPUT)) {
       InputFilenames.push_back(A->getValue());
     }
 
diff --git a/tools/driver/swift_format_main.cpp b/tools/driver/swift_format_main.cpp
index aaa2046e29..c8fe7f60e2 100644
--- a/tools/driver/swift_format_main.cpp
+++ b/tools/driver/swift_format_main.cpp
@@ -137,13 +137,11 @@ public:
         Diags.diagnose(SourceLoc(), diag::error_invalid_arg_value,
                        A->getAsString(ParsedArgs), A->getValue());
 
-    for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_line_range),
-                                   ParsedArgs.filtered_end()))
+    for (const Arg *A : ParsedArgs.filtered(OPT_line_range))
       LineRanges.push_back(A->getValue());
 
     if (ParsedArgs.hasArg(OPT_UNKNOWN)) {
-      for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_UNKNOWN),
-                                     ParsedArgs.filtered_end())) {
+      for (const Arg *A : ParsedArgs.filtered(OPT_UNKNOWN)) {
         Diags.diagnose(SourceLoc(), diag::error_unknown_arg,
                        A->getAsString(ParsedArgs));
       }
@@ -157,8 +155,7 @@ public:
       return 1;
     }
 
-    for (const Arg *A : make_range(ParsedArgs.filtered_begin(OPT_INPUT),
-                                   ParsedArgs.filtered_end())) {
+    for (const Arg *A : ParsedArgs.filtered(OPT_INPUT)) {
       InputFilenames.push_back(A->getValue());
     }
 
diff --git a/tools/swift-llvm-opt/LLVMOpt.cpp b/tools/swift-llvm-opt/LLVMOpt.cpp
index b364b73e3d..d3d9f05433 100644
--- a/tools/swift-llvm-opt/LLVMOpt.cpp
+++ b/tools/swift-llvm-opt/LLVMOpt.cpp
@@ -38,6 +38,7 @@
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
 #include "llvm/CodeGen/CommandFlags.h"
+#include "llvm/CodeGen/TargetPassConfig.h"
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/DebugInfo.h"
 #include "llvm/IR/IRPrintingPasses.h"
@@ -183,11 +184,16 @@ static void runSpecificPasses(StringRef Binary, llvm::Module *M,
   Passes.add(createTargetTransformInfoWrapperPass(TM ? TM->getTargetIRAnalysis()
                                                      : TargetIRAnalysis()));
 
+  if (TM) {
+    // FIXME: We should dyn_cast this when supported.
+    auto &LTM = static_cast<LLVMTargetMachine &>(*TM);
+    Pass *TPC = LTM.createPassConfig(Passes);
+    Passes.add(TPC);
+  }
+
   for (const llvm::PassInfo *PassInfo : PassList) {
     llvm::Pass *P = nullptr;
-    if (PassInfo->getTargetMachineCtor())
-      P = PassInfo->getTargetMachineCtor()(TM);
-    else if (PassInfo->getNormalCtor())
+    if (PassInfo->getNormalCtor())
       P = PassInfo->getNormalCtor()();
     else
       errs() << Binary << ": cannot create pass: " << PassInfo->getPassName()
diff --git a/utils/build-script b/utils/build-script
index d804618fab..05d7224461 100755
--- a/utils/build-script
+++ b/utils/build-script
@@ -2049,7 +2049,7 @@ iterations with -O",
         "--clang-user-visible-version",
         help="User-visible version of the embedded Clang and LLVM compilers",
         type=arguments.type.clang_compiler_version,
-        default="4.0.0",
+        default="5.0.0",
         metavar="MAJOR.MINOR.PATCH")
     parser.add_argument(
         "--swift-compiler-version",

--- a/include/swift/Basic/Dwarf.h
+++ b/include/swift/Basic/Dwarf.h
@@ -17,7 +17,7 @@
 #ifndef SWIFT_BASIC_DWARF_H
 #define SWIFT_BASIC_DWARF_H
 
-#include "llvm/Support/Dwarf.h"
+#include "llvm/BinaryFormat/Dwarf.h"
 
 namespace swift {
   /// The DWARF version emitted by the Swift compiler.
diff --git a/lib/AST/Builtins.cpp b/lib/AST/Builtins.cpp
index d0245261632..7c64922b37e 100644
--- a/lib/AST/Builtins.cpp
+++ b/lib/AST/Builtins.cpp
@@ -46,9 +46,9 @@ bool BuiltinInfo::isReadNone() const {
 
 bool IntrinsicInfo::hasAttribute(llvm::Attribute::AttrKind Kind) const {
   // FIXME: We should not be relying on the global LLVM context.
-  llvm::AttributeSet attrs
-    = llvm::Intrinsic::getAttributes(getGlobalLLVMContext(), ID);
-  return (attrs.hasAttribute(llvm::AttributeSet::FunctionIndex, Kind));
+  llvm::AttributeList attrs =
+      llvm::Intrinsic::getAttributes(getGlobalLLVMContext(), ID);
+  return (attrs.hasAttribute(llvm::AttributeList::FunctionIndex, Kind));
 }
 
 Type swift::getBuiltinType(ASTContext &Context, StringRef Name) {
@@ -1273,10 +1273,10 @@ getSwiftFunctionTypeForIntrinsic(unsigned iid, ArrayRef<Type> TypeArgs,
   }
   
   // Translate LLVM function attributes to Swift function attributes.
-  llvm::AttributeSet attrs =
+  llvm::AttributeList attrs =
       llvm::Intrinsic::getAttributes(getGlobalLLVMContext(), ID);
   Info = FunctionType::ExtInfo();
-  if (attrs.hasAttribute(llvm::AttributeSet::FunctionIndex,
+  if (attrs.hasAttribute(llvm::AttributeList::FunctionIndex,
                          llvm::Attribute::NoReturn))
     ResultTy = Context.getNeverType();
   
diff --git a/lib/ClangImporter/ImportDecl.cpp b/lib/ClangImporter/ImportDecl.cpp
index 57e9ff3de98..20896377a97 100644
--- a/lib/ClangImporter/ImportDecl.cpp
+++ b/lib/ClangImporter/ImportDecl.cpp
@@ -4223,12 +4223,12 @@ namespace {
       result->setCheckedInheritanceClause();
 
       // Add inferred attributes.
-#define INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeSet)        \
-      if (name.str().equals(#ClassName) &&                              \
-          result->getParentModule()->getName().str().equals(#ModuleName)) {  \
-        using namespace inferred_attributes;                            \
-        addInferredAttributes(result, AttributeSet);                    \
-      }
+#define INFERRED_ATTRIBUTES(ModuleName, ClassName, AttributeSet)               \
+  if (name.str().equals(#ClassName) &&                                         \
+      result->getParentModule()->getName().str().equals(#ModuleName)) {        \
+    using namespace inferred_attributes;                                       \
+    addInferredAttributes(result, AttributeSet);                               \
+  }
 #include "InferredAttributes.def"
 
       result->setMemberLoader(&Impl, 0);
diff --git a/lib/IRGen/CallEmission.h b/lib/IRGen/CallEmission.h
index 1b30f9a9f9d..33a0edcde4b 100644
--- a/lib/IRGen/CallEmission.h
+++ b/lib/IRGen/CallEmission.h
@@ -36,7 +36,7 @@ class CallEmission {
 
 private:
   /// The function attributes for the call.
-  llvm::AttributeSet Attrs;
+  llvm::AttributeList Attrs;
   
   /// The builtin/special arguments to pass to the call.
   SmallVector<llvm::Value*, 8> Args;
@@ -57,8 +57,8 @@ class CallEmission {
   void emitToUnmappedExplosion(Explosion &out);
   llvm::CallSite emitCallSite();
   llvm::CallSite emitInvoke(llvm::CallingConv::ID cc, llvm::Value *fn,
-                            ArrayRef<llvm::Value*> args,
-                            const llvm::AttributeSet &attrs);
+                            ArrayRef<llvm::Value *> args,
+                            const llvm::AttributeList &attrs);
 
 public:
   CallEmission(IRGenFunction &IGF, const Callee &callee)
diff --git a/lib/IRGen/GenCall.cpp b/lib/IRGen/GenCall.cpp
index 35899ff0ad9..a58182f36f9 100644
--- a/lib/IRGen/GenCall.cpp
+++ b/lib/IRGen/GenCall.cpp
@@ -76,7 +76,7 @@ static void addDereferenceableAttributeToBuilder(IRGenModule &IGM,
 }
 
 static void addIndirectValueParameterAttributes(IRGenModule &IGM,
-                                                llvm::AttributeSet &attrs,
+                                                llvm::AttributeList &attrs,
                                                 const TypeInfo &ti,
                                                 unsigned argIndex) {
   llvm::AttrBuilder b;
@@ -86,14 +86,13 @@ static void addIndirectValueParameterAttributes(IRGenModule &IGM,
   // The parameter must reference dereferenceable memory of the type.
   addDereferenceableAttributeToBuilder(IGM, b, ti);
 
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, argIndex+1, b);
+  auto resultAttrs = llvm::AttributeList::get(IGM.LLVMContext, argIndex + 1, b);
   attrs = attrs.addAttributes(IGM.LLVMContext, argIndex+1, resultAttrs);
 }
 
 static void addInoutParameterAttributes(IRGenModule &IGM,
-                                        llvm::AttributeSet &attrs,
-                                        const TypeInfo &ti,
-                                        unsigned argIndex,
+                                        llvm::AttributeList &attrs,
+                                        const TypeInfo &ti, unsigned argIndex,
                                         bool aliasable) {
   llvm::AttrBuilder b;
   // Aliasing inouts is unspecified, but we still want aliasing to be memory-
@@ -103,7 +102,7 @@ static void addInoutParameterAttributes(IRGenModule &IGM,
   // The inout must reference dereferenceable memory of the type.
   addDereferenceableAttributeToBuilder(IGM, b, ti);
 
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, argIndex+1, b);
+  auto resultAttrs = llvm::AttributeList::get(IGM.LLVMContext, argIndex + 1, b);
   attrs = attrs.addAttributes(IGM.LLVMContext, argIndex+1, resultAttrs);
 }
 
@@ -133,9 +132,8 @@ llvm::CallingConv::ID irgen::expandCallingConv(IRGenModule &IGM,
 }
 
 static void addIndirectResultAttributes(IRGenModule &IGM,
-                                        llvm::AttributeSet &attrs,
-                                        unsigned paramIndex,
-                                        bool allowSRet) {
+                                        llvm::AttributeList &attrs,
+                                        unsigned paramIndex, bool allowSRet) {
   static const llvm::Attribute::AttrKind attrKindsWithSRet[] = {
     llvm::Attribute::StructRet,
     llvm::Attribute::NoAlias,
@@ -145,14 +143,14 @@ static void addIndirectResultAttributes(IRGenModule &IGM,
     llvm::Attribute::NoAlias,
     llvm::Attribute::NoCapture,
   };
-  auto resultAttrs =
-    llvm::AttributeSet::get(IGM.LLVMContext, paramIndex + 1,
-                            (allowSRet ? makeArrayRef(attrKindsWithSRet)
-                                       : makeArrayRef(attrKindsWithoutSRet)));
+  auto resultAttrs = llvm::AttributeList::get(
+      IGM.LLVMContext, paramIndex + 1,
+      (allowSRet ? makeArrayRef(attrKindsWithSRet)
+                 : makeArrayRef(attrKindsWithoutSRet)));
   attrs = attrs.addAttributes(IGM.LLVMContext, paramIndex + 1, resultAttrs);
 }
 
-void IRGenModule::addSwiftSelfAttributes(llvm::AttributeSet &attrs,
+void IRGenModule::addSwiftSelfAttributes(llvm::AttributeList &attrs,
                                          unsigned argIndex) {
   if (!UseSwiftCC)
     return;
@@ -160,11 +158,11 @@ void IRGenModule::addSwiftSelfAttributes(llvm::AttributeSet &attrs,
     llvm::Attribute::SwiftSelf,
   };
   auto argAttrs =
-      llvm::AttributeSet::get(this->LLVMContext, argIndex + 1, attrKinds);
+      llvm::AttributeList::get(this->LLVMContext, argIndex + 1, attrKinds);
   attrs = attrs.addAttributes(this->LLVMContext, argIndex + 1, argAttrs);
 }
 
-void IRGenModule::addSwiftErrorAttributes(llvm::AttributeSet &attrs,
+void IRGenModule::addSwiftErrorAttributes(llvm::AttributeList &attrs,
                                           unsigned argIndex) {
   // Don't add the swifterror attribute on ABI that don't pass it in a register.
   // We create a shadow stack location of the swifterror parameter for the
@@ -177,33 +175,31 @@ void IRGenModule::addSwiftErrorAttributes(llvm::AttributeSet &attrs,
     llvm::Attribute::SwiftError,
   };
   auto argAttrs =
-      llvm::AttributeSet::get(this->LLVMContext, argIndex + 1, attrKinds);
+      llvm::AttributeList::get(this->LLVMContext, argIndex + 1, attrKinds);
   attrs = attrs.addAttributes(this->LLVMContext, argIndex + 1, argAttrs);
 }
 
 void irgen::addByvalArgumentAttributes(IRGenModule &IGM,
-                                       llvm::AttributeSet &attrs,
-                                       unsigned argIndex,
-                                       Alignment align) {
+                                       llvm::AttributeList &attrs,
+                                       unsigned argIndex, Alignment align) {
   llvm::AttrBuilder b;
   b.addAttribute(llvm::Attribute::ByVal);
   b.addAttribute(llvm::Attribute::getWithAlignment(IGM.LLVMContext,
                                                    align.getValue()));
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, argIndex+1, b);
+  auto resultAttrs = llvm::AttributeList::get(IGM.LLVMContext, argIndex + 1, b);
   attrs = attrs.addAttributes(IGM.LLVMContext,
                               argIndex+1,
                               resultAttrs);
 }
 
-void irgen::addExtendAttribute(IRGenModule &IGM,
-                               llvm::AttributeSet &attrs,
+void irgen::addExtendAttribute(IRGenModule &IGM, llvm::AttributeList &attrs,
                                unsigned index, bool signExtend) {
   llvm::AttrBuilder b;
   if (signExtend)
     b.addAttribute(llvm::Attribute::SExt);
   else
     b.addAttribute(llvm::Attribute::ZExt);
-  auto resultAttrs = llvm::AttributeSet::get(IGM.LLVMContext, index, b);
+  auto resultAttrs = llvm::AttributeList::get(IGM.LLVMContext, index, b);
   attrs = attrs.addAttributes(IGM.LLVMContext, index, resultAttrs);
 }
 
@@ -213,7 +209,7 @@ namespace {
     CanSILFunctionType FnType;
   public:
     SmallVector<llvm::Type*, 8> ParamIRTypes;
-    llvm::AttributeSet Attrs;
+    llvm::AttributeList Attrs;
     ForeignFunctionInfo ForeignInfo;
     bool CanUseSRet = true;
     bool CanUseError = true;
@@ -902,7 +898,7 @@ llvm::Type *SignatureExpansion::expandExternalSignatureTypes() {
     bool signExt = clangResultTy->hasSignedIntegerRepresentation();
     assert((signExt || clangResultTy->hasUnsignedIntegerRepresentation()) &&
            "Invalid attempt to add extension attribute to argument!");
-    addExtendAttribute(IGM, Attrs, llvm::AttributeSet::ReturnIndex, signExt);
+    addExtendAttribute(IGM, Attrs, llvm::AttributeList::ReturnIndex, signExt);
   }
 
   // If we return indirectly, that is the first parameter type.
@@ -1305,8 +1301,8 @@ void CallEmission::emitToUnmappedMemory(Address result) {
 // FIXME: This doesn't belong on IGF.
 llvm::CallSite CallEmission::emitInvoke(llvm::CallingConv::ID convention,
                                         llvm::Value *fn,
-                                        ArrayRef<llvm::Value*> args,
-                                        const llvm::AttributeSet &attrs) {
+                                        ArrayRef<llvm::Value *> args,
+                                        const llvm::AttributeList &attrs) {
   // TODO: exceptions!
   llvm::CallInst *call = IGF.Builder.CreateCall(fn, args);
   call->setAttributes(attrs);
@@ -1339,9 +1335,8 @@ llvm::CallSite CallEmission::emitCallSite() {
       Args[i] = IGF.coerceValue(Args[i], paramTy, IGF.IGM.DataLayout);
   }
 
-  llvm::CallSite call = emitInvoke(cc, fnPtr, Args,
-                                   llvm::AttributeSet::get(fnPtr->getContext(),
-                                                           Attrs));
+  llvm::CallSite call = emitInvoke(
+      cc, fnPtr, Args, llvm::AttributeList::get(fnPtr->getContext(), Attrs));
   Args.clear();
 
   // Return.
diff --git a/lib/IRGen/GenCall.h b/lib/IRGen/GenCall.h
index 3c7153b5396..c4576689fc5 100644
--- a/lib/IRGen/GenCall.h
+++ b/lib/IRGen/GenCall.h
@@ -24,7 +24,7 @@
 #include "llvm/IR/CallingConv.h"
 
 namespace llvm {
-  class AttributeSet;
+  class AttributeList;
   class Twine;
   class Type;
   class Value;
@@ -70,15 +70,15 @@ namespace irgen {
 
   /// Add function attributes to an attribute set for a byval argument.
   void addByvalArgumentAttributes(IRGenModule &IGM,
-                                  llvm::AttributeSet &attrs,
+                                  llvm::AttributeList &attrs,
                                   unsigned argIndex,
                                   Alignment align);
 
   /// Add signext or zeroext attribute set for an argument that needs
   /// extending.
-  void addExtendAttribute(IRGenModule &IGM, llvm::AttributeSet &attrs,
+  void addExtendAttribute(IRGenModule &IGM, llvm::AttributeList &attrs,
                           unsigned index, bool signExtend);
-  
+
   /// Can a series of values be simply pairwise coerced to (or from) an
   /// explosion schema, or do they need to traffic through memory?
   bool canCoerceToSchema(IRGenModule &IGM,
diff --git a/lib/IRGen/GenEnum.cpp b/lib/IRGen/GenEnum.cpp
index 1802e662fd1..b6aaeb53604 100644
--- a/lib/IRGen/GenEnum.cpp
+++ b/lib/IRGen/GenEnum.cpp
@@ -3239,9 +3239,9 @@ namespace {
       auto call = IGF.Builder.CreateCall(IGF.IGM.getGetEnumCaseMultiPayloadFn(),
                                          {addr.getAddress(), metadata});
       call->setDoesNotThrow();
-      call->addAttribute(llvm::AttributeSet::FunctionIndex,
+      call->addAttribute(llvm::AttributeList::FunctionIndex,
                          llvm::Attribute::ReadOnly);
-      
+
       return call;
     }
 
diff --git a/lib/IRGen/GenFunc.cpp b/lib/IRGen/GenFunc.cpp
index 0f579302019..2b7647f85d6 100644
--- a/lib/IRGen/GenFunc.cpp
+++ b/lib/IRGen/GenFunc.cpp
@@ -618,7 +618,7 @@ getFuncSignatureInfoForLowered(IRGenModule &IGM, CanSILFunctionType type) {
 
 llvm::FunctionType *
 IRGenModule::getFunctionType(CanSILFunctionType type,
-                             llvm::AttributeSet &attrs,
+                             llvm::AttributeList &attrs,
                              ForeignFunctionInfo *foreignInfo) {
   auto &sigInfo = getFuncSignatureInfoForLowered(*this, type);
   Signature sig = sigInfo.getSignature(*this);
@@ -684,18 +684,13 @@ static void emitApplyArgument(IRGenFunction &IGF,
 /// If 'layout' is null, there is a single captured value of
 /// Swift-refcountable type that is being used directly as the
 /// context object.
-static llvm::Function *emitPartialApplicationForwarder(IRGenModule &IGM,
-                                   llvm::Function *staticFnPtr,
-                                   bool calleeHasContext,
-                                   llvm::Type *fnTy,
-                                   const llvm::AttributeSet &origAttrs,
-                                   CanSILFunctionType origType,
-                                   CanSILFunctionType substType,
-                                   CanSILFunctionType outType,
-                                   SubstitutionList subs,
-                                   HeapLayout const *layout,
-                                   ArrayRef<ParameterConvention> conventions) {
-  llvm::AttributeSet outAttrs;
+static llvm::Function *emitPartialApplicationForwarder(
+    IRGenModule &IGM, llvm::Function *staticFnPtr, bool calleeHasContext,
+    llvm::Type *fnTy, const llvm::AttributeList &origAttrs,
+    CanSILFunctionType origType, CanSILFunctionType substType,
+    CanSILFunctionType outType, SubstitutionList subs, HeapLayout const *layout,
+    ArrayRef<ParameterConvention> conventions) {
+  llvm::AttributeList outAttrs;
 
   llvm::FunctionType *fwdTy = IGM.getFunctionType(outType, outAttrs);
   SILFunctionConventions outConv(outType, IGM.getSILModule());
@@ -716,8 +711,8 @@ static llvm::Function *emitPartialApplicationForwarder(IRGenModule &IGM,
 
   auto initialAttrs = IGM.constructInitialAttributes();
   // Merge initialAttrs with outAttrs.
-  auto updatedAttrs = outAttrs.addAttributes(IGM.getLLVMContext(),
-                        llvm::AttributeSet::FunctionIndex, initialAttrs);
+  auto updatedAttrs = outAttrs.addAttributes(
+      IGM.getLLVMContext(), llvm::AttributeList::FunctionIndex, initialAttrs);
   fwd->setAttributes(updatedAttrs);
 
   IRGenFunction subIGF(IGM, fwd);
@@ -1397,7 +1392,7 @@ void irgen::emitFunctionPartialApplication(IRGenFunction &IGF,
     assert(bindings.empty());
     assert(args.size() == 1);
 
-    llvm::AttributeSet attrs;
+    llvm::AttributeList attrs;
     auto fnPtrTy = IGF.IGM.getFunctionType(origType, attrs)
       ->getPointerTo();
 
@@ -1477,7 +1472,7 @@ void irgen::emitFunctionPartialApplication(IRGenFunction &IGF,
   assert(args.empty() && "unused args in partial application?!");
   
   // Create the forwarding stub.
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   auto fnPtrTy = IGF.IGM.getFunctionType(origType, attrs)
     ->getPointerTo();
 
diff --git a/lib/IRGen/GenHeap.cpp b/lib/IRGen/GenHeap.cpp
index 6220aebb54a..a6fd29babff 100644
--- a/lib/IRGen/GenHeap.cpp
+++ b/lib/IRGen/GenHeap.cpp
@@ -1249,9 +1249,9 @@ llvm::Constant *IRGenModule::getFixLifetimeFn() {
   // Don't inline the function, so it stays as a signal to the ARC passes.
   // The ARC passes will remove references to the function when they're
   // no longer needed.
-  fixLifetime->addAttribute(llvm::AttributeSet::FunctionIndex,
+  fixLifetime->addAttribute(llvm::AttributeList::FunctionIndex,
                             llvm::Attribute::NoInline);
-  
+
   // Give the function an empty body.
   auto entry = llvm::BasicBlock::Create(LLVMContext, "", fixLifetime);
   llvm::ReturnInst::Create(LLVMContext, entry);
diff --git a/lib/IRGen/GenMeta.cpp b/lib/IRGen/GenMeta.cpp
index 590e58d9c90..a595a77d304 100644
--- a/lib/IRGen/GenMeta.cpp
+++ b/lib/IRGen/GenMeta.cpp
@@ -344,9 +344,9 @@ static llvm::Value *emitForeignTypeMetadataRef(IRGenFunction &IGF,
   llvm::Value *candidate = IGF.IGM.getAddrOfForeignTypeMetadataCandidate(type);
   auto call = IGF.Builder.CreateCall(IGF.IGM.getGetForeignTypeMetadataFn(),
                                 candidate);
-  call->addAttribute(llvm::AttributeSet::FunctionIndex,
+  call->addAttribute(llvm::AttributeList::FunctionIndex,
                      llvm::Attribute::NoUnwind);
-  call->addAttribute(llvm::AttributeSet::FunctionIndex,
+  call->addAttribute(llvm::AttributeList::FunctionIndex,
                      llvm::Attribute::ReadNone);
   return call;
 }
@@ -396,7 +396,7 @@ static llvm::Value *emitNominalMetadataRef(IRGenFunction &IGF,
 
   auto result = IGF.Builder.CreateCall(accessor, genericArgs.Values);
   result->setDoesNotThrow();
-  result->addAttribute(llvm::AttributeSet::FunctionIndex,
+  result->addAttribute(llvm::AttributeList::FunctionIndex,
                        llvm::Attribute::ReadNone);
 
   IGF.setScopedLocalTypeData(theType, LocalTypeDataKind::forTypeMetadata(),
@@ -1180,7 +1180,7 @@ static llvm::Value *emitGenericMetadataAccessFunction(IRGenFunction &IGF,
   auto result = IGF.Builder.CreateCall(IGF.IGM.getGetGenericMetadataFn(),
                                        {metadata, arguments});
   result->setDoesNotThrow();
-  result->addAttribute(llvm::AttributeSet::FunctionIndex,
+  result->addAttribute(llvm::AttributeList::FunctionIndex,
                        llvm::Attribute::ReadOnly);
 
   IGF.Builder.CreateLifetimeEnd(argsBuffer,
@@ -1552,7 +1552,7 @@ namespace {
 
         auto result = IGF.Builder.CreateCall(accessor, args);
         result->setDoesNotThrow();
-        result->addAttribute(llvm::AttributeSet::FunctionIndex,
+        result->addAttribute(llvm::AttributeList::FunctionIndex,
                              llvm::Attribute::ReadNone);
 
         return result;
@@ -4515,7 +4515,7 @@ emitHeapMetadataRefForUnknownHeapObject(IRGenFunction &IGF,
                                          object->getName() + ".Type");
   metadata->setCallingConv(llvm::CallingConv::C);
   metadata->setDoesNotThrow();
-  metadata->addAttribute(llvm::AttributeSet::FunctionIndex,
+  metadata->addAttribute(llvm::AttributeList::FunctionIndex,
                          llvm::Attribute::ReadOnly);
   return metadata;
 }
@@ -4654,7 +4654,7 @@ llvm::Value *irgen::emitVirtualMethodValue(IRGenFunction &IGF,
 
   // Use the type of the method we were type-checked against, not the
   // type of the overridden method.
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   auto fnTy = IGF.IGM.getFunctionType(methodType, attrs)->getPointerTo();
 
   auto declaringClass = cast<ClassDecl>(overridden.getDecl()->getDeclContext());
diff --git a/lib/IRGen/GenObjC.cpp b/lib/IRGen/GenObjC.cpp
index 50f4439372b..a23f9611497 100644
--- a/lib/IRGen/GenObjC.cpp
+++ b/lib/IRGen/GenObjC.cpp
@@ -656,7 +656,7 @@ CallEmission irgen::prepareObjCMethodRootCall(IRGenFunction &IGF,
          "objc method call must be to a func/initializer/getter/setter/dtor");
 
   ForeignFunctionInfo foreignInfo;
-  llvm::AttributeSet attrs;
+  llvm::AttributeList attrs;
   auto fnTy = IGF.IGM.getFunctionType(origFnType, attrs, &foreignInfo);
   bool indirectResult = foreignInfo.ClangInfo->getReturnInfo().isIndirect();
   if (kind != ObjCMessageKind::Normal)
@@ -762,8 +762,8 @@ static llvm::Function *emitObjCPartialApplicationForwarder(IRGenModule &IGM,
  
   assert(resultType->getRepresentation()
            == SILFunctionType::Representation::Thick);
- 
-  llvm::AttributeSet attrs;
+
+  llvm::AttributeList attrs;
   llvm::FunctionType *fwdTy = IGM.getFunctionType(resultType, attrs);
   // FIXME: Give the thunk a real name.
   // FIXME: Maybe cache the thunk by function and closure types?
@@ -776,8 +776,8 @@ static llvm::Function *emitObjCPartialApplicationForwarder(IRGenModule &IGM,
 
   auto initialAttrs = IGM.constructInitialAttributes();
   // Merge initialAttrs with attrs.
-  auto updatedAttrs = attrs.addAttributes(IGM.getLLVMContext(),
-                        llvm::AttributeSet::FunctionIndex, initialAttrs);
+  auto updatedAttrs = attrs.addAttributes(
+      IGM.getLLVMContext(), llvm::AttributeList::FunctionIndex, initialAttrs);
   fwd->setAttributes(updatedAttrs);
   
   IRGenFunction subIGF(IGM, fwd);
diff --git a/lib/IRGen/GenOpaque.cpp b/lib/IRGen/GenOpaque.cpp
index 2760b23dd3f..b56952b1650 100644
--- a/lib/IRGen/GenOpaque.cpp
+++ b/lib/IRGen/GenOpaque.cpp
@@ -349,9 +349,9 @@ llvm::Value *IRGenFunction::emitValueWitnessForLayout(SILType type,
 static void setHelperAttributesForAggResult(llvm::CallInst *call,
                                             bool isFormalResult = true) {
   // Set as nounwind.
-  auto attrs = llvm::AttributeSet::get(call->getContext(),
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
+  auto attrs = llvm::AttributeList::get(call->getContext(),
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
 
   attrs = attrs.addAttribute(call->getContext(), 1, llvm::Attribute::NoAlias);
 
@@ -367,9 +367,9 @@ static void setHelperAttributesForAggResult(llvm::CallInst *call,
 /// Given a call to a helper function, set attributes appropriately.
 static void setHelperAttributes(llvm::CallInst *call) {
   // Set as nounwind.
-  auto attrs = llvm::AttributeSet::get(call->getContext(),
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
+  auto attrs = llvm::AttributeList::get(call->getContext(),
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
 
   call->setAttributes(attrs);
 }
diff --git a/lib/IRGen/IRGenFunction.cpp b/lib/IRGen/IRGenFunction.cpp
index 8eb014de8c7..a3fda85b57d 100644
--- a/lib/IRGen/IRGenFunction.cpp
+++ b/lib/IRGen/IRGenFunction.cpp
@@ -151,10 +151,10 @@ llvm::Value *IRGenFunction::emitVerifyEndOfLifetimeCall(llvm::Value *object,
 void IRGenFunction::emitAllocBoxCall(llvm::Value *typeMetadata,
                                       llvm::Value *&box,
                                       llvm::Value *&valueAddress) {
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
-  
+  auto attrs = llvm::AttributeList::get(IGM.LLVMContext,
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
+
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getAllocBoxFn(), typeMetadata);
   call->setAttributes(attrs);
@@ -165,9 +165,9 @@ void IRGenFunction::emitAllocBoxCall(llvm::Value *typeMetadata,
 
 void IRGenFunction::emitDeallocBoxCall(llvm::Value *box,
                                         llvm::Value *typeMetadata) {
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       llvm::Attribute::NoUnwind);
+  auto attrs = llvm::AttributeList::get(IGM.LLVMContext,
+                                        llvm::AttributeList::FunctionIndex,
+                                        llvm::Attribute::NoUnwind);
 
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getDeallocBoxFn(), box);
@@ -181,9 +181,8 @@ llvm::Value *IRGenFunction::emitProjectBoxCall(llvm::Value *box,
     llvm::Attribute::NoUnwind,
     llvm::Attribute::ReadNone,
   };
-  auto attrs = llvm::AttributeSet::get(IGM.LLVMContext,
-                                       llvm::AttributeSet::FunctionIndex,
-                                       attrKinds);
+  auto attrs = llvm::AttributeList::get(
+      IGM.LLVMContext, llvm::AttributeList::FunctionIndex, attrKinds);
   llvm::CallInst *call =
     Builder.CreateCall(IGM.getProjectBoxFn(), box);
   call->setCallingConv(IGM.DefaultCC);
diff --git a/lib/IRGen/IRGenModule.cpp b/lib/IRGen/IRGenModule.cpp
index f96eba672b1..9f8e8d70691 100644
--- a/lib/IRGen/IRGenModule.cpp
+++ b/lib/IRGen/IRGenModule.cpp
@@ -466,18 +466,16 @@ llvm::Constant *swift::getRuntimeFn(llvm::Module &Module,
     }
     // FIXME: getting attributes here without setting them does
     // nothing. This cannot be fixed until the attributes are correctly specified.
-    fn->getAttributes().
-      addAttributes(Module.getContext(),
-                    llvm::AttributeSet::FunctionIndex,
-                    llvm::AttributeSet::get(Module.getContext(),
-                                            llvm::AttributeSet::FunctionIndex,
-                                            buildFnAttr));
-    fn->getAttributes().
-      addAttributes(Module.getContext(),
-                    llvm::AttributeSet::ReturnIndex,
-                    llvm::AttributeSet::get(Module.getContext(),
-                                            llvm::AttributeSet::ReturnIndex,
-                                            buildRetAttr));
+    fn->getAttributes().addAttributes(
+        Module.getContext(), llvm::AttributeList::FunctionIndex,
+        llvm::AttributeList::get(Module.getContext(),
+                                 llvm::AttributeList::FunctionIndex,
+                                 buildFnAttr));
+    fn->getAttributes().addAttributes(
+        Module.getContext(), llvm::AttributeList::ReturnIndex,
+        llvm::AttributeList::get(Module.getContext(),
+                                 llvm::AttributeList::ReturnIndex,
+                                 buildRetAttr));
   }
 
   return cache;
@@ -504,7 +502,7 @@ llvm::Constant *swift::getWrapperFn(llvm::Module &Module,
   auto *fun = dyn_cast<llvm::Function>(fn);
   assert(fun && "Wrapper should be an llvm::Function");
   // Do not inline wrappers, because this would result in a code size increase.
-  fun->addAttribute(llvm::AttributeSet::FunctionIndex,
+  fun->addAttribute(llvm::AttributeList::FunctionIndex,
                     llvm::Attribute::NoInline);
   assert(fun->hasFnAttribute(llvm::Attribute::NoInline) &&
          "Wrappers should not be inlined");
@@ -754,32 +752,32 @@ void IRGenerator::addLazyWitnessTable(const ProtocolConformance *Conf) {
   }
 }
 
-llvm::AttributeSet IRGenModule::getAllocAttrs() {
+llvm::AttributeList IRGenModule::getAllocAttrs() {
   if (AllocAttrs.isEmpty()) {
-    AllocAttrs = llvm::AttributeSet::get(LLVMContext,
-                                         llvm::AttributeSet::ReturnIndex,
-                                         llvm::Attribute::NoAlias);
-    AllocAttrs = AllocAttrs.addAttribute(LLVMContext,
-                               llvm::AttributeSet::FunctionIndex,
-                               llvm::Attribute::NoUnwind);
+    AllocAttrs =
+        llvm::AttributeList::get(LLVMContext, llvm::AttributeList::ReturnIndex,
+                                 llvm::Attribute::NoAlias);
+    AllocAttrs =
+        AllocAttrs.addAttribute(LLVMContext, llvm::AttributeList::FunctionIndex,
+                                llvm::Attribute::NoUnwind);
   }
   return AllocAttrs;
 }
 
 /// Construct initial attributes from options.
-llvm::AttributeSet IRGenModule::constructInitialAttributes() {
-  llvm::AttributeSet attrsUpdated;
+llvm::AttributeList IRGenModule::constructInitialAttributes() {
+  llvm::AttributeList attrsUpdated;
   // Add DisableFPElim. 
   if (!IRGen.Opts.DisableFPElim) {
     attrsUpdated = attrsUpdated.addAttribute(LLVMContext,
-                     llvm::AttributeSet::FunctionIndex,
-                     "no-frame-pointer-elim", "false");
+                                             llvm::AttributeList::FunctionIndex,
+                                             "no-frame-pointer-elim", "false");
   } else {
     attrsUpdated = attrsUpdated.addAttribute(
-        LLVMContext, llvm::AttributeSet::FunctionIndex,
+        LLVMContext, llvm::AttributeList::FunctionIndex,
         "no-frame-pointer-elim", "true");
     attrsUpdated = attrsUpdated.addAttribute(
-        LLVMContext, llvm::AttributeSet::FunctionIndex,
+        LLVMContext, llvm::AttributeList::FunctionIndex,
         "no-frame-pointer-elim-non-leaf");
   }
 
@@ -789,8 +787,8 @@ llvm::AttributeSet IRGenModule::constructInitialAttributes() {
 
   std::string &CPU = ClangOpts.CPU;
   if (CPU != "")
-    attrsUpdated = attrsUpdated.addAttribute(LLVMContext,
-                     llvm::AttributeSet::FunctionIndex, "target-cpu", CPU);
+    attrsUpdated = attrsUpdated.addAttribute(
+        LLVMContext, llvm::AttributeList::FunctionIndex, "target-cpu", CPU);
 
   std::vector<std::string> &Features = ClangOpts.Features;
   if (!Features.empty()) {
@@ -801,7 +799,7 @@ llvm::AttributeSet IRGenModule::constructInitialAttributes() {
       allFeatures.push_back(',');
     });
     attrsUpdated = attrsUpdated.addAttribute(LLVMContext,
-                     llvm::AttributeSet::FunctionIndex, "target-features",
+                     llvm::AttributeList::FunctionIndex, "target-features",
                      allFeatures);
   }
   return attrsUpdated;
diff --git a/lib/IRGen/IRGenModule.h b/lib/IRGen/IRGenModule.h
index 74690a89302..ffb9aa98de8 100644
--- a/lib/IRGen/IRGenModule.h
+++ b/lib/IRGen/IRGenModule.h
@@ -57,7 +57,7 @@ namespace llvm {
   class StructType;
   class StringRef;
   class Type;
-  class AttributeSet;
+  class AttributeList;
 }
 namespace clang {
   class ASTContext;
@@ -837,7 +837,7 @@ class IRGenModule {
   ClassDecl *getObjCRuntimeBaseClass(Identifier name, Identifier objcName);
   llvm::Module *getModule() const;
   llvm::Module *releaseModule();
-  llvm::AttributeSet getAllocAttrs();
+  llvm::AttributeList getAllocAttrs();
 
 private:
   llvm::Constant *EmptyTupleMetadata = nullptr;
@@ -846,7 +846,7 @@ class IRGenModule {
   llvm::Constant *ObjCISAMaskPtr = nullptr;
   Optional<llvm::Value*> ObjCRetainAutoreleasedReturnValueMarker;
   llvm::DenseMap<Identifier, ClassDecl*> SwiftRootClasses;
-  llvm::AttributeSet AllocAttrs;
+  llvm::AttributeList AllocAttrs;
 
 #define FUNCTION_ID(Id)             \
 public:                             \
@@ -885,7 +885,7 @@ private:                            \
   /// invalid.
   bool finalize();
 
-  llvm::AttributeSet constructInitialAttributes();
+  llvm::AttributeList constructInitialAttributes();
 
   void emitProtocolDecl(ProtocolDecl *D);
   void emitEnumDecl(EnumDecl *D);
@@ -905,7 +905,7 @@ private:                            \
   void finishEmitAfterTopLevel();
 
   llvm::FunctionType *getFunctionType(CanSILFunctionType type,
-                                      llvm::AttributeSet &attrs,
+                                      llvm::AttributeList &attrs,
                                       ForeignFunctionInfo *foreignInfo=nullptr);
   ForeignFunctionInfo getForeignFunctionInfo(CanSILFunctionType type);
 
@@ -1017,10 +1017,10 @@ private:                            \
   void setTrueConstGlobal(llvm::GlobalVariable *var);
 
   /// Add the swiftself attribute.
-  void addSwiftSelfAttributes(llvm::AttributeSet &attrs, unsigned argIndex);
+  void addSwiftSelfAttributes(llvm::AttributeList &attrs, unsigned argIndex);
 
   /// Add the swifterror attribute.
-  void addSwiftErrorAttributes(llvm::AttributeSet &attrs, unsigned argIndex);
+  void addSwiftErrorAttributes(llvm::AttributeList &attrs, unsigned argIndex);
 
 private:
   llvm::Constant *getAddrOfLLVMVariable(LinkEntity entity,
diff --git a/lib/IRGen/IRGenSIL.cpp b/lib/IRGen/IRGenSIL.cpp
index 0b3443606fa..192f7fefc7a 100644
--- a/lib/IRGen/IRGenSIL.cpp
+++ b/lib/IRGen/IRGenSIL.cpp
@@ -2021,7 +2021,7 @@ static CallEmission getCallEmissionForLoweredValue(IRGenSILFunction &IGF,
     }
 
     // Cast the callee pointer to the right function type.
-    llvm::AttributeSet attrs;
+    llvm::AttributeList attrs;
     llvm::FunctionType *fnTy =
       IGF.IGM.getFunctionType(origCalleeType, attrs, &foreignInfo);
     calleeFn = IGF.Builder.CreateBitCast(calleeFn, fnTy->getPointerTo());
@@ -2040,8 +2040,9 @@ static CallEmission getCallEmissionForLoweredValue(IRGenSILFunction &IGF,
                                            foreignInfo);
   CallEmission callEmission(IGF, callee);
   if (IGF.CurSILFn->isThunk())
-    callEmission.addAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::NoInline);
-  
+    callEmission.addAttribute(llvm::AttributeList::FunctionIndex,
+                              llvm::Attribute::NoInline);
+
   return callEmission;
 }
 
diff --git a/lib/IRGen/Signature.h b/lib/IRGen/Signature.h
index 9c7d0bd0fc0..d4a3d0237c9 100644
--- a/lib/IRGen/Signature.h
+++ b/lib/IRGen/Signature.h
@@ -49,7 +49,7 @@ class ForeignFunctionInfo {
 /// A signature represents something which can actually be called.
 class Signature {
   llvm::FunctionType *Type = nullptr;
-  llvm::AttributeSet Attributes;
+  llvm::AttributeList Attributes;
   ForeignFunctionInfo ForeignInfo;
 
 public:
@@ -64,7 +64,7 @@ class Signature {
     return Type;
   }
 
-  llvm::AttributeSet getAttributes() const {
+  llvm::AttributeList getAttributes() const {
     assert(isValid());
     return Attributes;
   }
diff --git a/lib/LLVMPasses/ARCEntryPointBuilder.h b/lib/LLVMPasses/ARCEntryPointBuilder.h
index 144e92e76c5..00fadda275a 100644
--- a/lib/LLVMPasses/ARCEntryPointBuilder.h
+++ b/lib/LLVMPasses/ARCEntryPointBuilder.h
@@ -45,7 +45,7 @@ class ARCEntryPointBuilder {
   using CallInst = llvm::CallInst;
   using Value = llvm::Value;
   using Module = llvm::Module;
-  using AttributeSet = llvm::AttributeSet;
+  using AttributeList = llvm::AttributeList;
   using Attribute = llvm::Attribute;
   using APInt = llvm::APInt;
   
@@ -266,9 +266,9 @@ class ARCEntryPointBuilder {
     
     auto *ObjectPtrTy = getObjectPtrTy();
     auto &M = getModule();
-    auto AttrList = AttributeSet::get(M.getContext(), 1, Attribute::NoCapture);
+    auto AttrList = AttributeList::get(M.getContext(), 1, Attribute::NoCapture);
     AttrList = AttrList.addAttribute(
-        M.getContext(), AttributeSet::FunctionIndex, Attribute::NoUnwind);
+        M.getContext(), AttributeList::FunctionIndex, Attribute::NoUnwind);
     CheckUnowned = M.getOrInsertFunction("swift_checkUnowned", AttrList,
                                          Type::getVoidTy(M.getContext()),
                                          ObjectPtrTy, nullptr);
diff --git a/lib/LLVMPasses/LLVMMergeFunctions.cpp b/lib/LLVMPasses/LLVMMergeFunctions.cpp
index 956124632d3..24fb2a2b939 100644
--- a/lib/LLVMPasses/LLVMMergeFunctions.cpp
+++ b/lib/LLVMPasses/LLVMMergeFunctions.cpp
@@ -1039,7 +1039,7 @@ bool SwiftMergeFunctions::replaceDirectCallers(Function *Old, Function *New,
     auto CallSiteAttrs = CI->getAttributes();
 
     CallSiteAttrs = CallSiteAttrs.addAttributes(
-        Context, AttributeSet::ReturnIndex, NewFuncAttrs.getRetAttributes());
+        Context, AttributeList::ReturnIndex, NewFuncAttrs.getRetAttributes());
 
     SmallVector<Type *, 8> OldParamTypes;
     SmallVector<Value *, 16> NewArgs;
@@ -1051,7 +1051,7 @@ bool SwiftMergeFunctions::replaceDirectCallers(Function *Old, Function *New,
     
     // Add the existing parameters.
     for (Value *OldArg : CI->arg_operands()) {
-      AttributeSet Attrs = NewFuncAttrs.getParamAttributes(ParamIdx);
+      AttributeList Attrs = NewFuncAttrs.getParamAttributes(ParamIdx);
       if (Attrs.getNumSlots())
         CallSiteAttrs = CallSiteAttrs.addAttributes(Context, ParamIdx, Attrs);
 

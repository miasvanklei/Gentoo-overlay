From 3b3943009658dc88ec812bd4ed6194ee87f1f529 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Sat, 24 Sep 2016 10:44:35 -0400
Subject: [PATCH 01/18] [4.0] Configure allows LLVM 4.0

---
 configure | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/configure b/configure
index 8b271b2b..bb1be62 100755
--- a/configure
+++ b/configure
@@ -1064,6 +1064,9 @@ then
         (3.[7-9]*)
             msg "found ok version of LLVM: $LLVM_VERSION"
             ;;
+        (4.[0]*)
+            msg "found ok version of LLVM: $LLVM_VERSION"
+            ;;
         (*)
             err "bad LLVM version: $LLVM_VERSION, need >=3.7"
             ;;

From cf000b7c0df2a15c25eef03d3c38300a2328cab4 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Fri, 18 Nov 2016 15:24:00 -0500
Subject: [PATCH 02/18] [LLVM 4.0] Introduce a stable representation of DIFlags

---
 src/librustc_llvm/ffi.rs                 |  64 +++++++-----
 src/librustc_trans/debuginfo/metadata.rs |  34 +++----
 src/librustc_trans/debuginfo/mod.rs      |   7 +-
 src/rustllvm/RustWrapper.cpp             | 167 ++++++++++++++++++++++++++++---
 4 files changed, 212 insertions(+), 60 deletions(-)

diff --git a/src/librustc_llvm/ffi.rs b/src/librustc_llvm/ffi.rs
index bb2be24..b3a4271 100644
--- a/src/librustc_llvm/ffi.rs
+++ b/src/librustc_llvm/ffi.rs
@@ -11,7 +11,7 @@
 use debuginfo::{DIBuilderRef, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,
                 DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,
                 DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,
-                DINameSpace};
+                DINameSpace, DIFlags};
 
 use libc::{c_uint, c_int, size_t, c_char};
 use libc::{c_longlong, c_ulonglong, c_void};
@@ -437,7 +437,6 @@ pub enum Visibility {
 }
 
 pub mod debuginfo {
-    pub use self::DIDescriptorFlags::*;
     use super::MetadataRef;
 
     #[allow(missing_copy_implementations)]
@@ -426,24 +426,38 @@
     pub type DIEnumerator = DIDescriptor;
     pub type DITemplateTypeParameter = DIDescriptor;
 
-    #[derive(Copy, Clone)]
-    pub enum DIDescriptorFlags {
-        FlagPrivate = 1 << 0,
-        FlagProtected = 1 << 1,
-        FlagFwdDecl = 1 << 2,
-        FlagAppleBlock = 1 << 3,
-        FlagBlockByrefStruct = 1 << 4,
-        FlagVirtual = 1 << 5,
-        FlagArtificial = 1 << 6,
-        FlagExplicit = 1 << 7,
-        FlagPrototyped = 1 << 8,
-        FlagObjcClassComplete = 1 << 9,
-        FlagObjectPointer = 1 << 10,
-        FlagVector = 1 << 11,
-        FlagStaticMember = 1 << 12,
-        FlagIndirectVariable = 1 << 13,
-        FlagLValueReference = 1 << 14,
-        FlagRValueReference = 1 << 15,
+// These values **must** match with LLVMRustDIFlags!!
+    bitflags! {
+        #[repr(C)]
+        #[derive(Debug, Default)]
+        flags DIFlags: ::libc::c_uint {
+            const FlagZero                = 0,
+            const FlagPrivate             = 1,
+            const FlagProtected           = 2,
+            const FlagPublic              = 3,
+            const FlagFwdDecl             = (1 << 2),
+            const FlagAppleBlock          = (1 << 3),
+            const FlagBlockByrefStruct    = (1 << 4),
+            const FlagVirtual             = (1 << 5),
+            const FlagArtificial          = (1 << 6),
+            const FlagExplicit            = (1 << 7),
+            const FlagPrototyped          = (1 << 8),
+            const FlagObjcClassComplete   = (1 << 9),
+            const FlagObjectPointer       = (1 << 10),
+            const FlagVector              = (1 << 11),
+            const FlagStaticMember        = (1 << 12),
+            const FlagLValueReference     = (1 << 13),
+            const FlagRValueReference     = (1 << 14),
+            const FlagExternalTypeRef     = (1 << 15),
+            const FlagSingleInheritance   = (1 << 16),
+            const FlagMultipleInheritance = (2 << 16),
+            const FlagVirtualInheritance  = (3 << 16),
+            const FlagIntroducedVirtual   = (1 << 18),
+            const FlagBitField            = (1 << 19),
+
+            // #if LLVM_VERSION_GE(4, 0)
+            // FlagNoReturn            = (1 << 20),
+        }
     }
 }
 
@@ -1600,7 +1614,7 @@ extern "C" {
                                            isLocalToUnit: bool,
                                            isDefinition: bool,
                                            ScopeLine: c_uint,
-                                           Flags: c_uint,
+                                           Flags: DIFlags,
                                            isOptimized: bool,
                                            Fn: ValueRef,
                                            TParam: DIArray,
@@ -1628,7 +1642,7 @@ extern "C" {
                                              LineNumber: c_uint,
                                              SizeInBits: u64,
                                              AlignInBits: u64,
-                                             Flags: c_uint,
+                                             Flags: DIFlags,
                                              DerivedFrom: DIType,
                                              Elements: DIArray,
                                              RunTimeLang: c_uint,
@@ -1644,7 +1658,7 @@ extern "C" {
                                              SizeInBits: u64,
                                              AlignInBits: u64,
                                              OffsetInBits: u64,
-                                             Flags: c_uint,
+                                             Flags: DIFlags,
                                              Ty: DIType)
                                              -> DIDerivedType;
 
@@ -1680,7 +1694,7 @@ extern "C" {
                                            LineNo: c_uint,
                                            Ty: DIType,
                                            AlwaysPreserve: bool,
-                                           Flags: c_uint,
+                                           Flags: DIFlags,
                                            ArgNo: c_uint)
                                            -> DIVariable;
 
@@ -1740,7 +1754,7 @@ extern "C" {
                                             LineNumber: c_uint,
                                             SizeInBits: u64,
                                             AlignInBits: u64,
-                                            Flags: c_uint,
+                                            Flags: DIFlags,
                                             Elements: DIArray,
                                             RunTimeLang: c_uint,
                                             UniqueId: *const c_char)
diff --git a/src/librustc_trans/debuginfo/metadata.rs b/src/librustc_trans/debuginfo/metadata.rs
index 5b9ef78..e68dc3c 100644
--- a/src/librustc_trans/debuginfo/metadata.rs
+++ b/src/librustc_trans/debuginfo/metadata.rs
@@ -22,7 +22,7 @@ use context::SharedCrateContext;
 use session::Session;
 
 use llvm::{self, ValueRef};
-use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DILexicalBlock};
+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DILexicalBlock, DIFlags};
 
 use rustc::hir::def::CtorKind;
 use rustc::hir::def_id::DefId;
@@ -71,8 +71,6 @@ pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;
 // ptr::null() doesn't work :(
 pub const NO_SCOPE_METADATA: DIScope = (0 as DIScope);
 
-const FLAGS_NONE: c_uint = 0;
-
 #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]
 pub struct UniqueTypeId(ast::Name);
 
@@ -350,14 +348,14 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,
             llvm_type: member_llvm_types[0],
             type_metadata: element_type_metadata,
             offset: ComputedMemberOffset,
-            flags: FLAGS_NONE
+            flags: DIFlags::FlagZero,
         },
         MemberDescription {
             name: "length".to_string(),
             llvm_type: member_llvm_types[1],
             type_metadata: type_metadata(cx, cx.tcx().types.usize, span),
             offset: ComputedMemberOffset,
-            flags: FLAGS_NONE
+            flags: DIFlags::FlagZero,
         },
     ];
 
@@ -842,7 +840,7 @@ struct MemberDescription {
     llvm_type: Type,
     type_metadata: DIType,
     offset: MemberOffset,
-    flags: c_uint
+    flags: DIFlags,
 }
 
 // A factory for MemberDescriptions. It produces a list of member descriptions
@@ -926,7 +924,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {
                 llvm_type: type_of::type_of(cx, fty),
                 type_metadata: type_metadata(cx, fty, self.span),
                 offset: offset,
-                flags: FLAGS_NONE,
+                flags: DIFlags::FlagZero,
             }
         }).collect()
     }
@@ -991,7 +989,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {
                 llvm_type: type_of::type_of(cx, component_type),
                 type_metadata: type_metadata(cx, component_type, self.span),
                 offset: ComputedMemberOffset,
-                flags: FLAGS_NONE,
+                flags: DIFlags::FlagZero,
             }
         }).collect()
     }
@@ -1043,7 +1041,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {
                 llvm_type: type_of::type_of(cx, fty),
                 type_metadata: type_metadata(cx, fty, self.span),
                 offset: FixedMemberOffset { bytes: 0 },
-                flags: FLAGS_NONE,
+                flags: DIFlags::FlagZero,
             }
         }).collect()
     }
@@ -1141,7 +1139,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {
                             llvm_type: variant_llvm_type,
                             type_metadata: variant_type_metadata,
                             offset: FixedMemberOffset { bytes: 0 },
-                            flags: FLAGS_NONE
+                            flags: DIFlags::FlagZero
                         }
                     }).collect()
             },
@@ -1175,7 +1173,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {
                             llvm_type: variant_llvm_type,
                             type_metadata: variant_type_metadata,
                             offset: FixedMemberOffset { bytes: 0 },
-                            flags: FLAGS_NONE
+                            flags: DIFlags::FlagZero
                         }
                     ]
                 }
@@ -1212,7 +1210,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {
                     llvm_type: non_null_llvm_type,
                     type_metadata: non_null_type_metadata,
                     offset: FixedMemberOffset { bytes: 0 },
-                    flags: FLAGS_NONE
+                    flags: DIFlags::FlagZero
                 };
 
                 let unique_type_id = debug_context(cx).type_map
@@ -1249,7 +1247,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {
                         llvm_type: artificial_struct_llvm_type,
                         type_metadata: artificial_struct_metadata,
                         offset: FixedMemberOffset { bytes: 0 },
-                        flags: FLAGS_NONE
+                        flags: DIFlags::FlagZero
                     }
                 ]
             },
@@ -1293,7 +1291,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {
                         llvm_type: variant_llvm_type,
                         type_metadata: variant_type_metadata,
                         offset: FixedMemberOffset { bytes: 0 },
-                        flags: FLAGS_NONE
+                        flags: DIFlags::FlagZero
                     }
                 ]
             },
@@ -1322,7 +1320,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {
                     _ => type_metadata(cx, ty, self.span)
                 },
                 offset: ComputedMemberOffset,
-                flags: FLAGS_NONE
+                flags: DIFlags::FlagZero
             }
         }).collect()
     }
@@ -1542,7 +1540,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,
         UNKNOWN_LINE_NUMBER,
         bytes_to_bits(enum_type_size),
         bytes_to_bits(enum_type_align),
-        0, // Flags
+        DIFlags::FlagZero,
         ptr::null_mut(),
         0, // RuntimeLang
         unique_type_id_str.as_ptr())
@@ -1688,7 +1686,7 @@ fn create_struct_stub(cx: &CrateContext,
             UNKNOWN_LINE_NUMBER,
             bytes_to_bits(struct_size),
             bytes_to_bits(struct_align),
-            0,
+            DIFlags::FlagZero,
             ptr::null_mut(),
             empty_array,
             0,
@@ -1726,7 +1724,7 @@ fn create_union_stub(cx: &CrateContext,
             UNKNOWN_LINE_NUMBER,
             bytes_to_bits(union_size),
             bytes_to_bits(union_align),
-            0, // Flags
+            DIFlags::FlagZero,
             empty_array,
             0, // RuntimeLang
             unique_type_id.as_ptr())
diff --git a/src/librustc_trans/debuginfo/mod.rs b/src/librustc_trans/debuginfo/mod.rs
index 482275d..e023e65 100644
--- a/src/librustc_trans/debuginfo/mod.rs
+++ b/src/librustc_trans/debuginfo/mod.rs
@@ -22,8 +22,7 @@ use self::source_loc::InternalDebugLocation::{self, UnknownLocation};
 
 use llvm;
 use llvm::{ModuleRef, ContextRef, ValueRef};
-use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,
-                      FlagPrototyped};
+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};
 use rustc::hir::def_id::DefId;
 use rustc::ty::subst::Substs;
 
@@ -286,7 +285,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,
             is_local_to_unit,
             true,
             scope_line as c_uint,
-            FlagPrototyped as c_uint,
+            DIFlags::FlagPrototyped,
             cx.sess().opts.optimize != config::OptLevel::No,
             llfn,
             template_parameters,
@@ -478,7 +477,7 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
                     loc.line as c_uint,
                     type_metadata,
                     cx.sess().opts.optimize != config::OptLevel::No,
-                    0,
+                    DIFlags::FlagZero,
                     argument_index)
             };
             source_loc::set_debug_location(cx, None,
diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index 369388c..cf2b76a 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -332,6 +332,147 @@ DIT* unwrapDIptr(LLVMRustMetadataRef ref) {
 #define DIArray DINodeArray
 #define unwrapDI unwrapDIptr
 
+///// xxxx
+
+// Zero
+// Private
+// Protected
+// Public
+// FwdDecl
+// AppleBlock
+// BlockByrefStruct
+// Virtual
+// Artificial
+// Explicit
+// Prototyped
+// ObjcClassComplete
+// ObjectPointer
+// Vector
+// StaticMember
+// LValueReference
+// RValueReference
+// ExternalTypeRef
+// SingleInheritance
+// MultipleInheritance
+// VirtualInheritance
+// IntroducedVirtual
+// BitField
+// NoReturn
+
+// These values **must** match debuginfo::DIFlags! They also *happen*
+// to match LLVM, but that isn't required as we do giant sets of
+// matching below. The value shouldn't be directly passed to LLVM.
+enum class LLVMRustDIFlags : uint32_t {
+    FlagZero                = 0,
+    FlagPrivate             = 1,
+    FlagProtected           = 2,
+    FlagPublic              = 3,
+    FlagFwdDecl             = (1 << 2),
+    FlagAppleBlock          = (1 << 3),
+    FlagBlockByrefStruct    = (1 << 4),
+    FlagVirtual             = (1 << 5),
+    FlagArtificial          = (1 << 6),
+    FlagExplicit            = (1 << 7),
+    FlagPrototyped          = (1 << 8),
+    FlagObjcClassComplete   = (1 << 9),
+    FlagObjectPointer       = (1 << 10),
+    FlagVector              = (1 << 11),
+    FlagStaticMember        = (1 << 12),
+    FlagLValueReference     = (1 << 13),
+    FlagRValueReference     = (1 << 14),
+    FlagExternalTypeRef     = (1 << 15),
+    FlagSingleInheritance   = (1 << 16),
+    FlagMultipleInheritance = (2 << 16),
+    FlagVirtualInheritance  = (3 << 16),
+    FlagIntroducedVirtual   = (1 << 18),
+    FlagBitField            = (1 << 19),
+#if LLVM_VERSION_GE(4, 0)
+    FlagNoReturn            = (1 << 20),
+#endif
+};
+
+inline LLVMRustDIFlags operator& (LLVMRustDIFlags a, LLVMRustDIFlags b) {
+    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
+}
+
+inline LLVMRustDIFlags operator| (LLVMRustDIFlags a, LLVMRustDIFlags b) {
+    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
+}
+
+inline LLVMRustDIFlags& operator|= (LLVMRustDIFlags& a, LLVMRustDIFlags b) {
+    return a = a | b;
+}
+
+inline bool is_set(LLVMRustDIFlags f) {
+    return f != LLVMRustDIFlags::FlagZero;
+}
+
+// static LLVMRustDIFlags to_rust(unsigned flags) {
+//     LLVMRustDIFlags result = LLVMRustDIFlags::FlagZero;
+
+//     if (flags & DINode::DIFlags::FlagPrivate)             { result |= LLVMRustDIFlags::FlagPrivate; }
+//     if (flags & DINode::DIFlags::FlagProtected)           { result |= LLVMRustDIFlags::FlagProtected; }
+//     if (flags & DINode::DIFlags::FlagPublic)              { result |= LLVMRustDIFlags::FlagPublic; }
+//     if (flags & DINode::DIFlags::FlagFwdDecl)             { result |= LLVMRustDIFlags::FlagFwdDecl; }
+//     if (flags & DINode::DIFlags::FlagAppleBlock)          { result |= LLVMRustDIFlags::FlagAppleBlock; }
+//     if (flags & DINode::DIFlags::FlagBlockByrefStruct)    { result |= LLVMRustDIFlags::FlagBlockByrefStruct; }
+//     if (flags & DINode::DIFlags::FlagVirtual)             { result |= LLVMRustDIFlags::FlagVirtual; }
+//     if (flags & DINode::DIFlags::FlagArtificial)          { result |= LLVMRustDIFlags::FlagArtificial; }
+//     if (flags & DINode::DIFlags::FlagExplicit)            { result |= LLVMRustDIFlags::FlagExplicit; }
+//     if (flags & DINode::DIFlags::FlagPrototyped)          { result |= LLVMRustDIFlags::FlagPrototyped; }
+//     if (flags & DINode::DIFlags::FlagObjcClassComplete)   { result |= LLVMRustDIFlags::FlagObjcClassComplete; }
+//     if (flags & DINode::DIFlags::FlagObjectPointer)       { result |= LLVMRustDIFlags::FlagObjectPointer; }
+//     if (flags & DINode::DIFlags::FlagVector)              { result |= LLVMRustDIFlags::FlagVector; }
+//     if (flags & DINode::DIFlags::FlagStaticMember)        { result |= LLVMRustDIFlags::FlagStaticMember; }
+//     if (flags & DINode::DIFlags::FlagLValueReference)     { result |= LLVMRustDIFlags::FlagLValueReference; }
+//     if (flags & DINode::DIFlags::FlagRValueReference)     { result |= LLVMRustDIFlags::FlagRValueReference; }
+//     if (flags & DINode::DIFlags::FlagExternalTypeRef)     { result |= LLVMRustDIFlags::FlagExternalTypeRef; }
+//     if (flags & DINode::DIFlags::FlagSingleInheritance)   { result |= LLVMRustDIFlags::FlagSingleInheritance; }
+//     if (flags & DINode::DIFlags::FlagMultipleInheritance) { result |= LLVMRustDIFlags::FlagMultipleInheritance; }
+//     if (flags & DINode::DIFlags::FlagVirtualInheritance)  { result |= LLVMRustDIFlags::FlagVirtualInheritance; }
+//     if (flags & DINode::DIFlags::FlagIntroducedVirtual)   { result |= LLVMRustDIFlags::FlagIntroducedVirtual; }
+//     if (flags & DINode::DIFlags::FlagBitField)            { result |= LLVMRustDIFlags::FlagBitField; }
+// #if LLVM_VERSION_GE(4, 0)
+//     if (flags & DINode::DIFlags::FlagNoReturn)            { result |= LLVMRustDIFlags::FlagNoReturn; }
+// #endif
+
+//     return result;
+// }
+
+static unsigned from_rust(LLVMRustDIFlags flags) {
+    unsigned result = 0;
+
+    if (is_set(flags & LLVMRustDIFlags::FlagPrivate))             { result |= DINode::DIFlags::FlagPrivate; }
+    if (is_set(flags & LLVMRustDIFlags::FlagProtected))           { result |= DINode::DIFlags::FlagProtected; }
+    if (is_set(flags & LLVMRustDIFlags::FlagPublic))              { result |= DINode::DIFlags::FlagPublic; }
+    if (is_set(flags & LLVMRustDIFlags::FlagFwdDecl))             { result |= DINode::DIFlags::FlagFwdDecl; }
+    if (is_set(flags & LLVMRustDIFlags::FlagAppleBlock))          { result |= DINode::DIFlags::FlagAppleBlock; }
+    if (is_set(flags & LLVMRustDIFlags::FlagBlockByrefStruct))    { result |= DINode::DIFlags::FlagBlockByrefStruct; }
+    if (is_set(flags & LLVMRustDIFlags::FlagVirtual))             { result |= DINode::DIFlags::FlagVirtual; }
+    if (is_set(flags & LLVMRustDIFlags::FlagArtificial))          { result |= DINode::DIFlags::FlagArtificial; }
+    if (is_set(flags & LLVMRustDIFlags::FlagExplicit))            { result |= DINode::DIFlags::FlagExplicit; }
+    if (is_set(flags & LLVMRustDIFlags::FlagPrototyped))          { result |= DINode::DIFlags::FlagPrototyped; }
+    if (is_set(flags & LLVMRustDIFlags::FlagObjcClassComplete))   { result |= DINode::DIFlags::FlagObjcClassComplete; }
+    if (is_set(flags & LLVMRustDIFlags::FlagObjectPointer))       { result |= DINode::DIFlags::FlagObjectPointer; }
+    if (is_set(flags & LLVMRustDIFlags::FlagVector))              { result |= DINode::DIFlags::FlagVector; }
+    if (is_set(flags & LLVMRustDIFlags::FlagStaticMember))        { result |= DINode::DIFlags::FlagStaticMember; }
+    if (is_set(flags & LLVMRustDIFlags::FlagLValueReference))     { result |= DINode::DIFlags::FlagLValueReference; }
+    if (is_set(flags & LLVMRustDIFlags::FlagRValueReference))     { result |= DINode::DIFlags::FlagRValueReference; }
+    if (is_set(flags & LLVMRustDIFlags::FlagExternalTypeRef))     { result |= DINode::DIFlags::FlagExternalTypeRef; }
+    if (is_set(flags & LLVMRustDIFlags::FlagSingleInheritance))   { result |= DINode::DIFlags::FlagSingleInheritance; }
+    if (is_set(flags & LLVMRustDIFlags::FlagMultipleInheritance)) { result |= DINode::DIFlags::FlagMultipleInheritance; }
+    if (is_set(flags & LLVMRustDIFlags::FlagVirtualInheritance))  { result |= DINode::DIFlags::FlagVirtualInheritance; }
+    if (is_set(flags & LLVMRustDIFlags::FlagIntroducedVirtual))   { result |= DINode::DIFlags::FlagIntroducedVirtual; }
+    if (is_set(flags & LLVMRustDIFlags::FlagBitField))            { result |= DINode::DIFlags::FlagBitField; }
+#if LLVM_VERSION_GE(4, 0)
+    if (is_set(flags & LLVMRustDIFlags::FlagNoReturn))            { result |= DINode::DIFlags::FlagNoReturn; }
+#endif
+
+    return result;
+}
+
+//////// xxxx
+
 extern "C" uint32_t LLVMRustDebugMetadataVersion() {
     return DEBUG_METADATA_VERSION;
 }
@@ -411,7 +552,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(
     bool isLocalToUnit,
     bool isDefinition,
     unsigned ScopeLine,
-    unsigned Flags,
+    LLVMRustDIFlags Flags,
     bool isOptimized,
     LLVMValueRef Fn,
     LLVMRustMetadataRef TParam,
@@ -423,7 +564,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(
         unwrapDI<DIScope>(Scope), Name, LinkageName,
         unwrapDI<DIFile>(File), LineNo,
         unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,
-        Flags, isOptimized,
+        from_rust(Flags), isOptimized,
         TParams,
         unwrapDIptr<DISubprogram>(Decl));
     unwrap<Function>(Fn)->setSubprogram(Sub);
@@ -433,7 +574,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(
         unwrapDI<DIScope>(Scope), Name, LinkageName,
         unwrapDI<DIFile>(File), LineNo,
         unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,
-        Flags, isOptimized,
+        from_rust(Flags), isOptimized,
         unwrap<Function>(Fn),
         unwrapDIptr<MDNode>(TParam),
         unwrapDIptr<MDNode>(Decl)));
@@ -469,7 +610,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(
     unsigned LineNumber,
     uint64_t SizeInBits,
     uint64_t AlignInBits,
-    unsigned Flags,
+    LLVMRustDIFlags Flags,
     LLVMRustMetadataRef DerivedFrom,
     LLVMRustMetadataRef Elements,
     unsigned RunTimeLang,
@@ -482,7 +623,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(
         LineNumber,
         SizeInBits,
         AlignInBits,
-        Flags,
+        from_rust(Flags),
         unwrapDI<DIType>(DerivedFrom),
         DINodeArray(unwrapDI<MDTuple>(Elements)),
         RunTimeLang,
@@ -500,12 +641,12 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateMemberType(
     uint64_t SizeInBits,
     uint64_t AlignInBits,
     uint64_t OffsetInBits,
-    unsigned Flags,
+    LLVMRustDIFlags Flags,
     LLVMRustMetadataRef Ty) {
     return wrap(Builder->createMemberType(
         unwrapDI<DIDescriptor>(Scope), Name,
         unwrapDI<DIFile>(File), LineNo,
-        SizeInBits, AlignInBits, OffsetInBits, Flags,
+        SizeInBits, AlignInBits, OffsetInBits, from_rust(Flags),
         unwrapDI<DIType>(Ty)));
 }
 
@@ -561,7 +702,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(
     unsigned LineNo,
     LLVMRustMetadataRef Ty,
     bool AlwaysPreserve,
-    unsigned Flags,
+    LLVMRustDIFlags Flags,
     unsigned ArgNo) {
 #if LLVM_VERSION_GE(3, 8)
     if (Tag == 0x100) { // DW_TAG_auto_variable
@@ -569,20 +710,20 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(
             unwrapDI<DIDescriptor>(Scope), Name,
             unwrapDI<DIFile>(File),
             LineNo,
-            unwrapDI<DIType>(Ty), AlwaysPreserve, Flags));
+            unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));
     } else {
         return wrap(Builder->createParameterVariable(
             unwrapDI<DIDescriptor>(Scope), Name, ArgNo,
             unwrapDI<DIFile>(File),
             LineNo,
-            unwrapDI<DIType>(Ty), AlwaysPreserve, Flags));
+            unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));
     }
 #else
     return wrap(Builder->createLocalVariable(Tag,
         unwrapDI<DIDescriptor>(Scope), Name,
         unwrapDI<DIFile>(File),
         LineNo,
-        unwrapDI<DIType>(Ty), AlwaysPreserve, Flags, ArgNo));
+        unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags), ArgNo));
 #endif
 }
 
@@ -681,7 +822,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(
     unsigned LineNumber,
     uint64_t SizeInBits,
     uint64_t AlignInBits,
-    unsigned Flags,
+    LLVMRustDIFlags Flags,
     LLVMRustMetadataRef Elements,
     unsigned RunTimeLang,
     const char* UniqueId)
@@ -693,7 +834,7 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(
         LineNumber,
         SizeInBits,
         AlignInBits,
-        Flags,
+        from_rust(Flags),
         DINodeArray(unwrapDI<MDTuple>(Elements)),
         RunTimeLang,
         UniqueId

From 88689e22df5c02946fb7c79adb36ec14b4b8d971 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Fri, 18 Nov 2016 11:11:38 -0500
Subject: [PATCH 03/18] [4.0][Lost Functionality] DI Metadata can no longer be
 cast like this

---
 src/rustllvm/RustWrapper.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index cf2b76a..193250c 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -689,7 +689,12 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(
         LineNo,
         unwrapDI<DIType>(Ty),
         isLocalToUnit,
+#if LLVM_VERSION_GE(4,0)
+        // unwrapDI<DIExpression>((LLVMRustMetadataRef) Val),
+                                              nullptr, // TODO: LOST usefulness
+#else
         cast<Constant>(unwrap(Val)),
+#endif
         unwrapDIptr<MDNode>(Decl)));
 }
 

From 0a4053f58159044ecc56f6b4056e142a81888f4b Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Sat, 24 Sep 2016 12:37:04 -0400
Subject: [PATCH 04/18] [4.0] Update always inline pass location and
 constructor

---
 src/rustllvm/PassWrapper.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/rustllvm/PassWrapper.cpp b/src/rustllvm/PassWrapper.cpp
index 85e48f0..dd54343 100644
--- a/src/rustllvm/PassWrapper.cpp
+++ b/src/rustllvm/PassWrapper.cpp
@@ -22,6 +22,9 @@
 #include "llvm/Target/TargetSubtargetInfo.h"
 #include "llvm/Transforms/IPO/PassManagerBuilder.h"
 
+#if LLVM_VERSION_GE(4, 0)
+#include "llvm/Transforms/IPO/AlwaysInliner.h"
+#endif
 
 #include "llvm-c/Transforms/PassManagerBuilder.h"
 
@@ -546,7 +549,11 @@ LLVMRustPrintPasses() {
 
 extern "C" void
 LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {
+#if LLVM_VERSION_GE(4, 0)
+    unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);
+#else
     unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);
+#endif
 }
 
 extern "C" void

From 0a65fe963342605aa0602267422f872f982d9fab Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Sun, 25 Sep 2016 10:08:23 -0400
Subject: [PATCH 05/18] [4.0] Handle new error reporting styles

---
 src/rustllvm/ArchiveWrapper.cpp | 32 ++++++++++++++++++++++++--------
 1 file changed, 24 insertions(+), 8 deletions(-)

diff --git a/src/rustllvm/ArchiveWrapper.cpp b/src/rustllvm/ArchiveWrapper.cpp
index 12cd81e..af92ab4 100644
--- a/src/rustllvm/ArchiveWrapper.cpp
+++ b/src/rustllvm/ArchiveWrapper.cpp
@@ -36,7 +36,6 @@ struct RustArchiveIterator {
     Archive::child_iterator cur;
     Archive::child_iterator end;
 #if LLVM_VERSION_GE(3, 9)
-    Error err;
 #endif
 };
 
@@ -115,9 +114,11 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {
 #if LLVM_VERSION_LE(3, 8)
     rai->cur = ar->child_begin();
 #else
-    rai->cur = ar->child_begin(rai->err);
-    if (rai->err) {
-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());
+    Error err = Error::success();
+
+    rai->cur = ar->child_begin(err);
+    if (err) {
+        LLVMRustSetLastError(toString(std::move(err)).c_str());
         return NULL;
     }
 #endif
@@ -128,8 +129,10 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {
 extern "C" LLVMRustArchiveChildConstRef
 LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {
 #if LLVM_VERSION_GE(3, 9)
-    if (rai->err) {
-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());
+    Error err = Error::success();
+
+    if (err) {
+        LLVMRustSetLastError(toString(std::move(err)).c_str());
         return NULL;
     }
 #endif
@@ -163,9 +166,10 @@ LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {
 
 extern "C" const char*
 LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {
-    ErrorOr<StringRef> name_or_err = child->getName();
-    if (name_or_err.getError())
+    Expected<StringRef> name_or_err = child->getName();
+    if (!name_or_err)
         return NULL;
+
     StringRef name = name_or_err.get();
     *size = name.size();
     return name.data();
@@ -174,12 +178,24 @@ LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {
 extern "C" const char*
 LLVMRustArchiveChildData(LLVMRustArchiveChildRef child, size_t *size) {
     StringRef buf;
+#if LLVM_VERSION_GE(4, 0)
+    Expected<StringRef> buf_or_err = child->getBuffer();
+
+    if (!buf_or_err) {
+      LLVMRustSetLastError(toString(buf_or_err.takeError()).c_str());
+      return NULL;
+    }
+
+    buf = buf_or_err.get();
+#else
     ErrorOr<StringRef> buf_or_err = child->getBuffer();
     if (buf_or_err.getError()) {
       LLVMRustSetLastError(buf_or_err.getError().message().c_str());
       return NULL;
     }
+#endif
     buf = buf_or_err.get();
+
     *size = buf.size();
     return buf.data();
 }

From 5ad5ba6aa5e266d40da67c0e1a9596239874a4d9 Mon Sep 17 00:00:00 2001
From: Dylan McKay <dylanmckay34@gmail.com>
Date: Sun, 2 Oct 2016 02:04:42 +1300
Subject: [PATCH 06/18] [4.0] Set EH personality when resuming stack unwinding

To resume stack unwinding, the LLVM `resume` instruction must be used.

In order to use this instruction, the calling function must have an
exception handling personality set.

LLVM 4.0 adds a new IR validation check to ensure a personality is
always set in these cases.

This was introduced in [r277360](https://reviews.llvm.org/rL277360).
---
 src/librustc_trans/mir/block.rs | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/librustc_trans/mir/block.rs b/src/librustc_trans/mir/block.rs
index b22bcf9..dd58ca5 100644
--- a/src/librustc_trans/mir/block.rs
+++ b/src/librustc_trans/mir/block.rs
@@ -116,6 +116,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {
                 if let Some(cleanup_pad) = cleanup_pad {
                     bcx.cleanup_ret(cleanup_pad, None);
                 } else {
+                    let llpersonality = bcx.fcx().eh_personality();
+                    bcx.set_personality_fn(llpersonality);
+
                     let ps = self.get_personality_slot(&bcx);
                     let lp = bcx.load(ps);
                     bcx.with_block(|bcx| {

From c5622365fb6e8db61360efc1c9162c2a72ffc37c Mon Sep 17 00:00:00 2001
From: Dylan McKay <dylanmckay34@gmail.com>
Date: Thu, 6 Oct 2016 21:10:09 +1300
Subject: [PATCH 07/18] [4.0] Convert a bunch of strings to char buffers

LLVM 4.0 makes these std::string objects.
---
 src/librustc_llvm/diagnostic.rs  | 2 +-
 src/librustc_llvm/ffi.rs         | 2 +-
 src/librustc_trans/back/write.rs | 6 ++++--
 src/rustllvm/PassWrapper.cpp     | 6 +++---
 src/rustllvm/RustWrapper.cpp     | 6 +++---
 5 files changed, 12 insertions(+), 10 deletions(-)

diff --git a/src/librustc_llvm/diagnostic.rs b/src/librustc_llvm/diagnostic.rs
index 8767f03..c11b64e 100644
--- a/src/librustc_llvm/diagnostic.rs
+++ b/src/librustc_llvm/diagnostic.rs
@@ -48,7 +48,7 @@ pub struct OptimizationDiagnostic {
     pub pass_name: *const c_char,
     pub function: ValueRef,
     pub debug_loc: DebugLocRef,
-    pub message: TwineRef,
+    pub message: *const c_char,
 }
 
 impl OptimizationDiagnostic {
diff --git a/src/librustc_llvm/ffi.rs b/src/librustc_llvm/ffi.rs
index b3a4271..3fabc77 100644
--- a/src/librustc_llvm/ffi.rs
+++ b/src/librustc_llvm/ffi.rs
@@ -1870,7 +1870,7 @@ extern "C" {
                                                 pass_name_out: *mut *const c_char,
                                                 function_out: *mut ValueRef,
                                                 debugloc_out: *mut DebugLocRef,
-                                                message_out: *mut TwineRef);
+                                                message_out: *mut *const c_char);
     pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,
                                              cookie_out: *mut c_uint,
                                              message_out: *mut TwineRef,
diff --git a/src/librustc_trans/back/write.rs b/src/librustc_trans/back/write.rs
index 01eea08..751ae61 100644
--- a/src/librustc_trans/back/write.rs
+++ b/src/librustc_trans/back/write.rs
@@ -404,8 +404,10 @@ unsafe extern "C" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo
 
         llvm::diagnostic::Optimization(opt) => {
             let pass_name = str::from_utf8(CStr::from_ptr(opt.pass_name).to_bytes())
-                                .ok()
                                 .expect("got a non-UTF8 pass name from LLVM");
+            let message = str::from_utf8(CStr::from_ptr(opt.message).to_bytes())
+                              .expect("got a non-UTF8 message from LLVM");
+
             let enabled = match cgcx.remark {
                 AllPasses => true,
                 SomePasses(ref v) => v.iter().any(|s| *s == pass_name),
@@ -417,7 +419,7 @@ unsafe extern "C" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo
                                                 opt.kind.describe(),
                                                 pass_name,
                                                 if loc.is_empty() { "[unknown]" } else { &*loc },
-                                                llvm::twine_to_string(opt.message)));
+                                                message));
             }
         }
 
diff --git a/src/rustllvm/PassWrapper.cpp b/src/rustllvm/PassWrapper.cpp
index dd54343..6b8bc72 100644
--- a/src/rustllvm/PassWrapper.cpp
+++ b/src/rustllvm/PassWrapper.cpp
@@ -536,9 +536,9 @@ LLVMRustPrintPasses() {
     LLVMInitializePasses();
     struct MyListener : PassRegistrationListener {
         void passEnumerate(const PassInfo *info) {
-            if (info->getPassArgument() && *info->getPassArgument()) {
-                printf("%15s - %s\n", info->getPassArgument(),
-                       info->getPassName());
+            if (!info->getPassArgument().empty()) {
+                printf("%15s - %s\n", info->getPassArgument().data(),
+                       info->getPassName().data());
             }
         }
     } listener;
diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index 193250c..6f418c9 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -997,16 +997,16 @@ LLVMRustUnpackOptimizationDiagnostic(
     const char **pass_name_out,
     LLVMValueRef *function_out,
     LLVMDebugLocRef *debugloc_out,
-    LLVMTwineRef *message_out)
+    const char **message_out)
 {
     // Undefined to call this not on an optimization diagnostic!
     llvm::DiagnosticInfoOptimizationBase *opt
         = static_cast<llvm::DiagnosticInfoOptimizationBase*>(unwrap(di));
 
-    *pass_name_out = opt->getPassName();
+    *pass_name_out = opt->getPassName().data();
     *function_out = wrap(&opt->getFunction());
     *debugloc_out = wrap(&opt->getDebugLoc());
-    *message_out = wrap(&opt->getMsg());
+    *message_out = opt->getMsg().data();
 }
 
 extern "C" void

From b1df5f890c8afecf153921d7e1d458b194f5882c Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Thu, 17 Nov 2016 09:10:01 -0500
Subject: [PATCH 08/18] [LLVM 4.0] Pass new argument to CreateNameSpace

Debugging support for C++11 inline namespaces doesn't seem like
something we need to enable.
---
 src/rustllvm/RustWrapper.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index 6f418c9..4338860 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -873,7 +873,12 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateNameSpace(
         unwrapDI<DIDescriptor>(Scope),
         Name,
         unwrapDI<DIFile>(File),
-        LineNo));
+        LineNo
+#if LLVM_VERSION_GE(4, 0)
+        ,
+        false
+#endif
+    ));
 }
 
 extern "C" void LLVMRustDICompositeTypeSetTypeArray(

From 0aed62296800637465b664a59b2442f1961f8157 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Thu, 17 Nov 2016 09:10:19 -0500
Subject: [PATCH 09/18] [LLVM 4.0] New bitcode headers and API

---
 src/rustllvm/RustWrapper.cpp | 18 +++++++++++++++++-
 src/rustllvm/rustllvm.h      |  8 +++++++-
 2 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index 4338860..c6b9e56 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -934,19 +934,35 @@ extern "C" void LLVMRustWriteValueToString(LLVMValueRef Value, RustStringRef str
 extern "C" bool
 LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {
     Module *Dst = unwrap(dst);
+
     std::unique_ptr<MemoryBuffer> buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));
+
+#if LLVM_VERSION_GE(4, 0)
+    // can avoid copy at all?
+    Expected<std::unique_ptr<Module>> SrcOrError =
+        llvm::getLazyBitcodeModule(buf->getMemBufferRef(), Dst->getContext());
+    if (!SrcOrError) {
+        LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());
+        return false;
+    }
+
+    auto Src = std::move(*SrcOrError);
+#else
     ErrorOr<std::unique_ptr<Module>> Src =
         llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());
     if (!Src) {
         LLVMRustSetLastError(Src.getError().message().c_str());
         return false;
     }
+#endif
 
     std::string Err;
 
     raw_string_ostream Stream(Err);
     DiagnosticPrinterRawOStream DP(Stream);
-#if LLVM_VERSION_GE(3, 8)
+#if LLVM_VERSION_GE(4, 0)
+    if (Linker::linkModules(*Dst, std::move(Src))) {
+#elif LLVM_VERSION_GE(3, 8)
     if (Linker::linkModules(*Dst, std::move(Src.get()))) {
 #else
     if (Linker::LinkModules(Dst, Src->get(), [&](const DiagnosticInfo &DI) { DI.print(DP); })) {
diff --git a/src/rustllvm/rustllvm.h b/src/rustllvm/rustllvm.h
index ffe94d1..26b231c 100644
--- a/src/rustllvm/rustllvm.h
+++ b/src/rustllvm/rustllvm.h
@@ -39,7 +39,6 @@
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/Instrumentation.h"
 #include "llvm/Transforms/Vectorize.h"
-#include "llvm/Bitcode/ReaderWriter.h"
 #include "llvm-c/Core.h"
 #include "llvm-c/BitReader.h"
 #include "llvm-c/ExecutionEngine.h"
@@ -60,6 +59,13 @@
 #include "llvm/PassManager.h"
 #endif
 
+#if LLVM_VERSION_GE(4, 0)
+#include "llvm/Bitcode/BitcodeReader.h"
+#include "llvm/Bitcode/BitcodeWriter.h"
+#else
+#include "llvm/Bitcode/ReaderWriter.h"
+#endif
+
 #include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/IR/DebugInfo.h"
 #include "llvm/IR/DIBuilder.h"

From d4275750ee91ba6acf4a0535bb88ef8c7d959862 Mon Sep 17 00:00:00 2001
From: Robin Kruppe <robin.kruppe@gmail.com>
Date: Wed, 16 Nov 2016 23:34:15 +0100
Subject: [PATCH 10/18] Rebuild rustc_llvm when the rustllvm source files
 change

---
 src/librustc_llvm/build.rs | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/librustc_llvm/build.rs b/src/librustc_llvm/build.rs
index 5ebeb4f..c455d81 100644
--- a/src/librustc_llvm/build.rs
+++ b/src/librustc_llvm/build.rs
@@ -118,6 +118,9 @@ fn main() {
 
     cfg.flag("-g");
 
+    println!("cargo:rerun-if-changed=../rustllvm/PassWrapper.cpp");
+    println!("cargo:rerun-if-changed=../rustllvm/RustWrapper.cpp");
+    println!("cargo:rerun-if-changed=../rustllvm/ArchiveWrapper.cpp");
     cfg.file("../rustllvm/PassWrapper.cpp")
        .file("../rustllvm/RustWrapper.cpp")
        .file("../rustllvm/ArchiveWrapper.cpp")

From c0d38b638cbed4128861cae2fa0c0b4e224bee0f Mon Sep 17 00:00:00 2001
From: Robin Kruppe <robin.kruppe@gmail.com>
Date: Wed, 16 Nov 2016 23:36:08 +0100
Subject: [PATCH 11/18] Use llvm::Attribute API instead of "raw value" APIs,
 which will be removed in LLVM 4.0.

The librustc_llvm API remains mostly unchanged, except that llvm::Attribute is no longer a bitflag but represents only a *single* attribute.
The ability to store many attributes in a small number of bits and modify them without interacting with LLVM is only used in rustc_trans::abi and closely related modules, and only attributes for function arguments are considered there.
Thus rustc_trans::abi now has its own bit-packed representation of argument attributes, which are translated to rustc_llvm::Attribute when applying the attributes.
---
 src/librustc_llvm/Cargo.toml      |   3 -
 src/librustc_llvm/ffi.rs          | 101 ++++++++++++-------------------
 src/librustc_llvm/lib.rs          |  63 +++----------------
 src/librustc_trans/Cargo.toml     |   1 +
 src/librustc_trans/abi.rs         | 123 ++++++++++++++++++++++++++++++++------
 src/librustc_trans/attributes.rs  |   7 +--
 src/librustc_trans/cabi_asmjs.rs  |   6 +-
 src/librustc_trans/cabi_x86.rs    |   4 +-
 src/librustc_trans/cabi_x86_64.rs |   8 +--
 src/librustc_trans/lib.rs         |   4 ++
 src/rustllvm/RustWrapper.cpp      | 115 +++++++++++++++++++++--------------
 src/rustllvm/rustllvm.h           |  22 +++++++
 13 files changed, 261 insertions(+), 198 deletions(-)

diff --git a/src/librustc_llvm/Cargo.toml b/src/librustc_llvm/Cargo.toml
index f97daa2..88f8c05 100644
--- a/src/librustc_llvm/Cargo.toml
+++ b/src/librustc_llvm/Cargo.toml
@@ -12,9 +12,6 @@ crate-type = ["dylib"]
 [features]
 static-libstdcpp = []
 
-[dependencies]
-rustc_bitflags = { path = "../librustc_bitflags" }
-
 [build-dependencies]
 build_helper = { path = "../build_helper" }
 gcc = "0.3.27"
diff --git a/src/librustc_llvm/ffi.rs b/src/librustc_llvm/ffi.rs
index 3fabc77..495fdcd 100644
--- a/src/librustc_llvm/ffi.rs
+++ b/src/librustc_llvm/ffi.rs
@@ -84,59 +84,31 @@ pub enum DLLStorageClass {
     DllExport = 2, // Function to be accessible from DLL.
 }
 
-bitflags! {
-    #[derive(Default, Debug)]
-    flags Attribute : u64 {
-        const ZExt            = 1 << 0,
-        const SExt            = 1 << 1,
-        const NoReturn        = 1 << 2,
-        const InReg           = 1 << 3,
-        const StructRet       = 1 << 4,
-        const NoUnwind        = 1 << 5,
-        const NoAlias         = 1 << 6,
-        const ByVal           = 1 << 7,
-        const Nest            = 1 << 8,
-        const ReadNone        = 1 << 9,
-        const ReadOnly        = 1 << 10,
-        const NoInline        = 1 << 11,
-        const AlwaysInline    = 1 << 12,
-        const OptimizeForSize = 1 << 13,
-        const StackProtect    = 1 << 14,
-        const StackProtectReq = 1 << 15,
-        const NoCapture       = 1 << 21,
-        const NoRedZone       = 1 << 22,
-        const NoImplicitFloat = 1 << 23,
-        const Naked           = 1 << 24,
-        const InlineHint      = 1 << 25,
-        const ReturnsTwice    = 1 << 29,
-        const UWTable         = 1 << 30,
-        const NonLazyBind     = 1 << 31,
-
-        // Some of these are missing from the LLVM C API, the rest are
-        // present, but commented out, and preceded by the following warning:
-        // FIXME: These attributes are currently not included in the C API as
-        // a temporary measure until the API/ABI impact to the C API is understood
-        // and the path forward agreed upon.
-        const SanitizeAddress = 1 << 32,
-        const MinSize         = 1 << 33,
-        const NoDuplicate     = 1 << 34,
-        const StackProtectStrong = 1 << 35,
-        const SanitizeThread  = 1 << 36,
-        const SanitizeMemory  = 1 << 37,
-        const NoBuiltin       = 1 << 38,
-        const Returned        = 1 << 39,
-        const Cold            = 1 << 40,
-        const Builtin         = 1 << 41,
-        const OptimizeNone    = 1 << 42,
-        const InAlloca        = 1 << 43,
-        const NonNull         = 1 << 44,
-        const JumpTable       = 1 << 45,
-        const Convergent      = 1 << 46,
-        const SafeStack       = 1 << 47,
-        const NoRecurse       = 1 << 48,
-        const InaccessibleMemOnly         = 1 << 49,
-        const InaccessibleMemOrArgMemOnly = 1 << 50,
-    }
+/// Matches LLVMRustAttribute in rustllvm.h
+/// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,
+/// though it is not ABI compatible (since it's a C++ enum)
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+pub enum Attribute {
+    AlwaysInline    = 0,
+    ByVal           = 1,
+    Cold            = 2,
+    InlineHint      = 3,
+    MinSize         = 4,
+    Naked           = 5,
+    NoAlias         = 6,
+    NoCapture       = 7,
+    NoInline        = 8,
+    NonNull         = 9,
+    NoRedZone       = 10,
+    NoReturn        = 11,
+    NoUnwind        = 12,
+    OptimizeForSize = 13,
+    ReadOnly        = 14,
+    SExt            = 15,
+    StructRet       = 16,
+    UWTable         = 17,
+    ZExt            = 18,
 }
 
 /// LLVMIntPredicate
@@ -424,6 +396,9 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;
 #[allow(missing_copy_implementations)]
 pub enum OperandBundleDef_opaque {}
 pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;
+#[allow(missing_copy_implementations)]
+pub enum Attribute_opaque {}
+pub type AttributeRef = *mut Attribute_opaque;
 
 pub type DiagnosticHandler = unsafe extern "C" fn(DiagnosticInfoRef, *mut c_void);
 pub type InlineAsmDiagHandler = unsafe extern "C" fn(SMDiagnosticRef, *const c_void, c_uint);
@@ -545,6 +520,9 @@ extern "C" {
     /// See llvm::LLVMType::getContext.
     pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;
 
+    /// See llvm::Value::getContext
+    pub fn LLVMRustGetValueContext(V: ValueRef) -> ContextRef;
+
     // Operations on integer types
     pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;
     pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;
@@ -807,6 +785,8 @@ extern "C" {
                         Name: *const c_char)
                         -> ValueRef;
 
+    pub fn LLVMRustCreateAttribute(C: ContextRef, kind: Attribute, val: u64) -> AttributeRef;
+
     // Operations on functions
     pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;
     pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;
@@ -825,16 +805,12 @@ extern "C" {
     pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;
     pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);
     pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);
-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: u64);
-    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);
+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: AttributeRef);
     pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,
                                               index: c_uint,
                                               Name: *const c_char,
                                               Value: *const c_char);
-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: u64);
-    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);
-    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;
-    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);
+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: AttributeRef);
 
     // Operations on parameters
     pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;
@@ -845,9 +821,8 @@ extern "C" {
     pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;
     pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;
     pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;
-    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);
-    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);
-    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;
+    pub fn LLVMAddAttribute(Arg: ValueRef, attr: AttributeRef);
+    pub fn LLVMRemoveAttribute(Arg: ValueRef, attr: AttributeRef);
     pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);
 
     // Operations on basic blocks
@@ -891,7 +866,7 @@ extern "C" {
     pub fn LLVMAddInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);
     pub fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);
     pub fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint, align: c_uint);
-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, Val: u64);
+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: AttributeRef);
     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);
 
     // Operations on call instructions (only)
diff --git a/src/librustc_llvm/lib.rs b/src/librustc_llvm/lib.rs
index 49a8045..3f41b82 100644
--- a/src/librustc_llvm/lib.rs
+++ b/src/librustc_llvm/lib.rs
@@ -32,9 +32,6 @@
 #![cfg_attr(not(stage0), feature(rustc_private))]
 
 extern crate libc;
-#[macro_use]
-#[no_link]
-extern crate rustc_bitflags;
 
 pub use self::IntPredicate::*;
 pub use self::RealPredicate::*;
@@ -68,54 +65,6 @@ impl LLVMRustResult {
     }
 }
 
-#[derive(Copy, Clone, Default, Debug)]
-pub struct Attributes {
-    regular: Attribute,
-    dereferenceable_bytes: u64,
-}
-
-impl Attributes {
-    pub fn set(&mut self, attr: Attribute) -> &mut Self {
-        self.regular = self.regular | attr;
-        self
-    }
-
-    pub fn unset(&mut self, attr: Attribute) -> &mut Self {
-        self.regular = self.regular - attr;
-        self
-    }
-
-    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {
-        self.dereferenceable_bytes = bytes;
-        self
-    }
-
-    pub fn unset_dereferenceable(&mut self) -> &mut Self {
-        self.dereferenceable_bytes = 0;
-        self
-    }
-
-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {
-        unsafe {
-            self.regular.apply_llfn(idx, llfn);
-            if self.dereferenceable_bytes != 0 {
-                LLVMRustAddDereferenceableAttr(llfn, idx.as_uint(), self.dereferenceable_bytes);
-            }
-        }
-    }
-
-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {
-        unsafe {
-            self.regular.apply_callsite(idx, callsite);
-            if self.dereferenceable_bytes != 0 {
-                LLVMRustAddDereferenceableCallSiteAttr(callsite,
-                                                       idx.as_uint(),
-                                                       self.dereferenceable_bytes);
-            }
-        }
-    }
-}
-
 pub fn AddFunctionAttrStringValue(llfn: ValueRef,
                                   idx: AttributePlace,
                                   attr: &'static str,
@@ -140,7 +89,7 @@ impl AttributePlace {
         AttributePlace::Argument(0)
     }
 
-    fn as_uint(self) -> c_uint {
+    pub fn as_uint(self) -> c_uint {
         match self {
             AttributePlace::Function => !0,
             AttributePlace::Argument(i) => i,
@@ -228,16 +177,20 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {
 }
 
 impl Attribute {
+    fn as_object(&self, value: ValueRef) -> AttributeRef {
+        unsafe { LLVMRustCreateAttribute(LLVMRustGetValueContext(value), *self, 0) }
+    }
+
     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {
-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.bits()) }
+        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.as_object(llfn)) }
     }
 
     pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {
-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.bits()) }
+        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.as_object(callsite)) }
     }
 
     pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {
-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.bits()) }
+        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.as_object(llfn)) }
     }
 
     pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {
diff --git a/src/librustc_trans/Cargo.toml b/src/librustc_trans/Cargo.toml
index 38f9e7a..796a80d 100644
--- a/src/librustc_trans/Cargo.toml
+++ b/src/librustc_trans/Cargo.toml
@@ -16,6 +16,7 @@ graphviz = { path = "../libgraphviz" }
 log = { path = "../liblog" }
 rustc = { path = "../librustc" }
 rustc_back = { path = "../librustc_back" }
+rustc_bitflags = { path = "../librustc_bitflags" }
 rustc_const_eval = { path = "../librustc_const_eval" }
 rustc_const_math = { path = "../librustc_const_math" }
 rustc_data_structures = { path = "../librustc_data_structures" }
diff --git a/src/librustc_trans/abi.rs b/src/librustc_trans/abi.rs
index e884ec0..e488b43 100644
--- a/src/librustc_trans/abi.rs
+++ b/src/librustc_trans/abi.rs
@@ -8,7 +8,7 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
-use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector};
+use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};
 use base;
 use build::AllocaFcx;
 use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};
@@ -51,6 +51,93 @@ enum ArgKind {
     Ignore,
 }
 
+// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest
+// of this module
+pub use self::attr_impl::ArgAttribute;
+
+#[allow(non_upper_case_globals)]
+mod attr_impl {
+    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.
+    bitflags! {
+        #[derive(Default, Debug)]
+        flags ArgAttribute : u8 {
+            const ByVal     = 1 << 0,
+            const NoAlias   = 1 << 1,
+            const NoCapture = 1 << 2,
+            const NonNull   = 1 << 3,
+            const ReadOnly  = 1 << 4,
+            const SExt      = 1 << 5,
+            const StructRet = 1 << 6,
+            const ZExt      = 1 << 7,
+        }
+    }
+}
+
+macro_rules! for_each_kind {
+    ($flags: ident, $f: ident, $($kind: ident),+) => ({
+        $(if $flags.contains(ArgAttribute::$kind) { $f(llvm::Attribute::$kind) })+
+    })
+}
+
+impl ArgAttribute {
+    fn for_each_kind<F>(&self, mut f: F) where F: FnMut(llvm::Attribute) {
+        for_each_kind!(self, f,
+                       ByVal, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt)
+    }
+}
+
+/// A compact representation of LLVM attributes (at least those relevant for this module)
+/// that can be manipulated without interacting with LLVM's Attribute machinery.
+#[derive(Copy, Clone, Debug, Default)]
+pub struct ArgAttributes {
+    regular: ArgAttribute,
+    dereferenceable_bytes: u64,
+}
+
+impl ArgAttributes {
+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {
+        self.regular = self.regular | attr;
+        self
+    }
+
+    pub fn unset(&mut self, attr: ArgAttribute) -> &mut Self {
+        self.regular = self.regular - attr;
+        self
+    }
+
+    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {
+        self.dereferenceable_bytes = bytes;
+        self
+    }
+
+    pub fn unset_dereferenceable(&mut self) -> &mut Self {
+        self.dereferenceable_bytes = 0;
+        self
+    }
+
+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {
+        unsafe {
+            self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));
+            if self.dereferenceable_bytes != 0 {
+                llvm::LLVMRustAddDereferenceableAttr(llfn,
+                                                     idx.as_uint(),
+                                                     self.dereferenceable_bytes);
+            }
+        }
+    }
+
+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {
+        unsafe {
+            self.regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));
+            if self.dereferenceable_bytes != 0 {
+                llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,
+                                                             idx.as_uint(),
+                                                             self.dereferenceable_bytes);
+            }
+        }
+    }
+}
+
 /// Information about how a specific C type
 /// should be passed to or returned from a function
 ///
@@ -82,7 +169,7 @@ pub struct ArgType {
     /// Dummy argument, which is emitted before the real argument
     pub pad: Option<Type>,
     /// LLVM attributes of argument
-    pub attrs: llvm::Attributes
+    pub attrs: ArgAttributes
 }
 
 impl ArgType {
@@ -94,7 +181,7 @@ impl ArgType {
             signedness: None,
             cast: None,
             pad: None,
-            attrs: llvm::Attributes::default()
+            attrs: ArgAttributes::default()
         }
     }
 
@@ -102,15 +189,15 @@ impl ArgType {
         assert_eq!(self.kind, ArgKind::Direct);
 
         // Wipe old attributes, likely not valid through indirection.
-        self.attrs = llvm::Attributes::default();
+        self.attrs = ArgAttributes::default();
 
         let llarg_sz = llsize_of_alloc(ccx, self.ty);
 
         // For non-immediate arguments the callee gets its own copy of
         // the value on the stack, so there are no aliases. It's also
         // program-invisible so can't possibly capture
-        self.attrs.set(llvm::Attribute::NoAlias)
-                  .set(llvm::Attribute::NoCapture)
+        self.attrs.set(ArgAttribute::NoAlias)
+                  .set(ArgAttribute::NoCapture)
                   .set_dereferenceable(llarg_sz);
 
         self.kind = ArgKind::Indirect;
@@ -126,9 +213,9 @@ impl ArgType {
         if let Some(signed) = self.signedness {
             if self.ty.int_width() < bits {
                 self.attrs.set(if signed {
-                    llvm::Attribute::SExt
+                    ArgAttribute::SExt
                 } else {
-                    llvm::Attribute::ZExt
+                    ArgAttribute::ZExt
                 });
             }
         }
@@ -318,7 +405,7 @@ impl FnType {
             if ty.is_bool() {
                 let llty = Type::i1(ccx);
                 let mut arg = ArgType::new(llty, llty);
-                arg.attrs.set(llvm::Attribute::ZExt);
+                arg.attrs.set(ArgAttribute::ZExt);
                 arg
             } else {
                 let mut arg = ArgType::new(type_of::type_of(ccx, ty),
@@ -353,7 +440,7 @@ impl FnType {
             if let ty::TyBox(_) = ret_ty.sty {
                 // `Box` pointer return values never alias because ownership
                 // is transferred
-                ret.attrs.set(llvm::Attribute::NoAlias);
+                ret.attrs.set(ArgAttribute::NoAlias);
             }
 
             // We can also mark the return value as `dereferenceable` in certain cases
@@ -375,7 +462,7 @@ impl FnType {
         let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {
             // `Box` pointer parameters never alias because ownership is transferred
             ty::TyBox(inner) => {
-                arg.attrs.set(llvm::Attribute::NoAlias);
+                arg.attrs.set(ArgAttribute::NoAlias);
                 Some(inner)
             }
 
@@ -390,18 +477,18 @@ impl FnType {
                 let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();
 
                 if mt.mutbl != hir::MutMutable && !interior_unsafe {
-                    arg.attrs.set(llvm::Attribute::NoAlias);
+                    arg.attrs.set(ArgAttribute::NoAlias);
                 }
 
                 if mt.mutbl == hir::MutImmutable && !interior_unsafe {
-                    arg.attrs.set(llvm::Attribute::ReadOnly);
+                    arg.attrs.set(ArgAttribute::ReadOnly);
                 }
 
                 // When a reference in an argument has no named lifetime, it's
                 // impossible for that reference to escape this function
                 // (returned or stored beyond the call by a closure).
                 if let ReLateBound(_, BrAnon(_)) = *b {
-                    arg.attrs.set(llvm::Attribute::NoCapture);
+                    arg.attrs.set(ArgAttribute::NoCapture);
                 }
 
                 Some(mt.ty)
@@ -421,9 +508,9 @@ impl FnType {
                 let mut info = ArgType::new(original_tys[1], sizing_tys[1]);
 
                 if let Some(inner) = rust_ptr_attrs(ty, &mut data) {
-                    data.attrs.set(llvm::Attribute::NonNull);
+                    data.attrs.set(ArgAttribute::NonNull);
                     if ccx.tcx().struct_tail(inner).is_trait() {
-                        info.attrs.set(llvm::Attribute::NonNull);
+                        info.attrs.set(ArgAttribute::NonNull);
                     }
                 }
                 args.push(data);
@@ -494,7 +581,7 @@ impl FnType {
                 fixup(arg);
             }
             if self.ret.is_indirect() {
-                self.ret.attrs.set(llvm::Attribute::StructRet);
+                self.ret.attrs.set(ArgAttribute::StructRet);
             }
             return;
         }
@@ -530,7 +617,7 @@ impl FnType {
         }
 
         if self.ret.is_indirect() {
-            self.ret.attrs.set(llvm::Attribute::StructRet);
+            self.ret.attrs.set(ArgAttribute::StructRet);
         }
     }
 
diff --git a/src/librustc_trans/attributes.rs b/src/librustc_trans/attributes.rs
index 62eac35..f1e9041 100644
--- a/src/librustc_trans/attributes.rs
+++ b/src/librustc_trans/attributes.rs
@@ -24,10 +24,9 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {
         Always => Attribute::AlwaysInline.apply_llfn(Function, val),
         Never  => Attribute::NoInline.apply_llfn(Function, val),
         None   => {
-            let attr = Attribute::InlineHint |
-                       Attribute::AlwaysInline |
-                       Attribute::NoInline;
-            attr.unapply_llfn(Function, val)
+            Attribute::InlineHint.unapply_llfn(Function, val);
+            Attribute::AlwaysInline.unapply_llfn(Function, val);
+            Attribute::NoInline.unapply_llfn(Function, val);
         },
     };
 }
diff --git a/src/librustc_trans/cabi_asmjs.rs b/src/librustc_trans/cabi_asmjs.rs
index 3cbc378..f410627 100644
--- a/src/librustc_trans/cabi_asmjs.rs
+++ b/src/librustc_trans/cabi_asmjs.rs
@@ -10,8 +10,8 @@
 
 #![allow(non_upper_case_globals)]
 
-use llvm::{Struct, Array, Attribute};
-use abi::{FnType, ArgType};
+use llvm::{Struct, Array};
+use abi::{FnType, ArgType, ArgAttribute};
 use context::CrateContext;
 
 // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128
@@ -39,7 +39,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {
 fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {
     if arg.ty.is_aggregate() {
         arg.make_indirect(ccx);
-        arg.attrs.set(Attribute::ByVal);
+        arg.attrs.set(ArgAttribute::ByVal);
     }
 }
 
diff --git a/src/librustc_trans/cabi_x86.rs b/src/librustc_trans/cabi_x86.rs
index b52231f..5377b49 100644
--- a/src/librustc_trans/cabi_x86.rs
+++ b/src/librustc_trans/cabi_x86.rs
@@ -9,7 +9,7 @@
 // except according to those terms.
 
 use llvm::*;
-use abi::FnType;
+use abi::{ArgAttribute, FnType};
 use type_::Type;
 use super::common::*;
 use super::machine::*;
@@ -45,7 +45,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {
         if arg.is_ignore() { continue; }
         if arg.ty.kind() == Struct {
             arg.make_indirect(ccx);
-            arg.attrs.set(Attribute::ByVal);
+            arg.attrs.set(ArgAttribute::ByVal);
         } else {
             arg.extend_integer_width_to(32);
         }
diff --git a/src/librustc_trans/cabi_x86_64.rs b/src/librustc_trans/cabi_x86_64.rs
index 3399014..7f2fdbf 100644
--- a/src/librustc_trans/cabi_x86_64.rs
+++ b/src/librustc_trans/cabi_x86_64.rs
@@ -15,8 +15,8 @@
 use self::RegClass::*;
 
 use llvm::{Integer, Pointer, Float, Double};
-use llvm::{Struct, Array, Attribute, Vector};
-use abi::{self, ArgType, FnType};
+use llvm::{Struct, Array, Vector};
+use abi::{self, ArgType, ArgAttribute, FnType};
 use context::CrateContext;
 use type_::Type;
 
@@ -334,7 +334,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {
     fn x86_64_ty<F>(ccx: &CrateContext,
                     arg: &mut ArgType,
                     is_mem_cls: F,
-                    ind_attr: Option<Attribute>)
+                    ind_attr: Option<ArgAttribute>)
         where F: FnOnce(&[RegClass]) -> bool
     {
         if !arg.ty.is_reg_ty() {
@@ -384,7 +384,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {
                 sse_regs -= needed_sse;
             }
             in_mem
-        }, Some(Attribute::ByVal));
+        }, Some(ArgAttribute::ByVal));
 
         // An integer, pointer, double or float parameter
         // thus the above closure passed to `x86_64_ty` won't
diff --git a/src/librustc_trans/lib.rs b/src/librustc_trans/lib.rs
index fd9c761..5c372f0 100644
--- a/src/librustc_trans/lib.rs
+++ b/src/librustc_trans/lib.rs
@@ -23,6 +23,7 @@
       html_root_url = "https://doc.rust-lang.org/nightly/")]
 #![cfg_attr(not(stage0), deny(warnings))]
 
+#![feature(associated_consts)]
 #![feature(box_patterns)]
 #![feature(box_syntax)]
 #![feature(cell_extras)]
@@ -55,6 +56,9 @@ extern crate rustc_platform_intrinsics as intrinsics;
 extern crate serialize;
 extern crate rustc_const_math;
 extern crate rustc_const_eval;
+#[macro_use]
+#[no_link]
+extern crate rustc_bitflags;
 
 #[macro_use] extern crate log;
 #[macro_use] extern crate syntax;
diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index c6b9e56..184bbd6 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -109,37 +109,84 @@ extern "C" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {
   return wrap(Type::getMetadataTy(*unwrap(C)));
 }
 
-extern "C" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, uint64_t Val) {
+static Attribute::AttrKind
+from_rust(LLVMRustAttribute kind) {
+  switch (kind) {
+    case AlwaysInline:
+      return Attribute::AlwaysInline;
+    case ByVal:
+      return Attribute::ByVal;
+    case Cold:
+      return Attribute::Cold;
+    case InlineHint:
+      return Attribute::InlineHint;
+    case MinSize:
+      return Attribute::MinSize;
+    case Naked:
+      return Attribute::Naked;
+    case NoAlias:
+      return Attribute::NoAlias;
+    case NoCapture:
+      return Attribute::NoCapture;
+    case NoInline:
+      return Attribute::NoInline;
+    case NonNull:
+      return Attribute::NonNull;
+    case NoRedZone:
+      return Attribute::NoRedZone;
+    case NoReturn:
+      return Attribute::NoReturn;
+    case NoUnwind:
+      return Attribute::NoUnwind;
+    case OptimizeForSize:
+      return Attribute::OptimizeForSize;
+    case ReadOnly:
+      return Attribute::ReadOnly;
+    case SExt:
+      return Attribute::SExt;
+    case StructRet:
+      return Attribute::StructRet;
+    case UWTable:
+      return Attribute::UWTable;
+    case ZExt:
+      return Attribute::ZExt;
+    default:
+      llvm_unreachable("bad AttributeKind");
+  }
+}
+
+extern "C" LLVMAttributeRef LLVMRustCreateAttribute(LLVMContextRef C, LLVMRustAttribute Kind, uint64_t Val) {
+  return wrap(Attribute::get(*unwrap(C), from_rust(Kind), Val));
+}
+
+extern "C" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, LLVMAttributeRef attr) {
   CallSite Call = CallSite(unwrap<Instruction>(Instr));
-  AttrBuilder B;
-  B.addRawValue(Val);
+  AttrBuilder B(unwrap(attr));
   Call.setAttributes(
     Call.getAttributes().addAttributes(Call->getContext(), index,
                                        AttributeSet::get(Call->getContext(),
                                                          index, B)));
 }
 
-
 extern "C" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,
-						       unsigned idx,
-						       uint64_t b)
+                                                      unsigned index,
+                                                      uint64_t bytes)
 {
   CallSite Call = CallSite(unwrap<Instruction>(Instr));
   AttrBuilder B;
-  B.addDereferenceableAttr(b);
+  B.addDereferenceableAttr(bytes);
   Call.setAttributes(
-    Call.getAttributes().addAttributes(Call->getContext(), idx,
+    Call.getAttributes().addAttributes(Call->getContext(), index,
                                        AttributeSet::get(Call->getContext(),
-                                                         idx, B)));
+                                                         index, B)));
 }
 
 extern "C" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn,
 					     unsigned index,
-					     uint64_t Val)
+					     LLVMAttributeRef attr)
 {
   Function *A = unwrap<Function>(Fn);
-  AttrBuilder B;
-  B.addRawValue(Val);
+  AttrBuilder B(unwrap(attr));
   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));
 }
 
@@ -153,16 +200,6 @@ extern "C" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn,
   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));
 }
 
-extern "C" void LLVMRustAddFunctionAttrString(LLVMValueRef Fn,
-					      unsigned index,
-					      const char *Name)
-{
-  Function *F = unwrap<Function>(Fn);
-  AttrBuilder B;
-  B.addAttribute(Name);
-  F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));
-}
-
 extern "C" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,
 						   unsigned index,
 						   const char *Name,
@@ -175,31 +212,15 @@ extern "C" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,
 
 extern "C" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,
 						 unsigned index,
-						 uint64_t Val)
+						 LLVMAttributeRef attr)
 {
-  Function *A = unwrap<Function>(Fn);
-  const AttributeSet PAL = A->getAttributes();
-  AttrBuilder B(Val);
+  Function *F = unwrap<Function>(Fn);
+  const AttributeSet PAL = F->getAttributes();
+  AttrBuilder B(unwrap(attr));
   const AttributeSet PALnew =
-    PAL.removeAttributes(A->getContext(), index,
-                         AttributeSet::get(A->getContext(), index, B));
-  A->setAttributes(PALnew);
-}
-
-extern "C" void LLVMRustRemoveFunctionAttrString(LLVMValueRef fn,
-						 unsigned index,
-						 const char *Name)
-{
-  Function *f = unwrap<Function>(fn);
-  LLVMContext &C = f->getContext();
-  AttrBuilder B;
-  B.addAttribute(Name);
-  AttributeSet to_remove = AttributeSet::get(C, index, B);
-
-  AttributeSet attrs = f->getAttributes();
-  f->setAttributes(attrs.removeAttributes(f->getContext(),
-                                          index,
-                                          to_remove));
+    PAL.removeAttributes(F->getContext(), index,
+                         AttributeSet::get(F->getContext(), index, B));
+  F->setAttributes(PALnew);
 }
 
 // enable fpmath flag UnsafeAlgebra
@@ -1460,3 +1481,7 @@ extern "C" LLVMRustLinkage LLVMRustGetLinkage(LLVMValueRef V) {
 extern "C" void LLVMRustSetLinkage(LLVMValueRef V, LLVMRustLinkage RustLinkage) {
     LLVMSetLinkage(V, from_rust(RustLinkage));
 }
+
+extern "C" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {
+    return wrap(&unwrap(V)->getContext());
+}
diff --git a/src/rustllvm/rustllvm.h b/src/rustllvm/rustllvm.h
index 26b231c..b8c4076 100644
--- a/src/rustllvm/rustllvm.h
+++ b/src/rustllvm/rustllvm.h
@@ -78,6 +78,28 @@ enum class LLVMRustResult {
     Failure
 };
 
+enum LLVMRustAttribute {
+    AlwaysInline    = 0,
+    ByVal           = 1,
+    Cold            = 2,
+    InlineHint      = 3,
+    MinSize         = 4,
+    Naked           = 5,
+    NoAlias         = 6,
+    NoCapture       = 7,
+    NoInline        = 8,
+    NonNull         = 9,
+    NoRedZone       = 10,
+    NoReturn        = 11,
+    NoUnwind        = 12,
+    OptimizeForSize = 13,
+    ReadOnly        = 14,
+    SExt            = 15,
+    StructRet       = 16,
+    UWTable         = 17,
+    ZExt            = 18,
+};
+
 typedef struct OpaqueRustString *RustStringRef;
 typedef struct LLVMOpaqueTwine *LLVMTwineRef;
 typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;

From b9478d859bdcf46b80a3bf4a5e995ca93c463d63 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Fri, 18 Nov 2016 11:11:18 -0500
Subject: [PATCH 12/18] [LLVM 4.0] Move debuginfo alignment argument

Alignment was removed from createBasicType and moved to

- createGlobalVariable
- createAutoVariable
- createStaticMemberType (unused in Rust)
- createTempGlobalVariableFwdDecl (unused in Rust)

https://github.com/llvm-mirror/llvm/commit/e69c459a6e9756ca1ff3acb1dcfc434843aee80f
---
 src/librustc_llvm/ffi.rs                 |  6 +++--
 src/librustc_trans/debuginfo/metadata.rs |  8 ++++++-
 src/librustc_trans/debuginfo/mod.rs      |  5 +++-
 src/rustllvm/RustWrapper.cpp             | 39 +++++++++++++++++++++++++-------
 4 files changed, 46 insertions(+), 12 deletions(-)

diff --git a/src/librustc_llvm/ffi.rs b/src/librustc_llvm/ffi.rs
index 495fdcd..d342c77 100644
--- a/src/librustc_llvm/ffi.rs
+++ b/src/librustc_llvm/ffi.rs
@@ -1658,7 +1658,8 @@ extern "C" {
                                                  Ty: DIType,
                                                  isLocalToUnit: bool,
                                                  Val: ValueRef,
-                                                 Decl: DIDescriptor)
+                                                 Decl: DIDescriptor,
+                                                 AlignInBits: u64)
                                                  -> DIGlobalVariable;
 
     pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,
@@ -1670,7 +1671,8 @@ extern "C" {
                                            Ty: DIType,
                                            AlwaysPreserve: bool,
                                            Flags: DIFlags,
-                                           ArgNo: c_uint)
+                                           ArgNo: c_uint,
+                                           AlignInBits: u64)
                                            -> DIVariable;
 
     pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,
diff --git a/src/librustc_trans/debuginfo/metadata.rs b/src/librustc_trans/debuginfo/metadata.rs
index e68dc3c..57c2723 100644
--- a/src/librustc_trans/debuginfo/metadata.rs
+++ b/src/librustc_trans/debuginfo/metadata.rs
@@ -1771,6 +1771,10 @@ pub fn create_global_var_metadata(cx: &CrateContext,
 
     let var_name = CString::new(var_name).unwrap();
     let linkage_name = CString::new(linkage_name).unwrap();
+
+    let ty = cx.tcx().lookup_item_type(node_def_id).ty;
+    let global_align = type_of::align_of(cx, ty);
+
     unsafe {
         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),
                                                     var_scope,
@@ -1781,7 +1785,9 @@ pub fn create_global_var_metadata(cx: &CrateContext,
                                                     type_metadata,
                                                     is_local_to_unit,
                                                     global,
-                                                    ptr::null_mut());
+                                                    ptr::null_mut(),
+                                                    global_align as u64,
+        );
     }
 }
 
diff --git a/src/librustc_trans/debuginfo/mod.rs b/src/librustc_trans/debuginfo/mod.rs
index e023e65..0ae2af4 100644
--- a/src/librustc_trans/debuginfo/mod.rs
+++ b/src/librustc_trans/debuginfo/mod.rs
@@ -462,6 +462,7 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
         LocalVariable    |
         CapturedVariable => (0, DW_TAG_auto_variable)
     };
+    let align = ::type_of::align_of(cx, variable_type);
 
     let name = CString::new(variable_name.as_str().as_bytes()).unwrap();
     match (variable_access, &[][..]) {
@@ -478,7 +479,9 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
                     type_metadata,
                     cx.sess().opts.optimize != config::OptLevel::No,
                     DIFlags::FlagZero,
-                    argument_index)
+                    argument_index,
+                    align as u64,
+                )
             };
             source_loc::set_debug_location(cx, None,
                 InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));
diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index 184bbd6..239a0ea 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -609,8 +609,13 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateBasicType(
     uint64_t AlignInBits,
     unsigned Encoding) {
     return wrap(Builder->createBasicType(
-        Name, SizeInBits,
-        AlignInBits, Encoding));
+        Name,
+        SizeInBits,
+#if LLVM_VERSION_LE(3, 9)
+        AlignInBits,
+#endif
+        Encoding
+    ));
 }
 
 extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreatePointerType(
@@ -702,8 +707,11 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(
     LLVMRustMetadataRef Ty,
     bool isLocalToUnit,
     LLVMValueRef Val,
-    LLVMRustMetadataRef Decl = NULL) {
-    return wrap(Builder->createGlobalVariable(unwrapDI<DIDescriptor>(Context),
+    LLVMRustMetadataRef Decl = NULL,
+    uint64_t AlignInBits = 0)
+{
+    return wrap(Builder->createGlobalVariable(
+        unwrapDI<DIDescriptor>(Context),
         Name,
         LinkageName,
         unwrapDI<DIFile>(File),
@@ -716,7 +724,12 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(
 #else
         cast<Constant>(unwrap(Val)),
 #endif
-        unwrapDIptr<MDNode>(Decl)));
+        unwrapDIptr<MDNode>(Decl)
+#if LLVM_VERSION_GE(4, 0)
+        ,
+        AlignInBits
+#endif
+    ));
 }
 
 extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(
@@ -729,14 +742,24 @@ extern "C" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(
     LLVMRustMetadataRef Ty,
     bool AlwaysPreserve,
     LLVMRustDIFlags Flags,
-    unsigned ArgNo) {
+    unsigned ArgNo,
+    uint64_t AlignInBits)
+{
 #if LLVM_VERSION_GE(3, 8)
     if (Tag == 0x100) { // DW_TAG_auto_variable
         return wrap(Builder->createAutoVariable(
-            unwrapDI<DIDescriptor>(Scope), Name,
+            unwrapDI<DIDescriptor>(Scope),
+            Name,
             unwrapDI<DIFile>(File),
             LineNo,
-            unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));
+            unwrapDI<DIType>(Ty),
+            AlwaysPreserve,
+            from_rust(Flags)
+#if LLVM_VERSION_GE(4,0)
+            ,
+            AlignInBits
+#endif
+        ));
     } else {
         return wrap(Builder->createParameterVariable(
             unwrapDI<DIDescriptor>(Scope), Name, ArgNo,

From a22837524451f79483d9a98a1765993a87a85cbe Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Fri, 18 Nov 2016 16:22:39 -0500
Subject: [PATCH 13/18] [LLVM 4.0] Support new DIFlags enum

---
 src/rustllvm/RustWrapper.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index 239a0ea..b4c04ae 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -460,8 +460,13 @@ inline bool is_set(LLVMRustDIFlags f) {
 //     return result;
 // }
 
+#if LLVM_VERSION_GE(4, 0)
+static DINode::DIFlags from_rust(LLVMRustDIFlags flags) {
+    DINode::DIFlags result = DINode::DIFlags::FlagZero;
+#else
 static unsigned from_rust(LLVMRustDIFlags flags) {
     unsigned result = 0;
+#endif
 
     if (is_set(flags & LLVMRustDIFlags::FlagPrivate))             { result |= DINode::DIFlags::FlagPrivate; }
     if (is_set(flags & LLVMRustDIFlags::FlagProtected))           { result |= DINode::DIFlags::FlagProtected; }

From c343f327e5319eadc773d4721943e14fe87848e3 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Fri, 18 Nov 2016 17:10:36 -0500
Subject: [PATCH 14/18] [4.0] DIFlags --- Readd bitflags / squash

---
 src/librustc_llvm/Cargo.toml | 3 +++
 src/librustc_llvm/lib.rs     | 3 +++
 3 files changed, 8 insertions(+)

diff --git a/src/librustc_llvm/Cargo.toml b/src/librustc_llvm/Cargo.toml
index 88f8c05..f97daa2 100644
--- a/src/librustc_llvm/Cargo.toml
+++ b/src/librustc_llvm/Cargo.toml
@@ -12,6 +12,9 @@ crate-type = ["dylib"]
 [features]
 static-libstdcpp = []
 
+[dependencies]
+rustc_bitflags = { path = "../librustc_bitflags" }
+
 [build-dependencies]
 build_helper = { path = "../build_helper" }
 gcc = "0.3.27"
diff --git a/src/librustc_llvm/lib.rs b/src/librustc_llvm/lib.rs
index 3f41b82..23c13b0 100644
--- a/src/librustc_llvm/lib.rs
+++ b/src/librustc_llvm/lib.rs
@@ -32,6 +32,9 @@
 #![cfg_attr(not(stage0), feature(rustc_private))]
 
 extern crate libc;
+#[macro_use]
+#[no_link]
+extern crate rustc_bitflags;
 
 pub use self::IntPredicate::*;
 pub use self::RealPredicate::*;

From b5f86ae9de9850e67b805ce56947abde825afff9 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Sun, 6 Nov 2016 10:03:44 -0500
Subject: [PATCH 16/18] [Hack] Disable Rust-specific modifications to LLVM

Upstream Rust has custom functionality compared to LLVM upstream. Each
one makes upgrading harder. Sigh.

- target and feature listing support
- JSBackend
---
 src/rustllvm/PassWrapper.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/rustllvm/PassWrapper.cpp b/src/rustllvm/PassWrapper.cpp
index 6b8bc72..95cdbad 100644
--- a/src/rustllvm/PassWrapper.cpp
+++ b/src/rustllvm/PassWrapper.cpp
@@ -250,7 +250,7 @@ from_rust(LLVMRustCodeGenOptLevel level)
   }
 }
 
-#if LLVM_RUSTLLVM
+#if LLVM_RUSTLLVM && false
 /// getLongestEntryLength - Return the length of the longest entry in the table.
 ///
 static size_t getLongestEntryLength(ArrayRef<SubtargetFeatureKV> Table) {

From b13393e89d3b43dbe09ab27beae99b944845a560 Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Fri, 18 Nov 2016 18:40:06 -0500
Subject: [PATCH 17/18] [4.0] rustcllvm lock

---
 src/librustc_llvm/Cargo.lock | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)
 create mode 100644 src/librustc_llvm/Cargo.lock

diff --git a/src/librustc_llvm/Cargo.lock b/src/librustc_llvm/Cargo.lock
new file mode 100644
index 0000000..17678ef
--- /dev/null
+++ b/src/librustc_llvm/Cargo.lock
@@ -0,0 +1,22 @@
+[root]
+name = "rustc_llvm"
+version = "0.0.0"
+dependencies = [
+ "build_helper 0.1.0",
+ "gcc 0.3.28 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc_bitflags 0.0.0",
+]
+
+[[package]]
+name = "build_helper"
+version = "0.1.0"
+
+[[package]]
+name = "gcc"
+version = "0.3.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "rustc_bitflags"
+version = "0.0.0"
+

From b7c8d316d4c65fceb5660f42d064180999d8972a Mon Sep 17 00:00:00 2001
From: Jake Goulding <jake.goulding@gmail.com>
Date: Sat, 19 Nov 2016 11:55:05 -0500
Subject: [PATCH 18/18] error string is an *owned std::str*

---
 src/librustc_llvm/diagnostic.rs  | 12 ++++++++++--
 src/librustc_trans/back/write.rs | 15 ++++++++++++---
 src/rustllvm/RustWrapper.cpp     |  2 +-
 3 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/src/librustc_llvm/diagnostic.rs b/src/librustc_llvm/diagnostic.rs
index c11b64e..6110f03 100644
--- a/src/librustc_llvm/diagnostic.rs
+++ b/src/librustc_llvm/diagnostic.rs
@@ -45,10 +45,10 @@ impl OptimizationDiagnosticKind {
 
 pub struct OptimizationDiagnostic {
     pub kind: OptimizationDiagnosticKind,
-    pub pass_name: *const c_char,
+    pub pass_name: *const c_char, // This is a llvm::StringRef
     pub function: ValueRef,
     pub debug_loc: DebugLocRef,
-    pub message: *const c_char,
+    pub message: *const c_char, // We own this
 }
 
 impl OptimizationDiagnostic {
@@ -74,6 +74,14 @@ impl OptimizationDiagnostic {
     }
 }
 
+impl Drop for OptimizationDiagnostic {
+    fn drop(&mut self) {
+        unsafe {
+            ::libc::free(self.message as *mut _);
+        }
+    }
+}
+
 #[derive(Copy, Clone)]
 pub struct InlineAsmDiagnostic {
     pub cookie: c_uint,
diff --git a/src/librustc_trans/back/write.rs b/src/librustc_trans/back/write.rs
index 751ae61..3e2e5bb 100644
--- a/src/librustc_trans/back/write.rs
+++ b/src/librustc_trans/back/write.rs
@@ -404,9 +404,18 @@ unsafe extern "C" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo
 
         llvm::diagnostic::Optimization(opt) => {
             let pass_name = str::from_utf8(CStr::from_ptr(opt.pass_name).to_bytes())
-                                .expect("got a non-UTF8 pass name from LLVM");
-            let message = str::from_utf8(CStr::from_ptr(opt.message).to_bytes())
-                              .expect("got a non-UTF8 message from LLVM");
+                .expect("got a non-UTF8 pass name from LLVM");
+
+            let a = CStr::from_ptr(opt.message);
+            let b = a.to_bytes();
+
+            let message = match str::from_utf8(b) {
+                Ok(m) => m,
+                Err(e) => {
+                    panic!("got a non-UTF8 message from LLVM: {}\ncstr {:?}\nbytes {:?}", e, a, b);
+                },
+            };
+                    //          .expect("got a non-UTF8 message from LLVM");
 
             let enabled = match cgcx.remark {
                 AllPasses => true,
diff --git a/src/rustllvm/RustWrapper.cpp b/src/rustllvm/RustWrapper.cpp
index b4c04ae..fefb099 100644
--- a/src/rustllvm/RustWrapper.cpp
+++ b/src/rustllvm/RustWrapper.cpp
@@ -1076,7 +1076,7 @@ LLVMRustUnpackOptimizationDiagnostic(
     *pass_name_out = opt->getPassName().data();
     *function_out = wrap(&opt->getFunction());
     *debugloc_out = wrap(&opt->getDebugLoc());
-    *message_out = opt->getMsg().data();
+    *message_out = strdup(opt->getMsg().c_str());
 }
 
 extern "C" void

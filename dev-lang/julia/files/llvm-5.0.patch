From 7310ca228089a79286f9b941fc82466e3515b6cc Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sat, 29 Jul 2017 19:54:35 -0400
Subject: [PATCH 1/2] Fix C++ code compilation on LLVM 5.0 and SVN

Ref https://github.com/llvm-mirror/llvm/commit/ee809acd59b2d357c37ac1276aabb6620f94cb7b
Ref https://github.com/llvm-mirror/llvm/commit/966d9ebd7f825b6272aa691dcef6baada1129c5c
Ref https://github.com/llvm-mirror/llvm/commit/a81793582b3c47869680d354a97d59c55779c349
Ref https://github.com/llvm-mirror/llvm/commit/72786af0ac80b7d63f296d5cc8045e56535461ce
Ref https://github.com/llvm-mirror/llvm/commit/67191c1ced59d7790d8423d3a06b986baf0b9256
Ref https://github.com/llvm-mirror/llvm/commit/08ef6db99166c2f37a05c252152f352cbe2f481b
Ref https://github.com/llvm-mirror/llvm/commit/10ccfa6a1e7efc62fb55961986ada2c442a17491
---
 src/ccall.cpp                 |   6 +-
 src/cgutils.cpp               |   2 +
 src/codegen.cpp               |  44 +++++++----
 src/codegen_shared.h          |  46 +++++++++++
 src/debuginfo.cpp             |   8 ++
 src/jitlayers.cpp             | 178 +++++++++++++++++++++++++-----------------
 src/jitlayers.h               |  33 +++++---
 src/llvm-alloc-opt.cpp        |  15 +---
 src/llvm-late-gc-lowering.cpp |   8 +-
 9 files changed, 225 insertions(+), 115 deletions(-)

diff --git a/src/ccall.cpp b/src/ccall.cpp
index 818989cefc24..9975a37d5059 100644
--- a/src/ccall.cpp
+++ b/src/ccall.cpp
@@ -1101,11 +1101,7 @@ static jl_cgval_t emit_llvmcall(jl_codectx_t &ctx, jl_value_t **args, size_t nar
         //f->dump();
         llvm::raw_fd_ostream out(1,false);
         if (verifyFunction(*f,&out)) {
-#if JL_LLVM_VERSION >= 50000
-            f->print(llvm::dbgs(), nullptr, false, true);
-#else
-            f->dump();
-#endif
+            llvm_dump(f);
             jl_error("Malformed LLVM Function");
         }
     }
diff --git a/src/cgutils.cpp b/src/cgutils.cpp
index 430a33b105e2..960ec750cebe 100644
--- a/src/cgutils.cpp
+++ b/src/cgutils.cpp
@@ -2292,6 +2292,8 @@ static void emit_signal_fence(jl_codectx_t &ctx)
     // https://llvm.org/bugs/show_bug.cgi?id=27545
     ctx.builder.CreateCall(InlineAsm::get(FunctionType::get(T_void, false), "",
                                       "~{memory}", true));
+#elif JL_LLVM_VERSION >= 50000
+    ctx.builder.CreateFence(AtomicOrdering::SequentiallyConsistent, SyncScope::SingleThread);
 #else
     ctx.builder.CreateFence(AtomicOrdering::SequentiallyConsistent, SingleThread);
 #endif
diff --git a/src/codegen.cpp b/src/codegen.cpp
index de0e019350c1..408fc668f40d 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -85,6 +85,7 @@
 #include <polly/RegisterPasses.h>
 #include <polly/ScopDetection.h>
 #endif
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include "fix_llvm_assert.h"
 
 using namespace llvm;
@@ -1288,8 +1289,15 @@ uint64_t jl_get_llvm_fptr(void *function)
 {
     Function *F = (Function*)function;
     uint64_t addr = getAddressForFunction(F->getName());
-    if (!addr)
+    if (!addr) {
+#if JL_LLVM_VERSION >= 50000
+        if (auto exp_addr = jl_ExecutionEngine->findUnmangledSymbol(F->getName()).getAddress()) {
+            addr = exp_addr.get();
+        }
+#else
         addr = jl_ExecutionEngine->findUnmangledSymbol(F->getName()).getAddress();
+#endif
+    }
     return addr;
 }
 
@@ -5164,7 +5172,11 @@ static std::unique_ptr<Module> emit_function(
                     if (ctx.debug_enabled && vi.dinfo && !vi.boxroot && !vi.value.V) {
                         SmallVector<uint64_t, 8> addr;
                         addr.push_back(llvm::dwarf::DW_OP_deref);
+#if JL_LLVM_VERSION >= 50000
+                        addr.push_back(llvm::dwarf::DW_OP_plus_uconst);
+#else
                         addr.push_back(llvm::dwarf::DW_OP_plus);
+#endif
                         addr.push_back((i - 1) * sizeof(void*));
                         if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)
                             addr.push_back(llvm::dwarf::DW_OP_deref);
@@ -6777,30 +6789,30 @@ extern "C" void jl_init_codegen(void)
 // for debugging from gdb
 extern "C" void jl_dump_llvm_value(void *v)
 {
-#if JL_LLVM_VERSION >= 50000
-    ((Value*)v)->print(llvm::dbgs(), true);
-#else
-    ((Value*)v)->dump();
-#endif
+    llvm_dump((Value*)v);
 }
+
 extern "C" void jl_dump_llvm_inst_function(void *v)
 {
-#if JL_LLVM_VERSION >= 50000
-    cast<Instruction>(((Value*)v))->getParent()->getParent()->print(llvm::dbgs(), nullptr, true);
-#else
-    cast<Instruction>(((Value*)v))->getParent()->getParent()->dump();
-#endif
+    llvm_dump(cast<Instruction>(((Value*)v))->getParent()->getParent());
 }
+
 extern "C" void jl_dump_llvm_type(void *v)
 {
-#if JL_LLVM_VERSION >= 50000
-    ((Type*)v)->print(llvm::dbgs(), true);
-#else
-    ((Type*)v)->dump();
-#endif
+    llvm_dump((Type*)v);
     putchar('\n');
 }
 
+extern "C" void jl_dump_llvm_module(void *v)
+{
+    llvm_dump((Module*)v);
+}
+
+extern "C" void jl_dump_llvm_metadata(void *v)
+{
+    llvm_dump((Metadata*)v);
+}
+
 extern void jl_write_bitcode_func(void *F, char *fname) {
     std::error_code EC;
     raw_fd_ostream OS(fname, EC, sys::fs::F_None);
diff --git a/src/codegen_shared.h b/src/codegen_shared.h
index 6930d007e831..86aa020088d4 100644
--- a/src/codegen_shared.h
+++ b/src/codegen_shared.h
@@ -7,3 +7,49 @@ enum AddressSpace {
 
 #define JLCALL_CC (CallingConv::ID)36
 #define JLCALL_F_CC (CallingConv::ID)37
+
+static inline void llvm_dump(llvm::Value *v)
+{
+#if JL_LLVM_VERSION >= 50000
+    v->print(llvm::dbgs(), true);
+#else
+    v->dump();
+#endif
+}
+
+static inline void llvm_dump(llvm::Type *v)
+{
+#if JL_LLVM_VERSION >= 50000
+    v->print(llvm::dbgs(), true);
+#else
+    v->dump();
+#endif
+}
+
+static inline void llvm_dump(llvm::Function *f)
+{
+#if JL_LLVM_VERSION >= 50000
+    f->print(llvm::dbgs(), nullptr, false, true);
+#else
+    f->dump();
+#endif
+}
+
+static inline void llvm_dump(llvm::Module *m)
+{
+#if JL_LLVM_VERSION >= 50000
+    m->print(llvm::dbgs(), nullptr);
+#else
+    m->dump();
+#endif
+}
+
+static inline void llvm_dump(llvm::Metadata *m)
+{
+#if JL_LLVM_VERSION >= 50000
+    m->print(llvm::dbgs());
+    putchar('\n');
+#else
+    m->dump();
+#endif
+}
diff --git a/src/debuginfo.cpp b/src/debuginfo.cpp
index 551ffb9b81d0..b2a3f070f60e 100644
--- a/src/debuginfo.cpp
+++ b/src/debuginfo.cpp
@@ -399,7 +399,11 @@ class JuliaJITEventListener: public JITEventListener
                 ObjectInfo tmp = {&debugObj,
                     (size_t)SectionSize,
                     (ptrdiff_t)(SectionAddr - SectionLoadAddr),
+#if JL_LLVM_VERSION >= 60000
+                    DWARFContext::create(debugObj, &L).release(),
+#else
                     new DWARFContextInMemory(debugObj, &L),
+#endif
                     };
                 objectmap[SectionLoadAddr] = tmp;
                 first = false;
@@ -938,7 +942,11 @@ static objfileentry_t &find_object_file(uint64_t fbase, StringRef fname)
             slide = -(int64_t)fbase;
         }
 
+#if JL_LLVM_VERSION >= 60000
+        auto context = DWARFContext::create(*debugobj).release();
+#else
         auto context = new DWARFContextInMemory(*debugobj);
+#endif
         auto binary = errorobj->takeBinary();
         binary.first.release();
         binary.second.release();
diff --git a/src/jitlayers.cpp b/src/jitlayers.cpp
index 5e4cc93ca5f7..83fd0f31852c 100644
--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -46,7 +46,6 @@ namespace llvm {
 #include <llvm/IR/LegacyPassManagers.h>
 #include <llvm/IR/IRPrintingPasses.h>
 #include <llvm/Transforms/Utils/Cloning.h>
-#include <llvm/ExecutionEngine/JITEventListener.h>
 
 // target support
 #include <llvm/ADT/Triple.h>
@@ -60,6 +59,7 @@ namespace llvm {
 #include <llvm/ADT/StringMap.h>
 #include <llvm/ADT/StringSet.h>
 #include <llvm/ADT/SmallSet.h>
+#include "codegen_shared.h"
 #include "fix_llvm_assert.h"
 
 using namespace llvm;
@@ -356,61 +356,76 @@ JL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,
                                          const RuntimeDyld::LoadedObjectInfo &L,
                                          RTDyldMemoryManager *memmgr);
 
+template <typename ObjT, typename LoadResult>
+void JuliaOJIT::DebugObjectRegistrar::registerObject(RTDyldObjHandleT H, const ObjT &Object,
+                                                     const LoadResult &LO)
+{
+    OwningBinary<object::ObjectFile> SavedObject = LO->getObjectForDebug(*Object);
+
+    // If the debug object is unavailable, save (a copy of) the original object
+    // for our backtraces
+    if (!SavedObject.getBinary()) {
+        // This is unfortunate, but there doesn't seem to be a way to take
+        // ownership of the original buffer
+        auto NewBuffer = MemoryBuffer::getMemBufferCopy(Object->getData(),
+                                                        Object->getFileName());
+        auto NewObj = ObjectFile::createObjectFile(NewBuffer->getMemBufferRef());
+        assert(NewObj);
+        SavedObject = OwningBinary<object::ObjectFile>(std::move(*NewObj),
+                                                       std::move(NewBuffer));
+    }
+    else {
+        NotifyGDB(SavedObject);
+    }
+
+    SavedObjects.push_back(std::move(SavedObject));
+
+    ORCNotifyObjectEmitted(JuliaListener.get(), *Object,
+                           *SavedObjects.back().getBinary(),
+                           *LO, JIT.MemMgr.get());
+
+    // record all of the exported symbols defined in this object
+    // in the primary hash table for the enclosing JIT
+    for (auto &Symbol : Object->symbols()) {
+        auto Flags = Symbol.getFlags();
+        if (Flags & object::BasicSymbolRef::SF_Undefined)
+            continue;
+        if (!(Flags & object::BasicSymbolRef::SF_Exported))
+            continue;
+        auto NameOrError = Symbol.getName();
+        assert(NameOrError);
+        auto Name = NameOrError.get();
+        auto Sym = JIT.CompileLayer.findSymbolIn(H, Name, true);
+        assert(Sym);
+        // note: calling getAddress here eagerly finalizes H
+        // as an alternative, we could store the JITSymbol instead
+        // (which would present a lazy-initializer functor interface instead)
+#if JL_LLVM_VERSION >= 50000
+        JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)cantFail(Sym.getAddress());
+#else
+        JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)Sym.getAddress();
+#endif
+    }
+}
+
 // TODO: hook up RegisterJITEventListener, instead of hard-coding the GDB and JuliaListener targets
 template <typename ObjSetT, typename LoadResult>
-void JuliaOJIT::DebugObjectRegistrar::operator()(RTDyldObjectLinkingLayerBase::ObjSetHandleT H,
+void JuliaOJIT::DebugObjectRegistrar::operator()(RTDyldObjHandleT H,
                 const ObjSetT &Objects, const LoadResult &LOS)
 {
+#if JL_LLVM_VERSION >= 50000
+    registerObject(H, Objects->getBinary(),
+                   static_cast<const RuntimeDyld::LoadedObjectInfo*>(&LOS));
+#else
     auto oit = Objects.begin();
     auto lit = LOS.begin();
     for (; oit != Objects.end(); ++oit, ++lit) {
         const auto &Object = (*oit)->getBinary();
         auto &LO = *lit;
 
-        OwningBinary<object::ObjectFile> SavedObject = LO->getObjectForDebug(*Object);
-
-        // If the debug object is unavailable, save (a copy of) the original object
-        // for our backtraces
-        if (!SavedObject.getBinary()) {
-            // This is unfortunate, but there doesn't seem to be a way to take
-            // ownership of the original buffer
-            auto NewBuffer = MemoryBuffer::getMemBufferCopy(Object->getData(),
-                                                            Object->getFileName());
-            auto NewObj = ObjectFile::createObjectFile(NewBuffer->getMemBufferRef());
-            assert(NewObj);
-            SavedObject = OwningBinary<object::ObjectFile>(std::move(*NewObj),
-                                                           std::move(NewBuffer));
-        }
-        else {
-            NotifyGDB(SavedObject);
-        }
-
-        SavedObjects.push_back(std::move(SavedObject));
-
-        ORCNotifyObjectEmitted(JuliaListener.get(),
-                *Object,
-                *SavedObjects.back().getBinary(),
-                *LO, JIT.MemMgr);
-
-        // record all of the exported symbols defined in this object
-        // in the primary hash table for the enclosing JIT
-        for (auto &Symbol : Object->symbols()) {
-            auto Flags = Symbol.getFlags();
-            if (Flags & object::BasicSymbolRef::SF_Undefined)
-                continue;
-            if (!(Flags & object::BasicSymbolRef::SF_Exported))
-                continue;
-            auto NameOrError = Symbol.getName();
-            assert(NameOrError);
-            auto Name = NameOrError.get();
-            auto Sym = JIT.CompileLayer.findSymbolIn(H, Name, true);
-            assert(Sym);
-            // note: calling getAddress here eagerly finalizes H
-            // as an alternative, we could store the JITSymbol instead
-            // (which would present a lazy-initializer functor interface instead)
-            JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)Sym.getAddress();
-        }
+        registerObject(H, Object, LO);
     }
+#endif
 }
 
 void JuliaOJIT::DebugObjectRegistrar::NotifyGDB(OwningBinary<object::ObjectFile> &DebugObj)
@@ -432,37 +447,42 @@ void JuliaOJIT::DebugObjectRegistrar::NotifyGDB(OwningBinary<object::ObjectFile>
     }
 }
 
+object::OwningBinary<object::ObjectFile> JuliaOJIT::CompilerT::operator()(Module &M)
+{
+    JL_TIMING(LLVM_OPT);
+    jit.PM.run(M);
+    std::unique_ptr<MemoryBuffer> ObjBuffer(
+        new ObjectMemoryBuffer(std::move(jit.ObjBufferSV)));
+    auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());
+
+    if (!Obj) {
+        llvm_dump(&M);
+        std::string Buf;
+        raw_string_ostream OS(Buf);
+        logAllUnhandledErrors(Obj.takeError(), OS, "");
+        OS.flush();
+        llvm::report_fatal_error("FATAL: Unable to compile LLVM Module: '" + Buf + "'\n"
+                                 "The module's content was printed above. Please file a bug report");
+    }
+
+    return OwningObj(std::move(*Obj), std::move(ObjBuffer));
+}
+
 JuliaOJIT::JuliaOJIT(TargetMachine &TM)
   : TM(TM),
     DL(TM.createDataLayout()),
     ObjStream(ObjBufferSV),
     MemMgr(createRTDyldMemoryManager()),
-    ObjectLayer(DebugObjectRegistrar(*this)),
-    CompileLayer(
-            ObjectLayer,
-            [this](Module &M) {
-                JL_TIMING(LLVM_OPT);
-                PM.run(M);
-                std::unique_ptr<MemoryBuffer> ObjBuffer(
-                    new ObjectMemoryBuffer(std::move(ObjBufferSV)));
-                auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());
-
-                if (!Obj) {
+    registrar(*this),
+    ObjectLayer(
 #if JL_LLVM_VERSION >= 50000
-                    M.print(llvm::dbgs(), nullptr, false, true);
-#else
-                    M.dump();
+        [&] { return MemMgr; },
 #endif
-                    std::string Buf;
-                    raw_string_ostream OS(Buf);
-                    logAllUnhandledErrors(Obj.takeError(), OS, "");
-                    OS.flush();
-                    llvm::report_fatal_error("FATAL: Unable to compile LLVM Module: '" + Buf + "'\n"
-                        "The module's content was printed above. Please file a bug report");
-                }
-
-                return OwningObj(std::move(*Obj), std::move(ObjBuffer));
-            }
+        std::ref(registrar)
+        ),
+    CompileLayer(
+            ObjectLayer,
+            CompilerT(this)
         )
 {
     addOptimizationPasses(&PM, jl_generating_output() ? 0 : jl_options.opt_level);
@@ -555,10 +575,14 @@ void JuliaOJIT::addModule(std::unique_ptr<Module> M)
                       },
                       [](const std::string &S) { return nullptr; }
                     );
+#if JL_LLVM_VERSION >= 50000
+    auto modset = cantFail(CompileLayer.addModule(std::move(M), std::move(Resolver)));
+#else
     SmallVector<std::unique_ptr<Module>,1> Ms;
     Ms.push_back(std::move(M));
-    auto modset = CompileLayer.addModuleSet(std::move(Ms), MemMgr,
+    auto modset = CompileLayer.addModuleSet(std::move(Ms), MemMgr.get(),
                                             std::move(Resolver));
+#endif
     // Force LLVM to emit the module so that we can register the symbols
     // in our lookup table.
     CompileLayer.emitAndFinalize(modset);
@@ -566,7 +590,11 @@ void JuliaOJIT::addModule(std::unique_ptr<Module> M)
 
 void JuliaOJIT::removeModule(ModuleHandleT H)
 {
+#if JL_LLVM_VERSION >= 50000
+    CompileLayer.removeModule(H);
+#else
     CompileLayer.removeModuleSet(H);
+#endif
 }
 
 JL_JITSymbol JuliaOJIT::findSymbol(const std::string &Name, bool ExportedSymbolsOnly)
@@ -589,12 +617,22 @@ JL_JITSymbol JuliaOJIT::findUnmangledSymbol(const std::string Name)
 
 uint64_t JuliaOJIT::getGlobalValueAddress(const std::string &Name)
 {
+#if JL_LLVM_VERSION >= 50000
+    auto addr = findSymbol(getMangledName(Name), false).getAddress();
+    return addr ? addr.get() : 0;
+#else
     return findSymbol(getMangledName(Name), false).getAddress();
+#endif
 }
 
 uint64_t JuliaOJIT::getFunctionAddress(const std::string &Name)
 {
+#if JL_LLVM_VERSION >= 50000
+    auto addr = findSymbol(getMangledName(Name), false).getAddress();
+    return addr ? addr.get() : 0;
+#else
     return findSymbol(getMangledName(Name), false).getAddress();
+#endif
 }
 
 Function *JuliaOJIT::FindFunctionNamed(const std::string &Name)
diff --git a/src/jitlayers.h b/src/jitlayers.h
index ee13e49f2cb6..96e0c3bc19f6 100644
--- a/src/jitlayers.h
+++ b/src/jitlayers.h
@@ -16,6 +16,7 @@
 #  include "llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h"
 #endif
 #include "llvm/ExecutionEngine/ObjectMemoryBuffer.h"
+#include "llvm/ExecutionEngine/JITEventListener.h"
 
 #include "llvm/IR/LegacyPassManager.h"
 extern legacy::PassManager *jl_globalPM;
@@ -101,12 +102,9 @@ typedef orc::JITSymbol JL_JITSymbol;
 typedef RuntimeDyld::SymbolInfo JL_SymbolInfo;
 #endif
 #if JL_LLVM_VERSION >= 50000
-using orc::RTDyldObjectLinkingLayerBase;
-using orc::RTDyldObjectLinkingLayer;
+using RTDyldObjHandleT = orc::RTDyldObjectLinkingLayerBase::ObjHandleT;
 #else
-using RTDyldObjectLinkingLayerBase = orc::ObjectLinkingLayerBase;
-template <typename NotifyLoadedFtor>
-using RTDyldObjectLinkingLayer = orc::ObjectLinkingLayer<NotifyLoadedFtor>;
+using RTDyldObjHandleT = orc::ObjectLinkingLayerBase::ObjSetHandleT;
 #endif
 
 class JuliaOJIT {
@@ -116,19 +114,35 @@ class JuliaOJIT {
     public:
         DebugObjectRegistrar(JuliaOJIT &JIT);
         template <typename ObjSetT, typename LoadResult>
-        void operator()(RTDyldObjectLinkingLayerBase::ObjSetHandleT H, const ObjSetT &Objects,
-                        const LoadResult &LOS);
+        void operator()(RTDyldObjHandleT H, const ObjSetT &Objects, const LoadResult &LOS);
     private:
+        template <typename ObjT, typename LoadResult>
+        void registerObject(RTDyldObjHandleT H, const ObjT &Object, const LoadResult &LO);
         void NotifyGDB(object::OwningBinary<object::ObjectFile> &DebugObj);
         std::vector<object::OwningBinary<object::ObjectFile>> SavedObjects;
         std::unique_ptr<JITEventListener> JuliaListener;
         JuliaOJIT &JIT;
     };
 
+    struct CompilerT {
+        CompilerT(JuliaOJIT *pjit)
+            : jit(*pjit)
+        {}
+        object::OwningBinary<object::ObjectFile> operator()(Module &M);
+    private:
+        JuliaOJIT &jit;
+    };
+
 public:
-    typedef RTDyldObjectLinkingLayer<DebugObjectRegistrar> ObjLayerT;
+#if JL_LLVM_VERSION >= 50000
+    typedef orc::RTDyldObjectLinkingLayer ObjLayerT;
+    typedef orc::IRCompileLayer<ObjLayerT,CompilerT> CompileLayerT;
+    typedef CompileLayerT::ModuleHandleT ModuleHandleT;
+#else
+    typedef orc::ObjectLinkingLayer<std::reference_wrapper<DebugObjectRegistrar>> ObjLayerT;
     typedef orc::IRCompileLayer<ObjLayerT> CompileLayerT;
     typedef CompileLayerT::ModuleSetHandleT ModuleHandleT;
+#endif
     typedef StringMap<void*> SymbolTableT;
     typedef object::OwningBinary<object::ObjectFile> OwningObj;
 
@@ -160,7 +174,8 @@ class JuliaOJIT {
     raw_svector_ostream ObjStream;
     legacy::PassManager PM;
     MCContext *Ctx;
-    RTDyldMemoryManager *MemMgr;
+    std::shared_ptr<RTDyldMemoryManager> MemMgr;
+    DebugObjectRegistrar registrar;
     ObjLayerT ObjectLayer;
     CompileLayerT CompileLayer;
     SymbolTableT GlobalSymbolTable;
diff --git a/src/llvm-alloc-opt.cpp b/src/llvm-alloc-opt.cpp
index 1cf949104367..be872d7f056d 100644
--- a/src/llvm-alloc-opt.cpp
+++ b/src/llvm-alloc-opt.cpp
@@ -236,17 +236,10 @@ void AllocOpt::LifetimeMarker::insert(Instruction *ptr, Constant *sz, Instructio
         if (DT.dominates(orig, bb))
             continue;
         auto F = bb->getParent();
-#if JL_LLVM_VERSION >= 50000
-        F->print(llvm::dbgs(), nullptr, false, true);
-        orig->print(llvm::dbgs(), true);
-        jl_safe_printf("Does not dominate BB:\n");
-        bb->print(llvm::dbgs(), true);
-#else
-        F->dump();
-        orig->dump();
+        llvm_dump(F);
+        llvm_dump(orig);
         jl_safe_printf("Does not dominate BB:\n");
-        bb->dump();
-#endif
+        llvm_dump(bb);
         abort();
     }
 #endif
@@ -622,7 +615,7 @@ bool AllocOpt::runOnFunction(Function &F)
         AllocaInst *buff;
         Instruction *ptr;
         if (sz == 0) {
-            buff = prolog_builder.CreateAlloca(T_int8, 0);
+            buff = prolog_builder.CreateAlloca(T_int8, ConstantInt::get(T_int64, 0));
             ptr = buff;
         }
         else {
diff --git a/src/llvm-late-gc-lowering.cpp b/src/llvm-late-gc-lowering.cpp
index 72c0b684bfc3..a7c1ec1c052c 100644
--- a/src/llvm-late-gc-lowering.cpp
+++ b/src/llvm-late-gc-lowering.cpp
@@ -653,8 +653,8 @@ void RecursivelyVisit(callback f, Value *V) {
             RecursivelyVisit<VisitInst, callback>(f, TheUser);
             continue;
         }
-        V->dump();
-        TheUser->dump();
+        llvm_dump(V);
+        llvm_dump(TheUser);
         assert(false && "Unexpected instruction");
     }
 }
@@ -1122,11 +1122,11 @@ bool LateLowerGCFrame::CleanupIR(Function &F) {
     AllocaInst *Frame = nullptr;
     if (T_prjlvalue) {
         T_pprjlvalue = T_prjlvalue->getPointerTo();
-        Frame = new AllocaInst(T_prjlvalue, ConstantInt::get(T_int32, maxframeargs),
+        Frame = new AllocaInst(T_prjlvalue,
 #if JL_LLVM_VERSION >= 50000
         0,
 #endif
-        "", StartOff);
+        ConstantInt::get(T_int32, maxframeargs), "", StartOff);
     }
     for (BasicBlock &BB : F) {
         for (auto it = BB.begin(); it != BB.end();) {

From de4aba3f7632080f327c141cc571a20fff7a0dc7 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sun, 30 Jul 2017 00:48:58 -0400
Subject: [PATCH 2/2] Workaround InstCombiner::transformConstExprCastCall for
 jlcall

By declaring jlcall functions as `thunk`.
---
 src/codegen.cpp               | 14 ++++++++++++--
 src/llvm-late-gc-lowering.cpp |  9 +++++++--
 2 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/src/codegen.cpp b/src/codegen.cpp
index 408fc668f40d..755a2e86397f 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -1581,7 +1581,9 @@ void *jl_get_llvmf_decl(jl_method_instance_t *linfo, size_t world, bool getwrapp
     }
 
     if (getwrapper || !decls.specFunctionObject) {
-        return Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage, decls.functionObject);
+        auto f = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage, decls.functionObject);
+        f->addFnAttr("thunk");
+        return f;
     }
     else {
         jl_returninfo_t returninfo = get_specsig_function(NULL, decls.specFunctionObject, linfo->specTypes, linfo->rettype);
@@ -2881,7 +2883,9 @@ static jl_cgval_t emit_call_function_object(jl_method_instance_t *li, jl_llvm_fu
             retval = update_julia_type(ctx, retval, inferred_retty);
         return retval;
     }
-    Value *theFptr = jl_Module->getOrInsertFunction(decls.functionObject, jl_func_sig);
+    auto theFptr = jl_Module->getOrInsertFunction(decls.functionObject, jl_func_sig);
+    if (auto F = dyn_cast<Function>(theFptr->stripPointerCasts()))
+        F->addFnAttr("thunk");
     Value *ret = emit_jlcall(ctx, theFptr, boxed(ctx, argv[0]), &argv[1], nargs - 1);
     return mark_julia_type(ctx, ret, true, inferred_retty);
 }
@@ -4265,6 +4269,7 @@ static Function *gen_cfun_wrapper(jl_function_t *ff, jl_value_t *jlrettype, jl_t
                 else {
                     assert(theFptr->getFunctionType() == jl_func_sig);
                 }
+                theFptr->addFnAttr("thunk");
             }
         }
         BasicBlock *b_generic, *b_jlcall, *b_after;
@@ -4441,6 +4446,7 @@ static Function *gen_jlcall_wrapper(jl_method_instance_t *lam, const jl_returnin
 {
     Function *w = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage,
                                    funcName, M);
+    w->addFnAttr("thunk");
     jl_init_function(w);
     w->addFnAttr("no-frame-pointer-elim", "true");
     Function::arg_iterator AI = w->arg_begin();
@@ -4848,6 +4854,7 @@ static std::unique_ptr<Module> emit_function(
         f = Function::Create(needsparams ? jl_func_sig_sparams : jl_func_sig,
                              GlobalVariable::ExternalLinkage,
                              funcName.str(), M);
+        f->addFnAttr("thunk");
         returninfo.decl = f;
         jl_init_function(f);
         declarations->functionObject = strdup(f->getName().str().c_str());
@@ -5793,6 +5800,7 @@ static GlobalVariable *julia_const_gv(jl_value_t *val)
 static Function *jlcall_func_to_llvm(const std::string &cname, jl_fptr_t addr, Module *m)
 {
     Function *f = Function::Create(jl_func_sig, Function::ExternalLinkage, cname, m);
+    f->addFnAttr("thunk");
     add_named_global(f, addr);
     return f;
 }
@@ -6120,6 +6128,7 @@ static void init_julia_llvm_env(Module *m)
     jlnew_func =
         Function::Create(jl_func_sig, Function::ExternalLinkage,
                          "jl_new_structv", m);
+    jlnew_func->addFnAttr("thunk");
     add_named_global(jlnew_func, &jl_new_structv);
 
     std::vector<Type*> args2(0);
@@ -6236,6 +6245,7 @@ static void init_julia_llvm_env(Module *m)
     jlapplygeneric_func = Function::Create(FunctionType::get(T_prjlvalue, agargs, false),
                                            Function::ExternalLinkage,
                                            "jl_apply_generic", m);
+    jlapplygeneric_func->addFnAttr("thunk");
     add_named_global(jlapplygeneric_func, &jl_apply_generic);
 
     std::vector<Type *> invokeargs(0);
diff --git a/src/llvm-late-gc-lowering.cpp b/src/llvm-late-gc-lowering.cpp
index a7c1ec1c052c..da97ce56b3a2 100644
--- a/src/llvm-late-gc-lowering.cpp
+++ b/src/llvm-late-gc-lowering.cpp
@@ -1177,7 +1177,8 @@ bool LateLowerGCFrame::CleanupIR(Function &F) {
             } else if (CC == JLCALL_CC ||
                        CC == JLCALL_F_CC) {
                 assert(T_prjlvalue);
-                size_t nframeargs = CI->getNumArgOperands() - (CC == JLCALL_F_CC);
+                size_t nargs = CI->getNumArgOperands();
+                size_t nframeargs = nargs - (CC == JLCALL_F_CC);
                 SmallVector<Value *, 3> ReplacementArgs;
                 auto it = CI->arg_begin();
                 if (CC == JLCALL_F_CC)
@@ -1201,7 +1202,11 @@ bool LateLowerGCFrame::CleanupIR(Function &F) {
                 Value *newFptr = Builder.CreateBitCast(callee, FTy->getPointerTo());
                 CallInst *NewCall = CallInst::Create(newFptr, ReplacementArgs, "", CI);
                 NewCall->setTailCallKind(CI->getTailCallKind());
-                NewCall->setAttributes(CI->getAttributes());
+                auto old_attrs = CI->getAttributes();
+                // LLVM 5.0 use AttributeList::get
+                NewCall->setAttributes(old_attrs.get(CI->getContext(),
+                                                     old_attrs.getFnAttributes(),
+                                                     old_attrs.getRetAttributes(), {}));
                 NewCall->setDebugLoc(CI->getDebugLoc());
                 CI->replaceAllUsesWith(NewCall);
             } else if (CI->getNumArgOperands() == CI->getNumOperands()) {

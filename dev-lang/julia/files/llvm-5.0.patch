--- a/src/codegen.cpp	2017-07-23 15:36:48.828758440 +0200
+++ b/src/codegen.cpp	2017-07-23 16:00:02.212371694 +0200
@@ -1422,8 +1422,12 @@
     uint64_t addr = getAddressForFunction(llvmf);
 #ifdef USE_ORCJIT
     if (!addr)
+#if JL_LLVM_VERSION >= 50000
+        addr = jl_ExecutionEngine->findUnmangledSymbol(llvmf->getName()).getAddress().get();
+#else
         addr = jl_ExecutionEngine->findUnmangledSymbol(llvmf->getName()).getAddress();
 #endif
+#endif
     return addr;
 }
 
--- a/src/cgutils.cpp	2017-07-23 15:53:22.692066858 +0200
+++ b/src/cgutils.cpp	2017-07-23 15:54:38.387943157 +0200
@@ -2390,7 +2390,9 @@
     builder.CreateCall(InlineAsm::get(FunctionType::get(T_void, false), "",
                                       "~{memory}", true));
 #else
-#  if JL_LLVM_VERSION >= 30900
+#  if JL_LLVM_VERSION >= 50000
+    builder.CreateFence(AtomicOrdering::SequentiallyConsistent, llvm::SyncScope::SingleThread);
+#  elif JL_LLVM_VERSION >= 30900
     builder.CreateFence(AtomicOrdering::SequentiallyConsistent, SingleThread);
 #  else
     builder.CreateFence(SequentiallyConsistent, SingleThread);
--- a/src/ccall.cpp	2017-07-23 16:00:09.820358633 +0200
+++ b/src/ccall.cpp	2017-07-23 16:06:02.570735535 +0200
@@ -1275,7 +1275,7 @@
     assert(rt && !jl_is_abstract_ref_type(rt));
 
 #if JL_LLVM_VERSION >= 50000
-    std::vector<AttributeList> paramattrs;
+    std::vector<AttrBuilder> paramattrs;
 #else
     std::vector<AttributeSet> paramattrs;
 #endif
@@ -1302,7 +1302,7 @@
 #endif
             retattrs.addAttribute(Attribute::NoAlias);
 #if JL_LLVM_VERSION >= 50000
-            paramattrs.push_back(AttributeList::get(jl_LLVMContext, 1, retattrs));
+            paramattrs.push_back(std::move(retattrs));
 #else
             paramattrs.push_back(AttributeSet::get(jl_LLVMContext, 1, retattrs));
 #endif
@@ -1388,24 +1388,25 @@
         do { // for each arg for which this type applies, add the appropriate LLVM parameter attributes
             if (i < nargs) { // if vararg, the last declared arg type may not have a corresponding arg value
 #if JL_LLVM_VERSION >= 50000
-                AttributeList params = AttributeList::get(jl_LLVMContext, i + sret + 1, ab);
+                paramattrs.push_back(std::move(ab));
 #else
                 AttributeSet params = AttributeSet::get(jl_LLVMContext, i + sret + 1, ab);
-#endif
                 paramattrs.push_back(params);
+#endif
             }
             i++;
         } while (current_isVa && i < nargs); // if is this is the vararg, loop to the end
     }
 
     for (i = 0; i < nargs + sret; ++i) {
+        const auto &as = paramattrs.at(i);
 #if JL_LLVM_VERSION >= 50000
-        const AttributeList &as = paramattrs.at(i);
+        if (!as.hasAttributes())
+            continue;
 #else
-        const AttributeSet &as = paramattrs.at(i);
-#endif
         if (!as.isEmpty())
             attributes = attributes.addAttributes(jl_LLVMContext, i + 1, as);
+#endif
     }
     if (rt == jl_bottom_type) {
         attributes = attributes.addAttribute(jl_LLVMContext,
--- a/src/disasm.cpp	2017-07-23 17:37:48.784007175 +0200
+++ b/src/disasm.cpp	2017-07-23 17:39:03.607872838 +0200
@@ -28,8 +28,13 @@
 
 #include "llvm-version.h"
 #include <llvm/Object/ObjectFile.h>
+#if JL_LLVM_VERSION >= 50000
+#include <llvm/BinaryFormat/MachO.h>
+#include <llvm/BinaryFormat/COFF.h>
+#else
 #include <llvm/Support/MachO.h>
 #include <llvm/Support/COFF.h>
+#endif
 #include <llvm/MC/MCInst.h>
 #include <llvm/MC/MCStreamer.h>
 #include <llvm/MC/MCSubtargetInfo.h>
--- a/src/debuginfo.cpp	2017-07-23 17:39:26.487832598 +0200
+++ b/src/debuginfo.cpp	2017-07-23 17:40:35.031711913 +0200
@@ -1009,7 +1009,11 @@
 
     auto error_splitobj = object::ObjectFile::createObjectFile(
             SplitFile.get().get()->getMemBufferRef(),
+#if JL_LLVM_VERSION >= 50000
+            file_magic::unknown);
+#else
             sys::fs::file_magic::unknown);
+#endif
     if (!error_splitobj) {
 #if JL_LLVM_VERSION >= 30900
         return error_splitobj.takeError();
@@ -1181,7 +1185,12 @@
         std::unique_ptr<MemoryBuffer> membuf = MemoryBuffer::getMemBuffer(
                 StringRef((const char *)fbase, msize), "", false);
         auto origerrorobj = llvm::object::ObjectFile::createObjectFile(
-            membuf->getMemBufferRef(), sys::fs::file_magic::unknown);
+            membuf->getMemBufferRef(),
+#if JL_LLVM_VERSION >= 50000
+            file_magic::unknown);
+#else
+            sys::fs::file_magic::unknown);
+#endif
 #elif JL_LLVM_VERSION >= 30500
         MemoryBuffer *membuf = MemoryBuffer::getMemBuffer(
             StringRef((const char *)fbase, msize), "", false);
--- a/src/cgmemmgr.cpp	2017-07-23 17:41:49.479581648 +0200
+++ b/src/cgmemmgr.cpp	2017-07-23 17:42:44.799484730 +0200
@@ -744,8 +744,6 @@
     }
     void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,
                           size_t Size) override;
-    void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr,
-                            size_t Size) override;
     uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,
                                  unsigned SectionID,
                                  StringRef SectionName) override;
@@ -871,14 +869,6 @@
         pending_eh.push_back(EHFrame{(uint8_t*)(uintptr_t)LoadAddr, Size});
     }
 }
-
-void RTDyldMemoryManagerJL::deregisterEHFrames(uint8_t *Addr,
-                                               uint64_t LoadAddr,
-                                               size_t Size)
-{
-    deregister_eh_frames((uint8_t*)LoadAddr, Size);
-}
-
 }
 
 #if JL_LLVM_VERSION < 30800
--- a/jitlayers.cpp	2017-07-23 16:06:37.115674272 +0200
+++ b/jitlayers.cpp	2017-07-24 00:18:55.086041693 +0200
@@ -385,16 +385,22 @@
                                          const object::ObjectFile &obj,
                                          const object::ObjectFile &debugObj,
                                          const RuntimeDyld::LoadedObjectInfo &L,
-                                         RTDyldMemoryManager *memmgr);
+                                         std::shared_ptr<RTDyldMemoryManager> memmgr);
 
 // TODO: hook up RegisterJITEventListener, instead of hard-coding the GDB and JuliaListener targets
+#if JL_LLVM_VERSION >= 50000
+void JuliaOJIT::DebugObjectRegistrar::operator()(RTDyldObjectLinkingLayerBase::ObjHandleT H,
+                const RTDyldObjectLinkingLayer::ObjectPtr &Obj, const LoadedObjectInfo &l_LO)
+#else
 template <typename ObjSetT, typename LoadResult>
 void JuliaOJIT::DebugObjectRegistrar::operator()(RTDyldObjectLinkingLayerBase::ObjSetHandleT H,
                 const ObjSetT &Objects, const LoadResult &LOS)
+#endif
 {
 #if JL_LLVM_VERSION < 30800
     notifyObjectLoaded(JIT.MemMgr, H);
 #endif
+#if JL_LLVM_VERSION < 50000
     auto oit = Objects.begin();
     auto lit = LOS.begin();
     for (; oit != Objects.end(); ++oit, ++lit) {
@@ -404,8 +410,15 @@
         auto &Object = *oit;
 #endif
         auto &LO = *lit;
+#endif
 
+#if JL_LLVM_VERSION >= 50000
+        auto &LO = static_cast<const RuntimeDyld::LoadedObjectInfo&>(l_LO);
+        auto Object = Obj->getBinary();
+        OwningBinary<object::ObjectFile> SavedObject = LO.getObjectForDebug(*Object);
+#else
         OwningBinary<object::ObjectFile> SavedObject = LO->getObjectForDebug(*Object);
+#endif
 
         // If the debug object is unavailable, save (a copy of) the original object
         // for our backtraces
@@ -428,7 +441,11 @@
         ORCNotifyObjectEmitted(JuliaListener.get(),
                 *Object,
                 *SavedObjects.back().getBinary(),
+#if JL_LLVM_VERSION >= 50000
+                LO, JIT.MemMgr);
+#else
                 *LO, JIT.MemMgr);
+#endif
 
         // record all of the exported symbols defined in this object
         // in the primary hash table for the enclosing JIT
@@ -446,9 +463,18 @@
             // note: calling getAddress here eagerly finalizes H
             // as an alternative, we could store the JITSymbol instead
             // (which would present a lazy-initializer functor interface instead)
+#if JL_LLVM_VERSION >= 50000
+           if (auto AddrOrErr = Sym.getAddress())
+                JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)*AddrOrErr;
+           else
+                report_fatal_error(AddrOrErr.takeError());
+#else
             JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)Sym.getAddress();
+#endif
         }
+#if JL_LLVM_VERSION < 50000
     }
+#endif
 }
 
 void JuliaOJIT::DebugObjectRegistrar::NotifyGDB(OwningBinary<object::ObjectFile> &DebugObj)
@@ -475,7 +501,14 @@
     DL(TM.createDataLayout()),
     ObjStream(ObjBufferSV),
     MemMgr(createRTDyldMemoryManager()),
+#if JL_LLVM_VERSION >= 50000
+    DebugObjectRegistrar(*this),
+    ObjectLayer([this]() { return this->MemMgr; }, [=] (RTDyldObjectLinkingLayerBase::ObjHandleT H,
+                            const RTDyldObjectLinkingLayerBase::ObjectPtr &Obj, const LoadedObjectInfo &Info) {
+                            DebugObjectRegistrar.operator()(H, Obj, Info); } ),
+#else
     ObjectLayer(DebugObjectRegistrar(*this)),
+#endif
     CompileLayer(
             ObjectLayer,
             [this](Module &M) {
@@ -606,18 +639,26 @@
                       },
                       [](const std::string &S) { return nullptr; }
                     );
+#if JL_LLVM_VERSION >= 50000
+    auto modset = cantFail(CompileLayer.addModule(std::move(M), std::move(Resolver)));
+#else
     SmallVector<std::unique_ptr<Module>,1> Ms;
     Ms.push_back(std::move(M));
     auto modset = CompileLayer.addModuleSet(std::move(Ms), MemMgr,
                                             std::move(Resolver));
+#endif
     // Force LLVM to emit the module so that we can register the symbols
     // in our lookup table.
-    CompileLayer.emitAndFinalize(modset);
+    (void)CompileLayer.emitAndFinalize(modset);
 }
 
 void JuliaOJIT::removeModule(ModuleHandleT H)
 {
+#if JL_LLVM_VERSION >= 50000
+    (void)CompileLayer.removeModule(H);
+#else
     CompileLayer.removeModuleSet(H);
+#endif
 }
 
 JL_JITSymbol JuliaOJIT::findSymbol(const std::string &Name, bool ExportedSymbolsOnly)
@@ -640,12 +681,32 @@
 
 uint64_t JuliaOJIT::getGlobalValueAddress(const std::string &Name)
 {
+#if JL_LLVM_VERSION >= 50000
+    if (auto Sym = findSymbol(getMangledName(Name), false)) {
+        if (auto AddrOrErr = Sym.getAddress())
+            return *AddrOrErr;
+        else
+            report_fatal_error(AddrOrErr.takeError());
+    } else
+        report_fatal_error(Sym.takeError());
+#else
     return findSymbol(getMangledName(Name), false).getAddress();
+#endif
 }
 
 uint64_t JuliaOJIT::getFunctionAddress(const std::string &Name)
 {
+#if JL_LLVM_VERSION >= 50000
+    if (auto Sym = findSymbol(getMangledName(Name), false)) {
+        if (auto AddrOrErr = Sym.getAddress())
+            return *AddrOrErr;
+        else
+            report_fatal_error(AddrOrErr.takeError());
+    } else
+        report_fatal_error(Sym.takeError());
+#else
     return findSymbol(getMangledName(Name), false).getAddress();
+#endif
 }
 
 Function *JuliaOJIT::FindFunctionNamed(const std::string &Name)
--- a/jitlayers.h	2017-07-23 15:39:27.164505777 +0200
+++ b/jitlayers.h	2017-07-24 00:21:21.477771089 +0200
@@ -6,6 +6,7 @@
 #include <llvm/IR/Value.h>
 
 #include <llvm/ExecutionEngine/SectionMemoryManager.h>
+#include <llvm/ExecutionEngine/JITEventListener.h>
 #if defined(USE_ORCJIT)
 #include "llvm/ExecutionEngine/Orc/CompileUtils.h"
 #include "llvm/ExecutionEngine/Orc/IRCompileLayer.h"
@@ -26,7 +27,9 @@
 #include <llvm/ExecutionEngine/JITMemoryManager.h>
 #include <llvm/ExecutionEngine/Interpreter.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
-#include <llvm/ExecutionEngine/JITEventListener.h>
+#endif
+#if JL_LLVM_VERSION >= 50000
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
 #endif
 
 #if JL_LLVM_VERSION >= 30700
@@ -184,9 +187,15 @@
     class DebugObjectRegistrar {
     public:
         DebugObjectRegistrar(JuliaOJIT &JIT);
+#if JL_LLVM_VERSION >= 50000
+        void operator()(RTDyldObjectLinkingLayerBase::ObjHandleT H,
+                        const RTDyldObjectLinkingLayer::ObjectPtr &Obj,
+                        const LoadedObjectInfo &Info);
+#else
         template <typename ObjSetT, typename LoadResult>
         void operator()(RTDyldObjectLinkingLayerBase::ObjSetHandleT H, const ObjSetT &Objects,
                         const LoadResult &LOS);
+#endif
     private:
         void NotifyGDB(object::OwningBinary<object::ObjectFile> &DebugObj);
         std::vector<object::OwningBinary<object::ObjectFile>> SavedObjects;
@@ -195,9 +204,17 @@
     };
 
 public:
+#if JL_LLVM_VERSION >= 50000
+    typedef RTDyldObjectLinkingLayer ObjLayerT;
+    using NotifyFinalizedFtor = std::function<void(RTDyldObjectLinkingLayerBase::ObjHandleT)>;
+    typedef std::function<object::OwningBinary<object::ObjectFile>(Module &)> CompileFtor;
+    typedef orc::IRCompileLayer<ObjLayerT, CompileFtor> CompileLayerT;
+    typedef CompileLayerT::ModuleHandleT ModuleHandleT;
+#else
     typedef RTDyldObjectLinkingLayer<DebugObjectRegistrar> ObjLayerT;
     typedef orc::IRCompileLayer<ObjLayerT> CompileLayerT;
     typedef CompileLayerT::ModuleSetHandleT ModuleHandleT;
+#endif
     typedef StringMap<void*> SymbolTableT;
     typedef object::OwningBinary<object::ObjectFile> OwningObj;
 
@@ -229,7 +246,10 @@
     raw_svector_ostream ObjStream;
     legacy::PassManager PM;
     MCContext *Ctx;
-    RTDyldMemoryManager *MemMgr;
+    std::shared_ptr<RTDyldMemoryManager> MemMgr;
+#if JL_LLVM_VERSION >= 50000
+    DebugObjectRegistrar DebugObjectRegistrar;
+#endif
     ObjLayerT ObjectLayer;
     CompileLayerT CompileLayer;
     SymbolTableT GlobalSymbolTable;

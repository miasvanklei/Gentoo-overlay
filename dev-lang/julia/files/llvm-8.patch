diff --git a/src/Makefile b/src/Makefile
index 629b78d081c6..b3fdaa658191 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -184,7 +184,7 @@ endif
 	mv $@.tmp $@
 	$(INSTALL_NAME_CMD)libccalltest.$(SHLIB_EXT) $@
 
-$(build_shlibdir)/libllvmcalltest.$(SHLIB_EXT): $(SRCDIR)/llvmcalltest.cpp
+$(build_shlibdir)/libllvmcalltest.$(SHLIB_EXT): $(SRCDIR)/llvmcalltest.cpp $(LLVM_CONFIG_ABSOLUTE)
 	@$(call PRINT_CC, $(CXX) $(shell $(LLVM_CONFIG_HOST) --cxxflags) $(JCXXFLAGS) $(JCPPFLAGS) $(DEBUGFLAGS) -O3 $< $(fPIC) -shared -o $@ $(JLDFLAGS) -L$(build_shlibdir) -L$(build_libdir) $(NO_WHOLE_ARCHIVE) $(LLVMLINK))
 
 julia_flisp.boot.inc.phony: $(BUILDDIR)/julia_flisp.boot.inc
@@ -201,7 +201,7 @@ $(BUILDDIR)/julia_flisp.boot: $(addprefix $(SRCDIR)/,jlfrontend.scm flisp/aliase
 # additional dependency links
 $(BUILDDIR)/ast.o $(BUILDDIR)/ast.dbg.obj: $(BUILDDIR)/julia_flisp.boot.inc $(SRCDIR)/flisp/*.h
 $(BUILDDIR)/codegen.o $(BUILDDIR)/codegen.dbg.obj: $(addprefix $(SRCDIR)/,\
-	intrinsics.cpp jitlayers.h intrinsics.h debuginfo.h codegen_shared.h cgutils.cpp ccall.cpp abi_*.cpp processor.h)
+	intrinsics.cpp jitlayers.h intrinsics.h codegen_shared.h cgutils.cpp ccall.cpp abi_*.cpp processor.h)
 $(BUILDDIR)/processor.o $(BUILDDIR)/processor.dbg.obj: $(addprefix $(SRCDIR)/,processor_*.cpp processor.h features_*.h)
 $(BUILDDIR)/interpreter.o $(BUILDDIR)/interpreter.dbg.obj: $(SRCDIR)/interpreter-stacktrace.c
 $(BUILDDIR)/anticodegen.o $(BUILDDIR)/anticodegen.dbg.obj: $(SRCDIR)/intrinsics.h
diff --git a/src/ccall.cpp b/src/ccall.cpp
index e8fe4ef3a771..0e696ec64734 100644
--- a/src/ccall.cpp
+++ b/src/ccall.cpp
@@ -789,7 +789,12 @@ class FunctionMover final : public ValueMaterializer
         Function *F = dyn_cast<Function>(V);
         if (F) {
             if (isIntrinsicFunction(F)) {
-                return destModule->getOrInsertFunction(F->getName(),F->getFunctionType());
+                auto Fcopy = destModule->getOrInsertFunction(F->getName(), F->getFunctionType());
+#if JL_LLVM_VERSION >= 90000
+                return Fcopy.getCallee();
+#else
+                return Fcopy;
+#endif
             }
             if (F->isDeclaration() || F->getParent() != destModule) {
                 if (F->getName().empty())
@@ -1880,7 +1885,12 @@ jl_cgval_t function_sig_t::emit_a_ccall(
             bool f_extern = (strncmp(f_name, "extern ", 7) == 0);
             if (f_extern)
                 f_name += 7;
-            llvmf = jl_Module->getOrInsertFunction(f_name, functype);
+            llvmf = jl_Module->getOrInsertFunction(f_name, functype)
+#if JL_LLVM_VERSION >= 90000
+                .getCallee();
+#else
+                ;
+#endif
             if (!f_extern &&
                 (!isa<Function>(llvmf) ||
                  cast<Function>(llvmf)->getIntrinsicID() == Intrinsic::not_intrinsic))
diff --git a/src/codegen.cpp b/src/codegen.cpp
index 5c905bde8ee8..b927dda80d56 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -3,14 +3,9 @@
 #include "llvm-version.h"
 #include "platform.h"
 #include "options.h"
-#if defined(_OS_WINDOWS_) && JL_LLVM_VERSION < 70000
-// trick llvm into skipping the generation of _chkstk calls
-//   since it has some codegen issues associated with them:
-//   (a) assumed to be within 32-bit offset
-//   (b) bad asm is generated for certain code patterns:
-//       see https://github.com/JuliaLang/julia/pull/11644#issuecomment-112276813
-// also, use ELF because RuntimeDyld COFF I686 support didn't exist
-// also, use ELF because RuntimeDyld COFF X86_64 doesn't seem to work (fails to generate function pointers)?
+#if defined(_OS_WINDOWS_)
+// use ELF because RuntimeDyld COFF i686 support didn't exist
+// use ELF because RuntimeDyld COFF X86_64 doesn't seem to work (fails to generate function pointers)?
 #define FORCE_ELF
 #endif
 #if defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)
@@ -87,6 +82,10 @@
 
 using namespace llvm;
 
+#if JL_LLVM_VERSION >= 80000
+typedef Instruction TerminatorInst;
+#endif
+
 #if defined(_OS_WINDOWS_) && !defined(NOMINMAX)
 #define NOMINMAX
 #endif
@@ -3171,7 +3170,12 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, jl_code_instance_t
 static jl_cgval_t emit_call_specfun_boxed(jl_codectx_t &ctx, StringRef specFunctionObject,
                                           jl_cgval_t *argv, size_t nargs, jl_value_t *inferred_retty)
 {
-    auto theFptr = jl_Module->getOrInsertFunction(specFunctionObject, jl_func_sig);
+    auto theFptr = jl_Module->getOrInsertFunction(specFunctionObject, jl_func_sig)
+#if JL_LLVM_VERSION >= 90000
+                .getCallee();
+#else
+                ;
+#endif
     if (auto F = dyn_cast<Function>(theFptr->stripPointerCasts())) {
         add_return_attr(F, Attribute::NonNull);
         F->addFnAttr(Thunk);
@@ -5649,18 +5653,28 @@ static std::unique_ptr<Module> emit_function(
         else {
             subrty = get_specsig_di(jlrettype, lam->specTypes, topfile, dbuilder);
         }
-        SP = dbuilder.createFunction(CU,
-                                     dbgFuncName,      // Name
-                                     f->getName(),     // LinkageName
-                                     topfile,          // File
-                                     toplineno,        // LineNo
-                                     subrty,           // Ty
-                                     false,            // isLocalToUnit
-                                     true,             // isDefinition
-                                     toplineno,        // ScopeLine
-                                     DIFlagZero,       // Flags
-                                     true,             // isOptimized
-                                     nullptr);         // Template Parameters
+        SP = dbuilder.createFunction(CU
+                                     ,dbgFuncName      // Name
+                                     ,f->getName()     // LinkageName
+                                     ,topfile          // File
+                                     ,toplineno        // LineNo
+                                     ,subrty           // Ty
+#if JL_LLVM_VERSION < 80000
+                                     ,false            // isLocalToUnit
+                                     ,true             // isDefinition
+#endif
+                                     ,toplineno        // ScopeLine
+                                     ,DIFlagZero       // Flags
+#if JL_LLVM_VERSION < 80000
+                                     ,true             // isOptimized
+                                     ,nullptr          // Template Parameters
+#else
+                                     ,DISubprogram::SPFlagDefinition | DISubprogram::SPFlagOptimized // SPFlags
+                                     ,nullptr          // Template Parameters
+                                     ,nullptr          // Template Declaration
+                                     ,nullptr          // ThrownTypes
+#endif
+                                     );
         topdebugloc = DebugLoc::get(toplineno, 0, SP, NULL);
         f->setSubprogram(SP);
         if (jl_options.debug_level >= 2) {
@@ -6073,10 +6087,28 @@ static std::unique_ptr<Module> emit_function(
                     DISubprogram *&inl_SP = subprograms[std::make_tuple(fname, info.file)];
                     if (inl_SP == NULL) {
                         DIFile *difile = dbuilder.createFile(info.file, ".");
-                        inl_SP = dbuilder.createFunction(
-                                difile, std::string(fname) + ";",
-                                fname, difile, 0, jl_di_func_null_sig,
-                                false, true, 0, DIFlagZero, true, nullptr);
+                        inl_SP = dbuilder.createFunction(difile
+                                                     ,std::string(fname) + ";" // Name
+                                                     ,fname            // LinkageName
+                                                     ,difile           // File
+                                                     ,0                // LineNo
+                                                     ,jl_di_func_null_sig // Ty
+#if JL_LLVM_VERSION < 80000
+                                                     ,false            // isLocalToUnit
+                                                     ,true             // isDefinition
+#endif
+                                                     ,0                // ScopeLine
+                                                     ,DIFlagZero       // Flags
+#if JL_LLVM_VERSION < 80000
+                                                     ,true             // isOptimized
+                                                     ,nullptr          // Template Parameters
+#else
+                                                     ,DISubprogram::SPFlagDefinition | DISubprogram::SPFlagOptimized // SPFlags
+                                                     ,nullptr          // Template Parameters
+                                                     ,nullptr          // Template Declaration
+                                                     ,nullptr          // ThrownTypes
+#endif
+                                                     );
                     }
                     DebugLoc inl_loc = (info.inlined_at == 0) ? DebugLoc::get(0, 0, SP, NULL) : linetable.at(info.inlined_at).loc;
                     info.loc = DebugLoc::get(info.line, 0, inl_SP, inl_loc);
@@ -7594,6 +7626,12 @@ extern "C" void *jl_init_llvm(void)
 #if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)
     const char *const argv_copyprop[] = {"", "-disable-copyprop"}; // llvm bug 21743
     cl::ParseCommandLineOptions(sizeof(argv_copyprop)/sizeof(argv_copyprop[0]), argv_copyprop, "disable-copyprop\n");
+#endif
+#if JL_LLVM_VERSION >= 70000
+#if defined(_CPU_X86_) || defined(_CPU_X86_64_)
+    const char *const argv_avoidsfb[] = {"", "-x86-disable-avoid-SFB"}; // llvm bug 41629, see https://gist.github.com/vtjnash/192cab72a6cfc00256ff118238163b55
+    cl::ParseCommandLineOptions(sizeof(argv_avoidsfb)/sizeof(argv_avoidsfb[0]), argv_avoidsfb, "disable-avoidsfb\n");
+#endif
 #endif
     cl::ParseEnvironmentOptions("Julia", "JULIA_LLVM_ARGS");
 
diff --git a/src/debuginfo.cpp b/src/debuginfo.cpp
index 28bbba2a094a..dedfaae57d89 100644
--- a/src/debuginfo.cpp
+++ b/src/debuginfo.cpp
@@ -492,7 +492,7 @@ static int lookup_pointer(DIContext *context, jl_frame_t **frames,
     DILineInfoSpecifier infoSpec(DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath,
                                  DILineInfoSpecifier::FunctionNameKind::ShortName);
 
-    auto inlineInfo = context->getInliningInfoForAddress(pointer, infoSpec);
+    auto inlineInfo = context->getInliningInfoForAddress(makeAddress(pointer), infoSpec);
 
     int fromC = (*frames)[0].fromC;
     int n_frames = inlineInfo.getNumberOfFrames();
@@ -516,7 +516,7 @@ static int lookup_pointer(DIContext *context, jl_frame_t **frames,
             info = inlineInfo.getFrame(i);
         }
         else {
-            info = context->getLineInfoForAddress(pointer, infoSpec);
+            info = context->getLineInfoForAddress(makeAddress(pointer), infoSpec);
         }
 
         jl_frame_t *frame = &(*frames)[i];
diff --git a/src/debuginfo.h b/src/debuginfo.h
index 4acf509e8fd3..b7b532968f84 100644
--- a/src/debuginfo.h
+++ b/src/debuginfo.h
@@ -9,3 +9,15 @@ extern int jl_DI_for_fptr(uint64_t fptr, uint64_t *symsize, int64_t *slide, int6
 extern bool jl_dylib_DI_for_fptr(size_t pointer, const object::ObjectFile **object, llvm::DIContext **context,
         int64_t *slide, int64_t *section_slide,
         bool onlySysImg, bool *isSysImg, void **saddr, char **name, char **filename);
+
+#if JL_LLVM_VERSION >= 90000
+static object::SectionedAddress makeAddress(uint64_t address)
+{
+    return object::SectionedAddress(address, object::SectionedAddress::UndefSection);
+}
+#else
+static uint64_t makeAddress(uint64_t address)
+{
+    return address;
+}
+#endif
diff --git a/src/disasm.cpp b/src/disasm.cpp
index 34c3597cc7e5..93087b9f4240 100644
--- a/src/disasm.cpp
+++ b/src/disasm.cpp
@@ -737,6 +737,7 @@ static int OpInfoLookup(void *DisInfo, uint64_t PC, uint64_t Offset, uint64_t Si
 }
 } // namespace
 
+
 static void jl_dump_asm_internal(
         uintptr_t Fptr, size_t Fsize, int64_t slide,
         const object::ObjectFile *object,
@@ -831,7 +832,7 @@ static void jl_dump_asm_internal(
 
     DILineInfoTable di_lineinfo;
     if (di_ctx)
-        di_lineinfo = di_ctx->getLineInfoForAddressRange(Fptr+slide, Fsize);
+        di_lineinfo = di_ctx->getLineInfoForAddressRange(makeAddress(Fptr + slide), Fsize);
     if (!di_lineinfo.empty()) {
         auto cur_addr = di_lineinfo[0].first;
         auto nlineinfo = di_lineinfo.size();
@@ -901,7 +902,7 @@ static void jl_dump_asm_internal(
                     std::string buf;
                     DILineInfoSpecifier infoSpec(DILineInfoSpecifier::FileLineInfoKind::Default,
                                                  DILineInfoSpecifier::FunctionNameKind::ShortName);
-                    DIInliningInfo dbg = di_ctx->getInliningInfoForAddress(Index + Fptr + slide, infoSpec);
+                    DIInliningInfo dbg = di_ctx->getInliningInfoForAddress(makeAddress(Index + Fptr + slide), infoSpec);
                     if (dbg.getNumberOfFrames()) {
                         dbgctx.emit_lineinfo(buf, dbg);
                     }
diff --git a/src/jitlayers.cpp b/src/jitlayers.cpp
index e0aaa9b53bf2..cd68699728c5 100644
--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -315,7 +315,7 @@ void JuliaOJIT::DebugObjectRegistrar::registerObject(RTDyldObjHandleT H, const O
                                                        std::move(NewBuffer));
     }
     else {
-        JIT.NotifyFinalizer(*(SavedObject.getBinary()), *LO);
+        JIT.NotifyFinalizer(H, *(SavedObject.getBinary()), *LO);
     }
 
     SavedObjects.push_back(std::move(SavedObject));
@@ -575,11 +575,17 @@ void JuliaOJIT::RegisterJITEventListener(JITEventListener *L)
     EventListeners.push_back(L);
 }
 
-void JuliaOJIT::NotifyFinalizer(const object::ObjectFile &Obj,
+void JuliaOJIT::NotifyFinalizer(RTDyldObjHandleT Key,
+                                const object::ObjectFile &Obj,
                                 const RuntimeDyld::LoadedObjectInfo &LoadedObjectInfo)
 {
     for (auto &Listener : EventListeners)
+#if JL_LLVM_VERSION >= 80000
+        Listener->notifyObjectLoaded(Key, Obj, LoadedObjectInfo);
+#else
         Listener->NotifyObjectEmitted(Obj, LoadedObjectInfo);
+    (void)Key;
+#endif
 }
 
 const DataLayout& JuliaOJIT::getDataLayout() const
diff --git a/src/jitlayers.h b/src/jitlayers.h
index b58ce874c1ab..1056146f1697 100644
--- a/src/jitlayers.h
+++ b/src/jitlayers.h
@@ -127,13 +127,19 @@ class JuliaOJIT {
     };
 
 public:
+#if JL_LLVM_VERSION >= 80000
+    typedef orc::LegacyRTDyldObjectLinkingLayer ObjLayerT;
+    typedef orc::LegacyIRCompileLayer<ObjLayerT,CompilerT> CompileLayerT;
+    typedef orc::VModuleKey ModuleHandleT;
+#elif JL_LLVM_VERSION >= 70000
     typedef orc::RTDyldObjectLinkingLayer ObjLayerT;
     typedef orc::IRCompileLayer<ObjLayerT,CompilerT> CompileLayerT;
-    #if JL_LLVM_VERSION >= 70000
     typedef orc::VModuleKey ModuleHandleT;
-    #else
+#else
+    typedef orc::RTDyldObjectLinkingLayer ObjLayerT;
+    typedef orc::IRCompileLayer<ObjLayerT,CompilerT> CompileLayerT;
     typedef CompileLayerT::ModuleHandleT ModuleHandleT;
-    #endif
+#endif
     typedef StringMap<void*> SymbolTableT;
     typedef object::OwningBinary<object::ObjectFile> OwningObj;
 
@@ -141,7 +147,9 @@ class JuliaOJIT {
 
     void RegisterJITEventListener(JITEventListener *L);
     std::vector<JITEventListener *> EventListeners;
-    void NotifyFinalizer(const object::ObjectFile &Obj, const RuntimeDyld::LoadedObjectInfo &LoadedObjectInfo);
+    void NotifyFinalizer(RTDyldObjHandleT Key,
+                         const object::ObjectFile &Obj,
+                         const RuntimeDyld::LoadedObjectInfo &LoadedObjectInfo);
     void addGlobalMapping(StringRef Name, uint64_t Addr);
     void addGlobalMapping(const GlobalValue *GV, void *Addr);
     void *getPointerToGlobalIfAvailable(StringRef S);
diff --git a/src/llvm-api.cpp b/src/llvm-api.cpp
index 816843c6b4d6..7d7dcf1e509b 100644
--- a/src/llvm-api.cpp
+++ b/src/llvm-api.cpp
@@ -220,11 +220,14 @@ extern "C" JL_DLLEXPORT LLVMContextRef LLVMExtraGetValueContext(LLVMValueRef V)
     return wrap(&unwrap(V)->getContext());
 }
 
+
+#if JL_LLVM_VERSION < 80000
 extern ModulePass *createNVVMReflectPass();
 extern "C" JL_DLLEXPORT void LLVMExtraAddNVVMReflectPass(LLVMPassManagerRef PM)
 {
     unwrap(PM)->add(createNVVMReflectPass());
 }
+#endif
 
 extern "C" JL_DLLEXPORT void
 LLVMExtraAddTargetLibraryInfoByTiple(const char *T, LLVMPassManagerRef PM)
diff --git a/src/llvm-propagate-addrspaces.cpp b/src/llvm-propagate-addrspaces.cpp
index 7e66a02fd006..9d93155711f9 100644
--- a/src/llvm-propagate-addrspaces.cpp
+++ b/src/llvm-propagate-addrspaces.cpp
@@ -256,7 +256,7 @@ void PropagateJuliaAddrspaces::visitMemSetInst(MemSetInst &MI) {
     Value *Replacement = LiftPointer(MI.getRawDest());
     if (!Replacement)
         return;
-    Value *TheFn = Intrinsic::getDeclaration(MI.getModule(), Intrinsic::memset,
+    Function *TheFn = Intrinsic::getDeclaration(MI.getModule(), Intrinsic::memset,
         {Replacement->getType(), MI.getOperand(1)->getType()});
     MI.setCalledFunction(TheFn);
     MI.setArgOperand(0, Replacement);
@@ -281,7 +281,7 @@ void PropagateJuliaAddrspaces::visitMemTransferInst(MemTransferInst &MTI) {
     }
     if (Dest == MTI.getRawDest() && Src == MTI.getRawSource())
         return;
-    Value *TheFn = Intrinsic::getDeclaration(MTI.getModule(), MTI.getIntrinsicID(),
+    Function *TheFn = Intrinsic::getDeclaration(MTI.getModule(), MTI.getIntrinsicID(),
         {Dest->getType(), Src->getType(),
          MTI.getOperand(2)->getType()});
     MTI.setCalledFunction(TheFn);
diff --git a/src/llvm-ptls.cpp b/src/llvm-ptls.cpp
index 2a18a19bd8e2..62b01736e7d8 100644
--- a/src/llvm-ptls.cpp
+++ b/src/llvm-ptls.cpp
@@ -33,6 +33,10 @@
 
 using namespace llvm;
 
+#if JL_LLVM_VERSION >= 80000
+typedef Instruction TerminatorInst;
+#endif
+
 std::pair<MDNode*,MDNode*> tbaa_make_child(const char *name, MDNode *parent=nullptr,
                                            bool isConstant=false);
 
@@ -213,7 +217,7 @@ void LowerPTLS::fix_ptls_use(CallInst *ptlsStates)
             auto getter = new LoadInst(T_ptls_getter, ptls_slot, "", false, ptlsStates);
             getter->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
             getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(*ctx, None));
-            ptlsStates->setCalledFunction(getter);
+            ptlsStates->setCalledFunction(ptlsStates->getFunctionType(), getter);
             set_ptls_attrs(ptlsStates);
 
             phi->addIncoming(fastTLS, fastTLS->getParent());
@@ -228,7 +232,7 @@ void LowerPTLS::fix_ptls_use(CallInst *ptlsStates)
         auto getter = new LoadInst(T_ptls_getter, ptls_slot, "", false, ptlsStates);
         getter->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
         getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(*ctx, None));
-        ptlsStates->setCalledFunction(getter);
+        ptlsStates->setCalledFunction(ptlsStates->getFunctionType(), getter);
         set_ptls_attrs(ptlsStates);
     }
     else if (jl_tls_offset != -1) {
@@ -238,7 +242,7 @@ void LowerPTLS::fix_ptls_use(CallInst *ptlsStates)
     else {
         // use the address of the actual getter function directly
         auto val = ConstantInt::get(T_size, (uintptr_t)jl_get_ptls_states_getter());
-        ptlsStates->setCalledFunction(ConstantExpr::getIntToPtr(val, T_ptls_getter));
+        ptlsStates->setCalledFunction(ptlsStates->getFunctionType(), ConstantExpr::getIntToPtr(val, T_ptls_getter));
         set_ptls_attrs(ptlsStates);
     }
 #else

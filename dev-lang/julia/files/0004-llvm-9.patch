diff --git a/src/debuginfo.cpp b/src/debuginfo.cpp
index 1a9030227e7c..b732d0b06a7a 100644
--- a/src/debuginfo.cpp
+++ b/src/debuginfo.cpp
@@ -574,7 +574,14 @@ static debug_link_info getDebuglink(const object::ObjectFile &Obj)
         StringRef sName;
         if (!Section.getName(sName) && sName == ".gnu_debuglink") {
             StringRef Contents;
-            if (!Section.getContents(Contents)) {
+#if JL_LLVM_VERSION >= 90000
+            auto found = Section.getContents();
+            if (found)
+                Contents = *found;
+#else
+            bool found = !Section.getContents(Contents);
+#endif
+            if (found) {
                 size_t length = Contents.find('\0');
                 info.filename = Contents.substr(0, length);
                 info.crc32 = *(const uint32_t*)Contents.substr(LLT_ALIGN(length + 1, 4), 4).data();
diff --git a/src/llvm-alloc-opt.cpp b/src/llvm-alloc-opt.cpp
index da62067deb74..2bfa29037a49 100644
--- a/src/llvm-alloc-opt.cpp
+++ b/src/llvm-alloc-opt.cpp
@@ -881,25 +881,38 @@ void Optimizer::replaceIntrinsicUseWith(IntrinsicInst *call, Intrinsic::ID ID,
         args[i] = arg == orig_i ? new_i : arg;
         argTys[i] = args[i]->getType();
     }
+    auto oldfType = call->getFunctionType();
+    auto newfType = FunctionType::get(
+            oldfType->getReturnType(),
+            makeArrayRef(argTys).slice(0, oldfType->getNumParams()),
+            oldfType->isVarArg());
 
     // Accumulate an array of overloaded types for the given intrinsic
+    // and compute the new name mangling schema
     SmallVector<Type*, 4> overloadTys;
     {
         SmallVector<Intrinsic::IITDescriptor, 8> Table;
         getIntrinsicInfoTableEntries(ID, Table);
         ArrayRef<Intrinsic::IITDescriptor> TableRef = Table;
-        auto oldfType = call->getFunctionType();
+#if JL_LLVM_VERSION >= 90000
+        auto res = Intrinsic::matchIntrinsicSignature(newfType, TableRef, overloadTys);
+        assert(res == Intrinsic::MatchIntrinsicTypes_Match);
+        (void)res;
+#else
         bool res = Intrinsic::matchIntrinsicType(oldfType->getReturnType(), TableRef, overloadTys);
         assert(!res);
-        for (auto Ty : argTys) {
+        for (auto Ty : newfType->params()) {
             res = Intrinsic::matchIntrinsicType(Ty, TableRef, overloadTys);
             assert(!res);
         }
-        res = Intrinsic::matchIntrinsicVarArg(oldfType->isVarArg(), TableRef);
-        assert(!res);
         (void)res;
+#endif
+        bool matchvararg = Intrinsic::matchIntrinsicVarArg(newfType->isVarArg(), TableRef);
+        assert(!matchvararg);
+        (void)matchvararg;
     }
     auto newF = Intrinsic::getDeclaration(call->getModule(), ID, overloadTys);
+    assert(newF->getFunctionType() == newfType);
     newF->setCallingConv(call->getCallingConv());
     auto newCall = CallInst::Create(newF, args, "", call);
     newCall->setTailCallKind(call->getTailCallKind());


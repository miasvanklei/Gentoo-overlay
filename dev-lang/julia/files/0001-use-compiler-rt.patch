--- /dev/null
+++ b/src/builtins.cpp
@@ -0,0 +1,28 @@
+#include <stdint.h>
+
+extern "C" unsigned long long __udivmodti4 (unsigned long long a, unsigned long long b, unsigned long long *c);
+extern "C" unsigned long long __umodti3 (unsigned long long a, unsigned long long b);
+extern "C" unsigned long long __udivti3 (unsigned long long a, unsigned long long b);
+extern "C" long long __divti3 (long long a, long long b);
+
+constexpr unsigned int str2int(const char* str, int h = 0)
+{
+    return !str[h] ? 5381 : (str2int(str, h+1) * 33) ^ str[h];
+}
+
+// Resolve functions from compiler_rt. Since compiler_rt is a static library
+// and not a dynamic one, we need to list all functions.
+static uintptr_t resolve_builtins(const char *name) {
+    switch(str2int(name)) {
+        case str2int("__udivmodti4"):
+            return (uintptr_t)&__udivmodti4;
+        case str2int("__umodti3"):
+            return (uintptr_t)&__umodti3;
+        case str2int("__udivti3"):
+            return (uintptr_t)&__udivti3;
+        case str2int("__divti3"):
+            return (uintptr_t)&__divti3;
+        default:
+            return 0;
+    }
+}
--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -278,6 +278,8 @@
 }
 #endif
 
+#include "builtins.cpp"
+
 // Custom object emission notification handler for the JuliaOJIT
 extern JITEventListener *CreateJuliaJITEventListener();
 JuliaOJIT::DebugObjectRegistrar::DebugObjectRegistrar(JuliaOJIT &JIT)
@@ -551,6 +551,8 @@
     // Step 2: Search the program symbols
     if (uint64_t addr = SectionMemoryManager::getSymbolAddressInProcess(Name))
         return JL_SymbolInfo(addr, JITSymbolFlags::Exported);
+    if (uint64_t addr = resolve_builtins(Name.c_str()))
+        return JL_SymbolInfo(addr, JITSymbolFlags::Exported);
 #if defined(_OS_LINUX_) || defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)
     if (uint64_t addr = resolve_atomic(Name.c_str()))
         return JL_SymbolInfo(addr, JITSymbolFlags::Exported);


--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -252,6 +252,24 @@ void addOptimizationPasses(legacy::PassManagerBase *PM, int opt_level,
     PM->add(createCombineMulAddPass());
 }
 
+// Resolve compiler-rt functions in rtlib.jl
+static uint64_t resolve_libcalls(const char *name)
+{
+    static void *compiler_rt_hdl = jl_load_dynamic_library("libcompiler-rt",
+                                                             JL_RTLD_LOCAL, 0);
+    static const char *const prefix = "__";
+    if (!compiler_rt_hdl) {
+        jl_printf(JL_STDERR, "WARNING: Unable to load compiler-rt\n");
+        return 0;
+    }
+    if (strncmp(name, prefix, strlen(prefix)) != 0)
+        return 0;
+    uintptr_t value;
+    jl_dlsym(compiler_rt_hdl, name, (void **)&value, 0);
+    return value;
+}
+
+
 extern "C" JL_DLLEXPORT
 void jl_add_optimization_passes(LLVMPassManagerRef PM, int opt_level, int lower_intrinsics) {
     addOptimizationPasses(unwrap(PM), opt_level, lower_intrinsics);
@@ -548,6 +572,8 @@ JL_JITSymbol JuliaOJIT::resolveSymbol(const std::string& Name)
 #if defined(_OS_LINUX_) || defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)
     if (uint64_t addr = resolve_atomic(Name.c_str()))
         return JL_SymbolInfo(addr, JITSymbolFlags::Exported);
+    if (uint64_t addr = resolve_libcalls(Name.c_str()))
+        return JL_SymbolInfo(addr, JITSymbolFlags::Exported);
 #endif
     // Return failure code
     return JL_SymbolInfo(nullptr);

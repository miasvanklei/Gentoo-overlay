--- /dev/null
+++ b/src/builtins.cpp
@@ -0,0 +1,54 @@
+#include <stdint.h>
+
+extern "C" unsigned long long __udivmodti4 (unsigned long long a, unsigned long long b, unsigned long long *c);
+extern "C" unsigned long long __umodti3 (unsigned long long a, unsigned long long b);
+extern "C" unsigned long long __udivti3 (unsigned long long a, unsigned long long b);
+extern "C" long long __divti3 (long long a, long long b);
+
+constexpr unsigned int str2int(const char* str, int h = 0)
+{
+    return !str[h] ? 5381 : (str2int(str, h+1) * 33) ^ str[h];
+}
+
+#define OPTIMISED_CASES              \
+  OPTIMISED_CASE(1, uint8_t)         \
+  OPTIMISED_CASE(2, uint16_t)        \
+  OPTIMISED_CASE(4, uint32_t)        \
+  OPTIMISED_CASE(8, uint64_t)
+
+#define OPTIMIZED_SWITCH_CASES   \
+  OPTIMIZED_SWITCH_CASE(1)       \
+  OPTIMIZED_SWITCH_CASE(2)       \
+  OPTIMIZED_SWITCH_CASE(4)       \
+  OPTIMIZED_SWITCH_CASE(8)       \
+
+#define PPCAT_NX(A, B) A ## B
+#define PPCAT(A, B) PPCAT_NX(A, B)
+#define STRINGIZE_NX(A) #A
+#define STRINGIZE(A) STRINGIZE_NX(A)
+
+#define OPTIMIZED_SWITCH_CASE(n)  \
+  case str2int(STRINGIZE(PPCAT(__atomic_load_, n))):          \
+    return (uintptr_t)&__atomic_load_##n;
+
+#define OPTIMISED_CASE(n, type)                \
+  extern "C" type __atomic_load_##n(type *src, int model);
+OPTIMISED_CASES
+
+// Resolve functions from compiler_rt. Since compiler_rt is a static library
+// and not a dynamic one, we need to list all functions.
+static uintptr_t resolve_builtins(const char *name) {
+    switch(str2int(name)) {
+        case str2int("__udivmodti4"):
+            return (uintptr_t)&__udivmodti4;
+        case str2int("__umodti3"):
+            return (uintptr_t)&__umodti3;
+        case str2int("__udivti3"):
+            return (uintptr_t)&__udivti3;
+        case str2int("__divti3"):
+            return (uintptr_t)&__divti3;
+        OPTIMIZED_SWITCH_CASES
+        default:
+            return 0;
+    }
+}
--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -278,6 +278,8 @@
 }
 #endif
 
+#include "builtins.cpp"
+
 // Custom object emission notification handler for the JuliaOJIT
 extern JITEventListener *CreateJuliaJITEventListener();
 JuliaOJIT::DebugObjectRegistrar::DebugObjectRegistrar(JuliaOJIT &JIT)
@@ -551,6 +551,8 @@
     // Step 2: Search the program symbols
     if (uint64_t addr = SectionMemoryManager::getSymbolAddressInProcess(Name))
         return JL_SymbolInfo(addr, JITSymbolFlags::Exported);
+    if (uint64_t addr = resolve_builtins(Name.c_str()))
+        return JL_SymbolInfo(addr, JITSymbolFlags::Exported);
 #if defined(_OS_LINUX_) || defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)
     if (uint64_t addr = resolve_atomic(Name.c_str()))
         return JL_SymbolInfo(addr, JITSymbolFlags::Exported);


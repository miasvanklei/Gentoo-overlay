--- a/driver/args.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/args.cpp	2023-03-19 12:35:31.287304278 +0100
@@ -159,11 +159,11 @@
 
 int executeAndWait(
     std::vector<const char *> fullArgs,
-    llvm::Optional<llvm::sys::WindowsEncodingMethod> responseFileEncoding,
+    std::optional<llvm::sys::WindowsEncodingMethod> responseFileEncoding,
     std::string *errorMsg) {
   args::ResponseFile rspFile;
-  if (responseFileEncoding.hasValue() &&
-      !rspFile.setup(fullArgs, responseFileEncoding.getValue())) {
+  if (responseFileEncoding &&
+      !rspFile.setup(fullArgs, *responseFileEncoding)) {
     if (errorMsg)
       *errorMsg = "could not write temporary response file";
     return -1;
@@ -177,9 +177,8 @@
   }
 
   const std::vector<llvm::StringRef> argv = toRefsVector(fullArgs);
-  auto envVars = llvm::None;
 
-  return llvm::sys::ExecuteAndWait(argv[0], argv, envVars, {}, 0, 0, errorMsg);
+  return llvm::sys::ExecuteAndWait(argv[0], argv, {}, {}, 0, 0, errorMsg);
 }
 } // namespace args
 
--- a/driver/args.h	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/args.h	2023-03-19 12:35:31.287304278 +0100
@@ -40,8 +40,8 @@
 // Executes a command line and returns its exit code.
 // Optionally uses a response file to overcome cmdline length limitations.
 int executeAndWait(std::vector<const char *> fullArgs,
-                   llvm::Optional<llvm::sys::WindowsEncodingMethod>
-                       responseFileEncoding = {llvm::None},
+                   std::optional<llvm::sys::WindowsEncodingMethod>
+                       responseFileEncoding = {},
                    std::string *errorMsg = nullptr);
 } // namespace args
 
--- a/driver/cl_options-llvm.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/cl_options-llvm.cpp	2023-03-19 12:35:31.287304278 +0100
@@ -68,7 +68,7 @@
 using FPK = llvm::FramePointer::FP;
 #endif
 
-llvm::Optional<FPK> framePointerUsage() {
+std::optional<FPK> framePointerUsage() {
 #if LDC_LLVM_VER >= 1100
   // Defaults to `FP::None`; no way to check if set explicitly by user except
   // indirectly via setFunctionAttributes()...
@@ -78,7 +78,7 @@
     return ::FramePointerUsage.getValue();
   if (disableFPElim.getNumOccurrences() > 0)
     return disableFPElim ? llvm::FramePointer::All : llvm::FramePointer::None;
-  return llvm::None;
+  return {};
 #endif
 }
 
--- a/driver/cl_options-llvm.h	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/cl_options-llvm.h	2023-03-19 12:35:31.287304278 +0100
@@ -22,12 +22,12 @@
 namespace opts {
 
 std::string getArchStr();
-llvm::Optional<llvm::Reloc::Model> getRelocModel();
-llvm::Optional<llvm::CodeModel::Model> getCodeModel();
+std::optional<llvm::Reloc::Model> getRelocModel();
+std::optional<llvm::CodeModel::Model> getCodeModel();
 #if LDC_LLVM_VER >= 1300
-llvm::Optional<llvm::FramePointerKind> framePointerUsage();
+std::optional<llvm::FramePointerKind> framePointerUsage();
 #else
-llvm::Optional<llvm::FramePointer::FP> framePointerUsage();
+std::optional<llvm::FramePointer::FP> framePointerUsage();
 #endif
 
 bool disableRedZone();
--- a/driver/linker.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/linker.cpp	2023-03-19 12:35:31.287304278 +0100
@@ -192,10 +192,10 @@
 
 //////////////////////////////////////////////////////////////////////////////
 
-llvm::Optional<std::vector<std::string>> getExplicitPlatformLibs() {
+std::optional<std::vector<std::string>> getExplicitPlatformLibs() {
   if (platformLib.getNumOccurrences() > 0)
     return parseLibNames(platformLib);
-  return llvm::None;
+  return {};
 }
 
 //////////////////////////////////////////////////////////////////////////////
--- a/driver/linker.h	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/linker.h	2023-03-19 12:35:31.287304278 +0100
@@ -42,7 +42,7 @@
 /**
  * Returns the -platformlib library names, if specified.
  */
-llvm::Optional<std::vector<std::string>> getExplicitPlatformLibs();
+std::optional<std::vector<std::string>> getExplicitPlatformLibs();
 
 /**
  * Returns the value of -mscrtlib.
--- a/driver/main.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/main.cpp	2023-03-19 12:35:31.287304278 +0100
@@ -581,7 +581,6 @@
 #endif
   initializeVectorization(Registry);
   initializeInstCombine(Registry);
-  initializeAggressiveInstCombine(Registry);
   initializeIPO(Registry);
 #if LDC_LLVM_VER < 1600
   initializeInstrumentation(Registry);
--- a/driver/targetmachine.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/targetmachine.cpp	2023-03-19 12:35:31.287304278 +0100
@@ -203,7 +203,7 @@
 }
 
 static std::string getAArch64TargetCPU(const llvm::Triple &triple) {
-  auto defaultCPU = llvm::AArch64::getDefaultCPU(triple.getArchName());
+  auto defaultCPU = llvm::ARM::getDefaultCPU(triple.getArchName());
   if (!defaultCPU.empty())
     return std::string(defaultCPU);
 
@@ -364,8 +364,8 @@
                     std::string cpu, const std::string featuresString,
                     const ExplicitBitness::Type bitness,
                     FloatABI::Type &floatABI,
-                    llvm::Optional<llvm::Reloc::Model> relocModel,
-                    llvm::Optional<llvm::CodeModel::Model> codeModel,
+                    std::optional<llvm::Reloc::Model> relocModel,
+                    std::optional<llvm::CodeModel::Model> codeModel,
                     const llvm::CodeGenOpt::Level codeGenOptLevel,
                     const bool noLinkerStripDead) {
   // Determine target triple. If the user didn't explicitly specify one, use
--- a/driver/targetmachine.h	2023-03-12 15:37:15.000000000 +0100
+++ b/driver/targetmachine.h	2023-03-19 12:35:31.287304278 +0100
@@ -55,8 +55,8 @@
 createTargetMachine(std::string targetTriple, std::string arch, std::string cpu,
                     std::string featuresString, ExplicitBitness::Type bitness,
                     FloatABI::Type &floatABI,
-                    llvm::Optional<llvm::Reloc::Model> relocModel,
-                    llvm::Optional<llvm::CodeModel::Model> codeModel,
+                    std::optional<llvm::Reloc::Model> relocModel,
+                    std::optional<llvm::CodeModel::Model> codeModel,
                     llvm::CodeGenOpt::Level codeGenOptLevel,
                     bool noLinkerStripDead);
 
--- a/gen/abi/nvptx.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/abi/nvptx.cpp	2023-03-19 12:35:31.416307048 +0100
@@ -39,7 +39,7 @@
   }
   void rewriteArgument(IrFuncTy &fty, IrFuncTyArg &arg) override {
     Type *ty = arg.type->toBasetype();
-    llvm::Optional<DcomputePointer> ptr;
+    std::optional<DcomputePointer> ptr;
     if (ty->ty == TY::Tstruct &&
         (ptr = toDcomputePointer(static_cast<TypeStruct *>(ty)->sym))) {
       pointerRewite.applyTo(arg);
--- a/gen/abi/spirv.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/abi/spirv.cpp	2023-03-19 12:35:31.416307048 +0100
@@ -49,7 +49,7 @@
   }
   void rewriteArgument(IrFuncTy &fty, IrFuncTyArg &arg) override {
     Type *ty = arg.type->toBasetype();
-    llvm::Optional<DcomputePointer> ptr;
+    std::optional<DcomputePointer> ptr;
     if (ty->ty == TY::Tstruct &&
         (ptr = toDcomputePointer(static_cast<TypeStruct *>(ty)->sym))) {
       pointerRewite.applyTo(arg);
--- a/gen/dcompute/druntime.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/dcompute/druntime.cpp	2023-03-19 12:35:31.416307048 +0100
@@ -41,12 +41,12 @@
   return isFromLDC_Mod(sym,Id::opencl);
 }
 
-llvm::Optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd) {
+std::optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd) {
   if (sd->ident != Id::dcPointer || !isFromLDC_DCompute(sd))
-    return llvm::Optional<DcomputePointer>(llvm::None);
+    return {};
 
   TemplateInstance *ti = sd->isInstantiated();
   int addrspace = isExpression((*ti->tiargs)[0])->toInteger();
   Type *type = isType((*ti->tiargs)[1]);
-  return llvm::Optional<DcomputePointer>(DcomputePointer(addrspace, type));
+  return std::optional<DcomputePointer>(DcomputePointer(addrspace, type));
 }
--- a/gen/dcompute/druntime.h	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/dcompute/druntime.h	2023-03-19 12:35:31.416307048 +0100
@@ -37,4 +37,4 @@
     return llType->getPointerTo(as);
   }
 };
-llvm::Optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd);
+std::optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd);
--- a/gen/dcompute/targetOCL.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/dcompute/targetOCL.cpp	2023-03-19 12:35:31.416307048 +0100
@@ -174,7 +174,7 @@
   void decodeTypes(std::array<llvm::SmallVector<llvm::Metadata *, 8>,count_KernArgMD>& attrs,
                    VarDeclaration *v)
   {
-    llvm::Optional<DcomputePointer> ptr;
+    std::optional<DcomputePointer> ptr;
     std::string typeQuals;
     std::string baseTyName;
     std::string tyName;
--- a/gen/dibuilder.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/dibuilder.cpp	2023-03-19 12:35:31.415307026 +0100
@@ -372,7 +372,7 @@
 DIType DIBuilder::CreatePointerType(TypePointer *type) {
   // TODO: The addressspace is important for dcompute targets. See e.g.
   // https://www.mail-archive.com/dwarf-discuss@lists.dwarfstd.org/msg00326.html
-  const llvm::Optional<unsigned> DWARFAddressSpace = llvm::None;
+  const std::optional<unsigned> DWARFAddressSpace = {};
 
   const auto name = processDIName(type->toPrettyChars(true));
 
@@ -732,7 +732,7 @@
 }
 
 DISubroutineType DIBuilder::CreateEmptyFunctionType() {
-  auto paramsArray = DBuilder.getOrCreateTypeArray(llvm::None);
+  auto paramsArray = DBuilder.getOrCreateTypeArray({});
   return DBuilder.createSubroutineType(paramsArray);
 }
 
@@ -778,7 +778,7 @@
     // display null as void*
     return DBuilder.createPointerType(
         CreateTypeDescription(Type::tvoid), target.ptrsize * 8, 0,
-        /* DWARFAddressSpace */ llvm::None, "typeof(null)");
+        /* DWARFAddressSpace */ {}, "typeof(null)");
   }
   if (auto te = t->isTypeEnum())
     return CreateEnumType(te);
@@ -801,7 +801,7 @@
     const auto name =
         (tc->sym->toPrettyChars(true) + llvm::StringRef("*")).str();
     return DBuilder.createPointerType(aggregateDIType, target.ptrsize * 8, 0,
-                                      llvm::None, processDIName(name));
+                                      {}, processDIName(name));
   }
   if (auto tf = t->isTypeFunction())
     return CreateFunctionType(tf);
--- a/gen/ms-cxx-helper.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/ms-cxx-helper.cpp	2023-03-19 12:35:31.415307026 +0100
@@ -114,7 +114,7 @@
       if (!newInst)
         newInst = Inst->clone();
 
-      nbb->getInstList().push_back(newInst);
+      newInst->insertInto(nbb, nbb->end());
       VMap[Inst] = newInst; // Add instruction map to value.
       if (unwindTo)
         if (auto dest = getUnwindDest(Inst))
--- a/gen/optimizer.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/optimizer.cpp	2023-03-19 12:35:31.415307026 +0100
@@ -569,7 +569,7 @@
 }
 
 
-static llvm::Optional<PGOOptions> getPGOOptions() {
+static std::optional<PGOOptions> getPGOOptions() {
  //FIXME: Do we have these anywhere?
  bool debugInfoForProfiling=false;
  bool pseudoProbeForProfiling=false;
@@ -584,7 +584,7 @@
                      PGOOptions::CSPGOAction::NoCSAction,
                      debugInfoForProfiling, pseudoProbeForProfiling);
   }
-  return None;
+  return {};
 }
 static PipelineTuningOptions getPipelineTuningOptions(unsigned optLevelVal, unsigned sizeLevelVal) {
   PipelineTuningOptions pto;
@@ -647,7 +647,7 @@
   bool debugLogging = false;
   ppo.Indent = false;
   ppo.SkipAnalyses = false;
-  StandardInstrumentations si(debugLogging, verifyEach, ppo);
+  StandardInstrumentations si(M->getContext(), debugLogging, verifyEach, ppo);
 
   si.registerCallbacks(pic, &fam);
 
--- a/gen/runtime.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/runtime.cpp	2023-03-19 12:35:31.417307069 +0100
@@ -33,7 +33,7 @@
 #include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/IR/Attributes.h"
 #if LDC_LLVM_VER >= 1600
-#include "llvm/IR/ModRef.h"
+#include "llvm/Support/ModRef.h"
 #endif
 #include "llvm/IR/Module.h"
 #include "llvm/Support/CommandLine.h"
--- a/gen/uda.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/gen/uda.cpp	2023-03-19 12:35:31.415307026 +0100
@@ -219,7 +219,7 @@
   if (numArgIdx >= 0) {
     builder.addAllocSizeAttr(llvmSizeIdx, llvmNumIdx);
   } else {
-    builder.addAllocSizeAttr(llvmSizeIdx, llvm::Optional<unsigned>());
+    builder.addAllocSizeAttr(llvmSizeIdx, std::optional<unsigned>());
   }
 
   llvm::Function *func = irFunc->getLLVMFunc();
--- a/ir/irtypestruct.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/ir/irtypestruct.cpp	2023-03-19 12:35:31.286304257 +0100
@@ -71,7 +71,7 @@
 
   // For ldc.dcomptetypes.Pointer!(uint n,T),
   // emit { T addrspace(gIR->dcomputetarget->mapping[n])* }
-  llvm::Optional<DcomputePointer> p;
+  std::optional<DcomputePointer> p;
 
   if (gIR->dcomputetarget && (p = toDcomputePointer(sd))) {
     // Translate the virtual dcompute address space into the real one for
--- a/runtime/jit-rt/cpp-so/bind.h	2023-03-12 15:37:15.000000000 +0100
+++ b/runtime/jit-rt/cpp-so/bind.h	2023-03-19 12:35:31.294304429 +0100
@@ -27,7 +27,7 @@
 class Function;
 }
 
-using BindOverride = llvm::Optional<
+using BindOverride = std::optional<
     llvm::function_ref<llvm::Constant *(llvm::Type &, const void *, size_t)>>;
 
 llvm::Function *
--- a/runtime/jit-rt/cpp-so/jit_context.cpp	2023-03-12 15:37:15.000000000 +0100
+++ b/runtime/jit-rt/cpp-so/jit_context.cpp	2023-03-19 12:35:31.294304429 +0100
@@ -63,8 +63,8 @@
   assert(target != nullptr);
   std::unique_ptr<llvm::TargetMachine> ret(target->createTargetMachine(
       triple, llvm::sys::getHostCPUName(), llvm::join(getHostAttrs(), ","), {},
-      llvm::Optional<llvm::Reloc::Model>{},
-      llvm::Optional<llvm::CodeModel::Model>{}, llvm::CodeGenOpt::Default,
+      std::optional<llvm::Reloc::Model>{},
+      std::optional<llvm::CodeModel::Model>{}, llvm::CodeGenOpt::Default,
       /*jit*/ true));
   assert(ret != nullptr);
   return ret;
--- a/runtime/jit-rt/cpp-so/valueparser.h	2023-03-12 15:37:16.000000000 +0100
+++ b/runtime/jit-rt/cpp-so/valueparser.h	2023-03-19 12:35:31.294304429 +0100
@@ -24,7 +24,7 @@
 class DataLayout;
 }
 
-using ParseInitializerOverride = llvm::Optional<
+using ParseInitializerOverride = std::optional<
     llvm::function_ref<llvm::Constant *(llvm::Type &, const void *, size_t)>>;
 
 llvm::Constant *parseInitializer(
--- a/utils/not.cpp	2023-03-12 15:37:16.000000000 +0100
+++ b/utils/not.cpp	2023-03-19 12:35:31.286304257 +0100
@@ -43,7 +43,7 @@
   Argv.reserve(argc);
   for (int i = 0; i < argc; ++i)
     Argv.push_back(argv[i]);
-  auto Env = llvm::None;
+  auto Env = {};
 
   std::string ErrMsg;
   int Result = sys::ExecuteAndWait(*Program, Argv, Env, {}, 0, 0, &ErrMsg);

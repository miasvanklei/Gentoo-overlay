--- a/dmd/globals.h	2023-07-23 21:15:47.000000000 +0200
+++ b/dmd/globals.h	2023-07-29 22:34:33.935334578 +0200
@@ -17,7 +17,7 @@
 #include "compiler.h"
 
 #if IN_LLVM
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 
 enum OUTPUTFLAG
 {
--- a/driver/archiver.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/archiver.cpp	2023-07-29 22:34:33.969335029 +0200
@@ -14,7 +14,7 @@
 #include "driver/timetrace.h"
 #include "driver/tool.h"
 #include "gen/logger.h"
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 #include "llvm/Object/Archive.h"
 #include "llvm/Object/ArchiveWriter.h"
 #include "llvm/Object/MachO.h"
--- a/driver/args.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/args.cpp	2023-07-29 22:34:33.970335042 +0200
@@ -175,9 +175,8 @@
   }
 
   const std::vector<llvm::StringRef> argv = toRefsVector(fullArgs);
-  auto envVars = llvm::None;
 
-  return llvm::sys::ExecuteAndWait(argv[0], argv, envVars, {}, 0, 0, errorMsg);
+  return llvm::sys::ExecuteAndWait(argv[0], argv, {}, {}, 0, 0, errorMsg);
 }
 } // namespace args
 
--- a/driver/cl_options-llvm.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/cl_options-llvm.cpp	2023-07-29 22:34:33.970335042 +0200
@@ -10,7 +10,7 @@
 #include "driver/cl_options-llvm.h"
 
 #if LDC_WITH_LLD
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 #endif
 
 // Pull in command-line options and helper functions from special LLVM header
@@ -46,7 +46,7 @@
 #endif
 }
 
-Optional<Reloc::Model> getRelocModel() {
+std::optional<Reloc::Model> getRelocModel() {
 #if LDC_LLVM_VER >= 1100
   return codegen::getExplicitRelocModel();
 #else
@@ -54,7 +54,7 @@
 #endif
 }
 
-Optional<CodeModel::Model> getCodeModel() {
+std::optional<CodeModel::Model> getCodeModel() {
 #if LDC_LLVM_VER >= 1100
   return codegen::getExplicitCodeModel();
 #else
@@ -68,7 +68,7 @@
 using FPK = llvm::FramePointer::FP;
 #endif
 
-llvm::Optional<FPK> framePointerUsage() {
+std::optional<FPK> framePointerUsage() {
 #if LDC_LLVM_VER >= 1100
   // Defaults to `FP::None`; no way to check if set explicitly by user except
   // indirectly via setFunctionAttributes()...
@@ -78,7 +78,7 @@
     return ::FramePointerUsage.getValue();
   if (disableFPElim.getNumOccurrences() > 0)
     return disableFPElim ? llvm::FramePointer::All : llvm::FramePointer::None;
-  return llvm::None;
+  return {};
 #endif
 }
 
--- a/driver/cl_options-llvm.h	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/cl_options-llvm.h	2023-07-29 22:34:33.970335042 +0200
@@ -9,7 +9,6 @@
 
 #pragma once
 
-#include "llvm/ADT/Optional.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/CodeGen.h"
 #include "llvm/Target/TargetOptions.h"
@@ -22,12 +21,12 @@
 namespace opts {
 
 std::string getArchStr();
-llvm::Optional<llvm::Reloc::Model> getRelocModel();
-llvm::Optional<llvm::CodeModel::Model> getCodeModel();
+std::optional<llvm::Reloc::Model> getRelocModel();
+std::optional<llvm::CodeModel::Model> getCodeModel();
 #if LDC_LLVM_VER >= 1300
-llvm::Optional<llvm::FramePointerKind> framePointerUsage();
+std::optional<llvm::FramePointerKind> framePointerUsage();
 #else
-llvm::Optional<llvm::FramePointer::FP> framePointerUsage();
+std::optional<llvm::FramePointer::FP> framePointerUsage();
 #endif
 
 bool disableRedZone();
--- a/driver/cl_options_instrumentation.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/cl_options_instrumentation.cpp	2023-07-29 22:34:33.969335029 +0200
@@ -18,7 +18,7 @@
 #include "dmd/errors.h"
 #include "dmd/globals.h"
 #include "gen/to_string.h"
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 
 namespace {
 namespace cl = llvm::cl;
--- a/driver/linker.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/linker.cpp	2023-07-29 22:34:33.970335042 +0200
@@ -192,10 +192,10 @@
 
 //////////////////////////////////////////////////////////////////////////////
 
-llvm::Optional<std::vector<std::string>> getExplicitPlatformLibs() {
+std::optional<std::vector<std::string>> getExplicitPlatformLibs() {
   if (platformLib.getNumOccurrences() > 0)
     return parseLibNames(platformLib);
-  return llvm::None;
+  return {};
 }
 
 //////////////////////////////////////////////////////////////////////////////
--- a/driver/linker.h	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/linker.h	2023-07-29 22:34:33.970335042 +0200
@@ -42,7 +42,7 @@
 /**
  * Returns the -platformlib library names, if specified.
  */
-llvm::Optional<std::vector<std::string>> getExplicitPlatformLibs();
+std::optional<std::vector<std::string>> getExplicitPlatformLibs();
 
 /**
  * Returns the value of -mscrtlib.
--- a/driver/main.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/main.cpp	2023-07-29 22:34:33.970335042 +0200
@@ -580,7 +580,6 @@
 #endif
   initializeVectorization(Registry);
   initializeInstCombine(Registry);
-  initializeAggressiveInstCombine(Registry);
   initializeIPO(Registry);
 #if LDC_LLVM_VER < 1600
   initializeInstrumentation(Registry);
@@ -591,7 +590,6 @@
   initializeTarget(Registry);
 
 // Initialize passes not included above
-  initializeRewriteSymbolsLegacyPassPass(Registry);
   initializeSjLjEHPreparePass(Registry);
 }
 
--- a/driver/targetmachine.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/targetmachine.cpp	2023-07-29 22:34:33.970335042 +0200
@@ -20,13 +20,12 @@
 #include "gen/logger.h"
 #include "llvm/ADT/StringExtras.h"
 #include "llvm/ADT/StringSwitch.h"
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 #include "llvm/IR/Module.h"
 #include "llvm/MC/MCObjectFileInfo.h"
-#include "llvm/MC/SubtargetFeature.h"
-#include "llvm/Support/Host.h"
+#include "llvm/TargetParser/SubtargetFeature.h"
 #include "llvm/Support/CommandLine.h"
-#include "llvm/Support/TargetParser.h"
+#include "llvm/TargetParser/Host.h"
 #if LDC_LLVM_VER >= 1400
 #include "llvm/MC/TargetRegistry.h"
 #else
@@ -36,8 +35,8 @@
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Target/TargetOptions.h"
 #if LDC_LLVM_VER >= 1400
-#include "llvm/Support/AArch64TargetParser.h"
-#include "llvm/Support/ARMTargetParser.h"
+#include "llvm/TargetParser/AArch64TargetParser.h"
+#include "llvm/TargetParser/ARMTargetParser.h"
 #endif
 
 #include "gen/optimizer.h"
@@ -203,7 +202,7 @@
 }
 
 static std::string getAArch64TargetCPU(const llvm::Triple &triple) {
-  auto defaultCPU = llvm::AArch64::getDefaultCPU(triple.getArchName());
+  auto defaultCPU = llvm::ARM::getDefaultCPU(triple.getArchName());
   if (!defaultCPU.empty())
     return std::string(defaultCPU);
 
@@ -364,8 +363,8 @@
                     std::string cpu, const std::string featuresString,
                     const ExplicitBitness::Type bitness,
                     FloatABI::Type &floatABI,
-                    llvm::Optional<llvm::Reloc::Model> relocModel,
-                    llvm::Optional<llvm::CodeModel::Model> codeModel,
+                    std::optional<llvm::Reloc::Model> relocModel,
+                    std::optional<llvm::CodeModel::Model> codeModel,
                     const llvm::CodeGenOpt::Level codeGenOptLevel,
                     const bool noLinkerStripDead) {
   // Determine target triple. If the user didn't explicitly specify one, use
@@ -521,7 +520,6 @@
   // LLVM fork. LLVM 7+ enables regular emutls by default; prevent that.
   if (triple.getEnvironment() == llvm::Triple::Android) {
     targetOptions.EmulatedTLS = false;
-    targetOptions.ExplicitEmulatedTLS = true;
   }
 
   const std::string finalFeaturesString =
--- a/driver/targetmachine.h	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/targetmachine.h	2023-07-29 22:34:33.970335042 +0200
@@ -14,7 +14,6 @@
 
 #pragma once
 
-#include "llvm/ADT/Optional.h"
 #include "llvm/Support/CodeGen.h"
 #include <string>
 #include <vector>
@@ -55,8 +54,8 @@
 createTargetMachine(std::string targetTriple, std::string arch, std::string cpu,
                     std::string featuresString, ExplicitBitness::Type bitness,
                     FloatABI::Type &floatABI,
-                    llvm::Optional<llvm::Reloc::Model> relocModel,
-                    llvm::Optional<llvm::CodeModel::Model> codeModel,
+                    std::optional<llvm::Reloc::Model> relocModel,
+                    std::optional<llvm::CodeModel::Model> codeModel,
                     llvm::CodeGenOpt::Level codeGenOptLevel,
                     bool noLinkerStripDead);
 
--- a/driver/toobj.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/driver/toobj.cpp	2023-07-29 22:34:33.970335042 +0200
@@ -53,11 +53,6 @@
 using CodeGenFileType = llvm::CodeGenFileType;
 #endif
 
-static llvm::cl::opt<bool>
-    NoIntegratedAssembler("no-integrated-as", llvm::cl::ZeroOrMore,
-                          llvm::cl::Hidden,
-                          llvm::cl::desc("Disable integrated assembler"));
-
 namespace {
 
 // The dllimport relocation pass on Windows is *not* an optimization pass.
@@ -293,8 +288,7 @@
   // There is no integrated assembler on AIX because XCOFF is not supported.
   // Starting with LLVM 3.5 the integrated assembler can be used with MinGW.
   return global.params.output_o &&
-         (NoIntegratedAssembler ||
-          global.params.targetTriple->getOS() == llvm::Triple::AIX);
+    (global.params.targetTriple->getOS() == llvm::Triple::AIX);
 }
 
 bool shouldOutputObjectFile() {
--- a/gen/abi/nvptx.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/abi/nvptx.cpp	2023-07-29 22:34:33.842333345 +0200
@@ -39,7 +39,7 @@
   }
   void rewriteArgument(IrFuncTy &fty, IrFuncTyArg &arg) override {
     Type *ty = arg.type->toBasetype();
-    llvm::Optional<DcomputePointer> ptr;
+    std::optional<DcomputePointer> ptr;
     if (ty->ty == TY::Tstruct &&
         (ptr = toDcomputePointer(static_cast<TypeStruct *>(ty)->sym))) {
       pointerRewite.applyTo(arg);
--- a/gen/abi/spirv.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/abi/spirv.cpp	2023-07-29 22:34:33.842333345 +0200
@@ -49,7 +49,7 @@
   }
   void rewriteArgument(IrFuncTy &fty, IrFuncTyArg &arg) override {
     Type *ty = arg.type->toBasetype();
-    llvm::Optional<DcomputePointer> ptr;
+    std::optional<DcomputePointer> ptr;
     if (ty->ty == TY::Tstruct &&
         (ptr = toDcomputePointer(static_cast<TypeStruct *>(ty)->sym))) {
       pointerRewite.applyTo(arg);
--- a/gen/dcompute/druntime.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/dcompute/druntime.cpp	2023-07-29 22:34:33.841333332 +0200
@@ -41,12 +41,12 @@
   return isFromLDC_Mod(sym,Id::opencl);
 }
 
-llvm::Optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd) {
+std::optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd) {
   if (sd->ident != Id::dcPointer || !isFromLDC_DCompute(sd))
-    return llvm::Optional<DcomputePointer>(llvm::None);
+    return {};
 
   TemplateInstance *ti = sd->isInstantiated();
   int addrspace = isExpression((*ti->tiargs)[0])->toInteger();
   Type *type = isType((*ti->tiargs)[1]);
-  return llvm::Optional<DcomputePointer>(DcomputePointer(addrspace, type));
+  return std::optional<DcomputePointer>(DcomputePointer(addrspace, type));
 }
--- a/gen/dcompute/druntime.h	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/dcompute/druntime.h	2023-07-29 22:34:33.841333332 +0200
@@ -17,7 +17,6 @@
 #include "gen/irstate.h"
 #include "gen/llvm.h"
 #include "gen/tollvm.h"
-#include "llvm/ADT/Optional.h"
 
 class Dsymbol;
 class Type;
@@ -37,4 +36,4 @@
     return llType->getPointerTo(as);
   }
 };
-llvm::Optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd);
+std::optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd);
--- a/gen/dcompute/targetOCL.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/dcompute/targetOCL.cpp	2023-07-29 22:34:33.841333332 +0200
@@ -174,7 +174,7 @@
   void decodeTypes(std::array<llvm::SmallVector<llvm::Metadata *, 8>,count_KernArgMD>& attrs,
                    VarDeclaration *v)
   {
-    llvm::Optional<DcomputePointer> ptr;
+    std::optional<DcomputePointer> ptr;
     std::string typeQuals;
     std::string baseTyName;
     std::string tyName;
--- a/gen/dibuilder.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/dibuilder.cpp	2023-07-29 22:34:33.843333358 +0200
@@ -372,7 +372,7 @@
 DIType DIBuilder::CreatePointerType(TypePointer *type) {
   // TODO: The addressspace is important for dcompute targets. See e.g.
   // https://www.mail-archive.com/dwarf-discuss@lists.dwarfstd.org/msg00326.html
-  const llvm::Optional<unsigned> DWARFAddressSpace = llvm::None;
+  const std::optional<unsigned> DWARFAddressSpace = {};
 
   const auto name = processDIName(type->toPrettyChars(true));
 
@@ -730,7 +730,7 @@
 }
 
 DISubroutineType DIBuilder::CreateEmptyFunctionType() {
-  auto paramsArray = DBuilder.getOrCreateTypeArray(llvm::None);
+  auto paramsArray = DBuilder.getOrCreateTypeArray({});
   return DBuilder.createSubroutineType(paramsArray);
 }
 
@@ -776,7 +776,7 @@
     // display null as void*
     return DBuilder.createPointerType(
         CreateTypeDescription(Type::tvoid), target.ptrsize * 8, 0,
-        /* DWARFAddressSpace */ llvm::None, "typeof(null)");
+        /* DWARFAddressSpace */ {}, "typeof(null)");
   }
   if (auto te = t->isTypeEnum())
     return CreateEnumType(te);
@@ -799,7 +799,7 @@
     const auto name =
         (tc->sym->toPrettyChars(true) + llvm::StringRef("*")).str();
     return DBuilder.createPointerType(aggregateDIType, target.ptrsize * 8, 0,
-                                      llvm::None, processDIName(name));
+                                      {}, processDIName(name));
   }
   if (auto tf = t->isTypeFunction())
     return CreateFunctionType(tf);
--- a/gen/modules.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/modules.cpp	2023-07-29 22:34:33.841333332 +0200
@@ -48,6 +48,7 @@
 #include "llvm/ProfileData/InstrProfReader.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/FileSystem.h"
+#include "llvm/Support/VirtualFileSystem.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Transforms/Utils/ModuleUtils.h"
 
@@ -353,8 +354,9 @@
     IF_LOG Logger::println("Read profile data from %s",
                            global.params.datafileInstrProf);
 
+    auto FS = llvm::vfs::getRealFileSystem();
     auto readerOrErr =
-        llvm::IndexedInstrProfReader::create(global.params.datafileInstrProf);
+        llvm::IndexedInstrProfReader::create(global.params.datafileInstrProf, *FS);
     if (auto E = readerOrErr.takeError()) {
       handleAllErrors(std::move(E), [&](const llvm::ErrorInfoBase &EI) {
         irs->dmodule->error("Could not read profile file '%s': %s",
--- a/gen/ms-cxx-helper.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/ms-cxx-helper.cpp	2023-07-29 22:34:33.843333358 +0200
@@ -114,7 +114,7 @@
       if (!newInst)
         newInst = Inst->clone();
 
-      nbb->getInstList().push_back(newInst);
+      newInst->insertInto(nbb, nbb->end());
       VMap[Inst] = newInst; // Add instruction map to value.
       if (unwindTo)
         if (auto dest = getUnwindDest(Inst))
--- a/gen/optimizer.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/optimizer.cpp	2023-07-29 22:34:33.843333358 +0200
@@ -20,7 +20,7 @@
 #include "driver/cl_options_sanitizers.h"
 #include "driver/plugins.h"
 #include "driver/targetmachine.h"
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 #include "llvm/Analysis/InlineCost.h"
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
@@ -31,10 +31,10 @@
 #include "llvm/IR/Verifier.h"
 #include "llvm/LinkAllPasses.h"
 #include "llvm/Support/CommandLine.h"
+#include "llvm/Support/VirtualFileSystem.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Transforms/Instrumentation.h"
 #include "llvm/Transforms/IPO.h"
-#include "llvm/Transforms/IPO/PassManagerBuilder.h"
 #include "llvm/Transforms/Instrumentation/MemorySanitizer.h"
 #include "llvm/Transforms/Instrumentation/ThreadSanitizer.h"
 #include "llvm/Transforms/Instrumentation/AddressSanitizer.h"
@@ -559,22 +559,23 @@
 }
 
 
-static llvm::Optional<PGOOptions> getPGOOptions() {
+static std::optional<PGOOptions> getPGOOptions() {
  //FIXME: Do we have these anywhere?
  bool debugInfoForProfiling=false;
  bool pseudoProbeForProfiling=false;
+ auto FS = llvm::vfs::getRealFileSystem();
  if (opts::isInstrumentingForIRBasedPGO()) {
-    return PGOOptions(global.params.datafileInstrProf, "", "",
+    return PGOOptions(global.params.datafileInstrProf, "", "", "", FS,
                      PGOOptions::PGOAction::IRInstr,
                      PGOOptions::CSPGOAction::NoCSAction,
                      debugInfoForProfiling, pseudoProbeForProfiling);
   } else if (opts::isUsingIRBasedPGOProfile()) {
-    return PGOOptions(global.params.datafileInstrProf, "", "",
+    return PGOOptions(global.params.datafileInstrProf, "", "", "", FS,
                      PGOOptions::PGOAction::IRUse,
                      PGOOptions::CSPGOAction::NoCSAction,
                      debugInfoForProfiling, pseudoProbeForProfiling);
   }
-  return None;
+  return {};
 }
 static PipelineTuningOptions getPipelineTuningOptions(unsigned optLevelVal, unsigned sizeLevelVal) {
   PipelineTuningOptions pto;
@@ -637,9 +638,9 @@
   bool debugLogging = false;
   ppo.Indent = false;
   ppo.SkipAnalyses = false;
-  StandardInstrumentations si(debugLogging, /*VerifyEach=*/false, ppo);
+  StandardInstrumentations si(M->getContext(), debugLogging, /*VerifyEach=*/false, ppo);
 
-  si.registerCallbacks(pic, &fam);
+  si.registerCallbacks(pic, &mam);
 
   PassBuilder pb(gTargetMachine, getPipelineTuningOptions(optLevelVal, sizeLevelVal),
                  getPGOOptions(), &pic);
--- a/gen/passes/DLLImportRelocation.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/passes/DLLImportRelocation.cpp	2023-07-29 22:34:33.843333358 +0200
@@ -276,7 +276,7 @@
   Impl impl(m);
   bool hasChanged = false;
 
-  for (GlobalVariable &global : m.getGlobalList()) {
+  for (GlobalVariable &global : m.globals()) {
     // TODO: thread-local globals would need to be initialized in a separate TLS
     // ctor
     if (!global.hasInitializer() || global.isThreadLocal())
--- a/gen/pgo_ASTbased.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/pgo_ASTbased.cpp	2023-07-29 22:34:33.841333332 +0200
@@ -920,7 +920,7 @@
   auto EC = RecordExpected.takeError();
 
   if (EC) {
-    auto IPE = llvm::InstrProfError::take(std::move(EC));
+    auto IPE = llvm::InstrProfError::take(std::move(EC)).first;
     if (IPE == llvm::instrprof_error::unknown_function) {
       IF_LOG Logger::println("No profile data for function: %s",
                              FuncName.c_str());
--- a/gen/rttibuilder.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/rttibuilder.cpp	2023-07-29 22:34:33.842333345 +0200
@@ -46,7 +46,7 @@
   // We need to explicitly zero any padding bytes as per TDPL §7.1.1 (and
   // also match the struct type lowering code here).
   const uint64_t fieldStart = llvm::alignTo(
-      prevFieldEnd, gDataLayout->getABITypeAlignment(C->getType()));
+      prevFieldEnd, gDataLayout->getABITypeAlign(C->getType()).value());
 
   const uint64_t paddingBytes = fieldStart - prevFieldEnd;
   if (paddingBytes) {
--- a/gen/runtime.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/runtime.cpp	2023-07-29 22:34:33.843333358 +0200
@@ -33,7 +33,7 @@
 #include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/IR/Attributes.h"
 #if LDC_LLVM_VER >= 1600
-#include "llvm/IR/ModRef.h"
+#include "llvm/Support/ModRef.h"
 #endif
 #include "llvm/IR/Module.h"
 #include "llvm/Support/CommandLine.h"
--- a/gen/target.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/target.cpp	2023-07-29 22:34:33.842333345 +0200
@@ -102,7 +102,7 @@
   realType = getRealType(triple);
   realsize = gDataLayout->getTypeAllocSize(realType);
   realpad = realsize - gDataLayout->getTypeStoreSize(realType);
-  realalignsize = gDataLayout->getABITypeAlignment(realType);
+  realalignsize = gDataLayout->getABITypeAlign(realType).value();
   classinfosize = 0; // unused
   maxStaticDataSize = std::numeric_limits<unsigned long long>::max();
 
@@ -211,7 +211,7 @@
   if (type->ty == TY::Tvoid) {
     return 1;
   }
-  return gDataLayout->getABITypeAlignment(DtoType(type));
+  return gDataLayout->getABITypeAlign(DtoType(type)).value();
 }
 
 /******************************
--- a/gen/tollvm.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/tollvm.cpp	2023-07-29 22:34:33.842333345 +0200
@@ -748,7 +748,7 @@
 size_t getTypeAllocSize(LLType *t) { return gDataLayout->getTypeAllocSize(t); }
 
 unsigned int getABITypeAlign(LLType *t) {
-  return gDataLayout->getABITypeAlignment(t);
+  return gDataLayout->getABITypeAlign(t).value();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
--- a/gen/uda.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/gen/uda.cpp	2023-07-29 22:34:33.843333358 +0200
@@ -219,7 +219,7 @@
   if (numArgIdx >= 0) {
     builder.addAllocSizeAttr(llvmSizeIdx, llvmNumIdx);
   } else {
-    builder.addAllocSizeAttr(llvmSizeIdx, llvm::Optional<unsigned>());
+    builder.addAllocSizeAttr(llvmSizeIdx, std::optional<unsigned>());
   }
 
   llvm::Function *func = irFunc->getLLVMFunc();
@@ -459,8 +459,6 @@
           .Case("swifttailcc", llvm::CallingConv::SwiftTail)
 #endif
           .Case("x86_intrcc", llvm::CallingConv::X86_INTR)
-          .Case("hhvmcc", llvm::CallingConv::HHVM)
-          .Case("hhvm_ccc", llvm::CallingConv::HHVM_C)
           .Case("cxx_fast_tlscc", llvm::CallingConv::CXX_FAST_TLS)
           .Case("amdgpu_vs", llvm::CallingConv::AMDGPU_VS)
 #if LDC_LLVM_VER >= 1200
--- a/ir/irtypestruct.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/ir/irtypestruct.cpp	2023-07-29 22:34:33.841333332 +0200
@@ -71,7 +71,7 @@
 
   // For ldc.dcomptetypes.Pointer!(uint n,T),
   // emit { T addrspace(gIR->dcomputetarget->mapping[n])* }
-  llvm::Optional<DcomputePointer> p;
+  std::optional<DcomputePointer> p;
 
   if (gIR->dcomputetarget && (p = toDcomputePointer(sd))) {
     // Translate the virtual dcompute address space into the real one for
--- a/runtime/druntime/src/ldc/intrinsics.di	2023-07-23 21:15:47.000000000 +0200
+++ b/runtime/druntime/src/ldc/intrinsics.di	2023-07-29 22:34:33.964334963 +0200
@@ -28,6 +28,7 @@
 else version (LDC_LLVM_1400) enum LLVM_version = 1400;
 else version (LDC_LLVM_1500) enum LLVM_version = 1500;
 else version (LDC_LLVM_1600) enum LLVM_version = 1600;
+else version (LDC_LLVM_1700) enum LLVM_version = 1700;
 else static assert(false, "LDC LLVM version not supported");
 
 enum LLVM_atleast(int major) = (LLVM_version >= major * 100);
--- a/runtime/jit-rt/cpp-so/bind.h	2023-07-23 21:15:47.000000000 +0200
+++ b/runtime/jit-rt/cpp-so/bind.h	2023-07-29 22:34:33.940334644 +0200
@@ -27,7 +27,7 @@
 class Function;
 }
 
-using BindOverride = llvm::Optional<
+using BindOverride = std::optional<
     llvm::function_ref<llvm::Constant *(llvm::Type &, const void *, size_t)>>;
 
 llvm::Function *
--- a/runtime/jit-rt/cpp-so/disassembler.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/runtime/jit-rt/cpp-so/disassembler.cpp	2023-07-29 22:34:33.940334644 +0200
@@ -12,7 +12,7 @@
 #include <algorithm>
 #include <unordered_map>
 
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 #include "llvm/MC/MCAsmBackend.h"
 #include "llvm/MC/MCAsmInfo.h"
 #include "llvm/MC/MCCodeEmitter.h"
--- a/runtime/jit-rt/cpp-so/jit_context.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/runtime/jit-rt/cpp-so/jit_context.cpp	2023-07-29 22:34:33.940334644 +0200
@@ -63,8 +63,8 @@
   assert(target != nullptr);
   std::unique_ptr<llvm::TargetMachine> ret(target->createTargetMachine(
       triple, llvm::sys::getHostCPUName(), llvm::join(getHostAttrs(), ","), {},
-      llvm::Optional<llvm::Reloc::Model>{},
-      llvm::Optional<llvm::CodeModel::Model>{}, llvm::CodeGenOpt::Default,
+      std::optional<llvm::Reloc::Model>{},
+      std::optional<llvm::CodeModel::Model>{}, llvm::CodeGenOpt::Default,
       /*jit*/ true));
   assert(ret != nullptr);
   return ret;
--- a/runtime/jit-rt/cpp-so/optimizer.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/runtime/jit-rt/cpp-so/optimizer.cpp	2023-07-29 22:34:33.940334644 +0200
@@ -19,7 +19,7 @@
 #include "llvm/IR/Module.h"
 #include "llvm/IR/Verifier.h"
 
-#include "llvm/ADT/Triple.h"
+#include "llvm/TargetParser/Triple.h"
 
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
--- a/runtime/jit-rt/cpp-so/valueparser.h	2023-07-23 21:15:47.000000000 +0200
+++ b/runtime/jit-rt/cpp-so/valueparser.h	2023-07-29 22:34:33.940334644 +0200
@@ -24,7 +24,7 @@
 class DataLayout;
 }
 
-using ParseInitializerOverride = llvm::Optional<
+using ParseInitializerOverride = std::optional<
     llvm::function_ref<llvm::Constant *(llvm::Type &, const void *, size_t)>>;
 
 llvm::Constant *parseInitializer(
--- a/utils/not.cpp	2023-07-23 21:15:47.000000000 +0200
+++ b/utils/not.cpp	2023-07-29 22:34:33.969335029 +0200
@@ -43,7 +43,7 @@
   Argv.reserve(argc);
   for (int i = 0; i < argc; ++i)
     Argv.push_back(argv[i]);
-  auto Env = llvm::None;
+  auto Env = {};
 
   std::string ErrMsg;
   int Result = sys::ExecuteAndWait(*Program, Argv, Env, {}, 0, 0, &ErrMsg);

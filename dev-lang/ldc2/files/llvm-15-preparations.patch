diff --git a/driver/codegenerator.cpp b/driver/codegenerator.cpp
index 70d155ddf0..995f2a34bd 100644
--- a/driver/codegenerator.cpp
+++ b/driver/codegenerator.cpp
@@ -24,6 +24,9 @@
 #include "gen/modules.h"
 #include "gen/runtime.h"
 #include "ir/irdsymbol.h"
+#if LDC_LLVM_VER >= 1500
+#include "llvm/IR/DiagnosticInfo.h"
+#endif
 #if LDC_LLVM_VER >= 1100
 #include "llvm/IR/LLVMRemarkStreamer.h"
 #elif LDC_LLVM_VER >= 900
diff --git a/driver/targetmachine.cpp b/driver/targetmachine.cpp
index 3f6a35283c..2954eb25a7 100644
--- a/driver/targetmachine.cpp
+++ b/driver/targetmachine.cpp
@@ -31,6 +31,10 @@
 #include "llvm/Support/TargetSelect.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Target/TargetOptions.h"
+#if LDC_LLVM_VER >= 1500
+#include "llvm/Support/AArch64TargetParser.h"
+#include "llvm/Support/ARMTargetParser.h"
+#endif
 
 #if LDC_LLVM_VER >= 700
 #include "gen/optimizer.h"
diff --git a/gen/dibuilder.cpp b/gen/dibuilder.cpp
index 2ec29ba817..fd44e8b04e 100644
--- a/gen/dibuilder.cpp
+++ b/gen/dibuilder.cpp
@@ -1153,7 +1153,12 @@ void DIBuilder::EmitValue(llvm::Value *val, VarDeclaration *vd) {
 void DIBuilder::EmitLocalVariable(llvm::Value *ll, VarDeclaration *vd,
                                   Type *type, bool isThisPtr, bool forceAsLocal,
                                   bool isRefRVal,
-                                  llvm::ArrayRef<int64_t> addr) {
+#if LDC_LLVM_VER >= 1500
+                                  llvm::ArrayRef<uint64_t> addr
+#else
+                                  llvm::ArrayRef<int64_t> addr
+#endif
+                                  ) {
   if (!mustEmitFullDebugInfo())
     return;
 
diff --git a/gen/dibuilder.h b/gen/dibuilder.h
index a40816ccee..fe0848cf8e 100644
--- a/gen/dibuilder.h
+++ b/gen/dibuilder.h
@@ -140,7 +140,12 @@ class DIBuilder {
   EmitLocalVariable(llvm::Value *ll, VarDeclaration *vd, Type *type = nullptr,
                     bool isThisPtr = false, bool forceAsLocal = false,
                     bool isRefRVal = false,
-                    llvm::ArrayRef<int64_t> addr = llvm::ArrayRef<int64_t>());
+#if LDC_LLVM_VER >= 1500
+                    llvm::ArrayRef<uint64_t> addr = llvm::ArrayRef<uint64_t>()
+#else
+                    llvm::ArrayRef<int64_t> addr = llvm::ArrayRef<int64_t>()
+#endif
+                    );
 
   /// \brief Emits all things necessary for making debug info for a global
   /// variable vd.
diff --git a/gen/functions.cpp b/gen/functions.cpp
index 9aa4e545bb..565bd3e9dd 100644
--- a/gen/functions.cpp
+++ b/gen/functions.cpp
@@ -96,11 +96,19 @@ llvm::FunctionType *DtoFunctionType(Type *type, IrFuncTy &irFty, Type *thistype,
   } else {
     Type *rt = f->next;
     const bool byref = f->isref() && rt->toBasetype()->ty != TY::Tvoid;
+#if LDC_LLVM_VER >= 1500
+      llvm::AttrBuilder attrs(getGlobalContext());
+#else
     llvm::AttrBuilder attrs;
+#endif
 
     if (abi->returnInArg(f, fd && fd->needThis())) {
       // sret return
+#if LDC_LLVM_VER >= 1500
+      llvm::AttrBuilder sretAttrs(getGlobalContext());
+#else
       llvm::AttrBuilder sretAttrs;
+#endif
 #if LDC_LLVM_VER >= 1200
       sretAttrs.addStructRetAttr(DtoType(rt));
 #else
@@ -109,32 +117,40 @@ llvm::FunctionType *DtoFunctionType(Type *type, IrFuncTy &irFty, Type *thistype,
       sretAttrs.addAttribute(LLAttribute::NoAlias);
       if (unsigned alignment = DtoAlignment(rt))
         sretAttrs.addAlignmentAttr(alignment);
-      newIrFty.arg_sret = new IrFuncTyArg(rt, true, sretAttrs);
+      newIrFty.arg_sret = new IrFuncTyArg(rt, true, std::move(sretAttrs));
       rt = Type::tvoid;
       ++nextLLArgIdx;
     } else {
       // sext/zext return
       DtoAddExtendAttr(byref ? rt->pointerTo() : rt, attrs);
     }
-    newIrFty.ret = new IrFuncTyArg(rt, byref, attrs);
+    newIrFty.ret = new IrFuncTyArg(rt, byref, std::move(attrs));
   }
   ++nextLLArgIdx;
 
   if (thistype) {
     // Add the this pointer for member functions
+#if LDC_LLVM_VER >= 1500
+    llvm::AttrBuilder attrs(getGlobalContext());
+#else
     llvm::AttrBuilder attrs;
+#endif
     attrs.addAttribute(LLAttribute::NonNull);
     if (fd && fd->isCtorDeclaration()) {
       attrs.addAttribute(LLAttribute::Returned);
     }
     newIrFty.arg_this = new IrFuncTyArg(
-        thistype, thistype->toBasetype()->ty == TY::Tstruct, attrs);
+        thistype, thistype->toBasetype()->ty == TY::Tstruct, std::move(attrs));
     ++nextLLArgIdx;
   } else if (nesttype) {
     // Add the context pointer for nested functions
+#if LDC_LLVM_VER >= 1500
+    llvm::AttrBuilder attrs(getGlobalContext());
+#else
     llvm::AttrBuilder attrs;
+#endif
     attrs.addAttribute(LLAttribute::NonNull);
-    newIrFty.arg_nest = new IrFuncTyArg(nesttype, false, attrs);
+    newIrFty.arg_nest = new IrFuncTyArg(nesttype, false, std::move(attrs));
     ++nextLLArgIdx;
   }
 
@@ -179,7 +195,11 @@ llvm::FunctionType *DtoFunctionType(Type *type, IrFuncTy &irFty, Type *thistype,
     bool passPointer = arg->storageClass & (STCref | STCout);
 
     Type *loweredDType = arg->type;
+#if LDC_LLVM_VER >= 1500
+    llvm::AttrBuilder attrs(getGlobalContext());
+#else
     llvm::AttrBuilder attrs;
+#endif
     if (arg->storageClass & STClazy) {
       // Lazy arguments are lowered to delegates.
       Logger::println("lazy param");
@@ -217,7 +237,7 @@ llvm::FunctionType *DtoFunctionType(Type *type, IrFuncTy &irFty, Type *thistype,
       }
     }
 
-    newIrFty.args.push_back(new IrFuncTyArg(loweredDType, passPointer, attrs));
+    newIrFty.args.push_back(new IrFuncTyArg(loweredDType, passPointer, std::move(attrs)));
     newIrFty.args.back()->parametersIdx = i;
     ++nextLLArgIdx;
   }
diff --git a/gen/inlineir.cpp b/gen/inlineir.cpp
index c2c0c45a9a..2a881c2704 100644
--- a/gen/inlineir.cpp
+++ b/gen/inlineir.cpp
@@ -37,7 +37,10 @@ struct TempDisableDiscardValueNames {
 /// Note: don't add function _parameter_ attributes
 void copyFnAttributes(llvm::Function *wannabe, llvm::Function *idol) {
   auto attrSet = idol->getAttributes();
-#if LDC_LLVM_VER >= 1400
+#if   LDC_LLVM_VER >= 1500
+  auto fnAttrSet = attrSet.getFnAttrs();
+  wannabe->addFnAttrs(llvm::AttrBuilder(getGlobalContext(), fnAttrSet));
+#elif LDC_LLVM_VER >= 1400
   auto fnAttrSet = attrSet.getFnAttrs();
   wannabe->addFnAttrs(fnAttrSet);
 #else
diff --git a/gen/nested.cpp b/gen/nested.cpp
index 3e84afd374..a6c3b8ef2f 100644
--- a/gen/nested.cpp
+++ b/gen/nested.cpp
@@ -125,7 +125,11 @@ DValue *DtoNestedVariable(const Loc &loc, Type *astype, VarDeclaration *vd,
   // Make the DWARF variable address relative to the context pointer (ctx);
   // register all ops (offsetting, dereferencing) required to get there in the
   // following list.
+#if LDC_LLVM_VER >= 1500
+  LLSmallVector<uint64_t, 4> dwarfAddrOps;
+#else
   LLSmallVector<int64_t, 4> dwarfAddrOps;
+#endif
 
   const auto offsetToNthField = [&val, &dwarfAddrOps](unsigned fieldIndex,
                                                       const char *name = "") {
diff --git a/gen/passes/GarbageCollect2Stack.cpp b/gen/passes/GarbageCollect2Stack.cpp
index 80d52203c1..fadc232227 100644
--- a/gen/passes/GarbageCollect2Stack.cpp
+++ b/gen/passes/GarbageCollect2Stack.cpp
@@ -12,11 +12,6 @@
 //
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "dgc2stack"
-#if LDC_LLVM_VER < 700
-#define LLVM_DEBUG DEBUG
-#endif
-
 #include "gen/attributes.h"
 #include "metadata.h"
 #include "gen/passes/Passes.h"
@@ -42,6 +37,11 @@
 #include "llvm/Support/raw_ostream.h"
 #include <algorithm>
 
+#define DEBUG_TYPE "dgc2stack"
+#if LDC_LLVM_VER < 700
+#define LLVM_DEBUG DEBUG
+#endif
+
 using namespace llvm;
 
 STATISTIC(NumGcToStack, "Number of calls promoted to constant-size allocas");
diff --git a/gen/tocall.cpp b/gen/tocall.cpp
index 4c71dfadec..c5aeb75609 100644
--- a/gen/tocall.cpp
+++ b/gen/tocall.cpp
@@ -131,7 +131,11 @@ static void addExplicitArguments(std::vector<LLValue *> &args, AttrSet &attrs,
     Type *argType = argexps[i]->type;
     bool passByVal = gABI->passByVal(irFty.type, argType);
 
+#if LDC_LLVM_VER >= 1500
+    llvm::AttrBuilder initialAttrs(getGlobalContext());
+#else
     llvm::AttrBuilder initialAttrs;
+#endif
     if (passByVal) {
 #if LDC_LLVM_VER >= 1200
       initialAttrs.addByValAttr(DtoType(argType));
@@ -144,7 +148,7 @@ static void addExplicitArguments(std::vector<LLValue *> &args, AttrSet &attrs,
       DtoAddExtendAttr(argType, initialAttrs);
     }
 
-    optionalIrArgs.push_back(new IrFuncTyArg(argType, passByVal, initialAttrs));
+    optionalIrArgs.push_back(new IrFuncTyArg(argType, passByVal, std::move(initialAttrs)));
     optionalIrArgs.back()->parametersIdx = i;
   }
 
@@ -1048,7 +1052,12 @@ DValue *DtoCallFunction(const Loc &loc, Type *resulttype, DValue *fnval,
     call->setCallingConv(gABI->callingConv(tf, iab.hasContext));
   }
   // merge in function attributes set in callOrInvoke
-#if LDC_LLVM_VER >= 1400
+#if LDC_LLVM_VER >= 1500
+    auto attrbuildattribs = call->getAttributes().getFnAttrs();
+    attrlist = attrlist.addFnAttributes(
+      gIR->context(),
+      llvm::AttrBuilder(gIR->context(), attrbuildattribs));
+#elif LDC_LLVM_VER >= 1400
   attrlist = attrlist.addFnAttributes(
       gIR->context(),
       llvm::AttrBuilder(call->getAttributes(), LLAttributeList::FunctionIndex));
diff --git a/gen/uda.cpp b/gen/uda.cpp
index e782f2347b..2e7a963ea7 100644
--- a/gen/uda.cpp
+++ b/gen/uda.cpp
@@ -194,7 +194,11 @@ void applyAttrAllocSize(StructLiteralExp *sle, IrFunction *irFunc) {
   const auto llvmSizeIdx = sizeArgIdx + offset;
   const auto llvmNumIdx = numArgIdx + offset;
 
+#if LDC_LLVM_VER >= 1500
+  llvm::AttrBuilder builder(getGlobalContext());
+#else
   llvm::AttrBuilder builder;
+#endif
   if (numArgIdx >= 0) {
     builder.addAllocSizeAttr(llvmSizeIdx, llvmNumIdx);
   } else {
@@ -425,7 +429,11 @@ void applyFuncDeclUDAs(FuncDeclaration *decl, IrFunction *irFunc) {
       if (ident == Id::udaAllocSize) {
         applyAttrAllocSize(sle, irFunc);
       } else if (ident == Id::udaLLVMAttr) {
+#if LDC_LLVM_VER >= 1500
+        llvm::AttrBuilder attrs(getGlobalContext());
+#else
         llvm::AttrBuilder attrs;
+#endif
         applyAttrLLVMAttr(sle, attrs);
 #if LDC_LLVM_VER >= 1400
         func->addFnAttrs(attrs);
diff --git a/ir/irfuncty.cpp b/ir/irfuncty.cpp
index cdc5570681..58ddcda11a 100644
--- a/ir/irfuncty.cpp
+++ b/ir/irfuncty.cpp
@@ -17,10 +17,26 @@
 #include "gen/logger.h"
 #include "gen/tollvm.h"
 
+IrFuncTyArg::IrFuncTyArg(Type *t, bool bref)
+    : type(t),
+      ltype(t != Type::tvoid && bref ? DtoType(t->pointerTo()) : DtoType(t)),
+      attrs(
+#if LDC_LLVM_VER < 1500
+        llvm::AttrBuilder {}
+#else
+        llvm::AttrBuilder(getGlobalContext())
+#endif
+      ),
+      byref(bref)
+{
+  mem.addRange(&type, sizeof(type));
+}
+
 IrFuncTyArg::IrFuncTyArg(Type *t, bool bref, llvm::AttrBuilder a)
     : type(t),
       ltype(t != Type::tvoid && bref ? DtoType(t->pointerTo()) : DtoType(t)),
       attrs(std::move(a)), byref(bref) {
+
   mem.addRange(&type, sizeof(type));
 }
 
diff --git a/ir/irfuncty.h b/ir/irfuncty.h
index 38f0ecf97a..42adc5f440 100644
--- a/ir/irfuncty.h
+++ b/ir/irfuncty.h
@@ -76,7 +76,8 @@ struct IrFuncTyArg {
    *  @param byref Initial value for the 'byref' field. If true the initial
    *               LLVM Type will be of DtoType(type->pointerTo()), instead
    *               of just DtoType(type) */
-  IrFuncTyArg(Type *t, bool byref, llvm::AttrBuilder attrs = {});
+  IrFuncTyArg(Type *t, bool byref);
+  IrFuncTyArg(Type *t, bool byref, llvm::AttrBuilder);
   IrFuncTyArg(const IrFuncTyArg &) = delete;
 
   ~IrFuncTyArg();

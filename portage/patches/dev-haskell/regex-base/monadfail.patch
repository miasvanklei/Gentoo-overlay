--- a/Text/Regex/Base/Context.hs	2019-08-27 13:36:17.411965277 +0200
+++ b/Text/Regex/Base/Context.hs	2019-08-27 13:37:37.179507071 +0200
@@ -244,29 +244,29 @@
 {-# INLINE nullArray #-}
 nullArray = listArray (1,0) []
 
-nullFail :: (RegexContext regex source (AllMatches [] target),Monad m) => regex -> source -> m (AllMatches [] target)
+nullFail :: (RegexContext regex source (AllMatches [] target),MonadFail m) => regex -> source -> m (AllMatches [] target)
 {-# INLINE nullFail #-}
 nullFail r s = case match r s of
                  (AllMatches []) -> regexFailed
                  xs -> return xs
 
-nullFailText :: (RegexContext regex source (AllTextMatches [] target),Monad m) => regex -> source -> m (AllTextMatches [] target)
+nullFailText :: (RegexContext regex source (AllTextMatches [] target),MonadFail m) => regex -> source -> m (AllTextMatches [] target)
 {-# INLINE nullFailText #-}
 nullFailText r s = case match r s of
                      (AllTextMatches []) -> regexFailed
                      xs -> return xs
 
-nullFail' :: (RegexContext regex source ([] target),Monad m) => regex -> source -> m ([] target)
+nullFail' :: (RegexContext regex source ([] target),MonadFail m) => regex -> source -> m ([] target)
 {-# INLINE nullFail' #-}
 nullFail' r s = case match r s of
                  ([]) -> regexFailed
                  xs -> return xs
 
-regexFailed :: (Monad m) => m b
+regexFailed :: (MonadFail m) => m b
 {-# INLINE regexFailed #-}
 regexFailed =  fail $ "regex failed to match"
 
-actOn :: (RegexLike r s,Monad m) => ((s,MatchText s,s)->t) -> r -> s -> m t
+actOn :: (RegexLike r s, MonadFail m) => ((s,MatchText s,s)->t) -> r -> s -> m t
 {-# INLINE actOn #-}
 actOn f r s = case matchOnceText r s of
     Nothing -> regexFailed
--- a/Text/Regex/Base/Impl.hs	2019-08-27 13:40:15.182609438 +0200
+++ b/Text/Regex/Base/Impl.hs	2019-08-27 13:40:55.604896645 +0200
@@ -37,11 +37,11 @@
 import Text.Regex.Base
 import Data.Array((!))
 
-regexFailed :: (Monad m) => m b
+regexFailed :: (MonadFail m) => m b
 {-# INLINE regexFailed #-}
 regexFailed =  fail $ "regex failed to match"
 
-actOn :: (RegexLike r s,Monad m) => ((s,MatchText s,s)->t) -> r -> s -> m t
+actOn :: (RegexLike r s, MonadFail m) => ((s,MatchText s,s)->t) -> r -> s -> m t
 {-# INLINE actOn #-}
 actOn f r s = case matchOnceText r s of
     Nothing -> regexFailed
@@ -53,6 +53,6 @@
     Nothing -> empty
     Just (_,ma,_) -> fst (ma!0)
 
-polymatchM :: (RegexLike a b,Monad m) => a -> b -> m b
+polymatchM :: (RegexLike a b, MonadFail m) => a -> b -> m b
 {-# INLINE polymatchM #-}
 polymatchM =  actOn (\(_,ma,_)->fst (ma!0))
--- a/Text/Regex/Base/RegexLike.hs	2019-08-27 13:39:27.580273726 +0200
+++ b/Text/Regex/Base/RegexLike.hs	2019-08-27 13:39:53.043452954 +0200
@@ -102,9 +102,9 @@
   -- | Specify your own options
   makeRegexOpts :: compOpt -> execOpt -> source -> regex
   -- | make using the defaultCompOpt and defaultExecOpt, reporting errors with fail
-  makeRegexM :: (Monad m) => source -> m regex
+  makeRegexM :: (MonadFail m, Monad m) => source -> m regex
   -- | Specify your own options, reporting errors with fail
-  makeRegexOptsM :: (Monad m) => compOpt -> execOpt -> source -> m regex
+  makeRegexOptsM :: (MonadFail m, Monad m) => compOpt -> execOpt -> source -> m regex
 
   makeRegex = makeRegexOpts defaultCompOpt defaultExecOpt
   makeRegexM = makeRegexOptsM defaultCompOpt defaultExecOpt
@@ -189,7 +189,7 @@
 -- > ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"]
 class (RegexLike regex source) => RegexContext regex source target where
   match :: regex -> source -> target
-  matchM :: (Monad m) => regex -> source -> m target
+  matchM :: (MonadFail m, Monad m) => regex -> source -> m target
 
 ----------------
 -- | Extract allows for indexing operations on String or ByteString.

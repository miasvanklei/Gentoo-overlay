--- a/drivers/usb/dwc3/core.c	2022-06-30 14:04:52.437972370 +0200
+++ b/drivers/usb/dwc3/core.c	2022-06-30 14:09:14.700018096 +0200
@@ -109,7 +109,7 @@
 
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 	reg &= ~(DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_OTG));
-	reg |= DWC3_GCTL_PRTCAPDIR(mode);
+	reg |= DWC3_GCTL_PRTCAPDIR(mode & DWC3_GCTL_PRTCAP_OTG);
 	dwc3_writel(dwc->regs, DWC3_GCTL, reg);
 
 	dwc->current_dr_role = mode;
@@ -143,6 +151,7 @@
 		dwc3_host_exit(dwc);
 		break;
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		dwc3_gadget_exit(dwc);
 		dwc3_event_buffers_cleanup(dwc);
 		break;
@@ -158,10 +167,37 @@
 	if (dwc->current_dr_role && ((DWC3_IP_IS(DWC3) ||
 			DWC3_VER_IS_PRIOR(DWC31, 190A)) &&
 			desired_dr_role != DWC3_GCTL_PRTCAP_OTG)) {
+		/*
+		* RK3399 TypeC PHY needs to be powered off and powered on again
+		* for it to apply the correct Type-C plug orientation setting
+		* and reconfigure itself.
+		*
+		* For that purpose we observe complete USB disconnect via
+		* extcon in drd.c and pass it to __dwc3_set_mode as
+		* desired_dr_role == 0.
+		*
+		* We thus handle transitions between three states of
+		* desired_dr_role here:
+		*
+		* - DWC3_GCTL_PRTCAP_HOST
+		* - DWC3_GCTL_PRTCAP_DEVICE
+		* - DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED - almost equivalent to
+		*   DWC3_GCTL_PRTCAP_DEVICE, present only to distinguish
+		*   disconnected state, and so that set_mode is called when
+		*   user plugs in the device to the host.
+		*/
+		if (dwc->usb3_phy_powered && dwc->usb3_phy_reset_quirk)
+			phy_power_off(dwc->usb3_generic_phy);
+
 		reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 		reg |= DWC3_GCTL_CORESOFTRESET;
 		dwc3_writel(dwc->regs, DWC3_GCTL, reg);
 
+		if (dwc->usb3_phy_reset_quirk) {
+			ret = phy_power_on(dwc->usb3_generic_phy);
+			dwc->usb3_phy_powered = ret >= 0;
+		}
+
 		/*
 		 * Wait for internal clocks to synchronized. DWC_usb31 and
 		 * DWC_usb32 may need at least 50ms (less for DWC_usb3). To
@@ -200,6 +236,7 @@
 		}
 		break;
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		dwc3_core_soft_reset(dwc);
 
 		dwc3_event_buffers_setup(dwc);
@@ -835,7 +872,9 @@
 	usb_phy_set_suspend(dwc->usb2_phy, 1);
 	usb_phy_set_suspend(dwc->usb3_phy, 1);
 	phy_power_off(dwc->usb2_generic_phy);
-	phy_power_off(dwc->usb3_generic_phy);
+	if (dwc->usb3_phy_powered)
+		phy_power_off(dwc->usb3_generic_phy);
+	dwc->usb3_phy_powered = false;

 	usb_phy_shutdown(dwc->usb2_phy);
 	usb_phy_shutdown(dwc->usb3_phy);
 }
@@ -1124,6 +1163,8 @@
 	if (ret < 0)
 		goto err3;
 
+	dwc->usb3_phy_powered = true;
+
 	ret = dwc3_event_buffers_setup(dwc);
 	if (ret) {
 		dev_err(dwc->dev, "failed to setup event buffers\n");
@@ -1231,6 +1272,7 @@
 
 err4:
 	phy_power_off(dwc->usb3_generic_phy);
+	dwc->usb3_phy_powered = false;
 
 err3:
 	phy_power_off(dwc->usb2_generic_phy);
@@ -1507,6 +1549,8 @@
 
 	dwc->dis_split_quirk = device_property_read_bool(dev,
 				"snps,dis-split-quirk");
+	dwc->usb3_phy_reset_quirk = device_property_read_bool(dev,
+				"snps,usb3-phy-reset-quirk");
 
 	dwc->lpm_nyet_threshold = lpm_nyet_threshold;
 	dwc->tx_de_emphasis = tx_de_emphasis;
@@ -1892,6 +1936,7 @@
 
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		if (pm_runtime_suspended(dwc->dev))
 			break;
 		spin_lock_irqsave(&dwc->lock, flags);
@@ -1952,11 +1997,12 @@
 
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		ret = dwc3_core_init_for_resume(dwc);
 		if (ret)
 			return ret;
 
-		dwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_DEVICE);
+		dwc3_set_prtcap(dwc, dwc->current_dr_role);
 		spin_lock_irqsave(&dwc->lock, flags);
 		dwc3_gadget_resume(dwc);
 		spin_unlock_irqrestore(&dwc->lock, flags);
@@ -2015,6 +2061,7 @@
 {
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		if (dwc->connected)
 			return -EBUSY;
 		break;
@@ -2057,6 +2104,7 @@
 
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		dwc3_gadget_process_pending_events(dwc);
 		break;
 	case DWC3_GCTL_PRTCAP_HOST:
@@ -2076,6 +2124,7 @@
 
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_DEVICE:
+	case DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED:
 		if (dwc3_runtime_checks(dwc))
 			return -EBUSY;
 		break;
--- a/drivers/usb/dwc3/core.h	2022-06-30 14:04:54.417006326 +0200
+++ b/drivers/usb/dwc3/core.h	2022-06-30 14:05:33.007656527 +0200
@@ -243,6 +243,12 @@
 #define DWC3_GCTL_PRTCAP_HOST	1
 #define DWC3_GCTL_PRTCAP_DEVICE	2
 #define DWC3_GCTL_PRTCAP_OTG	3
+/* This is not a real register value, but a special state used for
+ * current_dr_role to mean DWC3_GCTL_PRTCAP_DEVICE in disconnected
+ * state. Value is chosen so that masking with register width
+ * produces DWC3_GCTL_PRTCAP_DEVICE value.
+ */
+#define DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED	6
 
 #define DWC3_GCTL_CORESOFTRESET		BIT(11)
 #define DWC3_GCTL_SOFITPSYNC		BIT(10)
@@ -1102,6 +1108,10 @@
  *	3	- Reserved
  * @dis_metastability_quirk: set to disable metastability quirk.
  * @dis_split_quirk: set to disable split boundary.
+ * @usb3_phy_reset_quirk: set to power cycle the USB3 PHY during mode
+ *                        changes. Useful on RK3399 that needs this
+ *                        to apply Type-C orientation changes in
+ *                        Type-C phy driver.
  * @imod_interval: set the interrupt moderation interval in 250ns
  *			increments or 0 to disable.
  * @max_cfg_eps: current max number of IN eps used across all USB configs.
@@ -1151,6 +1161,7 @@
 
 	struct phy		*usb2_generic_phy;
 	struct phy		*usb3_generic_phy;
+	bool			usb3_phy_powered;
 
 	bool			phys_ready;
 
@@ -1316,6 +1327,8 @@
 	unsigned		dis_split_quirk:1;
 	unsigned		async_callbacks:1;
 
+	unsigned		usb3_phy_reset_quirk:1;
+
 	u16			imod_interval;
 
 	int			max_cfg_eps;
--- a/drivers/usb/dwc3/drd.c	2022-06-30 14:04:59.593094852 +0200
+++ b/drivers/usb/dwc3/drd.c	2022-06-30 14:05:12.623315874 +0200
@@ -415,15 +415,28 @@
 
 static void dwc3_drd_update(struct dwc3 *dwc)
 {
-	int id;
+	u32 mode = DWC3_GCTL_PRTCAP_DEVICE_DISCONNECTED;
+	int ret;
 
 	if (dwc->edev) {
-		id = extcon_get_state(dwc->edev, EXTCON_USB_HOST);
-		if (id < 0)
-			id = 0;
-		dwc3_set_mode(dwc, id ?
-			      DWC3_GCTL_PRTCAP_HOST :
-			      DWC3_GCTL_PRTCAP_DEVICE);
+		ret = extcon_get_state(dwc->edev, EXTCON_USB_HOST);
+		if (ret > 0)
+			mode = DWC3_GCTL_PRTCAP_HOST;
+
+		if (dwc->usb3_phy_reset_quirk) {
+			/*
+			 * With this quirk enabled, we want to pass 0
+			 * to dwc3_set_mode to signal no USB connection
+			 * state.
+			 */
+			ret = extcon_get_state(dwc->edev, EXTCON_USB);
+			if (ret > 0)
+				mode = DWC3_GCTL_PRTCAP_DEVICE;
+		} else {
+			mode = DWC3_GCTL_PRTCAP_DEVICE;
+		}
+
+		dwc3_set_mode(dwc, mode);
 	}
 }
 
@@ -432,9 +445,7 @@
 {
 	struct dwc3 *dwc = container_of(nb, struct dwc3, edev_nb);
 
-	dwc3_set_mode(dwc, event ?
-		      DWC3_GCTL_PRTCAP_HOST :
-		      DWC3_GCTL_PRTCAP_DEVICE);
+	dwc3_drd_update(dwc);
 
 	return NOTIFY_DONE;
 }
@@ -589,8 +600,7 @@
 
 	if (dwc->edev) {
 		dwc->edev_nb.notifier_call = dwc3_drd_notifier;
-		ret = extcon_register_notifier(dwc->edev, EXTCON_USB_HOST,
-					       &dwc->edev_nb);
+		ret = extcon_register_notifier_all(dwc->edev, &dwc->edev_nb);
 		if (ret < 0) {
 			dev_err(dwc->dev, "couldn't register cable notifier\n");
 			return ret;

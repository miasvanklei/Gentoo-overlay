diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h6-pine-h64.dts b/arch/arm64/boot/dts/allwinner/sun50i-h6-pine-h64.dts
index 1ffd68f43f8758..aab11a49d2cb1b 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h6-pine-h64.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h6-pine-h64.dts
@@ -81,6 +81,19 @@
 	};
 };
 
+&ac200_codec {
+	avcc-supply = <&reg_aldo2>;
+	status = "okay";
+};
+
+&ac200_pwm_clk {
+	status = "okay";
+};
+
+&analog {
+	status = "okay";
+};
+
 &cpu0 {
 	cpu-supply = <&reg_dcdca>;
 };
@@ -123,6 +136,14 @@
 	};
 };
 
+&i2c3 {
+	status = "okay";
+};
+
+&i2s3 {
+	status = "okay";
+};
+
 &mdio {
 	ext_rgmii_phy: ethernet-phy@1 {
 		compatible = "ethernet-phy-ieee802.3-c22";
@@ -161,6 +182,10 @@
 	vcc-pg-supply = <&reg_aldo1>;
 };
 
+&pwm {
+	status = "okay";
+};
+
 &r_i2c {
 	status = "okay";
 
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
index 53f6660656ac59..2f94c13e3d73cd 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
@@ -17,6 +17,32 @@
 	#address-cells = <1>;
 	#size-cells = <1>;
 
+	analog: analog-codec {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "ac200-audio";
+		simple-audio-card,mclk-fs = <512>;
+		status = "disabled";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s3>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&ac200_codec>;
+		};
+	};
+
+	ac200_pwm_clk: ac200_clk {
+		compatible = "pwm-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwm1_pin>;
+		pwms = <&pwm 1 42 0>;
+		status = "disabled";
+	};
+
 	cpus {
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -280,6 +306,14 @@
 			cpu_speed_grade: cpu-speed-grade@1c {
 				reg = <0x1c 0x4>;
 			};
+
+			ephy_calib: ephy_calib@2c {
+				reg = <0x2c 0x2>;
+			};
+
+			ac200_bg: ac200_bg@30 {
+				reg = <0x30 0x2>;
+			};
 		};
 
 		timer@3009000 {
@@ -334,6 +368,13 @@
 				drive-strength = <40>;
 			};
 
+			ext_rmii_pins: rmii_pins {
+				pins = "PA0", "PA1", "PA2", "PA3", "PA4",
+				       "PA5", "PA6", "PA7", "PA8", "PA9";
+				function = "emac";
+				drive-strength = <40>;
+			};
+
 			hdmi_pins: hdmi-pins {
 				pins = "PH8", "PH9", "PH10";
 				function = "hdmi";
@@ -354,6 +395,17 @@
 				function = "i2c2";
 			};
 
+			i2c3_pins: i2c3-pins {
+				pins = "PB17", "PB18";
+				function = "i2c3";
+				bias-pull-up;
+			};
+
+			i2s3_pins: i2s3-pins {
+				pins = "PB12", "PB13", "PB14", "PB15", "PB16";
+				function = "i2s3";
+			};
+
 			mmc0_pins: mmc0-pins {
 				pins = "PF0", "PF1", "PF2", "PF3",
 				       "PF4", "PF5";
@@ -380,6 +432,11 @@
 				bias-pull-up;
 			};
 
+			pwm1_pin: pwm1-pin {
+				pins = "PB19";
+				function = "pwm1";
+			};
+
 			/omit-if-no-ref/
 			spi0_pins: spi0-pins {
 				pins = "PC0", "PC2", "PC3";
@@ -583,6 +640,49 @@
 			#size-cells = <0>;
 		};
 
+		i2c3: i2c@5002c00 {
+			compatible = "allwinner,sun50i-h6-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x05002c00 0x400>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C3>;
+			resets = <&ccu RST_BUS_I2C3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c3_pins>;
+			clock-frequency = <100000>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ac200: mfd@10 {
+				compatible = "x-powers,ac200";
+				reg = <0x10>;
+				clocks = <&ac200_pwm_clk>;
+				interrupt-parent = <&pio>;
+				interrupts = <1 20 IRQ_TYPE_LEVEL_LOW>;
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				nvmem-cells = <&ac200_bg>;
+				nvmem-cell-names = "bandgap";
+
+				ac200_ephy_ctl: syscon {
+					compatible = "x-powers,ac200-ephy-ctl";
+					nvmem-cells = <&ephy_calib>;
+					nvmem-cell-names = "calibration";
+					#clock-cells = <0>;
+					#reset-cells = <0>;
+					phy-mode = "rmii";
+					status = "disabled";
+				};
+
+				ac200_codec: codec {
+					#sound-dai-cells = <0>;
+					compatible = "x-powers,ac200-codec";
+					status = "disabled";
+				};
+			};
+		};
+
 		spi0: spi@5010000 {
 			compatible = "allwinner,sun50i-h6-spi",
 				     "allwinner,sun8i-h3-spi";
@@ -633,6 +733,21 @@
 			};
 		};
 
+		i2s3: i2s@508f000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h6-i2s";
+			reg = <0x0508f000 0x1000>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2S3>, <&ccu CLK_I2S3>;
+			clock-names = "apb", "mod";
+			dmas = <&dma 6>, <&dma 6>;
+			resets = <&ccu RST_BUS_I2S3>;
+			dma-names = "rx", "tx";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s3_pins>;
+			status = "disabled";
+		};
+
 		i2s1: i2s@5091000 {
 			#sound-dai-cells = <0>;
 			compatible = "allwinner,sun50i-h6-i2s";
diff --git a/drivers/clk/clk-gate.c b/drivers/clk/clk-gate.c
index 64283807600b65..f83aef5e6e79c9 100644
--- a/drivers/clk/clk-gate.c
+++ b/drivers/clk/clk-gate.c
@@ -9,6 +9,7 @@
 #include <linux/clk-provider.h>
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/err.h>
@@ -124,11 +125,42 @@ const struct clk_ops clk_gate_ops = {
 };
 EXPORT_SYMBOL_GPL(clk_gate_ops);
 
+static int clk_gate_regmap_setclrbit(struct clk_hw *hw, bool enable)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+	bool set = gate->flags & CLK_GATE_SET_TO_DISABLE;
+
+	set ^= enable;
+
+	if (set)
+		return regmap_set_bits(gate->regmap, gate->regmap_offs,
+				       BIT(gate->bit_idx));
+	else
+		return regmap_clear_bits(gate->regmap, gate->regmap_offs,
+					 BIT(gate->bit_idx));
+}
+
+static int clk_gate_regmap_prepare(struct clk_hw *hw)
+{
+	return clk_gate_regmap_setclrbit(hw, true);
+}
+
+static void clk_gate_regmap_unprepare(struct clk_hw *hw)
+{
+	clk_gate_regmap_setclrbit(hw, false);
+}
+
+const struct clk_ops clk_gate_regmap_ops = {
+	.prepare = clk_gate_regmap_prepare,
+	.unprepare = clk_gate_regmap_unprepare,
+};
+
 struct clk_hw *__clk_hw_register_gate(struct device *dev,
 		struct device_node *np, const char *name,
 		const char *parent_name, const struct clk_hw *parent_hw,
 		const struct clk_parent_data *parent_data,
 		unsigned long flags,
+		struct regmap *regmap, unsigned int regmap_offs,
 		void __iomem *reg, u8 bit_idx,
 		u8 clk_gate_flags, spinlock_t *lock)
 {
@@ -150,7 +182,10 @@ struct clk_hw *__clk_hw_register_gate(struct device *dev,
 		return ERR_PTR(-ENOMEM);
 
 	init.name = name;
-	init.ops = &clk_gate_ops;
+	if (regmap)
+		init.ops = &clk_gate_regmap_ops;
+	else
+		init.ops = &clk_gate_ops;
 	init.flags = flags;
 	init.parent_names = parent_name ? &parent_name : NULL;
 	init.parent_hws = parent_hw ? &parent_hw : NULL;
@@ -162,6 +197,8 @@ struct clk_hw *__clk_hw_register_gate(struct device *dev,
 
 	/* struct clk_gate assignments */
 	gate->reg = reg;
+	gate->regmap = regmap;
+	gate->regmap_offs = regmap_offs;
 	gate->bit_idx = bit_idx;
 	gate->flags = clk_gate_flags;
 	gate->lock = lock;
@@ -197,6 +234,22 @@ struct clk *clk_register_gate(struct device *dev, const char *name,
 }
 EXPORT_SYMBOL_GPL(clk_register_gate);
 
+struct clk *clk_register_regmap_gate(struct device *dev, const char *name,
+		const char *parent_name, unsigned long flags,
+		struct regmap *regmap, unsigned int regmap_offs,
+		u8 bit_idx, u8 clk_gate_flags)
+{
+	struct clk_hw *hw;
+
+	hw = clk_hw_register_regmap_gate(dev, name, parent_name, flags, regmap,
+					 regmap_offs, bit_idx, clk_gate_flags);
+
+	if (IS_ERR(hw))
+		return ERR_CAST(hw);
+	return hw->clk;
+}
+EXPORT_SYMBOL_GPL(clk_register_regmap_gate);
+
 void clk_unregister_gate(struct clk *clk)
 {
 	struct clk_gate *gate;
@@ -234,6 +287,7 @@ struct clk_hw *__devm_clk_hw_register_gate(struct device *dev,
 		const char *parent_name, const struct clk_hw *parent_hw,
 		const struct clk_parent_data *parent_data,
 		unsigned long flags,
+		struct regmap *regmap, unsigned int regmap_offs,
 		void __iomem *reg, u8 bit_idx,
 		u8 clk_gate_flags, spinlock_t *lock)
 {
@@ -244,8 +298,8 @@ struct clk_hw *__devm_clk_hw_register_gate(struct device *dev,
 		return ERR_PTR(-ENOMEM);
 
 	hw = __clk_hw_register_gate(dev, np, name, parent_name, parent_hw,
-				    parent_data, flags, reg, bit_idx,
-				    clk_gate_flags, lock);
+				    parent_data, flags, regmap, regmap_offs,
+				    reg, bit_idx, clk_gate_flags, lock);
 
 	if (!IS_ERR(hw)) {
 		*ptr = hw;
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 8b93856de432ae..b72ef08aea2bb5 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -178,6 +178,18 @@ config MFD_AC100
 	  This driver include only the core APIs. You have to select individual
 	  components like codecs or RTC under the corresponding menus.
 
+config MFD_AC200
+	tristate "X-Powers AC200"
+	select MFD_CORE
+	select REGMAP_I2C
+	depends on COMMON_CLK
+	depends on I2C
+	depends on OF
+	help
+	  If you say Y here you get support for the X-Powers AC200 IC.
+	  This driver include only the core APIs. You have to select individual
+	  components like Ethernet PHY or codec under the corresponding menus.
+
 config MFD_AXP20X
 	tristate
 	select MFD_CORE
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 7ed3ef4a698cf2..91dc530d0bde2e 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -144,6 +144,7 @@ obj-$(CONFIG_MFD_DA9052_SPI)	+= da9052-spi.o
 obj-$(CONFIG_MFD_DA9052_I2C)	+= da9052-i2c.o
 
 obj-$(CONFIG_MFD_AC100)		+= ac100.o
+obj-$(CONFIG_MFD_AC200)		+= ac200.o
 obj-$(CONFIG_MFD_AXP20X)	+= axp20x.o
 obj-$(CONFIG_MFD_AXP20X_I2C)	+= axp20x-i2c.o
 obj-$(CONFIG_MFD_AXP20X_RSB)	+= axp20x-rsb.o
diff --git a/drivers/mfd/ac200.c b/drivers/mfd/ac200.c
new file mode 100644
index 00000000000000..625b119f53cfcc
--- /dev/null
+++ b/drivers/mfd/ac200.c
@@ -0,0 +1,190 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * MFD core driver for X-Powers' AC200 IC
+ *
+ * The AC200 is a chip which is co-packaged with Allwinner H6 SoC and
+ * includes analog audio codec, analog TV encoder, ethernet PHY, eFuse
+ * and RTC.
+ *
+ * Copyright (c) 2019 Jernej Skrabec <jernej.skrabec@gmail.com>
+ *
+ * Based on AC100 driver with following copyrights:
+ * Copyright (2016) Chen-Yu Tsai
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/mfd/core.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+
+struct ac200_dev {
+	struct clk	*clk;
+	struct regmap	*regmap;
+};
+
+#define AC200_SYS_CONTROL	0x0002
+#define AC200_SYS_BG_CTL	0x0050
+
+/* interface register (can be accessed from any page) */
+#define AC200_TWI_REG_ADDR_H	0xFE
+
+#define AC200_MAX_REG		0xA1F2
+
+static const struct regmap_range_cfg ac200_range_cfg[] = {
+	{
+		.range_max = AC200_MAX_REG,
+		.selector_reg = AC200_TWI_REG_ADDR_H,
+		.selector_mask = 0xff,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 256,
+	}
+};
+
+static const struct regmap_config ac200_regmap_config = {
+	.name		= "AC200",
+	.reg_bits	= 8,
+	.reg_stride	= 2,
+	.val_bits	= 16,
+	.ranges		= ac200_range_cfg,
+	.num_ranges	= ARRAY_SIZE(ac200_range_cfg),
+	.max_register	= AC200_MAX_REG,
+};
+
+static struct mfd_cell ac200_cells[] = {
+	{
+		.name		= "ac200-codec",
+		.of_compatible	= "x-powers,ac200-codec",
+	}, {
+		.name		= "ac200-ephy-ctl",
+		.of_compatible	= "x-powers,ac200-ephy-ctl",
+	},
+};
+
+static int ac200_i2c_probe(struct i2c_client *i2c)
+{
+	struct device *dev = &i2c->dev;
+	struct nvmem_cell *bgcell;
+	struct ac200_dev *ac200;
+	u16 *bgdata, bgval;
+	size_t bglen;
+	int ret;
+
+	ac200 = devm_kzalloc(dev, sizeof(*ac200), GFP_KERNEL);
+	if (!ac200)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, ac200);
+
+	ac200->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(ac200->clk))
+		return dev_err_probe(dev, PTR_ERR(ac200->clk),
+				     "Can't obtain the clock\n");
+
+	ac200->regmap = devm_regmap_init_i2c(i2c, &ac200_regmap_config);
+	if (IS_ERR(ac200->regmap)) {
+		ret = PTR_ERR(ac200->regmap);
+		dev_err(dev, "Regmap init failed: %d\n", ret);
+		return ret;
+	}
+
+	bgcell = devm_nvmem_cell_get(dev, "bandgap");
+	if (IS_ERR(bgcell))
+		return dev_err_probe(dev, PTR_ERR(bgcell),
+				     "Unable to find bandgap data!\n");
+
+	bgdata = nvmem_cell_read(bgcell, &bglen);
+	if (IS_ERR(bgdata)) {
+		dev_err(dev, "Unable to read bandgap data!\n");
+		return PTR_ERR(bgdata);
+	}
+
+	if (bglen != 2) {
+		dev_err(dev, "Invalid nvmem bandgap length!\n");
+		kfree(bgdata);
+		return -EINVAL;
+	}
+
+	bgval = *bgdata;
+	kfree(bgdata);
+
+	ret = clk_prepare_enable(ac200->clk);
+	if (ret)
+		return ret;
+
+	/*
+	 * There is no documentation on how long we have to wait before
+	 * executing first operation. Vendor driver sleeps for 40 ms.
+	 */
+	msleep(40);
+
+	ret = regmap_write(ac200->regmap, AC200_SYS_CONTROL, 0);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(ac200->regmap, AC200_SYS_CONTROL, 1);
+	if (ret)
+		goto err;
+
+	if (bgval) {
+		/* bandgap register is not documented */
+		ret = regmap_write(ac200->regmap, AC200_SYS_BG_CTL,
+				   0x8280 | bgval);
+		if (ret)
+			goto err;
+	}
+
+	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE, ac200_cells,
+				   ARRAY_SIZE(ac200_cells), NULL, 0, NULL);
+	if (ret) {
+		dev_err(dev, "Failed to add MFD devices: %d\n", ret);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	clk_disable_unprepare(ac200->clk);
+	return ret;
+}
+
+static void ac200_i2c_remove(struct i2c_client *i2c)
+{
+	struct ac200_dev *ac200 = i2c_get_clientdata(i2c);
+
+	regmap_write(ac200->regmap, AC200_SYS_CONTROL, 0);
+
+	clk_disable_unprepare(ac200->clk);
+}
+
+static const struct i2c_device_id ac200_ids[] = {
+	{ "ac200", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ac200_ids);
+
+static const struct of_device_id ac200_of_match[] = {
+	{ .compatible = "x-powers,ac200" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ac200_of_match);
+
+static struct i2c_driver ac200_i2c_driver = {
+	.driver = {
+		.name	= "ac200",
+		.of_match_table	= of_match_ptr(ac200_of_match),
+	},
+	.probe	= ac200_i2c_probe,
+	.remove = ac200_i2c_remove,
+	.id_table = ac200_ids,
+};
+module_i2c_driver(ac200_i2c_driver);
+
+MODULE_DESCRIPTION("MFD core driver for AC200");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index c57a0262fb64f0..a1f8fdfc5762fb 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -63,6 +63,13 @@ config SFP
 
 comment "MII PHY device drivers"
 
+config AC200_PHY
+	tristate "AC200 EPHY"
+	depends on NVMEM
+	depends on OF
+	help
+	  Fast ethernet PHY as found in X-Powers AC200 multi-function device.
+
 config AMD_PHY
 	tristate "AMD PHYs"
 	help
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index f7138d3c896b3f..9ad2b8cc01b167 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_SFP)		+= sfp.o
 sfp-obj-$(CONFIG_SFP)		+= sfp-bus.o
 obj-y				+= $(sfp-obj-y) $(sfp-obj-m)
 
+obj-$(CONFIG_AC200_PHY)		+= ac200.o
 obj-$(CONFIG_ADIN_PHY)		+= adin.o
 obj-$(CONFIG_ADIN1100_PHY)	+= adin1100.o
 obj-$(CONFIG_AMD_PHY)		+= amd.o
diff --git a/drivers/net/phy/ac200.c b/drivers/net/phy/ac200.c
new file mode 100644
index 00000000000000..8499914f49b873
--- /dev/null
+++ b/drivers/net/phy/ac200.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0+
+/**
+ * Driver for AC200 Ethernet PHY
+ *
+ * Copyright (c) 2019 Jernej Skrabec <jernej.skrabec@gmail.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+
+#define AC200_EPHY_ID			0x00441400
+#define AC200_EPHY_ID_MASK		0x0ffffff0
+
+static int ac200_ephy_config_init(struct phy_device *phydev)
+{
+	phy_write(phydev, 0x1f, 0x0100);	/* Switch to Page 1 */
+	phy_write(phydev, 0x12, 0x4824);	/* Disable APS */
+
+	phy_write(phydev, 0x1f, 0x0200);	/* Switch to Page 2 */
+	phy_write(phydev, 0x18, 0x0000);	/* PHYAFE TRX optimization */
+
+	phy_write(phydev, 0x1f, 0x0600);	/* Switch to Page 6 */
+	phy_write(phydev, 0x14, 0x708f);	/* PHYAFE TX optimization */
+	phy_write(phydev, 0x13, 0xF000);	/* PHYAFE RX optimization */
+	phy_write(phydev, 0x15, 0x1530);
+
+	phy_write(phydev, 0x1f, 0x0800);	/* Switch to Page 8 */
+	phy_write(phydev, 0x18, 0x00bc);	/* PHYAFE TRX optimization */
+
+	phy_write(phydev, 0x1f, 0x0100);	/* switch to page 1 */
+	phy_clear_bits(phydev, 0x17, BIT(3));	/* disable intelligent EEE */
+
+	/* disable 802.3az EEE */
+	phy_write(phydev, 0x1f, 0x0200);	/* switch to page 2 */
+	phy_write(phydev, 0x18, 0x0000);
+	phy_write(phydev, 0x1f, 0x0000);	/* switch to page 0 */
+	phy_clear_bits_mmd(phydev, 0x7, 0x3c, BIT(1));
+
+	/* FIXME: This is probably H6 specific */
+	phy_set_bits(phydev, 0x13, BIT(12));
+
+	return 0;
+}
+
+static int ac200_ephy_probe(struct phy_device *phydev)
+{
+	struct device *dev = &phydev->mdio.dev;
+	struct clk *clk;
+
+	clk = devm_clk_get_optional_enabled(dev, NULL);
+	if (IS_ERR(clk))
+		return dev_err_probe(dev, PTR_ERR(clk),
+				     "Failed to request clock\n");
+
+	return 0;
+}
+
+static struct phy_driver ac200_ephy_driver[] = {
+	{
+		.phy_id		= AC200_EPHY_ID,
+		.phy_id_mask	= AC200_EPHY_ID_MASK,
+		.name		= "Allwinner AC200 EPHY",
+		.soft_reset	= genphy_soft_reset,
+		.config_init	= ac200_ephy_config_init,
+		.probe		= ac200_ephy_probe,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+	}
+};
+module_phy_driver(ac200_ephy_driver);
+
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_DESCRIPTION("AC200 Ethernet PHY driver");
+MODULE_LICENSE("GPL");
+
+static const struct mdio_device_id __maybe_unused ac200_ephy_phy_tbl[] = {
+	{ AC200_EPHY_ID, AC200_EPHY_ID_MASK },
+	{ }
+};
+MODULE_DEVICE_TABLE(mdio, ac200_ephy_phy_tbl);
diff --git a/drivers/phy/allwinner/Kconfig b/drivers/phy/allwinner/Kconfig
index fb584518b2d0fd..2e8ceca4a6a9d8 100644
--- a/drivers/phy/allwinner/Kconfig
+++ b/drivers/phy/allwinner/Kconfig
@@ -57,3 +57,12 @@ config PHY_SUN50I_USB3
 	  part of Allwinner H6 SoC.
 
 	  This driver controls each individual USB 2+3 host PHY combo.
+
+config AC200_PHY_CTL
+	tristate "X-Power AC200 PHY control driver"
+	depends on MFD_AC200
+	depends on RESET_CONTROLLER
+	help
+	  Enable this to support the Ethernet PHY operation of the AC200
+	  mixed signal chip. This driver just enables and configures the
+	  PHY, the PHY itself is supported by a standard driver.
diff --git a/drivers/phy/allwinner/Makefile b/drivers/phy/allwinner/Makefile
index bd74901a12551e..0eecec7a908a44 100644
--- a/drivers/phy/allwinner/Makefile
+++ b/drivers/phy/allwinner/Makefile
@@ -3,3 +3,4 @@ obj-$(CONFIG_PHY_SUN4I_USB)		+= phy-sun4i-usb.o
 obj-$(CONFIG_PHY_SUN6I_MIPI_DPHY)	+= phy-sun6i-mipi-dphy.o
 obj-$(CONFIG_PHY_SUN9I_USB)		+= phy-sun9i-usb.o
 obj-$(CONFIG_PHY_SUN50I_USB3)		+= phy-sun50i-usb3.o
+obj-$(CONFIG_AC200_PHY_CTL)		+= ac200-ephy-ctl.o
diff --git a/drivers/phy/allwinner/ac200-ephy-ctl.c b/drivers/phy/allwinner/ac200-ephy-ctl.c
new file mode 100644
index 00000000000000..8efeaf18e42c17
--- /dev/null
+++ b/drivers/phy/allwinner/ac200-ephy-ctl.c
@@ -0,0 +1,302 @@
+// SPDX-License-Identifier: GPL-2.0+
+/**
+ * syscon driver to control and configure AC200 Ethernet PHY
+ * Copyright (c) 2022 Arm Ltd.
+ *
+ * TODO's and questions:
+ * =========================
+ * - This driver is something like a syscon driver, as it controls various
+ *   bits and registers that effect other devices (the actual PHY). It's
+ *   unclear where it should live, though:
+ *   - it could be integrated into the MFD driver, but this looks messy
+ *   - it could live at the current location (drivers/phy/allwinner), but that
+ *     sounds wrong
+ *   - it could be a separate file, but in drivers/mfd
+ *   - anything else
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset-controller.h>
+
+/* macros for system ephy control 0 register */
+#define AC200_SYS_EPHY_CTL0		0x0014
+#define AC200_EPHY_RESET_INVALID	BIT(0)
+#define AC200_EPHY_SYSCLK_GATING	1
+
+/* macros for system ephy control 1 register */
+#define AC200_SYS_EPHY_CTL1		0x0016
+#define AC200_EPHY_E_EPHY_MII_IO_EN	BIT(0)
+#define AC200_EPHY_E_LNK_LED_IO_EN	BIT(1)
+#define AC200_EPHY_E_SPD_LED_IO_EN	BIT(2)
+#define AC200_EPHY_E_DPX_LED_IO_EN	BIT(3)
+
+/* macros for ephy control register */
+#define AC200_EPHY_CTL			0x6000
+#define AC200_EPHY_SHUTDOWN		BIT(0)
+#define AC200_EPHY_LED_POL		BIT(1)
+#define AC200_EPHY_CLK_SEL		BIT(2)
+#define AC200_EPHY_ADDR(x)		(((x) & 0x1F) << 4)
+#define AC200_EPHY_XMII_SEL		BIT(11)
+#define AC200_EPHY_CALIB(x)		(((x) & 0xF) << 12)
+
+struct ac200_ephy_ctl_dev {
+	struct reset_controller_dev	rcdev;
+	struct clk_hw			*gate_clk;
+	struct regmap			*regmap;
+};
+
+static struct ac200_ephy_ctl_dev *to_phy_dev(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct ac200_ephy_ctl_dev, rcdev);
+}
+
+static int ephy_ctl_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+	int ret;
+
+	ret = regmap_clear_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+				AC200_EPHY_RESET_INVALID);
+	if (ret)
+		return ret;
+
+	/* This is going via I2C, so there is plenty of built-in delay. */
+	return regmap_set_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+			       AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_assert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+
+	return regmap_clear_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+				 AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_deassert(struct reset_controller_dev *rcdev,
+			     unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+
+	return regmap_set_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+			       AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_status(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+
+	return regmap_test_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+				AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_reset_of_xlate(struct reset_controller_dev *rcdev,
+				   const struct of_phandle_args *reset_spec)
+{
+	if (WARN_ON(reset_spec->args_count != 0))
+		return -EINVAL;
+
+	return 0;
+}
+
+const struct reset_control_ops ephy_ctl_reset_ops = {
+	.assert		= ephy_ctl_assert,
+	.deassert	= ephy_ctl_deassert,
+	.reset		= ephy_ctl_reset,
+	.status		= ephy_ctl_status,
+};
+
+static void ac200_ephy_ctl_disable(struct ac200_ephy_ctl_dev *priv)
+{
+	regmap_write(priv->regmap, AC200_EPHY_CTL, AC200_EPHY_SHUTDOWN);
+	regmap_write(priv->regmap, AC200_SYS_EPHY_CTL1, 0);
+	regmap_write(priv->regmap, AC200_SYS_EPHY_CTL0, 0);
+}
+
+static int ac200_ephy_ctl_probe(struct platform_device *pdev)
+{
+	struct reset_controller_dev *rcdev;
+	struct device *dev = &pdev->dev;
+	struct ac200_ephy_ctl_dev *priv;
+	struct nvmem_cell *calcell;
+	const char *parent_name;
+	phy_interface_t phy_if;
+	u16 *caldata, ephy_ctl;
+	struct clk *clk;
+	size_t callen;
+	u32 value;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->regmap = dev_get_regmap(dev->parent, NULL);
+	if (!priv->regmap)
+		return -EPROBE_DEFER;
+
+	calcell = devm_nvmem_cell_get(dev, "calibration");
+	if (IS_ERR(calcell))
+		return dev_err_probe(dev, PTR_ERR(calcell),
+				     "Unable to find calibration data!\n");
+
+	caldata = nvmem_cell_read(calcell, &callen);
+	if (IS_ERR(caldata)) {
+		dev_err(dev, "Unable to read calibration data!\n");
+		return PTR_ERR(caldata);
+	}
+
+	if (callen != 2) {
+		dev_err(dev, "Calibration data length must be 2 bytes!\n");
+		kfree(caldata);
+		return -EINVAL;
+	}
+
+	ephy_ctl = AC200_EPHY_CALIB(*caldata + 3);
+	kfree(caldata);
+
+	ret = of_get_phy_mode(dev->of_node, &phy_if);
+	if (ret) {
+		dev_err(dev, "Unable to read PHY connection mode\n");
+		return ret;
+	}
+
+	switch (phy_if) {
+	case PHY_INTERFACE_MODE_MII:
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		ephy_ctl |= AC200_EPHY_XMII_SEL;
+		break;
+	default:
+		dev_err(dev, "Illegal PHY connection mode (%d), only RMII or MII supported\n",
+			phy_if);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "x-powers,led-polarity",
+				   &value);
+	if (ret) {
+		dev_err(dev, "Unable to read LED polarity setting\n");
+		return ret;
+	}
+
+	if (value == GPIO_ACTIVE_LOW)
+		ephy_ctl |= AC200_EPHY_LED_POL;
+
+	ret = of_property_read_u32(dev->of_node, "phy-address", &value);
+	if (ret) {
+		dev_err(dev, "Unable to read PHY address value\n");
+		return ret;
+	}
+
+	ephy_ctl |= AC200_EPHY_ADDR(value);
+
+	clk = clk_get(dev->parent, NULL);
+	if (IS_ERR(clk))
+		return dev_err_probe(dev, PTR_ERR(clk),
+				     "Unable to obtain the clock\n");
+
+	if (clk_get_rate(clk) == 24000000)
+		ephy_ctl |= AC200_EPHY_CLK_SEL;
+
+	clk_put(clk);
+
+	/* Assert reset and gate clock, to disable PHY for now */
+	ret = regmap_write(priv->regmap, AC200_SYS_EPHY_CTL0, 0);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->regmap, AC200_SYS_EPHY_CTL1,
+			   AC200_EPHY_E_EPHY_MII_IO_EN |
+			   AC200_EPHY_E_LNK_LED_IO_EN |
+			   AC200_EPHY_E_SPD_LED_IO_EN |
+			   AC200_EPHY_E_DPX_LED_IO_EN);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->regmap, AC200_EPHY_CTL, ephy_ctl);
+	if (ret)
+		return ret;
+
+	rcdev = &priv->rcdev;
+	rcdev->owner = dev->driver->owner;
+	rcdev->nr_resets = 1;
+	rcdev->ops = &ephy_ctl_reset_ops;
+	rcdev->of_node = dev->of_node;
+	rcdev->of_reset_n_cells = 0;
+	rcdev->of_xlate = ephy_ctl_reset_of_xlate;
+
+	ret = devm_reset_controller_register(dev, rcdev);
+	if (ret) {
+		dev_err(dev, "Unable to register reset controller: %d\n", ret);
+		goto err_disable_ephy;
+	}
+
+	parent_name = of_clk_get_parent_name(dev->parent->of_node, 0);
+	priv->gate_clk = devm_clk_hw_register_regmap_gate(dev,
+				"ac200-ephy-ctl-gate", parent_name, 0,
+				priv->regmap, AC200_SYS_EPHY_CTL0,
+				AC200_EPHY_SYSCLK_GATING, 0);
+	if (IS_ERR(priv->gate_clk)) {
+		ret = PTR_ERR(priv->gate_clk);
+		dev_err(dev, "Unable to register gate clock: %d\n", ret);
+		goto err_disable_ephy;
+	}
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,
+					  priv->gate_clk);
+	if (ret) {
+		dev_err(dev, "Unable to register clock provider: %d\n", ret);
+		goto err_disable_ephy;
+	}
+
+	return 0;
+
+err_disable_ephy:
+	ac200_ephy_ctl_disable(priv);
+
+	return ret;
+}
+
+static int ac200_ephy_ctl_remove(struct platform_device *pdev)
+{
+	struct ac200_ephy_ctl_dev *priv = platform_get_drvdata(pdev);
+
+	ac200_ephy_ctl_disable(priv);
+
+	return 0;
+}
+
+static const struct of_device_id ac200_ephy_ctl_match[] = {
+	{ .compatible = "x-powers,ac200-ephy-ctl" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ac200_ephy_ctl_match);
+
+static struct platform_driver ac200_ephy_ctl_driver = {
+	.probe		= ac200_ephy_ctl_probe,
+	.remove		= ac200_ephy_ctl_remove,
+	.driver		= {
+		.name		= "ac200-ephy-ctl",
+		.of_match_table	= ac200_ephy_ctl_match,
+	},
+};
+module_platform_driver(ac200_ephy_ctl_driver);
+
+MODULE_AUTHOR("Andre Przywara <andre.przywara@arm.com>");
+MODULE_DESCRIPTION("AC200 Ethernet PHY control driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 267cd06b54a019..5de2c071fcf8de 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -8,6 +8,7 @@
 
 #include <linux/of.h>
 #include <linux/of_clk.h>
+#include <linux/regmap.h>
 
 /*
  * flags used across common struct clk.  these flags should only affect the
@@ -510,6 +511,8 @@ void of_fixed_clk_setup(struct device_node *np);
 struct clk_gate {
 	struct clk_hw hw;
 	void __iomem	*reg;
+	struct regmap	*regmap;
+	unsigned int	regmap_offs;
 	u8		bit_idx;
 	u8		flags;
 	spinlock_t	*lock;
@@ -527,6 +530,7 @@ struct clk_hw *__clk_hw_register_gate(struct device *dev,
 		const char *parent_name, const struct clk_hw *parent_hw,
 		const struct clk_parent_data *parent_data,
 		unsigned long flags,
+		struct regmap *regmap, unsigned int regmap_offs,
 		void __iomem *reg, u8 bit_idx,
 		u8 clk_gate_flags, spinlock_t *lock);
 struct clk_hw *__devm_clk_hw_register_gate(struct device *dev,
@@ -534,12 +538,17 @@ struct clk_hw *__devm_clk_hw_register_gate(struct device *dev,
 		const char *parent_name, const struct clk_hw *parent_hw,
 		const struct clk_parent_data *parent_data,
 		unsigned long flags,
+		struct regmap *regmap, unsigned int regmap_offs,
 		void __iomem *reg, u8 bit_idx,
 		u8 clk_gate_flags, spinlock_t *lock);
 struct clk *clk_register_gate(struct device *dev, const char *name,
 		const char *parent_name, unsigned long flags,
 		void __iomem *reg, u8 bit_idx,
 		u8 clk_gate_flags, spinlock_t *lock);
+struct clk *clk_register_regmap_gate(struct device *dev, const char *name,
+		const char *parent_name, unsigned long flags,
+		struct regmap *regmap, unsigned int regmap_offs,
+		u8 bit_idx, u8 clk_gate_flags);
 /**
  * clk_hw_register_gate - register a gate clock with the clock framework
  * @dev: device that is registering this clock
@@ -554,8 +563,14 @@ struct clk *clk_register_gate(struct device *dev, const char *name,
 #define clk_hw_register_gate(dev, name, parent_name, flags, reg, bit_idx,     \
 			     clk_gate_flags, lock)			      \
 	__clk_hw_register_gate((dev), NULL, (name), (parent_name), NULL,      \
-			       NULL, (flags), (reg), (bit_idx),		      \
+			       NULL, (flags), NULL, 0, (reg), (bit_idx),      \
 			       (clk_gate_flags), (lock))
+
+#define clk_hw_register_regmap_gate(dev, name, parent_name, flags, regmap,    \
+				    regmap_offs, bit_idx, clk_gate_flags)     \
+	__clk_hw_register_gate((dev), NULL, (name), (parent_name), NULL,      \
+			       NULL, (flags), regmap, regmap_offs, NULL,      \
+			       (bit_idx), (clk_gate_flags), NULL)
 /**
  * clk_hw_register_gate_parent_hw - register a gate clock with the clock
  * framework
@@ -571,8 +586,15 @@ struct clk *clk_register_gate(struct device *dev, const char *name,
 #define clk_hw_register_gate_parent_hw(dev, name, parent_hw, flags, reg,      \
 				       bit_idx, clk_gate_flags, lock)	      \
 	__clk_hw_register_gate((dev), NULL, (name), NULL, (parent_hw),        \
-			       NULL, (flags), (reg), (bit_idx),		      \
+			       NULL, (flags), NULL, 0, (reg), (bit_idx),      \
 			       (clk_gate_flags), (lock))
+
+#define clk_hw_register_regmap_gate_parent_hw(dev, name, parent_hw, flags,    \
+					      regmap, regmap_offs, bit_idx,   \
+					      clk_gate_flags)		      \
+	__clk_hw_register_gate((dev), NULL, (name), NULL, (parent_hw),        \
+			       NULL, (flags), regmap, regmap_offs, NULL,      \
+			       (bit_idx), (clk_gate_flags), NULL)
 /**
  * clk_hw_register_gate_parent_data - register a gate clock with the clock
  * framework
@@ -588,7 +610,7 @@ struct clk *clk_register_gate(struct device *dev, const char *name,
 #define clk_hw_register_gate_parent_data(dev, name, parent_data, flags, reg,  \
 				       bit_idx, clk_gate_flags, lock)	      \
 	__clk_hw_register_gate((dev), NULL, (name), NULL, NULL, (parent_data), \
-			       (flags), (reg), (bit_idx),		      \
+			       (flags), NULL, 0, (reg), (bit_idx),	      \
 			       (clk_gate_flags), (lock))
 /**
  * devm_clk_hw_register_gate - register a gate clock with the clock framework
@@ -628,8 +628,9 @@
 #define devm_clk_hw_register_gate(dev, name, parent_name, flags, reg, bit_idx,\
 				  clk_gate_flags, lock)			      \
 	__devm_clk_hw_register_gate((dev), NULL, (name), (parent_name), NULL, \
-			       NULL, (flags), (reg), (bit_idx),		      \
+			       NULL, (flags), NULL, 0, (reg), (bit_idx),      \
 			       (clk_gate_flags), (lock))
+
 /**
  * devm_clk_hw_register_gate_parent_data - register a gate clock with the
  * clock framework
@@ -646,8 +647,15 @@
 					      reg, bit_idx, clk_gate_flags,   \
 					      lock)			      \
 	__devm_clk_hw_register_gate((dev), NULL, (name), NULL, NULL,	      \
-				    (parent_data), (flags), (reg), (bit_idx), \
-				    (clk_gate_flags), (lock))
+				    (parent_data), (flags), NULL, 0, (reg),   \
+				    (bit_idx), (clk_gate_flags), (lock))
+
+#define devm_clk_hw_register_regmap_gate(dev, name, parent_name, flags,      \
+					regmap, regmap_offs, bit_idx,        \
+					clk_gate_flags)			     \
+       __devm_clk_hw_register_gate((dev), NULL, (name), (parent_name), NULL, \
+				NULL, (flags), (regmap), (regmap_offs), NULL,\
+				(bit_idx), (clk_gate_flags), NULL)
 
 void clk_unregister_gate(struct clk *clk);
 void clk_hw_unregister_gate(struct clk_hw *hw);
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 7022e6286e6cb8..49b90c83b4850c 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -17,6 +17,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_88PM860X
 	imply SND_SOC_L3
 	imply SND_SOC_AB8500_CODEC
+	imply SND_SOC_AC200_CODEC
 	imply SND_SOC_AC97_CODEC
 	imply SND_SOC_AD1836
 	imply SND_SOC_AD193X_SPI
@@ -369,6 +370,15 @@ config SND_SOC_AB8500_CODEC
 	tristate
 	depends on ABX500_CORE
 
+config SND_SOC_AC200_CODEC
+	tristate "AC200 Codec"
+	depends on MFD_AC200
+	help
+	  Enable support for X-Powers AC200 analog audio codec.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-soc-ac200.
+
 config SND_SOC_AC97_CODEC
 	tristate "Build generic ASoC AC97 CODEC driver"
 	select SND_AC97_CODEC
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 9170ee1447dda2..e6d44c2d2fd6ba 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 snd-soc-88pm860x-objs := 88pm860x-codec.o
 snd-soc-ab8500-codec-objs := ab8500-codec.o
+snd-soc-ac200-objs := ac200.o
 snd-soc-ac97-objs := ac97.o
 snd-soc-ad1836-objs := ad1836.o
 snd-soc-ad193x-objs := ad193x.o
@@ -359,6 +360,7 @@ snd-soc-simple-mux-objs := simple-mux.o
 
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
+obj-$(CONFIG_SND_SOC_AC200_CODEC)	+= snd-soc-ac200.o
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_AD1836)	+= snd-soc-ad1836.o
 obj-$(CONFIG_SND_SOC_AD193X)	+= snd-soc-ad193x.o
diff --git a/sound/soc/codecs/ac200.c b/sound/soc/codecs/ac200.c
new file mode 100644
index 00000000000000..113a45408116b7
--- /dev/null
+++ b/sound/soc/codecs/ac200.c
@@ -0,0 +1,774 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * X-Powers AC200 Codec Driver
+ *
+ * Copyright (C) 2022 Jernej Skrabec <jernej.skrabec@gmail.com>
+ */
+
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#define AC200_CODEC_RATES (SNDRV_PCM_RATE_8000 | \
+			   SNDRV_PCM_RATE_11025 | \
+			   SNDRV_PCM_RATE_16000 | \
+			   SNDRV_PCM_RATE_22050 | \
+			   SNDRV_PCM_RATE_32000 | \
+			   SNDRV_PCM_RATE_44100 | \
+			   SNDRV_PCM_RATE_48000 | \
+			   SNDRV_PCM_RATE_96000 | \
+			   SNDRV_PCM_RATE_192000 | \
+			   SNDRV_PCM_RATE_KNOT)
+
+#define AC200_CODEC_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+			     SNDRV_PCM_FMTBIT_S16_LE | \
+			     SNDRV_PCM_FMTBIT_S20_LE | \
+			     SNDRV_PCM_FMTBIT_S24_LE | \
+			     SNDRV_PCM_FMTBIT_S32_LE)
+
+#define AC200_SYS_AUDIO_CTL0			0x0010
+#define AC200_SYS_AUDIO_CTL0_MCLK_GATING	BIT(1)
+#define AC200_SYS_AUDIO_CTL0_RST_INVALID	BIT(0)
+#define AC200_SYS_AUDIO_CTL1			0x0012
+#define AC200_SYS_AUDIO_CTL1_I2S_IO_EN		BIT(0)
+
+#define AC200_SYS_CLK_CTL			0x2000
+#define AC200_SYS_CLK_CTL_I2S			15
+#define AC200_SYS_CLK_CTL_ADC			3
+#define AC200_SYS_CLK_CTL_DAC			2
+#define AC200_SYS_MOD_RST			0x2002
+#define AC200_SYS_MOD_RST_I2S			15
+#define AC200_SYS_MOD_RST_ADC			3
+#define AC200_SYS_MOD_RST_DAC			2
+#define AC200_SYS_SR_CTL			0x2004
+#define AC200_SYS_SR_CTL_SR_MASK		GENMASK(3, 0)
+#define AC200_SYS_SR_CTL_SR(x)			(x)
+#define AC200_I2S_CTL				0x2100
+#define AC200_I2S_CTL_SDO_EN			3
+#define AC200_I2S_CTL_TX_EN			2
+#define AC200_I2S_CTL_RX_EN			1
+#define AC200_I2S_CTL_GEN			0
+#define AC200_I2S_CLK				0x2102
+#define AC200_I2S_CLK_BCLK_OUT			BIT(15)
+#define AC200_I2S_CLK_LRCK_OUT			BIT(14)
+#define AC200_I2S_CLK_BCLKDIV_MASK		GENMASK(13, 10)
+#define AC200_I2S_CLK_BCLKDIV(x)		((x) << 10)
+#define AC200_I2S_CLK_LRCK_MASK			GENMASK(9, 0)
+#define AC200_I2S_CLK_LRCK(x)			((x) - 1)
+#define AC200_I2S_FMT0				0x2104
+#define AC200_I2S_FMT0_MODE_MASK		GENMASK(15, 14)
+#define AC200_I2S_FMT0_MODE(x)			((x) << 14)
+#define AC200_I2S_FMT0_MODE_PCM			0
+#define AC200_I2S_FMT0_MODE_LEFT		1
+#define AC200_I2S_FMT0_MODE_RIGHT		2
+#define AC200_I2S_FMT0_TX_OFFSET_MASK		GENMASK(11, 10)
+#define AC200_I2S_FMT0_TX_OFFSET(x)		((x) << 10)
+#define AC200_I2S_FMT0_RX_OFFSET_MASK		GENMASK(9, 8)
+#define AC200_I2S_FMT0_RX_OFFSET(x)		((x) << 8)
+#define AC200_I2S_FMT0_SR_MASK			GENMASK(6, 4)
+#define AC200_I2S_FMT0_SR(x)			((x) << 4)
+#define AC200_I2S_FMT0_SW_MASK			GENMASK(3, 1)
+#define AC200_I2S_FMT0_SW(x)			((x) << 1)
+#define AC200_I2S_FMT1				0x2108
+#define AC200_I2S_FMT1_BCLK_POL_INVERT		BIT(15)
+#define AC200_I2S_FMT1_LRCK_POL_INVERT		BIT(14)
+#define AC200_I2S_MIX_SRC			0x2114
+#define AC200_I2S_MIX_SRC_LMIX_DAC		13
+#define AC200_I2S_MIX_SRC_LMIX_ADC		12
+#define AC200_I2S_MIX_SRC_RMIX_DAC		9
+#define AC200_I2S_MIX_SRC_RMIX_ADC		8
+#define AC200_I2S_MIX_GAIN			0x2116
+#define AC200_I2S_MIX_GAIN_LMIX_DAC		13
+#define AC200_I2S_MIX_GAIN_LMIX_ADC		12
+#define AC200_I2S_MIX_GAIN_RMIX_DAC		9
+#define AC200_I2S_MIX_GAIN_RMIX_ADC		8
+#define AC200_I2S_DAC_VOL			0x2118
+#define AC200_I2S_DAC_VOL_LEFT			8
+#define AC200_I2S_DAC_VOL_RIGHT			0
+#define AC200_I2S_ADC_VOL			0x211A
+#define AC200_I2S_ADC_VOL_LEFT			8
+#define AC200_I2S_ADC_VOL_RIGHT			0
+#define AC200_DAC_CTL				0x2200
+#define AC200_DAC_CTL_DAC_EN			15
+#define AC200_DAC_MIX_SRC			0x2202
+#define AC200_DAC_MIX_SRC_LMIX_DAC		13
+#define AC200_DAC_MIX_SRC_LMIX_ADC		12
+#define AC200_DAC_MIX_SRC_RMIX_DAC		9
+#define AC200_DAC_MIX_SRC_RMIX_ADC		8
+#define AC200_DAC_MIX_GAIN			0x2204
+#define AC200_DAC_MIX_GAIN_LMIX_DAC		13
+#define AC200_DAC_MIX_GAIN_LMIX_ADC		12
+#define AC200_DAC_MIX_GAIN_RMIX_DAC		9
+#define AC200_DAC_MIX_GAIN_RMIX_ADC		8
+#define AC200_OUT_MIX_CTL			0x2220
+#define AC200_OUT_MIX_CTL_RDAC_EN		15
+#define AC200_OUT_MIX_CTL_LDAC_EN		14
+#define AC200_OUT_MIX_CTL_RMIX_EN		13
+#define AC200_OUT_MIX_CTL_LMIX_EN		12
+#define AC200_OUT_MIX_CTL_MIC1_VOL		4
+#define AC200_OUT_MIX_CTL_MIC2_VOL		0
+#define AC200_OUT_MIX_SRC			0x2222
+#define AC200_OUT_MIX_SRC_RMIX_MIC1		14
+#define AC200_OUT_MIX_SRC_RMIX_MIC2		13
+#define AC200_OUT_MIX_SRC_RMIX_RDAC		9
+#define AC200_OUT_MIX_SRC_RMIX_LDAC		8
+#define AC200_OUT_MIX_SRC_LMIX_MIC1		6
+#define AC200_OUT_MIX_SRC_LMIX_MIC2		5
+#define AC200_OUT_MIX_SRC_LMIX_LDAC		1
+#define AC200_OUT_MIX_SRC_LMIX_RDAC		0
+#define AC200_LINEOUT_CTL			0x2224
+#define AC200_LINEOUT_CTL_EN			15
+#define AC200_LINEOUT_CTL_LEN			14
+#define AC200_LINEOUT_CTL_REN			13
+#define AC200_LINEOUT_CTL_LMONO			12
+#define AC200_LINEOUT_CTL_RMONO			11
+#define AC200_LINEOUT_CTL_VOL			0
+#define AC200_ADC_CTL				0x2300
+#define AC200_ADC_CTL_ADC_EN			15
+#define AC200_MBIAS_CTL				0x2310
+#define AC200_MBIAS_CTL_MBIAS_EN		15
+#define AC200_MBIAS_CTL_ADDA_BIAS_EN		3
+#define AC200_ADC_MIC_CTL			0x2320
+#define AC200_ADC_MIC_CTL_RADC_EN		15
+#define AC200_ADC_MIC_CTL_LADC_EN		14
+#define AC200_ADC_MIC_CTL_ADC_VOL		8
+#define AC200_ADC_MIC_CTL_MIC1_GAIN_EN		7
+#define AC200_ADC_MIC_CTL_MIC1_BOOST		4
+#define AC200_ADC_MIC_CTL_MIC2_GAIN_EN		3
+#define AC200_ADC_MIC_CTL_MIC2_BOOST		0
+#define AC200_ADC_MIX_SRC			0x2322
+#define AC200_ADC_MIX_SRC_RMIX_MIC1		14
+#define AC200_ADC_MIX_SRC_RMIX_MIC2		13
+#define AC200_ADC_MIX_SRC_RMIX_RMIX		9
+#define AC200_ADC_MIX_SRC_RMIX_LMIX		8
+#define AC200_ADC_MIX_SRC_LMIX_MIC1		6
+#define AC200_ADC_MIX_SRC_LMIX_MIC2		5
+#define AC200_ADC_MIX_SRC_LMIX_LMIX		1
+#define AC200_ADC_MIX_SRC_LMIX_RMIX		0
+
+struct ac200_codec {
+	struct regmap *regmap;
+	unsigned int format;
+};
+
+struct ac200_map {
+	int match;
+	int value;
+};
+
+static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(mixer_scale, -600, 600, 0);
+static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(gain_scale, -450, 150, 0);
+static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(lineout_scale, -4650, 150, 1);
+static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(codec_scale, -12000, 75, 1);
+static const unsigned int mic_scale[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 7, TLV_DB_SCALE_ITEM(2400, 300, 0),
+};
+
+static const struct snd_kcontrol_new ac200_codec_controls[] = {
+	SOC_SINGLE_TLV("Master Playback Volume", AC200_LINEOUT_CTL,
+		       AC200_LINEOUT_CTL_VOL, 0x1f, 0, lineout_scale),
+	SOC_DOUBLE_TLV("I2S Master Playback Volume", AC200_I2S_DAC_VOL,
+		       AC200_I2S_DAC_VOL_LEFT, AC200_I2S_DAC_VOL_RIGHT,
+		       0xff, 0, codec_scale),
+	SOC_DOUBLE_TLV("I2S Master Capture Volume", AC200_I2S_ADC_VOL,
+		       AC200_I2S_ADC_VOL_LEFT, AC200_I2S_ADC_VOL_RIGHT,
+		       0xff, 0, codec_scale),
+	SOC_DOUBLE_TLV("I2S Capture Volume", AC200_I2S_MIX_GAIN,
+		       AC200_I2S_MIX_GAIN_LMIX_ADC, AC200_I2S_MIX_GAIN_RMIX_ADC,
+		       0x1, 1, mixer_scale),
+	SOC_DOUBLE_TLV("I2S Capture Volume", AC200_I2S_MIX_GAIN,
+		       AC200_I2S_MIX_GAIN_LMIX_DAC, AC200_I2S_MIX_GAIN_RMIX_DAC,
+		       0x1, 1, mixer_scale),
+	SOC_DOUBLE_TLV("DAC Playback Volume", AC200_DAC_MIX_GAIN,
+		       AC200_DAC_MIX_GAIN_LMIX_DAC, AC200_DAC_MIX_GAIN_RMIX_DAC,
+		       0x1, 1, mixer_scale),
+	SOC_DOUBLE_TLV("ADC Playback Volume", AC200_DAC_MIX_GAIN,
+		       AC200_DAC_MIX_GAIN_LMIX_ADC, AC200_DAC_MIX_GAIN_RMIX_ADC,
+		       0x1, 1, mixer_scale),
+	SOC_SINGLE_TLV("MIC1 Playback Volume", AC200_OUT_MIX_CTL,
+		       AC200_OUT_MIX_CTL_MIC1_VOL, 0x7, 0, gain_scale),
+	SOC_SINGLE_TLV("MIC2 Playback Volume", AC200_OUT_MIX_CTL,
+		       AC200_OUT_MIX_CTL_MIC2_VOL, 0x7, 0, gain_scale),
+	SOC_SINGLE_TLV("ADC Volume", AC200_ADC_MIC_CTL,
+		       AC200_ADC_MIC_CTL_ADC_VOL, 0x07, 0, gain_scale),
+	SOC_SINGLE_TLV("MIC1 Boost Volume", AC200_ADC_MIC_CTL,
+		       AC200_ADC_MIC_CTL_MIC1_BOOST, 0x07, 0, mic_scale),
+	SOC_SINGLE_TLV("MIC2 Boost Volume", AC200_ADC_MIC_CTL,
+		       AC200_ADC_MIC_CTL_MIC2_BOOST, 0x07, 0, mic_scale),
+	SOC_DOUBLE("Line Out Playback Switch", AC200_LINEOUT_CTL,
+		   AC200_LINEOUT_CTL_LEN, AC200_LINEOUT_CTL_REN, 1, 0),
+};
+
+static const struct snd_kcontrol_new i2s_mixer[] = {
+	SOC_DAPM_DOUBLE("I2S DAC Capture Switch", AC200_I2S_MIX_SRC,
+			AC200_I2S_MIX_SRC_LMIX_DAC,
+			AC200_I2S_MIX_SRC_RMIX_DAC, 1, 0),
+	SOC_DAPM_DOUBLE("I2S ADC Capture Switch", AC200_I2S_MIX_SRC,
+			AC200_I2S_MIX_SRC_LMIX_ADC,
+			AC200_I2S_MIX_SRC_RMIX_ADC, 1, 0),
+};
+
+static const struct snd_kcontrol_new dac_mixer[] = {
+	SOC_DAPM_DOUBLE("I2S DAC Playback Switch", AC200_DAC_MIX_SRC,
+			AC200_DAC_MIX_SRC_LMIX_DAC,
+			AC200_DAC_MIX_SRC_RMIX_DAC, 1, 0),
+	SOC_DAPM_DOUBLE("I2S ADC Playback Switch", AC200_DAC_MIX_SRC,
+			AC200_DAC_MIX_SRC_LMIX_ADC,
+			AC200_DAC_MIX_SRC_RMIX_ADC, 1, 0),
+};
+
+static const struct snd_kcontrol_new output_mixer[] = {
+	SOC_DAPM_DOUBLE("MIC1 Playback Switch", AC200_OUT_MIX_SRC,
+			AC200_OUT_MIX_SRC_LMIX_MIC1,
+			AC200_OUT_MIX_SRC_RMIX_MIC1, 1, 0),
+	SOC_DAPM_DOUBLE("MIC2 Playback Switch", AC200_OUT_MIX_SRC,
+			AC200_OUT_MIX_SRC_LMIX_MIC2,
+			AC200_OUT_MIX_SRC_RMIX_MIC2, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Playback Switch", AC200_OUT_MIX_SRC,
+			AC200_OUT_MIX_SRC_LMIX_LDAC,
+			AC200_OUT_MIX_SRC_RMIX_RDAC, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Reversed Playback Switch", AC200_OUT_MIX_SRC,
+			AC200_OUT_MIX_SRC_LMIX_RDAC,
+			AC200_OUT_MIX_SRC_RMIX_LDAC, 1, 0),
+};
+
+static const struct snd_kcontrol_new input_mixer[] = {
+	SOC_DAPM_DOUBLE("MIC1 Capture Switch", AC200_ADC_MIX_SRC,
+			AC200_ADC_MIX_SRC_LMIX_MIC1,
+			AC200_ADC_MIX_SRC_RMIX_MIC1, 1, 0),
+	SOC_DAPM_DOUBLE("MIC2 Capture Switch", AC200_ADC_MIX_SRC,
+			AC200_ADC_MIX_SRC_LMIX_MIC2,
+			AC200_ADC_MIX_SRC_RMIX_MIC2, 1, 0),
+	SOC_DAPM_DOUBLE("Output Mixer Capture Switch", AC200_ADC_MIX_SRC,
+			AC200_ADC_MIX_SRC_LMIX_LMIX,
+			AC200_ADC_MIX_SRC_RMIX_RMIX, 1, 0),
+	SOC_DAPM_DOUBLE("Output Mixer Reversed Capture Switch",
+			AC200_ADC_MIX_SRC,
+			AC200_ADC_MIX_SRC_LMIX_RMIX,
+			AC200_ADC_MIX_SRC_RMIX_LMIX, 1, 0),
+};
+
+const char * const lineout_mux_enum_text[] = {
+	"Stereo", "Mono",
+};
+
+static SOC_ENUM_DOUBLE_DECL(lineout_mux_enum, AC200_LINEOUT_CTL,
+			    AC200_LINEOUT_CTL_LMONO, AC200_LINEOUT_CTL_RMONO,
+			    lineout_mux_enum_text);
+
+static const struct snd_kcontrol_new lineout_mux =
+	SOC_DAPM_ENUM("Line Out Source Playback Route", lineout_mux_enum);
+
+static const struct snd_soc_dapm_widget ac200_codec_dapm_widgets[] = {
+	/* Regulator */
+	SND_SOC_DAPM_REGULATOR_SUPPLY("avcc", 0, 0),
+
+	/* System clocks */
+	SND_SOC_DAPM_SUPPLY("CLK SYS I2S", AC200_SYS_CLK_CTL,
+			    AC200_SYS_CLK_CTL_I2S, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("CLK SYS DAC", AC200_SYS_CLK_CTL,
+			    AC200_SYS_CLK_CTL_DAC, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("CLK SYS ADC", AC200_SYS_CLK_CTL,
+			    AC200_SYS_CLK_CTL_ADC, 0, NULL, 0),
+
+	/* Module resets */
+	SND_SOC_DAPM_SUPPLY("RST SYS I2S", AC200_SYS_MOD_RST,
+			    AC200_SYS_MOD_RST_I2S, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("RST SYS DAC", AC200_SYS_MOD_RST,
+			    AC200_SYS_MOD_RST_DAC, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("RST SYS ADC", AC200_SYS_MOD_RST,
+			    AC200_SYS_MOD_RST_DAC, 0, NULL, 0),
+
+	/* I2S gates */
+	SND_SOC_DAPM_SUPPLY("CLK I2S GEN", AC200_I2S_CTL,
+			    AC200_I2S_CTL_GEN, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("CLK I2S SDO", AC200_I2S_CTL,
+			    AC200_I2S_CTL_SDO_EN, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("CLK I2S TX", AC200_I2S_CTL,
+			    AC200_I2S_CTL_TX_EN, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("CLK I2S RX", AC200_I2S_CTL,
+			    AC200_I2S_CTL_RX_EN, 0, NULL, 0),
+
+	/* Module supplies */
+	SND_SOC_DAPM_SUPPLY("ADC Enable", AC200_ADC_CTL,
+			    AC200_ADC_CTL_ADC_EN, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DAC Enable", AC200_DAC_CTL,
+			    AC200_DAC_CTL_DAC_EN, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("Line Out Enable", AC200_LINEOUT_CTL,
+			    AC200_LINEOUT_CTL_EN, 0, NULL, 0),
+
+	/* Bias */
+	SND_SOC_DAPM_SUPPLY("MIC Bias", AC200_MBIAS_CTL,
+			    AC200_MBIAS_CTL_MBIAS_EN, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADDA Bias", AC200_MBIAS_CTL,
+			    AC200_MBIAS_CTL_ADDA_BIAS_EN, 0, NULL, 0),
+
+	/* DAC */
+	SND_SOC_DAPM_DAC("Left DAC", "Playback", AC200_OUT_MIX_CTL,
+			 AC200_OUT_MIX_CTL_LDAC_EN, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Playback", AC200_OUT_MIX_CTL,
+			 AC200_OUT_MIX_CTL_RDAC_EN, 0),
+
+	/* ADC */
+	SND_SOC_DAPM_ADC("Left ADC", "Capture", AC200_ADC_MIC_CTL,
+			 AC200_ADC_MIC_CTL_LADC_EN, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Capture", AC200_ADC_MIC_CTL,
+			 AC200_ADC_MIC_CTL_RADC_EN, 0),
+
+	/* Mixers */
+	SND_SOC_DAPM_MIXER("Left Output Mixer", AC200_OUT_MIX_CTL,
+			   AC200_OUT_MIX_CTL_LMIX_EN, 0,
+			   output_mixer, ARRAY_SIZE(output_mixer)),
+	SND_SOC_DAPM_MIXER("Right Output Mixer", AC200_OUT_MIX_CTL,
+			   AC200_OUT_MIX_CTL_RMIX_EN, 0,
+			   output_mixer, ARRAY_SIZE(output_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left Input Mixer", SND_SOC_NOPM, 0, 0,
+			   input_mixer, ARRAY_SIZE(input_mixer)),
+	SND_SOC_DAPM_MIXER("Right Input Mixer", SND_SOC_NOPM, 0, 0,
+			   input_mixer, ARRAY_SIZE(input_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left DAC Mixer", SND_SOC_NOPM, 0, 0,
+			   dac_mixer, ARRAY_SIZE(dac_mixer)),
+	SND_SOC_DAPM_MIXER("Right DAC Mixer", SND_SOC_NOPM, 0, 0,
+			   dac_mixer, ARRAY_SIZE(dac_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left I2S Mixer", SND_SOC_NOPM, 0, 0,
+			   i2s_mixer, ARRAY_SIZE(i2s_mixer)),
+	SND_SOC_DAPM_MIXER("Right I2S Mixer", SND_SOC_NOPM, 0, 0,
+			   i2s_mixer, ARRAY_SIZE(i2s_mixer)),
+
+	/* Muxes */
+	SND_SOC_DAPM_MUX("Line Out Source Playback Route",
+			 SND_SOC_NOPM, 0, 0, &lineout_mux),
+
+	/* Gain/attenuation */
+	SND_SOC_DAPM_PGA("MIC1 Amplifier", AC200_ADC_MIC_CTL,
+			 AC200_ADC_MIC_CTL_MIC1_GAIN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC2 Amplifier", AC200_ADC_MIC_CTL,
+			 AC200_ADC_MIC_CTL_MIC2_GAIN_EN, 0, NULL, 0),
+
+	/* Inputs */
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),
+
+	/* Outputs */
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+};
+
+static const struct snd_soc_dapm_route ac200_codec_dapm_routes[] = {
+	{ "RST SYS I2S", NULL, "CLK SYS I2S" },
+	{ "RST SYS ADC", NULL, "CLK SYS ADC" },
+	{ "RST SYS DAC", NULL, "CLK SYS DAC" },
+
+	{ "CLK I2S GEN", NULL, "RST SYS I2S" },
+	{ "CLK I2S SDO", NULL, "CLK I2S GEN" },
+	{ "CLK I2S TX", NULL, "CLK I2S SDO" },
+	{ "CLK I2S RX", NULL, "CLK I2S SDO" },
+
+	{ "ADC Enable", NULL, "RST SYS ADC" },
+	{ "ADC Enable", NULL, "ADDA Bias" },
+	{ "ADC Enable", NULL, "avcc" },
+	{ "DAC Enable", NULL, "RST SYS DAC" },
+	{ "DAC Enable", NULL, "ADDA Bias" },
+	{ "DAC Enable", NULL, "avcc" },
+
+	{ "Left DAC", NULL,  "DAC Enable" },
+	{ "Left DAC", NULL,  "CLK I2S RX" },
+	{ "Right DAC", NULL,  "DAC Enable" },
+	{ "Right DAC", NULL,  "CLK I2S RX" },
+
+	{ "Left ADC", NULL,  "ADC Enable" },
+	{ "Left ADC", NULL,  "CLK I2S TX" },
+	{ "Right ADC", NULL,  "ADC Enable" },
+	{ "Right ADC", NULL,  "CLK I2S TX" },
+
+	{ "Left Output Mixer", "MIC1 Playback Switch", "MIC1 Amplifier" },
+	{ "Left Output Mixer", "MIC2 Playback Switch", "MIC2 Amplifier" },
+	{ "Left Output Mixer", "DAC Playback Switch", "Left DAC Mixer" },
+	{ "Left Output Mixer", "DAC Reversed Playback Switch", "Right DAC Mixer" },
+
+	{ "Right Output Mixer", "MIC1 Playback Switch", "MIC1 Amplifier" },
+	{ "Right Output Mixer", "MIC2 Playback Switch", "MIC2 Amplifier" },
+	{ "Right Output Mixer", "DAC Playback Switch", "Right DAC Mixer" },
+	{ "Right Output Mixer", "DAC Reversed Playback Switch", "Left DAC Mixer" },
+
+	{ "Left Input Mixer", "MIC1 Capture Switch", "MIC1 Amplifier" },
+	{ "Left Input Mixer", "MIC2 Capture Switch", "MIC2 Amplifier" },
+	{ "Left Input Mixer", "Output Mixer Capture Switch", "Left Output Mixer" },
+	{ "Left Input Mixer", "Output Mixer Reversed Capture Switch", "Right Output Mixer" },
+
+	{ "Right Input Mixer", "MIC1 Capture Switch", "MIC1 Amplifier" },
+	{ "Right Input Mixer", "MIC2 Capture Switch", "MIC2 Amplifier" },
+	{ "Right Input Mixer", "Output Mixer Capture Switch", "Right Output Mixer" },
+	{ "Right Input Mixer", "Output Mixer Reversed Capture Switch", "Left Output Mixer" },
+
+	{ "Left I2S Mixer", "I2S DAC Capture Switch", "Left DAC" },
+	{ "Left I2S Mixer", "I2S ADC Capture Switch", "Left Input Mixer" },
+	{ "Right I2S Mixer", "I2S DAC Capture Switch", "Right DAC" },
+	{ "Right I2S Mixer", "I2S ADC Capture Switch", "Right Input Mixer" },
+
+	{ "Left DAC Mixer", "I2S DAC Playback Switch", "Left DAC" },
+	{ "Left DAC Mixer", "I2S ADC Playback Switch", "Left Input Mixer" },
+	{ "Right DAC Mixer", "I2S DAC Playback Switch", "Right DAC" },
+	{ "Right DAC Mixer", "I2S ADC Playback Switch", "Right Input Mixer" },
+
+	{ "Line Out Source Playback Route", "Stereo", "Left Output Mixer" },
+	{ "Line Out Source Playback Route", "Stereo", "Right Output Mixer" },
+	{ "Line Out Source Playback Route", "Mono", "Right Output Mixer" },
+	{ "Line Out Source Playback Route", "Mono", "Left Output Mixer" },
+
+	{ "Left ADC", NULL, "Left I2S Mixer" },
+	{ "Right ADC", NULL, "Right I2S Mixer" },
+
+	{ "LINEOUT", NULL, "Line Out Enable", },
+	{ "LINEOUT", NULL, "Line Out Source Playback Route" },
+
+	{ "MIC1", NULL, "MIC Bias" },
+	{ "MIC2", NULL, "MIC Bias" },
+	{ "MIC1 Amplifier", NULL, "MIC1" },
+	{ "MIC2 Amplifier", NULL, "MIC2" },
+};
+
+static int ac200_get_sr_sw(unsigned int width)
+{
+	switch (width) {
+	case 8:
+		return 1;
+	case 12:
+		return 2;
+	case 16:
+		return 3;
+	case 20:
+		return 4;
+	case 24:
+		return 5;
+	case 28:
+		return 6;
+	case 32:
+		return 7;
+	}
+
+	return -EINVAL;
+}
+
+static const struct ac200_map ac200_bclk_div_map[] = {
+	{ .match = 1,	.value = 1 },
+	{ .match = 2,	.value = 2 },
+	{ .match = 4,	.value = 3 },
+	{ .match = 6,	.value = 4 },
+	{ .match = 8,	.value = 5 },
+	{ .match = 12,	.value = 6 },
+	{ .match = 16,	.value = 7 },
+	{ .match = 24,	.value = 8 },
+	{ .match = 32,	.value = 9 },
+	{ .match = 48,	.value = 10 },
+	{ .match = 64,	.value = 11 },
+	{ .match = 96,	.value = 12 },
+	{ .match = 128,	.value = 13 },
+	{ .match = 176,	.value = 14 },
+	{ .match = 192,	.value = 15 },
+};
+
+static int ac200_get_bclk_div(unsigned int sample_rate, unsigned int period)
+{
+	unsigned int sysclk_rate = (sample_rate % 4000) ? 22579200 : 24576000;
+	unsigned int div = sysclk_rate / sample_rate / period;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ac200_bclk_div_map); i++) {
+		const struct ac200_map *bdiv = &ac200_bclk_div_map[i];
+
+		if (bdiv->match == div)
+			return bdiv->value;
+	}
+
+	return -EINVAL;
+}
+
+static const struct ac200_map ac200_ssr_map[] = {
+	{ .match = 8000,	.value = 0 },
+	{ .match = 11025,	.value = 1 },
+	{ .match = 12000,	.value = 2 },
+	{ .match = 16000,	.value = 3 },
+	{ .match = 22050,	.value = 4 },
+	{ .match = 24000,	.value = 5 },
+	{ .match = 32000,	.value = 6 },
+	{ .match = 44100,	.value = 7 },
+	{ .match = 48000,	.value = 8 },
+	{ .match = 96000,	.value = 9 },
+	{ .match = 192000,	.value = 10 },
+};
+
+static int ac200_get_ssr(unsigned int sample_rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ac200_ssr_map); i++) {
+		const struct ac200_map *ssr = &ac200_ssr_map[i];
+
+		if (ssr->match == sample_rate)
+			return ssr->value;
+	}
+
+	return -EINVAL;
+}
+
+static int ac200_codec_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct ac200_codec *priv = snd_soc_dai_get_drvdata(dai);
+	unsigned int slot_width = params_physical_width(params);
+	unsigned int sample_rate = params_rate(params);
+	int sr, period, sw, bclkdiv, ssr;
+
+	sr = ac200_get_sr_sw(params_width(params));
+	if (sr < 0)
+		return sr;
+
+	sw = ac200_get_sr_sw(slot_width);
+	if (sw < 0)
+		return sw;
+
+	regmap_update_bits(priv->regmap, AC200_I2S_FMT0,
+			   AC200_I2S_FMT0_SR_MASK |
+			   AC200_I2S_FMT0_SW_MASK,
+			   AC200_I2S_FMT0_SR(sr) |
+			   AC200_I2S_FMT0_SW(sw));
+
+	switch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		period = slot_width;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+	case SND_SOC_DAIFMT_DSP_B:
+		period = slot_width * 2;
+		break;
+	}
+
+	bclkdiv = ac200_get_bclk_div(sample_rate, period);
+	if (bclkdiv < 0)
+		return bclkdiv;
+
+	regmap_update_bits(priv->regmap, AC200_I2S_CLK,
+			   AC200_I2S_CLK_LRCK_MASK |
+			   AC200_I2S_CLK_BCLKDIV_MASK,
+			   AC200_I2S_CLK_LRCK(period) |
+			   AC200_I2S_CLK_BCLKDIV(bclkdiv));
+
+	ssr = ac200_get_ssr(sample_rate);
+	if (ssr < 0)
+		return ssr;
+
+	regmap_update_bits(priv->regmap, AC200_SYS_SR_CTL,
+			   AC200_SYS_SR_CTL_SR_MASK,
+			   AC200_SYS_SR_CTL_SR(ssr));
+
+	return 0;
+}
+
+static int ac200_codec_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct ac200_codec *priv = snd_soc_dai_get_drvdata(dai);
+	unsigned long offset, mode, value;
+
+	priv->format = fmt;
+
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
+	case SND_SOC_DAIFMT_CBP_CFP:
+		value = AC200_I2S_CLK_BCLK_OUT | AC200_I2S_CLK_LRCK_OUT;
+		break;
+	case SND_SOC_DAIFMT_CBC_CFP:
+		value = AC200_I2S_CLK_LRCK_OUT;
+		break;
+	case SND_SOC_DAIFMT_CBP_CFC:
+		value = AC200_I2S_CLK_BCLK_OUT;
+		break;
+	case SND_SOC_DAIFMT_CBC_CFC:
+		value = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(priv->regmap, AC200_I2S_CLK,
+			   AC200_I2S_CLK_BCLK_OUT |
+			   AC200_I2S_CLK_LRCK_OUT, value);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		mode = AC200_I2S_FMT0_MODE_LEFT;
+		offset = 1;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		mode = AC200_I2S_FMT0_MODE_RIGHT;
+		offset = 0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		mode = AC200_I2S_FMT0_MODE_LEFT;
+		offset = 0;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		mode = AC200_I2S_FMT0_MODE_PCM;
+		offset = 1;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		mode = AC200_I2S_FMT0_MODE_PCM;
+		offset = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(priv->regmap, AC200_I2S_FMT0,
+			   AC200_I2S_FMT0_MODE_MASK |
+			   AC200_I2S_FMT0_TX_OFFSET_MASK |
+			   AC200_I2S_FMT0_RX_OFFSET_MASK,
+			   AC200_I2S_FMT0_MODE(mode) |
+			   AC200_I2S_FMT0_TX_OFFSET(offset) |
+			   AC200_I2S_FMT0_RX_OFFSET(offset));
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		value = 0;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		value = AC200_I2S_FMT1_LRCK_POL_INVERT;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		value = AC200_I2S_FMT1_BCLK_POL_INVERT;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		value = AC200_I2S_FMT1_BCLK_POL_INVERT |
+			AC200_I2S_FMT1_LRCK_POL_INVERT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(priv->regmap, AC200_I2S_FMT1,
+			   AC200_I2S_FMT1_BCLK_POL_INVERT |
+			   AC200_I2S_FMT1_LRCK_POL_INVERT, value);
+
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops ac200_codec_dai_ops = {
+	.hw_params	= ac200_codec_hw_params,
+	.set_fmt	= ac200_codec_set_fmt,
+};
+
+static struct snd_soc_dai_driver ac200_codec_dai = {
+	.name = "ac200-dai",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = AC200_CODEC_RATES,
+		.formats = AC200_CODEC_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AC200_CODEC_RATES,
+		.formats = AC200_CODEC_FORMATS,
+	},
+	.ops = &ac200_codec_dai_ops,
+	.symmetric_rate = 1,
+	.symmetric_sample_bits = 1,
+};
+
+static int ac200_codec_component_probe(struct snd_soc_component *component)
+{
+	struct ac200_codec *priv = snd_soc_component_get_drvdata(component);
+
+	snd_soc_component_init_regmap(component, priv->regmap);
+
+	return 0;
+}
+
+static struct snd_soc_component_driver ac200_soc_component = {
+	.controls		= ac200_codec_controls,
+	.num_controls		= ARRAY_SIZE(ac200_codec_controls),
+	.dapm_widgets		= ac200_codec_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ac200_codec_dapm_widgets),
+	.dapm_routes		= ac200_codec_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ac200_codec_dapm_routes),
+	.probe			= ac200_codec_component_probe,
+};
+
+static int ac200_codec_probe(struct platform_device *pdev)
+{
+	struct ac200_codec *priv;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct ac200_codec), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!priv->regmap)
+		return -EPROBE_DEFER;
+
+	platform_set_drvdata(pdev, priv);
+
+	ret = regmap_write(priv->regmap, AC200_SYS_AUDIO_CTL0,
+			   AC200_SYS_AUDIO_CTL0_RST_INVALID |
+			   AC200_SYS_AUDIO_CTL0_MCLK_GATING);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->regmap, AC200_SYS_AUDIO_CTL1,
+			   AC200_SYS_AUDIO_CTL1_I2S_IO_EN);
+	if (ret)
+		return ret;
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &ac200_soc_component,
+					      &ac200_codec_dai, 1);
+
+	if (ret)
+		dev_err(&pdev->dev, "Failed to register codec: %d\n", ret);
+
+	return ret;
+}
+
+static int ac200_codec_remove(struct platform_device *pdev)
+{
+	struct ac200_codec *priv =  dev_get_drvdata(&pdev->dev);
+
+	regmap_write(priv->regmap, AC200_SYS_AUDIO_CTL0, 0);
+	regmap_write(priv->regmap, AC200_SYS_AUDIO_CTL1, 0);
+
+	return 0;
+}
+
+static const struct of_device_id ac200_codec_match[] = {
+	{ .compatible = "x-powers,ac200-codec" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ac200_codec_match);
+
+static struct platform_driver ac200_codec_driver = {
+	.driver = {
+		.name = "ac200-codec",
+		.of_match_table = ac200_codec_match,
+	},
+	.probe = ac200_codec_probe,
+	.remove = ac200_codec_remove,
+};
+module_platform_driver(ac200_codec_driver);
+
+MODULE_DESCRIPTION("X-Powers AC200 Codec Driver");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_LICENSE("GPL");

diff --git a/src/basic/time-util.c b/src/basic/time-util.c
index 55931a2546157..332fbdffd0992 100644
--- a/src/basic/time-util.c
+++ b/src/basic/time-util.c
@@ -623,6 +623,19 @@ char* format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {
         return buf;
 }
 
+int parse_gmtoff(const char *t, long *ret) {
+        assert(t);
+
+        struct tm tm;
+        const char *k = strptime(t, "%z", &tm);
+        if (!k || *k != '\0')
+                return -EINVAL;
+
+        if (ret)
+                *ret = tm.tm_gmtoff;
+        return 0;
+}
+
 static int parse_timestamp_impl(
                 const char *t,
                 size_t max_len,
@@ -667,10 +667,14 @@ static int parse_timestamp_impl(
         _cleanup_free_ char *t_alloc = NULL;
         usec_t usec, plus = 0, minus = 0;
         bool with_tz = false;
-        int r, weekday = -1;
         unsigned fractional = 0;
         const char *k;
         struct tm tm, copy;
+        int r;
+#ifndef __GLIBC__
+        _unused_
+#endif
+        int weekday = -1;
 
         /* Allowed syntaxes:
          *
@@ -920,8 +924,11 @@ static int parse_timestamp_impl(
         assert(plus == 0);
         assert(minus == 0);
 
+#ifdef __GLIBC__
+        /* musl does not set tm_wday field and set 0 unless it is explicitly requested by %w or so. */
         if (weekday >= 0 && tm.tm_wday != weekday)
                 return -EINVAL;
+#endif
 
         if (gmtoff < 0) {
                 plus = -gmtoff * USEC_PER_SEC;
@@ -965,44 +965,13 @@ static int parse_timestamp_impl(
         return 0;
 }
 
-static int parse_timestamp_maybe_with_tz(const char *t, size_t tz_offset, bool valid_tz, usec_t *ret) {
-        assert(t);
-
-        tzset();
-
-        for (int j = 0; j <= 1; j++) {
-                if (isempty(tzname[j]))
-                        continue;
-
-                if (!streq(t + tz_offset, tzname[j]))
-                        continue;
-
-                /* The specified timezone matches tzname[] of the local timezone. */
-                return parse_timestamp_impl(t, tz_offset - 1, /* utc = */ false, /* isdst = */ j, /* gmtoff = */ 0, ret);
-        }
-
-        /* If we know that the last word is a valid timezone (e.g. Asia/Tokyo), then simply drop the timezone
-         * and parse the remaining string as a local time. If we know that the last word is not a timezone,
-         * then assume that it is a part of the time and try to parse the whole string as a local time. */
-        return parse_timestamp_impl(t, valid_tz ? tz_offset - 1 : SIZE_MAX,
-                                    /* utc = */ false, /* isdst = */ -1, /* gmtoff = */ 0, ret);
-}
-
-typedef struct ParseTimestampResult {
-        usec_t usec;
-        int return_value;
-} ParseTimestampResult;
-
 int parse_timestamp(const char *t, usec_t *ret) {
-        ParseTimestampResult *shared, tmp;
-        const char *k, *tz, *current_tz;
-        size_t max_len, t_len;
-        struct tm tm;
+        long gmtoff;
         int r;
 
         assert(t);
 
-        t_len = strlen(t);
+        size_t t_len = strlen(t);
         if (t_len > 2 && t[t_len - 1] == 'Z') {
                 /* Try to parse as RFC3339-style welded UTC: "1985-04-12T23:20:50.52Z" */
                 r = parse_timestamp_impl(t, t_len - 1, /* utc = */ true, /* isdst = */ -1, /* gmtoff = */ 0, ret);
@@ -1010,17 +979,15 @@ int parse_timestamp(const char *t, usec_t *ret) {
                         return r;
         }
 
-        if (t_len > 7 && IN_SET(t[t_len - 6], '+', '-') && t[t_len - 7] != ' ') {  /* RFC3339-style welded offset: "1990-12-31T15:59:60-08:00" */
-                k = strptime(&t[t_len - 6], "%z", &tm);
-                if (k && *k == '\0')
-                        return parse_timestamp_impl(t, t_len - 6, /* utc = */ true, /* isdst = */ -1, /* gmtoff = */ tm.tm_gmtoff, ret);
-        }
+        /* RFC3339-style welded offset: "1990-12-31T15:59:60-08:00" */
+        if (t_len > 7 && IN_SET(t[t_len - 6], '+', '-') && t[t_len - 7] != ' ' && parse_gmtoff(&t[t_len - 6], &gmtoff) >= 0)
+                return parse_timestamp_impl(t, t_len - 6, /* utc = */ true, /* isdst = */ -1, gmtoff, ret);
 
-        tz = strrchr(t, ' ');
+        const char *tz = strrchr(t, ' ');
         if (!tz)
                 return parse_timestamp_impl(t, /* max_len = */ SIZE_MAX, /* utc = */ false, /* isdst = */ -1, /* gmtoff = */ 0, ret);
 
-        max_len = tz - t;
+        size_t max_len = tz - t;
         tz++;
 
         /* Shortcut, parse the string as UTC. */
@@ -1030,65 +997,39 @@ int parse_timestamp(const char *t, usec_t *ret) {
         /* If the timezone is compatible with RFC-822/ISO 8601 (e.g. +06, or -03:00) then parse the string as
          * UTC and shift the result. Note, this must be earlier than the timezone check with tzname[], as
          * tzname[] may be in the same format. */
-        k = strptime(tz, "%z", &tm);
-        if (k && *k == '\0')
-                return parse_timestamp_impl(t, max_len, /* utc = */ true, /* isdst = */ -1, /* gmtoff = */ tm.tm_gmtoff, ret);
-
-        /* If the last word is not a timezone file (e.g. Asia/Tokyo), then let's check if it matches
-         * tzname[] of the local timezone, e.g. JST or CEST. */
-        if (!timezone_is_valid(tz, LOG_DEBUG))
-                return parse_timestamp_maybe_with_tz(t, tz - t, /* valid_tz = */ false, ret);
-
-        /* Shortcut. If the current $TZ is equivalent to the specified timezone, it is not necessary to fork
-         * the process. */
-        current_tz = getenv("TZ");
-        if (current_tz && *current_tz == ':' && streq(current_tz + 1, tz))
-                return parse_timestamp_maybe_with_tz(t, tz - t, /* valid_tz = */ true, ret);
-
-        /* Otherwise, to avoid polluting the current environment variables, let's fork the process and set
-         * the specified timezone in the child process. */
-
-        shared = mmap(NULL, sizeof *shared, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
-        if (shared == MAP_FAILED)
-                return negative_errno();
-
-        /* The input string may be in argv. Let's copy it. */
-        _cleanup_free_ char *t_copy = strdup(t);
-        if (!t_copy)
-                return -ENOMEM;
-
-        t = t_copy;
-        assert_se(tz = endswith(t_copy, tz));
-
-        r = safe_fork("(sd-timestamp)", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_DEATHSIG_SIGKILL|FORK_WAIT, NULL);
-        if (r < 0) {
-                (void) munmap(shared, sizeof *shared);
-                return r;
-        }
-        if (r == 0) {
-                const char *colon_tz;
-
-                /* tzset(3) says $TZ should be prefixed with ":" if we reference timezone files */
-                colon_tz = strjoina(":", tz);
+        if (parse_gmtoff(tz, &gmtoff) >= 0)
+                return parse_timestamp_impl(t, max_len, /* utc = */ true, /* isdst = */ -1, gmtoff, ret);
 
-                if (setenv("TZ", colon_tz, 1) != 0) {
-                        shared->return_value = negative_errno();
-                        _exit(EXIT_FAILURE);
-                }
+        /* Check if the last word matches tzname[] of the local timezone. Note, this must be done earlier
+         * than the check by timezone_is_valid() below, as some short timezone specifications have their own
+         * timezone files (e.g. WET has its own timezone file, but JST does not), but using such files does
+         * not follow the timezone change in the current area. */
+        tzset();
+        for (int j = 0; j <= 1; j++) {
+                if (isempty(tzname[j]))
+                        continue;
 
-                shared->return_value = parse_timestamp_maybe_with_tz(t, tz - t, /* valid_tz = */ true, &shared->usec);
+                if (!streq(tz, tzname[j]))
+                        continue;
 
-                _exit(EXIT_SUCCESS);
+                /* The specified timezone matches tzname[] of the local timezone. */
+                return parse_timestamp_impl(t, max_len, /* utc = */ false, /* isdst = */ j, /* gmtoff = */ 0, ret);
         }
 
-        tmp = *shared;
-        if (munmap(shared, sizeof *shared) != 0)
-                return negative_errno();
+        /* If the last word is a valid timezone file (e.g. Asia/Tokyo), then save the current timezone, apply
+         * the specified timezone, and parse the remaining string as a local time. */
+        if (timezone_is_valid(tz, LOG_DEBUG)) {
+                SAVE_TIMEZONE;
+
+                if (setenv("TZ", strjoina(":", tz), /* overwrite = */ true) < 0)
+                        return negative_errno();
 
-        if (tmp.return_value == 0 && ret)
-                *ret = tmp.usec;
+                return parse_timestamp_impl(t, max_len, /* utc = */ false, /* isdst = */ -1, /* gmtoff = */ 0, ret);
+        }
 
-        return tmp.return_value;
+        /* Otherwise, assume that the last word is a part of the time and try to parse the whole string as a
+         * local time. */
+        return parse_timestamp_impl(t, SIZE_MAX, /* utc = */ false, /* isdst = */ -1, /* gmtoff = */ 0, ret);
 }
 
 static const char* extract_multiplier(const char *p, usec_t *ret) {
@@ -1584,6 +1584,30 @@ int verify_timezone(const char *name, int log_level) {
         return 0;
 }
 
+void reset_timezone(char **p) {
+        assert(p);
+
+        if (!*p)
+                return;
+
+        if (*p == POINTER_MAX) {
+                (void) unsetenv("TZ");
+                tzset();
+                return;
+        }
+
+        (void) setenv("TZ", *p, /* overwrite = */ true);
+        tzset();
+
+        *p = mfree(*p);
+        return;
+}
+
+char* save_timezone(void) {
+        const char *e = getenv("TZ");
+        return e ? strdup(e) : POINTER_MAX;
+}
+
 bool clock_supported(clockid_t clock) {
         struct timespec ts;
 
diff --git a/src/basic/time-util.h b/src/basic/time-util.h
index d31e62d18ae60..b3cbff5187426 100644
--- a/src/basic/time-util.h
+++ b/src/basic/time-util.h
@@ -149,6 +149,7 @@ static inline char* format_timestamp(char *buf, size_t l, usec_t t) {
 #define FORMAT_TIMESTAMP_STYLE(t, style) \
         format_timestamp_style((char[FORMAT_TIMESTAMP_MAX]){}, FORMAT_TIMESTAMP_MAX, t, style)
 
+int parse_gmtoff(const char *t, long *ret);
 int parse_timestamp(const char *t, usec_t *ret);
 
 int parse_sec(const char *t, usec_t *ret);
@@ -163,6 +163,11 @@ static inline bool timezone_is_valid(const char *name, int log_level) {
         return verify_timezone(name, log_level) >= 0;
 }
 
+void reset_timezone(char **p);
+char* save_timezone(void);
+#define SAVE_TIMEZONE                                                   \
+        _unused_ _cleanup_(reset_timezone) char *_saved_timzeone_ = save_timezone()
+
 bool clock_supported(clockid_t clock);
 
 usec_t usec_shift_clock(usec_t, clockid_t from, clockid_t to);
diff --git a/src/include/musl/time.h b/src/include/musl/time.h
new file mode 100644
index 0000000000000..349f9a3577710
--- /dev/null
+++ b/src/include/musl/time.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include_next <time.h>
+
+char* strptime_fallback(const char *s, const char *format, struct tm *tm);
+#define strptime strptime_fallback
diff --git a/src/libc/musl/meson.build b/src/libc/musl/meson.build
index a876230c67f87..8d06d919ef9ce 100644
--- a/src/libc/musl/meson.build
+++ b/src/libc/musl/meson.build
@@ -3,3 +3,7 @@
 if get_option('libc') != 'musl'
         subdir_done()
 endif
+
+libc_wrapper_sources += files(
+        'time.c',
+)
diff --git a/src/libc/musl/time.c b/src/libc/musl/time.c
new file mode 100644
index 0000000000000..12108166b2bb4
--- /dev/null
+++ b/src/libc/musl/time.c
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#include <stdbool.h>
+#include <string.h>
+#include <time.h>
+
+/* The header time.h overrides strptime with strptime_fallback, hence we need to undef it here. */
+#undef strptime
+
+char* strptime_fallback(const char *s, const char *format, struct tm *tm) {
+        /* First try native strptime() as is, and if it succeeds, return the resuit as is. */
+        char *k = strptime(s, format, tm);
+        if (k)
+                return k;
+
+        /* Check inputs for safety. */
+        if (!s || !format || !tm)
+                return NULL;
+
+        /* We only fallback if the format is exactly "%z". */
+        if (strcmp(format, "%z") != 0)
+                return NULL;
+
+        /* In the below, we parse timezone specifiction compatible with RFC-822/ISO 8601 and its extensions
+         * (e.g. +06, +0900, or -03:00). */
+
+        bool positive;
+        switch (*s) {
+        case '+':
+                positive = true;
+                break;
+        case '-':
+                positive = false;
+                break;
+        default:
+                return NULL;
+        }
+
+        s++;
+
+        if (*s < '0' || *s > '9')
+                return NULL;
+        long t = (*s - '0') * 10 * 60 * 60;
+
+        s++;
+
+        if (*s < '0' || *s > '9')
+                return NULL;
+        t += (*s - '0') * 60 * 60;
+
+        s++;
+
+        if (*s == '\0') /* 2 digits case */
+                goto finalize;
+
+        if (*s == ':') /* skip colon */
+                s++;
+
+        if (*s < '0' || *s >= '6') /* refuse minutes equal to or larger than 60 */
+                return NULL;
+        t += (*s - '0') * 10 * 60;
+
+        s++;
+
+        if (*s < '0' || *s > '9')
+                return NULL;
+        t += (*s - '0') * 60;
+
+        s++;
+
+        if (*s != '\0')
+                return NULL;
+
+finalize:
+        if (t > 24 * 60 * 60) /* refuse larger than 24 hours */
+                return NULL;
+
+        if (!positive)
+                t = -t;
+
+        *tm = (struct tm) {
+                .tm_gmtoff = t,
+        };
+
+        return (char*) s;
+}

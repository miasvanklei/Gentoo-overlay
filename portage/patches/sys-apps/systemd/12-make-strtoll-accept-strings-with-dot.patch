diff --git a/src/include/musl/stdlib.h b/src/include/musl/stdlib.h
new file mode 100644
index 0000000000000..ecfd6ccb43075
--- /dev/null
+++ b/src/include/musl/stdlib.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include_next <stdlib.h>
+
+long long strtoll_fallback(const char *nptr, char **endptr, int base);
+#define strtoll strtoll_fallback
diff --git a/src/libc/musl/meson.build b/src/libc/musl/meson.build
index 5fb590e868ca5..ea09af9fa57af 100644
--- a/src/libc/musl/meson.build
+++ b/src/libc/musl/meson.build
@@ -7,5 +7,6 @@ endif
 libc_wrapper_sources += files(
         'printf.c',
         'time.c',
+        'stdlib.c',
         'string.c',
 )
diff --git a/src/libc/musl/stdlib.c b/src/libc/musl/stdlib.c
new file mode 100644
index 0000000000000..d4e271421796d
--- /dev/null
+++ b/src/libc/musl/stdlib.c
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#include <stdlib.h>
+
+/* The header stdlib.h overrides strtoll with strtoll_fallback, hence we need to undef it here. */
+#undef strtoll
+
+long long strtoll_fallback(const char *nptr, char **endptr, int base) {
+        /* glibc returns 0 if the first character is '.' without error, but musl returns as an error.
+         * As our code assumes the glibc behavior, let's accept string starts with '.'. */
+        if (nptr && *nptr == '.') {
+                if (endptr)
+                        *endptr = (char*) nptr;
+                return 0;
+        }
+
+        /* Otherwise, use the native strtoll(). */
+        return strtoll(nptr, endptr, base);
+}

diff --git a/src/basic/glob-util.c b/src/basic/glob-util.c
index 5843ef088f3f3..84b369be87775 100644
--- a/src/basic/glob-util.c
+++ b/src/basic/glob-util.c
@@ -9,9 +9,42 @@
 #include "string-util.h"
 #include "strv.h"
 
+static bool safe_glob_verify(const char *p, const char *prefix) {
+        if (isempty(p))
+                return false; /* should not happen, but for safey. */
+
+        if (prefix) {
+                /* Skip the prefix, as we allow dots in prefix.
+                 * Note, glob() does not normalize paths, hence do not use path_startswith(). */
+                p = startswith(p, prefix);
+                if (!p)
+                        return false; /* should not happen, but for safety. */
+        }
+
+        for (;;) {
+                p += strspn(p, "/");
+                if (*p == '\0')
+                        return true;
+                if (*p == '.') {
+                        p++;
+                        if (IN_SET(*p, '/', '\0'))
+                                return false; /* refuse dot */
+                        if (*p == '.') {
+                                p++;
+                                if (IN_SET(*p, '/', '\0'))
+                                        return false; /* refuse dot dot */
+                        }
+                }
+
+                p += strcspn(p, "/");
+                if (*p == '\0')
+                        return true;
+        }
+}
+
 DEFINE_TRIVIAL_DESTRUCTOR(closedir_wrapper, void, closedir);
 
-int safe_glob_full(const char *path, int flags, opendir_t opendir_func, char ***ret) {
+int safe_glob_internal(const char *path, int flags, bool use_gnu_extension, opendir_t opendir_func, char ***ret) {
         _cleanup_(globfree) glob_t g = {
                 .gl_closedir = closedir_wrapper,
                 .gl_readdir = (struct dirent* (*)(void *)) readdir_no_dot,
@@ -23,8 +56,16 @@ int safe_glob_full(const char *path, int flags, opendir_t opendir_func, char ***
 
         assert(path);
 
+        // TODO: expand braces if GLOB_BRACE is specified but not supported.
+
+#if GLOB_ALTDIRFUNC == 0
+        use_gnu_extension = false;
+#else
+        SET_FLAG(flags, GLOB_ALTDIRFUNC, use_gnu_extension);
+#endif
+
         errno = 0;
-        r = glob(path, flags | GLOB_ALTDIRFUNC, NULL, &g);
+        r = glob(path, flags, NULL, &g);
         if (r == GLOB_NOMATCH)
                 return -ENOENT;
         if (r == GLOB_NOSPACE)
@@ -32,6 +73,36 @@ int safe_glob_full(const char *path, int flags, opendir_t opendir_func, char ***
         if (r != 0)
                 return errno_or_else(EIO);
 
+        if (!use_gnu_extension) {
+                _cleanup_free_ char *prefix = NULL;
+                r = glob_non_glob_prefix(path, &prefix);
+                if (r < 0 && r != -ENOENT)
+                        return r;
+
+                _cleanup_strv_free_ char **filtered = NULL;
+                size_t n_filtered = 0;
+                STRV_FOREACH(p, g.gl_pathv) {
+                        if (!safe_glob_verify(*p, prefix))
+                                continue;
+
+                        if (!ret)
+                                return 0; /* Found at least one entry, let's return earlier. */
+
+                        /* When musl is used, each entry is not a head of allocated memory. Hence, it is
+                         * necessary to copy the string. */
+                        r = strv_extend_with_size(&filtered, &n_filtered, *p);
+                        if (r < 0)
+                                return r;
+                }
+
+                if (n_filtered == 0)
+                        return -ENOENT;
+
+                assert(ret);
+                *ret = TAKE_PTR(filtered);
+                return 0;
+        }
+
         if (strv_isempty(g.gl_pathv))
                 return -ENOENT;
 
diff --git a/src/basic/glob-util.h b/src/basic/glob-util.h
index ea3e869319843..36bfd6716c141 100644
--- a/src/basic/glob-util.h
+++ b/src/basic/glob-util.h
@@ -7,7 +7,14 @@
 
 typedef DIR* (*opendir_t)(const char *);
 
-int safe_glob_full(const char *path, int flags, opendir_t opendir_func, char ***ret);
+int safe_glob_internal(const char *path, int flags, bool use_gnu_extension, opendir_t opendir_func, char ***ret);
+static inline int safe_glob_test(const char *path, int flags, char ***ret) {
+        /* This is for testing the fallback logic for the case GLOB_ALTDIRFUNC is not supported. */
+        return safe_glob_internal(path, flags, false, NULL, ret);
+}
+static inline int safe_glob_full(const char *path, int flags, opendir_t opendir_func, char ***ret) {
+        return safe_glob_internal(path, flags, true, opendir_func, ret);
+}
 static inline int safe_glob(const char *path, int flags, char ***ret) {
         return safe_glob_full(path, flags, NULL, ret);
 }
diff --git a/src/include/musl/glob.h b/src/include/musl/glob.h
new file mode 100644
index 0000000000000..58e6c50678875
--- /dev/null
+++ b/src/include/musl/glob.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include_next <glob.h>
+
+/* Here, we set 0 to GLOB_ALTDIRFUNC and GLOB_BRACE, rather than the values used by glibc,
+ * to indicate that glob() does not support these flags. */
+
+#ifndef GLOB_ALTDIRFUNC
+#define GLOB_ALTDIRFUNC 0
+#define gl_flags    __dummy1
+#define gl_closedir __dummy2[0]
+#define gl_readdir  __dummy2[1]
+#define gl_opendir  __dummy2[2]
+#define gl_lstat    __dummy2[3]
+#define gl_stat     __dummy2[4]
+#endif
+
+#ifndef GLOB_BRACE
+#define GLOB_BRACE 0
+#endif

--- a/libsandbox/wrapper-funcs/__wrapper_exec.c	2017-10-15 13:34:34.175856093 +0200
+++ b/libsandbox/wrapper-funcs/__wrapper_exec.c	2017-10-15 13:36:54.896731326 +0200
@@ -20,20 +20,17 @@
 #ifndef SB_EXEC_COMMON
 #define SB_EXEC_COMMON
 
-/* Check to see if we can run this program in-process.  If not, try to fall back
- * tracing it out-of-process via some trace mechanisms (e.g. ptrace).
- */
-static bool sb_check_exec(const char *filename, char *const argv[])
+/* Check to see if this a static ELF and if so, protect using trace mechanisms */
+static void sb_check_exec(const char *filename, char *const argv[])
 {
 	int fd;
 	unsigned char *elf;
 	struct stat st;
 	bool do_trace = false;
-	bool run_in_process = true;
 
-	fd = sb_unwrapped_open_DEFAULT(filename, O_RDONLY|O_CLOEXEC, 0);
+	fd = open(filename, O_RDONLY|O_CLOEXEC);
 	if (fd == -1)
-		return true;
+		return;
 	if (fstat(fd, &st))
 		goto out_fd;
 	if (st.st_size < sizeof(Elf64_Ehdr))
@@ -60,131 +57,19 @@
 	 * gains root just to preload libsandbox.so.  That unfortunately
 	 * could easily open up people to root vulns.
 	 */
-	if (st.st_mode & (S_ISUID | S_ISGID))
-		if (getuid() != 0)
-			run_in_process = false;
-
-	/* We also need to ptrace programs that interpose their own allocator.
-	 * http://crbug.com/586444
-	 */
-	if (run_in_process) {
-		static const char * const libc_alloc_syms[] = {
-			"__libc_calloc",
-			"__libc_free",
-			"__libc_malloc",
-			"__libc_realloc",
-			"__malloc_hook",
-			"__realloc_hook",
-			"__free_hook",
-			"__memalign_hook",
-			"__malloc_initialize_hook",
-		};
+	if (getuid() == 0 || !(st.st_mode & (S_ISUID | S_ISGID))) {
 #define PARSE_ELF(n) \
 ({ \
 	Elf##n##_Ehdr *ehdr = (void *)elf; \
 	Elf##n##_Phdr *phdr = (void *)(elf + ehdr->e_phoff); \
-	Elf##n##_Addr vaddr, filesz, vsym = 0, vstr = 0, vhash = 0, vliblist = 0; \
-	Elf##n##_Off offset, symoff = 0, stroff = 0, hashoff = 0, liblistoff = 0; \
-	Elf##n##_Dyn *dyn; \
-	Elf##n##_Sym *sym, *symend; \
-	uint##n##_t ent_size = 0, str_size = 0; \
-	bool dynamic = false; \
-	size_t i; \
-	\
+	uint16_t p; \
+	if (st.st_size < sizeof(*ehdr)) \
+		goto out_mmap; \
 	if (st.st_size < ehdr->e_phoff + ehdr->e_phentsize * ehdr->e_phnum) \
 		goto out_mmap; \
-	\
-	/* First gather the tags we care about. */ \
-	for (i = 0; i < ehdr->e_phnum; ++i) { \
-		switch (phdr[i].p_type) { \
-		case PT_INTERP: dynamic = true; break; \
-		case PT_DYNAMIC: \
-			dyn = (void *)(elf + phdr[i].p_offset); \
-			while (dyn->d_tag != DT_NULL) { \
-				switch (dyn->d_tag) { \
-				case DT_SYMTAB:      vsym = dyn->d_un.d_val; break; \
-				case DT_SYMENT:      ent_size = dyn->d_un.d_val; break; \
-				case DT_STRTAB:      vstr = dyn->d_un.d_val; break; \
-				case DT_STRSZ:       str_size = dyn->d_un.d_val; break; \
-				case DT_HASH:        vhash = dyn->d_un.d_val; break; \
-				case DT_GNU_LIBLIST: vliblist = dyn->d_un.d_val; break; \
-				} \
-				++dyn; \
-			} \
-			break; \
-		} \
-	} \
-	\
-	if (dynamic && vsym && ent_size && vstr && str_size) { \
-		/* Figure out where in the file these tables live. */ \
-		for (i = 0; i < ehdr->e_phnum; ++i) { \
-			vaddr = phdr[i].p_vaddr; \
-			filesz = phdr[i].p_filesz; \
-			offset = phdr[i].p_offset; \
-			if (vsym >= vaddr && vsym < vaddr + filesz) \
-				symoff = offset + (vsym - vaddr); \
-			if (vstr >= vaddr && vstr < vaddr + filesz) \
-				stroff = offset + (vstr - vaddr); \
-			if (vhash >= vaddr && vhash < vaddr + filesz) \
-				hashoff = offset + (vhash - vaddr); \
-			if (vliblist >= vaddr && vliblist < vaddr + filesz) \
-				liblistoff = offset + (vliblist - vaddr); \
-		} \
-		\
-		/* Finally walk the symbol table.  This should generally be fast as \
-		 * we only look at exported symbols, and the vast majority of exes \
-		 * out there do not export any symbols at all. \
-		 */ \
-		if (symoff && stroff) { \
-			/* Nowhere is the # of symbols recorded, or the size of the symbol \
-			 * table.  Instead, we do what glibc does: use the sysv hash table \
-			 * if it exists, else assume that the string table always directly \
-			 * follows the symbol table.  This seems like a poor assumption to \
-			 * make, but glibc has gotten by this long.  See determine_info in \
-			 * glibc's elf/dl-addr.c. \
-			 * \
-			 * Turns out prelink will violate that assumption.  Fortunately it \
-			 * will insert its liblist at the same location all the time -- it \
-			 * replaces the string table with its liblist table. \
-			 * \
-			 * Long term, we should behave the same as glibc and walk the gnu \
-			 * hash table first before falling back to the raw symbol table. \
-			 * \
-			 * We don't sanity check the ranges here as you aren't executing \
-			 * corrupt programs in the sandbox. \
-			 */ \
-			sym = (void *)(elf + symoff); \
-			if (vhash) { \
-				/* Hash entries are always 32-bits. */ \
-				uint32_t *hashes = (void *)(elf + hashoff); \
-				symend = sym + hashes[1]; \
-			} else if (vliblist) \
-				symend = (void *)(elf + liblistoff); \
-			else \
-				symend = (void *)(elf + stroff); \
-			\
-			while (sym < symend) { \
-				char *symname = (void *)(elf + stroff + sym->st_name); \
-				if (ELF##n##_ST_VISIBILITY(sym->st_other) == STV_DEFAULT && \
-				    sym->st_shndx != SHN_UNDEF && sym->st_shndx < SHN_LORESERVE && \
-				    sym->st_name && \
-				    /* Minor optimization to avoid strcmp. */ \
-				    symname[0] == '_' && symname[1] == '_') { \
-					/* Blacklist internal C library symbols. */ \
-					for (i = 0; i < ARRAY_SIZE(libc_alloc_syms); ++i) \
-						if (!strcmp(symname, libc_alloc_syms[i])) { \
-							run_in_process = false; \
-							goto use_trace; \
-						} \
-				} \
-				++sym; \
-			} \
-		} \
-		\
-	} \
-	\
-	if (dynamic) \
-		goto done; \
+	for (p = 0; p < ehdr->e_phnum; ++p) \
+		if (phdr[p].p_type == PT_INTERP) \
+			goto done; \
 })
 		if (elf[EI_CLASS] == ELFCLASS32)
 			PARSE_ELF(32);
@@ -193,7 +78,6 @@
 #undef PARSE_ELF
 	}
 
- use_trace:
 	do_trace = trace_possible(filename, argv, elf);
 	/* Now that we're done with stuff, clean up before forking */
 
@@ -206,8 +90,6 @@
 
 	if (do_trace)
 		trace_main(filename, argv);
-
-	return run_in_process;
 }
 
 #endif
@@ -225,7 +107,6 @@
 WRAPPER_RET_TYPE WRAPPER_NAME(WRAPPER_ARGS_PROTO)
 {
 	WRAPPER_RET_TYPE result = WRAPPER_RET_DEFAULT;
-	bool run_in_process = true;
 
 	/* The C library may implement some exec funcs by calling other
 	 * exec funcs.  So we might get a little sandbox recursion going
@@ -270,15 +151,15 @@
 		if (!SB_SAFE(check_path))
 			goto done;
 
-		run_in_process = sb_check_exec(check_path, argv);
+		sb_check_exec(check_path, argv);
 	}
 #endif
 
 #ifdef EXEC_MY_ENV
-	struct sb_envp_ctx ec = sb_new_envp((char**)envp, run_in_process);
+	struct sb_envp_ctx ec = sb_new_envp((char**)envp, true);
 	char **my_env = ec.sb_envp;
 #else
-	struct sb_envp_ctx ec = sb_new_envp(environ, run_in_process);
+	struct sb_envp_ctx ec = sb_new_envp(environ, true);
 	environ = ec.sb_envp;
 #endif
 
 	restore_errno();

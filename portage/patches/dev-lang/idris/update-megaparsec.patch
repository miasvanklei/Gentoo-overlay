--- a/idris.cabal
+++ b/idris.cabal
@@ -289,10 +289,11 @@
                 , fingertree >= 0.1.4.1 && < 0.2
                 , haskeline >= 0.7 && < 0.8
                 , ieee754 >= 0.7 && < 0.9
-                , megaparsec >= 6.2 && < 7
+                , megaparsec >= 7 && < 8
                 , mtl >= 2.1 && < 2.3
                 , network < 2.8
                 , optparse-applicative >= 0.13 && < 0.15
+                , parser-combinators >= 1.0.0
                 , pretty < 1.2
                 , process < 1.7
                 , regex-tdfa >= 1.2
--- a/src/Idris/Parser/Helpers.hs
+++ b/src/Idris/Parser/Helpers.hs
@@ -393,7 +393,7 @@ popIndent = do ist <- get
 
 -- | Gets current indentation
 indent :: Parsing m => m Int
-indent = P.unPos . P.sourceColumn <$> P.getPosition
+indent = P.unPos . P.sourceColumn <$> P.getSourcePos
 
 -- | Gets last indentation
 lastIndent :: (MonadState IState m) => m Int
--- a/src/Idris/Parser/Stack.hs
+++ b/src/Idris/Parser/Stack.hs
@@ -57,23 +57,24 @@ type Parsing m = (P.MonadParsec Void String m, MonadWriter FC m)
 runparser :: Parser st res -> st -> String -> String -> Either ParseError res
 runparser p i inputname s =
   case P.parse (runWriterT (evalStateT p i)) inputname s of
-    Left err -> Left $ ParseError s err
+    Left err -> Left $ ParseError err
     Right v  -> Right $ fst v
 
 {- * Parse errors -}
 
-data ParseError = ParseError String (P.ParseError (P.Token String) Void)
+newtype ParseError = ParseError (P.ParseErrorBundle String Void)
 
 instance Message ParseError where
-  messageExtent (ParseError _ err) = sourcePositionFC pos
+  messageExtent (ParseError err) = sourcePositionFC pos
     where
-      (pos NonEmpty.:| _) = P.errorPos err
-  messageText (ParseError _ err) = PP.text . init . P.parseErrorTextPretty $ err
-  messageSource (ParseError src _) = Just src
+      (pos, _) = P.reachOffsetNoLine (P.errorOffset err') (P.bundlePosState err)
+      err' = NonEmpty.head . P.bundleErrors $ err
+  messageText (ParseError err) = PP.text . init . P.errorBundlePretty $ err
+  messageSource (ParseError err) = Just . P.sourceName . P.pstateSourcePos . P.bundlePosState $ err
 
 -- | A fully formatted parse error, with caret and bar, etc.
 prettyError                    :: ParseError -> String
-prettyError (ParseError s err) = P.parseErrorPretty' s err
+prettyError (ParseError err) = P.errorBundlePretty err
 
 {- * Mark and restore -}
 
@@ -104,7 +104,7 @@ sourcePositionFC (P.SourcePos name line column) =
 -- This is useful when the position is needed in a way unrelated to the
 -- heirarchy of parsers.  Prefer using @withExtent@ and friends.
 getFC :: Parsing m => m FC
-getFC = sourcePositionFC <$> P.getPosition
+getFC = sourcePositionFC <$> P.getSourcePos
 
 -- | Add an extent (widen) our current parsing context.
 addExtent :: MonadWriter FC m => FC -> m ()
--- a/src/Idris/Output.hs
+++ b/src/Idris/Output.hs
@@ -75,9 +75,10 @@ instance Message SimpleWarning where
 formatMessage :: Message w => w -> Idris OutputDoc
 formatMessage w = do
     i <- getIState
-    maybeSource <- case messageSource w of
-                     Just src -> pure (Just src)
-                     Nothing  -> readSource fc
+    rs <- readSource fc
+    let maybeSource = case rs of
+          Just src -> Just src
+          Nothing -> messageSource w
     let maybeFormattedSource = maybeSource >>= layoutSource fc (regions (idris_highlightedRegions i))
     return $ layoutMessage (layoutFC fc) maybeFormattedSource (messageText w)
   where
--- a/src/Idris/Parser/Stack.hs
+++ b/src/Idris/Parser/Stack.hs
@@ -62,19 +62,29 @@ runparser p i inputname s =
 
 {- * Parse errors -}
 
-newtype ParseError = ParseError (P.ParseErrorBundle String Void)
+newtype ParseError = ParseError { unParseError :: P.ParseErrorBundle String Void }
+
+parseError :: ParseError -> P.ParseError String Void
+parseError = NonEmpty.head . P.bundleErrors . unParseError
+
+parseErrorPosState :: ParseError -> P.PosState String
+parseErrorPosState = P.bundlePosState . unParseError
+
+parseErrorOffset :: ParseError -> Int
+parseErrorOffset = P.errorOffset . parseError
 
 instance Message ParseError where
-  messageExtent (ParseError err) = sourcePositionFC pos
+  messageExtent err = sourcePositionFC pos
+    where
+      (pos, _) = P.reachOffsetNoLine (parseErrorOffset err) (parseErrorPosState err)
+  messageText = PP.text . init . P.parseErrorTextPretty . parseError
+  messageSource err = Just sline
     where
-      (pos, _) = P.reachOffsetNoLine (P.errorOffset err') (P.bundlePosState err)
-      err' = NonEmpty.head . P.bundleErrors $ err
-  messageText (ParseError err) = PP.text . init . P.errorBundlePretty $ err
-  messageSource (ParseError err) = Just . P.sourceName . P.pstateSourcePos . P.bundlePosState $ err
+      (_, sline, _) = P.reachOffset (parseErrorOffset err) (parseErrorPosState err)
 
 -- | A fully formatted parse error, with caret and bar, etc.
-prettyError                    :: ParseError -> String
-prettyError (ParseError err) = P.errorBundlePretty err
+prettyError :: ParseError -> String
+prettyError =  P.errorBundlePretty . unParseError
 
 {- * Mark and restore -}
 
--- a/src/Idris/Package/Parser.hs
+++ b/src/Idris/Package/Parser.hs
@@ -26,14 +26,13 @@ import System.Exit
 import System.FilePath (isValid, takeExtension, takeFileName)
 import Text.Megaparsec ((<?>))
 import qualified Text.Megaparsec as P
-import qualified Text.Megaparsec.Char as P
 import qualified Text.PrettyPrint.ANSI.Leijen as PP
 
 type PParser = Parser PkgDesc
 
 parseDesc :: FilePath -> IO PkgDesc
 parseDesc fp = do
-    when (not $ takeExtension fp == ".ipkg") $ do
+    unless (takeExtension fp == ".ipkg") $ do
         putStrLn $ unwords ["The presented iPKG file does not have a '.ipkg' extension:", show fp]
         exitWith (ExitFailure 1)
     res <- doesFileExist fp
--- a/src/Idris/Parser/Ops.hs
+++ b/src/Idris/Parser/Ops.hs
@@ -23,8 +23,7 @@ import Data.List
 import Data.List.NonEmpty (fromList)
 import Text.Megaparsec ((<?>))
 import qualified Text.Megaparsec as P
-import qualified Text.Megaparsec.Char as P
-import qualified Text.Megaparsec.Expr as P
+import qualified Control.Monad.Combinators.Expr as P
 
 -- | Creates table for fixity declarations to build expression parser
 -- using pre-build and user-defined operator/fixity declarations
--- a/src/Idris/Parser/Expr.hs
+++ b/src/Idris/Parser/Expr.hs
@@ -27,7 +27,7 @@ import Data.Maybe
 import Text.Megaparsec ((<?>))
 import qualified Text.Megaparsec as P
 import qualified Text.Megaparsec.Char as P
-import qualified Text.Megaparsec.Expr as P
+import qualified Control.Monad.Combinators.Expr as P
 
 -- | Allow implicit type declarations
 allowImp :: SyntaxInfo -> SyntaxInfo
@@ -1406,7 +1406,7 @@ VerbatimString_t ::=
  -}
 verbatimStringLiteral :: Parsing m => m String
 verbatimStringLiteral = token $ do P.try $ string "\"\"\""
-                                   str <- P.manyTill P.anyChar $ P.try (string "\"\"\"")
+                                   str <- P.manyTill P.anySingle $ P.try (string "\"\"\"")
                                    moreQuotes <- P.many $ P.char '"'
                                    return $ str ++ moreQuotes
 
--- a/src/Idris/REPL/Parser.hs
+++ b/src/Idris/REPL/Parser.hs
@@ -33,7 +33,6 @@ import Data.List.Split (splitOn)
 import System.Console.ANSI (Color(..))
 import System.FilePath ((</>))
 import qualified Text.Megaparsec as P
-import qualified Text.Megaparsec.Char as P
 
 parseCmd :: IState -> String -> String -> Either IP.ParseError (Either String Command)
 parseCmd i inputname = IP.runparser pCmd i inputname . trim
@@ -68,7 +67,7 @@ parserCommandsForHelp =
   , nameArgCmd ["miss", "missing"] Missing "Show missing clauses"
   , (["doc"], NameArg, "Show internal documentation", cmd_doc)
   , (["mkdoc"], NamespaceArg, "Generate IdrisDoc for namespace(s) and dependencies"
-    , genArg "namespace" (P.many P.anyChar) MakeDoc)
+    , genArg "namespace" (P.many P.anySingle) MakeDoc)
   , (["apropos"], SeqArgs (OptionalArg PkgArgs) NameArg, " Search names, types, and documentation"
     , cmd_apropos)
   , (["s", "search"], SeqArgs (OptionalArg PkgArgs) ExprArg
@@ -198,7 +197,7 @@ pCmd = P.choice [ do c <- cmd names; parser c
     where nop = do P.eof; return (Right NOP)
           unrecognized = do
               IP.lchar ':'
-              cmd <- P.many P.anyChar
+              cmd <- P.many P.anySingle
               let cmd' = takeWhile (/=' ') cmd
               return (Left $ "Unrecognized command: " ++ cmd')
 
@@ -260,7 +259,7 @@ nameArg = genArg "name" IP.name
 fnNameArg = genArg "functionname" IP.fnName
 
 strArg :: (String -> Command) -> String -> IP.IdrisParser (Either String Command)
-strArg = genArg "string" (P.many P.anyChar)
+strArg = genArg "string" (P.many P.anySingle)
 
 moduleArg :: (FilePath -> Command) -> String -> IP.IdrisParser (Either String Command)
 moduleArg = genArg "module" (fmap toPath IP.identifier)
@@ -342,7 +341,7 @@ cmd_execute name = do
 
 cmd_dynamic :: String -> IP.IdrisParser (Either String Command)
 cmd_dynamic name = do
-    let optArg = do l <- P.many P.anyChar
+    let optArg = do l <- P.many P.anySingle
                     if (l /= "")
                         then return $ Right (DynamicLink l)
                         else return $ Right ListDynamic
@@ -440,7 +439,7 @@ cmd_unlet name = Right . Undefine <$> P.many IP.name
 cmd_loadto :: String -> IP.IdrisParser (Either String Command)
 cmd_loadto name = do
     toline <- fromInteger <$> IP.natural
-    f <- P.many P.anyChar
+    f <- P.many P.anySingle
     return (Right (Load f (Just toline)))
 
 cmd_colour :: String -> IP.IdrisParser (Either String Command)
 

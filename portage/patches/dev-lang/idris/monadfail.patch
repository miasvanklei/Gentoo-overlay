--- a/src/Idris/CmdOptions.hs
+++ b/src/Idris/CmdOptions.hs
@@ -264,7 +264,7 @@
 parseCodegen "bytecode" = Bytecode
 parseCodegen cg         = Via IBCFormat (map toLower cg)
 
-parseLogCats :: Monad m => String -> m [LogCat]
+parseLogCats :: (MonadFail m, Monad m) => String -> m [LogCat]
 parseLogCats s =
     case lastMay (readP_to_S doParse s) of
       Just (xs, _) -> return xs
@@ -290,7 +290,7 @@
       s <- look
       fail $ "Category: " ++ s ++ " is not recognised."
 
-parseConsoleWidth :: Monad m => String -> m ConsoleWidth
+parseConsoleWidth :: (MonadFail m, Monad m) => String -> m ConsoleWidth
 parseConsoleWidth "auto"     = return AutomaticWidth
 parseConsoleWidth "infinite" = return InfinitelyWide
 parseConsoleWidth  s =
--- a/src/Idris/Core/CaseTree.hs
+++ b/src/Idris/Core/CaseTree.hs
@@ -627,7 +627,7 @@
         PConst cval -> return $ addConG cval (ps, res) acc
         PSuc n -> return $ addg False CSuc [n] (ps, res) acc
         PReflected fn args -> return $ addg False (CFn fn) args (ps, res) acc
-        pat -> fail $ show pat ++ " is not a constructor or constant (can't happen)"
+        pat -> undefined -- fail $ show pat ++ " is not a constructor or constant (can't happen)"
 
     addg uniq c conargs res []
            = [ConGroup uniq c [(conargs, res)]]
--- a/src/Idris/Core/TT.hs
+++ b/src/Idris/Core/TT.hs
@@ -324,6 +324,8 @@
 instance Monad TC where
     return x = OK x
     x >>= k = bindTC x k
+
+instance MonadFail TC where
     fail e = Error (InternalMsg e)
 
 instance MonadPlus TC where
--- a/src/Idris/Package/Parser.hs
+++ b/src/Idris/Package/Parser.hs
@@ -64,7 +64,7 @@
 -- | Parses a filename.
 -- |
 -- | Treated for now as an identifier or a double-quoted string.
-filename :: Parsing m => m String
+filename :: (MonadFail m, Parsing m) => m String
 filename = (do
                 -- Treat a double-quoted string as a filename to support spaces.
                 -- This also moves away from tying filenames to identifiers, so
--- a/src/Idris/Parser/Data.hs
+++ b/src/Idris/Parser/Data.hs
@@ -91,7 +91,7 @@
                         Nothing    -> Nothing
             return $ map (\n -> (n, p, t, doc')) ns
 
-        constructor :: (Parsing m, MonadState IState m) => m Name
+        constructor :: (MonadFail m, Parsing m, MonadState IState m) => m Name
         constructor = keyword "constructor" *> fnName
 
         endPlicity :: Maybe Char -> IdrisParser Plicity
--- a/src/Idris/Parser/Helpers.hs
+++ b/src/Idris/Parser/Helpers.hs
@@ -512,7 +512,7 @@
                                           when (i < lvl || isParen) (fail "end of block")
                       _ -> return ()
 
-indentGt :: (Parsing m, MonadState IState m) => m ()
+indentGt :: (MonadFail m, Parsing m, MonadState IState m) => m ()
 indentGt = do
   li <- lastIndent
   i <- indent
--- a/src/Idris/Parser/Ops.hs
+++ b/src/Idris/Parser/Ops.hs
@@ -104,7 +104,7 @@
     ;
 @
 -}
-backtickOperator :: (Parsing m, MonadState IState m) => m Name
+backtickOperator :: (MonadFail m, Parsing m, MonadState IState m) => m Name
 backtickOperator = P.between (indentGt *> lchar '`') (indentGt *> lchar '`') name
 
 {- | Parses an operator name (either a symbolic name or a backtick-quoted name)
@@ -116,7 +116,7 @@
     ;
 @
 -}
-operatorName :: (Parsing m, MonadState IState m) => m Name
+operatorName :: (MonadFail m, Parsing m, MonadState IState m) => m Name
 operatorName =     sUN <$> symbolicOperator
                <|> backtickOperator
 
@@ -131,7 +131,7 @@
 @
 
 -}
-operatorFront :: Parsing m => m Name
+operatorFront :: (MonadFail m, Parsing m) => m Name
 operatorFront = do     P.try $ lchar '(' *> (eqTy <$ reservedOp "=") <* lchar ')'
                    <|> maybeWithNS (lchar '(' *> symbolicOperator <* lchar ')') []
 
@@ -141,7 +141,7 @@
   FnName ::= Name | OperatorFront;
 @
 -}
-fnName :: (Parsing m, MonadState IState m) => m Name
+fnName :: (MonadFail m, Parsing m, MonadState IState m) => m Name
 fnName = P.try operatorFront <|> name <?> "function name"
 
 {- | Parses a fixity declaration
@@ -235,7 +235,7 @@
 invalidOperators = [":", "=>", "->", "<-", "=", "?=", "|", "**", "==>", "\\", "%", "~", "?", "!", "@"]
 
 -- | Parses an operator
-symbolicOperator :: Parsing m => m String
+symbolicOperator :: (MonadFail m, Parsing m) => m String
 symbolicOperator = do op <- token . some $ operatorLetter
                       when (op `elem` (invalidOperators ++ commentMarkers)) $
                            fail $ op ++ " is not a valid operator"

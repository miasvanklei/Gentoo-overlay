diff --git a/tests/test.py b/tests/test.py
index 271c6af..35b16ee 100644
--- a/tests/test.py
+++ b/tests/test.py
@@ -391,14 +391,15 @@ def test_subscribe_artists(self):
     def test_get_foreign_playlist(self):
         self.assertRaises(Exception, self.yt.get_playlist, "PLABC")
         playlist = self.yt.get_playlist(sample_playlist, limit=300, suggestions_limit=7)
+        self.assertGreater(len(playlist['duration']), 5)
         self.assertGreater(len(playlist["tracks"]), 200)
         self.assertNotIn("suggestions", playlist)
 
-        playlist = self.yt.get_playlist("RDCLAK5uy_kpxnNxJpPZjLKbL9WgvrPuErWkUxMP6x4",
-                                        limit=None,
-                                        related=True)
-        self.assertGreater(len(playlist["tracks"]), 100)
-        self.assertEqual(len(playlist["related"]), 10)
+        playlist = self.yt_oauth.get_playlist("PLj4BSJLnVpNyIjbCWXWNAmybc97FXLlTk",
+                                              limit=None,
+                                              related=True)
+        self.assertGreater(len(playlist["tracks"]), 200)
+        self.assertEqual(len(playlist["related"]), 0)
 
     def test_get_owned_playlist(self):
         playlist = self.yt_brand.get_playlist(config["playlists"]["own"],
diff --git a/ytmusicapi/mixins/playlists.py b/ytmusicapi/mixins/playlists.py
index d668e09..70f0dfe 100644
--- a/ytmusicapi/mixins/playlists.py
+++ b/ytmusicapi/mixins/playlists.py
@@ -133,20 +133,20 @@ def get_playlist(self,
                 playlist['year'] = nav(header, SUBTITLE3)
 
         second_subtitle_runs = header['secondSubtitle']['runs']
-        own_offset = (own_playlist and len(second_subtitle_runs) > 3) * 2
-        song_count = to_int(second_subtitle_runs[own_offset]['text'])
-        if len(second_subtitle_runs) > 1:
-            playlist['duration'] = second_subtitle_runs[own_offset + 2]['text']
 
+        has_views = (len(second_subtitle_runs) > 3) * 2
+        playlist['views'] = None if not has_views else to_int(second_subtitle_runs[0]['text'])
+        has_duration = (len(second_subtitle_runs) > 1) * 2
+        playlist['duration'] = None if not has_duration else second_subtitle_runs[has_views + has_duration]['text']
+        song_count = second_subtitle_runs[has_views + 0]['text'].split(" ")
+        song_count = to_int(song_count[0]) if len(song_count) > 1 else 0
         playlist['trackCount'] = song_count
-        playlist['views'] = None
-        if own_playlist:
-            playlist['views'] = to_int(second_subtitle_runs[0]['text'])
 
         request_func = lambda additionalParams: self._send_request(endpoint, body, additionalParams)
 
         # suggestions and related are missing e.g. on liked songs
         section_list = nav(response, SINGLE_COLUMN_TAB + ['sectionListRenderer'])
+        playlist['related'] = []
         if 'continuations' in section_list:
             additionalParams = get_continuation_params(section_list)
             if own_playlist and (suggestions_limit > 0 or related):
@@ -168,23 +168,21 @@ def get_playlist(self,
 
             if related:
                 response = request_func(additionalParams)
-                continuation = nav(response, SECTION_LIST_CONTINUATION)
-                parse_func = lambda results: parse_content_list(results, parse_playlist)
-                playlist['related'] = get_continuation_contents(
-                    nav(continuation, CONTENT + CAROUSEL), parse_func)
-
-        if song_count > 0:
+                continuation = nav(response, SECTION_LIST_CONTINUATION, True)
+                if continuation:
+                    parse_func = lambda results: parse_content_list(results, parse_playlist)
+                    playlist['related'] = get_continuation_contents(
+                        nav(continuation, CONTENT + CAROUSEL), parse_func)
+
+        playlist['tracks'] = []
+        if 'contents' in results:
             playlist['tracks'] = parse_playlist_items(results['contents'])
-            if limit is None:
-                limit = song_count
-            songs_to_get = min(limit, song_count)
 
             parse_func = lambda contents: parse_playlist_items(contents)
             if 'continuations' in results:
                 playlist['tracks'].extend(
-                    get_continuations(results, 'musicPlaylistShelfContinuation',
-                                      songs_to_get - len(playlist['tracks']), request_func,
-                                      parse_func))
+                    get_continuations(results, 'musicPlaylistShelfContinuation', limit,
+                                      request_func, parse_func))
 
         playlist['duration_seconds'] = sum_total_duration(playlist)
         return playlist

From cd00102e1397d9d45a837865cb7a16f8ca293781 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Tue, 01 Feb 2022 13:05:36 +0200
Subject: [PATCH] Client: Remove mWaitingForUpdateDelivery

Currently, mWaitingForUpdateDelivery is shared between the main thread
(doHandleFrameCallback()) and the frame callback event thread
(handleFrameCallback()), however the access to it is not synchronized
between both threads. On the other hand, QWaylandWindow
already ensures not to create a frame callback if there's already one
pending.

This change removes mWaitingForUpdateDelivery flag because it should be
already covered by mWaitingForFrameCallback and to remove unsynchronized
shared state between threads.

Change-Id: I0e5a25d18d1e66c4d7683e7e972330c4d7cbbf38
---

diff --git a/src/client/qwaylandwindow.cpp b/src/client/qwaylandwindow.cpp
index 812373a..29e6ef6 100644
--- a/src/client/qwaylandwindow.cpp
+++ b/src/client/qwaylandwindow.cpp
@@ -638,23 +638,18 @@
     mFrameCallbackElapsedTimer.invalidate();
 
     // The rest can wait until we can run it on the correct thread
-    if (!mWaitingForUpdateDelivery) {
-        auto doHandleExpose = [this]() {
-            bool wasExposed = isExposed();
-            mFrameCallbackTimedOut = false;
-            if (!wasExposed && isExposed()) // Did setting mFrameCallbackTimedOut make the window exposed?
-                sendExposeEvent(QRect(QPoint(), geometry().size()));
-            if (wasExposed && hasPendingUpdateRequest())
-                deliverUpdateRequest();
+    auto doHandleExpose = [this]() {
+        bool wasExposed = isExposed();
+        mFrameCallbackTimedOut = false;
+        if (!wasExposed && isExposed()) // Did setting mFrameCallbackTimedOut make the window exposed?
+            sendExposeEvent(QRect(QPoint(), geometry().size()));
+        if (wasExposed && hasPendingUpdateRequest())
+            deliverUpdateRequest();
+    };
 
-            mWaitingForUpdateDelivery = false;
-        };
-
-        // Queued connection, to make sure we don't call handleUpdate() from inside waitForFrameSync()
-        // in the single-threaded case.
-        mWaitingForUpdateDelivery = true;
-        QMetaObject::invokeMethod(this, doHandleExpose, Qt::QueuedConnection);
-    }
+    // Queued connection, to make sure we don't call handleUpdate() from inside waitForFrameSync()
+    // in the single-threaded case.
+    QMetaObject::invokeMethod(this, doHandleExpose, Qt::QueuedConnection);
 
     mFrameSyncWait.notify_all();
 }
diff --git a/src/client/qwaylandwindow_p.h b/src/client/qwaylandwindow_p.h
index d64c80c..6eb8053 100644
--- a/src/client/qwaylandwindow_p.h
+++ b/src/client/qwaylandwindow_p.h
@@ -280,7 +280,6 @@
     WId mWindowId;
     bool mWaitingForFrameCallback = false;
     bool mFrameCallbackTimedOut = false; // Whether the frame callback has timed out
-    bool mWaitingForUpdateDelivery = false;
     int mFrameCallbackCheckIntervalTimerId = -1;
     QElapsedTimer mFrameCallbackElapsedTimer;
     struct ::wl_callback *mFrameCallback = nullptr;

--- a/llvm/cmake/modules/HandleLLVMOptions.cmake	2021-02-18 22:01:01.935290223 +0100
+++ b/llvm/cmake/modules/HandleLLVMOptions.cmake	2021-02-18 22:06:06.651480238 +0100
@@ -77,6 +77,14 @@
   endif()
 endif()
 
+option(LLVM_ENABLE_CLASSIC_FLANG "Build support for classic Flang instead of the new built-in Flang" OFF)
+if(LLVM_ENABLE_CLASSIC_FLANG)
+  set(LLVM_ENABLE_CLASSIC_FLANG 1)
+  add_definitions( -DENABLE_CLASSIC_FLANG )
+else()
+  set(LLVM_ENABLE_CLASSIC_FLANG 0)
+endif()
+
 if(LLVM_ENABLE_EXPENSIVE_CHECKS)
   add_definitions(-DEXPENSIVE_CHECKS)
 
--- a/llvm/include/llvm/Analysis/TargetLibraryInfo.h	2021-02-18 22:01:01.961290447 +0100
+++ b/llvm/include/llvm/Analysis/TargetLibraryInfo.h	2021-02-18 22:01:32.531553652 +0100
@@ -89,6 +89,7 @@
     NoLibrary,  // Don't use any vector library.
     Accelerate, // Use Accelerate framework.
     MASSV,      // IBM MASS vector library.
+    PGMATH,     // PGI math library.
     SVML        // Intel short vector math library.
   };
 
--- a/llvm/include/llvm/Bitcode/LLVMBitCodes.h	2021-02-18 22:01:01.968290508 +0100
+++ b/llvm/include/llvm/Bitcode/LLVMBitCodes.h	2021-02-18 22:01:32.531553652 +0100
@@ -338,6 +338,9 @@
   METADATA_INDEX_OFFSET = 38,           // [offset]
   METADATA_INDEX = 39,                  // [bitpos]
   METADATA_LABEL = 40,                  // [distinct, scope, name, file, line]
+  METADATA_STRING_TYPE = 41,      // [distinct, name, size, align, ...]
+  METADATA_FORTRAN_ARRAY_TYPE = 42, // [distinct, name, [bounds ...], ...]
+  METADATA_FORTRAN_SUBRANGE = 43, // [distinct, lbound, lbnde, ubound, ubnde]
   METADATA_COMMON_BLOCK = 44,     // [distinct, scope, name, variable,...]
 };
 
--- a/llvm/include/llvm/IR/DIBuilder.h	2021-02-18 22:01:01.976290577 +0100
+++ b/llvm/include/llvm/IR/DIBuilder.h	2021-02-18 22:01:32.531553652 +0100
@@ -199,6 +199,12 @@
                                  unsigned Encoding,
                                  DINode::DIFlags Flags = DINode::FlagZero);
 
+    /// Create debugging information entry for a string
+    /// type.
+    /// \param Name        Type name.
+    /// \param SizeInBits  Size of the type.
+    DIStringType *createStringType(StringRef Name, uint64_t SizeInBits);
+
     /// Create debugging information entry for a qualified
     /// type, e.g. 'const int'.
     /// \param Tag         Tag identifing type, e.g. dwarf::TAG_volatile_type
@@ -491,6 +497,14 @@
     DICompositeType *createArrayType(uint64_t Size, uint32_t AlignInBits,
                                      DIType *Ty, DINodeArray Subscripts);
 
+    /// Create debugging information entry for a Fortran array.
+    /// \param Size         Array size.
+    /// \param AlignInBits  Alignment.
+    /// \param Ty           Element type.
+    /// \param Subscripts   Subscripts.
+    DIFortranArrayType *createFortranArrayType(
+        uint64_t Size, uint32_t AlignInBits, DIType *Ty, DINodeArray Subs);
+
     /// Create debugging information entry for a vector type.
     /// \param Size         Array size.
     /// \param AlignInBits  Alignment.
@@ -576,6 +590,12 @@
     DISubrange *getOrCreateSubrange(Metadata *Count, Metadata *LowerBound,
                                     Metadata *UpperBound, Metadata *Stride);
 
+    /// Create a descriptor for a value range.  This
+    /// implicitly uniques the values returned.
+    DIFortranSubrange *getOrCreateFortranSubrange(
+        int64_t CLBound, int64_t CUBound, bool NoUBound, Metadata *Lbound,
+        Metadata * Lbndexp, Metadata *Ubound, Metadata * Ubndexp);
+
     /// Create a new descriptor for the specified variable.
     /// \param Context     Variable scope.
     /// \param Name        Name of the variable.
@@ -727,6 +749,17 @@
                                      StringRef Name, DIFile *File,
                                      unsigned LineNo);
 
+    /// Create common block entry for a Fortran common block
+    /// \param Scope       Scope of this common block
+    /// \param Name        The name of this common block
+    /// \param File        The file this common block is defined
+    /// \param LineNo      Line number
+    /// \param VarList     List of variables that a located in common block
+    /// \param AlignInBits Common block alignment
+    DICommonBlock *createCommonBlock(DIScope *Scope, DIGlobalVariable *decl,
+                                     StringRef Name, DIFile *File,
+                                     unsigned LineNo, uint32_t AlignInBits = 0);
+
     /// This creates new descriptor for a namespace with the specified
     /// parent scope.
     /// \param Scope       Namespace scope
--- a/llvm/include/llvm/IR/DebugInfoMetadata.h	2021-02-18 22:01:01.976290577 +0100
+++ b/llvm/include/llvm/IR/DebugInfoMetadata.h	2021-02-18 22:01:32.532553660 +0100
@@ -180,10 +180,13 @@
       return false;
     case GenericDINodeKind:
     case DISubrangeKind:
+    case DIFortranSubrangeKind:
     case DIEnumeratorKind:
     case DIBasicTypeKind:
+    case DIStringTypeKind:
     case DIDerivedTypeKind:
     case DICompositeTypeKind:
+    case DIFortranArrayTypeKind:
     case DISubroutineTypeKind:
     case DIFileKind:
     case DICompileUnitKind:
@@ -350,6 +353,71 @@
   }
 };
 
+/// Fortran array subrange
+class DIFortranSubrange : public DINode {
+  friend class LLVMContextImpl;
+  friend class MDNode;
+
+  int64_t CLowerBound;
+  int64_t CUpperBound;
+  bool NoUpperBound;
+
+  DIFortranSubrange(LLVMContext &C, StorageType Storage, int64_t CLowerBound,
+                    int64_t CUpperBound, bool NoUpperBound,
+                    ArrayRef<Metadata *> Ops)
+      : DINode(C, DIFortranSubrangeKind, Storage,
+               dwarf::DW_TAG_subrange_type, Ops), CLowerBound(CLowerBound),
+        CUpperBound(CUpperBound), NoUpperBound(NoUpperBound) {}
+  ~DIFortranSubrange() = default;
+
+  static DIFortranSubrange *getImpl(LLVMContext &Context, int64_t CLBound,
+                                    int64_t CUBound, bool NoUpperBound,
+                                    Metadata *Lbound, Metadata *Lbndexp,
+                                    Metadata *Ubound, Metadata *Ubndexp,
+                                    StorageType Storage,
+                                    bool ShouldCreate = true);
+
+  TempDIFortranSubrange cloneImpl() const {
+    return getTemporary(getContext(), getCLowerBound(), getCUpperBound(),
+                        noUpperBound(), getRawLowerBound(),
+                        getRawLowerBoundExpression(), getRawUpperBound(),
+                        getRawUpperBoundExpression());
+  }
+
+public:
+  DEFINE_MDNODE_GET(DIFortranSubrange, (int64_t CLB, int64_t CUB, bool NUB,
+                                        Metadata *LBound, Metadata *LBndExp,
+                                        Metadata *UBound, Metadata *UBndExp),
+                    (CLB, CUB, NUB, LBound, LBndExp, UBound, UBndExp))
+
+  TempDIFortranSubrange clone() const { return cloneImpl(); }
+
+  DIVariable *getLowerBound() const {
+    return cast_or_null<DIVariable>(getRawLowerBound());
+  }
+  DIExpression *getLowerBoundExp() const {
+    return cast_or_null<DIExpression>(getRawLowerBoundExpression());
+  }
+  DIVariable *getUpperBound() const {
+    return  cast_or_null<DIVariable>(getRawUpperBound());
+  }
+  DIExpression *getUpperBoundExp() const {
+    return cast_or_null<DIExpression>(getRawUpperBoundExpression());
+  }
+
+  int64_t getCLowerBound() const { return CLowerBound; }
+  int64_t getCUpperBound() const { return CUpperBound; }
+  Metadata *getRawLowerBound() const { return getOperand(0); }
+  Metadata *getRawLowerBoundExpression() const { return getOperand(1); }
+  Metadata *getRawUpperBound() const { return getOperand(2); }
+  Metadata *getRawUpperBoundExpression() const { return getOperand(3); }
+  bool noUpperBound() const { return NoUpperBound; }
+
+  static bool classof(const Metadata *MD) {
+    return MD->getMetadataID() == DIFortranSubrangeKind;
+  }
+};
+
 /// Enumeration value.
 ///
 /// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no
@@ -451,8 +519,10 @@
     default:
       return false;
     case DIBasicTypeKind:
+    case DIStringTypeKind:
     case DIDerivedTypeKind:
     case DICompositeTypeKind:
+    case DIFortranArrayTypeKind:
     case DISubroutineTypeKind:
     case DIFileKind:
     case DICompileUnitKind:
@@ -697,8 +767,10 @@
     default:
       return false;
     case DIBasicTypeKind:
+    case DIStringTypeKind:
     case DIDerivedTypeKind:
     case DICompositeTypeKind:
+    case DIFortranArrayTypeKind:
     case DISubroutineTypeKind:
       return true;
     }
@@ -747,6 +819,12 @@
   DEFINE_MDNODE_GET(DIBasicType, (unsigned Tag, StringRef Name),
                     (Tag, Name, 0, 0, 0, FlagZero))
   DEFINE_MDNODE_GET(DIBasicType,
+                    (unsigned Tag, StringRef Name, uint64_t SizeInBits),
+                    (Tag, Name, SizeInBits, 0, 0, FlagZero))
+  DEFINE_MDNODE_GET(DIBasicType,
+                    (unsigned Tag, MDString *Name, uint64_t SizeInBits),
+                    (Tag, Name, SizeInBits, 0, 0, FlagZero))
+  DEFINE_MDNODE_GET(DIBasicType,
                     (unsigned Tag, StringRef Name, uint64_t SizeInBits,
                      uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),
                     (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))
@@ -770,6 +848,99 @@
   }
 };
 
+/// String type, Fortran CHARACTER(n)
+class DIStringType : public DIType {
+  friend class LLVMContextImpl;
+  friend class MDNode;
+
+  unsigned Encoding;
+
+  DIStringType(LLVMContext &C, StorageType Storage, unsigned Tag,
+               uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,
+               ArrayRef<Metadata *> Ops)
+      : DIType(C, DIStringTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,
+               FlagZero, Ops),
+        Encoding(Encoding) {}
+  ~DIStringType() = default;
+
+  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,
+                               StringRef Name, Metadata *StringLength,
+                               Metadata *StrLenExp, uint64_t SizeInBits,
+                               uint32_t AlignInBits, unsigned Encoding,
+                               StorageType Storage, bool ShouldCreate = true) {
+    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),
+                   StringLength, StrLenExp, SizeInBits, AlignInBits, Encoding,
+                   Storage, ShouldCreate);
+  }
+  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,
+                               MDString *Name, Metadata *StringLength,
+                               Metadata *StrLenExp, uint64_t SizeInBits,
+                               uint32_t AlignInBits, unsigned Encoding,
+                               StorageType Storage, bool ShouldCreate = true);
+
+  TempDIStringType cloneImpl() const {
+    return getTemporary(getContext(), getTag(), getName(), getRawStringLength(),
+                        getRawStringLengthExp(), getSizeInBits(),
+                        getAlignInBits(), getEncoding());
+  }
+
+public:
+  DEFINE_MDNODE_GET(DIStringType, (unsigned Tag, StringRef Name),
+                    (Tag, Name, nullptr, nullptr, 0, 0, 0))
+  DEFINE_MDNODE_GET(DIStringType,
+                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,
+                     uint32_t AlignInBits),
+                    (Tag, Name, nullptr, nullptr, SizeInBits, AlignInBits, 0))
+  DEFINE_MDNODE_GET(DIStringType,
+                    (unsigned Tag, MDString *Name, uint64_t SizeInBits,
+                     uint32_t AlignInBits),
+                    (Tag, Name, nullptr, nullptr, SizeInBits, AlignInBits, 0))
+  DEFINE_MDNODE_GET(DIStringType,
+                    (unsigned Tag, StringRef Name, Metadata *StringLength,
+                     Metadata *StringLengthExp, uint64_t SizeInBits,
+                     uint32_t AlignInBits),
+                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,
+                     AlignInBits, 0))
+  DEFINE_MDNODE_GET(DIStringType,
+                    (unsigned Tag, MDString *Name, Metadata *StringLength,
+                     Metadata *StringLengthExp, uint64_t SizeInBits,
+                     uint32_t AlignInBits),
+                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,
+                     AlignInBits, 0))
+  DEFINE_MDNODE_GET(DIStringType,
+                    (unsigned Tag, StringRef Name, Metadata *StringLength,
+                     Metadata *StringLengthExp, uint64_t SizeInBits,
+                     uint32_t AlignInBits, unsigned Encoding),
+                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,
+                     AlignInBits, Encoding))
+  DEFINE_MDNODE_GET(DIStringType,
+                    (unsigned Tag, MDString *Name, Metadata *StringLength,
+                     Metadata *StringLengthExp, uint64_t SizeInBits,
+                     uint32_t AlignInBits, unsigned Encoding),
+                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,
+                     AlignInBits, Encoding))
+
+  TempDIStringType clone() const { return cloneImpl(); }
+
+  static bool classof(const Metadata *MD) {
+    return MD->getMetadataID() == DIStringTypeKind;
+  }
+
+  DIVariable *getStringLength() const {
+    return cast_or_null<DIVariable>(getRawStringLength());
+  }
+
+  DIExpression *getStringLengthExp() const {
+    return cast_or_null<DIExpression>(getRawStringLengthExp());
+  }
+
+  unsigned getEncoding() const { return Encoding; }
+
+  Metadata *getRawStringLength() const { return getOperand(3); }
+
+  Metadata *getRawStringLengthExp() const { return getOperand(4); }
+};
+
 /// Derived types.
 ///
 /// This includes qualified types, pointers, references, friends, typedefs, and
@@ -1088,6 +1259,90 @@
   }
 };
 
+/// Fortran array types.
+class DIFortranArrayType : public DIType {
+  friend class LLVMContextImpl;
+  friend class MDNode;
+
+  DIFortranArrayType(LLVMContext &C, StorageType Storage, unsigned Tag,
+                     unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,
+                     uint64_t OffsetInBits, DIFlags Flags,
+                     ArrayRef<Metadata *> Ops)
+      : DIType(C, DIFortranArrayTypeKind, Storage, Tag, Line, SizeInBits,
+               AlignInBits, OffsetInBits, Flags, Ops) {}
+  ~DIFortranArrayType() = default;
+
+  static DIFortranArrayType *
+  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, Metadata *File,
+          unsigned Line, DIScope *Scope, DIType *BaseType,
+          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,
+          DIFlags Flags, DINodeArray Elements, StorageType Storage,
+          bool ShouldCreate = true) {
+    return getImpl(
+        Context, Tag, getCanonicalMDString(Context, Name), File, Line, Scope,
+        BaseType, SizeInBits, AlignInBits, OffsetInBits, Flags, Elements.get(),
+        Storage, ShouldCreate);
+  }
+  static DIFortranArrayType *
+  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,
+          unsigned Line, Metadata *Scope, Metadata *BaseType,
+          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,
+          DIFlags Flags, Metadata *Elements, StorageType Storage,
+          bool ShouldCreate = true);
+
+  TempDIFortranArrayType cloneImpl() const {
+    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),
+                        getScope(), getBaseType(), getSizeInBits(),
+                        getAlignInBits(), getOffsetInBits(), getFlags(),
+                        getElements());
+  }
+
+public:
+  DEFINE_MDNODE_GET(DIFortranArrayType,
+                    (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,
+                     DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,
+                     uint32_t AlignInBits, uint64_t OffsetInBits,
+                     DIFlags Flags, DINodeArray Elements),
+                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,
+                     AlignInBits, OffsetInBits, Flags, Elements))
+  DEFINE_MDNODE_GET(DIFortranArrayType,
+                    (unsigned Tag, MDString *Name, Metadata *File,
+                     unsigned Line, Metadata *Scope, Metadata *BaseType,
+                     uint64_t SizeInBits, uint32_t AlignInBits,
+                     uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements),
+                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,
+                     AlignInBits, OffsetInBits, Flags, Elements))
+
+  TempDIFortranArrayType clone() const { return cloneImpl(); }
+
+  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }
+  DINodeArray getElements() const {
+    return cast_or_null<MDTuple>(getRawElements());
+  }
+
+  Metadata *getRawBaseType() const { return getOperand(3); }
+  Metadata *getRawElements() const { return getOperand(4); }
+
+  /// Replace operands.
+  ///
+  /// If this \a isUniqued() and not \a isResolved(), on a uniquing collision
+  /// this will be RAUW'ed and deleted.  Use a \a TrackingMDRef to keep track
+  /// of its movement if necessary.
+  /// @{
+  void replaceElements(DINodeArray Elements) {
+#ifndef NDEBUG
+    for (DINode *Op : getElements())
+      assert(is_contained(Elements->operands(), Op) &&
+             "Lost a member during member list replacement");
+#endif
+    replaceOperandWith(4, Elements.get());
+  }
+
+  static bool classof(const Metadata *MD) {
+    return MD->getMetadataID() == DIFortranArrayTypeKind;
+  }
+};
+
 /// Type array for a subprogram.
 ///
 /// TODO: Fold the array of types in directly as operands.
--- a/llvm/include/llvm/IR/Metadata.def	2021-02-18 22:01:01.978290594 +0100
+++ b/llvm/include/llvm/IR/Metadata.def	2021-02-18 22:01:32.532553660 +0100
@@ -113,6 +113,9 @@
 HANDLE_SPECIALIZED_MDNODE_BRANCH(DIMacroNode)
 HANDLE_SPECIALIZED_MDNODE_LEAF_UNIQUABLE(DIMacro)
 HANDLE_SPECIALIZED_MDNODE_LEAF_UNIQUABLE(DIMacroFile)
+HANDLE_SPECIALIZED_MDNODE_LEAF_UNIQUABLE(DIStringType)
+HANDLE_SPECIALIZED_MDNODE_LEAF_UNIQUABLE(DIFortranArrayType)
+HANDLE_SPECIALIZED_MDNODE_LEAF_UNIQUABLE(DIFortranSubrange)
 HANDLE_SPECIALIZED_MDNODE_LEAF_UNIQUABLE(DICommonBlock)
 
 #undef HANDLE_METADATA
--- a/llvm/include/llvm-c/DebugInfo.h	2021-02-18 22:01:01.994290731 +0100
+++ b/llvm/include/llvm-c/DebugInfo.h	2021-02-18 22:01:32.531553652 +0100
@@ -159,6 +159,9 @@
   LLVMDIImportedEntityMetadataKind,
   LLVMDIMacroMetadataKind,
   LLVMDIMacroFileMetadataKind,
+  LLVMDIStringTypeMetadataKind,
+  LLVMDIFortranArrayTypeMetadataKind,
+  LLVMDIFortranSubrangeMetadataKind,
   LLVMDICommonBlockMetadataKind
 };
 typedef unsigned LLVMMetadataKind;
--- a/llvm/lib/Analysis/TargetLibraryInfo.cpp	2021-02-18 22:01:01.997290757 +0100
+++ b/llvm/lib/Analysis/TargetLibraryInfo.cpp	2021-02-18 22:01:32.533553669 +0100
@@ -27,7 +27,9 @@
                clEnumValN(TargetLibraryInfoImpl::MASSV, "MASSV",
                           "IBM MASS vector library"),
                clEnumValN(TargetLibraryInfoImpl::SVML, "SVML",
-                          "Intel SVML library")));
+                          "Intel SVML library"),
+               clEnumValN(TargetLibraryInfoImpl::PGMATH, "PGMATH",
+                          "PGI math library")));
 
 StringLiteral const TargetLibraryInfoImpl::StandardNames[LibFunc::NumLibFuncs] =
     {
@@ -562,7 +564,6 @@
 TargetLibraryInfoImpl::TargetLibraryInfoImpl(const Triple &T) {
   // Default to everything being available.
   memset(AvailableArray, -1, sizeof(AvailableArray));
-
   initialize(*this, T, StandardNames);
 }
 
@@ -1565,6 +1566,456 @@
     addVectorizableFunctions(VecFuncs);
     break;
   }
+
+  // NOTE: All routines listed here are not available on all the architectures.
+  // Based on the size of vector registers available and the size of data, the
+  // vector width should be chosen correctly.
+  case PGMATH: {
+    const VecDesc VecFuncs[] = {
+        {"__fd_sin_1", "__fd_sin_2", 2},
+        {"__fd_sin_1", "__fd_sin_4", 4},
+        {"__fd_sin_1", "__fd_sin_8", 8},
+
+        {"__fs_sin_1", "__fs_sin_4", 4},
+        {"__fs_sin_1", "__fs_sin_8", 8},
+        {"__fs_sin_1", "__fs_sin_16", 16},
+
+        {"__pd_sin_1", "__pd_sin_2", 2},
+        {"__pd_sin_1", "__pd_sin_4", 4},
+        {"__pd_sin_1", "__pd_sin_8", 8},
+
+        {"__ps_sin_1", "__ps_sin_4", 4},
+        {"__ps_sin_1", "__ps_sin_8", 8},
+        {"__ps_sin_1", "__ps_sin_16", 16},
+
+        {"__rd_sin_1", "__rd_sin_2", 2},
+        {"__rd_sin_1", "__rd_sin_4", 4},
+        {"__rd_sin_1", "__rd_sin_8", 8},
+
+        {"__rs_sin_1", "__rs_sin_4", 4},
+        {"__rs_sin_1", "__rs_sin_8", 8},
+        {"__rs_sin_1", "__rs_sin_16", 16},
+
+        {"__fd_cos_1", "__fd_cos_2", 2},
+        {"__fd_cos_1", "__fd_cos_4", 4},
+        {"__fd_cos_1", "__fd_cos_8", 8},
+
+        {"__fs_cos_1", "__fs_cos_4", 4},
+        {"__fs_cos_1", "__fs_cos_8", 8},
+        {"__fs_cos_1", "__fs_cos_16", 16},
+
+        {"__pd_cos_1", "__pd_cos_2", 2},
+        {"__pd_cos_1", "__pd_cos_4", 4},
+        {"__pd_cos_1", "__pd_cos_8", 8},
+
+        {"__ps_cos_1", "__ps_cos_4", 4},
+        {"__ps_cos_1", "__ps_cos_8", 8},
+        {"__ps_cos_1", "__ps_cos_16", 16},
+
+        {"__rd_cos_1", "__rd_cos_2", 2},
+        {"__rd_cos_1", "__rd_cos_4", 4},
+        {"__rd_cos_1", "__rd_cos_8", 8},
+
+        {"__rs_cos_1", "__rs_cos_4", 4},
+        {"__rs_cos_1", "__rs_cos_8", 8},
+        {"__rs_cos_1", "__rs_cos_16", 16},
+
+        {"__fd_sincos_1", "__fd_sincos_2", 2},
+        {"__fd_sincos_1", "__fd_sincos_4", 4},
+        {"__fd_sincos_1", "__fd_sincos_8", 8},
+
+        {"__fs_sincos_1", "__fs_sincos_4", 4},
+        {"__fs_sincos_1", "__fs_sincos_8", 8},
+        {"__fs_sincos_1", "__fs_sincos_16", 16},
+
+        {"__pd_sincos_1", "__pd_sincos_2", 2},
+        {"__pd_sincos_1", "__pd_sincos_4", 4},
+        {"__pd_sincos_1", "__pd_sincos_8", 8},
+
+        {"__ps_sincos_1", "__ps_sincos_4", 4},
+        {"__ps_sincos_1", "__ps_sincos_8", 8},
+        {"__ps_sincos_1", "__ps_sincos_16", 16},
+
+        {"__rd_sincos_1", "__rd_sincos_2", 2},
+        {"__rd_sincos_1", "__rd_sincos_4", 4},
+        {"__rd_sincos_1", "__rd_sincos_8", 8},
+
+        {"__rs_sincos_1", "__rs_sincos_4", 4},
+        {"__rs_sincos_1", "__rs_sincos_8", 8},
+        {"__rs_sincos_1", "__rs_sincos_16", 16},
+
+        {"__fd_tan_1", "__fd_tan_2", 2},
+        {"__fd_tan_1", "__fd_tan_4", 4},
+        {"__fd_tan_1", "__fd_tan_8", 8},
+
+        {"__fs_tan_1", "__fs_tan_4", 4},
+        {"__fs_tan_1", "__fs_tan_8", 8},
+        {"__fs_tan_1", "__fs_tan_16", 16},
+
+        {"__pd_tan_1", "__pd_tan_2", 2},
+        {"__pd_tan_1", "__pd_tan_4", 4},
+        {"__pd_tan_1", "__pd_tan_8", 8},
+
+        {"__ps_tan_1", "__ps_tan_4", 4},
+        {"__ps_tan_1", "__ps_tan_8", 8},
+        {"__ps_tan_1", "__ps_tan_16", 16},
+
+        {"__rd_tan_1", "__rd_tan_2", 2},
+        {"__rd_tan_1", "__rd_tan_4", 4},
+        {"__rd_tan_1", "__rd_tan_8", 8},
+
+        {"__rs_tan_1", "__rs_tan_4", 4},
+        {"__rs_tan_1", "__rs_tan_8", 8},
+        {"__rs_tan_1", "__rs_tan_16", 16},
+
+        {"__fd_sinh_1", "__fd_sinh_2", 2},
+        {"__fd_sinh_1", "__fd_sinh_4", 4},
+        {"__fd_sinh_1", "__fd_sinh_8", 8},
+
+        {"__fs_sinh_1", "__fs_sinh_4", 4},
+        {"__fs_sinh_1", "__fs_sinh_8", 8},
+        {"__fs_sinh_1", "__fs_sinh_16", 16},
+
+        {"__pd_sinh_1", "__pd_sinh_2", 2},
+        {"__pd_sinh_1", "__pd_sinh_4", 4},
+        {"__pd_sinh_1", "__pd_sinh_8", 8},
+
+        {"__ps_sinh_1", "__ps_sinh_4", 4},
+        {"__ps_sinh_1", "__ps_sinh_8", 8},
+        {"__ps_sinh_1", "__ps_sinh_16", 16},
+
+        {"__rd_sinh_1", "__rd_sinh_2", 2},
+        {"__rd_sinh_1", "__rd_sinh_4", 4},
+        {"__rd_sinh_1", "__rd_sinh_8", 8},
+
+        {"__rs_sinh_1", "__rs_sinh_4", 4},
+        {"__rs_sinh_1", "__rs_sinh_8", 8},
+        {"__rs_sinh_1", "__rs_sinh_16", 16},
+
+        {"__fd_cosh_1", "__fd_cosh_2", 2},
+        {"__fd_cosh_1", "__fd_cosh_4", 4},
+        {"__fd_cosh_1", "__fd_cosh_8", 8},
+
+        {"__fs_cosh_1", "__fs_cosh_4", 4},
+        {"__fs_cosh_1", "__fs_cosh_8", 8},
+        {"__fs_cosh_1", "__fs_cosh_16", 16},
+
+        {"__pd_cosh_1", "__pd_cosh_2", 2},
+        {"__pd_cosh_1", "__pd_cosh_4", 4},
+        {"__pd_cosh_1", "__pd_cosh_8", 8},
+
+        {"__ps_cosh_1", "__ps_cosh_4", 4},
+        {"__ps_cosh_1", "__ps_cosh_8", 8},
+        {"__ps_cosh_1", "__ps_cosh_16", 16},
+
+        {"__rd_cosh_1", "__rd_cosh_2", 2},
+        {"__rd_cosh_1", "__rd_cosh_4", 4},
+        {"__rd_cosh_1", "__rd_cosh_8", 8},
+
+        {"__rs_cosh_1", "__rs_cosh_4", 4},
+        {"__rs_cosh_1", "__rs_cosh_8", 8},
+        {"__rs_cosh_1", "__rs_cosh_16", 16},
+
+        {"__fd_tanh_1", "__fd_tanh_2", 2},
+        {"__fd_tanh_1", "__fd_tanh_4", 4},
+        {"__fd_tanh_1", "__fd_tanh_8", 8},
+
+        {"__fs_tanh_1", "__fs_tanh_4", 4},
+        {"__fs_tanh_1", "__fs_tanh_8", 8},
+        {"__fs_tanh_1", "__fs_tanh_16", 16},
+
+        {"__pd_tanh_1", "__pd_tanh_2", 2},
+        {"__pd_tanh_1", "__pd_tanh_4", 4},
+        {"__pd_tanh_1", "__pd_tanh_8", 8},
+
+        {"__ps_tanh_1", "__ps_tanh_4", 4},
+        {"__ps_tanh_1", "__ps_tanh_8", 8},
+        {"__ps_tanh_1", "__ps_tanh_16", 16},
+
+        {"__rd_tanh_1", "__rd_tanh_2", 2},
+        {"__rd_tanh_1", "__rd_tanh_4", 4},
+        {"__rd_tanh_1", "__rd_tanh_8", 8},
+
+        {"__rs_tanh_1", "__rs_tanh_4", 4},
+        {"__rs_tanh_1", "__rs_tanh_8", 8},
+        {"__rs_tanh_1", "__rs_tanh_16", 16},
+
+        {"__fd_asin_1", "__fd_asin_2", 2},
+        {"__fd_asin_1", "__fd_asin_4", 4},
+        {"__fd_asin_1", "__fd_asin_8", 8},
+
+        {"__fs_asin_1", "__fs_asin_4", 4},
+        {"__fs_asin_1", "__fs_asin_8", 8},
+        {"__fs_asin_1", "__fs_asin_16", 16},
+
+        {"__pd_asin_1", "__pd_asin_2", 2},
+        {"__pd_asin_1", "__pd_asin_4", 4},
+        {"__pd_asin_1", "__pd_asin_8", 8},
+
+        {"__ps_asin_1", "__ps_asin_4", 4},
+        {"__ps_asin_1", "__ps_asin_8", 8},
+        {"__ps_asin_1", "__ps_asin_16", 16},
+
+        {"__rd_asin_1", "__rd_asin_2", 2},
+        {"__rd_asin_1", "__rd_asin_4", 4},
+        {"__rd_asin_1", "__rd_asin_8", 8},
+
+        {"__rs_asin_1", "__rs_asin_4", 4},
+        {"__rs_asin_1", "__rs_asin_8", 8},
+        {"__rs_asin_1", "__rs_asin_16", 16},
+
+        {"__fd_acos_1", "__fd_acos_2", 2},
+        {"__fd_acos_1", "__fd_acos_4", 4},
+        {"__fd_acos_1", "__fd_acos_8", 8},
+
+        {"__fs_acos_1", "__fs_acos_4", 4},
+        {"__fs_acos_1", "__fs_acos_8", 8},
+        {"__fs_acos_1", "__fs_acos_16", 16},
+
+        {"__pd_acos_1", "__pd_acos_2", 2},
+        {"__pd_acos_1", "__pd_acos_4", 4},
+        {"__pd_acos_1", "__pd_acos_8", 8},
+
+        {"__ps_acos_1", "__ps_acos_4", 4},
+        {"__ps_acos_1", "__ps_acos_8", 8},
+        {"__ps_acos_1", "__ps_acos_16", 16},
+
+        {"__rd_acos_1", "__rd_acos_2", 2},
+        {"__rd_acos_1", "__rd_acos_4", 4},
+        {"__rd_acos_1", "__rd_acos_8", 8},
+
+        {"__rs_acos_1", "__rs_acos_4", 4},
+        {"__rs_acos_1", "__rs_acos_8", 8},
+        {"__rs_acos_1", "__rs_acos_16", 16},
+
+        {"__fd_atan_1", "__fd_atan_2", 2},
+        {"__fd_atan_1", "__fd_atan_4", 4},
+        {"__fd_atan_1", "__fd_atan_8", 8},
+
+        {"__fs_atan_1", "__fs_atan_4", 4},
+        {"__fs_atan_1", "__fs_atan_8", 8},
+        {"__fs_atan_1", "__fs_atan_16", 16},
+
+        {"__pd_atan_1", "__pd_atan_2", 2},
+        {"__pd_atan_1", "__pd_atan_4", 4},
+        {"__pd_atan_1", "__pd_atan_8", 8},
+
+        {"__ps_atan_1", "__ps_atan_4", 4},
+        {"__ps_atan_1", "__ps_atan_8", 8},
+        {"__ps_atan_1", "__ps_atan_16", 16},
+
+        {"__rd_atan_1", "__rd_atan_2", 2},
+        {"__rd_atan_1", "__rd_atan_4", 4},
+        {"__rd_atan_1", "__rd_atan_8", 8},
+
+        {"__rs_atan_1", "__rs_atan_4", 4},
+        {"__rs_atan_1", "__rs_atan_8", 8},
+        {"__rs_atan_1", "__rs_atan_16", 16},
+
+        {"__fd_atan2_1", "__fd_atan2_2", 2},
+        {"__fd_atan2_1", "__fd_atan2_4", 4},
+        {"__fd_atan2_1", "__fd_atan2_8", 8},
+
+        {"__fs_atan2_1", "__fs_atan2_4", 4},
+        {"__fs_atan2_1", "__fs_atan2_8", 8},
+        {"__fs_atan2_1", "__fs_atan2_16", 16},
+
+        {"__pd_atan2_1", "__pd_atan2_2", 2},
+        {"__pd_atan2_1", "__pd_atan2_4", 4},
+        {"__pd_atan2_1", "__pd_atan2_8", 8},
+
+        {"__ps_atan2_1", "__ps_atan2_4", 4},
+        {"__ps_atan2_1", "__ps_atan2_8", 8},
+        {"__ps_atan2_1", "__ps_atan2_16", 16},
+
+        {"__rd_atan2_1", "__rd_atan2_2", 2},
+        {"__rd_atan2_1", "__rd_atan2_4", 4},
+        {"__rd_atan2_1", "__rd_atan2_8", 8},
+
+        {"__rs_atan2_1", "__rs_atan2_4", 4},
+        {"__rs_atan2_1", "__rs_atan2_8", 8},
+        {"__rs_atan2_1", "__rs_atan2_16", 16},
+
+        {"__fd_pow_1", "__fd_pow_2", 2},
+        {"__fd_pow_1", "__fd_pow_4", 4},
+        {"__fd_pow_1", "__fd_pow_8", 8},
+
+        {"__fs_pow_1", "__fs_pow_4", 4},
+        {"__fs_pow_1", "__fs_pow_8", 8},
+        {"__fs_pow_1", "__fs_pow_16", 16},
+
+        {"__pd_pow_1", "__pd_pow_2", 2},
+        {"__pd_pow_1", "__pd_pow_4", 4},
+        {"__pd_pow_1", "__pd_pow_8", 8},
+
+        {"__ps_pow_1", "__ps_pow_4", 4},
+        {"__ps_pow_1", "__ps_pow_8", 8},
+        {"__ps_pow_1", "__ps_pow_16", 16},
+
+        {"__rd_pow_1", "__rd_pow_2", 2},
+        {"__rd_pow_1", "__rd_pow_4", 4},
+        {"__rd_pow_1", "__rd_pow_8", 8},
+
+        {"__rs_pow_1", "__rs_pow_4", 4},
+        {"__rs_pow_1", "__rs_pow_8", 8},
+        {"__rs_pow_1", "__rs_pow_16", 16},
+
+        {"__fs_powi_1", "__fs_powi_4", 4},
+        {"__fs_powi_1", "__fs_powi_8", 8},
+        {"__fs_powi_1", "__fs_powi_16", 16},
+
+        {"__ps_powi_1", "__ps_powi_4", 4},
+        {"__ps_powi_1", "__ps_powi_8", 8},
+        {"__ps_powi_1", "__ps_powi_16", 16},
+
+        {"__rs_powi_1", "__rs_powi_4", 4},
+        {"__rs_powi_1", "__rs_powi_8", 8},
+        {"__rs_powi_1", "__rs_powi_16", 16},
+
+        {"__fd_powi1_1", "__fd_powi1_2", 2},
+        {"__fd_powi1_1", "__fd_powi1_4", 4},
+        {"__fd_powi1_1", "__fd_powi1_8", 8},
+
+        {"__fs_powi1_1", "__fs_powi1_4", 4},
+        {"__fs_powi1_1", "__fs_powi1_8", 8},
+        {"__fs_powi1_1", "__fs_powi1_16", 16},
+
+        {"__pd_powi1_1", "__pd_powi1_2", 2},
+        {"__pd_powi1_1", "__pd_powi1_4", 4},
+        {"__pd_powi1_1", "__pd_powi1_8", 8},
+
+        {"__ps_powi1_1", "__ps_powi1_4", 4},
+        {"__ps_powi1_1", "__ps_powi1_8", 8},
+        {"__ps_powi1_1", "__ps_powi1_16", 16},
+
+        {"__rd_powi1_1", "__rd_powi1_2", 2},
+        {"__rd_powi1_1", "__rd_powi1_4", 4},
+        {"__rd_powi1_1", "__rd_powi1_8", 8},
+
+        {"__rs_powi1_1", "__rs_powi1_4", 4},
+        {"__rs_powi1_1", "__rs_powi1_8", 8},
+        {"__rs_powi1_1", "__rs_powi1_16", 16},
+
+        {"__fd_powk_1", "__fd_powk_2", 2},
+        {"__fd_powk_1", "__fd_powk_4", 4},
+        {"__fd_powk_1", "__fd_powk_8", 8},
+
+        {"__fs_powk_1", "__fs_powk_4", 4},
+        {"__fs_powk_1", "__fs_powk_8", 8},
+        {"__fs_powk_1", "__fs_powk_16", 16},
+
+        {"__pd_powk_1", "__pd_powk_2", 2},
+        {"__pd_powk_1", "__pd_powk_4", 4},
+        {"__pd_powk_1", "__pd_powk_8", 8},
+
+        {"__ps_powk_1", "__ps_powk_4", 4},
+        {"__ps_powk_1", "__ps_powk_8", 8},
+        {"__ps_powk_1", "__ps_powk_16", 16},
+
+        {"__rd_powk_1", "__rd_powk_2", 2},
+        {"__rd_powk_1", "__rd_powk_4", 4},
+        {"__rd_powk_1", "__rd_powk_8", 8},
+
+        {"__rs_powk_1", "__rs_powk_4", 4},
+        {"__rs_powk_1", "__rs_powk_8", 8},
+        {"__rs_powk_1", "__rs_powk_16", 16},
+
+        {"__fd_powk1_1", "__fd_powk1_2", 2},
+        {"__fd_powk1_1", "__fd_powk1_4", 4},
+        {"__fd_powk1_1", "__fd_powk1_8", 8},
+
+        {"__fs_powk1_1", "__fs_powk1_4", 4},
+        {"__fs_powk1_1", "__fs_powk1_8", 8},
+        {"__fs_powk1_1", "__fs_powk1_16", 16},
+
+        {"__pd_powk1_1", "__pd_powk1_2", 2},
+        {"__pd_powk1_1", "__pd_powk1_4", 4},
+        {"__pd_powk1_1", "__pd_powk1_8", 8},
+
+        {"__ps_powk1_1", "__ps_powk1_4", 4},
+        {"__ps_powk1_1", "__ps_powk1_8", 8},
+        {"__ps_powk1_1", "__ps_powk1_16", 16},
+
+        {"__rd_powk1_1", "__rd_powk1_2", 2},
+        {"__rd_powk1_1", "__rd_powk1_4", 4},
+        {"__rd_powk1_1", "__rd_powk1_8", 8},
+
+        {"__rs_powk1_1", "__rs_powk1_4", 4},
+        {"__rs_powk1_1", "__rs_powk1_8", 8},
+        {"__rs_powk1_1", "__rs_powk1_16", 16},
+
+        {"__fd_log10_1", "__fd_log10_2", 2},
+        {"__fd_log10_1", "__fd_log10_4", 4},
+        {"__fd_log10_1", "__fd_log10_8", 8},
+
+        {"__fs_log10_1", "__fs_log10_4", 4},
+        {"__fs_log10_1", "__fs_log10_8", 8},
+        {"__fs_log10_1", "__fs_log10_16", 16},
+
+        {"__pd_log10_1", "__pd_log10_2", 2},
+        {"__pd_log10_1", "__pd_log10_4", 4},
+        {"__pd_log10_1", "__pd_log10_8", 8},
+
+        {"__ps_log10_1", "__ps_log10_4", 4},
+        {"__ps_log10_1", "__ps_log10_8", 8},
+        {"__ps_log10_1", "__ps_log10_16", 16},
+
+        {"__rd_log10_1", "__rd_log10_2", 2},
+        {"__rd_log10_1", "__rd_log10_4", 4},
+        {"__rd_log10_1", "__rd_log10_8", 8},
+
+        {"__rs_log10_1", "__rs_log10_4", 4},
+        {"__rs_log10_1", "__rs_log10_8", 8},
+        {"__rs_log10_1", "__rs_log10_16", 16},
+
+        {"__fd_log_1", "__fd_log_2", 2},
+        {"__fd_log_1", "__fd_log_4", 4},
+        {"__fd_log_1", "__fd_log_8", 8},
+
+        {"__fs_log_1", "__fs_log_4", 4},
+        {"__fs_log_1", "__fs_log_8", 8},
+        {"__fs_log_1", "__fs_log_16", 16},
+
+        {"__pd_log_1", "__pd_log_2", 2},
+        {"__pd_log_1", "__pd_log_4", 4},
+        {"__pd_log_1", "__pd_log_8", 8},
+
+        {"__ps_log_1", "__ps_log_4", 4},
+        {"__ps_log_1", "__ps_log_8", 8},
+        {"__ps_log_1", "__ps_log_16", 16},
+
+        {"__rd_log_1", "__rd_log_2", 2},
+        {"__rd_log_1", "__rd_log_4", 4},
+        {"__rd_log_1", "__rd_log_8", 8},
+
+        {"__rs_log_1", "__rs_log_4", 4},
+        {"__rs_log_1", "__rs_log_8", 8},
+        {"__rs_log_1", "__rs_log_16", 16},
+
+        {"__fs_exp_1", "__fs_exp_4", 4},
+        {"__fs_exp_1", "__fs_exp_8", 8},
+        {"__fs_exp_1", "__fs_exp_16", 16},
+
+        {"__pd_exp_1", "__pd_exp_2", 2},
+        {"__pd_exp_1", "__pd_exp_4", 4},
+        {"__pd_exp_1", "__pd_exp_8", 8},
+
+        {"__ps_exp_1", "__ps_exp_4", 4},
+        {"__ps_exp_1", "__ps_exp_8", 8},
+        {"__ps_exp_1", "__ps_exp_16", 16},
+
+        {"__rd_exp_1", "__rd_exp_2", 2},
+        {"__rd_exp_1", "__rd_exp_4", 4},
+        {"__rd_exp_1", "__rd_exp_8", 8},
+
+        {"__rs_exp_1", "__rs_exp_4", 4},
+        {"__rs_exp_1", "__rs_exp_8", 8},
+        {"__rs_exp_1", "__rs_exp_16", 16}
+    };
+    addVectorizableFunctions(VecFuncs);
+    break;
+  }
+
   case NoLibrary:
     break;
   }
--- a/llvm/lib/AsmParser/LLParser.cpp	2021-02-18 22:01:02.003290809 +0100
+++ b/llvm/lib/AsmParser/LLParser.cpp	2021-02-18 22:06:06.652480249 +0100
@@ -4565,6 +4565,28 @@
   return false;
 }
 
+/// ParseDIFortranSubrange:
+///   ::= !DIFortranSubrange(lowerBound: 2)
+bool LLParser::ParseDIFortranSubrange(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(constLowerBound, MDSignedField, (0, INT64_MIN, INT64_MAX));         \
+  OPTIONAL(constUpperBound, MDSignedField, (0, INT64_MIN, INT64_MAX));         \
+  OPTIONAL(lowerBound, MDField, );                                             \
+  OPTIONAL(lowerBoundExpression, MDField, );                                   \
+  OPTIONAL(upperBound, MDField, );                                             \
+  OPTIONAL(upperBoundExpression, MDField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  Result = GET_OR_DISTINCT(DIFortranSubrange,
+                           (Context, constLowerBound.Val, constUpperBound.Val,
+                            (!constUpperBound.Seen) && (!upperBound.Seen),
+                            lowerBound.Val, lowerBoundExpression.Val,
+                            upperBound.Val, upperBoundExpression.Val));
+  return false;
+}
+
+
 /// ParseDIEnumerator:
 ///   ::= !DIEnumerator(value: 30, isUnsigned: true, name: "SomeKind")
 bool LLParser::ParseDIEnumerator(MDNode *&Result, bool IsDistinct) {
@@ -4609,6 +4631,26 @@
   return false;
 }
 
+/// ParseDIStringType:
+///   ::= !DIStringType(name: "character(4)", size: 32, align: 32)
+bool LLParser::ParseDIStringType(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_string_type));                   \
+  OPTIONAL(name, MDStringField, );                                             \
+  OPTIONAL(stringLength, MDField, );                                           \
+  OPTIONAL(stringLengthExpression, MDField, );                                 \
+  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \
+  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \
+  OPTIONAL(encoding, DwarfAttEncodingField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  Result = GET_OR_DISTINCT(DIStringType, (Context, tag.Val, name.Val,
+      stringLength.Val, stringLengthExpression.Val, size.Val, align.Val,
+      encoding.Val));
+  return false;
+}
+
 /// ParseDIDerivedType:
 ///   ::= !DIDerivedType(tag: DW_TAG_pointer_type, name: "int", file: !0,
 ///                      line: 7, scope: !1, baseType: !2, size: 32,
@@ -4687,6 +4729,31 @@
   return false;
 }
 
+bool LLParser::ParseDIFortranArrayType(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_array_type));                    \
+  OPTIONAL(name, MDStringField, );                                             \
+  OPTIONAL(file, MDField, );                                                   \
+  OPTIONAL(line, LineField, );                                                 \
+  OPTIONAL(scope, MDField, );                                                  \
+  OPTIONAL(baseType, MDField, );                                               \
+  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \
+  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \
+  OPTIONAL(offset, MDUnsignedField, (0, UINT64_MAX));                          \
+  OPTIONAL(flags, DIFlagField, );                                              \
+  OPTIONAL(elements, MDField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  // Create a new node, and save it in the context if it belongs in the type
+  // map.
+  Result = GET_OR_DISTINCT(
+      DIFortranArrayType,
+      (Context, tag.Val, name.Val, file.Val, line.Val, scope.Val, baseType.Val,
+       size.Val, align.Val, offset.Val, flags.Val, elements.Val));
+  return false;
+}
+
 bool LLParser::ParseDISubroutineType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(flags, DIFlagField, );                                              \
@@ -4990,6 +5057,21 @@
 ///                         isDefinition: true, templateParams: !3,
 ///                         declaration: !4, align: 8)
 bool LLParser::ParseDIGlobalVariable(MDNode *&Result, bool IsDistinct) {
+#ifdef ENABLE_CLASSIC_FLANG
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(name, MDStringField, (/* AllowEmpty */ true));                      \
+  OPTIONAL(scope, MDField, );                                                  \
+  OPTIONAL(linkageName, MDStringField, );                                      \
+  OPTIONAL(file, MDField, );                                                   \
+  OPTIONAL(line, LineField, );                                                 \
+  OPTIONAL(type, MDField, );                                                   \
+  OPTIONAL(isLocal, MDBoolField, );                                            \
+  OPTIONAL(isDefinition, MDBoolField, (true));                                 \
+  OPTIONAL(templateParams, MDField, );                                         \
+  OPTIONAL(declaration, MDField, );                                            \
+  OPTIONAL(flags, DIFlagField, );                                              \
+  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));
+#else
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(name, MDStringField, (/* AllowEmpty */ false));                     \
   OPTIONAL(scope, MDField, );                                                  \
@@ -5001,7 +5083,9 @@
   OPTIONAL(isDefinition, MDBoolField, (true));                                 \
   OPTIONAL(templateParams, MDField, );                                         \
   OPTIONAL(declaration, MDField, );                                            \
+  OPTIONAL(flags, DIFlagField, );                                              \
   OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));
+#endif
   PARSE_MD_FIELDS();
 #undef VISIT_MD_FIELDS
 
--- a/llvm/lib/Bitcode/Reader/MetadataLoader.cpp	2021-02-18 22:01:02.004290818 +0100
+++ b/llvm/lib/Bitcode/Reader/MetadataLoader.cpp	2021-02-18 22:01:32.534553678 +0100
@@ -851,10 +851,13 @@
       case bitc::METADATA_LOCATION:
       case bitc::METADATA_GENERIC_DEBUG:
       case bitc::METADATA_SUBRANGE:
+      case bitc::METADATA_FORTRAN_SUBRANGE:
       case bitc::METADATA_ENUMERATOR:
       case bitc::METADATA_BASIC_TYPE:
+      case bitc::METADATA_STRING_TYPE:
       case bitc::METADATA_DERIVED_TYPE:
       case bitc::METADATA_COMPOSITE_TYPE:
+      case bitc::METADATA_FORTRAN_ARRAY_TYPE:
       case bitc::METADATA_SUBROUTINE_TYPE:
       case bitc::METADATA_MODULE:
       case bitc::METADATA_FILE:
@@ -1286,6 +1289,20 @@
     NextMetadataNo++;
     break;
   }
+  case bitc::METADATA_FORTRAN_SUBRANGE: {
+    if (Record.size() != 8)
+      return error("Invalid record");
+
+    IsDistinct = Record[0];
+    MetadataList.assignValue(
+        GET_OR_DISTINCT(DIFortranSubrange,
+                        (Context, Record[1], Record[2], Record[3],
+                         getMDOrNull(Record[4]), getMDOrNull(Record[5]),
+                         getMDOrNull(Record[6]), getMDOrNull(Record[7]))),
+        NextMetadataNo);
+    NextMetadataNo++;
+    break;
+  }
   case bitc::METADATA_ENUMERATOR: {
     if (Record.size() < 3)
       return error("Invalid record");
@@ -1325,6 +1342,20 @@
     NextMetadataNo++;
     break;
   }
+  case bitc::METADATA_STRING_TYPE: {
+    if (Record.size() != 8)
+      return error("Invalid record");
+
+    IsDistinct = Record[0];
+    MetadataList.assignValue(
+        GET_OR_DISTINCT(DIStringType,
+                        (Context, Record[1], getMDString(Record[2]),
+                         getMDOrNull(Record[3]), getMDOrNull(Record[4]),
+                         Record[5], Record[6], Record[7])),
+        NextMetadataNo);
+    NextMetadataNo++;
+    break;
+  }
   case bitc::METADATA_DERIVED_TYPE: {
     if (Record.size() < 12 || Record.size() > 13)
       return error("Invalid record");
@@ -1421,6 +1452,38 @@
     NextMetadataNo++;
     break;
   }
+  case bitc::METADATA_FORTRAN_ARRAY_TYPE: {
+    if (Record.size() != 12)
+      return error("Invalid record");
+
+    // If we have a UUID and this is not a forward declaration, lookup the
+    // mapping.
+    IsDistinct = Record[0] & 0x1;
+    unsigned Tag = Record[1];
+    MDString *Name = getMDString(Record[2]);
+    Metadata *File = getMDOrNull(Record[3]);
+    unsigned Line = Record[4];
+    Metadata *Scope = getDITypeRefOrNull(Record[5]);
+    Metadata *BaseType = nullptr;
+    uint64_t SizeInBits = Record[7];
+    if (Record[8] > (uint64_t)std::numeric_limits<uint32_t>::max())
+      return error("Alignment value is too large");
+    uint32_t AlignInBits = Record[8];
+    uint64_t OffsetInBits = 0;
+    DINode::DIFlags Flags = static_cast<DINode::DIFlags>(Record[10]);
+    Metadata *Elements = nullptr;
+    BaseType = getDITypeRefOrNull(Record[6]);
+    OffsetInBits = Record[9];
+    Elements = getMDOrNull(Record[11]);
+    DIFortranArrayType *CT =
+      GET_OR_DISTINCT(DIFortranArrayType,
+                      (Context, Tag, Name, File, Line, Scope, BaseType,
+                       SizeInBits, AlignInBits, OffsetInBits, Flags,
+                       Elements));
+    MetadataList.assignValue(CT, NextMetadataNo);
+    NextMetadataNo++;
+    break;
+  }
   case bitc::METADATA_SUBROUTINE_TYPE: {
     if (Record.size() < 3 || Record.size() > 4)
       return error("Invalid record");
--- a/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp	2021-02-18 22:01:02.003290809 +0100
+++ b/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp	2021-02-18 22:01:32.535553686 +0100
@@ -296,14 +296,22 @@
                           SmallVectorImpl<uint64_t> &Record, unsigned &Abbrev);
   void writeDISubrange(const DISubrange *N, SmallVectorImpl<uint64_t> &Record,
                        unsigned Abbrev);
+  void writeDIFortranSubrange(const DIFortranSubrange *N,
+                              SmallVectorImpl<uint64_t> &Record,
+                              unsigned Abbrev);
   void writeDIEnumerator(const DIEnumerator *N,
                          SmallVectorImpl<uint64_t> &Record, unsigned Abbrev);
   void writeDIBasicType(const DIBasicType *N, SmallVectorImpl<uint64_t> &Record,
                         unsigned Abbrev);
+  void writeDIStringType(const DIStringType *N,
+                         SmallVectorImpl<uint64_t> &Record, unsigned Abbrev);
   void writeDIDerivedType(const DIDerivedType *N,
                           SmallVectorImpl<uint64_t> &Record, unsigned Abbrev);
   void writeDICompositeType(const DICompositeType *N,
                             SmallVectorImpl<uint64_t> &Record, unsigned Abbrev);
+  void writeDIFortranArrayType(const DIFortranArrayType *N,
+                               SmallVectorImpl<uint64_t> &Record,
+                               unsigned Abbrev);
   void writeDISubroutineType(const DISubroutineType *N,
                              SmallVectorImpl<uint64_t> &Record,
                              unsigned Abbrev);
@@ -1553,6 +1561,22 @@
     emitSignedInt64(Vals, RawData[i]);
 }
 
+void ModuleBitcodeWriter::writeDIFortranSubrange(
+    const DIFortranSubrange *N, SmallVectorImpl<uint64_t> &Record,
+    unsigned Abbrev) {
+  Record.push_back(N->isDistinct());
+  Record.push_back(N->getCLowerBound());
+  Record.push_back(N->getCUpperBound());
+  Record.push_back(N->noUpperBound());
+  Record.push_back(VE.getMetadataOrNullID(N->getLowerBound()));
+  Record.push_back(VE.getMetadataOrNullID(N->getLowerBoundExp()));
+  Record.push_back(VE.getMetadataOrNullID(N->getUpperBound()));
+  Record.push_back(VE.getMetadataOrNullID(N->getUpperBoundExp()));
+
+  Stream.EmitRecord(bitc::METADATA_FORTRAN_SUBRANGE, Record, Abbrev);
+  Record.clear();
+}
+
 void ModuleBitcodeWriter::writeDIEnumerator(const DIEnumerator *N,
                                             SmallVectorImpl<uint64_t> &Record,
                                             unsigned Abbrev) {
@@ -1581,6 +1605,22 @@
   Record.clear();
 }
 
+void ModuleBitcodeWriter::writeDIStringType(const DIStringType *N,
+                                           SmallVectorImpl<uint64_t> &Record,
+                                           unsigned Abbrev) {
+  Record.push_back(N->isDistinct());
+  Record.push_back(N->getTag());
+  Record.push_back(VE.getMetadataOrNullID(N->getRawName()));
+  Record.push_back(VE.getMetadataOrNullID(N->getStringLength()));
+  Record.push_back(VE.getMetadataOrNullID(N->getStringLengthExp()));
+  Record.push_back(N->getSizeInBits());
+  Record.push_back(N->getAlignInBits());
+  Record.push_back(N->getEncoding());
+
+  Stream.EmitRecord(bitc::METADATA_STRING_TYPE, Record, Abbrev);
+  Record.clear();
+}
+
 void ModuleBitcodeWriter::writeDIDerivedType(const DIDerivedType *N,
                                              SmallVectorImpl<uint64_t> &Record,
                                              unsigned Abbrev) {
@@ -1635,6 +1675,26 @@
   Record.clear();
 }
 
+void ModuleBitcodeWriter::writeDIFortranArrayType(
+    const DIFortranArrayType *N, SmallVectorImpl<uint64_t> &Record,
+    unsigned Abbrev) {
+  Record.push_back(N->isDistinct());
+  Record.push_back(N->getTag());
+  Record.push_back(VE.getMetadataOrNullID(N->getRawName()));
+  Record.push_back(VE.getMetadataOrNullID(N->getFile()));
+  Record.push_back(N->getLine());
+  Record.push_back(VE.getMetadataOrNullID(N->getScope()));
+  Record.push_back(VE.getMetadataOrNullID(N->getBaseType()));
+  Record.push_back(N->getSizeInBits());
+  Record.push_back(N->getAlignInBits());
+  Record.push_back(N->getOffsetInBits());
+  Record.push_back(N->getFlags());
+  Record.push_back(VE.getMetadataOrNullID(N->getElements().get()));
+
+  Stream.EmitRecord(bitc::METADATA_FORTRAN_ARRAY_TYPE, Record, Abbrev);
+  Record.clear();
+}
+
 void ModuleBitcodeWriter::writeDISubroutineType(
     const DISubroutineType *N, SmallVectorImpl<uint64_t> &Record,
     unsigned Abbrev) {
--- a/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h	2021-02-18 22:01:32.535553686 +0100
@@ -178,6 +178,9 @@
                 DebugLocStream::ListBuilder &List,
                 const DIBasicType *BT,
                 DwarfCompileUnit &TheCU);
+
+  void finalize(const AsmPrinter &AP, DebugLocStream::ListBuilder &List,
+                const DIStringType *ST, DwarfCompileUnit &TheCU);
 };
 
 /// Compare two DbgValueLocs for equality.
--- a/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.cpp	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.cpp	2021-02-18 22:01:32.535553686 +0100
@@ -37,7 +37,10 @@
          "Popped off more entries than are in the list");
 }
 
-DebugLocStream::ListBuilder::~ListBuilder() {
+void DebugLocStream::ListBuilder::finalize() {
+  if (Finalized)
+    return;
+  Finalized = true;
   if (!Locs.finalizeList(Asm))
     return;
   V.initializeDbgValue(&MI);
--- a/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h	2021-02-18 22:01:02.011290878 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h	2021-02-18 22:01:32.535553686 +0100
@@ -160,22 +160,25 @@
   const MachineInstr &MI;
   size_t ListIndex;
   Optional<uint8_t> TagOffset;
+  bool Finalized;
 
 public:
   ListBuilder(DebugLocStream &Locs, DwarfCompileUnit &CU, AsmPrinter &Asm,
               DbgVariable &V, const MachineInstr &MI)
       : Locs(Locs), Asm(Asm), V(V), MI(MI), ListIndex(Locs.startList(&CU)),
-        TagOffset(None) {}
+        TagOffset(None), Finalized(false) {}
 
   void setTagOffset(uint8_t TO) {
     TagOffset = TO;
   }
 
+  void finalize();
+
   /// Finalize the list.
   ///
   /// If the list is empty, delete it.  Otherwise, finalize it by creating a
   /// temp symbol in \a Asm and setting up the \a DbgVariable.
-  ~ListBuilder();
+  ~ListBuilder() { finalize(); }
 
   DebugLocStream &getLocs() { return Locs; }
 };
--- a/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp	2021-02-18 22:02:19.186955386 +0100
@@ -155,7 +155,8 @@
   } else {
     DeclContext = GV->getScope();
     // Add name and type.
-    addString(*VariableDIE, dwarf::DW_AT_name, GV->getDisplayName());
+    if (!GV->getDisplayName().empty())
+      addString(*VariableDIE, dwarf::DW_AT_name, GV->getDisplayName());
     if (GTy)
       addType(*VariableDIE, GTy);
 
@@ -186,7 +190,12 @@
 }
 
 void DwarfCompileUnit::addLocationAttribute(
-    DIE *VariableDIE, const DIGlobalVariable *GV, ArrayRef<GlobalExpr> GlobalExprs) {
+  DIE *VariableDIE, const DIGlobalVariable *GV, ArrayRef<GlobalExpr> GlobalExprs) {
+  addLocationBlock(VariableDIE, dwarf::DW_AT_location, GV, GlobalExprs);
+}
+
+void DwarfCompileUnit::addLocationBlock(DIE *VariableDIE,
+  dwarf::Attribute Attribute, const DIGlobalVariable *GV, ArrayRef<GlobalExpr> GlobalExprs) {
   bool addToAccelTable = false;
   DIELoc *Loc = nullptr;
   Optional<unsigned> NVPTXAddressSpace;
@@ -295,7 +304,7 @@
             NVPTXAddressSpace ? *NVPTXAddressSpace : NVPTX_ADDR_global_space);
   }
   if (Loc)
-    addBlock(*VariableDIE, dwarf::DW_AT_location, DwarfExpr->finalize());
+    addBlock(*VariableDIE, Attribute, DwarfExpr->finalize());
 
   if (DD->useAllLinkageNames())
     addLinkageName(*VariableDIE, GV->getLinkageName());
@@ -311,6 +320,13 @@
   }
 }
 
+ArrayRef<DwarfCompileUnit::GlobalExpr>
+DwarfCompileUnit::findGlobalExprList(DIGlobalVariable *GV) {
+  if (globalVarMap)
+    return (*globalVarMap)[GV];
+  return SmallVector<GlobalExpr, 1>();
+}
+
 DIE *DwarfCompileUnit::getOrCreateCommonBlock(
     const DICommonBlock *CB, ArrayRef<GlobalExpr> GlobalExprs) {
   // Construct the context before querying for the existence of the DIE in case
@@ -687,21 +703,28 @@
   }
 
   // Add variable address.
+  constructDieLocation(*VariableDie, dwarf::DW_AT_location, DV);
+  return VariableDie;
+}
 
-  unsigned Offset = DV.getDebugLocListIndex();
-  if (Offset != ~0U) {
-    addLocationList(*VariableDie, dwarf::DW_AT_location, Offset);
-    auto TagOffset = DV.getDebugLocListTagOffset();
-    if (TagOffset)
-      addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,
-              *TagOffset);
-    return VariableDie;
+void DwarfCompileUnit::constructDieLocation(
+    DIE &Die, dwarf::Attribute Attribute, const DbgVariable &DV) {
+  if (Attribute == dwarf::DW_AT_location) {
+    unsigned Offset = DV.getDebugLocListIndex();
+    if (Offset != ~0U) {
+      addLocationList(Die, Attribute, Offset);
+      auto TagOffset = DV.getDebugLocListTagOffset();
+      if (TagOffset)
+        addUInt(Die, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,
+                *TagOffset);
+      return;
+    }
   }
 
   // Check if variable has a single location description.
   if (auto *DVal = DV.getValueLoc()) {
     if (DVal->isLocation())
-      addVariableAddress(DV, *VariableDie, DVal->getLoc());
+      addVariableAddress(DV, Die, DVal->getLoc());
     else if (DVal->isInt()) {
       auto *Expr = DV.getSingleExpression();
       if (Expr && Expr->getNumElements()) {
@@ -711,24 +734,23 @@
         DwarfExpr.addFragmentOffset(Expr);
         DwarfExpr.addUnsignedConstant(DVal->getInt());
         DwarfExpr.addExpression(Expr);
-        addBlock(*VariableDie, dwarf::DW_AT_location, DwarfExpr.finalize());
+        addBlock(Die, dwarf::DW_AT_location, DwarfExpr.finalize());
         if (DwarfExpr.TagOffset)
-          addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset,
+          addUInt(Die, dwarf::DW_AT_LLVM_tag_offset,
                   dwarf::DW_FORM_data1, *DwarfExpr.TagOffset);
-
       } else
-        addConstantValue(*VariableDie, DVal->getInt(), DV.getType());
+        addConstantValue(Die, DVal->getInt(), DV.getType());
     } else if (DVal->isConstantFP()) {
-      addConstantFPValue(*VariableDie, DVal->getConstantFP());
+      addConstantFPValue(Die, DVal->getConstantFP());
     } else if (DVal->isConstantInt()) {
-      addConstantValue(*VariableDie, DVal->getConstantInt(), DV.getType());
+      addConstantValue(Die, DVal->getConstantInt(), DV.getType());
     }
-    return VariableDie;
+    return;
   }
 
   // .. else use frame index.
   if (!DV.hasFrameIndexExprs())
-    return VariableDie;
+    return;
 
   Optional<unsigned> NVPTXAddressSpace;
   DIELoc *Loc = new (DIEValueAllocator) DIELoc;
@@ -773,15 +795,52 @@
     // cuda-gdb requires DW_AT_address_class for all variables to be able to
     // correctly interpret address space of the variable address.
     const unsigned NVPTX_ADDR_local_space = 6;
-    addUInt(*VariableDie, dwarf::DW_AT_address_class, dwarf::DW_FORM_data1,
+    addUInt(Die, dwarf::DW_AT_address_class, dwarf::DW_FORM_data1,
             NVPTXAddressSpace ? *NVPTXAddressSpace : NVPTX_ADDR_local_space);
   }
-  addBlock(*VariableDie, dwarf::DW_AT_location, DwarfExpr.finalize());
+  addBlock(Die, dwarf::DW_AT_location, DwarfExpr.finalize());
   if (DwarfExpr.TagOffset)
-    addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,
+    addUInt(Die, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,
             *DwarfExpr.TagOffset);
 
-  return VariableDie;
+  return;
+}
+
+void DwarfCompileUnit::constructDieLocationAddExpr(
+    DIE &Die, dwarf::Attribute Attribute, const DbgVariable &DV,
+    DIExpression *SubExpr) {
+  if (Attribute == dwarf::DW_AT_location)
+    return; // clients like gdb don't handle location lists correctly
+  if (DV.getValueLoc())
+    return; // temp should not have a DBG_VALUE instruction
+  if (!DV.hasFrameIndexExprs())
+    return; // but it should have a frame index expression
+
+  DIELoc *Loc = new (DIEValueAllocator) DIELoc;
+  DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);
+  for (auto &Fragment : DV.getFrameIndexExprs()) {
+    Register FrameReg = 0;
+    const DIExpression *Expr = Fragment.Expr;
+    const TargetFrameLowering *TFI = Asm->MF->getSubtarget().getFrameLowering();
+    int Offset = TFI->getFrameIndexReference(*Asm->MF, Fragment.FI, FrameReg);
+    DwarfExpr.addFragmentOffset(Expr);
+    SmallVector<uint64_t, 8> Ops;
+    Ops.push_back(dwarf::DW_OP_plus_uconst);
+    Ops.push_back(Offset);
+    Ops.append(Expr->elements_begin(), Expr->elements_end());
+    if (SubExpr) {
+      for (unsigned SEOp : SubExpr->getElements())
+        Ops.push_back(SEOp);
+    } else {
+      Ops.push_back(dwarf::DW_OP_deref);
+    }
+    DIExpressionCursor Cursor(Ops);
+    DwarfExpr.setMemoryLocationKind();
+    DwarfExpr.addMachineRegExpression(
+        *Asm->MF->getSubtarget().getRegisterInfo(), Cursor, FrameReg);
+    DwarfExpr.addExpression(std::move(Cursor));
+  }
+  addBlock(Die, Attribute, DwarfExpr.finalize());
 }
 
 DIE *DwarfCompileUnit::constructVariableDIE(DbgVariable &DV,
--- a/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h	2021-02-18 22:01:32.536553695 +0100
@@ -142,6 +142,15 @@
 
   std::vector<BaseTypeRef> ExprRefedBaseTypes;
 
+private:
+  DenseMap<DIGlobalVariable *, SmallVector<GlobalExpr, 1>> *globalVarMap;
+public:
+  void setGlobalVarMap(
+      DenseMap<DIGlobalVariable *, SmallVector<GlobalExpr, 1>> *p = nullptr) {
+    globalVarMap = p;
+  }
+  ArrayRef<GlobalExpr> findGlobalExprList(DIGlobalVariable *GV);
+
   /// Get or create global variable DIE.
   DIE *
   getOrCreateGlobalVariableDIE(const DIGlobalVariable *GV,
@@ -152,6 +161,9 @@
 
   void addLocationAttribute(DIE *ToDIE, const DIGlobalVariable *GV,
                             ArrayRef<GlobalExpr> GlobalExprs);
+  void addLocationBlock(DIE *ToDIE, dwarf::Attribute Attr,
+                        const DIGlobalVariable *GV,
+                        ArrayRef<GlobalExpr> GlobalExprs);
 
   /// addLabelAddress - Add a dwarf label attribute data and value using
   /// either DW_FORM_addr or DW_FORM_GNU_addr_index.
@@ -360,6 +372,12 @@
   uint64_t getDWOId() const { return DWOId; }
   void setDWOId(uint64_t DwoId) { DWOId = DwoId; }
 
+  void constructDieLocation(DIE &Die, dwarf::Attribute Attribute,
+                            const DbgVariable &DV);
+  void constructDieLocationAddExpr(DIE &Die, dwarf::Attribute Attribute,
+                                   const DbgVariable &DV,
+                                   DIExpression *SubExpr);
+
   bool hasDwarfPubSections() const;
 
   void addBaseTypeRef(DIEValueList &Die, int64_t Idx);
--- a/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp	2021-02-18 22:01:02.013290895 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp	2021-02-18 22:01:32.536553695 +0100
@@ -1203,11 +1203,13 @@
         GVMapEntry.push_back({nullptr, Expr});
     }
     DenseSet<DIGlobalVariable *> Processed;
+    CU.setGlobalVarMap(&GVMap);
     for (auto *GVE : CUNode->getGlobalVariables()) {
       DIGlobalVariable *GV = GVE->getVariable();
       if (Processed.insert(GV).second)
         CU.getOrCreateGlobalVariableDIE(GV, sortGlobalExprs(GVMap[GV]));
     }
+    CU.setGlobalVarMap();
 
     for (auto *Ty : CUNode->getEnumTypes()) {
       // The enum types array by design contains pointers to
@@ -1489,6 +1491,56 @@
     CU.createAbstractEntity(Node, Scope);
 }
 
+DIE *DwarfDebug::getSubrangeDie(const DIFortranSubrange *SR) const {
+  auto I = SubrangeDieMap.find(SR);
+  return (I == SubrangeDieMap.end()) ? nullptr : I->second;
+}
+
+void DwarfDebug::constructSubrangeDie(const DIFortranArrayType *AT,
+                                      DbgVariable &DV,
+                                      DwarfCompileUnit &TheCU) {
+  const DIFortranSubrange *WFS = nullptr;
+  DIExpression *WUEx = nullptr;
+  DIExpression *WLEx = nullptr;
+  const DIVariable *DI = DV.getVariable();
+  DINodeArray Elements = AT->getElements();
+
+  for (unsigned i = 0, N = Elements.size(); i < N; ++i) {
+    DINode *Element = cast<DINode>(Elements[i]);
+    if (const DIFortranSubrange *FS = dyn_cast<DIFortranSubrange>(Element)) {
+      if (DIVariable *UBV = FS->getUpperBound())
+        if (UBV == DI) {
+          WFS = FS;
+          WUEx = FS->getUpperBoundExp();
+        }
+      if (DIVariable *LBV = FS->getLowerBound())
+        if (LBV == DI) {
+          WFS = FS;
+          WLEx = FS->getLowerBoundExp();
+        }
+    }
+    if (WFS) {
+      DIE *Die;
+      auto I = SubrangeDieMap.find(WFS);
+      if (I == SubrangeDieMap.end()) {
+        Die = DIE::get(DIEValueAllocator, dwarf::DW_TAG_subrange_type);
+        SubrangeDieMap[WFS] = Die;
+      } else {
+        Die = I->second;
+      }
+
+      assert(Die);
+      if (WLEx)
+        TheCU.constructDieLocationAddExpr(
+            *Die, dwarf::DW_AT_lower_bound, DV, WLEx);
+      if (WUEx)
+        TheCU.constructDieLocationAddExpr(
+            *Die, dwarf::DW_AT_upper_bound, DV, WUEx);
+      WFS = nullptr;
+    }
+  }
+}
+
 // Collect variable information from side table maintained by MF.
 void DwarfDebug::collectVariableInfoFromMFTable(
     DwarfCompileUnit &TheCU, DenseSet<InlinedEntity> &Processed) {
@@ -1517,6 +1569,11 @@
     RegVar->initializeMMI(VI.Expr, VI.Slot);
     LLVM_DEBUG(dbgs() << "Created DbgVariable for " << VI.Var->getName()
                       << "\n");
+    if (VariableInDependentType.count(VI.Var)) {
+      const DIType *DT = VariableInDependentType[VI.Var];
+      if (const DIFortranArrayType *AT = dyn_cast<DIFortranArrayType>(DT))
+        constructSubrangeDie(AT, *RegVar.get(), TheCU);
+    }
     if (DbgVariable *DbgVar = MFVars.lookup(Var))
       DbgVar->addMMIEntry(*RegVar);
     else if (InfoHolder.addScopeVariable(Scope, RegVar.get())) {
@@ -1773,10 +1830,38 @@
   return ConcreteEntities.back().get();
 }
 
+void DwarfDebug::populateDependentTypeMap() {
+  for (const auto &I : DbgValues) {
+    InlinedEntity IV = I.first;
+    if (I.second.empty())
+      continue;
+    if (const DIVariable *DIV = dyn_cast<DIVariable>(IV.first)) {
+      if (const DIStringType *ST = dyn_cast<DIStringType>(
+              static_cast<const Metadata *>(DIV->getType())))
+        if (const DIVariable *LV = ST->getStringLength())
+          VariableInDependentType[LV] = ST;
+
+      if (const DIFortranArrayType *AT = dyn_cast<DIFortranArrayType>(
+              static_cast<const Metadata *>(DIV->getType()))) {
+        for (const DINode *S : AT->getElements()) {
+          if (const DIFortranSubrange *FS = dyn_cast<DIFortranSubrange>(S)) {
+            if (const DIVariable *LBV = FS->getLowerBound())
+              VariableInDependentType[LBV] = AT;
+            if (const DIVariable *UBV = FS->getUpperBound())
+              VariableInDependentType[UBV] = AT;
+          }
+        }
+      }
+    }
+  }
+}
+
 // Find variables for each lexical scope.
 void DwarfDebug::collectEntityInfo(DwarfCompileUnit &TheCU,
                                    const DISubprogram *SP,
                                    DenseSet<InlinedEntity> &Processed) {
+  clearDependentTracking();
+  populateDependentTypeMap();
   // Grab the variable info that was squirreled away in the MMI side-table.
   collectVariableInfoFromMFTable(TheCU, Processed);
 
@@ -1798,7 +1883,9 @@
       continue;
 
     LexicalScope *Scope = nullptr;
-    const DILocalVariable *LocalVar = cast<DILocalVariable>(IV.first);
+    const DILocalVariable *LocalVar = dyn_cast<DILocalVariable>(IV.first);
+    if (!LocalVar)
+      continue;
     if (const DILocation *IA = IV.second)
       Scope = LScopes.findInlinedScope(LocalVar->getScope(), IA);
     else
@@ -1859,6 +1946,22 @@
     // Finalize the entry by lowering it into a DWARF bytestream.
     for (auto &Entry : Entries)
       Entry.finalize(*Asm, List, BT, TheCU);
+    List.finalize();
+
+    if (VariableInDependentType.count(LocalVar)) {
+      const DIType *DT = VariableInDependentType[LocalVar];
+      if (const DIStringType *ST = dyn_cast<DIStringType>(DT)) {
+        unsigned Offset;
+        DbgVariable TVar = {LocalVar, IV.second};
+        DebugLocStream::ListBuilder LB(DebugLocs, TheCU, *Asm, TVar, *MInsn);
+        for (auto &Entry : Entries)
+          Entry.finalize(*Asm, LB, ST, TheCU);
+        LB.finalize();
+        Offset = TVar.getDebugLocListIndex();
+        if (Offset != ~0u)
+          addStringTypeLoc(ST, Offset);
+      }
+    }
   }
 
   // For each InlinedEntity collected from DBG_LABEL instructions, convert to
@@ -2549,6 +2652,33 @@
     List.setTagOffset(*DwarfExpr.TagOffset);
 }
 
+inline static DbgValueLoc mkDbgValueLoc(const DIExpression *expr,
+                                        DbgValueLoc &value) {
+  if (value.isInt())
+    return DbgValueLoc(expr, value.getInt());
+  if (value.isLocation())
+    return DbgValueLoc(expr, value.getLoc());
+  if (value.isConstantInt())
+    return DbgValueLoc(expr, value.getConstantInt());
+  assert(value.isConstantFP());
+  return DbgValueLoc(expr, value.getConstantFP());
+}
+
+void DebugLocEntry::finalize(const AsmPrinter &AP,
+                             DebugLocStream::ListBuilder &List,
+                             const DIStringType *ST,
+                             DwarfCompileUnit &TheCU) {
+  DebugLocStream::EntryBuilder Entry(List, Begin, End);
+  BufferByteStreamer Streamer = Entry.getStreamer();
+  DebugLocDwarfExpression DwarfExpr(AP.getDwarfVersion(), Streamer, TheCU);
+  DbgValueLoc &Value = Values[0];
+  assert(!Value.isFragment());
+  assert(Values.size() == 1 && "only fragments may have >1 value");
+  Value = mkDbgValueLoc(ST->getStringLengthExp(), Value);
+  DwarfDebug::emitDebugLocValue(AP, nullptr, Value, DwarfExpr);
+  DwarfExpr.finalize();
+}
+
 void DwarfDebug::emitDebugLocEntryLocation(const DebugLocStream::Entry &Entry,
                                            const DwarfCompileUnit *CU) {
   // Emit the size.
--- a/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h	2021-02-18 22:01:32.536553695 +0100
@@ -283,6 +283,8 @@
   DwarfCompileUnit *CU;
 };
 
+class DummyDwarfExpression;
+
 /// The kind of accelerator tables we should emit.
 enum class AccelTableKind {
   Default, ///< Platform default.
@@ -409,6 +411,14 @@
   bool SingleCU;
   bool IsDarwin;
 
+  /// Map for tracking Fortran deferred CHARACTER lengths
+  DenseMap<const DIStringType*, unsigned> StringTypeLocMap;
+
+  /// Map for tracking Fortran assumed shape array descriptors
+  DenseMap<const DIFortranSubrange*, DIE*> SubrangeDieMap;
+
+  DenseMap<const DIVariable*,const DIType*> VariableInDependentType;
+
   AddressPool AddrPool;
 
   /// Accelerator tables.
@@ -604,6 +614,12 @@
   /// Emit the reference to the section.
   void emitSectionReference(const DwarfCompileUnit &CU);
 
+  /// Populate dependent type variable map
+  void populateDependentTypeMap();
+
+  /// Clear dependent type tracking map
+  void clearDependentTracking() { VariableInDependentType.clear(); }
+
 protected:
   /// Gather pre-function debug information.
   void beginFunctionImpl(const MachineFunction *MF) override;
@@ -768,6 +784,21 @@
     return CUDieMap.lookup(Die);
   }
 
+  unsigned getStringTypeLoc(const DIStringType *ST) const {
+    auto I = StringTypeLocMap.find(ST);
+    return I != StringTypeLocMap.end() ? I->second : 0;
+  }
+
+  void addStringTypeLoc(const DIStringType *ST, unsigned Loc) {
+    assert(ST);
+    if (Loc)
+      StringTypeLocMap[ST] = Loc;
+  }
+
+  DIE *getSubrangeDie(const DIFortranSubrange *SR) const;
+  void constructSubrangeDie(const DIFortranArrayType *AT,
+                            DbgVariable &DV, DwarfCompileUnit &TheCU);
+
   /// \defgroup DebuggerTuning Predicates to tune DWARF for a given debugger.
   ///
   /// Returns whether we are "tuning" for a given debugger.
--- a/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp	2021-02-18 22:01:32.537553704 +0100
@@ -654,8 +654,12 @@
 
   if (auto *BT = dyn_cast<DIBasicType>(Ty))
     constructTypeDIE(TyDIE, BT);
+  else if (auto *ST = dyn_cast<DIStringType>(Ty))
+    constructTypeDIE(TyDIE, ST);
   else if (auto *STy = dyn_cast<DISubroutineType>(Ty))
     constructTypeDIE(TyDIE, STy);
+  else if (auto *ATy = dyn_cast<DIFortranArrayType>(Ty))
+    constructArrayTypeDIE(TyDIE, ATy);
   else if (auto *CTy = dyn_cast<DICompositeType>(Ty)) {
     if (DD->generateTypeUnits() && !Ty->isForwardDecl() &&
         (Ty->getRawName() || CTy->getRawIdentifier())) {
@@ -772,8 +776,9 @@
   if (BTy->getTag() == dwarf::DW_TAG_unspecified_type)
     return;
 
-  addUInt(Buffer, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1,
-          BTy->getEncoding());
+  if (BTy->getTag() != dwarf::DW_TAG_string_type)
+    addUInt(Buffer, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1,
+            BTy->getEncoding());
 
   uint64_t Size = BTy->getSizeInBits() >> 3;
   addUInt(Buffer, dwarf::DW_AT_byte_size, None, Size);
@@ -784,6 +789,31 @@
     addUInt(Buffer, dwarf::DW_AT_endianity, None, dwarf::DW_END_little);
 }
 
+void DwarfUnit::constructTypeDIE(DIE &Buffer, const DIStringType *STy) {
+  // Get core information.
+  StringRef Name = STy->getName();
+  // Add name if not anonymous or intermediate type.
+  if (!Name.empty())
+    addString(Buffer, dwarf::DW_AT_name, Name);
+
+  if (unsigned LLI = DD->getStringTypeLoc(STy)) {
+    // DW_TAG_string_type has a DW_AT_string_length location
+    dwarf::Form Form = (DD->getDwarfVersion() >= 4)
+      ? dwarf::DW_FORM_sec_offset : dwarf::DW_FORM_data4;
+    Buffer.addValue(DIEValueAllocator, dwarf::DW_AT_string_length, Form,
+                    DIELocList(LLI));
+  }
+
+  uint64_t Size = STy->getSizeInBits() >> 3;
+  addUInt(Buffer, dwarf::DW_AT_byte_size, None, Size);
+
+  if (STy->getEncoding()) {
+    // for eventual unicode support
+    addUInt(Buffer, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1,
+            STy->getEncoding());
+  }
+}
+
 void DwarfUnit::constructTypeDIE(DIE &Buffer, const DIDerivedType *DTy) {
   // Get core information.
   StringRef Name = DTy->getName();
@@ -1385,6 +1415,48 @@
   addBoundTypeEntry(dwarf::DW_AT_byte_stride, SR->getStride());
 }
 
+void DwarfUnit::constructFortranSubrangeDIE(DIE &Buffer,
+                                            const DIFortranSubrange *SR) {
+  DIE *IndexTy = getIndexTyDie();
+  DIE *Die = DD->getSubrangeDie(SR);
+  if ((!Die) || Die->getParent())
+    Die = DIE::get(DIEValueAllocator, dwarf::DW_TAG_subrange_type);
+  DIE &DW_Subrange = Buffer.addChild(Die);
+  addDIEEntry(DW_Subrange, dwarf::DW_AT_type, *IndexTy);
+
+  if (DIVariable *GV = SR->getLowerBound()) {
+    if (DIGlobalVariable *GVar = dyn_cast<DIGlobalVariable>(GV)) {
+      ArrayRef<DwarfCompileUnit::GlobalExpr> GEL = getCU().findGlobalExprList(GVar);
+      if (GEL.size() >= 1) {
+        DwarfCompileUnit::GlobalExpr GE = {GEL.front().Var, SR->getLowerBoundExp()};
+        SmallVector<DwarfCompileUnit::GlobalExpr, 1> GEV;
+        GEV.emplace_back(GE);
+        getCU().addLocationBlock(Die, dwarf::DW_AT_lower_bound, GVar, GEV);
+      }
+    }
+  } else {
+    int64_t BVC = SR->getCLowerBound();
+    addSInt(DW_Subrange, dwarf::DW_AT_lower_bound, dwarf::DW_FORM_sdata, BVC);
+  }
+
+  if (SR->noUpperBound()) {
+    // do nothing
+  } else if (DIVariable *GV = SR->getUpperBound()) {
+    if (DIGlobalVariable *GVar = dyn_cast<DIGlobalVariable>(GV)) {
+      ArrayRef<DwarfCompileUnit::GlobalExpr> GEL = getCU().findGlobalExprList(GVar);
+      if (GEL.size() >= 1) {
+        DwarfCompileUnit::GlobalExpr GE = {GEL.front().Var, SR->getUpperBoundExp()};
+        SmallVector<DwarfCompileUnit::GlobalExpr, 1> GEV;
+        GEV.emplace_back(GE);
+        getCU().addLocationBlock(Die, dwarf::DW_AT_upper_bound, GVar, GEV);
+      }
+    }
+  } else {
+    int64_t BVC = SR->getCUpperBound();
+    addSInt(DW_Subrange, dwarf::DW_AT_upper_bound, dwarf::DW_FORM_sdata, BVC);
+  }
+}
+
 DIE *DwarfUnit::getIndexTyDie() {
   if (IndexTyDie)
     return IndexTyDie;
@@ -1465,6 +1537,20 @@
   }
 }
 
+void DwarfUnit::constructArrayTypeDIE(DIE &Buffer,
+                                      const DIFortranArrayType *ATy) {
+  // Emit the element type.
+  addType(Buffer, ATy->getBaseType());
+
+  // Add subranges to array type.
+  DINodeArray Elements = ATy->getElements();
+  for (unsigned i = 0, N = Elements.size(); i < N; ++i) {
+    DINode *Element = cast<DINode>(Elements[i]);
+    if (const DIFortranSubrange *FS = dyn_cast<DIFortranSubrange>(Element))
+      constructFortranSubrangeDIE(Buffer, FS);
+  }
+}
+
 void DwarfUnit::constructEnumTypeDIE(DIE &Buffer, const DICompositeType *CTy) {
   const DIType *DTy = CTy->getBaseType();
   bool IsUnsigned = DTy && isUnsignedDIType(DD, DTy);
--- a/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h	2021-02-18 22:01:02.012290887 +0100
+++ b/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h	2021-02-18 22:01:32.537553704 +0100
@@ -306,10 +306,14 @@
 
 private:
   void constructTypeDIE(DIE &Buffer, const DIBasicType *BTy);
+  void constructTypeDIE(DIE &Buffer, const DIStringType *BTy);
+  void constructTypeDIE(DIE &Buffer, const DIFortranArrayType *ATy);
   void constructTypeDIE(DIE &Buffer, const DIDerivedType *DTy);
   void constructTypeDIE(DIE &Buffer, const DISubroutineType *CTy);
   void constructSubrangeDIE(DIE &Buffer, const DISubrange *SR, DIE *IndexTy);
+  void constructFortranSubrangeDIE(DIE &Buffer, const DIFortranSubrange *SR);
   void constructArrayTypeDIE(DIE &Buffer, const DICompositeType *CTy);
+  void constructArrayTypeDIE(DIE &Buffer, const DIFortranArrayType *ATy);
   void constructEnumTypeDIE(DIE &Buffer, const DICompositeType *CTy);
   DIE &constructMemberDIE(DIE &Buffer, const DIDerivedType *DT);
   void constructTemplateTypeParameterDIE(DIE &Buffer,
--- a/llvm/lib/IR/AsmWriter.cpp	2021-02-18 22:01:02.017290930 +0100
+++ b/llvm/lib/IR/AsmWriter.cpp	2021-02-18 22:01:32.537553704 +0100
@@ -1889,6 +1889,24 @@
   Out << ")";
 }
 
+static void writeDIFortranSubrange(raw_ostream &Out, const DIFortranSubrange *N,
+                                   TypePrinting *TypePrinter,
+                                   SlotTracker *Machine,
+                                   const Module *Context) {
+  Out << "!DIFortranSubrange(";
+  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);
+  Printer.printInt("constLowerBound", N->getCLowerBound(), false);
+  if (!N->noUpperBound())
+    Printer.printInt("constUpperBound", N->getCUpperBound(), false);
+  Printer.printMetadata("lowerBound", N->getRawLowerBound());
+  Printer.printMetadata("lowerBoundExpression",
+                        N->getRawLowerBoundExpression());
+  Printer.printMetadata("upperBound", N->getRawUpperBound());
+  Printer.printMetadata("upperBoundExpression",
+                        N->getRawUpperBoundExpression());
+  Out << ")";
+}
+
 static void writeDIEnumerator(raw_ostream &Out, const DIEnumerator *N,
                               TypePrinting *, SlotTracker *, const Module *) {
   Out << "!DIEnumerator(";
@@ -1916,6 +1934,23 @@
   Out << ")";
 }
 
+static void writeDIStringType(raw_ostream &Out, const DIStringType *N,
+                             TypePrinting *TypePrinter, SlotTracker *Machine,
+                              const Module *Context) {
+  Out << "!DIStringType(";
+  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);
+  if (N->getTag() != dwarf::DW_TAG_string_type)
+    Printer.printTag(N);
+  Printer.printString("name", N->getName());
+  Printer.printMetadata("stringLength", N->getRawStringLength());
+  Printer.printMetadata("stringLengthExpression", N->getRawStringLengthExp());
+  Printer.printInt("size", N->getSizeInBits());
+  Printer.printInt("align", N->getAlignInBits());
+  Printer.printDwarfEnum("encoding", N->getEncoding(),
+                         dwarf::AttributeEncodingString);
+  Out << ")";
+}
+
 static void writeDIDerivedType(raw_ostream &Out, const DIDerivedType *N,
                                TypePrinting *TypePrinter, SlotTracker *Machine,
                                const Module *Context) {
@@ -1965,6 +2000,24 @@
   Out << ")";
 }
 
+static void writeDIFortranArrayType(
+    raw_ostream &Out, const DIFortranArrayType *N, TypePrinting *TypePrinter,
+    SlotTracker *Machine, const Module *Context) {
+  Out << "!DIFortranArrayType(";
+  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);
+  Printer.printTag(N);
+  Printer.printString("name", N->getName());
+  Printer.printMetadata("scope", N->getRawScope());
+  Printer.printMetadata("file", N->getRawFile());
+  Printer.printInt("line", N->getLine());
+  Printer.printMetadata("baseType", N->getRawBaseType());
+  Printer.printInt("size", N->getSizeInBits());
+  Printer.printInt("align", N->getAlignInBits());
+  Printer.printInt("offset", N->getOffsetInBits());
+  Printer.printMetadata("elements", N->getRawElements());
+  Out << ")";
+}
+
 static void writeDISubroutineType(raw_ostream &Out, const DISubroutineType *N,
                                   TypePrinting *TypePrinter,
                                   SlotTracker *Machine, const Module *Context) {
--- a/llvm/lib/IR/DIBuilder.cpp	2021-02-18 22:01:02.018290938 +0100
+++ b/llvm/lib/IR/DIBuilder.cpp	2021-02-18 22:01:32.538553712 +0100
@@ -267,6 +267,12 @@
                           0, Encoding, Flags);
 }
 
+DIStringType *DIBuilder::createStringType(StringRef Name, uint64_t SizeInBits) {
+  assert(!Name.empty() && "Unable to create type without name");
+  return DIStringType::get(VMContext, dwarf::DW_TAG_string_type, Name,
+                           SizeInBits, 0);
+}
+
 DIDerivedType *DIBuilder::createQualifiedType(unsigned Tag, DIType *FromTy) {
   return DIDerivedType::get(VMContext, Tag, "", nullptr, 0, nullptr, FromTy, 0,
                             0, 0, None, DINode::FlagZero);
@@ -529,6 +535,15 @@
   return R;
 }
 
+DIFortranArrayType *DIBuilder::createFortranArrayType(
+    uint64_t Size, uint32_t AlignInBits, DIType *Ty, DINodeArray Subscripts) {
+  auto *R = DIFortranArrayType::get(VMContext, dwarf::DW_TAG_array_type, "",
+                                    nullptr, 0, nullptr, Ty, Size, AlignInBits,
+                                    0, DINode::FlagZero, Subscripts);
+  trackIfUnresolved(R);
+  return R;
+}
+
 DICompositeType *DIBuilder::createVectorType(uint64_t Size,
                                              uint32_t AlignInBits, DIType *Ty,
                                              DINodeArray Subscripts) {
@@ -643,6 +658,12 @@
   return DISubrange::get(VMContext, CountNode, LB, UB, Stride);
 }
 
+DIFortranSubrange *DIBuilder::getOrCreateFortranSubrange(
+    int64_t CLB, int64_t CUB, bool NUB, Metadata *LB, Metadata *LBE,
+    Metadata *UB, Metadata *UBE) {
+  return DIFortranSubrange::get(VMContext, CLB, CUB, NUB, LB, LBE, UB, UBE);
+}
+
 static void checkGlobalVariableScope(DIScope *Context) {
 #ifndef NDEBUG
   if (auto *CT =
--- a/llvm/lib/IR/DebugInfoMetadata.cpp	2021-02-18 22:01:02.016290921 +0100
+++ b/llvm/lib/IR/DebugInfoMetadata.cpp	2021-02-18 22:01:32.538553712 +0100
@@ -435,6 +435,15 @@
   return BoundType();
 }
 
+DIFortranSubrange *DIFortranSubrange::getImpl(
+    LLVMContext &Context, int64_t CLB, int64_t CUB, bool NUB, Metadata *LB,
+    Metadata *LBE, Metadata *UB, Metadata *UBE, StorageType Storage,
+    bool ShouldCreate) {
+  DEFINE_GETIMPL_LOOKUP(DIFortranSubrange, (CLB, CUB, NUB, LB, LBE, UB, UBE));
+  Metadata *Ops[] = {LB, LBE, UB, UBE};
+  DEFINE_GETIMPL_STORE(DIFortranSubrange, (CLB, CUB, NUB), Ops);
+}
+
 DIEnumerator *DIEnumerator::getImpl(LLVMContext &Context, const APInt &Value,
                                     bool IsUnsigned, MDString *Name,
                                     StorageType Storage, bool ShouldCreate) {
@@ -457,6 +466,21 @@
                       Flags), Ops);
 }
 
+DIStringType *DIStringType::getImpl(LLVMContext &Context, unsigned Tag,
+                                    MDString *Name, Metadata *StringLength,
+                                    Metadata *StringLengthExp,
+                                    uint64_t SizeInBits, uint32_t AlignInBits,
+                                    unsigned Encoding, StorageType Storage,
+                                    bool ShouldCreate) {
+  assert(isCanonical(Name) && "Expected canonical MDString");
+  DEFINE_GETIMPL_LOOKUP(DIStringType,
+                        (Tag, Name, StringLength, StringLengthExp, SizeInBits,
+                         AlignInBits, Encoding));
+  Metadata *Ops[] = {nullptr, nullptr, Name, StringLength, StringLengthExp};
+  DEFINE_GETIMPL_STORE(DIStringType, (Tag, SizeInBits, AlignInBits, Encoding),
+                       Ops);
+}
+
 Optional<DIBasicType::Signedness> DIBasicType::getSignedness() const {
   switch (getEncoding()) {
   case dwarf::DW_ATE_signed:
@@ -487,6 +511,22 @@
                       DWARFAddressSpace, Flags), Ops);
 }
 
+DIFortranArrayType *DIFortranArrayType::getImpl(
+    LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,
+    unsigned Line, Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,
+    uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,
+    Metadata *Elements, StorageType Storage, bool ShouldCreate) {
+  assert(isCanonical(Name) && "Expected canonical MDString");
+
+  // Keep this in sync with buildODRType.
+  DEFINE_GETIMPL_LOOKUP(
+      DIFortranArrayType, (Tag, Name, File, Line, Scope, BaseType, SizeInBits,
+                           AlignInBits, OffsetInBits, Flags, Elements));
+  Metadata *Ops[] = {File, Scope, Name, BaseType, Elements};
+  DEFINE_GETIMPL_STORE(DIFortranArrayType, (Tag, Line, SizeInBits, AlignInBits,
+                                            OffsetInBits, Flags), Ops);
+}
+
 DICompositeType *DICompositeType::getImpl(
     LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,
     unsigned Line, Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,
--- a/llvm/lib/IR/LLVMContextImpl.h	2021-02-18 22:01:02.018290938 +0100
+++ b/llvm/lib/IR/LLVMContextImpl.h	2021-02-18 22:01:32.539553720 +0100
@@ -366,6 +366,42 @@
   }
 };
 
+template <> struct MDNodeKeyImpl<DIFortranSubrange> {
+  int64_t CLBound;
+  int64_t CUBound;
+  bool NoUBound;
+  Metadata *LowerBound;
+  Metadata *LowerBoundExp;
+  Metadata *UpperBound;
+  Metadata *UpperBoundExp;
+
+  MDNodeKeyImpl(int64_t CLB, int64_t CUB, bool NUB, Metadata *LB, Metadata *LBE,
+                Metadata *UB, Metadata *UBE)
+      : CLBound(CLB), CUBound(CUB), NoUBound(NUB), LowerBound(LB),
+        LowerBoundExp(LBE), UpperBound(UB), UpperBoundExp(UBE) {}
+  MDNodeKeyImpl(const DIFortranSubrange *N)
+      : CLBound(N->getCLowerBound()), CUBound(N->getCUpperBound()),
+        NoUBound(N->noUpperBound()), LowerBound(N->getRawLowerBound()),
+        LowerBoundExp(N->getRawLowerBoundExpression()),
+        UpperBound(N->getRawUpperBound()),
+        UpperBoundExp(N->getRawUpperBoundExpression()) {}
+
+  bool isKeyOf(const DIFortranSubrange *RHS) const {
+    return CLBound == RHS->getCLowerBound() &&
+      CUBound == RHS->getCUpperBound() &&
+      NoUBound == RHS->noUpperBound() &&
+      LowerBound == RHS->getRawLowerBound() &&
+      LowerBoundExp == RHS->getRawLowerBoundExpression() &&
+      UpperBound == RHS->getRawUpperBound() &&
+      UpperBoundExp == RHS->getRawUpperBoundExpression();
+  }
+
+  unsigned getHashValue() const {
+    return hash_combine(CLBound, CUBound, NoUBound, UpperBound, UpperBoundExp,
+                        LowerBound, LowerBoundExp);
+  }
+};
+
 template <> struct MDNodeKeyImpl<DIEnumerator> {
   APInt Value;
   MDString *Name;
@@ -417,6 +453,39 @@
   }
 };
 
+template <> struct MDNodeKeyImpl<DIStringType> {
+  unsigned Tag;
+  MDString *Name;
+  Metadata *StringLength;
+  Metadata *StringLengthExp;
+  uint64_t SizeInBits;
+  uint32_t AlignInBits;
+  unsigned Encoding;
+
+  MDNodeKeyImpl(unsigned Tag, MDString *Name, Metadata *StringLength,
+                Metadata *StringLengthExp, uint64_t SizeInBits,
+                uint32_t AlignInBits, unsigned Encoding)
+      : Tag(Tag), Name(Name), StringLength(StringLength),
+        StringLengthExp(StringLengthExp), SizeInBits(SizeInBits),
+        AlignInBits(AlignInBits), Encoding(Encoding) {}
+  MDNodeKeyImpl(const DIStringType *N)
+      : Tag(N->getTag()), Name(N->getRawName()),
+        StringLength(N->getRawStringLength()),
+        StringLengthExp(N->getRawStringLengthExp()),
+        SizeInBits(N->getSizeInBits()),
+        AlignInBits(N->getAlignInBits()), Encoding(N->getEncoding()) {}
+
+  bool isKeyOf(const DIStringType *RHS) const {
+    return Tag == RHS->getTag() && Name == RHS->getRawName() &&
+           SizeInBits == RHS->getSizeInBits() &&
+           AlignInBits == RHS->getAlignInBits() &&
+           Encoding == RHS->getEncoding();
+  }
+  unsigned getHashValue() const {
+    return hash_combine(Tag, Name, SizeInBits, AlignInBits, Encoding);
+  }
+};
+
 template <> struct MDNodeKeyImpl<DIDerivedType> {
   unsigned Tag;
   MDString *Name;
@@ -577,6 +646,52 @@
   }
 };
 
+template <> struct MDNodeKeyImpl<DIFortranArrayType> {
+  unsigned Tag;
+  MDString *Name;
+  Metadata *File;
+  unsigned Line;
+  Metadata *Scope;
+  Metadata *BaseType;
+  uint64_t SizeInBits;
+  uint64_t OffsetInBits;
+  uint32_t AlignInBits;
+  unsigned Flags;
+  Metadata *Elements;
+
+  MDNodeKeyImpl(unsigned Tag, MDString *Name, Metadata *File, unsigned Line,
+                Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,
+                uint32_t AlignInBits, uint64_t OffsetInBits, unsigned Flags,
+                Metadata *Elements)
+      : Tag(Tag), Name(Name), File(File), Line(Line), Scope(Scope),
+        BaseType(BaseType), SizeInBits(SizeInBits), OffsetInBits(OffsetInBits),
+        AlignInBits(AlignInBits), Flags(Flags), Elements(Elements) {}
+  MDNodeKeyImpl(const DIFortranArrayType *N)
+      : Tag(N->getTag()), Name(N->getRawName()), File(N->getRawFile()),
+        Line(N->getLine()), Scope(N->getRawScope()),
+        BaseType(N->getRawBaseType()), SizeInBits(N->getSizeInBits()),
+        OffsetInBits(N->getOffsetInBits()), AlignInBits(N->getAlignInBits()),
+        Flags(N->getFlags()), Elements(N->getRawElements()) {}
+
+  bool isKeyOf(const DIFortranArrayType *RHS) const {
+    return Tag == RHS->getTag() && Name == RHS->getRawName() &&
+           File == RHS->getRawFile() && Line == RHS->getLine() &&
+           Scope == RHS->getRawScope() && BaseType == RHS->getRawBaseType() &&
+           SizeInBits == RHS->getSizeInBits() &&
+           AlignInBits == RHS->getAlignInBits() &&
+           OffsetInBits == RHS->getOffsetInBits() && Flags == RHS->getFlags() &&
+           Elements == RHS->getRawElements();
+  }
+
+  unsigned getHashValue() const {
+    // Intentionally computes the hash on a subset of the operands for
+    // performance reason. The subset has to be significant enough to avoid
+    // collision "most of the time". There is no correctness issue in case of
+    // collision because of the full check above.
+    return hash_combine(Name, File, Line, BaseType, Scope, Elements);
+  }
+};
+
 template <> struct MDNodeKeyImpl<DISubroutineType> {
   unsigned Flags;
   uint8_t CC;
--- a/llvm/lib/IR/Verifier.cpp	2021-02-18 22:01:02.017290930 +0100
+++ b/llvm/lib/IR/Verifier.cpp	2021-02-18 22:01:32.539553720 +0100
@@ -920,6 +920,14 @@
            "Stride must be signed constant or DIVariable or DIExpression", &N);
 }
 
+void Verifier::visitDIFortranSubrange(const DIFortranSubrange &N) {
+  AssertDI(N.getTag() == dwarf::DW_TAG_subrange_type, "invalid tag", &N);
+  AssertDI(N.getLowerBound() ? (N.getLowerBoundExp() != nullptr) : true,
+           "no lower bound", &N);
+  AssertDI(N.getUpperBound() ? (N.getUpperBoundExp() != nullptr) : true,
+           "no upper bound", &N);
+}
+
 void Verifier::visitDIEnumerator(const DIEnumerator &N) {
   AssertDI(N.getTag() == dwarf::DW_TAG_enumerator, "invalid tag", &N);
 }
@@ -932,6 +940,11 @@
             "has conflicting flags", &N);
 }
 
+void Verifier::visitDIStringType(const DIStringType &N) {
+  AssertDI( N.getTag() == dwarf::DW_TAG_string_type,
+           "invalid tag", &N);
+}
+
 void Verifier::visitDIDerivedType(const DIDerivedType &N) {
   // Common scope checks.
   visitDIScope(N);
@@ -1037,6 +1050,22 @@
   }
 }
 
+void Verifier::visitDIFortranArrayType(const DIFortranArrayType &N) {
+  // Common scope checks.
+  visitDIScope(N);
+
+  AssertDI(N.getTag() == dwarf::DW_TAG_array_type, "invalid tag", &N);
+
+  AssertDI(isScope(N.getRawScope()), "invalid scope", &N, N.getRawScope());
+  AssertDI(isType(N.getRawBaseType()), "invalid base type", &N,
+           N.getRawBaseType());
+
+  AssertDI(!N.getRawElements() || isa<MDTuple>(N.getRawElements()),
+           "invalid composite elements", &N, N.getRawElements());
+  AssertDI(!hasConflictingReferenceFlags(N.getFlags()),
+           "invalid reference flags", &N);
+}
+
 void Verifier::visitDISubroutineType(const DISubroutineType &N) {
   AssertDI(N.getTag() == dwarf::DW_TAG_subroutine_type, "invalid tag", &N);
   if (auto *Types = N.getRawTypeArray()) {
--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp	2021-02-18 22:01:02.158292143 +0100
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp	2021-02-18 22:01:32.540553729 +0100
@@ -5200,8 +5200,10 @@
       if (ValuesToIgnore.count(&I))
         continue;
 
-      // Only examine Loads, Stores and PHINodes.
-      if (!isa<LoadInst>(I) && !isa<StoreInst>(I) && !isa<PHINode>(I))
+      // Examine Loads, Stores, PHINodes
+      // Also examine instructions which convert to a float/double
+      if (!isa<LoadInst>(I) && !isa<StoreInst>(I) && !isa<PHINode>(I) &&
+          !isa<FPExtInst>(I) && !isa<SIToFPInst>(I) && !isa<UIToFPInst>(I))
         continue;
 
       // Examine PHI nodes that are reduction variables. Update the type to

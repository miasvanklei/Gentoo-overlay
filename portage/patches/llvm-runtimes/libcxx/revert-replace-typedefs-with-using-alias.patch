--- a/libcxx/include/string
+++ b/libcxx/include/string
@@ -767,18 +767,18 @@
   using __default_allocator_type _LIBCPP_NODEBUG = allocator<_CharT>;
 
 public:
-  using __self _LIBCPP_NODEBUG         = basic_string;
-  using __self_view _LIBCPP_NODEBUG    = basic_string_view<_CharT, _Traits>;
-  using traits_type                    = _Traits;
-  using value_type                     = _CharT;
-  using allocator_type                 = _Allocator;
-  using __alloc_traits _LIBCPP_NODEBUG = allocator_traits<allocator_type>;
-  using size_type                      = typename __alloc_traits::size_type;
-  using difference_type                = typename __alloc_traits::difference_type;
-  using reference                      = value_type&;
-  using const_reference                = const value_type&;
-  using pointer                        = typename __alloc_traits::pointer;
-  using const_pointer                  = typename __alloc_traits::const_pointer;
+  typedef basic_string __self;
+  typedef basic_string_view<_CharT, _Traits> __self_view;
+  typedef _Traits traits_type;
+  typedef _CharT value_type;
+  typedef _Allocator allocator_type;
+  typedef allocator_traits<allocator_type> __alloc_traits;
+  typedef typename __alloc_traits::size_type size_type;
+  typedef typename __alloc_traits::difference_type difference_type;
+  typedef value_type& reference;
+  typedef const value_type& const_reference;
+  typedef typename __alloc_traits::pointer pointer;
+  typedef typename __alloc_traits::const_pointer const_pointer;
 
   // A basic_string contains the following members which may be trivially relocatable:
   // - pointer: is currently assumed to be trivially relocatable, but is still checked in case that changes
@@ -841,14 +841,14 @@
   // Users might provide custom allocators, and prior to C++20 we have no existing way to detect whether the allocator's
   // pointer type is contiguous (though it has to be by the Standard). Using the wrapper type ensures the iterator is
   // considered contiguous.
-  using iterator       = __bounded_iter<__wrap_iter<pointer> >;
-  using const_iterator = __bounded_iter<__wrap_iter<const_pointer> >;
+  typedef __bounded_iter<__wrap_iter<pointer> > iterator;
+  typedef __bounded_iter<__wrap_iter<const_pointer> > const_iterator;
 #  else
-  using iterator       = __wrap_iter<pointer>;
-  using const_iterator = __wrap_iter<const_pointer>;
+  typedef __wrap_iter<pointer> iterator;
+  typedef __wrap_iter<const_pointer> const_iterator;
 #  endif
-  using reverse_iterator       = std::reverse_iterator<iterator>;
-  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+  typedef std::reverse_iterator<iterator> reverse_iterator;
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
 
 private:
   static_assert(CHAR_BIT == 8, "This implementation assumes that one byte contains 8 bits");
--- a/libcxx/include/__type_traits/invoke.h
+++ b/libcxx/include/__type_traits/invoke.h
@@ -384,7 +384,7 @@
 struct _LIBCPP_NO_SPECIALIZATIONS invoke_result : __invoke_result<_Fn, _Args...> {};
 
 template <class _Fn, class... _Args>
-using invoke_result_t = __invoke_result_t<_Fn, _Args...>;
+using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
 
 #endif
 

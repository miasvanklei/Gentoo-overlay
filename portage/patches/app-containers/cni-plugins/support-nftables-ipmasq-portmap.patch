diff --git a/go.mod b/go.mod
index 698962799..b5a2efe40 100644
--- a/go.mod
+++ b/go.mod
@@ -12,6 +12,7 @@ require (
 	github.com/d2g/dhcp4 v0.0.0-20170904100407-a1d1b6c41b1c
 	github.com/d2g/dhcp4client v1.0.0
 	github.com/d2g/dhcp4server v0.0.0-20181031114812-7d4a0a7f59a5
+	github.com/danwinship/nftables v0.0.8
 	github.com/godbus/dbus/v5 v5.1.0
 	github.com/mattn/go-shellwords v1.0.12
 	github.com/networkplumbing/go-nft v0.4.0
diff --git a/go.sum b/go.sum
index 975851db2..ccf3db167 100644
--- a/go.sum
+++ b/go.sum
@@ -233,6 +233,8 @@ github.com/d2g/dhcp4server v0.0.0-20181031114812-7d4a0a7f59a5 h1:+CpLbZIeUn94m02
 github.com/d2g/dhcp4server v0.0.0-20181031114812-7d4a0a7f59a5/go.mod h1:Eo87+Kg/IX2hfWJfwxMzLyuSZyxSoAug2nGa1G2QAi8=
 github.com/d2g/hardwareaddr v0.0.0-20190221164911-e7d9fbe030e4 h1:itqmmf1PFpC4n5JW+j4BU7X4MTfVurhYRTjODoPb2Y8=
 github.com/d2g/hardwareaddr v0.0.0-20190221164911-e7d9fbe030e4/go.mod h1:bMl4RjIciD2oAxI7DmWRx6gbeqrkoLqv3MV0vzNad+I=
+github.com/danwinship/nftables v0.0.8 h1:UQlahMFYARR11ywo4eM3kAWmKonWMCJKMAuoGh0xtTQ=
+github.com/danwinship/nftables v0.0.8/go.mod h1:RT2RoLHm0C6lnlPuPhfkxU8VkYYtKUSWf9FI8bae9FY=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
@@ -449,6 +451,7 @@ github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
 github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
 github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
 github.com/linuxkit/virtsock v0.0.0-20201010232012-f8cee7dfc7a3/go.mod h1:3r6x7q95whyfWQpmGZTu3gk3v2YkMi05HEzl7Tf7YEo=
+github.com/lithammer/dedent v1.1.0 h1:VNzHMVCBNG1j0fh3OrsFRkVUwStdDArbgBWoPAffktY=
 github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mailru/easyjson v0.0.0-20160728113105-d5b7844b561a/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
 github.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
diff --git a/pkg/ip/ipmasq_iptables_linux.go b/pkg/ip/ipmasq_iptables_linux.go
new file mode 100644
index 000000000..5dfbf090d
--- /dev/null
+++ b/pkg/ip/ipmasq_iptables_linux.go
@@ -0,0 +1,130 @@
+// Copyright 2015 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ip
+
+import (
+	"fmt"
+	"net"
+
+	"github.com/coreos/go-iptables/iptables"
+
+	"github.com/containernetworking/plugins/pkg/utils"
+)
+
+// setupIPMasqIPTables is the iptables-based implementation of SetupIPMasq
+func setupIPMasqIPTables(ipn *net.IPNet, pluginName, containerID string) error {
+	chain := utils.FormatChainName(pluginName, containerID)
+	comment := utils.FormatComment(pluginName, containerID)
+	isV6 := ipn.IP.To4() == nil
+
+	var ipt *iptables.IPTables
+	var err error
+	var multicastNet string
+
+	if isV6 {
+		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv6)
+		multicastNet = "ff00::/8"
+	} else {
+		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv4)
+		multicastNet = "224.0.0.0/4"
+	}
+	if err != nil {
+		return fmt.Errorf("failed to locate iptables: %v", err)
+	}
+
+	// Create chain if doesn't exist
+	exists := false
+	chains, err := ipt.ListChains("nat")
+	if err != nil {
+		return fmt.Errorf("failed to list chains: %v", err)
+	}
+	for _, ch := range chains {
+		if ch == chain {
+			exists = true
+			break
+		}
+	}
+	if !exists {
+		if err = ipt.NewChain("nat", chain); err != nil {
+			return err
+		}
+	}
+
+	// Packets to this network should not be touched
+	if err := ipt.AppendUnique("nat", chain, "-d", ipn.String(), "-j", "ACCEPT", "-m", "comment", "--comment", comment); err != nil {
+		return err
+	}
+
+	// Don't masquerade multicast - pods should be able to talk to other pods
+	// on the local network via multicast.
+	if err := ipt.AppendUnique("nat", chain, "!", "-d", multicastNet, "-j", "MASQUERADE", "-m", "comment", "--comment", comment); err != nil {
+		return err
+	}
+
+	// Packets from the specific IP of this network will hit the chain
+	return ipt.AppendUnique("nat", "POSTROUTING", "-s", ipn.IP.String(), "-j", chain, "-m", "comment", "--comment", comment)
+}
+
+// teardownIPMasqIPTables is the iptables-based implementation of TeardownIPMasq
+func teardownIPMasqIPTables(ipn *net.IPNet, pluginName, containerID string) error {
+	chain := utils.FormatChainName(pluginName, containerID)
+	comment := utils.FormatComment(pluginName, containerID)
+	isV6 := ipn.IP.To4() == nil
+
+	var ipt *iptables.IPTables
+	var err error
+
+	if isV6 {
+		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv6)
+	} else {
+		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv4)
+	}
+	if err != nil {
+		return fmt.Errorf("failed to locate iptables: %v", err)
+	}
+
+	err = ipt.Delete("nat", "POSTROUTING", "-s", ipn.IP.String(), "-j", chain, "-m", "comment", "--comment", comment)
+	if err != nil && !isNotExist(err) {
+		return err
+	}
+
+	// for downward compatibility
+	err = ipt.Delete("nat", "POSTROUTING", "-s", ipn.String(), "-j", chain, "-m", "comment", "--comment", comment)
+	if err != nil && !isNotExist(err) {
+		return err
+	}
+
+	err = ipt.ClearChain("nat", chain)
+	if err != nil && !isNotExist(err) {
+		return err
+	}
+
+	err = ipt.DeleteChain("nat", chain)
+	if err != nil && !isNotExist(err) {
+		return err
+	}
+
+	return nil
+}
+
+// isNotExist returnst true if the error is from iptables indicating
+// that the target does not exist.
+func isNotExist(err error) bool {
+	e, ok := err.(*iptables.Error)
+	if !ok {
+		return false
+	}
+	return e.IsNotExist()
+}
diff --git a/pkg/ip/ipmasq_linux.go b/pkg/ip/ipmasq_linux.go
index aa59a8db5..9bbc5b020 100644
--- a/pkg/ip/ipmasq_linux.go
+++ b/pkg/ip/ipmasq_linux.go
@@ -15,111 +15,56 @@
 package ip
 
 import (
+	"errors"
 	"fmt"
 	"net"
+	"strings"
 
-	"github.com/coreos/go-iptables/iptables"
+	"github.com/containernetworking/plugins/pkg/utils"
 )
 
-// SetupIPMasq installs iptables rules to masquerade traffic
-// coming from ip of ipn and going outside of ipn
-func SetupIPMasq(ipn *net.IPNet, chain string, comment string) error {
-	isV6 := ipn.IP.To4() == nil
-
-	var ipt *iptables.IPTables
-	var err error
-	var multicastNet string
-
-	if isV6 {
-		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv6)
-		multicastNet = "ff00::/8"
-	} else {
-		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv4)
-		multicastNet = "224.0.0.0/4"
-	}
-	if err != nil {
-		return fmt.Errorf("failed to locate iptables: %v", err)
-	}
-
-	// Create chain if doesn't exist
-	exists := false
-	chains, err := ipt.ListChains("nat")
-	if err != nil {
-		return fmt.Errorf("failed to list chains: %v", err)
-	}
-	for _, ch := range chains {
-		if ch == chain {
-			exists = true
-			break
-		}
-	}
-	if !exists {
-		if err = ipt.NewChain("nat", chain); err != nil {
-			return err
+// SetupIPMasq installs rules to masquerade traffic coming from ip of ipn and going
+// outside of ipn. The backend can be either "iptables" or "nftables"; if it is nil, then
+// a suitable default implementation will be used.
+func SetupIPMasq(backend *string, ipn *net.IPNet, pluginName, containerID string) error {
+	if backend == nil {
+		// Prefer iptables, unless only nftables is available
+		defaultBackend := "iptables"
+		if !utils.SupportsIPTables() && utils.SupportsNFTables() {
+			defaultBackend = "nftables"
 		}
+		backend = &defaultBackend
 	}
 
-	// Packets to this network should not be touched
-	if err := ipt.AppendUnique("nat", chain, "-d", ipn.String(), "-j", "ACCEPT", "-m", "comment", "--comment", comment); err != nil {
-		return err
-	}
-
-	// Don't masquerade multicast - pods should be able to talk to other pods
-	// on the local network via multicast.
-	if err := ipt.AppendUnique("nat", chain, "!", "-d", multicastNet, "-j", "MASQUERADE", "-m", "comment", "--comment", comment); err != nil {
-		return err
+	switch *backend {
+	case "iptables":
+		return setupIPMasqIPTables(ipn, pluginName, containerID)
+	case "nftables":
+		return setupIPMasqNFTables(ipn, pluginName, containerID)
+	default:
+		return fmt.Errorf("unknown ipmasq backend %q", *backend)
 	}
-
-	// Packets from the specific IP of this network will hit the chain
-	return ipt.AppendUnique("nat", "POSTROUTING", "-s", ipn.IP.String(), "-j", chain, "-m", "comment", "--comment", comment)
 }
 
 // TeardownIPMasq undoes the effects of SetupIPMasq
-func TeardownIPMasq(ipn *net.IPNet, chain string, comment string) error {
-	isV6 := ipn.IP.To4() == nil
-
-	var ipt *iptables.IPTables
-	var err error
-
-	if isV6 {
-		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv6)
-	} else {
-		ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv4)
-	}
-	if err != nil {
-		return fmt.Errorf("failed to locate iptables: %v", err)
-	}
+func TeardownIPMasq(ipn *net.IPNet, pluginName, containerID string) error {
+	var errs []string
 
-	err = ipt.Delete("nat", "POSTROUTING", "-s", ipn.IP.String(), "-j", chain, "-m", "comment", "--comment", comment)
-	if err != nil && !isNotExist(err) {
-		return err
-	}
-
-	// for downward compatibility
-	err = ipt.Delete("nat", "POSTROUTING", "-s", ipn.String(), "-j", chain, "-m", "comment", "--comment", comment)
-	if err != nil && !isNotExist(err) {
-		return err
-	}
+	// Do both the iptables and the nftables cleanup, since the pod may have been
+	// created with a different version of this plugin or a different configuration.
 
-	err = ipt.ClearChain("nat", chain)
-	if err != nil && !isNotExist(err) {
-		return err
+	err := teardownIPMasqIPTables(ipn, pluginName, containerID)
+	if err != nil && utils.SupportsIPTables() {
+		errs = append(errs, err.Error())
 	}
 
-	err = ipt.DeleteChain("nat", chain)
-	if err != nil && !isNotExist(err) {
-		return err
+	err = teardownIPMasqNFTables(ipn, pluginName, containerID)
+	if err != nil && utils.SupportsNFTables() {
+		errs = append(errs, err.Error())
 	}
 
-	return nil
-}
-
-// isNotExist returnst true if the error is from iptables indicating
-// that the target does not exist.
-func isNotExist(err error) bool {
-	e, ok := err.(*iptables.Error)
-	if !ok {
-		return false
+	if errs == nil {
+		return nil
 	}
-	return e.IsNotExist()
+	return errors.New(strings.Join(errs, "\n"))
 }
diff --git a/pkg/ip/ipmasq_linux_test.go b/pkg/ip/ipmasq_linux_test.go
new file mode 100644
index 000000000..0c4f9a817
--- /dev/null
+++ b/pkg/ip/ipmasq_linux_test.go
@@ -0,0 +1,110 @@
+// Copyright 2023 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ip
+
+import (
+	"strings"
+	"testing"
+
+	"github.com/danwinship/nftables"
+	"github.com/vishvananda/netlink"
+)
+
+func Test_setupIPMasqNFTables(t *testing.T) {
+	nft := nftables.NewFake(nftables.InetFamily, ipMasqTableName)
+
+	containers := []struct {
+		id   string
+		addr string
+	}{
+		{
+			id:   "one",
+			addr: "192.168.1.1/24",
+		},
+		{
+			id:   "two",
+			addr: "192.168.1.2/24",
+		},
+		{
+			id:   "three",
+			addr: "192.168.99.5/24",
+		},
+	}
+
+	for _, c := range containers {
+		addr, err := netlink.ParseAddr(c.addr)
+		if err != nil {
+			t.Fatalf("failed to parse test addr: %v", err)
+		}
+		err = setupIPMasqNFTablesWithInterface(nft, addr.IPNet, "unit-test", c.id)
+		if err != nil {
+			t.Fatalf("error from setupIPMasqNFTables: %v", err)
+		}
+	}
+
+	expected := strings.TrimSpace(`
+add table inet cni_plugins_masquerade { comment "Masquerading for plugins from github.com/containernetworking/plugins" ; }
+add chain inet cni_plugins_masquerade masq_checks { comment "Masquerade traffic from certain IPs to any (non-multicast) IP outside their subnet" ; }
+add rule inet cni_plugins_masquerade masq_checks ip saddr == 192.168.1.1 ip daddr != 192.168.1.0/24 masquerade comment "8c062ad391bb8ebf"
+add rule inet cni_plugins_masquerade masq_checks ip saddr == 192.168.1.2 ip daddr != 192.168.1.0/24 masquerade comment "a777505f2d11fd66"
+add rule inet cni_plugins_masquerade masq_checks ip saddr == 192.168.99.5 ip daddr != 192.168.99.0/24 masquerade comment "dab3c041fbc51d09"
+add chain inet cni_plugins_masquerade postrouting { type nat hook postrouting priority srcnat ; }
+add rule inet cni_plugins_masquerade postrouting ip daddr == 224.0.0.0/4  return
+add rule inet cni_plugins_masquerade postrouting ip6 daddr == ff00::/8  return
+add rule inet cni_plugins_masquerade postrouting goto masq_checks
+`)
+	dump := strings.TrimSpace(nft.Dump())
+	if dump != expected {
+		t.Errorf("expected nftables state:\n%s\n\nactual:\n%s\n\n", expected, dump)
+	}
+
+	// Add a new container reusing "one"'s address, before deleting "one"
+	addr, err := netlink.ParseAddr(containers[0].addr)
+	if err != nil {
+		t.Fatalf("failed to parse test addr: %v", err)
+	}
+	err = setupIPMasqNFTablesWithInterface(nft, addr.IPNet, "unit-test", "four")
+	if err != nil {
+		t.Fatalf("error from setupIPMasqNFTables: %v", err)
+	}
+
+	// Now remove the original containers
+	for _, c := range containers {
+		addr, err := netlink.ParseAddr(c.addr)
+		if err != nil {
+			t.Fatalf("failed to parse test addr: %v", err)
+		}
+		err = teardownIPMasqNFTablesWithInterface(nft, addr.IPNet, "unit-test", c.id)
+		if err != nil {
+			t.Fatalf("error from teardownIPMasqNFTables: %v", err)
+		}
+	}
+
+	// We should be left with just the rule for "four"
+
+	expected = strings.TrimSpace(`
+add table inet cni_plugins_masquerade { comment "Masquerading for plugins from github.com/containernetworking/plugins" ; }
+add chain inet cni_plugins_masquerade masq_checks { comment "Masquerade traffic from certain IPs to any (non-multicast) IP outside their subnet" ; }
+add rule inet cni_plugins_masquerade masq_checks ip saddr == 192.168.1.1 ip daddr != 192.168.1.0/24 masquerade comment "a154bc98ffb3110e"
+add chain inet cni_plugins_masquerade postrouting { type nat hook postrouting priority srcnat ; }
+add rule inet cni_plugins_masquerade postrouting ip daddr == 224.0.0.0/4  return
+add rule inet cni_plugins_masquerade postrouting ip6 daddr == ff00::/8  return
+add rule inet cni_plugins_masquerade postrouting goto masq_checks
+`)
+	dump = strings.TrimSpace(nft.Dump())
+	if dump != expected {
+		t.Errorf("expected nftables state:\n%s\n\nactual:\n%s\n\n", expected, dump)
+	}
+}
diff --git a/pkg/ip/ipmasq_nftables_linux.go b/pkg/ip/ipmasq_nftables_linux.go
new file mode 100644
index 000000000..78af869ea
--- /dev/null
+++ b/pkg/ip/ipmasq_nftables_linux.go
@@ -0,0 +1,165 @@
+// Copyright 2023 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ip
+
+import (
+	"context"
+	"net"
+
+	"github.com/danwinship/nftables"
+
+	"github.com/containernetworking/plugins/pkg/utils"
+)
+
+const (
+	ipMasqTableName = "cni_plugins_masquerade"
+	ipMasqChainName = "masq_checks"
+)
+
+// The nftables ipmasq implementation is basically a straight port of the iptables
+// implementation: we add a rule for each mapping, with a comment containing a hash of the
+// container ID, so that we can later reliably delete the rules we want. (This is
+// important because in edge cases, it's possible the plugin might see "ADD container A
+// with IP 192.168.1.3", followed by "ADD container B with IP 192.168.1.3" followed by
+// "DEL container A with IP 192.168.1.3", and we need to make sure that the DEL causes us
+// to delete the rule for container A, and not the rule for container B.)
+//
+// It would be more nftables-y to have a chain with a single rule doing a lookup against a
+// set with an element per mapping, rather than having a chain with a rule per mapping.
+// But there's no easy, non-racy way to say "delete the element 192.168.1.3 from the set,
+// but only if it was added for container A, not if it was added for container B".
+
+// hashForContainer returns a unique hash identifying the rules for this container with
+// this plugin
+func hashForContainer(pluginName, containerID string) string {
+	return utils.MustFormatHashWithPrefix(16, "", pluginName+":"+containerID)
+}
+
+// setupIPMasqNFTables is the nftables-based implementation of SetupIPMasq
+func setupIPMasqNFTables(ipn *net.IPNet, pluginName, containerID string) error {
+	nft := nftables.New(nftables.InetFamily, ipMasqTableName)
+	return setupIPMasqNFTablesWithInterface(nft, ipn, pluginName, containerID)
+}
+
+func setupIPMasqNFTablesWithInterface(nft nftables.Interface, ipn *net.IPNet, pluginName, containerID string) error {
+	comment := hashForContainer(pluginName, containerID)
+	staleRules, err := findRules(nft, comment)
+	if err != nil {
+		return err
+	}
+
+	tx := nftables.NewTransaction()
+
+	// Ensure that our table and chains exist.
+	tx.Add(&nftables.Table{
+		Comment: nftables.Optional("Masquerading for plugins from github.com/containernetworking/plugins"),
+	})
+	tx.Add(&nftables.Chain{
+		Name:    ipMasqChainName,
+		Comment: nftables.Optional("Masquerade traffic from certain IPs to any (non-multicast) IP outside their subnet"),
+	})
+
+	// Ensure that the postrouting chain exists and has the correct rules. (Has to be
+	// done after creating ipMasqChainName, so we can jump to it.)
+	tx.Add(&nftables.Chain{
+		Name:     "postrouting",
+		Type:     nftables.Optional(nftables.NATType),
+		Hook:     nftables.Optional(nftables.PostroutingHook),
+		Priority: nftables.Optional(nftables.SNATPriority),
+	})
+	tx.Flush(&nftables.Chain{
+		Name: "postrouting",
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "postrouting",
+		Rule:  "ip daddr == 224.0.0.0/4  return",
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "postrouting",
+		Rule:  "ip6 daddr == ff00::/8  return",
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "postrouting",
+		Rule: nftables.Concat(
+			"goto", ipMasqChainName,
+		),
+	})
+
+	// Delete stale rules, add new rules to masquerade chain
+	for _, rule := range staleRules {
+		tx.Delete(rule)
+	}
+	ip := "ip"
+	if ipn.IP.To4() == nil {
+		ip = "ip6"
+	}
+
+	// e.g. if ipn is "192.168.1.4/24", then dstNet is "192.168.1.0/24"
+	dstNet := &net.IPNet{IP: ipn.IP.Mask(ipn.Mask), Mask: ipn.Mask}
+
+	tx.Add(&nftables.Rule{
+		Chain: ipMasqChainName,
+		Rule: nftables.Concat(
+			ip, "saddr", "==", ipn.IP,
+			ip, "daddr", "!=", dstNet,
+			"masquerade",
+		),
+		Comment: nftables.Optional(comment),
+	})
+
+	return nft.Run(context.TODO(), tx)
+}
+
+// teardownIPMasqNFTables is the nftables-based implementation of TeardownIPMasq
+func teardownIPMasqNFTables(ipn *net.IPNet, pluginName, containerID string) error {
+	nft := nftables.New(nftables.InetFamily, ipMasqTableName)
+	return teardownIPMasqNFTablesWithInterface(nft, ipn, pluginName, containerID)
+}
+
+func teardownIPMasqNFTablesWithInterface(nft nftables.Interface, _ *net.IPNet, pluginName, containerID string) error {
+	rules, err := findRules(nft, hashForContainer(pluginName, containerID))
+	if err != nil {
+		return err
+	} else if len(rules) == 0 {
+		return nil
+	}
+
+	tx := nftables.NewTransaction()
+	for _, rule := range rules {
+		tx.Delete(rule)
+	}
+	return nft.Run(context.TODO(), tx)
+}
+
+// findRules finds rules with the given comment; it is used by both setup and teardown.
+func findRules(nft nftables.Interface, comment string) ([]*nftables.Rule, error) {
+	rules, err := nft.ListRules(context.TODO(), ipMasqChainName)
+	if err != nil {
+		if nftables.IsNotFound(err) {
+			// If ipMasqChainName doesn't exist yet, that's fine
+			return nil, nil
+		}
+		return nil, err
+	}
+
+	matchingRules := make([]*nftables.Rule, 0, 1)
+	for _, rule := range rules {
+		if rule.Comment != nil && *rule.Comment == comment {
+			matchingRules = append(matchingRules, rule)
+		}
+	}
+
+	return matchingRules, nil
+}
diff --git a/pkg/utils/netfilter.go b/pkg/utils/netfilter.go
new file mode 100644
index 000000000..9c06f918b
--- /dev/null
+++ b/pkg/utils/netfilter.go
@@ -0,0 +1,45 @@
+// Copyright 2017 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package utils
+
+import (
+	"github.com/coreos/go-iptables/iptables"
+	"github.com/danwinship/nftables"
+)
+
+// SupportsIPTables tests whether the system supports using netfilter via the iptables API
+// (whether via "iptables-legacy" or "iptables-nft"). (Note that this returns true if it
+// is *possible* to use iptables; it does not test whether any other components on the
+// system are *actually* using iptables.)
+func SupportsIPTables() bool {
+	ipt, err := iptables.NewWithProtocol(iptables.ProtocolIPv4)
+	if err != nil {
+		return false
+	}
+	// We don't care whether the chain actually exists, only whether we can *check*
+	// whether it exists.
+	_, err = ipt.ChainExists("filter", "INPUT")
+	return err == nil
+}
+
+// SupportsNFTables tests whether the system supports using netfilter via the nftables API
+// (ie, not via "iptables-nft"). (Note that this returns true if it is *possible* to use
+// nftables; it does not test whether any other components on the system are *actually*
+// using nftables.)
+func SupportsNFTables() bool {
+	nft := nftables.New(nftables.IPv4Family, "supports_nftables_test")
+	err := nft.Present()
+	return err == nil
+}
diff --git a/pkg/utils/netfilter_test.go b/pkg/utils/netfilter_test.go
new file mode 100644
index 000000000..f4cf9584f
--- /dev/null
+++ b/pkg/utils/netfilter_test.go
@@ -0,0 +1,52 @@
+// Copyright 2017-2018 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package utils
+
+import (
+	"os"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+)
+
+var _ = Describe("netfilter support", func() {
+	When("it is available", func() {
+		It("reports that iptables is supported", func() {
+			Expect(SupportsIPTables()).To(BeTrue(), "This test should only fail if iptables is not available, but the test suite as a whole requires it to be available.")
+		})
+		It("reports that nftables is supported", func() {
+			Expect(SupportsNFTables()).To(BeTrue(), "This test should only fail if nftables is not available, but the test suite as a whole requires it to be available.")
+		})
+	})
+
+	// These are Serial because os.Setenv has process-wide effect
+	When("it is not available", Serial, func() {
+		var origPath string
+		BeforeEach(func() {
+			origPath = os.Getenv("PATH")
+			os.Setenv("PATH", "/does-not-exist")
+		})
+		AfterEach(func() {
+			os.Setenv("PATH", origPath)
+		})
+
+		It("reports that iptables is not supported", func() {
+			Expect(SupportsIPTables()).To(BeFalse(), "found iptables outside of PATH??")
+		})
+		It("reports that nftables is not supported", func() {
+			Expect(SupportsNFTables()).To(BeFalse(), "found nftables outside of PATH??")
+		})
+	})
+})
diff --git a/plugins/main/bridge/bridge.go b/plugins/main/bridge/bridge.go
index f4e61c72d..7bc62939a 100644
--- a/plugins/main/bridge/bridge.go
+++ b/plugins/main/bridge/bridge.go
@@ -35,7 +35,6 @@ import (
 	"github.com/containernetworking/plugins/pkg/ipam"
 	"github.com/containernetworking/plugins/pkg/link"
 	"github.com/containernetworking/plugins/pkg/ns"
-	"github.com/containernetworking/plugins/pkg/utils"
 	bv "github.com/containernetworking/plugins/pkg/utils/buildversion"
 	"github.com/containernetworking/plugins/pkg/utils/sysctl"
 )
@@ -52,6 +51,7 @@ type NetConf struct {
 	IsDefaultGW         bool         `json:"isDefaultGateway"`
 	ForceAddress        bool         `json:"forceAddress"`
 	IPMasq              bool         `json:"ipMasq"`
+	IPMasqBackend       *string      `json:"ipMasqBackend,omitempty"`
 	MTU                 int          `json:"mtu"`
 	HairpinMode         bool         `json:"hairpinMode"`
 	PromiscMode         bool         `json:"promiscMode"`
@@ -672,10 +672,8 @@ func cmdAdd(args *skel.CmdArgs) error {
 		}
 
 		if n.IPMasq {
-			chain := utils.FormatChainName(n.Name, args.ContainerID)
-			comment := utils.FormatComment(n.Name, args.ContainerID)
 			for _, ipc := range result.IPs {
-				if err = ip.SetupIPMasq(&ipc.Address, chain, comment); err != nil {
+				if err = ip.SetupIPMasq(n.IPMasqBackend, &ipc.Address, n.Name, args.ContainerID); err != nil {
 					return err
 				}
 			}
@@ -808,10 +806,8 @@ func cmdDel(args *skel.CmdArgs) error {
 	}
 
 	if isLayer3 && n.IPMasq {
-		chain := utils.FormatChainName(n.Name, args.ContainerID)
-		comment := utils.FormatComment(n.Name, args.ContainerID)
 		for _, ipn := range ipnets {
-			if err := ip.TeardownIPMasq(ipn, chain, comment); err != nil {
+			if err := ip.TeardownIPMasq(ipn, n.Name, args.ContainerID); err != nil {
 				return err
 			}
 		}
diff --git a/plugins/main/bridge/bridge_test.go b/plugins/main/bridge/bridge_test.go
index 74b82ce37..acb440cf6 100644
--- a/plugins/main/bridge/bridge_test.go
+++ b/plugins/main/bridge/bridge_test.go
@@ -15,6 +15,7 @@
 package main
 
 import (
+	"context"
 	"encoding/json"
 	"fmt"
 	"net"
@@ -22,6 +23,7 @@ import (
 	"strings"
 
 	"github.com/coreos/go-iptables/iptables"
+	"github.com/danwinship/nftables"
 	"github.com/networkplumbing/go-nft/nft"
 	. "github.com/onsi/ginkgo/v2"
 	. "github.com/onsi/gomega"
@@ -77,6 +79,7 @@ type testCase struct {
 	vlanTrunk         []*VlanTrunk
 	removeDefaultVlan bool
 	ipMasq            bool
+	ipMasqBackend     string
 	macspoofchk       bool
 	AddErr020         string
 	DelErr020         string
@@ -167,6 +170,9 @@ const (
 	ipMasqConfStr = `,
 	"ipMasq": %t`
 
+	ipMasqBackendConfStr = `,
+	"ipMasqBackend": "%s"`
+
 	// Single subnet configuration (legacy)
 	subnetConfStr = `,
         "subnet":  "%s"`
@@ -238,6 +244,9 @@ func (tc testCase) netConfJSON(dataDir string) string {
 	if tc.ipMasq {
 		conf += tc.ipMasqConfig()
 	}
+	if tc.ipMasqBackend != "" {
+		conf += tc.ipMasqBackendConfig()
+	}
 	if tc.args.cni.mac != "" {
 		conf += fmt.Sprintf(argsFormat, tc.args.cni.mac)
 	}
@@ -286,6 +295,11 @@ func (tc testCase) ipMasqConfig() string {
 	return conf
 }
 
+func (tc testCase) ipMasqBackendConfig() string {
+	conf := fmt.Sprintf(ipMasqBackendConfStr, tc.ipMasqBackend)
+	return conf
+}
+
 func (tc testCase) rangesConfig() string {
 	conf := rangesStartStr
 	for i, tcRange := range tc.ranges {
@@ -2361,41 +2375,79 @@ var _ = Describe("bridge Operations", func() {
 		})
 
 		if testutils.SpecVersionHasChaining(ver) {
-			It(fmt.Sprintf("[%s] configures a bridge and ipMasq rules", ver), func() {
-				err := originalNS.Do(func(ns.NetNS) error {
-					defer GinkgoRecover()
-					tc := testCase{
-						ranges: []rangeInfo{{
-							subnet: "10.1.2.0/24",
-						}},
-						ipMasq:     true,
-						cniVersion: ver,
-					}
-
-					args := tc.createCmdArgs(originalNS, dataDir)
-					r, _, err := testutils.CmdAddWithArgs(args, func() error {
-						return cmdAdd(args)
-					})
-					Expect(err).NotTo(HaveOccurred())
-					result, err := types100.GetResult(r)
-					Expect(err).NotTo(HaveOccurred())
-					Expect(result.IPs).Should(HaveLen(1))
-
-					ipt, err := iptables.NewWithProtocol(iptables.ProtocolIPv4)
-					Expect(err).NotTo(HaveOccurred())
-
-					rules, err := ipt.List("nat", "POSTROUTING")
-					Expect(err).NotTo(HaveOccurred())
-					Expect(rules).Should(ContainElement(ContainSubstring(result.IPs[0].Address.IP.String())))
+			for _, tc := range []testCase{
+				{
+					ranges: []rangeInfo{{
+						subnet: "10.1.2.0/24",
+					}},
+					ipMasq:     true,
+					cniVersion: ver,
+				},
+				{
+					ranges: []rangeInfo{{
+						subnet: "10.1.2.0/24",
+					}},
+					ipMasq:        true,
+					ipMasqBackend: "iptables",
+					cniVersion:    ver,
+				},
+				{
+					ranges: []rangeInfo{{
+						subnet: "10.1.2.0/24",
+					}},
+					ipMasq:        true,
+					ipMasqBackend: "nftables",
+					cniVersion:    ver,
+				},
+			} {
+				tc := tc
+				It(fmt.Sprintf("[%s] configures a bridge and ipMasq rules with ipMasqBackend %q", ver, tc.ipMasqBackend), func() {
+					err := originalNS.Do(func(ns.NetNS) error {
+						defer GinkgoRecover()
+
+						args := tc.createCmdArgs(originalNS, dataDir)
+						r, _, err := testutils.CmdAddWithArgs(args, func() error {
+							return cmdAdd(args)
+						})
+						Expect(err).NotTo(HaveOccurred())
+						result, err := types100.GetResult(r)
+						Expect(err).NotTo(HaveOccurred())
+						Expect(result.IPs).Should(HaveLen(1))
+
+						ip := result.IPs[0].Address.IP.String()
+
+						// Update this if the default ipmasq backend changes
+						switch tc.ipMasqBackend {
+						case "iptables", "":
+							ipt, err := iptables.NewWithProtocol(iptables.ProtocolIPv4)
+							Expect(err).NotTo(HaveOccurred())
+
+							rules, err := ipt.List("nat", "POSTROUTING")
+							Expect(err).NotTo(HaveOccurred())
+							Expect(rules).Should(ContainElement(ContainSubstring(ip)))
+						case "nftables":
+							nft := nftables.New(nftables.InetFamily, "cni_plugins_masquerade")
+							rules, err := nft.ListRules(context.TODO(), "masq_checks")
+							Expect(err).NotTo(HaveOccurred())
+							found := false
+							for _, r := range rules {
+								if strings.Contains(r.Rule, ip) {
+									found = true
+									break
+								}
+							}
+							Expect(found).To(BeTrue(), "expected to find a Rule containing %q", ip)
+						}
 
-					err = testutils.CmdDelWithArgs(args, func() error {
-						return cmdDel(args)
+						err = testutils.CmdDelWithArgs(args, func() error {
+							return cmdDel(args)
+						})
+						Expect(err).NotTo(HaveOccurred())
+						return nil
 					})
 					Expect(err).NotTo(HaveOccurred())
-					return nil
 				})
-				Expect(err).NotTo(HaveOccurred())
-			})
+			}
 
 			for i, tc := range []testCase{
 				{
diff --git a/plugins/main/ptp/ptp.go b/plugins/main/ptp/ptp.go
index 841e57d12..7d8a7c144 100644
--- a/plugins/main/ptp/ptp.go
+++ b/plugins/main/ptp/ptp.go
@@ -31,7 +31,6 @@ import (
 	"github.com/containernetworking/plugins/pkg/ip"
 	"github.com/containernetworking/plugins/pkg/ipam"
 	"github.com/containernetworking/plugins/pkg/ns"
-	"github.com/containernetworking/plugins/pkg/utils"
 	bv "github.com/containernetworking/plugins/pkg/utils/buildversion"
 )
 
@@ -44,8 +43,9 @@ func init() {
 
 type NetConf struct {
 	types.NetConf
-	IPMasq bool `json:"ipMasq"`
-	MTU    int  `json:"mtu"`
+	IPMasq        bool    `json:"ipMasq"`
+	IPMasqBackend *string `json:"ipMasqBackend,omitempty"`
+	MTU           int     `json:"mtu"`
 }
 
 func setupContainerVeth(netns ns.NetNS, ifName string, mtu int, pr *current.Result) (*current.Interface, *current.Interface, error) {
@@ -229,10 +229,8 @@ func cmdAdd(args *skel.CmdArgs) error {
 	}
 
 	if conf.IPMasq {
-		chain := utils.FormatChainName(conf.Name, args.ContainerID)
-		comment := utils.FormatComment(conf.Name, args.ContainerID)
 		for _, ipc := range result.IPs {
-			if err = ip.SetupIPMasq(&ipc.Address, chain, comment); err != nil {
+			if err = ip.SetupIPMasq(conf.IPMasqBackend, &ipc.Address, conf.Name, args.ContainerID); err != nil {
 				return err
 			}
 		}
@@ -293,10 +291,8 @@ func cmdDel(args *skel.CmdArgs) error {
 	}
 
 	if len(ipnets) != 0 && conf.IPMasq {
-		chain := utils.FormatChainName(conf.Name, args.ContainerID)
-		comment := utils.FormatComment(conf.Name, args.ContainerID)
 		for _, ipn := range ipnets {
-			err = ip.TeardownIPMasq(ipn, chain, comment)
+			err = ip.TeardownIPMasq(ipn, conf.Name, args.ContainerID)
 		}
 	}
 
diff --git a/plugins/main/ptp/ptp_test.go b/plugins/main/ptp/ptp_test.go
index 0ede4409e..bdc78b13e 100644
--- a/plugins/main/ptp/ptp_test.go
+++ b/plugins/main/ptp/ptp_test.go
@@ -39,6 +39,7 @@ type Net struct {
 	CNIVersion    string                 `json:"cniVersion"`
 	Type          string                 `json:"type,omitempty"`
 	IPMasq        bool                   `json:"ipMasq"`
+	IPMasqBackend *string                `json:"ipMasqBackend,omitempty"`
 	MTU           int                    `json:"mtu"`
 	IPAM          *allocator.IPAMConfig  `json:"ipam"`
 	DNS           types.DNS              `json:"dns"`
@@ -368,6 +369,62 @@ var _ = Describe("ptp Operations", func() {
 			doTest(conf, ver, 1, dnsConf, targetNS)
 		})
 
+		It(fmt.Sprintf("[%s] configures and deconfigures a ptp link when specifying ipMasqBackend: iptables", ver), func() {
+			dnsConf := types.DNS{
+				Nameservers: []string{"10.1.2.123"},
+				Domain:      "some.domain.test",
+				Search:      []string{"search.test"},
+				Options:     []string{"option1:foo"},
+			}
+			dnsConfBytes, err := json.Marshal(dnsConf)
+			Expect(err).NotTo(HaveOccurred())
+
+			conf := fmt.Sprintf(`{
+			    "cniVersion": "%s",
+			    "name": "mynet",
+			    "type": "ptp",
+			    "ipMasq": true,
+			    "ipMasqBackend": "iptables",
+			    "mtu": 5000,
+			    "ipam": {
+				"type": "host-local",
+				"subnet": "10.1.2.0/24",
+				"dataDir": "%s"
+			    },
+			    "dns": %s
+			}`, ver, dataDir, string(dnsConfBytes))
+
+			doTest(conf, ver, 1, dnsConf, targetNS)
+		})
+
+		It(fmt.Sprintf("[%s] configures and deconfigures a ptp link when specifying ipMasqBackend: nftables", ver), func() {
+			dnsConf := types.DNS{
+				Nameservers: []string{"10.1.2.123"},
+				Domain:      "some.domain.test",
+				Search:      []string{"search.test"},
+				Options:     []string{"option1:foo"},
+			}
+			dnsConfBytes, err := json.Marshal(dnsConf)
+			Expect(err).NotTo(HaveOccurred())
+
+			conf := fmt.Sprintf(`{
+			    "cniVersion": "%s",
+			    "name": "mynet",
+			    "type": "ptp",
+			    "ipMasq": true,
+			    "ipMasqBackend": "nftables",
+			    "mtu": 5000,
+			    "ipam": {
+				"type": "host-local",
+				"subnet": "10.1.2.0/24",
+				"dataDir": "%s"
+			    },
+			    "dns": %s
+			}`, ver, dataDir, string(dnsConfBytes))
+
+			doTest(conf, ver, 1, dnsConf, targetNS)
+		})
+
 		It(fmt.Sprintf("[%s] configures and deconfigures a dual-stack ptp link + routes with ADD/DEL", ver), func() {
 			conf := fmt.Sprintf(`{
 			    "cniVersion": "%s",
diff --git a/plugins/meta/portmap/main.go b/plugins/meta/portmap/main.go
index 09af586a5..0fad159ef 100644
--- a/plugins/meta/portmap/main.go
+++ b/plugins/meta/portmap/main.go
@@ -37,9 +37,22 @@ import (
 	"github.com/containernetworking/cni/pkg/types"
 	current "github.com/containernetworking/cni/pkg/types/100"
 	"github.com/containernetworking/cni/pkg/version"
+	"github.com/containernetworking/plugins/pkg/utils"
 	bv "github.com/containernetworking/plugins/pkg/utils/buildversion"
 )
 
+type PortMapper interface {
+	forwardPorts(config *PortMapConf, containerNet net.IPNet) error
+	checkPorts(config *PortMapConf, containerNet net.IPNet) error
+	unforwardPorts(config *PortMapConf) error
+}
+
+// These are vars rather than consts so we can "&" them
+var (
+	iptablesBackend = "iptables"
+	nftablesBackend = "nftables"
+)
+
 // PortMapEntry corresponds to a single entry in the port_mappings argument,
 // see CONVENTIONS.md
 type PortMapEntry struct {
@@ -51,16 +64,23 @@ type PortMapEntry struct {
 
 type PortMapConf struct {
 	types.NetConf
-	SNAT                 *bool     `json:"snat,omitempty"`
-	ConditionsV4         *[]string `json:"conditionsV4"`
-	ConditionsV6         *[]string `json:"conditionsV6"`
-	MasqAll              bool      `json:"masqAll,omitempty"`
-	MarkMasqBit          *int      `json:"markMasqBit"`
-	ExternalSetMarkChain *string   `json:"externalSetMarkChain"`
-	RuntimeConfig        struct {
+
+	mapper PortMapper
+
+	// Generic config
+	Backend       *string   `json:"backend,omitempty"`
+	SNAT          *bool     `json:"snat,omitempty"`
+	ConditionsV4  *[]string `json:"conditionsV4"`
+	ConditionsV6  *[]string `json:"conditionsV6"`
+	MasqAll       bool      `json:"masqAll,omitempty"`
+	RuntimeConfig struct {
 		PortMaps []PortMapEntry `json:"portMappings,omitempty"`
 	} `json:"runtimeConfig,omitempty"`
 
+	// iptables-backend-specific config
+	MarkMasqBit          *int    `json:"markMasqBit"`
+	ExternalSetMarkChain *string `json:"externalSetMarkChain"`
+
 	// These are fields parsed out of the config or the environment;
 	// included here for convenience
 	ContainerID string    `json:"-"`
@@ -89,7 +109,7 @@ func cmdAdd(args *skel.CmdArgs) error {
 	netConf.ContainerID = args.ContainerID
 
 	if netConf.ContIPv4.IP != nil {
-		if err := forwardPorts(netConf, netConf.ContIPv4); err != nil {
+		if err := netConf.mapper.forwardPorts(netConf, netConf.ContIPv4); err != nil {
 			return err
 		}
 		// Delete conntrack entries for UDP to avoid conntrack blackholing traffic
@@ -98,10 +118,21 @@ func cmdAdd(args *skel.CmdArgs) error {
 		if err := deletePortmapStaleConnections(netConf.RuntimeConfig.PortMaps, unix.AF_INET); err != nil {
 			log.Printf("failed to delete stale UDP conntrack entries for %s: %v", netConf.ContIPv4.IP, err)
 		}
+
+		if *netConf.SNAT {
+			// Set the route_localnet bit on the host interface, so that
+			// 127/8 can cross a routing boundary.
+			hostIfName := getRoutableHostIF(netConf.ContIPv4.IP)
+			if hostIfName != "" {
+				if err := enableLocalnetRouting(hostIfName); err != nil {
+					return fmt.Errorf("unable to enable route_localnet: %v", err)
+				}
+			}
+		}
 	}
 
 	if netConf.ContIPv6.IP != nil {
-		if err := forwardPorts(netConf, netConf.ContIPv6); err != nil {
+		if err := netConf.mapper.forwardPorts(netConf, netConf.ContIPv6); err != nil {
 			return err
 		}
 		// Delete conntrack entries for UDP to avoid conntrack blackholing traffic
@@ -130,7 +161,7 @@ func cmdDel(args *skel.CmdArgs) error {
 
 	// We don't need to parse out whether or not we're using v6 or snat,
 	// deletion is idempotent
-	return unforwardPorts(netConf)
+	return netConf.mapper.unforwardPorts(netConf)
 }
 
 func main() {
@@ -155,13 +186,13 @@ func cmdCheck(args *skel.CmdArgs) error {
 	conf.ContainerID = args.ContainerID
 
 	if conf.ContIPv4.IP != nil {
-		if err := checkPorts(conf, conf.ContIPv4); err != nil {
+		if err := conf.mapper.checkPorts(conf, conf.ContIPv4); err != nil {
 			return err
 		}
 	}
 
 	if conf.ContIPv6.IP != nil {
-		if err := checkPorts(conf, conf.ContIPv6); err != nil {
+		if err := conf.mapper.checkPorts(conf, conf.ContIPv6); err != nil {
 			return err
 		}
 	}
@@ -196,17 +227,36 @@ func parseConfig(stdin []byte, ifName string) (*PortMapConf, *current.Result, er
 		conf.SNAT = &tvar
 	}
 
-	if conf.MarkMasqBit != nil && conf.ExternalSetMarkChain != nil {
-		return nil, nil, fmt.Errorf("Cannot specify externalSetMarkChain and markMasqBit")
+	err := validateBackend(&conf)
+	if err != nil {
+		return nil, nil, err
 	}
+	switch *conf.Backend {
+	case iptablesBackend:
+		conf.mapper = &portMapperIPTables{}
 
-	if conf.MarkMasqBit == nil {
-		bvar := DefaultMarkBit // go constants are "special"
-		conf.MarkMasqBit = &bvar
-	}
+		if conf.MarkMasqBit != nil && conf.ExternalSetMarkChain != nil {
+			return nil, nil, fmt.Errorf("Cannot specify externalSetMarkChain and markMasqBit")
+		}
+
+		if conf.MarkMasqBit == nil {
+			bvar := DefaultMarkBit // go constants are "special"
+			conf.MarkMasqBit = &bvar
+		}
+
+		if *conf.MarkMasqBit < 0 || *conf.MarkMasqBit > 31 {
+			return nil, nil, fmt.Errorf("MasqMarkBit must be between 0 and 31")
+		}
+
+	case nftablesBackend:
+		conf.mapper = &portMapperNFTables{}
+
+		if conf.MarkMasqBit != nil || conf.ExternalSetMarkChain != nil {
+			return nil, nil, fmt.Errorf("externalSetMarkChain and markMasqBit can only be specified when using iptables backend")
+		}
 
-	if *conf.MarkMasqBit < 0 || *conf.MarkMasqBit > 31 {
-		return nil, nil, fmt.Errorf("MasqMarkBit must be between 0 and 31")
+	default:
+		return nil, nil, fmt.Errorf("unrecognized backend %q", *conf.Backend)
 	}
 
 	// Reject invalid port numbers
@@ -248,3 +298,61 @@ func parseConfig(stdin []byte, ifName string) (*PortMapConf, *current.Result, er
 
 	return &conf, result, nil
 }
+
+// validateBackend validates and/or sets conf.Backend
+func validateBackend(conf *PortMapConf) error {
+	backendConfig := make(map[string][]string)
+
+	if conf.MarkMasqBit != nil {
+		backendConfig[iptablesBackend] = append(backendConfig[iptablesBackend], "markMasqBit")
+	}
+	if conf.ExternalSetMarkChain != nil {
+		backendConfig[iptablesBackend] = append(backendConfig[iptablesBackend], "externalSetMarkChain")
+	}
+	if conditionsBackend := detectBackendOfConditions(conf.ConditionsV4); conditionsBackend != "" {
+		backendConfig[conditionsBackend] = append(backendConfig[conditionsBackend], "conditionsV4")
+	}
+	if conditionsBackend := detectBackendOfConditions(conf.ConditionsV6); conditionsBackend != "" {
+		backendConfig[conditionsBackend] = append(backendConfig[conditionsBackend], "conditionsV6")
+	}
+
+	// If backend wasn't requested explicitly, default to iptables, unless it is not
+	// available (and nftables is). FIXME: flip this default at some point.
+	if conf.Backend == nil {
+		if !utils.SupportsIPTables() && utils.SupportsNFTables() {
+			conf.Backend = &nftablesBackend
+		} else {
+			conf.Backend = &iptablesBackend
+		}
+	}
+
+	// Make sure we dont have config for the wrong backend
+	var wrongBackend string
+	if *conf.Backend == iptablesBackend {
+		wrongBackend = nftablesBackend
+	} else {
+		wrongBackend = iptablesBackend
+	}
+	if len(backendConfig[wrongBackend]) > 0 {
+		return fmt.Errorf("%s backend was requested but configuration contains %s-specific options %v", *conf.Backend, wrongBackend, backendConfig[wrongBackend])
+	}
+
+	// OK
+	return nil
+}
+
+// detectBackendOfConditions returns "iptables" if conditions contains iptables
+// conditions, "nftables" if it contains nftables conditions, and "" if it is empty.
+func detectBackendOfConditions(conditions *[]string) string {
+	if conditions == nil || len(*conditions) == 0 || (*conditions)[0] == "" {
+		return ""
+	}
+
+	// The first token of any iptables condition would start with a hyphen (e.g. "-d",
+	// "--sport", "-m"). No nftables condition would start that way. (An nftables
+	// condition might include a negative number, but not as the first token.)
+	if (*conditions)[0][0] == '-' {
+		return iptablesBackend
+	}
+	return nftablesBackend
+}
diff --git a/plugins/meta/portmap/portmap.go b/plugins/meta/portmap/portmap_iptables.go
similarity index 93%
rename from plugins/meta/portmap/portmap.go
rename to plugins/meta/portmap/portmap_iptables.go
index e380da932..07d6c4209 100644
--- a/plugins/meta/portmap/portmap.go
+++ b/plugins/meta/portmap/portmap_iptables.go
@@ -25,7 +25,6 @@ import (
 	"github.com/vishvananda/netlink"
 
 	"github.com/containernetworking/plugins/pkg/utils"
-	"github.com/containernetworking/plugins/pkg/utils/sysctl"
 )
 
 // This creates the chains to be added to iptables. The basic structure is
@@ -52,9 +51,11 @@ const (
 	OldTopLevelSNATChainName = "CNI-HOSTPORT-SNAT"
 )
 
+type portMapperIPTables struct{}
+
 // forwardPorts establishes port forwarding to a given container IP.
 // containerNet.IP can be either v4 or v6.
-func forwardPorts(config *PortMapConf, containerNet net.IPNet) error {
+func (*portMapperIPTables) forwardPorts(config *PortMapConf, containerNet net.IPNet) error {
 	isV6 := (containerNet.IP.To4() == nil)
 
 	var ipt *iptables.IPTables
@@ -87,17 +88,6 @@ func forwardPorts(config *PortMapConf, containerNet net.IPNet) error {
 				return fmt.Errorf("unable to create chain %s: %v", setMarkChain.name, err)
 			}
 		}
-
-		if !isV6 {
-			// Set the route_localnet bit on the host interface, so that
-			// 127/8 can cross a routing boundary.
-			hostIfName := getRoutableHostIF(containerNet.IP)
-			if hostIfName != "" {
-				if err := enableLocalnetRouting(hostIfName); err != nil {
-					return fmt.Errorf("unable to enable route_localnet: %v", err)
-				}
-			}
-		}
 	}
 
 	// Generate the DNAT (actual port forwarding) rules
@@ -117,7 +107,7 @@ func forwardPorts(config *PortMapConf, containerNet net.IPNet) error {
 	return nil
 }
 
-func checkPorts(config *PortMapConf, containerNet net.IPNet) error {
+func (*portMapperIPTables) checkPorts(config *PortMapConf, containerNet net.IPNet) error {
 	isV6 := (containerNet.IP.To4() == nil)
 	dnatChain := genDnatChain(config.Name, config.ContainerID)
 	fillDnatRules(&dnatChain, config, containerNet)
@@ -344,14 +334,6 @@ func genMarkMasqChain(markBit int) chain {
 	return ch
 }
 
-// enableLocalnetRouting tells the kernel not to treat 127/8 as a martian,
-// so that connections with a source ip of 127/8 can cross a routing boundary.
-func enableLocalnetRouting(ifName string) error {
-	routeLocalnetPath := "net/ipv4/conf/" + ifName + "/route_localnet"
-	_, err := sysctl.Sysctl(routeLocalnetPath, "1")
-	return err
-}
-
 // genOldSnatChain is no longer used, but used to be created. We'll try and
 // tear it down in case the plugin version changed between ADD and DEL
 func genOldSnatChain(netName, containerID string) chain {
@@ -372,7 +354,7 @@ func genOldSnatChain(netName, containerID string) chain {
 // don't know which protocols were used.
 // So, we first check that iptables is "generally OK" by doing a check. If
 // not, we ignore the error, unless neither v4 nor v6 are OK.
-func unforwardPorts(config *PortMapConf) error {
+func (*portMapperIPTables) unforwardPorts(config *PortMapConf) error {
 	dnatChain := genDnatChain(config.Name, config.ContainerID)
 
 	// Might be lying around from old versions
diff --git a/plugins/meta/portmap/portmap_iptables_test.go b/plugins/meta/portmap/portmap_iptables_test.go
new file mode 100644
index 000000000..bc9bbf223
--- /dev/null
+++ b/plugins/meta/portmap/portmap_iptables_test.go
@@ -0,0 +1,252 @@
+// Copyright 2017 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"fmt"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/containernetworking/cni/pkg/types"
+)
+
+var _ = Describe("portmapping configuration (iptables)", func() {
+	netName := "testNetName"
+	containerID := "icee6giejonei6sohng6ahngee7laquohquee9shiGo7fohferakah3Feiyoolu2pei7ciPhoh7shaoX6vai3vuf0ahfaeng8yohb9ceu0daez5hashee8ooYai5wa3y"
+
+	for _, ver := range []string{"0.3.0", "0.3.1", "0.4.0", "1.0.0"} {
+		// Redefine ver inside for scope so real value is picked up by each dynamically defined It()
+		// See Gingkgo's "Patterns for dynamically generating tests" documentation.
+		ver := ver
+
+		Describe("Generating iptables chains", func() {
+			Context("for DNAT", func() {
+				It(fmt.Sprintf("[%s] generates a correct standard container chain", ver), func() {
+					ch := genDnatChain(netName, containerID)
+
+					Expect(ch).To(Equal(chain{
+						table:       "nat",
+						name:        "CNI-DN-bfd599665540dd91d5d28",
+						entryChains: []string{TopLevelDNATChainName},
+					}))
+					configBytes := []byte(fmt.Sprintf(`{
+						"name": "test",
+						"type": "portmap",
+						"cniVersion": "%s",
+						"runtimeConfig": {
+							"portMappings": [
+								{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"},
+								{ "hostPort": 8081, "containerPort": 80, "protocol": "tcp"},
+								{ "hostPort": 8080, "containerPort": 81, "protocol": "udp"},
+								{ "hostPort": 8082, "containerPort": 82, "protocol": "udp"},
+								{ "hostPort": 8083, "containerPort": 83, "protocol": "tcp", "hostIP": "192.168.0.2"},
+								{ "hostPort": 8084, "containerPort": 84, "protocol": "tcp", "hostIP": "0.0.0.0"},
+								{ "hostPort": 8085, "containerPort": 85, "protocol": "tcp", "hostIP": "2001:db8:a::1"},
+								{ "hostPort": 8086, "containerPort": 86, "protocol": "tcp", "hostIP": "::"}
+							]
+						},
+						"snat": true,
+						"conditionsV4": ["-a", "b"],
+						"conditionsV6": ["-c", "d"]
+					}`, ver))
+
+					conf, _, err := parseConfig(configBytes, "foo")
+					Expect(err).NotTo(HaveOccurred())
+					conf.ContainerID = containerID
+
+					ch = genDnatChain(conf.Name, containerID)
+					Expect(ch).To(Equal(chain{
+						table:       "nat",
+						name:        "CNI-DN-67e92b96e692a494b6b85",
+						entryChains: []string{"CNI-HOSTPORT-DNAT"},
+					}))
+
+					n, err := types.ParseCIDR("10.0.0.2/24")
+					Expect(err).NotTo(HaveOccurred())
+					fillDnatRules(&ch, conf, *n)
+
+					Expect(ch.entryRules).To(Equal([][]string{
+						{
+							"-m", "comment", "--comment",
+							fmt.Sprintf("dnat name: \"test\" id: \"%s\"", containerID),
+							"-m", "multiport",
+							"-p", "tcp",
+							"--destination-ports", "8080,8081,8083,8084,8085,8086",
+							"-a", "b",
+						},
+						{
+							"-m", "comment", "--comment",
+							fmt.Sprintf("dnat name: \"test\" id: \"%s\"", containerID),
+							"-m", "multiport",
+							"-p", "udp",
+							"--destination-ports", "8080,8082",
+							"-a", "b",
+						},
+					}))
+
+					Expect(ch.rules).To(Equal([][]string{
+						// tcp rules and not hostIP
+						{"-p", "tcp", "--dport", "8080", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8080", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
+						{"-p", "tcp", "--dport", "8081", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8081", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8081", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
+						// udp rules and not hostIP
+						{"-p", "udp", "--dport", "8080", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "udp", "--dport", "8080", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "udp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:81"},
+						{"-p", "udp", "--dport", "8082", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "udp", "--dport", "8082", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "udp", "--dport", "8082", "-j", "DNAT", "--to-destination", "10.0.0.2:82"},
+						// tcp rules and hostIP
+						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-j", "DNAT", "--to-destination", "10.0.0.2:83"},
+						// tcp rules and hostIP = "0.0.0.0"
+						{"-p", "tcp", "--dport", "8084", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8084", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8084", "-j", "DNAT", "--to-destination", "10.0.0.2:84"},
+					}))
+
+					ch.rules = nil
+					ch.entryRules = nil
+
+					n, err = types.ParseCIDR("2001:db8::2/64")
+					Expect(err).NotTo(HaveOccurred())
+					fillDnatRules(&ch, conf, *n)
+
+					Expect(ch.rules).To(Equal([][]string{
+						// tcp rules and not hostIP
+						{"-p", "tcp", "--dport", "8080", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "[2001:db8::2]:80"},
+						{"-p", "tcp", "--dport", "8081", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8081", "-j", "DNAT", "--to-destination", "[2001:db8::2]:80"},
+						// udp rules and not hostIP
+						{"-p", "udp", "--dport", "8080", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "udp", "--dport", "8080", "-j", "DNAT", "--to-destination", "[2001:db8::2]:81"},
+						{"-p", "udp", "--dport", "8082", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "udp", "--dport", "8082", "-j", "DNAT", "--to-destination", "[2001:db8::2]:82"},
+						// tcp rules and hostIP
+						{"-p", "tcp", "--dport", "8085", "-d", "2001:db8:a::1", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8085", "-d", "2001:db8:a::1", "-j", "DNAT", "--to-destination", "[2001:db8::2]:85"},
+						// tcp rules and hostIP = "::"
+						{"-p", "tcp", "--dport", "8086", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
+						{"-p", "tcp", "--dport", "8086", "-j", "DNAT", "--to-destination", "[2001:db8::2]:86"},
+					}))
+
+					// Disable snat, generate rules
+					ch.rules = nil
+					ch.entryRules = nil
+					fvar := false
+					conf.SNAT = &fvar
+
+					n, err = types.ParseCIDR("10.0.0.2/24")
+					Expect(err).NotTo(HaveOccurred())
+					fillDnatRules(&ch, conf, *n)
+					Expect(ch.rules).To(Equal([][]string{
+						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
+						{"-p", "tcp", "--dport", "8081", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
+						{"-p", "udp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:81"},
+						{"-p", "udp", "--dport", "8082", "-j", "DNAT", "--to-destination", "10.0.0.2:82"},
+						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-j", "DNAT", "--to-destination", "10.0.0.2:83"},
+						{"-p", "tcp", "--dport", "8084", "-j", "DNAT", "--to-destination", "10.0.0.2:84"},
+					}))
+				})
+
+				It(fmt.Sprintf("[%s] generates a correct chain with external mark", ver), func() {
+					ch := genDnatChain(netName, containerID)
+
+					Expect(ch).To(Equal(chain{
+						table:       "nat",
+						name:        "CNI-DN-bfd599665540dd91d5d28",
+						entryChains: []string{TopLevelDNATChainName},
+					}))
+					configBytes := []byte(fmt.Sprintf(`{
+						"name": "test",
+						"type": "portmap",
+						"cniVersion": "%s",
+						"runtimeConfig": {
+							"portMappings": [
+								{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"}
+							]
+						},
+						"externalSetMarkChain": "PLZ-SET-MARK",
+						"conditionsV4": ["-a", "b"],
+						"conditionsV6": ["-c", "d"]
+					}`, ver))
+
+					conf, _, err := parseConfig(configBytes, "foo")
+					Expect(err).NotTo(HaveOccurred())
+					conf.ContainerID = containerID
+
+					ch = genDnatChain(conf.Name, containerID)
+					n, err := types.ParseCIDR("10.0.0.2/24")
+					Expect(err).NotTo(HaveOccurred())
+					fillDnatRules(&ch, conf, *n)
+					Expect(ch.rules).To(Equal([][]string{
+						{"-p", "tcp", "--dport", "8080", "-s", "10.0.0.2/24", "-j", "PLZ-SET-MARK"},
+						{"-p", "tcp", "--dport", "8080", "-s", "127.0.0.1", "-j", "PLZ-SET-MARK"},
+						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
+					}))
+				})
+
+				It(fmt.Sprintf("[%s] generates a correct top-level chain", ver), func() {
+					ch := genToplevelDnatChain()
+
+					Expect(ch).To(Equal(chain{
+						table:       "nat",
+						name:        "CNI-HOSTPORT-DNAT",
+						entryChains: []string{"PREROUTING", "OUTPUT"},
+						entryRules:  [][]string{{"-m", "addrtype", "--dst-type", "LOCAL"}},
+					}))
+				})
+
+				It(fmt.Sprintf("[%s] generates the correct mark chains", ver), func() {
+					masqBit := 5
+					ch := genSetMarkChain(masqBit)
+					Expect(ch).To(Equal(chain{
+						table: "nat",
+						name:  "CNI-HOSTPORT-SETMARK",
+						rules: [][]string{{
+							"-m", "comment",
+							"--comment", "CNI portfwd masquerade mark",
+							"-j", "MARK",
+							"--set-xmark", "0x20/0x20",
+						}},
+					}))
+
+					ch = genMarkMasqChain(masqBit)
+					Expect(ch).To(Equal(chain{
+						table:       "nat",
+						name:        "CNI-HOSTPORT-MASQ",
+						entryChains: []string{"POSTROUTING"},
+						entryRules: [][]string{{
+							"-m", "comment",
+							"--comment", "CNI portfwd requiring masquerade",
+						}},
+						rules: [][]string{{
+							"-m", "mark",
+							"--mark", "0x20/0x20",
+							"-j", "MASQUERADE",
+						}},
+						prependEntry: true,
+					}))
+				})
+			})
+		})
+	}
+})
diff --git a/plugins/meta/portmap/portmap_nftables.go b/plugins/meta/portmap/portmap_nftables.go
new file mode 100644
index 000000000..5c66a52fb
--- /dev/null
+++ b/plugins/meta/portmap/portmap_nftables.go
@@ -0,0 +1,320 @@
+// Copyright 2023 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"context"
+	"fmt"
+	"net"
+
+	"github.com/danwinship/nftables"
+)
+
+const (
+	tableName = "cni_hostport"
+
+	hostIPHostPortsChain = "hostip_hostports"
+	hostPortsChain       = "hostports"
+	masqueradingChain    = "masquerading"
+)
+
+// The nftables portmap implementation is fairly similar to the iptables implementation:
+// we add a rule for each mapping, with a comment containing a hash of the container ID,
+// so that we can later reliably delete the rules we want. (This is important because in
+// edge cases, it's possible the plugin might see "ADD container A with IP 192.168.1.3",
+// followed by "ADD container B with IP 192.168.1.3" followed by "DEL container A with IP
+// 192.168.1.3", and we need to make sure that the DEL causes us to delete the rule for
+// container A, and not the rule for container B.) This iptables implementation actually
+// uses a separate chain per container but there's not really any need for that...
+//
+// As with pkg/ip/ipmasq_nftables_linux.go, it would be more nftables-y to have a chain
+// with a single rule doing a lookup against a map with an element per mapping, rather
+// than having a chain with a rule per mapping. But there's no easy, non-racy way to say
+// "delete the element 192.168.1.3 from the map, but only if it was added for container A,
+// not if it was added for container B".
+
+type portMapperNFTables struct {
+	ipv4 nftables.Interface
+	ipv6 nftables.Interface
+}
+
+// getPortMapNFT creates an nftables.Interface for port mapping for the IP family of ipn
+func (pmNFT *portMapperNFTables) getPortMapNFT(ipv6 bool) nftables.Interface {
+	if ipv6 {
+		if pmNFT.ipv6 == nil {
+			pmNFT.ipv6 = nftables.New(nftables.IPv6Family, tableName)
+		}
+		return pmNFT.ipv6
+	}
+
+	if pmNFT.ipv4 == nil {
+		pmNFT.ipv4 = nftables.New(nftables.IPv4Family, tableName)
+	}
+	return pmNFT.ipv4
+}
+
+// forwardPorts establishes port forwarding to a given container IP.
+// containerNet.IP can be either v4 or v6.
+func (pmNFT *portMapperNFTables) forwardPorts(config *PortMapConf, containerNet net.IPNet) error {
+	isV6 := (containerNet.IP.To4() == nil)
+	nft := pmNFT.getPortMapNFT(isV6)
+	var conditions []string
+	if isV6 && config.ConditionsV6 != nil {
+		conditions = *config.ConditionsV6
+	} else if !isV6 && config.ConditionsV4 != nil {
+		conditions = *config.ConditionsV4
+	}
+
+	tx := nftables.NewTransaction()
+
+	// Ensure basic rule structure
+	tx.Add(&nftables.Table{
+		Comment: nftables.Optional("CNI portmap plugin"),
+	})
+
+	tx.Add(&nftables.Chain{
+		Name: "hostports",
+	})
+	tx.Add(&nftables.Chain{
+		Name: "hostip_hostports",
+	})
+
+	tx.Add(&nftables.Chain{
+		Name:     "prerouting",
+		Type:     nftables.Optional(nftables.NATType),
+		Hook:     nftables.Optional(nftables.PreroutingHook),
+		Priority: nftables.Optional(nftables.DNATPriority),
+	})
+	tx.Flush(&nftables.Chain{
+		Name: "prerouting",
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "prerouting",
+		Rule: nftables.Concat(
+			conditions,
+			"jump", hostIPHostPortsChain,
+		),
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "prerouting",
+		Rule: nftables.Concat(
+			conditions,
+			"jump", hostPortsChain,
+		),
+	})
+
+	tx.Add(&nftables.Chain{
+		Name: "output",
+		Type: nftables.Optional(nftables.NATType),
+		Hook: nftables.Optional(nftables.OutputHook),
+
+		// DNATPriority is not allowed on OutputHook, even though the "dnat"
+		// command is. Specify the numeric value instead...
+		Priority: nftables.Optional(nftables.BaseChainPriority("-100")),
+	})
+	tx.Flush(&nftables.Chain{
+		Name: "output",
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "output",
+		Rule: nftables.Concat(
+			conditions,
+			"jump", hostIPHostPortsChain,
+		),
+	})
+	tx.Add(&nftables.Rule{
+		Chain: "output",
+		Rule: nftables.Concat(
+			conditions,
+			"fib daddr type local",
+			"jump", hostPortsChain,
+		),
+	})
+
+	if *config.SNAT {
+		tx.Add(&nftables.Chain{
+			Name:     masqueradingChain,
+			Type:     nftables.Optional(nftables.NATType),
+			Hook:     nftables.Optional(nftables.PostroutingHook),
+			Priority: nftables.Optional(nftables.SNATPriority),
+		})
+	}
+
+	// Set up this container
+	for _, e := range config.RuntimeConfig.PortMaps {
+		useHostIP := false
+		if e.HostIP != "" {
+			hostIP := net.ParseIP(e.HostIP)
+			isHostV6 := (hostIP.To4() == nil)
+			// Ignore wrong-IP-family HostIPs
+			if isV6 != isHostV6 {
+				continue
+			}
+
+			// Unspecified addresses cannot be used as destination
+			useHostIP = !hostIP.IsUnspecified()
+		}
+
+		if useHostIP {
+			tx.Add(&nftables.Rule{
+				Chain: hostIPHostPortsChain,
+				Rule: nftables.Concat(
+					"$IP daddr", e.HostIP,
+					"$IP protocol", e.Protocol,
+					"th dport", e.HostPort,
+					"dnat $IP addr . port to", containerNet.IP, ".", e.ContainerPort,
+				),
+				Comment: &config.ContainerID,
+			})
+		} else {
+			tx.Add(&nftables.Rule{
+				Chain: hostPortsChain,
+				Rule: nftables.Concat(
+					"$IP protocol", e.Protocol,
+					"th dport", e.HostPort,
+					"dnat $IP addr . port to", containerNet.IP, ".", e.ContainerPort,
+				),
+				Comment: &config.ContainerID,
+			})
+		}
+	}
+
+	if *config.SNAT {
+		// Add mark-to-masquerade rules for hairpin and localhost
+		// In theory we should validate that the original dst IP and port are as
+		// expected, but *any* traffic matching one of these patterns would need
+		// to be masqueraded to be able to work correctly anyway.
+		tx.Add(&nftables.Rule{
+			Chain: masqueradingChain,
+			Rule: nftables.Concat(
+				"$IP saddr", containerNet.IP,
+				"$IP daddr", containerNet.IP,
+				"masquerade",
+			),
+			Comment: &config.ContainerID,
+		})
+		if !isV6 {
+			tx.Add(&nftables.Rule{
+				Chain: masqueradingChain,
+				Rule: nftables.Concat(
+					"$IP saddr 127.0.0.1",
+					"$IP daddr", containerNet.IP,
+					"masquerade",
+				),
+				Comment: &config.ContainerID,
+			})
+		}
+	}
+
+	err := nft.Run(context.TODO(), tx)
+	if err != nil {
+		return fmt.Errorf("unable to set up nftables rules for port mappings: %v", err)
+	}
+
+	return nil
+}
+
+func (pmNFT *portMapperNFTables) checkPorts(config *PortMapConf, containerNet net.IPNet) error {
+	isV6 := (containerNet.IP.To4() == nil)
+
+	var hostPorts, hostIPHostPorts, masqueradings int
+	for _, e := range config.RuntimeConfig.PortMaps {
+		if e.HostIP != "" {
+			hostIPHostPorts++
+		} else {
+			hostPorts++
+		}
+	}
+	if *config.SNAT {
+		masqueradings = len(config.RuntimeConfig.PortMaps)
+		if isV6 {
+			masqueradings *= 2
+		}
+	}
+
+	nft := pmNFT.getPortMapNFT(isV6)
+	if hostPorts > 0 {
+		err := checkPortsAgainstRules(nft, hostPortsChain, config.ContainerID, hostPorts)
+		if err != nil {
+			return err
+		}
+	}
+	if hostIPHostPorts > 0 {
+		err := checkPortsAgainstRules(nft, hostIPHostPortsChain, config.ContainerID, hostIPHostPorts)
+		if err != nil {
+			return err
+		}
+	}
+	if masqueradings > 0 {
+		err := checkPortsAgainstRules(nft, masqueradingChain, config.ContainerID, masqueradings)
+		if err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func checkPortsAgainstRules(nft nftables.Interface, chain, comment string, nPorts int) error {
+	rules, err := nft.ListRules(context.TODO(), chain)
+	if err != nil {
+		return err
+	}
+
+	found := 0
+	for _, r := range rules {
+		if r.Comment != nil && *r.Comment == comment {
+			found++
+		}
+	}
+	if found < nPorts {
+		return fmt.Errorf("missing hostport rules in %q chain", chain)
+	}
+
+	return nil
+}
+
+// unforwardPorts deletes any nftables rules created by this plugin.
+// It should be idempotent - it will not error if the chain does not exist.
+func (pmNFT *portMapperNFTables) unforwardPorts(config *PortMapConf) error {
+	// Always clear both IPv4 and IPv6, just to be sure
+	for _, family := range []nftables.Family{nftables.IPv4Family, nftables.IPv6Family} {
+		nft := pmNFT.getPortMapNFT(family == nftables.IPv6Family)
+
+		tx := nftables.NewTransaction()
+		for _, chain := range []string{hostPortsChain, hostIPHostPortsChain, masqueradingChain} {
+			rules, err := nft.ListRules(context.TODO(), chain)
+			if err != nil {
+				if nftables.IsNotFound(err) {
+					continue
+				}
+				return fmt.Errorf("could not list rules in table %s: %w", tableName, err)
+			}
+
+			for _, r := range rules {
+				if r.Comment != nil && *r.Comment == config.ContainerID {
+					tx.Delete(r)
+				}
+			}
+		}
+
+		err := nft.Run(context.TODO(), tx)
+		if err != nil {
+			return fmt.Errorf("error deleting nftables rules: %w", err)
+		}
+	}
+
+	return nil
+}
diff --git a/plugins/meta/portmap/portmap_nftables_test.go b/plugins/meta/portmap/portmap_nftables_test.go
new file mode 100644
index 000000000..61999fddf
--- /dev/null
+++ b/plugins/meta/portmap/portmap_nftables_test.go
@@ -0,0 +1,134 @@
+// Copyright 2023 CNI authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/danwinship/nftables"
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/containernetworking/cni/pkg/types"
+)
+
+var _ = Describe("portmapping configuration (nftables)", func() {
+	containerID := "icee6giejonei6so"
+
+	for _, ver := range []string{"0.3.0", "0.3.1", "0.4.0", "1.0.0"} {
+		// Redefine ver inside for scope so real value is picked up by each dynamically defined It()
+		// See Gingkgo's "Patterns for dynamically generating tests" documentation.
+		ver := ver
+
+		Describe("nftables rules", func() {
+			var pmNFT *portMapperNFTables
+			var ipv4Fake, ipv6Fake *nftables.Fake
+			BeforeEach(func() {
+				ipv4Fake = nftables.NewFake(nftables.IPv4Family, tableName)
+				ipv6Fake = nftables.NewFake(nftables.IPv6Family, tableName)
+				pmNFT = &portMapperNFTables{
+					ipv4: ipv4Fake,
+					ipv6: ipv6Fake,
+				}
+			})
+
+			It(fmt.Sprintf("[%s] generates correct rules on ADD", ver), func() {
+				configBytes := []byte(fmt.Sprintf(`{
+					"name": "test",
+					"type": "portmap",
+					"cniVersion": "%s",
+					"backend": "nftables",
+					"runtimeConfig": {
+						"portMappings": [
+							{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"},
+							{ "hostPort": 8081, "containerPort": 80, "protocol": "tcp"},
+							{ "hostPort": 8080, "containerPort": 81, "protocol": "udp"},
+							{ "hostPort": 8082, "containerPort": 82, "protocol": "udp"},
+							{ "hostPort": 8083, "containerPort": 83, "protocol": "tcp", "hostIP": "192.168.0.2"},
+							{ "hostPort": 8084, "containerPort": 84, "protocol": "tcp", "hostIP": "0.0.0.0"},
+							{ "hostPort": 8085, "containerPort": 85, "protocol": "tcp", "hostIP": "2001:db8:a::1"},
+							{ "hostPort": 8086, "containerPort": 86, "protocol": "tcp", "hostIP": "::"}
+						]
+					},
+					"snat": true,
+					"conditionsV4": ["a", "b"],
+					"conditionsV6": ["c", "d"]
+				}`, ver))
+
+				conf, _, err := parseConfig(configBytes, "foo")
+				Expect(err).NotTo(HaveOccurred())
+				conf.ContainerID = containerID
+
+				containerNet, err := types.ParseCIDR("10.0.0.2/24")
+				Expect(err).NotTo(HaveOccurred())
+
+				err = pmNFT.forwardPorts(conf, *containerNet)
+				Expect(err).NotTo(HaveOccurred())
+
+				expectedRules := strings.TrimSpace(`
+add table ip cni_hostport { comment "CNI portmap plugin" ; }
+add chain ip cni_hostport hostip_hostports
+add rule ip cni_hostport hostip_hostports ip daddr 192.168.0.2 ip protocol tcp th dport 8083 dnat ip addr . port to 10.0.0.2 . 83 comment "icee6giejonei6so"
+add chain ip cni_hostport hostports
+add rule ip cni_hostport hostports ip protocol tcp th dport 8080 dnat ip addr . port to 10.0.0.2 . 80 comment "icee6giejonei6so"
+add rule ip cni_hostport hostports ip protocol tcp th dport 8081 dnat ip addr . port to 10.0.0.2 . 80 comment "icee6giejonei6so"
+add rule ip cni_hostport hostports ip protocol udp th dport 8080 dnat ip addr . port to 10.0.0.2 . 81 comment "icee6giejonei6so"
+add rule ip cni_hostport hostports ip protocol udp th dport 8082 dnat ip addr . port to 10.0.0.2 . 82 comment "icee6giejonei6so"
+add rule ip cni_hostport hostports ip protocol tcp th dport 8084 dnat ip addr . port to 10.0.0.2 . 84 comment "icee6giejonei6so"
+add chain ip cni_hostport masquerading { type nat hook postrouting priority srcnat ; }
+add rule ip cni_hostport masquerading ip saddr 10.0.0.2 ip daddr 10.0.0.2 masquerade comment "icee6giejonei6so"
+add rule ip cni_hostport masquerading ip saddr 127.0.0.1 ip daddr 10.0.0.2 masquerade comment "icee6giejonei6so"
+add chain ip cni_hostport output { type nat hook output priority -100 ; }
+add rule ip cni_hostport output a b jump hostip_hostports
+add rule ip cni_hostport output a b fib daddr type local jump hostports
+add chain ip cni_hostport prerouting { type nat hook prerouting priority dstnat ; }
+add rule ip cni_hostport prerouting a b jump hostip_hostports
+add rule ip cni_hostport prerouting a b jump hostports
+`)
+				actualRules := strings.TrimSpace(ipv4Fake.Dump())
+				Expect(actualRules).To(Equal(expectedRules))
+
+				// Disable snat, generate IPv6 rules
+				*conf.SNAT = false
+				containerNet, err = types.ParseCIDR("2001:db8::2/64")
+				Expect(err).NotTo(HaveOccurred())
+
+				err = pmNFT.forwardPorts(conf, *containerNet)
+				Expect(err).NotTo(HaveOccurred())
+
+				expectedRules = strings.TrimSpace(`
+add table ip6 cni_hostport { comment "CNI portmap plugin" ; }
+add chain ip6 cni_hostport hostip_hostports
+add rule ip6 cni_hostport hostip_hostports ip6 daddr 2001:db8:a::1 ip6 protocol tcp th dport 8085 dnat ip6 addr . port to 2001:db8::2 . 85 comment "icee6giejonei6so"
+add chain ip6 cni_hostport hostports
+add rule ip6 cni_hostport hostports ip6 protocol tcp th dport 8080 dnat ip6 addr . port to 2001:db8::2 . 80 comment "icee6giejonei6so"
+add rule ip6 cni_hostport hostports ip6 protocol tcp th dport 8081 dnat ip6 addr . port to 2001:db8::2 . 80 comment "icee6giejonei6so"
+add rule ip6 cni_hostport hostports ip6 protocol udp th dport 8080 dnat ip6 addr . port to 2001:db8::2 . 81 comment "icee6giejonei6so"
+add rule ip6 cni_hostport hostports ip6 protocol udp th dport 8082 dnat ip6 addr . port to 2001:db8::2 . 82 comment "icee6giejonei6so"
+add rule ip6 cni_hostport hostports ip6 protocol tcp th dport 8086 dnat ip6 addr . port to 2001:db8::2 . 86 comment "icee6giejonei6so"
+add chain ip6 cni_hostport output { type nat hook output priority -100 ; }
+add rule ip6 cni_hostport output c d jump hostip_hostports
+add rule ip6 cni_hostport output c d fib daddr type local jump hostports
+add chain ip6 cni_hostport prerouting { type nat hook prerouting priority dstnat ; }
+add rule ip6 cni_hostport prerouting c d jump hostip_hostports
+add rule ip6 cni_hostport prerouting c d jump hostports
+`)
+				actualRules = strings.TrimSpace(ipv6Fake.Dump())
+				Expect(actualRules).To(Equal(expectedRules))
+			})
+		})
+	}
+})
diff --git a/plugins/meta/portmap/portmap_test.go b/plugins/meta/portmap/portmap_test.go
index 4897fe632..3c41f8a0d 100644
--- a/plugins/meta/portmap/portmap_test.go
+++ b/plugins/meta/portmap/portmap_test.go
@@ -24,9 +24,6 @@ import (
 )
 
 var _ = Describe("portmapping configuration", func() {
-	netName := "testNetName"
-	containerID := "icee6giejonei6sohng6ahngee7laquohquee9shiGo7fohferakah3Feiyoolu2pei7ciPhoh7shaoX6vai3vuf0ahfaeng8yohb9ceu0daez5hashee8ooYai5wa3y"
-
 	for _, ver := range []string{"0.3.0", "0.3.1", "0.4.0", "1.0.0"} {
 		// Redefine ver inside for scope so real value is picked up by each dynamically defined It()
 		// See Gingkgo's "Patterns for dynamically generating tests" documentation.
@@ -38,6 +35,7 @@ var _ = Describe("portmapping configuration", func() {
 					"name": "test",
 					"type": "portmap",
 					"cniVersion": "%s",
+					"backend": "iptables",
 					"runtimeConfig": {
 						"portMappings": [
 							{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"},
@@ -45,8 +43,8 @@ var _ = Describe("portmapping configuration", func() {
 						]
 					},
 					"snat": false,
-					"conditionsV4": ["a", "b"],
-					"conditionsV6": ["c", "d"],
+					"conditionsV4": ["-a", "b"],
+					"conditionsV6": ["-c", "d"],
 					"prevResult": {
 						"interfaces": [
 							{"name": "host"},
@@ -77,8 +75,8 @@ var _ = Describe("portmapping configuration", func() {
 				c, _, err := parseConfig(configBytes, "container")
 				Expect(err).NotTo(HaveOccurred())
 				Expect(c.CNIVersion).To(Equal(ver))
-				Expect(c.ConditionsV4).To(Equal(&[]string{"a", "b"}))
-				Expect(c.ConditionsV6).To(Equal(&[]string{"c", "d"}))
+				Expect(c.ConditionsV4).To(Equal(&[]string{"-a", "b"}))
+				Expect(c.ConditionsV6).To(Equal(&[]string{"-c", "d"}))
 				fvar := false
 				Expect(c.SNAT).To(Equal(&fvar))
 				Expect(c.Name).To(Equal("test"))
@@ -97,15 +95,16 @@ var _ = Describe("portmapping configuration", func() {
 					"name": "test",
 					"type": "portmap",
 					"cniVersion": "%s",
+					"backend": "iptables",
 					"snat": false,
-					"conditionsV4": ["a", "b"],
-					"conditionsV6": ["c", "d"]
+					"conditionsV4": ["-a", "b"],
+					"conditionsV6": ["-c", "d"]
 				}`, ver))
 				c, _, err := parseConfig(configBytes, "container")
 				Expect(err).NotTo(HaveOccurred())
 				Expect(c.CNIVersion).To(Equal(ver))
-				Expect(c.ConditionsV4).To(Equal(&[]string{"a", "b"}))
-				Expect(c.ConditionsV6).To(Equal(&[]string{"c", "d"}))
+				Expect(c.ConditionsV4).To(Equal(&[]string{"-a", "b"}))
+				Expect(c.ConditionsV6).To(Equal(&[]string{"-c", "d"}))
 				fvar := false
 				Expect(c.SNAT).To(Equal(&fvar))
 				Expect(c.Name).To(Equal("test"))
@@ -116,9 +115,10 @@ var _ = Describe("portmapping configuration", func() {
 					"name": "test",
 					"type": "portmap",
 					"cniVersion": "%s",
+					"backend": "iptables",
 					"snat": false,
-					"conditionsV4": ["a", "b"],
-					"conditionsV6": ["c", "d"],
+					"conditionsV4": ["-a", "b"],
+					"conditionsV6": ["-c", "d"],
 					"runtimeConfig": {
 						"portMappings": [
 							{ "hostPort": 0, "containerPort": 80, "protocol": "tcp"}
@@ -129,6 +129,83 @@ var _ = Describe("portmapping configuration", func() {
 				Expect(err).To(MatchError("Invalid host port number: 0"))
 			})
 
+			It(fmt.Sprintf("[%s] defaults to iptables when backend is not specified", ver), func() {
+				// "defaults to iptables" is only true if iptables is installed
+				// (or if neither iptables nor nftables is installed), but the
+				// other unit tests would fail if iptables wasn't installed, so
+				// we know it must be.
+				configBytes := []byte(fmt.Sprintf(`{
+					"name": "test",
+					"type": "portmap",
+					"cniVersion": "%s"
+				}`, ver))
+				c, _, err := parseConfig(configBytes, "container")
+				Expect(err).NotTo(HaveOccurred())
+				Expect(c.CNIVersion).To(Equal(ver))
+				Expect(c.Backend).To(Equal(&iptablesBackend))
+				Expect(c.Name).To(Equal("test"))
+			})
+
+			It(fmt.Sprintf("[%s] uses nftables if requested", ver), func() {
+				configBytes := []byte(fmt.Sprintf(`{
+					"name": "test",
+					"type": "portmap",
+					"cniVersion": "%s",
+					"backend": "nftables"
+				}`, ver))
+				c, _, err := parseConfig(configBytes, "container")
+				Expect(err).NotTo(HaveOccurred())
+				Expect(c.CNIVersion).To(Equal(ver))
+				Expect(c.Backend).To(Equal(&nftablesBackend))
+				Expect(c.Name).To(Equal("test"))
+			})
+
+			It(fmt.Sprintf("[%s] allows nftables conditions if nftables is requested", ver), func() {
+				configBytes := []byte(fmt.Sprintf(`{
+					"name": "test",
+					"type": "portmap",
+					"cniVersion": "%s",
+					"backend": "nftables",
+					"conditionsV4": ["aaa", "bbbb"],
+					"conditionsV6": ["ccc"]
+				}`, ver))
+				c, _, err := parseConfig(configBytes, "container")
+				Expect(err).NotTo(HaveOccurred())
+				Expect(c.CNIVersion).To(Equal(ver))
+				Expect(c.Backend).To(Equal(&nftablesBackend))
+				Expect(c.ConditionsV4).To(Equal(&[]string{"aaa", "bbbb"}))
+				Expect(c.ConditionsV6).To(Equal(&[]string{"ccc"}))
+				Expect(c.Name).To(Equal("test"))
+			})
+
+			It(fmt.Sprintf("[%s] rejects nftables options with 'backend: iptables'", ver), func() {
+				configBytes := []byte(fmt.Sprintf(`{
+					"name": "test",
+					"type": "portmap",
+					"cniVersion": "%s",
+					"backend": "iptables",
+					"conditionsV4": ["aaa", "bbbb"],
+					"conditionsV6": ["ccc"]
+				}`, ver))
+				_, _, err := parseConfig(configBytes, "container")
+				Expect(err).To(MatchError("iptables backend was requested but configuration contains nftables-specific options [conditionsV4 conditionsV6]"))
+			})
+
+			It(fmt.Sprintf("[%s] rejects iptables options with 'backend: nftables'", ver), func() {
+				configBytes := []byte(fmt.Sprintf(`{
+					"name": "test",
+					"type": "portmap",
+					"cniVersion": "%s",
+					"backend": "nftables",
+					"markMasqBit": 5,
+					"externalSetMarkChain": "KUBE-MARK-MASQ",
+					"conditionsV4": ["-a", "b"],
+					"conditionsV6": ["-c", "d"]
+				}`, ver))
+				_, _, err := parseConfig(configBytes, "container")
+				Expect(err).To(MatchError("nftables backend was requested but configuration contains iptables-specific options [markMasqBit externalSetMarkChain conditionsV4 conditionsV6]"))
+			})
+
 			It(fmt.Sprintf("[%s] does not fail on missing prevResult interface index", ver), func() {
 				configBytes := []byte(fmt.Sprintf(`{
 					"name": "test",
@@ -139,7 +216,7 @@ var _ = Describe("portmapping configuration", func() {
 							{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"}
 						]
 					},
-					"conditionsV4": ["a", "b"],
+					"conditionsV4": ["-a", "b"],
 					"prevResult": {
 						"interfaces": [
 							{"name": "host"}
@@ -157,222 +234,5 @@ var _ = Describe("portmapping configuration", func() {
 				Expect(err).NotTo(HaveOccurred())
 			})
 		})
-
-		Describe("Generating chains", func() {
-			Context("for DNAT", func() {
-				It(fmt.Sprintf("[%s] generates a correct standard container chain", ver), func() {
-					ch := genDnatChain(netName, containerID)
-
-					Expect(ch).To(Equal(chain{
-						table:       "nat",
-						name:        "CNI-DN-bfd599665540dd91d5d28",
-						entryChains: []string{TopLevelDNATChainName},
-					}))
-					configBytes := []byte(fmt.Sprintf(`{
-						"name": "test",
-						"type": "portmap",
-						"cniVersion": "%s",
-						"runtimeConfig": {
-							"portMappings": [
-								{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"},
-								{ "hostPort": 8081, "containerPort": 80, "protocol": "tcp"},
-								{ "hostPort": 8080, "containerPort": 81, "protocol": "udp"},
-								{ "hostPort": 8082, "containerPort": 82, "protocol": "udp"},
-								{ "hostPort": 8083, "containerPort": 83, "protocol": "tcp", "hostIP": "192.168.0.2"},
-								{ "hostPort": 8084, "containerPort": 84, "protocol": "tcp", "hostIP": "0.0.0.0"},
-								{ "hostPort": 8085, "containerPort": 85, "protocol": "tcp", "hostIP": "2001:db8:a::1"},
-								{ "hostPort": 8086, "containerPort": 86, "protocol": "tcp", "hostIP": "::"}
-							]
-						},
-						"snat": true,
-						"conditionsV4": ["a", "b"],
-						"conditionsV6": ["c", "d"]
-					}`, ver))
-
-					conf, _, err := parseConfig(configBytes, "foo")
-					Expect(err).NotTo(HaveOccurred())
-					conf.ContainerID = containerID
-
-					ch = genDnatChain(conf.Name, containerID)
-					Expect(ch).To(Equal(chain{
-						table:       "nat",
-						name:        "CNI-DN-67e92b96e692a494b6b85",
-						entryChains: []string{"CNI-HOSTPORT-DNAT"},
-					}))
-
-					n, err := types.ParseCIDR("10.0.0.2/24")
-					Expect(err).NotTo(HaveOccurred())
-					fillDnatRules(&ch, conf, *n)
-
-					Expect(ch.entryRules).To(Equal([][]string{
-						{
-							"-m", "comment", "--comment",
-							fmt.Sprintf("dnat name: \"test\" id: \"%s\"", containerID),
-							"-m", "multiport",
-							"-p", "tcp",
-							"--destination-ports", "8080,8081,8083,8084,8085,8086",
-							"a", "b",
-						},
-						{
-							"-m", "comment", "--comment",
-							fmt.Sprintf("dnat name: \"test\" id: \"%s\"", containerID),
-							"-m", "multiport",
-							"-p", "udp",
-							"--destination-ports", "8080,8082",
-							"a", "b",
-						},
-					}))
-
-					Expect(ch.rules).To(Equal([][]string{
-						// tcp rules and not hostIP
-						{"-p", "tcp", "--dport", "8080", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8080", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
-						{"-p", "tcp", "--dport", "8081", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8081", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8081", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
-						// udp rules and not hostIP
-						{"-p", "udp", "--dport", "8080", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "udp", "--dport", "8080", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "udp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:81"},
-						{"-p", "udp", "--dport", "8082", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "udp", "--dport", "8082", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "udp", "--dport", "8082", "-j", "DNAT", "--to-destination", "10.0.0.2:82"},
-						// tcp rules and hostIP
-						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-j", "DNAT", "--to-destination", "10.0.0.2:83"},
-						// tcp rules and hostIP = "0.0.0.0"
-						{"-p", "tcp", "--dport", "8084", "-s", "10.0.0.2/24", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8084", "-s", "127.0.0.1", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8084", "-j", "DNAT", "--to-destination", "10.0.0.2:84"},
-					}))
-
-					ch.rules = nil
-					ch.entryRules = nil
-
-					n, err = types.ParseCIDR("2001:db8::2/64")
-					Expect(err).NotTo(HaveOccurred())
-					fillDnatRules(&ch, conf, *n)
-
-					Expect(ch.rules).To(Equal([][]string{
-						// tcp rules and not hostIP
-						{"-p", "tcp", "--dport", "8080", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "[2001:db8::2]:80"},
-						{"-p", "tcp", "--dport", "8081", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8081", "-j", "DNAT", "--to-destination", "[2001:db8::2]:80"},
-						// udp rules and not hostIP
-						{"-p", "udp", "--dport", "8080", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "udp", "--dport", "8080", "-j", "DNAT", "--to-destination", "[2001:db8::2]:81"},
-						{"-p", "udp", "--dport", "8082", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "udp", "--dport", "8082", "-j", "DNAT", "--to-destination", "[2001:db8::2]:82"},
-						// tcp rules and hostIP
-						{"-p", "tcp", "--dport", "8085", "-d", "2001:db8:a::1", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8085", "-d", "2001:db8:a::1", "-j", "DNAT", "--to-destination", "[2001:db8::2]:85"},
-						// tcp rules and hostIP = "::"
-						{"-p", "tcp", "--dport", "8086", "-s", "2001:db8::2/64", "-j", "CNI-HOSTPORT-SETMARK"},
-						{"-p", "tcp", "--dport", "8086", "-j", "DNAT", "--to-destination", "[2001:db8::2]:86"},
-					}))
-
-					// Disable snat, generate rules
-					ch.rules = nil
-					ch.entryRules = nil
-					fvar := false
-					conf.SNAT = &fvar
-
-					n, err = types.ParseCIDR("10.0.0.2/24")
-					Expect(err).NotTo(HaveOccurred())
-					fillDnatRules(&ch, conf, *n)
-					Expect(ch.rules).To(Equal([][]string{
-						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
-						{"-p", "tcp", "--dport", "8081", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
-						{"-p", "udp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:81"},
-						{"-p", "udp", "--dport", "8082", "-j", "DNAT", "--to-destination", "10.0.0.2:82"},
-						{"-p", "tcp", "--dport", "8083", "-d", "192.168.0.2", "-j", "DNAT", "--to-destination", "10.0.0.2:83"},
-						{"-p", "tcp", "--dport", "8084", "-j", "DNAT", "--to-destination", "10.0.0.2:84"},
-					}))
-				})
-
-				It(fmt.Sprintf("[%s] generates a correct chain with external mark", ver), func() {
-					ch := genDnatChain(netName, containerID)
-
-					Expect(ch).To(Equal(chain{
-						table:       "nat",
-						name:        "CNI-DN-bfd599665540dd91d5d28",
-						entryChains: []string{TopLevelDNATChainName},
-					}))
-					configBytes := []byte(fmt.Sprintf(`{
-						"name": "test",
-						"type": "portmap",
-						"cniVersion": "%s",
-						"runtimeConfig": {
-							"portMappings": [
-								{ "hostPort": 8080, "containerPort": 80, "protocol": "tcp"}
-							]
-						},
-						"externalSetMarkChain": "PLZ-SET-MARK",
-						"conditionsV4": ["a", "b"],
-						"conditionsV6": ["c", "d"]
-					}`, ver))
-
-					conf, _, err := parseConfig(configBytes, "foo")
-					Expect(err).NotTo(HaveOccurred())
-					conf.ContainerID = containerID
-
-					ch = genDnatChain(conf.Name, containerID)
-					n, err := types.ParseCIDR("10.0.0.2/24")
-					Expect(err).NotTo(HaveOccurred())
-					fillDnatRules(&ch, conf, *n)
-					Expect(ch.rules).To(Equal([][]string{
-						{"-p", "tcp", "--dport", "8080", "-s", "10.0.0.2/24", "-j", "PLZ-SET-MARK"},
-						{"-p", "tcp", "--dport", "8080", "-s", "127.0.0.1", "-j", "PLZ-SET-MARK"},
-						{"-p", "tcp", "--dport", "8080", "-j", "DNAT", "--to-destination", "10.0.0.2:80"},
-					}))
-				})
-
-				It(fmt.Sprintf("[%s] generates a correct top-level chain", ver), func() {
-					ch := genToplevelDnatChain()
-
-					Expect(ch).To(Equal(chain{
-						table:       "nat",
-						name:        "CNI-HOSTPORT-DNAT",
-						entryChains: []string{"PREROUTING", "OUTPUT"},
-						entryRules:  [][]string{{"-m", "addrtype", "--dst-type", "LOCAL"}},
-					}))
-				})
-
-				It(fmt.Sprintf("[%s] generates the correct mark chains", ver), func() {
-					masqBit := 5
-					ch := genSetMarkChain(masqBit)
-					Expect(ch).To(Equal(chain{
-						table: "nat",
-						name:  "CNI-HOSTPORT-SETMARK",
-						rules: [][]string{{
-							"-m", "comment",
-							"--comment", "CNI portfwd masquerade mark",
-							"-j", "MARK",
-							"--set-xmark", "0x20/0x20",
-						}},
-					}))
-
-					ch = genMarkMasqChain(masqBit)
-					Expect(ch).To(Equal(chain{
-						table:       "nat",
-						name:        "CNI-HOSTPORT-MASQ",
-						entryChains: []string{"POSTROUTING"},
-						entryRules: [][]string{{
-							"-m", "comment",
-							"--comment", "CNI portfwd requiring masquerade",
-						}},
-						rules: [][]string{{
-							"-m", "mark",
-							"--mark", "0x20/0x20",
-							"-j", "MASQUERADE",
-						}},
-						prependEntry: true,
-					}))
-				})
-			})
-		})
 	}
 })
diff --git a/plugins/meta/portmap/utils.go b/plugins/meta/portmap/utils.go
index e6709089d..922705579 100644
--- a/plugins/meta/portmap/utils.go
+++ b/plugins/meta/portmap/utils.go
@@ -21,6 +21,8 @@ import (
 	"strings"
 
 	"github.com/vishvananda/netlink"
+
+	"github.com/containernetworking/plugins/pkg/utils/sysctl"
 )
 
 // fmtIpPort correctly formats ip:port literals for iptables and ip6tables -
@@ -52,6 +54,14 @@ func getRoutableHostIF(containerIP net.IP) string {
 	return ""
 }
 
+// enableLocalnetRouting tells the kernel not to treat 127/8 as a martian,
+// so that connections with a source ip of 127/8 can cross a routing boundary.
+func enableLocalnetRouting(ifName string) error {
+	routeLocalnetPath := "net/ipv4/conf/" + ifName + "/route_localnet"
+	_, err := sysctl.Sysctl(routeLocalnetPath, "1")
+	return err
+}
+
 // groupByProto groups port numbers by protocol
 func groupByProto(entries []PortMapEntry) map[string][]int {
 	if len(entries) == 0 {
diff --git a/vendor/github.com/danwinship/nftables/LICENSE b/vendor/github.com/danwinship/nftables/LICENSE
new file mode 100644
index 000000000..261eeb9e9
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/vendor/github.com/danwinship/nftables/README.md b/vendor/github.com/danwinship/nftables/README.md
new file mode 100644
index 000000000..1c92a1435
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/README.md
@@ -0,0 +1,199 @@
+# golang nftables library
+
+This is a library for using nftables from Go.
+
+It is not intended to support arbitrary use cases, but instead
+specifically focuses on supporing Kubernetes components which are
+using nftables in the way that nftables is supposed to be used (as
+opposed to using nftables in a naively-translated-from-iptables way,
+or using nftables to do totally valid things that aren't the sorts of
+things Kubernetes components are likely to need to do).
+
+It is still under development and is not API stable.
+
+## Usage
+
+Create an `Interface` object to manage operations on a single nftables
+table:
+
+```golang
+nft := nftables.New(nftables.IPv4Family, "my-table")
+
+// Make sure nftables actually works here
+if err := nft.Present(); err != nil {
+        return fmt.Errorf("no nftables support: %v", err)
+}
+```
+
+The `Define` method can be used to add defines (as with `nft -D
+name=value`) to an `Interface` which can then be referenced with
+`$name` in transactions. If you are using `IPv4Family` or `IPv6Family`
+then you automatically get the defines `IP` (`"ip"` or `"ip6"`) and
+`INET_ADDR` (`"ipv4_addr"` or `"ipv6_addr"`) which can be used to
+allow the same rules and set/map definitions to be used for IPv4 and
+IPv6.
+
+You can use the `List`, `ListRules`, and `ListElements` methods on the
+`Interface` to check if objects exist. `List` returns the names of
+`"chains"`, `"sets"`, or `"maps"` in the table, while `ListRules` and
+`ListElements` return `Rule` and `Element` objects.
+
+```golang
+chains, err := nft.List(ctx, "chains")
+if err != nil {
+        return fmt.Errorf("could not list chains: %v", err)
+}
+
+FIXME
+
+elements, err := nft.ListElements(ctx, "map", "mymap")
+if err != nil {
+        return fmt.Errorf("could not list map elements: %v", err)
+}
+
+FIXME
+```
+
+To make changes, create a `Transaction`, add the appropriate
+operations to the transaction, and then call `nft.Run` on it:
+
+```golang
+tx := nftables.NewTransaction()
+
+tx.Add(&nftables.Chain{
+        Name:    "mychain",
+        Comment: nftables.Optional("this is my chain"),
+})
+tx.Flush(&nftables.Chain{
+        Name: "mychain",
+})
+
+var destIP net.IP
+var destPort uint16
+...
+tx.Add(&nftables.Rule{
+        Chain: "mychain",
+        Rule:  nftables.Concat(
+                "$IP daddr", destIP,
+                "$IP protocol", "tcp",
+                "th port", destPort,
+                "jump", destChain,
+        )
+})
+
+err := nft.Run(context, tx)
+```
+
+If any operation in the transaction would fail, then `Run()` will
+return an error and the entire transaction will be ignored. You can
+use the `nftables.IsNotFound()` and `nft.IsAlreadyExists()` methods to
+check for those well-known error types. In a large transaction, there
+is no supported way to determine exactly which operation failed.
+
+## `nftables.Transaction` operations
+
+`nftables.Transaction` operations correspond to the top-level commands
+in the `nft` binary. Currently-supported operations are:
+
+- `tx.Add()`: adds an object, which may already exist, as with `nft add`
+- `tx.Create()`: creates an object, which must not already exist, as with `nft create`
+- `tx.Flush()`: flushes the contents of a table/chain/set/map, as with `nft flush`
+- `tx.Delete()`: deletes an object, as with `nft delete`
+- `tx.Insert()`: inserts a rule before another rule, as with `nft insert rule`
+- `tx.Replace()`: replaces a rule, as with `nft replace rule`
+
+## Objects
+
+The `Transaction` methods take arguments of type `nftables.Object`.
+The currently-supported objects are:
+
+- `Table`
+- `Chain`
+- `Rule`
+- `Set`
+- `Map`
+- `Element`
+
+Optional fields in objects can be filled in with the help of the
+`Optional()` function, which just returns a pointer to its
+argument.
+
+`Concat()` can be used to concatenate a series of strings, `[]string`
+arrays, and other arguments (including numbers, `net.IP`s /
+`net.IPNet`s, and anything else that can be formatted usefully via
+`fmt.Sprintf("%s")`) together into a single string. This is often
+useful when constructing `Rule`s.
+
+The `Join()` and `Split()` helper functions can be used with set and
+map keys and values, to convert between multiple values specified
+separately, and a single string with the values separated by dots.
+
+## `nftables.Fake`
+
+There is a fake (in-memory) implementation of `nftables.Interface` for
+use in unit tests. Use `nftables.NewFake()` instead of
+`nftables.New()` to create it, and then it should work mostly the
+same. See `fake.go` for more details of the public APIs for examining
+the current state of the fake nftables database.
+
+Note that at the present time, `fake.Run()` is not actually
+transactional, so unit tests that rely on things not being changed if
+a transaction fails partway through will not work as expected.
+
+## Missing APIs
+
+Various top-level object types are not yet supported (notably the
+"stateful objects" like `counter`).
+
+Most IPTables libraries have an API for "add this rule only if it
+doesn't already exist", but that does not seem as useful in nftables
+(or at least "in nftables as used by Kubernetes-ish components that
+aren't just blindly copying over old iptables APIs"), because chains
+tend to have static rules and dynamic sets/maps, rather than having
+dynamic rules. If you aren't sure if a chain has the correct rules,
+you can just `Flush` it and recreate all of the rules.
+
+I've considered changing the semantics of `tx.Add(obj)` so that
+`obj.Handle` is filled in with the new object's handle on return from
+`Run()`, for ease of deleting later. (This would be implemented by
+using the `--handle` (`-a`) and `--echo` (`-e`) flags to `nft add`.)
+However, this would require potentially difficult parsing of the `nft`
+output. `ListRules` fills in the handles of the rules it returns, so
+it's possible to find out a rule's handle after the fact that way. For
+other supported object types, either handles don't exist (`Element`)
+or you don't really need to know their handles because it's possible
+to delete by name instead (`Table`, `Chain`, `Set`, `Map`).
+
+The "destroy" (delete-without-ENOENT) command that exists in newer
+versions of `nft` is not currently supported because it would be
+unexpectedly heavyweight to emulate on systems that don't have it, so
+it is better (for now) to force callers to implement it by hand.
+
+# Design Notes
+
+The library works by invoking the `nft` binary, mostly not using the
+`--json` mode.
+
+Although it might seem like we ought to use either the low-level
+(netlink) interface, or at least the JSON interface, that doesn't seem
+like a good idea in practice. The documented syntax of nftables rules
+and set/map elements is implemented by the higher-level APIs, so if we
+used the lower-level APIs (or the JSON API, which wraps the
+lower-level APIs), then the official nftables documentation would be
+mostly useless to people using this library. (You would essentially be
+forced to do `nft add rule ...; nft -j list chain ...` to figure out
+the JSON syntax for the rules you wanted so you could then write it in
+the form the library needed.)
+
+Using the non-JSON syntax has its own problems, and means that it is
+basically impossible for us to reliably parse the actual "rule" part
+of rules. (We can reliably parse the output of `"nft list chain"` into
+`Rule` objects, including distinguishing any `comment` from the rule
+itself, but we don't have any ability to split the rule up into
+individual clauses.)
+
+The fact that the API uses functions and objects (e.g.
+`tx.Add(&nftables.Chain{...})`) rather than just specifying everything
+as textual input to `nft` (e.g. `tx.Exec("add chain ...")`) is mostly
+just because it's _much_ easier to have a fake implementation for unit
+tests this way.
diff --git a/vendor/github.com/danwinship/nftables/error.go b/vendor/github.com/danwinship/nftables/error.go
new file mode 100644
index 000000000..eba074ffe
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/error.go
@@ -0,0 +1,93 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"errors"
+	"fmt"
+	"os/exec"
+	"strings"
+	"syscall"
+)
+
+type nftablesError struct {
+	wrapped error
+	msg     string
+	errno   syscall.Errno
+}
+
+// wrapError wraps an error resulting from running nft
+func wrapError(err error) error {
+	nerr := &nftablesError{wrapped: err, msg: err.Error()}
+	if ee, ok := err.(*exec.ExitError); ok {
+		if len(ee.Stderr) > 0 {
+			nerr.msg = string(ee.Stderr)
+			eol := strings.Index(nerr.msg, "\n")
+			// The nft binary does not call setlocale() and so will return
+			// English error strings regardless of the locale.
+			enoent := strings.Index(nerr.msg, "No such file or directory")
+			eexist := strings.Index(nerr.msg, "File exists")
+			if enoent != -1 && (enoent < eol || eol == -1) {
+				nerr.errno = syscall.ENOENT
+			} else if eexist != -1 && (eexist < eol || eol == -1) {
+				nerr.errno = syscall.EEXIST
+			}
+		}
+	}
+	return nerr
+}
+
+// notFoundError returns an nftablesError with the given message for which IsNotFound will
+// return true.
+func notFoundError(format string, args ...interface{}) error {
+	return &nftablesError{msg: fmt.Sprintf(format, args...), errno: syscall.ENOENT}
+}
+
+// existsError returns an nftablesError with the given message for which IsAlreadyExists
+// will return true.
+func existsError(format string, args ...interface{}) error {
+	return &nftablesError{msg: fmt.Sprintf(format, args...), errno: syscall.EEXIST}
+}
+
+func (nerr *nftablesError) Error() string {
+	return nerr.msg
+}
+
+func (nerr *nftablesError) Unwrap() error {
+	return nerr.wrapped
+}
+
+// IsNotFound tests if err corresponds to an nftables "not found" error of any sort.
+// (e.g., in response to a "delete rule" command, this might indicate that the rule
+// doesn't exist, or the chain doesn't exist, or the table doesn't exist.)
+func IsNotFound(err error) bool {
+	var nerr *nftablesError
+	if errors.As(err, &nerr) {
+		return nerr.errno == syscall.ENOENT
+	}
+	return false
+}
+
+// IsAlreadyExists tests if err corresponds to an nftables "already exists" error (e.g.
+// when doing a "create" rather than an "add").
+func IsAlreadyExists(err error) bool {
+	var nerr *nftablesError
+	if errors.As(err, &nerr) {
+		return nerr.errno == syscall.EEXIST
+	}
+	return false
+}
diff --git a/vendor/github.com/danwinship/nftables/exec.go b/vendor/github.com/danwinship/nftables/exec.go
new file mode 100644
index 000000000..d612ed4f3
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/exec.go
@@ -0,0 +1,115 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"fmt"
+	"io"
+	"os/exec"
+	"reflect"
+	"testing"
+)
+
+// execer is a mockable wrapper around os/exec.
+type execer interface {
+	// LookPath wraps exec.LookPath
+	LookPath(file string) (string, error)
+
+	// Run runs cmd as with cmd.Output(). If an error occurs, and the process outputs
+	// stderr, then that output will be returned in the error.
+	Run(cmd *exec.Cmd) (string, error)
+}
+
+// realExec implements execer by actually using os/exec
+type realExec struct{}
+
+// LookPath is part of execer
+func (_ realExec) LookPath(file string) (string, error) {
+	return exec.LookPath(file)
+}
+
+// Run is part of execer
+func (_ realExec) Run(cmd *exec.Cmd) (string, error) {
+	out, err := cmd.Output()
+	if err != nil {
+		err = wrapError(err)
+	}
+	return string(out), err
+}
+
+// fakeExec is a mockable implementation of execer for unit tests
+type fakeExec struct {
+	t *testing.T
+
+	// missingBinaries is the set of binaries for which LookPath should fail
+	missingBinaries map[string]bool
+
+	// expected is the list of expected Run calls
+	expected []expectedCmd
+
+	// matched is used internally, to keep track of where we are in expected
+	matched int
+}
+
+func newFakeExec(t *testing.T) *fakeExec {
+	return &fakeExec{t: t, missingBinaries: make(map[string]bool)}
+}
+
+func (fe *fakeExec) LookPath(file string) (string, error) {
+	if fe.missingBinaries[file] {
+		return "", &exec.Error{file, exec.ErrNotFound}
+	}
+	return "/" + file, nil
+}
+
+// expectedCmd details one expected fakeExec Cmd
+type expectedCmd struct {
+	args   []string
+	stdin  string
+	stdout string
+	err    error
+}
+
+func (fe *fakeExec) Run(cmd *exec.Cmd) (string, error) {
+	if fe.t.Failed() {
+		return "", fmt.Errorf("unit test failed")
+	}
+
+	if len(fe.expected) == fe.matched {
+		fe.t.Errorf("ran out of commands before executing %v", cmd.Args)
+		return "", fmt.Errorf("unit test failed")
+	}
+	expected := &fe.expected[fe.matched]
+	fe.matched++
+
+	if !reflect.DeepEqual(expected.args, cmd.Args) {
+		fe.t.Errorf("incorrect arguments: expected %v, got %v", expected.args, cmd.Args)
+		return "", fmt.Errorf("unit test failed")
+	}
+
+	var stdin string
+	if cmd.Stdin != nil {
+		inBytes, _ := io.ReadAll(cmd.Stdin)
+		stdin = string(inBytes)
+	}
+	if expected.stdin != stdin {
+		fe.t.Errorf("incorrect stdin: expected %q, got %q", expected.stdin, stdin)
+		return "", fmt.Errorf("unit test failed")
+	}
+
+	return expected.stdout, expected.err
+}
diff --git a/vendor/github.com/danwinship/nftables/fake.go b/vendor/github.com/danwinship/nftables/fake.go
new file mode 100644
index 000000000..bb687efbe
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/fake.go
@@ -0,0 +1,515 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"context"
+	"fmt"
+	"sort"
+	"strings"
+)
+
+// Fake is a fake implementation of Interface
+type Fake struct {
+	family  Family
+	table   string
+	defines []define
+
+	nextHandle int
+
+	// Table contains the Interface's table. This will be `nil` until you `tx.Add()`
+	// the table.
+	Table *FakeTable
+}
+
+// FakeTable wraps Table for the Fake implementation
+type FakeTable struct {
+	Table
+
+	// Chains contains the table's chains, keyed by name
+	Chains map[string]*FakeChain
+
+	// Sets contains the table's sets, keyed by name
+	Sets map[string]*FakeSet
+
+	// Maps contains the table's maps, keyed by name
+	Maps map[string]*FakeMap
+}
+
+// FakeChain wraps Chain for the Fake implementation
+type FakeChain struct {
+	Chain
+
+	// Rules contains the chain's rules, in order
+	Rules []*Rule
+}
+
+// FakeSet wraps Set for the Fake implementation
+type FakeSet struct {
+	Set
+
+	// Elements contains the set's elements. You can also use the FakeSet's
+	// FindElement() method to see if a particular element is present.
+	Elements []*Element
+}
+
+// FakeMap wraps Set for the Fake implementation
+type FakeMap struct {
+	Map
+
+	// Elements contains the map's elements. You can also use the FakeMap's
+	// FindElement() method to see if a particular element is present.
+	Elements []*Element
+}
+
+// NewFake creates a new fake Interface, for unit tests
+func NewFake(family Family, table string) *Fake {
+	return &Fake{
+		family:  family,
+		table:   table,
+		defines: defaultDefinesForFamily(family),
+	}
+}
+
+var _ Interface = &Fake{}
+
+// Present is part of Interface.
+func (fake *Fake) Present() error {
+	return nil
+}
+
+// List is part of Interface.
+func (fake *Fake) List(ctx context.Context, objectType string) ([]string, error) {
+	if fake.Table == nil {
+		return nil, notFoundError("no such table %q", fake.table)
+	}
+
+	var result []string
+
+	switch objectType {
+	case "chain", "chains":
+		for name := range fake.Table.Chains {
+			result = append(result, name)
+		}
+	case "set", "sets":
+		for name := range fake.Table.Sets {
+			result = append(result, name)
+		}
+	case "map", "maps":
+		for name := range fake.Table.Maps {
+			result = append(result, name)
+		}
+
+	default:
+		return nil, fmt.Errorf("unsupported object type %q", objectType)
+	}
+
+	return result, nil
+}
+
+// ListRules is part of Interface
+func (fake *Fake) ListRules(ctx context.Context, chain string) ([]*Rule, error) {
+	if fake.Table == nil {
+		return nil, notFoundError("no such chain %q", chain)
+	}
+	ch := fake.Table.Chains[chain]
+	if ch == nil {
+		return nil, notFoundError("no such chain %q", chain)
+	}
+	return ch.Rules, nil
+}
+
+// ListElements is part of Interface
+func (fake *Fake) ListElements(ctx context.Context, objectType, name string) ([]*Element, error) {
+	if fake.Table == nil {
+		return nil, notFoundError("no such %s %q", objectType, name)
+	}
+	if objectType == "set" {
+		s := fake.Table.Sets[name]
+		if s != nil {
+			return s.Elements, nil
+		}
+	} else if objectType == "map" {
+		m := fake.Table.Maps[name]
+		if m != nil {
+			return m.Elements, nil
+		}
+	}
+	return nil, notFoundError("no such %s %q", objectType, name)
+}
+
+// Define is part of Interface
+func (fake *Fake) Define(name, value string) {
+	fake.defines = append(fake.defines, define{name, value})
+}
+
+func substituteDefines(val string, defines []define) string {
+	for _, def := range defines {
+		val = strings.ReplaceAll(val, "$"+def.name, def.value)
+	}
+	return val
+}
+
+// Run is part of Interface
+func (fake *Fake) Run(ctx context.Context, tx *Transaction) error {
+	if tx.err != nil {
+		return tx.err
+	}
+
+	// FIXME: not actually transactional!
+
+	for _, op := range tx.operations {
+		// If the table hasn't been created, and this isn't a Table operation, then fail
+		if fake.Table == nil {
+			if _, ok := op.obj.(*Table); !ok {
+				return notFoundError("no such table \"%s %s\"", fake.family, fake.table)
+			}
+		}
+
+		if op.verb == addVerb || op.verb == createVerb || op.verb == insertVerb {
+			fake.nextHandle++
+		}
+
+		switch obj := op.obj.(type) {
+		case *Table:
+			err := checkExists(op.verb, "table", fake.table, fake.Table)
+			if err != nil {
+				return err
+			}
+			switch op.verb {
+			case flushVerb:
+				fake.Table = nil
+				fallthrough
+			case addVerb, createVerb:
+				if fake.Table != nil {
+					continue
+				}
+				table := *obj
+				table.Handle = Optional(fake.nextHandle)
+				fake.Table = &FakeTable{
+					Table:  table,
+					Chains: make(map[string]*FakeChain),
+					Sets:   make(map[string]*FakeSet),
+					Maps:   make(map[string]*FakeMap),
+				}
+			case deleteVerb:
+				fake.Table = nil
+			default:
+				return fmt.Errorf("unhandled operation %q", op.verb)
+			}
+
+		case *Chain:
+			existingChain := fake.Table.Chains[obj.Name]
+			err := checkExists(op.verb, "chain", obj.Name, existingChain)
+			if err != nil {
+				return err
+			}
+			switch op.verb {
+			case addVerb, createVerb:
+				if existingChain != nil {
+					continue
+				}
+				chain := *obj
+				chain.Handle = Optional(fake.nextHandle)
+				fake.Table.Chains[obj.Name] = &FakeChain{
+					Chain: chain,
+				}
+			case flushVerb:
+				existingChain.Rules = nil
+			case deleteVerb:
+				// FIXME delete-by-handle
+				delete(fake.Table.Chains, obj.Name)
+			default:
+				return fmt.Errorf("unhandled operation %q", op.verb)
+			}
+
+		case *Rule:
+			existingChain := fake.Table.Chains[obj.Chain]
+			if existingChain == nil {
+				return notFoundError("no such chain %q", obj.Chain)
+			}
+			if op.verb == deleteVerb {
+				i := findRule(existingChain.Rules, *obj.Handle)
+				if i == -1 {
+					return notFoundError("no rule with handle %d", *obj.Handle)
+				}
+				existingChain.Rules = append(existingChain.Rules[:i], existingChain.Rules[i+1:]...)
+				continue
+			}
+
+			rule := *obj
+			rule.Rule = substituteDefines(rule.Rule, fake.defines)
+			refRule := -1
+			if rule.Handle != nil {
+				refRule = findRule(existingChain.Rules, *obj.Handle)
+				if refRule == -1 {
+					return notFoundError("no rule with handle %d", *obj.Handle)
+				}
+			} else if obj.Index != nil {
+				if *obj.Index >= len(existingChain.Rules) {
+					return notFoundError("no rule with index %d", *obj.Index)
+				}
+				refRule = *obj.Index
+			}
+
+			switch op.verb {
+			case addVerb:
+				if refRule == -1 {
+					existingChain.Rules = append(existingChain.Rules, &rule)
+				} else {
+					existingChain.Rules = append(existingChain.Rules[:refRule+1], append([]*Rule{&rule}, existingChain.Rules[refRule+1:]...)...)
+				}
+				rule.Handle = Optional(fake.nextHandle)
+			case insertVerb:
+				if refRule == -1 {
+					existingChain.Rules = append([]*Rule{&rule}, existingChain.Rules...)
+				} else {
+					existingChain.Rules = append(existingChain.Rules[:refRule], append([]*Rule{&rule}, existingChain.Rules[refRule:]...)...)
+				}
+				rule.Handle = Optional(fake.nextHandle)
+			case replaceVerb:
+				existingChain.Rules[refRule] = &rule
+			default:
+				return fmt.Errorf("unhandled operation %q", op.verb)
+			}
+
+		case *Set:
+			existingSet := fake.Table.Sets[obj.Name]
+			err := checkExists(op.verb, "set", obj.Name, existingSet)
+			if err != nil {
+				return err
+			}
+			switch op.verb {
+			case addVerb, createVerb:
+				if existingSet != nil {
+					continue
+				}
+				set := *obj
+				set.Type = substituteDefines(set.Type, fake.defines)
+				set.TypeOf = substituteDefines(set.TypeOf, fake.defines)
+				set.Handle = Optional(fake.nextHandle)
+				fake.Table.Sets[obj.Name] = &FakeSet{
+					Set: set,
+				}
+			case flushVerb:
+				existingSet.Elements = nil
+			case deleteVerb:
+				// FIXME delete-by-handle
+				delete(fake.Table.Sets, obj.Name)
+			default:
+				return fmt.Errorf("unhandled operation %q", op.verb)
+			}
+		case *Map:
+			existingMap := fake.Table.Maps[obj.Name]
+			err := checkExists(op.verb, "map", obj.Name, existingMap)
+			if err != nil {
+				return err
+			}
+			switch op.verb {
+			case addVerb:
+				if existingMap != nil {
+					continue
+				}
+				mapObj := *obj
+				mapObj.Type = substituteDefines(mapObj.Type, fake.defines)
+				mapObj.TypeOf = substituteDefines(mapObj.TypeOf, fake.defines)
+				mapObj.Handle = Optional(fake.nextHandle)
+				fake.Table.Maps[obj.Name] = &FakeMap{
+					Map: mapObj,
+				}
+			case flushVerb:
+				existingMap.Elements = nil
+			case deleteVerb:
+				// FIXME delete-by-handle
+				delete(fake.Table.Maps, obj.Name)
+			default:
+				return fmt.Errorf("unhandled operation %q", op.verb)
+			}
+		case *Element:
+			if len(obj.Value) == 0 {
+				existingSet := fake.Table.Sets[obj.Name]
+				if existingSet == nil {
+					return notFoundError("no such set %q", obj.Name)
+				}
+				switch op.verb {
+				case addVerb, createVerb:
+					element := *obj
+					element.Key = substituteDefines(element.Key, fake.defines)
+					if i := findElement(existingSet.Elements, element.Key); i != -1 {
+						if op.verb == createVerb {
+							return existsError("element %q already exists", element.Key)
+						}
+						existingSet.Elements[i] = &element
+					} else {
+						existingSet.Elements = append(existingSet.Elements, &element)
+					}
+				case deleteVerb:
+					key := substituteDefines(obj.Key, fake.defines)
+					if i := findElement(existingSet.Elements, obj.Key); i != -1 {
+						existingSet.Elements = append(existingSet.Elements[:i], existingSet.Elements[i+1:]...)
+					} else {
+						return notFoundError("no such element %q", key)
+					}
+				default:
+					return fmt.Errorf("unhandled operation %q", op.verb)
+				}
+			} else {
+				existingMap := fake.Table.Maps[obj.Name]
+				if existingMap == nil {
+					return notFoundError("no such map %q", obj.Name)
+				}
+				switch op.verb {
+				case addVerb, createVerb:
+					element := *obj
+					element.Key = substituteDefines(element.Key, fake.defines)
+					element.Value = substituteDefines(element.Value, fake.defines)
+					if i := findElement(existingMap.Elements, element.Key); i != -1 {
+						if op.verb == createVerb {
+							return existsError("element %q already exists", element.Key)
+						}
+						existingMap.Elements[i] = &element
+					} else {
+						existingMap.Elements = append(existingMap.Elements, &element)
+					}
+				case deleteVerb:
+					key := substituteDefines(obj.Key, fake.defines)
+					if i := findElement(existingMap.Elements, obj.Key); i != -1 {
+						existingMap.Elements = append(existingMap.Elements[:i], existingMap.Elements[i+1:]...)
+					} else {
+						return notFoundError("no such element %q", key)
+					}
+				default:
+					return fmt.Errorf("unhandled operation %q", op.verb)
+				}
+			}
+		default:
+			return fmt.Errorf("unhandled object type %T", op.obj)
+		}
+	}
+
+	return nil
+}
+
+func checkExists(verb verb, objectType, name string, existing Object) error {
+	switch verb {
+	case addVerb:
+		// It's fine if the object either exists or doesn't
+		return nil
+	case createVerb:
+		if existing != nil {
+			return existsError("%s %q already exists", objectType, name)
+		}
+	default:
+		if existing == nil {
+			return notFoundError("no such %s %q", objectType, name)
+		}
+	}
+	return nil
+}
+
+// Dump dumps the current contents of fake, in a way that looks like an nft transaction,
+// but not actually guaranteed to be usable as such. (e.g., chains may be referenced
+// before they are created, etc)
+func (fake *Fake) Dump() string {
+	if fake.Table == nil {
+		return ""
+	}
+
+	buf := &strings.Builder{}
+
+	table := fake.Table
+	table.writeOperation(addVerb, fake.family, fake.table, buf)
+
+	for _, cname := range sortKeys(table.Chains) {
+		ch := table.Chains[cname]
+		ch.writeOperation(addVerb, fake.family, fake.table, buf)
+
+		for _, rule := range ch.Rules {
+			// Avoid outputing handles
+			dumpRule := *rule
+			dumpRule.Handle = nil
+			dumpRule.Index = nil
+			dumpRule.writeOperation(addVerb, fake.family, fake.table, buf)
+		}
+	}
+
+	for _, sname := range sortKeys(table.Sets) {
+		s := table.Sets[sname]
+		s.writeOperation(addVerb, fake.family, fake.table, buf)
+
+		for _, element := range s.Elements {
+			element.writeOperation(addVerb, fake.family, fake.table, buf)
+		}
+	}
+	for _, mname := range sortKeys(table.Maps) {
+		m := table.Maps[mname]
+		m.writeOperation(addVerb, fake.family, fake.table, buf)
+
+		for _, element := range m.Elements {
+			element.writeOperation(addVerb, fake.family, fake.table, buf)
+		}
+	}
+
+	return buf.String()
+}
+
+func sortKeys[K ~string, V any](m map[K]V) []K {
+	keys := make([]K, 0, len(m))
+	for key := range m {
+		keys = append(keys, key)
+	}
+	sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })
+	return keys
+}
+
+func findRule(rules []*Rule, handle int) int {
+	for i := range rules {
+		if rules[i].Handle != nil && *rules[i].Handle == handle {
+			return i
+		}
+	}
+	return -1
+}
+
+func findElement(elements []*Element, key string) int {
+	for i := range elements {
+		if elements[i].Key == key {
+			return i
+		}
+	}
+	return -1
+}
+
+// FindElement finds an element of the set with the given key. If there is no matching
+// element, it returns nil.
+func (s *FakeSet) FindElement(key ...string) *Element {
+	index := findElement(s.Elements, Join(key...))
+	if index == -1 {
+		return nil
+	}
+	return s.Elements[index]
+}
+
+// FindElement finds an element of the map with the given key. If there is no matching
+// element, it returns nil.
+func (m *FakeMap) FindElement(key ...string) *Element {
+	index := findElement(m.Elements, Join(key...))
+	if index == -1 {
+		return nil
+	}
+	return m.Elements[index]
+}
diff --git a/vendor/github.com/danwinship/nftables/nftables.go b/vendor/github.com/danwinship/nftables/nftables.go
new file mode 100644
index 000000000..246049dd4
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/nftables.go
@@ -0,0 +1,402 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"os/exec"
+	"regexp"
+	"strconv"
+	"strings"
+)
+
+// Interface is an interface for running nftables commands against a given family and table.
+type Interface interface {
+	// Present determines if nftables is present/usable on the system.
+	Present() error
+
+	// Define adds a define (as with "nft -D") to the Interface, which can then be
+	// referenced as `$name` in transaction bodies (e.g., rules, elements, etc; any
+	// string-valued Object field).
+	//
+	// If the Interface's family is `IPv4Family` or `IPv6Family`, then two defines
+	// will automatically be added: "IP", defined to either "ip" or "ip6", and
+	// "INET_ADDR", defined to either "ipv4_addr" or "ipv6_addr".
+	Define(name, value string)
+
+	// Run runs a Transaction and returns the result. The IsNotFound and
+	// IsAlreadyExists methods can be used to test the result.
+	Run(ctx context.Context, tx *Transaction) error
+
+	// List returns a list of the names of the objects of objectType ("chain", "set",
+	// or "map") in the table. If there are no such objects, this will return an empty
+	// list and no error.
+	List(ctx context.Context, objectType string) ([]string, error)
+
+	// ListRules returns a list of the rules in a chain. If the chain exists but
+	// contains no rules, this will return an empty list and no error.
+	ListRules(ctx context.Context, chain string) ([]*Rule, error)
+
+	// ListElements returns a list of the elements in a set or map. (objectType should
+	// be "set" or "map".) If the set/map exists but contains no elements, this will
+	// return an empty list and no error.
+	ListElements(ctx context.Context, objectType, name string) ([]*Element, error)
+}
+
+// define stores an nftables define. (We have to use `[]define` rather than
+// `map[string]string` because order is important.)
+type define struct {
+	name  string
+	value string
+}
+
+func defaultDefinesForFamily(family Family) []define {
+	switch family {
+	case IPv4Family:
+		return []define{{"IP", "ip"}, {"INET_ADDR", "ipv4_addr"}}
+	case IPv6Family:
+		return []define{{"IP", "ip6"}, {"INET_ADDR", "ipv6_addr"}}
+	default:
+		return []define{}
+	}
+}
+
+// realNFTables is an implementation of Interface
+type realNFTables struct {
+	family  Family
+	table   string
+	defines []define
+
+	exec execer
+}
+
+// for unit tests
+func newInternal(family Family, table string, exec execer) Interface {
+	return &realNFTables{
+		family:  family,
+		table:   table,
+		defines: defaultDefinesForFamily(family),
+
+		exec: exec,
+	}
+}
+
+// New creates a new nftables.Interface for interacting with the given table.
+func New(family Family, table string) Interface {
+	return newInternal(family, table, realExec{})
+}
+
+// Present is part of Interface.
+func (nft *realNFTables) Present() error {
+	if _, err := nft.exec.LookPath("nft"); err != nil {
+		return fmt.Errorf("could not run nftables binary: %w", err)
+	}
+
+	cmd := exec.Command("nft", "--check", "add", "table", string(nft.family), nft.table)
+	_, err := nft.exec.Run(cmd)
+	return err
+}
+
+// Define is part of Interface
+func (nft *realNFTables) Define(name, value string) {
+	nft.defines = append(nft.defines, define{name, value})
+}
+
+// Run is part of Interface
+func (nft *realNFTables) Run(ctx context.Context, tx *Transaction) error {
+	if tx.err != nil {
+		return tx.err
+	}
+
+	buf, err := tx.asCommandBuf(nft.family, nft.table)
+	if err != nil {
+		return err
+	}
+
+	args := make([]string, 0, 2*len(nft.defines)+2)
+	for _, def := range nft.defines {
+		args = append(args, "-D", fmt.Sprintf("%s=%s", def.name, def.value))
+	}
+	args = append(args, "-f", "-")
+
+	cmd := exec.CommandContext(ctx, "nft", args...)
+	cmd.Stdin = buf
+	_, err = nft.exec.Run(cmd)
+	return err
+}
+
+func jsonVal[T any](json map[string]interface{}, key string) (T, bool) {
+	if ifVal, exists := json[key]; exists {
+		tVal, ok := ifVal.(T)
+		return tVal, ok
+	} else {
+		var zero T
+		return zero, false
+	}
+}
+
+// List is part of Interface.
+func (nft *realNFTables) List(ctx context.Context, objectType string) ([]string, error) {
+	// All currently-existing nftables object types have plural forms that are just
+	// the singular form plus 's'.
+	var typeSingular, typePlural string
+	if objectType[len(objectType)-1] == 's' {
+		typeSingular = objectType[:len(objectType)-1]
+		typePlural = objectType
+	} else {
+		typeSingular = objectType
+		typePlural = objectType + "s"
+	}
+
+	cmd := exec.CommandContext(ctx, "nft", "--json", "list", typePlural, string(nft.family))
+	out, err := nft.exec.Run(cmd)
+	if err != nil {
+		return nil, fmt.Errorf("failed to run nft: %w", err)
+	}
+
+	// out contains JSON looking like:
+	// {
+	//   "nftables": [
+	//     {
+	//       "metainfo": {
+	//         "json_schema_version": 1
+	//         ...
+	//       }
+	//     },
+	//     {
+	//       "chain": {
+	//         "family": "ip",
+	//         "table": "kube_proxy",
+	//         "name": "KUBE-SERVICES",
+	//         "handle": 3,
+	//       }
+	//     },
+	//     ...
+	//   ]
+	// }
+
+	jsonResult := map[string][]map[string]map[string]interface{}{}
+	if err := json.Unmarshal([]byte(out), &jsonResult); err != nil {
+		return nil, fmt.Errorf("could not parse nft output: %w", err)
+	}
+
+	nftablesResult := jsonResult["nftables"]
+	if nftablesResult == nil || len(nftablesResult) == 0 {
+		return nil, fmt.Errorf("could not find result in nft output %q", out)
+	}
+	metainfo := nftablesResult[0]["metainfo"]
+	if metainfo == nil {
+		return nil, fmt.Errorf("could not find metadata in nft output %q", out)
+	}
+	if version, ok := jsonVal[float64](metainfo, "json_schema_version"); !ok || version != 1.0 {
+		return nil, fmt.Errorf("could not find supported json_schema_version in nft output %q", out)
+	}
+
+	var result []string
+	for _, objContainer := range nftablesResult {
+		obj := objContainer[typeSingular]
+		if obj == nil {
+			continue
+		}
+		objTable, _ := jsonVal[string](obj, "table")
+		if objTable != nft.table {
+			continue
+		}
+
+		if name, ok := jsonVal[string](obj, "name"); ok {
+			result = append(result, name)
+		}
+	}
+
+	return result, nil
+}
+
+// ListRules is part of Interface
+func (nft *realNFTables) ListRules(ctx context.Context, chain string) ([]*Rule, error) {
+	// We don't use the JSON API because the syntax for rules is wildly different in
+	// JSON and there is no way to convert it to "normal" form.
+	cmd := exec.CommandContext(ctx, "nft", "--handle", "list", "chain", string(nft.family), nft.table, chain)
+	out, err := nft.exec.Run(cmd)
+	if err != nil {
+		return nil, fmt.Errorf("failed to run nft: %w", err)
+	}
+
+	// Output looks like:
+	//
+	// table inet firewalld { # handle 1
+	//     chain filter_INPUT { # handle 165
+	//         type filter hook input priority filter + 10; policy accept;
+	//         ct state { established, related } accept # handle 169
+	//         ct status dnat accept # handle 170
+	//         iifname "lo" accept # handle 171
+	//         ...
+	//     }
+	// }
+	//
+	// (Where the "type ..." line only appears for base chains.) If a rule has a
+	// comment, it will always be the last part of the rule (before the handle).
+
+	lines := strings.Split(out, "\n")
+	rules := make([]*Rule, 0, len(lines))
+	sawTable := false
+	sawChain := false
+	for _, line := range lines {
+		line := strings.TrimSpace(line)
+
+		if !sawTable {
+			if strings.HasPrefix(line, "table ") {
+				sawTable = true
+			}
+			continue
+		} else if !sawChain {
+			if strings.HasPrefix(line, "chain "+chain) {
+				sawChain = true
+			}
+			continue
+		} else if line == "}" {
+			break
+		}
+
+		parts := strings.Split(line, " # handle ")
+		if len(parts) != 2 {
+			continue
+		}
+		line, handleStr := parts[0], parts[1]
+		handle, err := strconv.Atoi(handleStr)
+		if err != nil {
+			continue
+		}
+
+		rule, comment := splitComment(line)
+		rules = append(rules, &Rule{
+			Chain:   chain,
+			Rule:    rule,
+			Comment: comment,
+			Handle:  &handle,
+		})
+	}
+
+	return rules, nil
+}
+
+// ListElements is part of Interface
+func (nft *realNFTables) ListElements(ctx context.Context, objectType, name string) ([]*Element, error) {
+	// We don't use the JSON API because the JSON syntax for elements, while not quite
+	// as bad as the syntax for rules, is still not easily transformable into "normal"
+	// form. (And in particular, for verdict maps, the verdict part is stored as a
+	// JSON rule, not as a string.)
+	cmd := exec.CommandContext(ctx, "nft", "list", objectType, string(nft.family), nft.table, name)
+	out, err := nft.exec.Run(cmd)
+	if err != nil {
+		return nil, fmt.Errorf("failed to run nft: %w", err)
+	}
+
+	// Output looks like:
+	//
+	// table ip testing {
+	//     map map1 {
+	//         type ipv4_addr . inet_proto . inet_service : verdict
+	//         elements = { 192.168.0.1 . tcp . 80 : goto chain1,
+	//                      192.168.0.2 . tcp . 443 comment "foo" : drop }
+	//     }
+	// }
+
+	lines := strings.Split(out, "\n")
+	elements := make([]*Element, 0, len(lines))
+	sawTable := false
+	sawObject := false
+	sawElements := false
+	for _, line := range lines {
+		line := strings.TrimSpace(line)
+
+		if !sawTable {
+			if strings.HasPrefix(line, "table ") {
+				sawTable = true
+			}
+			continue
+		} else if !sawObject {
+			if strings.HasPrefix(line, objectType+" "+name) {
+				sawObject = true
+			}
+			continue
+		} else if !sawElements {
+			if !strings.HasPrefix(line, "elements = { ") {
+				continue
+			}
+			sawElements = true
+			line = strings.TrimPrefix(line, "elements = { ")
+			// fall through into the main loop body
+		} else if line == "}" {
+			break
+		}
+
+		line = strings.TrimRight(line, ", }")
+		var key, value string
+		var comment *string
+
+		if objectType == "map" {
+			key, comment, value = splitMapValue(line)
+		} else {
+			key, comment = splitComment(line)
+		}
+		if key == "" {
+			continue
+		}
+
+		elements = append(elements, &Element{
+			Name:    name,
+			Key:     key,
+			Value:   value,
+			Comment: comment,
+		})
+	}
+
+	return elements, nil
+}
+
+var commentRegexp = regexp.MustCompile(`^(.*) comment "([^"]*)"$`)
+
+// splitComment splits line into a required pre-comment and optional trailing comment
+// (which is enclosed in quotes but does not contain any quotes).
+func splitComment(line string) (string, *string) {
+	// We could perhaps do this more efficiently without using a regexp, but it would
+	// be more complicated...
+	match := commentRegexp.FindStringSubmatch(line)
+	if match != nil {
+		return match[1], &match[2]
+	}
+	return line, nil
+}
+
+var mapValueRegexp = regexp.MustCompile(`^(([^"]|"[^"]*")+) : (([^"]|"[^"]*")+)`)
+
+// splitMapValue splits line into key, optional comment, and value, dealing with the
+// possibility of strings whose contents look like nftables syntax.
+func splitMapValue(line string) (string, *string, string) {
+	// We could perhaps do this more efficiently without using a regexp, but it would
+	// be more complicated...
+	match := mapValueRegexp.FindStringSubmatch(line)
+	if match == nil {
+		return "", nil, ""
+	}
+
+	value := match[3]
+	key, comment := splitComment(match[1])
+	return key, comment, value
+}
diff --git a/vendor/github.com/danwinship/nftables/objects.go b/vendor/github.com/danwinship/nftables/objects.go
new file mode 100644
index 000000000..fe327d93f
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/objects.go
@@ -0,0 +1,346 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"fmt"
+	"io"
+)
+
+// Object implementation for Table
+func (table *Table) validate(verb verb) error {
+	switch verb {
+	case addVerb, createVerb, flushVerb:
+		if table.Handle != nil {
+			return fmt.Errorf("cannot specify Handle in %s operation", verb)
+		}
+	case deleteVerb:
+		// Handle can be nil or non-nil
+	default:
+		return fmt.Errorf("%s is not implemented for tables", verb)
+	}
+
+	return nil
+}
+
+func (table *Table) writeOperation(verb verb, family Family, tableName string, writer io.Writer) {
+	// Special case for delete-by-handle
+	if verb == deleteVerb && table.Handle != nil {
+		fmt.Fprintf(writer, "delete table %s handle %d", family, *table.Handle)
+		return
+	}
+
+	// All other cases refer to the table by name
+	fmt.Fprintf(writer, "%s table %s %s", verb, family, tableName)
+	if (verb == addVerb || verb == createVerb) && table.Comment != nil {
+		fmt.Fprintf(writer, " { comment %q ; }", *table.Comment)
+	}
+	fmt.Fprintf(writer, "\n")
+}
+
+// Object implementation for Chain
+func (chain *Chain) validate(verb verb) error {
+	if chain.Hook == nil && (chain.Type != nil || chain.Priority != nil) {
+		return fmt.Errorf("regular chain %q must not specify Type or Priority", chain.Name)
+	} else if chain.Hook != nil && (chain.Type == nil || chain.Priority == nil) {
+		return fmt.Errorf("base chain %q must specify Type and Priority", chain.Name)
+	}
+
+	switch verb {
+	case addVerb, createVerb, flushVerb:
+		if chain.Name == "" {
+			return fmt.Errorf("no name specified for chain")
+		}
+		if chain.Handle != nil {
+			return fmt.Errorf("cannot specify Handle in %s operation", verb)
+		}
+	case deleteVerb:
+		if chain.Name == "" && chain.Handle == nil {
+			return fmt.Errorf("must specify either name or handle")
+		}
+	default:
+		return fmt.Errorf("%s is not implemented for chains", verb)
+	}
+
+	return nil
+}
+
+func (chain *Chain) writeOperation(verb verb, family Family, table string, writer io.Writer) {
+	// Special case for delete-by-handle
+	if verb == deleteVerb && chain.Handle != nil {
+		fmt.Fprintf(writer, "delete chain %s %s handle %d", family, table, *chain.Handle)
+		return
+	}
+
+	fmt.Fprintf(writer, "%s chain %s %s %s", verb, family, table, chain.Name)
+	if (verb == addVerb || verb == createVerb) && (chain.Type != nil || chain.Comment != nil) {
+		fmt.Fprintf(writer, " {")
+
+		if chain.Type != nil {
+			fmt.Fprintf(writer, " type %s hook %s priority %s ;", *chain.Type, *chain.Hook, *chain.Priority)
+		}
+		if chain.Comment != nil {
+			fmt.Fprintf(writer, " comment %q ;", *chain.Comment)
+		}
+
+		fmt.Fprintf(writer, " }")
+	}
+
+	fmt.Fprintf(writer, "\n")
+}
+
+// Object implementation for Rule
+func (rule *Rule) validate(verb verb) error {
+	if rule.Chain == "" {
+		return fmt.Errorf("no chain name specified for rule")
+	}
+
+	if rule.Index != nil && rule.Handle != nil {
+		return fmt.Errorf("cannot specify both Index and Handle")
+	}
+
+	switch verb {
+	case addVerb, insertVerb:
+		if rule.Rule == "" {
+			return fmt.Errorf("no rule specified")
+		}
+	case replaceVerb:
+		if rule.Rule == "" {
+			return fmt.Errorf("no rule specified")
+		}
+		if rule.Handle == nil {
+			return fmt.Errorf("must specify Handle with %s", verb)
+		}
+	case deleteVerb:
+		if rule.Handle == nil {
+			return fmt.Errorf("must specify Handle with %s", verb)
+		}
+	default:
+		return fmt.Errorf("%s is not implemented for rules", verb)
+	}
+
+	return nil
+}
+
+func (rule *Rule) writeOperation(verb verb, family Family, table string, writer io.Writer) {
+	fmt.Fprintf(writer, "%s rule %s %s %s", verb, family, table, rule.Chain)
+	if rule.Index != nil {
+		fmt.Fprintf(writer, " index %d", *rule.Index)
+	} else if rule.Handle != nil {
+		fmt.Fprintf(writer, " handle %d", *rule.Handle)
+	}
+
+	switch verb {
+	case addVerb, insertVerb, replaceVerb:
+		fmt.Fprintf(writer, " %s", rule.Rule)
+
+		if rule.Comment != nil {
+			fmt.Fprintf(writer, " comment %q", *rule.Comment)
+		}
+	}
+
+	fmt.Fprintf(writer, "\n")
+}
+
+// Object implementation for Set
+func (set *Set) validate(verb verb) error {
+	switch verb {
+	case addVerb, createVerb:
+		if (set.Type == "" && set.TypeOf == "") || (set.Type != "" && set.TypeOf != "") {
+			return fmt.Errorf("set must specify either Type or TypeOf")
+		}
+		if set.Handle != nil {
+			return fmt.Errorf("cannot specify Handle in %s operation", verb)
+		}
+		fallthrough
+	case flushVerb:
+		if set.Name == "" {
+			return fmt.Errorf("no name specified for set")
+		}
+	case deleteVerb:
+		if set.Name == "" && set.Handle == nil {
+			return fmt.Errorf("must specify either name or handle")
+		}
+	default:
+		return fmt.Errorf("%s is not implemented for sets", verb)
+	}
+
+	return nil
+}
+
+func (set *Set) writeOperation(verb verb, family Family, table string, writer io.Writer) {
+	// Special case for delete-by-handle
+	if verb == deleteVerb && set.Handle != nil {
+		fmt.Fprintf(writer, "delete set %s %s handle %d", family, table, *set.Handle)
+		return
+	}
+
+	fmt.Fprintf(writer, "%s set %s %s %s", verb, family, table, set.Name)
+	if verb == addVerb || verb == createVerb {
+		fmt.Fprintf(writer, " {")
+
+		if set.Type != "" {
+			fmt.Fprintf(writer, " type %s ;", set.Type)
+		} else {
+			fmt.Fprintf(writer, " typeof %s ;", set.TypeOf)
+		}
+
+		if len(set.Flags) != 0 {
+			fmt.Fprintf(writer, " flags ")
+			for i := range set.Flags {
+				if i > 0 {
+					fmt.Fprintf(writer, ",")
+				}
+				fmt.Fprintf(writer, "%s", set.Flags[i])
+			}
+			fmt.Fprintf(writer, " ;")
+		}
+
+		if set.Timeout != nil {
+			fmt.Fprintf(writer, " timeout %d ;", int64(set.Timeout.Seconds()))
+		}
+		if set.GCInterval != nil {
+			fmt.Fprintf(writer, " gc-interval %d ;", int64(set.GCInterval.Seconds()))
+		}
+		if set.Size != nil {
+			fmt.Fprintf(writer, " size %d ;", *set.Size)
+		}
+		if set.Policy != nil {
+			fmt.Fprintf(writer, " policy %s ;", *set.Policy)
+		}
+		if set.AutoMerge != nil && *set.AutoMerge {
+			fmt.Fprintf(writer, " auto-merge ;")
+		}
+
+		if set.Comment != nil {
+			fmt.Fprintf(writer, " comment %q ;", *set.Comment)
+		}
+
+		fmt.Fprintf(writer, " }")
+	}
+
+	fmt.Fprintf(writer, "\n")
+}
+
+// Object implementation for Map
+func (mapObj *Map) validate(verb verb) error {
+	switch verb {
+	case addVerb, createVerb:
+		if (mapObj.Type == "" && mapObj.TypeOf == "") || (mapObj.Type != "" && mapObj.TypeOf != "") {
+			return fmt.Errorf("map must specify either Type or TypeOf")
+		}
+		if mapObj.Handle != nil {
+			return fmt.Errorf("cannot specify Handle in %s operation", verb)
+		}
+		fallthrough
+	case flushVerb:
+		if mapObj.Name == "" {
+			return fmt.Errorf("no name specified for map")
+		}
+	case deleteVerb:
+		if mapObj.Name == "" && mapObj.Handle == nil {
+			return fmt.Errorf("must specify either name or handle")
+		}
+	default:
+		return fmt.Errorf("%s is not implemented for maps", verb)
+	}
+
+	return nil
+}
+
+func (mapObj *Map) writeOperation(verb verb, family Family, table string, writer io.Writer) {
+	// Special case for delete-by-handle
+	if verb == deleteVerb && mapObj.Handle != nil {
+		fmt.Fprintf(writer, "delete map %s %s handle %d", family, table, *mapObj.Handle)
+		return
+	}
+
+	fmt.Fprintf(writer, "%s map %s %s %s", verb, family, table, mapObj.Name)
+	if verb == addVerb || verb == createVerb {
+		fmt.Fprintf(writer, " {")
+
+		if mapObj.Type != "" {
+			fmt.Fprintf(writer, " type %s ;", mapObj.Type)
+		} else {
+			fmt.Fprintf(writer, " typeof %s ;", mapObj.TypeOf)
+		}
+
+		if len(mapObj.Flags) != 0 {
+			fmt.Fprintf(writer, " flags ")
+			for i := range mapObj.Flags {
+				if i > 0 {
+					fmt.Fprintf(writer, ",")
+				}
+				fmt.Fprintf(writer, "%s", mapObj.Flags[i])
+			}
+			fmt.Fprintf(writer, " ;")
+		}
+
+		if mapObj.Timeout != nil {
+			fmt.Fprintf(writer, " timeout %d ;", int64(mapObj.Timeout.Seconds()))
+		}
+		if mapObj.GCInterval != nil {
+			fmt.Fprintf(writer, " gc-interval %d ;", int64(mapObj.GCInterval.Seconds()))
+		}
+		if mapObj.Size != nil {
+			fmt.Fprintf(writer, " size %d ;", *mapObj.Size)
+		}
+		if mapObj.Policy != nil {
+			fmt.Fprintf(writer, " policy %s ;", *mapObj.Policy)
+		}
+
+		if mapObj.Comment != nil {
+			fmt.Fprintf(writer, " comment %q ;", *mapObj.Comment)
+		}
+
+		fmt.Fprintf(writer, " }")
+	}
+
+	fmt.Fprintf(writer, "\n")
+}
+
+// Object implementation for Element
+func (element *Element) validate(verb verb) error {
+	if element.Name == "" {
+		return fmt.Errorf("no set/map name specified for element")
+	}
+	if element.Key == "" {
+		return fmt.Errorf("no key specified for element")
+	}
+
+	switch verb {
+	case addVerb, createVerb, deleteVerb:
+	default:
+		return fmt.Errorf("%s is not implemented for elements", verb)
+	}
+
+	return nil
+}
+
+func (element *Element) writeOperation(verb verb, family Family, table string, writer io.Writer) {
+	fmt.Fprintf(writer, "%s element %s %s %s { %s", verb, family, table, element.Name, element.Key)
+
+	if element.Value != "" {
+		fmt.Fprintf(writer, " : %s", element.Value)
+	}
+
+	if (verb == addVerb || verb == createVerb) && element.Comment != nil {
+		fmt.Fprintf(writer, " comment %q", *element.Comment)
+	}
+
+	fmt.Fprintf(writer, " }\n")
+}
diff --git a/vendor/github.com/danwinship/nftables/transaction.go b/vendor/github.com/danwinship/nftables/transaction.go
new file mode 100644
index 000000000..2e5463d93
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/transaction.go
@@ -0,0 +1,125 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"bytes"
+	"io"
+)
+
+// Transaction represents an nftables transaction
+type Transaction struct {
+	operations []operation
+	err        error
+}
+
+// operation contains a single nftables operation (eg "add table", "flush chain")
+type operation struct {
+	verb verb
+	obj  Object
+}
+
+// verb is used internally to represent the different "nft" verbs
+type verb string
+
+const (
+	addVerb     verb = "add"
+	createVerb  verb = "create"
+	insertVerb  verb = "insert"
+	replaceVerb verb = "replace"
+	deleteVerb  verb = "delete"
+	flushVerb   verb = "flush"
+)
+
+// NewTransaction creates a new transaction.
+func NewTransaction() *Transaction {
+	return &Transaction{}
+}
+
+// asCommandBuf returns the transaction as an io.Reader that outputs a series of nft commands
+func (tx *Transaction) asCommandBuf(family Family, table string) (io.Reader, error) {
+	if tx.err != nil {
+		return nil, tx.err
+	}
+
+	buf := &bytes.Buffer{}
+	for _, op := range tx.operations {
+		op.obj.writeOperation(op.verb, family, table, buf)
+	}
+	return buf, nil
+}
+
+func (tx *Transaction) operation(verb verb, obj Object) {
+	if tx.err != nil {
+		return
+	}
+	if tx.err = obj.validate(verb); tx.err != nil {
+		return
+	}
+
+	tx.operations = append(tx.operations, operation{verb: verb, obj: obj})
+}
+
+// Add adds an "nft add" operation to tx, ensuring that obj exists by creating it if it
+// did not already exist. (If obj is a Rule, it will be appended to the end of its chain,
+// or else added after the Rule indicated by this rule's Index or Handle.) The Add() call
+// always succeeds, but if obj is invalid, or inconsistent with the existing nftables
+// state, then an error will be returned when the transaction is Run.
+func (tx *Transaction) Add(obj Object) {
+	tx.operation(addVerb, obj)
+}
+
+// Create adds an "nft create" operation to tx, creating obj, which must not already
+// exist. (If obj is a Rule, it will be appended to the end of its chain, or else added
+// after the Rule indicated by this rule's Index or Handle.) The Create() call always
+// succeeds, but if obj is invalid, already exists, or is inconsistent with the existing
+// nftables state, then an error will be returned when the transaction is Run.
+func (tx *Transaction) Create(obj Object) {
+	tx.operation(createVerb, obj)
+}
+
+// Insert adds an "nft insert" operation to tx, inserting obj (which must be a Rule) at
+// the start of its chain, or before the other Rule indicated by this rule's Index or
+// Handle. The Insert() call always succeeds, but if obj is invalid or is inconsistent
+// with the existing nftables state, then an error will be returned when the transaction
+// is Run.
+func (tx *Transaction) Insert(obj Object) {
+	tx.operation(insertVerb, obj)
+}
+
+// Replace adds an "nft replace" operation to tx, replacing an existing rule with obj
+// (which must be a Rule). The Replace() call always succeeds, but if obj is invalid, does
+// not contain the Handle of an existing rule, or is inconsistent with the existing
+// nftables state, then an error will be returned when the transaction is Run.
+func (tx *Transaction) Replace(obj Object) {
+	tx.operation(replaceVerb, obj)
+}
+
+// Flush adds an "nft flush" operation to tx, clearing the contents of obj. The Flush()
+// call always succeeds, but if obj does not exist (or does not support flushing) then an
+// error will be returned when the transaction is Run.
+func (tx *Transaction) Flush(obj Object) {
+	tx.operation(flushVerb, obj)
+}
+
+// Delete adds an "nft delete" operation to tx, deleting obj. The Delete() call always
+// succeeds, but if obj does not exist or cannot be deleted based on the information
+// provided (eg, Handle is required but not set) then an error will be returned when the
+// transaction is Run.
+func (tx *Transaction) Delete(obj Object) {
+	tx.operation(deleteVerb, obj)
+}
diff --git a/vendor/github.com/danwinship/nftables/types.go b/vendor/github.com/danwinship/nftables/types.go
new file mode 100644
index 000000000..769dc2bac
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/types.go
@@ -0,0 +1,325 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"io"
+	"time"
+)
+
+// Object is the interface for an nftables object. All of the concrete object types
+// implement this interface.
+type Object interface {
+	// validate validates an object for an operation
+	validate(verb verb) error
+
+	// writeOperation writes out an "nft" operation involving the object. It assumes
+	// that the object has been validated.
+	writeOperation(verb verb, family Family, table string, writer io.Writer)
+}
+
+// Family is an nftables family
+type Family string
+
+const (
+	// IPv4Family represents the "ip" nftables family, for IPv4 rules.
+	IPv4Family Family = "ip"
+
+	// IPv6Family represents the "ip6" nftables family, for IPv6 rules.
+	IPv6Family Family = "ip6"
+
+	// InetFamily represents the "inet" nftables family, for mixed IPv4 and IPv6 rules.
+	InetFamily Family = "inet"
+
+	// ARPFamily represents the "arp" nftables family, for ARP rules.
+	ARPFamily Family = "arp"
+
+	// BridgeFamily represents the "bridge" nftables family, for rules operating
+	// on packets traversing a bridge.
+	BridgeFamily Family = "bridge"
+
+	// NetDevFamily represents the "netdev" nftables family, for rules operating on
+	// the device ingress/egress path.
+	NetDevFamily Family = "netdev"
+)
+
+// Table represents an nftables table.
+type Table struct {
+	// Comment is an optional comment for the table. (Note that this can be specified
+	// on creation, but depending on the version of /sbin/nft that is available, it
+	// may not be filled in correctly in the result of a List.)
+	Comment *string
+
+	// Handle is an identifier that can be used to uniquely identify an object when
+	// deleting it. When adding a new object, this must be nil.
+	Handle *int
+}
+
+// BaseChainType represents the "type" of a "base chain" (ie, a chain that is attached to a hook)
+type BaseChainType string
+
+const (
+	// FilterType is the chain type for basic packet filtering.
+	FilterType BaseChainType = "filter"
+
+	// NATType is the chain type for doing DNAT, SNAT, and masquerading.
+	// NAT operations are only available from certain hooks.
+	NATType BaseChainType = "nat"
+
+	// RouteType is the chain type for rules that change the routing of packets.
+	// Chains of this type can only be added to the "output" hook.
+	RouteType BaseChainType = "route"
+)
+
+// BaseChainHook represents the "hook" that a base chain is attached to
+type BaseChainHook string
+
+// FIXME: document these correctly; virtually all of the existing iptables/nftables
+// documentation is slightly wrong, particular wrt locally-generated packets.
+const (
+	PreroutingHook  BaseChainHook = "prerouting"
+	InputHook       BaseChainHook = "input"
+	ForwardHook     BaseChainHook = "forward"
+	OutputHook      BaseChainHook = "output"
+	PostroutingHook BaseChainHook = "postrouting"
+	IngressHook     BaseChainHook = "ingress"
+	EgressHook      BaseChainHook = "egress"
+)
+
+// BaseChainPriority represents the "priority" of a base chain. In addition to the const
+// values, you can also use a signed integer value, or an arithmetic expression consisting
+// of a const value followed by "+" or "-" and an integer. Lower values run earlier.
+type BaseChainPriority string
+
+const (
+	// RawPriority is the earliest named priority. In particular, it can be used for
+	// rules that need to run before conntrack. It is equivalent to the value -300 and
+	// can be used in the ip, ip6, and inet families.
+	RawPriority BaseChainPriority = "raw"
+
+	// ManglePriority is the standard priority for packet-rewriting operations. It is
+	// equivalent to the value -150 and can be used in the ip, ip6, and inet families.
+	ManglePriority BaseChainPriority = "mangle"
+
+	// DNATPriority is the standard priority for DNAT operations. In the ip, ip6, and
+	// inet families, it is equivalent to the value -100. In the bridge family it is
+	// equivalent to the value -300. In both cases it can only be used from the
+	// prerouting hook.
+	DNATPriority BaseChainPriority = "dstnat"
+
+	// FilterPriority is the standard priority for filtering operations. In the ip,
+	// ip6, inet, arp, and netdev families, it is equivalent to the value 0. In the
+	// bridge family it is equivalent to the value -200.
+	FilterPriority BaseChainPriority = "filter"
+
+	// OutPriority is FIXME. It is equivalent to the value 300 and can only be used in
+	// the bridge family.
+	OutPriority BaseChainPriority = "out"
+
+	// SecurityPriority is the standard priority for security operations ("where
+	// secmark can be set for example"). It is equivalent to the value 50 and can be
+	// used in the ip, ip6, and inet families.
+	SecurityPriority BaseChainPriority = "security"
+
+	// SNATPriority is the standard priority for SNAT operations. In the ip, ip6, and
+	// inet families, it is equivalent to the value 100. In the bridge family it is
+	// equivalent to the value 300. In both cases it can only be used from the
+	// postrouting hook.
+	SNATPriority BaseChainPriority = "srcnat"
+)
+
+// Chain represents an nftables chain; either a "base chain" (if Type, Hook, and Priority
+// are specified), or a "regular chain" (if they are not).
+type Chain struct {
+	// Name is the name of the chain.
+	Name string
+
+	// Type is the chain type; this must be set for a base chain and unset for a
+	// regular chain.
+	Type *BaseChainType
+	// Hook is the hook that the chain is connected to; this must be set for a base
+	// chain and unset for a regular chain.
+	Hook *BaseChainHook
+	// Priority is the chain priority; this must be set for a base chain and unset for
+	// a regular chain. You can call ParsePriority() to convert this to a number.
+	Priority *BaseChainPriority
+
+	// Comment is an optional comment for the object.
+	Comment *string
+
+	// Handle is an identifier that can be used to uniquely identify an object when
+	// deleting it. When adding a new object, this must be nil
+	Handle *int
+}
+
+// Rule represents a rule in a chain
+type Rule struct {
+	// Chain is the name of the chain that contains this rule
+	Chain string
+
+	// Rule is the rule in standard nftables syntax. (Should be empty on Delete, but
+	// is ignored if not.) Note that this does not include any rule comment, which is
+	// separate from the rule itself.
+	Rule string
+
+	// Comment is an optional comment for the rule.
+	Comment *string
+
+	// Index is the number of a rule (counting from 0) to Add this Rule after or
+	// Insert it before. Cannot be specified along with Handle. If neither Index
+	// nor Handle is specified then Add appends the rule the end of the chain and
+	// Insert prepends it to the beginning.
+	Index *int
+
+	// Handle is a rule handle. In Add or Insert, if set, this is the handle of
+	// existing rule to put the new rule after/before. In Delete or Replace, this
+	// indicates the existing rule to delete/replace, and is mandatory. In the result
+	// of a List, this will indicate the rule's handle that can then be used in a
+	// later operation.
+	Handle *int
+}
+
+// SetFlag represents a set or map flag
+type SetFlag string
+
+const (
+	// ConstantFlag is a flag indicating that the set/map is constant. FIXME UNDOCUMENTED
+	ConstantFlag SetFlag = "constant"
+
+	// DynamicFlag is a flag indicating that the set contains stateful objects
+	// (counters, quotas, or limits) that will be dynamically updated.
+	DynamicFlag SetFlag = "dynamic"
+
+	// IntervalFlag is a flag indicating that the set contains either CIDR elements or
+	// IP ranges.
+	IntervalFlag SetFlag = "interval"
+
+	// TimeoutFlag is a flag indicating that the set/map has a timeout after which
+	// dynamically added elements will be removed. (It is set automatically if the
+	// set/map has a Timeout.)
+	TimeoutFlag SetFlag = "timeout"
+)
+
+// SetPolicy represents a set or map storage policy
+type SetPolicy string
+
+const (
+	// PolicyPerformance FIXME
+	PerformancePolicy SetPolicy = "performance"
+
+	// PolicyMemory FIXME
+	MemoryPolicy SetPolicy = "memory"
+)
+
+// Set represents the definition of an nftables set (but not its elements)
+type Set struct {
+	// Name is the name of the set.
+	Name string
+
+	// Type is the type of the set key (eg "ipv4_addr"). Either Type or TypeOf, but
+	// not both, must be non-empty.
+	Type string
+
+	// TypeOf is the type of the set key as an nftables expression (eg "ip saddr").
+	// Either Type or TypeOf, but not both, must be non-empty.
+	TypeOf string
+
+	// Flags are the set flags
+	Flags []SetFlag
+
+	// Timeout is the time that an element will stay in the set before being removed.
+	// (Optional; mandatory for sets that will be added to from the packet path)
+	Timeout *time.Duration
+
+	// GCInterval is the interval at which timed-out elements will be removed from the
+	// set. (Optional; FIXME DEFAULT)
+	GCInterval *time.Duration
+
+	// Size if the maximum numer of elements in the set.
+	// (Optional; mandatory for sets that will be added to from the packet path)
+	Size *uint64
+
+	// Policy is the FIXME
+	Policy *SetPolicy
+
+	// AutoMerge indicates that adjacent/overlapping set elements should be merged
+	// together (only for interval sets)
+	AutoMerge *bool
+
+	// Comment is an optional comment for the object.
+	Comment *string
+
+	// Handle is an identifier that can be used to uniquely identify an object when
+	// deleting it. When adding a new object, this must be nil
+	Handle *int
+}
+
+// Map represents the definition of an nftables map (but not its elements)
+type Map struct {
+	// Name is the name of the map.
+	Name string
+
+	// Type is the type of the map key and value (eg "ipv4_addr : verdict"). Either
+	// Type or TypeOf, but not both, must be non-empty.
+	Type string
+
+	// TypeOf is the type of the set key as an nftables expression (eg "ip saddr : verdict").
+	// Either Type or TypeOf, but not both, must be non-empty.
+	TypeOf string
+
+	// Flags are the map flags
+	Flags []SetFlag
+
+	// Timeout is the time that an element will stay in the set before being removed.
+	// (Optional; mandatory for sets that will be added to from the packet path)
+	Timeout *time.Duration
+
+	// GCInterval is the interval at which timed-out elements will be removed from the
+	// set. (Optional; FIXME DEFAULT)
+	GCInterval *time.Duration
+
+	// Size if the maximum numer of elements in the set.
+	// (Optional; mandatory for sets that will be added to from the packet path)
+	Size *uint64
+
+	// Policy is the FIXME
+	Policy *SetPolicy
+
+	// Comment is an optional comment for the object.
+	Comment *string
+
+	// Handle is an identifier that can be used to uniquely identify an object when
+	// deleting it. When adding a new object, this must be nil
+	Handle *int
+}
+
+// Element represents a set or map element
+type Element struct {
+	// Name is the name of the element's set or map.
+	Name string
+
+	// Key is the element key. You can use Join() to join multiple values into a
+	// single key.
+	Key string
+
+	// Value is the map element value. As with Key, you can use Join() to join
+	// multiple values into a single value. For set elements, this must be "".
+	Value string
+
+	// Comment is an optional comment for the element
+	Comment *string
+}
diff --git a/vendor/github.com/danwinship/nftables/util.go b/vendor/github.com/danwinship/nftables/util.go
new file mode 100644
index 000000000..2d5158914
--- /dev/null
+++ b/vendor/github.com/danwinship/nftables/util.go
@@ -0,0 +1,119 @@
+/*
+Copyright 2023 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package nftables
+
+import (
+	"fmt"
+	"strconv"
+	"strings"
+)
+
+// Optional can be used to fill in optional field values in objects
+func Optional[T any](val T) *T {
+	return &val
+}
+
+var numericPriorities = map[string]int{
+	"raw":      -300,
+	"mangle":   -150,
+	"dstnat":   -100,
+	"filter":   0,
+	"security": 50,
+	"srcnat":   100,
+}
+
+var bridgeNumericPriorities = map[string]int{
+	"dstnat": -300,
+	"filter": -200,
+	"out":    100,
+	"srcnat": 300,
+}
+
+// ParsePriority tries to convert the string form of a chain priority into a number
+func ParsePriority(family Family, priority string) (int, error) {
+	val, err := strconv.Atoi(priority)
+	if err == nil {
+		return val, nil
+	}
+
+	modVal := 0
+	if i := strings.IndexAny(priority, "+-"); i != -1 {
+		mod := priority[i:]
+		modVal, err = strconv.Atoi(mod)
+		if err != nil {
+			return 0, fmt.Errorf("could not parse modifier %q: %w", mod, err)
+		}
+		priority = priority[:i]
+	}
+
+	var found bool
+	if family == BridgeFamily {
+		val, found = bridgeNumericPriorities[priority]
+	} else {
+		val, found = numericPriorities[priority]
+	}
+	if !found {
+		return 0, fmt.Errorf("unknown priority %q", priority)
+	}
+
+	return val + modVal, nil
+}
+
+// Concat is a helper (primarily) for constructing Rule objects. It takes a series of
+// arguments and concatenates them together into a single string with spaces between the
+// arguments. Strings are output as-is, string arrays are output element by element,
+// numbers are output as with `fmt.Sprintf("%d")`, and all other types are output as with
+// `fmt.Sprintf("%s")`.
+func Concat(args ...interface{}) string {
+	b := &strings.Builder{}
+	for _, arg := range args {
+		// Ignore empty array arguments
+		if x, ok := arg.([]string); ok && len(x) == 0 {
+			continue
+		}
+
+		if b.Len() > 0 {
+			b.WriteByte(' ')
+		}
+		switch x := arg.(type) {
+		case string:
+			b.WriteString(x)
+		case []string:
+			for j, s := range x {
+				if j > 0 {
+					b.WriteByte(' ')
+				}
+				b.WriteString(s)
+			}
+		case int, uint, int16, uint16, int32, uint32, int64, uint64:
+			fmt.Fprintf(b, "%d", x)
+		default:
+			fmt.Fprintf(b, "%s", x)
+		}
+	}
+	return b.String()
+}
+
+// Join joins multiple string values together into a multi-valued set/map key/value.
+func Join(values ...string) string {
+	return strings.Join(values, " . ")
+}
+
+// Split splits an Element.Key or Element.Value into its component parts
+func Split(values string) []string {
+	return strings.Split(values, " . ")
+}
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 43f5fbe56..0e0f17396 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -72,6 +72,9 @@ github.com/d2g/dhcp4client
 github.com/d2g/dhcp4server
 github.com/d2g/dhcp4server/leasepool
 github.com/d2g/dhcp4server/leasepool/memorypool
+# github.com/danwinship/nftables v0.0.8
+## explicit; go 1.20
+github.com/danwinship/nftables
 # github.com/go-logr/logr v1.2.4
 ## explicit; go 1.16
 github.com/go-logr/logr

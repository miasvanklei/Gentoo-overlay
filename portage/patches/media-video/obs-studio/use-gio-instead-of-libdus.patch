--- a/cmake/Modules/FindDBus.cmake	2021-01-09 00:43:39.000000000 +0100
+++ b/cmake/Modules/FindDBus.cmake	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-# Once done these will be defined:
-#
-#  DBUS_FOUND
-#  DBUS_INCLUDE_DIRS
-#  DBUS_LIBRARIES
-
-find_package(PkgConfig QUIET)
-if (PKG_CONFIG_FOUND)
-	pkg_check_modules(_DBUS QUIET dbus-1)
-endif()
-
-find_path(DBUS_INCLUDE_DIR
-	NAMES dbus/dbus.h
-	HINTS
-		${_DBUS_INCLUDE_DIRS}
-	PATHS
-		/usr/include /usr/local/include /opt/local/include)
-
-find_path(DBUS_ARCH_INCLUDE_DIR
-	NAMES dbus/dbus-arch-deps.h
-	HINTS
-		${_DBUS_INCLUDE_DIRS}
-	PATHS
-		/usr/include /usr/local/include /opt/local/include)
-
-find_library(DBUS_LIB
-	NAMES dbus-1
-	HINTS
-		${_DBUS_LIBRARY_DIRS}
-	PATHS
-		/usr/lib /usr/local/lib /opt/local/lib)
-
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(DBus DEFAULT_MSG DBUS_LIB DBUS_INCLUDE_DIR DBUS_ARCH_INCLUDE_DIR)
-mark_as_advanced(DBUS_INCLUDE_DIR DBUS_ARCH_INCLUDE_DIR DBUS_LIB)
-
-if(DBUS_FOUND)
-	set(DBUS_INCLUDE_DIRS ${DBUS_INCLUDE_DIR} ${DBUS_ARCH_INCLUDE_DIR})
-	set(DBUS_LIBRARIES ${DBUS_LIB})
-	set(HAVE_DBUS "1")
-else()
-	set(HAVE_DBUS "0")
-endif()
--- a/cmake/Modules/FindGio.cmake	1970-01-01 01:00:00.000000000 +0100
+++ b/cmake/Modules/FindGio.cmake	2021-04-02 21:15:28.352031517 +0200
@@ -0,0 +1,27 @@
+# - Try to find Gio
+# Once done this will define
+#
+#  GIO_FOUND - system has Gio
+#  GIO_INCLUDE_DIRS - the Gio include directory
+#  GIO_LIBRARIES - the libraries needed to use Gio
+#  GIO_DEFINITIONS - Compiler switches required for using Gio
+
+# Use pkg-config to get the directories and then use these values
+# in the find_path() and find_library() calls
+find_package(PkgConfig)
+pkg_check_modules(PC_GIO gio-2.0)
+
+set(GIO_DEFINITIONS ${PC_GIO_CFLAGS})
+
+find_path(GIO_INCLUDE_DIRS gio.h PATHS ${PC_GIO_INCLUDEDIR} ${PC_GIO_INCLUDE_DIRS} PATH_SUFFIXES glib-2.0/gio/)
+find_library(GIO_LIBRARIES NAMES gio-2.0 libgio-2.0 PATHS ${PC_GIO_LIBDIR} ${PC_GIO_LIBRARY_DIRS})
+mark_as_advanced(GIO_INCLUDE_DIRS GIO_LIBRARIES)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Gio REQUIRED_VARS GIO_LIBRARIES GIO_INCLUDE_DIRS)
+
+if(GIO_FOUND)
+  set(HAVE_DBUS "1")
+else()
+  set(HAVE_DBUS "0")
+endif()
--- a/libobs/CMakeLists.txt	2021-01-09 00:43:39.000000000 +0100
+++ b/libobs/CMakeLists.txt	2021-04-02 21:15:28.359031552 +0200
@@ -36,7 +36,7 @@
 		set(HAVE_PULSEAUDIO "0")
 		set(USE_XINPUT "0")
 	endif()
-	find_package(DBus QUIET)
+	find_package(Gio QUIET)
 else()
 	set(HAVE_DBUS "0")
 	set(HAVE_PULSEAUDIO "0")
@@ -203,13 +203,15 @@
 		set(libobs_audio_monitoring_SOURCES
 			audio-monitoring/null/null-audio-monitoring.c)
 	endif()
-	if(DBUS_FOUND)
+	if(GIO_FOUND)
 		set(libobs_PLATFORM_SOURCES ${libobs_PLATFORM_SOURCES}
 			util/platform-nix-dbus.c)
-		include_directories(${DBUS_INCLUDE_DIRS})
+		include_directories(${GIO_INCLUDE_DIRS})
+		add_definitions(
+			${GIO_DEFINITIONS})
 		set(libobs_PLATFORM_DEPS
 			${libobs_PLATFORM_DEPS}
-			${DBUS_LIBRARIES})
+			${GIO_LIBRARIES})
 	endif()
 
 	include_directories(
--- a/libobs/util/platform-nix-dbus.c	2021-01-09 00:43:39.000000000 +0100
+++ b/libobs/util/platform-nix-dbus.c	2021-04-02 21:15:32.689053209 +0200
@@ -15,7 +15,7 @@
  */
 
 #include <assert.h>
-#include <dbus/dbus.h>
+#include <gio/gio.h>
 #include "bmem.h"
 
 /* NOTE: This is basically just the VLC implementation from its d-bus power
@@ -31,6 +31,7 @@
 struct service_info {
 	const char *name;
 	const char *path;
+	const char *interface;
 	const char *uninhibit;
 };
 
@@ -39,24 +40,28 @@
 		{
 			.name = "org.freedesktop.ScreenSaver",
 			.path = "/ScreenSaver",
+			.interface = "org.freedesktop.ScreenSaver",
 			.uninhibit = "UnInhibit",
 		},
 	[FREEDESKTOP_PM] =
 		{
 			.name = "org.freedesktop.PowerManagement.Inhibit",
 			.path = "/org/freedesktop/PowerManagement",
+			.interface = "org.freedesktop.PowerManagement.Inhibit",
 			.uninhibit = "UnInhibit",
 		},
 	[MATE_SM] =
 		{
 			.name = "org.mate.SessionManager",
 			.path = "/org/mate/SessionManager",
+			.interface = "org.mate.SessionManager",
 			.uninhibit = "Uninhibit",
 		},
 	[GNOME_SM] =
 		{
 			.name = "org.gnome.SessionManager",
 			.path = "/org/gnome/SessionManager",
+			.interface = "org.gnome.SessionManager",
 			.uninhibit = "Uninhibit",
 		},
 };
@@ -66,22 +71,15 @@
 
 struct dbus_sleep_info {
 	const struct service_info *service;
-	DBusPendingCall *pending;
-	DBusConnection *c;
-	dbus_uint32_t id;
+	GDBusConnection *c;
+	uint32_t cookie;
 	enum service_type type;
 };
 
 void dbus_sleep_info_destroy(struct dbus_sleep_info *info)
 {
 	if (info) {
-		if (info->pending) {
-			dbus_pending_call_cancel(info->pending);
-			dbus_pending_call_unref(info->pending);
-		}
-
-		dbus_connection_close(info->c);
-		dbus_connection_unref(info->c);
+		g_clear_object(&info->c);
 		bfree(info);
 	}
 }
@@ -89,25 +87,30 @@
 struct dbus_sleep_info *dbus_sleep_info_create(void)
 {
 	struct dbus_sleep_info *info = bzalloc(sizeof(*info));
-	DBusError err;
+	g_autoptr(GError) error = NULL;
 
-	dbus_error_init(&err);
-
-	info->c = dbus_bus_get_private(DBUS_BUS_SESSION, &err);
+	info->c = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &error);
 	if (!info->c) {
 		blog(LOG_ERROR, "Could not create dbus connection: %s",
-		     err.message);
+		     error->message);
 		bfree(info);
 		return NULL;
 	}
 
 	for (size_t i = 0; i < num_services; i++) {
 		const struct service_info *service = &services[i];
+		g_autoptr(GVariant) reply = NULL;
 
 		if (!service->name)
 			continue;
 
-		if (dbus_bus_name_has_owner(info->c, service->name, NULL)) {
+		reply = g_dbus_connection_call_sync(
+			info->c, "org.freedesktop.DBus",
+			"/org/freedesktop/DBus", "org.freedesktop.DBus",
+			"GetNameOwner", g_variant_new("(s)", service->name),
+			NULL, G_DBUS_CALL_FLAGS_NO_AUTO_START, -1, NULL, NULL);
+
+		if (reply != NULL) {
 			blog(LOG_DEBUG, "Found dbus service: %s",
 			     service->name);
 			info->service = service;
@@ -123,79 +126,51 @@
 void dbus_inhibit_sleep(struct dbus_sleep_info *info, const char *reason,
 			bool active)
 {
-	DBusMessage *reply;
+	g_autoptr(GVariant) reply = NULL;
+	g_autoptr(GError) error = NULL;
 	const char *method;
-	dbus_bool_t success;
-
-	if (info->pending) {
-
-		dbus_pending_call_block(info->pending);
-		reply = dbus_pending_call_steal_reply(info->pending);
-		dbus_pending_call_unref(info->pending);
-		info->pending = NULL;
-
-		if (reply) {
-			success = dbus_message_get_args(reply, NULL,
-							DBUS_TYPE_UINT32,
-							&info->id,
-							DBUS_TYPE_INVALID);
-			if (!success)
-				info->id = 0;
-			dbus_message_unref(reply);
-		}
-	}
+	GVariant *params;
 
-	if (active == !!info->id)
+	if (active == !!info->cookie)
 		return;
 
 	method = active ? "Inhibit" : info->service->uninhibit;
 
-	reply = dbus_message_new_method_call(info->service->name,
-					     info->service->path,
-					     info->service->name, method);
-	if (reply == NULL) {
-		blog(LOG_ERROR, "dbus_message_new_method_call failed");
-		return;
-	}
-
 	if (active) {
 		const char *program = "libobs";
-		dbus_uint32_t flags = 0xC;
-		dbus_uint32_t xid = 0;
+		uint32_t flags = 0xC;
+		uint32_t xid = 0;
 
-		assert(info->id == 0);
+		assert(info->cookie == 0);
 
 		switch (info->type) {
 		case MATE_SM:
 		case GNOME_SM:
-			success = dbus_message_append_args(
-				reply, DBUS_TYPE_STRING, &program,
-				DBUS_TYPE_UINT32, &xid, DBUS_TYPE_STRING,
-				&reason, DBUS_TYPE_UINT32, &flags,
-				DBUS_TYPE_INVALID);
+			params = g_variant_new("(s@usu)", program,
+					       g_variant_new_uint32(xid),
+					       reason, flags);
 			break;
 		default:
-			success = dbus_message_append_args(
-				reply, DBUS_TYPE_STRING, &program,
-				DBUS_TYPE_STRING, &reason, DBUS_TYPE_INVALID);
-		}
-
-		if (success) {
-			success = dbus_connection_send_with_reply(
-				info->c, reply, &info->pending, -1);
-			if (!success)
-				info->pending = NULL;
+			params = g_variant_new("(ss)", program, reason);
 		}
 	} else {
-		assert(info->id != 0);
-		success = dbus_message_append_args(
-			reply, DBUS_TYPE_UINT32, &info->id, DBUS_TYPE_INVALID);
-		if (success)
-			success = dbus_connection_send(info->c, reply, NULL);
-		if (!success)
-			info->id = 0;
+		assert(info->cookie != 0);
+		params = g_variant_new("(u)", info->cookie);
+	}
+
+	reply = g_dbus_connection_call_sync(
+		info->c, info->service->name, info->service->path,
+		info->service->interface, method, params, NULL,
+		G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
+
+	if (error != NULL) {
+		blog(LOG_ERROR, "Failed to call %s: %s", method,
+		     error->message);
+		return;
 	}
 
-	dbus_connection_flush(info->c);
-	dbus_message_unref(reply);
+	if (active)
+		g_variant_get(reply, "(u)", &info->cookie);
+	else
+		info->cookie = 0;
 }

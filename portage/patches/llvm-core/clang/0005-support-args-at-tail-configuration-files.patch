--- a/clang/include/clang/Driver/Driver.h	2025-08-26 16:19:30.000000000 +0200
+++ b/clang/include/clang/Driver/Driver.h	2025-08-27 12:45:41.717063192 +0200
@@ -322,11 +322,14 @@
   /// Object that stores strings read from configuration file.
   llvm::StringSaver Saver;
 
-  /// Arguments originated from configuration file (head part).
-  std::unique_ptr<llvm::opt::InputArgList> CfgOptionsHead;
+  /// Arguments originated from configuration file (compile head part).
+  std::unique_ptr<llvm::opt::InputArgList> CfgOptionsCompileHead;
 
-  /// Arguments originated from configuration file (tail part).
-  std::unique_ptr<llvm::opt::InputArgList> CfgOptionsTail;
+  /// Arguments originated from configuration file (compile tail part).
+  std::unique_ptr<llvm::opt::InputArgList> CfgOptionsCompileTail;
+
+  /// Arguments originated from configuration file (link part).
+  std::unique_ptr<llvm::opt::InputArgList> CfgOptionsLink;
 
   /// Arguments originated from command line.
   std::unique_ptr<llvm::opt::InputArgList> CLOptions;
--- a/clang/lib/Driver/Driver.cpp	2025-08-26 16:19:30.000000000 +0200
+++ b/clang/lib/Driver/Driver.cpp	2025-08-27 12:44:32.665732098 +0200
@@ -1244,50 +1244,66 @@
     return true;
   }
 
-  // Populate head and tail lists. The tail list is used only when linking.
-  SmallVector<const char *, 32> NewCfgHeadArgs, NewCfgTailArgs;
+  // Populate compile and linking lists.
+  SmallVector<const char *, 32> NewCfgCompileHeadArgs, NewCfgCompileTailArgs, NewCfgLinkArgs;
   for (const char *Opt : NewCfgFileArgs) {
     // An $-prefixed option should go to the tail list.
     if (Opt[0] == '$' && Opt[1])
-      NewCfgTailArgs.push_back(Opt + 1);
+      NewCfgLinkArgs.push_back(Opt + 1);
+    else if (Opt[0] == '%' && Opt[1])
+      NewCfgCompileTailArgs.push_back(Opt + 1);
     else
-      NewCfgHeadArgs.push_back(Opt);
+      NewCfgCompileHeadArgs.push_back(Opt);
   }
 
   // Read options from config file.
   llvm::SmallString<128> CfgFileName(FileName);
   llvm::sys::path::native(CfgFileName);
   bool ContainErrors = false;
-  auto NewHeadOptions = std::make_unique<InputArgList>(
-      ParseArgStrings(NewCfgHeadArgs, /*UseDriverMode=*/true, ContainErrors));
+  auto NewCompileHeadOptions = std::make_unique<InputArgList>(
+      ParseArgStrings(NewCfgCompileHeadArgs, /*UseDriverMode=*/true, ContainErrors));
   if (ContainErrors)
     return true;
-  auto NewTailOptions = std::make_unique<InputArgList>(
-      ParseArgStrings(NewCfgTailArgs, /*UseDriverMode=*/true, ContainErrors));
+  auto NewCompileTailOptions = std::make_unique<InputArgList>(
+      ParseArgStrings(NewCfgCompileTailArgs, /*UseDriverMode=*/true, ContainErrors));
+  if (ContainErrors)
+    return true;
+  auto NewLinkOptions = std::make_unique<InputArgList>(
+      ParseArgStrings(NewCfgLinkArgs, /*UseDriverMode=*/true, ContainErrors));
   if (ContainErrors)
     return true;
 
   // Claim all arguments that come from a configuration file so that the driver
   // does not warn on any that is unused.
-  for (Arg *A : *NewHeadOptions)
+  for (Arg *A : *NewCompileHeadOptions)
+    A->claim();
+  for (Arg *A : *NewCompileTailOptions)
     A->claim();
-  for (Arg *A : *NewTailOptions)
+  for (Arg *A : *NewLinkOptions)
     A->claim();
 
-  if (!CfgOptionsHead)
-    CfgOptionsHead = std::move(NewHeadOptions);
+  if (!CfgOptionsCompileHead)
+    CfgOptionsCompileHead = std::move(NewCompileHeadOptions);
+  else {
+    // If this is a subsequent config file, append options to the previous one.
+    for (auto *Opt : *NewCompileHeadOptions)
+      appendOneArg(*CfgOptionsCompileHead, Opt);
+  }
+
+  if (!CfgOptionsCompileTail)
+    CfgOptionsCompileTail = std::move(NewCompileTailOptions);
   else {
     // If this is a subsequent config file, append options to the previous one.
-    for (auto *Opt : *NewHeadOptions)
-      appendOneArg(*CfgOptionsHead, Opt);
+    for (auto *Opt : *NewCompileTailOptions)
+      appendOneArg(*CfgOptionsCompileTail, Opt);
   }
 
-  if (!CfgOptionsTail)
-    CfgOptionsTail = std::move(NewTailOptions);
+  if (!CfgOptionsLink)
+    CfgOptionsLink = std::move(NewLinkOptions);
   else {
     // If this is a subsequent config file, append options to the previous one.
-    for (auto *Opt : *NewTailOptions)
-      appendOneArg(*CfgOptionsTail, Opt);
+    for (auto *Opt : *NewLinkOptions)
+      appendOneArg(*CfgOptionsLink, Opt);
   }
 
   ConfigFiles.push_back(std::string(CfgFileName));
@@ -1498,18 +1514,24 @@
   // Try parsing configuration file.
   if (!ContainsError)
     ContainsError = loadConfigFiles();
-  bool HasConfigFileHead = !ContainsError && CfgOptionsHead;
-  bool HasConfigFileTail = !ContainsError && CfgOptionsTail;
+  bool HasConfigFileCompileHead = !ContainsError && CfgOptionsCompileHead;
+  bool HasConfigFileCompileTail = !ContainsError && CfgOptionsCompileTail;
+  bool HasConfigFileLink = !ContainsError && CfgOptionsLink;
 
   // All arguments, from both config file and command line.
   InputArgList Args =
-      HasConfigFileHead ? std::move(*CfgOptionsHead) : std::move(*CLOptions);
+      HasConfigFileCompileHead ? std::move(*CfgOptionsCompileHead) : std::move(*CLOptions);
 
-  if (HasConfigFileHead)
+  if (HasConfigFileCompileHead)
     for (auto *Opt : *CLOptions)
       if (!Opt->getOption().matches(options::OPT_config))
         appendOneArg(Args, Opt);
 
+  if (HasConfigFileCompileTail)
+    for (auto *Opt : *CfgOptionsCompileTail)
+      if (!Opt->getOption().matches(options::OPT_config))
+        appendOneArg(Args, Opt);
+
   // In CL mode, look for any pass-through arguments
   if (IsCLMode() && !ContainsError) {
     SmallVector<const char *, 16> CLModePassThroughArgList;
@@ -1818,11 +1840,11 @@
   // Construct the list of inputs.
   InputList Inputs;
   BuildInputs(C->getDefaultToolChain(), *TranslatedArgs, Inputs);
-  if (HasConfigFileTail && Inputs.size()) {
+  if (HasConfigFileLink && Inputs.size()) {
     Arg *FinalPhaseArg;
     if (getFinalPhase(*TranslatedArgs, &FinalPhaseArg) == phases::Link) {
-      DerivedArgList TranslatedLinkerIns(*CfgOptionsTail);
-      for (Arg *A : *CfgOptionsTail)
+      DerivedArgList TranslatedLinkerIns(*CfgOptionsLink);
+      for (Arg *A : *CfgOptionsLink)
         TranslatedLinkerIns.append(A);
       BuildInputs(C->getDefaultToolChain(), TranslatedLinkerIns, Inputs);
     }

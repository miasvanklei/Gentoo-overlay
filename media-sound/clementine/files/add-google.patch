diff --git a/ext/libclementine-common/CMakeLists.txt b/ext/libclementine-common/CMakeLists.txt
index 25b3225..8598ebc 100644
--- a/ext/libclementine-common/CMakeLists.txt
+++ b/ext/libclementine-common/CMakeLists.txt
@@ -7,6 +7,7 @@ set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --std=c++0x")
 
 set(SOURCES
   core/closure.cpp
+  core/latch.cpp
   core/logging.cpp
   core/messagehandler.cpp
   core/messagereply.cpp
@@ -16,6 +17,7 @@ set(SOURCES
 
 set(HEADERS
   core/closure.h
+  core/latch.h
   core/messagehandler.h
   core/messagereply.h
   core/workerpool.h
diff --git a/ext/libclementine-common/core/latch.cpp b/ext/libclementine-common/core/latch.cpp
new file mode 100644
index 0000000..ed4448c
--- /dev/null
+++ b/ext/libclementine-common/core/latch.cpp
@@ -0,0 +1,35 @@
+/* This file is part of Clementine.
+   Copyright 2016, John Maguire <john.maguire@gmail.com>
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+#include "latch.h"
+
+#include "core/logging.h"
+
+CountdownLatch::CountdownLatch() : count_(0) {}
+
+void CountdownLatch::Wait() {
+  QMutexLocker l(&mutex_);
+  ++count_;
+}
+
+void CountdownLatch::CountDown() {
+  QMutexLocker l(&mutex_);
+  Q_ASSERT(count_ > 0);
+  --count_;
+  if (count_ == 0) {
+    emit Done();
+  }
+}
diff --git a/ext/libclementine-common/core/latch.h b/ext/libclementine-common/core/latch.h
new file mode 100644
index 0000000..bec6f64
--- /dev/null
+++ b/ext/libclementine-common/core/latch.h
@@ -0,0 +1,38 @@
+/* This file is part of Clementine.
+   Copyright 2016, John Maguire <john.maguire@gmail.com>
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+#ifndef CORE_LATCH_H
+#define CORE_LATCH_H
+
+#include <QMutex>
+#include <QObject>
+
+class CountdownLatch : public QObject {
+  Q_OBJECT
+ public:
+  CountdownLatch();
+  void Wait();
+  void CountDown();
+
+signals:
+  void Done();
+
+ private:
+  QMutex mutex_;
+  int count_;
+};
+
+#endif  // CORE_LATCH_H
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index d6ff2bb..501e843 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -291,6 +291,7 @@ set(SOURCES
   smartplaylists/wizard.cpp
   smartplaylists/wizardplugin.cpp
 
+  songinfo/artistbiography.cpp
   songinfo/artistinfoview.cpp
   songinfo/collapsibleinfoheader.cpp
   songinfo/collapsibleinfopane.cpp
@@ -582,6 +583,7 @@ set(HEADERS
   smartplaylists/wizard.h
   smartplaylists/wizardplugin.h
 
+  songinfo/artistbiography.h
   songinfo/artistinfoview.h
   songinfo/collapsibleinfoheader.h
   songinfo/collapsibleinfopane.h
diff --git a/src/songinfo/artistbiography.cpp b/src/songinfo/artistbiography.cpp
new file mode 100644
index 0000000..1624e0b
--- /dev/null
+++ b/src/songinfo/artistbiography.cpp
@@ -0,0 +1,276 @@
+/* This file is part of Clementine.
+   Copyright 2016, John Maguire <john.maguire@gmail.com>
+
+   Clementine is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Clementine is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "artistbiography.h"
+
+#include <QLocale>
+#include <QUrlQuery>
+#include <QJsonObject>
+#include <QJsonDocument>
+#include <QJsonArray>
+#include <QJsonValue>
+
+#include "core/closure.h"
+#include "core/latch.h"
+#include "core/logging.h"
+#include "core/network.h"
+#include "songinfo/songinfotextview.h"
+#include "ui/iconloader.h"
+
+namespace {
+const char* kArtistBioUrl = "https://data.clementine-player.org/fetchbio";
+const char* kWikipediaImageListUrl =
+    "https://%1.wikipedia.org/w/"
+    "api.php?action=query&prop=images&format=json%imlimit=25";
+const char* kWikipediaImageInfoUrl =
+    "https://%1.wikipedia.org/w/"
+    "api.php?action=query&prop=imageinfo&iiprop=url|size%format=json";
+const char* kWikipediaExtractUrl =
+    "https://%1.wikipedia.org/w/"
+    "api.php?action=query&format=json&prop=extracts";
+const int kMinimumImageSize = 400;
+
+QString GetLocale() {
+  QLocale locale;
+  return locale.name().split('_')[0];
+}
+
+}  // namespace
+
+ArtistBiography::ArtistBiography() : network_(new NetworkAccessManager) {}
+
+ArtistBiography::~ArtistBiography() {}
+
+void ArtistBiography::FetchInfo(int id, const Song& metadata) {
+  if (metadata.artist().isEmpty()) {
+    emit Finished(id);
+    return;
+  }
+
+
+  QUrl url(kArtistBioUrl);
+  QUrlQuery url_query;
+  url_query.addQueryItem("artist", metadata.artist());
+  url_query.addQueryItem("lang", GetLocale());
+  url.setQuery(url_query);
+
+  qLog(Debug) << "Biography url: " << url;
+
+  QNetworkRequest request(url);
+  QNetworkReply* reply = network_->get(request);
+
+  NewClosure(reply, SIGNAL(finished()), [this, reply, id]() {
+    reply->deleteLater();
+
+    QVariantMap response = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
+
+    QString body = response["articleBody"].toString();
+    QString url = response["url"].toString();
+
+    CountdownLatch* latch = new CountdownLatch;
+
+    if (url.contains("wikipedia.org")) {
+      FetchWikipediaImages(id, url, latch);
+      FetchWikipediaArticle(id, url, latch);
+    } else {
+      latch->Wait();
+      if (!body.isEmpty()) {
+        CollapsibleInfoPane::Data data;
+        data.id_ = url;
+        data.title_ = tr("Biography");
+        data.type_ = CollapsibleInfoPane::Data::Type_Biography;
+
+        QString text;
+        text +=
+            "<p><a href=\"" + url + "\">" + tr("Open in your browser") + "</a></p>";
+
+        text += body;
+        SongInfoTextView* editor = new SongInfoTextView;
+        editor->SetHtml(text);
+        data.contents_ = editor;
+        emit InfoReady(id, data);
+      }
+      latch->CountDown();
+    }
+
+    NewClosure(latch, SIGNAL(Done()), [this, id, latch]() {
+      latch->deleteLater();
+      emit Finished(id);
+    });
+  });
+}
+
+namespace {
+
+QStringList ExtractImageTitles(const QVariantMap& json) {
+  QStringList ret;
+  for (auto it = json.constBegin(); it != json.constEnd(); ++it) {
+    if (it.value().type() == QVariant::Map) {
+      ret.append(ExtractImageTitles(it.value().toMap()));
+    } else if (it.key() == "images" && it.value().type() == QVariant::List) {
+      QVariantList images = it.value().toList();
+      for (QVariant i : images) {
+        QVariantMap image = i.toMap();
+        QString image_title = image["title"].toString();
+        if (!image_title.isEmpty() &&
+            (
+                // SVGs tend to be irrelevant icons.
+                image_title.endsWith(".jpg", Qt::CaseInsensitive) ||
+                image_title.endsWith(".png", Qt::CaseInsensitive))) {
+          ret.append(image_title);
+        }
+      }
+    }
+  }
+  return ret;
+}
+
+QUrl ExtractImageUrl(const QVariantMap& json) {
+  for (auto it = json.constBegin(); it != json.constEnd(); ++it) {
+    if (it.value().type() == QVariant::Map) {
+      QUrl r = ExtractImageUrl(it.value().toMap());
+      if (!r.isEmpty()) {
+        return r;
+      }
+    } else if (it.key() == "imageinfo") {
+      QVariantList imageinfos = it.value().toList();
+      QVariantMap imageinfo = imageinfos.first().toMap();
+      int width = imageinfo["width"].toInt();
+      int height = imageinfo["height"].toInt();
+      if (width < kMinimumImageSize || height < kMinimumImageSize) {
+        return QUrl();
+      }
+      return QUrl::fromEncoded(imageinfo["url"].toByteArray());
+    }
+  }
+  return QUrl();
+}
+
+QString ExtractExtract(const QVariantMap& json) {
+  for (auto it = json.constBegin(); it != json.constEnd(); ++it) {
+    if (it.value().type() == QVariant::Map) {
+      QString extract = ExtractExtract(it.value().toMap());
+      if (!extract.isEmpty()) {
+        return extract;
+      }
+    } else if (it.key() == "extract") {
+      return it.value().toString();
+    }
+  }
+  return QString::null;
+}
+
+}  // namespace
+
+void ArtistBiography::FetchWikipediaImages(int id,
+                                           const QString& wikipedia_url, CountdownLatch* latch) {
+  latch->Wait();
+  qLog(Debug) << wikipedia_url;
+  QRegExp regex("([a-z]+)\\.wikipedia\\.org/wiki/(.*)");
+  if (regex.indexIn(wikipedia_url) == -1) {
+    emit Finished(id);
+    return;
+  }
+  QString wiki_title = QUrl::fromPercentEncoding(regex.cap(2).toUtf8());
+  QString language = regex.cap(1);
+  QUrl url(QString(kWikipediaImageListUrl).arg(language));
+  QUrlQuery url_query;
+  url_query.addQueryItem("titles", wiki_title);
+  url.setQuery(url_query);
+
+  qLog(Debug) << "Wikipedia images:" << url;
+
+  QNetworkRequest request(url);
+  QNetworkReply* reply = network_->get(request);
+  NewClosure(reply, SIGNAL(finished()), [this, id, reply, language, latch]() {
+    reply->deleteLater();
+
+    QVariantMap response = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
+
+    QStringList image_titles = ExtractImageTitles(response);
+
+    for (const QString& image_title : image_titles) {
+      latch->Wait();
+      QUrl url(QString(kWikipediaImageInfoUrl).arg(language));
+      QUrlQuery url_query;
+      url_query.addQueryItem("titles", image_title);
+      url.setQuery(url_query);
+      qLog(Debug) << "Image info:" << url;
+
+      QNetworkRequest request(url);
+      QNetworkReply* reply = network_->get(request);
+      NewClosure(reply, SIGNAL(finished()), [this, id, reply, latch]() {
+        reply->deleteLater();
+        QVariantMap json = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
+        QUrl url = ExtractImageUrl(json);
+        qLog(Debug) << "Found wikipedia image url:" << url;
+        if (!url.isEmpty()) {
+          emit ImageReady(id, url);
+        }
+        latch->CountDown();
+      });
+    }
+
+    latch->CountDown();
+  });
+}
+void ArtistBiography::FetchWikipediaArticle(int id,
+                                            const QString& wikipedia_url,
+                                            CountdownLatch* latch) {
+  latch->Wait();
+  QRegExp regex("([a-z]+)\\.wikipedia\\.org/wiki/(.*)");
+  if (regex.indexIn(wikipedia_url) == -1) {
+    emit Finished(id);
+    return;
+  }
+  QString wiki_title = QUrl::fromPercentEncoding(regex.cap(2).toUtf8());
+  QString language = regex.cap(1);
+
+  QUrl url(QString(kWikipediaExtractUrl).arg(language));
+  QUrlQuery url_query;
+  url_query.addQueryItem("titles", wiki_title);
+  url.setQuery(url_query);
+  QNetworkRequest request(url);
+  QNetworkReply* reply = network_->get(request);
+
+  qLog(Debug) << "Article url:" << url;
+
+  NewClosure(reply, SIGNAL(finished()),
+             [this, id, reply, wikipedia_url, latch]() {
+    reply->deleteLater();
+
+    QVariantMap json = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
+    QString html = ExtractExtract(json);
+
+    CollapsibleInfoPane::Data data;
+    data.id_ = wikipedia_url;
+    data.title_ = tr("Biography");
+    data.type_ = CollapsibleInfoPane::Data::Type_Biography;
+    data.icon_ = IconLoader::Load("wikipedia", IconLoader::Provider);
+
+    QString text;
+    text += "<p><a href=\"" + wikipedia_url + "\">" +
+            tr("Open in your browser") + "</a></p>";
+
+    text += html;
+    SongInfoTextView* editor = new SongInfoTextView;
+    editor->SetHtml(text);
+    data.contents_ = editor;
+    emit InfoReady(id, data);
+    latch->CountDown();
+  });
+}
diff --git a/src/songinfo/artistbiography.h b/src/songinfo/artistbiography.h
new file mode 100644
index 0000000..2b6c9e1
--- /dev/null
+++ b/src/songinfo/artistbiography.h
@@ -0,0 +1,45 @@
+/* This file is part of Clementine.
+   Copyright 2016, John Maguire <john.maguire@gmail.com>
+
+   Clementine is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Clementine is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef ARTISTBIOGRAPHY_H
+#define ARTISTBIOGRAPHY_H
+
+#include <memory>
+
+#include "songinfoprovider.h"
+
+class CountdownLatch;
+class NetworkAccessManager;
+
+class ArtistBiography : public SongInfoProvider {
+  Q_OBJECT
+
+ public:
+  ArtistBiography();
+  ~ArtistBiography();
+
+  void FetchInfo(int id, const Song& metadata) override;
+
+ private:
+  void FetchWikipediaImages(int id, const QString& title,
+                            CountdownLatch* latch);
+  void FetchWikipediaArticle(int id, const QString& url, CountdownLatch* latch);
+
+  std::unique_ptr<NetworkAccessManager> network_;
+};
+
+#endif  // ARTISTBIOGRAPHY_H
diff --git a/src/songinfo/artistinfoview.cpp b/src/songinfo/artistinfoview.cpp
index 6bab19a..e336fb4 100644
--- a/src/songinfo/artistinfoview.cpp
+++ b/src/songinfo/artistinfoview.cpp
@@ -16,6 +16,7 @@
 */
 
 #include "artistinfoview.h"
+#include "songinfo/artistbiography.h"
 #include "songinfo/songinfofetcher.h"
 #include "songinfo/songkickconcerts.h"
 #include "songinfo/spotifyimages.h"
@@ -24,6 +25,7 @@
 ArtistInfoView::ArtistInfoView(QWidget* parent) : SongInfoBase(parent) {
   fetcher_->AddProvider(new SongkickConcerts);
   fetcher_->AddProvider(new SpotifyImages);
+  fetcher_->AddProvider(new ArtistBiography);
 }
 
 ArtistInfoView::~ArtistInfoView() {}
diff --git a/src/songinfo/songkickconcerts.cpp b/src/songinfo/songkickconcerts.cpp
index a832438..70bd586 100644
--- a/src/songinfo/songkickconcerts.cpp
+++ b/src/songinfo/songkickconcerts.cpp
@@ -23,6 +23,7 @@
 #include <QJsonDocument>
 #include <QJsonObject>
 #include <QJsonArray>
+#include <QUrlQuery>
 
 #include "core/closure.h"
 #include "core/logging.h"
diff --git a/src/songinfo/spotifyimages.cpp b/src/songinfo/spotifyimages.cpp
index 041c6cc..042a1f3 100644
--- a/src/songinfo/spotifyimages.cpp
+++ b/src/songinfo/spotifyimages.cpp
@@ -24,8 +24,7 @@ QString ExtractSpotifyId(const QString& spotify_uri) {
 }
 }  // namespace
 
-SpotifyImages::SpotifyImages()
-  : network_(new NetworkAccessManager) {
+SpotifyImages::SpotifyImages() : network_(new NetworkAccessManager) {
 }
 
 SpotifyImages::~SpotifyImages() {}
@@ -85,13 +84,18 @@ void SpotifyImages::FetchImagesForArtist(int id, const QString& spotify_id) {
       QUrl url = image["url"].toUrl();
       image_candidates.append(qMakePair(url, QSize(width, height)));
     }
-    QPair<QUrl, QSize> winner = *std::max_element(
-        image_candidates.begin(),
-        image_candidates.end(),
-        [](const QPair<QUrl, QSize>& a, const QPair<QUrl, QSize>& b) {
-          return (a.second.height() * a.second.width()) < (b.second.height() * b.second.width());
-        });
-    emit ImageReady(id, winner.first);
+    if (!image_candidates.isEmpty()) {
+      QPair<QUrl, QSize> winner =
+           *std::max_element(
+                image_candidates.begin(),
+                image_candidates.end(),
+                [](const QPair<QUrl, QSize>& a, const QPair<QUrl, QSize>& b) {
+
+                  return (a.second.height() * a.second.width()) <
+                         (b.second.height() * b.second.width());
+              });
+      emit ImageReady(id, winner.first);
+    }
     emit Finished(id);
   });
 }
diff --git a/src/widgets/prettyimage.cpp b/src/widgets/prettyimage.cpp
index 3b8536d..bfb3959 100644
--- a/src/widgets/prettyimage.cpp
+++ b/src/widgets/prettyimage.cpp
@@ -88,7 +88,8 @@ void PrettyImage::ImageFetched(RedirectFollower* follower) {
 
   QImage image = QImage::fromData(reply->readAll());
   if (image.isNull()) {
-    qLog(Debug) << "Image failed to load" << reply->request().url();
+    qLog(Debug) << "Image failed to load" << reply->request().url()
+                << reply->error();
     deleteLater();
   } else {
     state_ = State_CreatingThumbnail;

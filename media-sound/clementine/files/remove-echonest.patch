diff --git a/CMakeLists.txt b/CMakeLists.txt
index 133f25b..02b248a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -371,9 +371,6 @@ else (USE_SYSTEM_QXT)
   endif (NOT APPLE)
 endif (USE_SYSTEM_QXT)
 
-find_path(ECHONEST5_INCLUDE_DIRS Artist.h PATH_SUFFIXES echonest5 echonest)
-find_library(ECHONEST5_LIBRARIES echonest5)
-
 # Use system gmock if it's available
 # We need to look for both gmock and gtest
 find_path(GMOCK_INCLUDE_DIRS gmock/gmock.h)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index b63c561..d6ff2bb 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -29,7 +29,6 @@ include_directories(${LIBPROJECTM_INCLUDE_DIRS})
 include_directories(${QTSINGLEAPPLICATION_INCLUDE_DIRS})
 include_directories(${QTIOCOMPRESSOR_INCLUDE_DIRS})
 include_directories(${QXT_INCLUDE_DIRS})
-include_directories(${ECHONEST5_INCLUDE_DIRS})
 include_directories(${SHA2_INCLUDE_DIRS})
 include_directories(${CHROMAPRINT_INCLUDE_DIRS})
 include_directories(${MYGPOQT5_INCLUDE_DIRS})
@@ -295,8 +294,6 @@ set(SOURCES
   songinfo/artistinfoview.cpp
   songinfo/collapsibleinfoheader.cpp
   songinfo/collapsibleinfopane.cpp
-  songinfo/echonestbiographies.cpp
-  songinfo/echonestimages.cpp
   songinfo/songinfobase.cpp
   songinfo/songinfofetcher.cpp
   songinfo/songinfoprovider.cpp
@@ -306,6 +303,7 @@ set(SOURCES
   songinfo/songkickconcerts.cpp
   songinfo/songkickconcertwidget.cpp
   songinfo/songplaystats.cpp
+  songinfo/spotifyimages.cpp
   songinfo/taglyricsinfoprovider.cpp
   songinfo/ultimatelyricslyric.cpp
   songinfo/ultimatelyricsprovider.cpp
@@ -587,8 +585,6 @@ set(HEADERS
   songinfo/artistinfoview.h
   songinfo/collapsibleinfoheader.h
   songinfo/collapsibleinfopane.h
-  songinfo/echonestbiographies.h
-  songinfo/echonestimages.h
   songinfo/songinfobase.h
   songinfo/songinfofetcher.h
   songinfo/songinfoprovider.h
@@ -598,6 +594,7 @@ set(HEADERS
   songinfo/songkickconcerts.h
   songinfo/songkickconcertwidget.h
   songinfo/songplaystats.h
+  songinfo/spotifyimages.h
   songinfo/taglyricsinfoprovider.h
   songinfo/ultimatelyricslyric.h
   songinfo/ultimatelyricsprovider.h
@@ -824,16 +821,12 @@ optional_source(HAVE_LIBLASTFM
     internet/lastfm/lastfmcompat.cpp
     internet/lastfm/lastfmservice.cpp
     internet/lastfm/lastfmsettingspage.cpp
-    songinfo/echonestsimilarartists.cpp
-    songinfo/echonesttags.cpp
     songinfo/lastfmtrackinfoprovider.cpp
     songinfo/tagwidget.cpp
   HEADERS
     covers/lastfmcoverprovider.h
     internet/lastfm/lastfmservice.h
     internet/lastfm/lastfmsettingspage.h
-    songinfo/echonestsimilarartists.h
-    songinfo/echonesttags.h
     songinfo/lastfmtrackinfoprovider.h
     songinfo/tagwidget.h
   UI
@@ -1228,7 +1221,6 @@ target_link_libraries(clementine_lib
   ${TAGLIB_LIBRARIES}
   ${MYGPOQT5_LIBRARIES}
   ${CHROMAPRINT_LIBRARIES}
-  ${ECHONEST5_LIBRARIES}
   ${GOBJECT_LIBRARIES}
   ${GLIB_LIBRARIES}
   ${GIO_LIBRARIES}
diff --git a/src/main.cpp b/src/main.cpp
index 039ae7b..faf7e6c 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -424,10 +424,6 @@ int main(int argc, char* argv[]) {
   Application app;
   app.set_language_name(language);
 
-  Echonest::Config::instance()->setAPIKey("DFLFLJBUF4EGTXHIG");
-  Echonest::Config::instance()->setNetworkAccessManager(
-      new NetworkAccessManager);
-
   // Network proxy
   QNetworkProxyFactory::setApplicationProxyFactory(
       NetworkProxyFactory::Instance());
diff --git a/src/songinfo/artistinfoview.cpp b/src/songinfo/artistinfoview.cpp
index 5acfac3..6bab19a 100644
--- a/src/songinfo/artistinfoview.cpp
+++ b/src/songinfo/artistinfoview.cpp
@@ -16,25 +16,14 @@
 */
 
 #include "artistinfoview.h"
-#include "echonestbiographies.h"
-#include "echonestimages.h"
-#include "songinfofetcher.h"
-#include "songkickconcerts.h"
+#include "songinfo/songinfofetcher.h"
+#include "songinfo/songkickconcerts.h"
+#include "songinfo/spotifyimages.h"
 #include "widgets/prettyimageview.h"
 
-#ifdef HAVE_LIBLASTFM
-#include "echonestsimilarartists.h"
-#include "echonesttags.h"
-#endif
-
 ArtistInfoView::ArtistInfoView(QWidget* parent) : SongInfoBase(parent) {
-  fetcher_->AddProvider(new EchoNestBiographies);
-  fetcher_->AddProvider(new EchoNestImages);
   fetcher_->AddProvider(new SongkickConcerts);
-#ifdef HAVE_LIBLASTFM
-  fetcher_->AddProvider(new EchoNestSimilarArtists);
-  fetcher_->AddProvider(new EchoNestTags);
-#endif
+  fetcher_->AddProvider(new SpotifyImages);
 }
 
 ArtistInfoView::~ArtistInfoView() {}
diff --git a/src/songinfo/echonestbiographies.cpp b/src/songinfo/echonestbiographies.cpp
deleted file mode 100644
index 6fb37db..0000000
--- a/src/songinfo/echonestbiographies.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "echonestbiographies.h"
-
-#include <memory>
-
-#include <Artist.h>
-
-#include "songinfotextview.h"
-#include "core/logging.h"
-#include "ui/iconloader.h"
-
-struct EchoNestBiographies::Request {
-  Request(int id) : id_(id), artist_(new Echonest::Artist) {}
-
-  int id_;
-  std::unique_ptr<Echonest::Artist> artist_;
-};
-
-EchoNestBiographies::EchoNestBiographies() {
-  site_relevance_["wikipedia"] = 100;
-  site_relevance_["lastfm"] = 60;
-  site_relevance_["amazon"] = 30;
-
-  site_icons_["amazon"] = IconLoader::Load("amazon", IconLoader::Provider);
-  site_icons_["aol"] = IconLoader::Load("aol", IconLoader::Provider);
-  site_icons_["cdbaby"] = IconLoader::Load("cdbaby", IconLoader::Provider);
-  site_icons_["lastfm"] = IconLoader::Load("as", IconLoader::Lastfm);
-  site_icons_["mog"] = IconLoader::Load("mog", IconLoader::Provider);
-  site_icons_["mtvmusic"] = IconLoader::Load("mtvmusic", IconLoader::Provider);
-  site_icons_["myspace"] = IconLoader::Load("myspace", IconLoader::Provider);
-  site_icons_["wikipedia"] = IconLoader::Load("wikipedia", IconLoader::Provider);
-}
-
-void EchoNestBiographies::FetchInfo(int id, const Song& metadata) {
-  std::shared_ptr<Request> request(new Request(id));
-  request->artist_->setName(metadata.artist());
-
-  QNetworkReply* reply = request->artist_->fetchBiographies();
-  connect(reply, SIGNAL(finished()), SLOT(RequestFinished()));
-  requests_[reply] = request;
-}
-
-void EchoNestBiographies::RequestFinished() {
-  QNetworkReply* reply = qobject_cast<QNetworkReply*>(sender());
-  if (!reply || !requests_.contains(reply)) return;
-  reply->deleteLater();
-
-  RequestPtr request = requests_.take(reply);
-
-  try {
-    request->artist_->parseProfile(reply);
-  }
-  catch (Echonest::ParseError e) {
-    qLog(Warning) << "Error parsing echonest reply:" << e.errorType()
-                  << e.what();
-  }
-
-  QSet<QString> already_seen;
-
-  for (const Echonest::Biography& bio : request->artist_->biographies()) {
-    QString canonical_site = bio.site().toLower();
-    canonical_site.replace(QRegExp("[^a-z]"), "");
-
-    if (already_seen.contains(canonical_site)) continue;
-    already_seen.insert(canonical_site);
-
-    CollapsibleInfoPane::Data data;
-    data.id_ = "echonest/bio/" + bio.site();
-    data.title_ = tr("Biography from %1").arg(bio.site());
-    data.type_ = CollapsibleInfoPane::Data::Type_Biography;
-
-    if (site_relevance_.contains(canonical_site))
-      data.relevance_ = site_relevance_[canonical_site];
-    if (site_icons_.contains(canonical_site))
-      data.icon_ = site_icons_[canonical_site];
-
-    SongInfoTextView* editor = new SongInfoTextView;
-    QString text;
-    // Add a link to the bio webpage at the top if we have one
-    if (!bio.url().isEmpty()) {
-      QString bio_url = bio.url().toEncoded();
-      if (bio.site() == "facebook") {
-        bio_url.replace("graph.facebook.com", "www.facebook.com");
-      }
-      text += "<p><a href=\"" + bio_url + "\">" +
-              tr("Open in your browser") + "</a></p>";
-    }
-
-    text += bio.text();
-    if (bio.site() == "last.fm") {
-      // Echonest lost formatting and it seems there is currently no plans on
-      // Echonest side for changing this.
-      // But with last.fm, we can guess newlines: "  " corresponds to a newline
-      // (this seems to be because on last.fm' website, extra blank is inserted
-      // before <br /> tag, and this blank is kept).
-      // This is tricky, but this make the display nicer for last.fm
-      // biographies.
-      text.replace("  ", "<p>");
-    }
-    editor->SetHtml(text);
-    data.contents_ = editor;
-
-    emit InfoReady(request->id_, data);
-  }
-
-  emit Finished(request->id_);
-}
diff --git a/src/songinfo/echonestbiographies.h b/src/songinfo/echonestbiographies.h
deleted file mode 100644
index 2429bce..0000000
--- a/src/songinfo/echonestbiographies.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef ECHONESTBIOGRAPHIES_H
-#define ECHONESTBIOGRAPHIES_H
-
-#include <memory>
-
-#include "songinfoprovider.h"
-
-class QNetworkReply;
-
-class EchoNestBiographies : public SongInfoProvider {
-  Q_OBJECT
-
- public:
-  EchoNestBiographies();
-
-  void FetchInfo(int id, const Song& metadata);
-
- private slots:
-  void RequestFinished();
-
- private:
-  QMap<QString, int> site_relevance_;
-  QMap<QString, QIcon> site_icons_;
-
-  struct Request;
-  typedef std::shared_ptr<Request> RequestPtr;
-
-  QMap<QNetworkReply*, RequestPtr> requests_;
-};
-
-#endif  // ECHONESTBIOGRAPHIES_H
diff --git a/src/songinfo/echonestimages.cpp b/src/songinfo/echonestimages.cpp
deleted file mode 100644
index 6920a4e..0000000
--- a/src/songinfo/echonestimages.cpp
+++ /dev/null
@@ -1,148 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "echonestimages.h"
-
-#include <algorithm>
-#include <memory>
-
-#include <QJsonObject>
-#include <QJsonDocument>
-#include <QJsonArray>
-#include <QJsonValue>
-
-#include <Artist.h>
-
-#include "core/closure.h"
-#include "core/logging.h"
-#include "core/network.h"
-
-namespace {
-static const char* kSpotifyBucket = "spotify";
-static const char* kSpotifyArtistUrl = "https://api.spotify.com/v1/artists/%1";
-}
-
-EchoNestImages::EchoNestImages() : network_(new NetworkAccessManager) {}
-
-EchoNestImages::~EchoNestImages() {}
-
-void EchoNestImages::FetchInfo(int id, const Song& metadata) {
-  Echonest::Artist artist;
-  artist.setName(metadata.artist());
-
-  // Search for images directly on echonest.
-  // This is currently a bit limited as most results are for last.fm urls that
-  // no longer work.
-  QNetworkReply* reply = artist.fetchImages();
-  RegisterReply(reply, id);
-  NewClosure(reply, SIGNAL(finished()), this,
-             SLOT(RequestFinished(QNetworkReply*, int, Echonest::Artist)),
-             reply, id, artist);
-
-  // Also look up the artist id for the spotify API so we can directly request
-  // images from there too.
-  Echonest::Artist::SearchParams params;
-  params.push_back(
-      qMakePair(Echonest::Artist::Name, QVariant(metadata.artist())));
-  QNetworkReply* rosetta_reply = Echonest::Artist::search(
-      params,
-      Echonest::ArtistInformation(Echonest::ArtistInformation::NoInformation,
-                                  QStringList() << kSpotifyBucket));
-  RegisterReply(rosetta_reply, id);
-  NewClosure(rosetta_reply, SIGNAL(finished()), this,
-             SLOT(IdsFound(QNetworkReply*, int)), rosetta_reply, id);
-}
-
-void EchoNestImages::RequestFinished(QNetworkReply* reply, int id,
-                                     Echonest::Artist artist) {
-  reply->deleteLater();
-  try {
-    artist.parseProfile(reply);
-  } catch (Echonest::ParseError e) {
-    qLog(Warning) << "Error parsing echonest reply:" << e.errorType()
-                  << e.what();
-  }
-
-  for (const Echonest::ArtistImage& image : artist.images()) {
-    // Echonest still sends these broken URLs for last.fm.
-    if (image.url().authority() != "userserve-ak.last.fm") {
-      emit ImageReady(id, image.url());
-    }
-  }
-}
-
-void EchoNestImages::IdsFound(QNetworkReply* reply, int request_id) {
-  reply->deleteLater();
-  try {
-    Echonest::Artists artists = Echonest::Artist::parseSearch(reply);
-    if (artists.isEmpty()) {
-      return;
-    }
-    const Echonest::ForeignIds& foreign_ids = artists.first().foreignIds();
-    for (const Echonest::ForeignId& id : foreign_ids) {
-      if (id.catalog.contains("spotify")) {
-        DoSpotifyImageRequest(id.foreign_id, request_id);
-      }
-    }
-  } catch (Echonest::ParseError e) {
-    qLog(Warning) << "Error parsing echonest reply:" << e.errorType()
-                  << e.what();
-  }
-}
-
-void EchoNestImages::DoSpotifyImageRequest(const QString& id, int request_id) {
-  QString artist_id = id.split(":").last();
-  QUrl url(QString(kSpotifyArtistUrl).arg(artist_id));
-  QNetworkReply* reply = network_->get(QNetworkRequest(url));
-  RegisterReply(reply, request_id);
-  NewClosure(reply, SIGNAL(finished()), [this, reply, request_id]() {
-    reply->deleteLater();
-
-    QJsonObject result = QJsonDocument::fromJson(reply->readAll()).object();
-    QJsonArray images = result["images"].toArray();
-    QList<QPair<QUrl, QSize>> image_urls;
-    for (const QJsonValue& image : images) {
-      QJsonObject image_result = image.toObject();
-      image_urls.append(qMakePair(image_result["url"].toVariant().toUrl(),
-                                  QSize(image_result["width"].toInt(),
-                                        image_result["height"].toInt())));
-    }
-    // All the images are the same just different sizes; just pick the largest.
-    std::sort(image_urls.begin(), image_urls.end(),
-              [](const QPair<QUrl, QSize>& a,
-                 const QPair<QUrl, QSize>& b) {
-      // Sorted by area ascending.
-      return (a.second.height() * a.second.width()) <
-          (b.second.height() * b.second.width());
-    });
-    if (!image_urls.isEmpty()) {
-      emit ImageReady(request_id, image_urls.last().first);
-    }
-  });
-}
-
-// Keeps track of replies and emits Finished() when all replies associated with
-// a request are finished with.
-void EchoNestImages::RegisterReply(QNetworkReply* reply, int id) {
-  replies_.insert(id, reply);
-  NewClosure(reply, SIGNAL(destroyed()), [this, reply, id]() {
-    replies_.remove(id, reply);
-    if (!replies_.contains(id)) {
-      emit Finished(id);
-    }
-  });
-}
diff --git a/src/songinfo/echonestimages.h b/src/songinfo/echonestimages.h
deleted file mode 100644
index 94a8c1c..0000000
--- a/src/songinfo/echonestimages.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef ECHONESTIMAGES_H
-#define ECHONESTIMAGES_H
-
-#include <memory>
-
-#include <QMultiMap>
-
-#include <Artist.h>
-
-#include "songinfo/songinfoprovider.h"
-
-class NetworkAccessManager;
-class QNetworkReply;
-
-class EchoNestImages : public SongInfoProvider {
-  Q_OBJECT
-
- public:
-  EchoNestImages();
-  virtual ~EchoNestImages();
-  void FetchInfo(int id, const Song& metadata);
-
- private slots:
-  void RequestFinished(QNetworkReply*, int id, Echonest::Artist artist);
-  void IdsFound(QNetworkReply* reply, int id);
-
- private:
-  void DoSpotifyImageRequest(const QString& id, int request_id);
-
-  void RegisterReply(QNetworkReply* reply, int id);
-  QMultiMap<int, QNetworkReply*> replies_;
-  std::unique_ptr<NetworkAccessManager> network_;
-};
-
-#endif  // ECHONESTIMAGES_H
diff --git a/src/songinfo/echonestsimilarartists.cpp b/src/songinfo/echonestsimilarartists.cpp
deleted file mode 100644
index b1a9930..0000000
--- a/src/songinfo/echonestsimilarartists.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "echonestsimilarartists.h"
-#include "tagwidget.h"
-#include "core/logging.h"
-#include "ui/iconloader.h"
-
-#include <Artist.h>
-
-Q_DECLARE_METATYPE(QVector<QString>);
-
-void EchoNestSimilarArtists::FetchInfo(int id, const Song& metadata) {
-  using Echonest::Artist;
-
-  Artist::SearchParams params;
-  params << Artist::SearchParamEntry(Artist::Name, metadata.artist());
-  params << Artist::SearchParamEntry(Artist::MinHotttnesss, 0.5);
-
-  QNetworkReply* reply = Echonest::Artist::fetchSimilar(params);
-  connect(reply, SIGNAL(finished()), SLOT(RequestFinished()));
-  requests_[reply] = id;
-}
-
-void EchoNestSimilarArtists::RequestFinished() {
-  QNetworkReply* reply = qobject_cast<QNetworkReply*>(sender());
-  if (!reply || !requests_.contains(reply)) return;
-  reply->deleteLater();
-
-  int id = requests_.take(reply);
-
-  Echonest::Artists artists;
-  try {
-    artists = Echonest::Artist::parseSimilar(reply);
-  }
-  catch (Echonest::ParseError e) {
-    qLog(Warning) << "Error parsing echonest reply:" << e.errorType()
-                  << e.what();
-  }
-
-  if (!artists.isEmpty()) {
-    CollapsibleInfoPane::Data data;
-    data.id_ = "echonest/similarartists";
-    data.title_ = tr("Similar artists");
-    data.type_ = CollapsibleInfoPane::Data::Type_Similar;
-    data.icon_ = IconLoader::Load("echonest", IconLoader::Provider);
-
-    TagWidget* widget = new TagWidget(TagWidget::Type_Artists);
-    data.contents_ = widget;
-
-    widget->SetIcon(IconLoader::Load("x-clementine-artist", IconLoader::Base));
-
-    for (const Echonest::Artist& artist : artists) {
-      widget->AddTag(artist.name());
-      if (widget->count() >= 10) break;
-    }
-
-    emit InfoReady(id, data);
-  }
-
-  emit Finished(id);
-}
diff --git a/src/songinfo/echonestsimilarartists.h b/src/songinfo/echonestsimilarartists.h
deleted file mode 100644
index f78fa54..0000000
--- a/src/songinfo/echonestsimilarartists.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef ECHONESTSIMILARARTISTS_H
-#define ECHONESTSIMILARARTISTS_H
-
-#include "songinfoprovider.h"
-
-class QNetworkReply;
-
-class EchoNestSimilarArtists : public SongInfoProvider {
-  Q_OBJECT
-
- public:
-  void FetchInfo(int id, const Song& metadata);
-
- private slots:
-  void RequestFinished();
-
- private:
-  QMap<QNetworkReply*, int> requests_;
-};
-
-#endif  // ECHONESTSIMILARARTISTS_H
diff --git a/src/songinfo/echonesttags.cpp b/src/songinfo/echonesttags.cpp
deleted file mode 100644
index 657b05f..0000000
--- a/src/songinfo/echonesttags.cpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
-
-   Clementine is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   Clementine is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "echonesttags.h"
-
-#include <memory>
-
-#include <Artist.h>
-
-#include "tagwidget.h"
-#include "core/logging.h"
-#include "ui/iconloader.h"
-
-struct EchoNestTags::Request {
-  Request(int id) : id_(id), artist_(new Echonest::Artist) {}
-
-  int id_;
-  std::unique_ptr<Echonest::Artist> artist_;
-};
-
-void EchoNestTags::FetchInfo(int id, const Song& metadata) {
-  std::shared_ptr<Request> request(new Request(id));
-  request->artist_->setName(metadata.artist());
-
-  QNetworkReply* reply = request->artist_->fetchTerms();
-  connect(reply, SIGNAL(finished()), SLOT(RequestFinished()));
-  requests_[reply] = request;
-}
-
-void EchoNestTags::RequestFinished() {
-  QNetworkReply* reply = qobject_cast<QNetworkReply*>(sender());
-  if (!reply || !requests_.contains(reply)) return;
-  reply->deleteLater();
-
-  RequestPtr request = requests_.take(reply);
-
-  try {
-    request->artist_->parseProfile(reply);
-  }
-  catch (Echonest::ParseError e) {
-    qLog(Warning) << "Error parsing echonest reply:" << e.errorType()
-                  << e.what();
-  }
-
-  if (!request->artist_->terms().isEmpty()) {
-    CollapsibleInfoPane::Data data;
-    data.id_ = "echonest/artisttags";
-    data.title_ = tr("Artist tags");
-    data.type_ = CollapsibleInfoPane::Data::Type_Tags;
-    data.icon_ = IconLoader::Load("icon_tag", IconLoader::Lastfm);
-
-    TagWidget* widget = new TagWidget(TagWidget::Type_Tags);
-    data.contents_ = widget;
-
-    widget->SetIcon(data.icon_);
-
-    for (const Echonest::Term& term : request->artist_->terms()) {
-      widget->AddTag(term.name());
-      if (widget->count() >= 10) break;
-    }
-
-    emit InfoReady(request->id_, data);
-  }
-
-  emit Finished(request->id_);
-}
diff --git a/src/songinfo/songkickconcerts.cpp b/src/songinfo/songkickconcerts.cpp
index 458d89c..a832438 100644
--- a/src/songinfo/songkickconcerts.cpp
+++ b/src/songinfo/songkickconcerts.cpp
@@ -24,85 +24,71 @@
 #include <QJsonObject>
 #include <QJsonArray>
 
-#include <Artist.h>
-#include <TypeInformation.h>
-
 #include "core/closure.h"
 #include "core/logging.h"
 #include "songkickconcertwidget.h"
 #include "ui/iconloader.h"
 
-const char* SongkickConcerts::kSongkickArtistBucket = "songkick";
-const char* SongkickConcerts::kSongkickArtistCalendarUrl =
-    "https://api.songkick.com/api/3.0/artists/%1/calendar.json?"
-    "per_page=5&"
-    "apikey=8rgKfy1WU6IlJFfN";
+namespace {
+const char* kSongkickArtistCalendarUrl =
+    "https://api.songkick.com/api/3.0/artists/%1/calendar.json";
+const char* kSongkickArtistSearchUrl =
+    "https://api.songkick.com/api/3.0/search/artists.json";
+const char* kSongkickApiKey = "8rgKfy1WU6IlJFfN";
+}  // namespace
 
 SongkickConcerts::SongkickConcerts() {
   Geolocator* geolocator = new Geolocator;
   geolocator->Geolocate();
   connect(geolocator, SIGNAL(Finished(Geolocator::LatLng)),
           SLOT(GeolocateFinished(Geolocator::LatLng)));
-  NewClosure(geolocator, SIGNAL(Finished(Geolocator::LatLng)), geolocator,
-             SLOT(deleteLater()));
+  connect(geolocator, SIGNAL(Finished(Geolocator::LatLng)), geolocator,
+          SLOT(deleteLater()));
 }
 
 void SongkickConcerts::FetchInfo(int id, const Song& metadata) {
-  Echonest::Artist::SearchParams params;
-  params.push_back(
-      qMakePair(Echonest::Artist::Name, QVariant(metadata.artist())));
-  qLog(Debug) << "Params:" << params;
-  QNetworkReply* reply = Echonest::Artist::search(
-      params,
-      Echonest::ArtistInformation(Echonest::ArtistInformation::NoInformation,
-                                  QStringList() << kSongkickArtistBucket));
-  qLog(Debug) << reply->request().url();
+  if (metadata.artist().isEmpty()) {
+    emit Finished(id);
+    return;
+  }
+
+  QUrl url(kSongkickArtistSearchUrl);
+  QUrlQuery url_query;
+  url_query.addQueryItem("apikey", kSongkickApiKey);
+  url_query.addQueryItem("query", metadata.artist());
+  url.setQuery(url_query);
+
+  QNetworkRequest request(url);
+  QNetworkReply* reply = network_.get(request);
   NewClosure(reply, SIGNAL(finished()), this,
              SLOT(ArtistSearchFinished(QNetworkReply*, int)), reply, id);
 }
 
 void SongkickConcerts::ArtistSearchFinished(QNetworkReply* reply, int id) {
   reply->deleteLater();
-  try {
-    Echonest::Artists artists = Echonest::Artist::parseSearch(reply);
-    if (artists.isEmpty()) {
-      qLog(Debug) << "Failed to find artist in echonest";
-      emit Finished(id);
-      return;
-    }
-
-    const Echonest::Artist& artist = artists[0];
-    const Echonest::ForeignIds& foreign_ids = artist.foreignIds();
-    QString songkick_id;
-    for (const Echonest::ForeignId& id : foreign_ids) {
-      if (id.catalog == "songkick") {
-        songkick_id = id.foreign_id;
-        break;
-      }
-    }
-
-    if (songkick_id.isEmpty()) {
-      qLog(Debug) << "Failed to fetch songkick foreign id for artist";
-      emit Finished(id);
-      return;
-    }
+  QVariantMap json = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
 
-    QStringList split = songkick_id.split(':');
-    if (split.count() != 3) {
-      qLog(Error) << "Weird songkick id";
-      emit Finished(id);
-      return;
-    }
+  QVariantMap results_page = json["resultsPage"].toMap();
+  QVariantMap results = results_page["results"].toMap();
+  QVariantList artists = results["artist"].toList();
 
-    FetchSongkickCalendar(split[2], id);
-  } catch (Echonest::ParseError& e) {
-    qLog(Error) << "Error parsing echonest reply:" << e.errorType() << e.what();
+  if (artists.isEmpty()) {
     emit Finished(id);
+    return;
   }
+
+  QVariantMap artist = artists.first().toMap();
+  QString artist_id = artist["id"].toString();
+
+  FetchSongkickCalendar(artist_id, id);
 }
 
 void SongkickConcerts::FetchSongkickCalendar(const QString& artist_id, int id) {
   QUrl url(QString(kSongkickArtistCalendarUrl).arg(artist_id));
+  QUrlQuery url_query;
+  url_query.addQueryItem("per_page", "5");
+  url_query.addQueryItem("apikey", kSongkickApiKey);
+  url.setQuery(url_query);
   qLog(Debug) << url;
   QNetworkReply* reply = network_.get(QNetworkRequest(url));
   NewClosure(reply, SIGNAL(finished()), this,
diff --git a/src/songinfo/songkickconcerts.h b/src/songinfo/songkickconcerts.h
index 606909f..66cd484 100644
--- a/src/songinfo/songkickconcerts.h
+++ b/src/songinfo/songkickconcerts.h
@@ -44,9 +44,6 @@ class SongkickConcerts : public SongInfoProvider {
 
   NetworkAccessManager network_;
   Geolocator::LatLng latlng_;
-
-  static const char* kSongkickArtistBucket;
-  static const char* kSongkickArtistCalendarUrl;
 };
 
 #endif
diff --git a/src/songinfo/spotifyimages.cpp b/src/songinfo/spotifyimages.cpp
new file mode 100644
index 0000000..041c6cc
--- /dev/null
+++ b/src/songinfo/spotifyimages.cpp
@@ -0,0 +1,97 @@
+#include "spotifyimages.h"
+
+#include <algorithm>
+
+#include <QJsonObject>
+#include <QJsonDocument>
+#include <QJsonArray>
+#include <QJsonValue>
+#include <QPair>
+#include <QUrlQuery>
+
+#include "core/closure.h"
+#include "core/logging.h"
+#include "core/network.h"
+
+namespace {
+static const char* kSpotifySearchUrl = "https://api.spotify.com/v1/search";
+static const char* kSpotifyArtistUrl = "https://api.spotify.com/v1/artists/%1";
+}  // namespace
+
+namespace {
+QString ExtractSpotifyId(const QString& spotify_uri) {
+  return spotify_uri.split(':')[2];
+}
+}  // namespace
+
+SpotifyImages::SpotifyImages()
+  : network_(new NetworkAccessManager) {
+}
+
+SpotifyImages::~SpotifyImages() {}
+
+void SpotifyImages::FetchInfo(int id, const Song& metadata) {
+  if (metadata.artist().isEmpty()) {
+    emit Finished(id);
+    return;
+  }
+
+  // Fetch artist id.
+  QUrl search_url(kSpotifySearchUrl);
+  QUrlQuery search_url_query;
+  search_url_query.addQueryItem("q", metadata.artist());
+  search_url_query.addQueryItem("type", "artist");
+  search_url_query.addQueryItem("limit", "1");
+  search_url.setQuery(search_url_query);
+
+  qLog(Debug) << "Fetching artist:" << search_url;
+
+  QNetworkRequest request(search_url);
+  QNetworkReply* reply = network_->get(request);
+  NewClosure(reply, SIGNAL(finished()), [this, id, reply]() {
+    reply->deleteLater();
+    QVariantMap result = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
+    QVariantMap artists = result["artists"].toMap();
+    if (artists.isEmpty()) {
+      emit Finished(id);
+      return;
+    }
+    QVariantList items = artists["items"].toList();
+    if (items.isEmpty()) {
+      emit Finished(id);
+      return;
+    }
+    QVariantMap artist = items.first().toMap();
+    QString spotify_uri = artist["uri"].toString();
+
+    FetchImagesForArtist(id, ExtractSpotifyId(spotify_uri));
+  });
+}
+
+void SpotifyImages::FetchImagesForArtist(int id, const QString& spotify_id) {
+  QUrl artist_url(QString(kSpotifyArtistUrl).arg(spotify_id));
+  qLog(Debug) << "Fetching images for artist:" << artist_url;
+  QNetworkRequest request(artist_url);
+  QNetworkReply* reply = network_->get(request);
+  NewClosure(reply, SIGNAL(finished()), [this, id, reply]() {
+    reply->deleteLater();
+    QVariantMap result = QJsonDocument::fromJson(reply->readAll()).object().toVariantMap();
+    QVariantList images = result["images"].toList();
+    QList<QPair<QUrl, QSize>> image_candidates;
+    for (QVariant i : images) {
+      QVariantMap image = i.toMap();
+      int height = image["height"].toInt();
+      int width = image["width"].toInt();
+      QUrl url = image["url"].toUrl();
+      image_candidates.append(qMakePair(url, QSize(width, height)));
+    }
+    QPair<QUrl, QSize> winner = *std::max_element(
+        image_candidates.begin(),
+        image_candidates.end(),
+        [](const QPair<QUrl, QSize>& a, const QPair<QUrl, QSize>& b) {
+          return (a.second.height() * a.second.width()) < (b.second.height() * b.second.width());
+        });
+    emit ImageReady(id, winner.first);
+    emit Finished(id);
+  });
+}
diff --git a/src/songinfo/echonesttags.h b/src/songinfo/spotifyimages.h
similarity index 61%
rename from src/songinfo/echonesttags.h
rename to src/songinfo/spotifyimages.h
index 5776f3e..fe0457c 100644
--- a/src/songinfo/echonesttags.h
+++ b/src/songinfo/spotifyimages.h
@@ -1,5 +1,5 @@
 /* This file is part of Clementine.
-   Copyright 2010, David Sansome <me@davidsansome.com>
+   Copyright 2016, John Maguire <john.maguire@gmail.com>
 
    Clementine is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,29 +15,27 @@
    along with Clementine.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-#ifndef ECHONESTTAGS_H
-#define ECHONESTTAGS_H
+#ifndef SPOTIFYIMAGES_H
+#define SPOTIFYIMAGES_H
 
 #include <memory>
 
-#include "songinfoprovider.h"
+#include "songinfo/songinfoprovider.h"
 
-class QNetworkReply;
+class NetworkAccessManager;
 
-class EchoNestTags : public SongInfoProvider {
+class SpotifyImages : public SongInfoProvider {
   Q_OBJECT
-
  public:
-  void FetchInfo(int id, const Song& metadata);
+  SpotifyImages();
+  ~SpotifyImages();
 
- private slots:
-  void RequestFinished();
+  void FetchInfo(int id, const Song& metadata) override;
 
  private:
-  struct Request;
-  typedef std::shared_ptr<Request> RequestPtr;
+  void FetchImagesForArtist(int id, const QString& spotify_id);
 
-  QMap<QNetworkReply*, RequestPtr> requests_;
+  std::unique_ptr<NetworkAccessManager> network_;
 };
 
-#endif  // ECHONESTTAGS_H
+#endif  // SPOTIFYIMAGES_H

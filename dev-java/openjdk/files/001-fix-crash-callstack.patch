--- a/src/hotspot/share/services/memTracker.hpp  2021-08-06 00:12:27.000000000 +0200
+++ b/src/hotspot/share/services/memTracker.hpp 2021-10-13 12:18:45.160529361 +0200
@@ -87,9 +87,9 @@
 #include "services/virtualMemoryTracker.hpp"
 
 #define CURRENT_PC ((MemTracker::tracking_level() == NMT_detail) ? \
-                    NativeCallStack(0) : NativeCallStack::empty_stack())
+                    NativeCallStack(0, true) : NativeCallStack::empty_stack())
 #define CALLER_PC  ((MemTracker::tracking_level() == NMT_detail) ?  \
-                    NativeCallStack(1) : NativeCallStack::empty_stack())
+                    NativeCallStack(1, true) : NativeCallStack::empty_stack())
 
 class MemBaseline;
 
--- a/src/hotspot/share/utilities/nativeCallStack.cpp    2021-08-06 00:12:27.000000000 +0200
+++ b/src/hotspot/share/utilities/nativeCallStack.cpp   2021-10-13 12:18:45.162529388 +0200
@@ -28,24 +28,27 @@
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/nativeCallStack.hpp"
 
-const NativeCallStack NativeCallStack::_empty_stack; // Uses default ctor
-
-NativeCallStack::NativeCallStack(int toSkip) {
-
-  // We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used
-  // to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined
-  // (which means this is not a slowdebug build), and we are on 64-bit (except Windows).
-  // This is not necessarily a rule, but what has been obvserved to date.
+NativeCallStack::NativeCallStack(int toSkip, bool fillStack) {
+  if (fillStack) {
+    // We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used
+    // to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined
+    // (which means this is not a slowdebug build), and we are on 64-bit (except Windows).
+    // This is not necessarily a rule, but what has been obvserved to date.
 #if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64) || (defined(BSD) && defined (__aarch64__)))
-  // Not a tail call.
-  toSkip++;
+    // Not a tail call.
+    toSkip++;
 #if (defined(_NMT_NOINLINE_) && defined(BSD) && defined(_LP64))
-  // Mac OS X slowdebug builds have this odd behavior where NativeCallStack::NativeCallStack
-  // appears as two frames, so we need to skip an extra frame.
-  toSkip++;
+    // Mac OS X slowdebug builds have this odd behavior where NativeCallStack::NativeCallStack
+    // appears as two frames, so we need to skip an extra frame.
+    toSkip++;
 #endif // Special-case for BSD.
 #endif // Not a tail call.
-  os::get_native_stack(_stack, NMT_TrackingStackDepth, toSkip);
+    os::get_native_stack(_stack, NMT_TrackingStackDepth, toSkip);
+  } else {
+    for (int index = 0; index < NMT_TrackingStackDepth; index ++) {
+      _stack[index] = NULL;
+    }
+  }
 }
 
 NativeCallStack::NativeCallStack(address* pc, int frameCount) {
--- a/src/hotspot/share/utilities/nativeCallStack.hpp    2021-08-06 00:12:27.000000000 +0200
+++ b/src/hotspot/share/utilities/nativeCallStack.hpp   2021-10-13 12:18:45.162529388 +0200
@@ -56,18 +56,15 @@
 class NativeCallStack : public StackObj {
 private:
   address       _stack[NMT_TrackingStackDepth];
-  static const NativeCallStack _empty_stack;
 public:
-  // Default ctor creates an empty stack.
-  // (it may make sense to remove this altogether but its used in a few places).
-  NativeCallStack() {
-    memset(_stack, 0, sizeof(_stack));
-  }
-
-  NativeCallStack(int toSkip);
   NativeCallStack(address* pc, int frameCount);
+  NativeCallStack(int toSkip = 0, bool fillStack = false);
+
+  static inline const NativeCallStack& empty_stack() {
+    static const NativeCallStack EMPTY_STACK(0, false);
+    return EMPTY_STACK;
+  }
 
-  static inline const NativeCallStack& empty_stack() { return _empty_stack; }
 
   // if it is an empty stack
   inline bool is_empty() const {

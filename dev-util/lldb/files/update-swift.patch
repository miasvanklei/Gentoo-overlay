diff --git a/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp b/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp
index 729c8c2ab..1eda42162 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp
@@ -20,7 +20,6 @@
 #include "lldb/Target/Target.h"
 #include "swift/AST/ASTContext.h"
 #include "swift/AST/ASTWalker.h"
-#include "swift/AST/ArchetypeBuilder.h"
 #include "swift/AST/Decl.h"
 #include "swift/AST/DiagnosticEngine.h"
 #include "swift/AST/DiagnosticsFrontend.h"
@@ -792,7 +791,8 @@ public:
     if (!m_persistent_vars.count(var_decl))
       return;
 
-    swift::Type target_type = var_decl->getType();
+    swift::Type target_type = var_decl->getDeclContext()
+        ->mapTypeIntoContext(var_decl->getInterfaceType());
     swift::LValueType *target_lvalue_type = swift::LValueType::get(target_type);
 
     const bool implicit = true;
@@ -899,9 +899,11 @@ void SwiftASTManipulator::FindVariableDeclarations(
 
     size_t persistent_info_location = m_variables.size();
 
+    auto type = var_decl->getDeclContext()->mapTypeIntoContext(
+        var_decl->getInterfaceType());
     persistent_info.m_name = name;
     persistent_info.m_type = CompilerType(&var_decl->getASTContext(),
-                                          var_decl->getType().getPointer());
+                                          type.getPointer());
     persistent_info.m_decl = var_decl;
 
     m_variables.push_back(persistent_info);
@@ -1151,7 +1153,7 @@ bool SwiftASTManipulator::FixupResultAfterTypeChecking(Error &error) {
             if (error_var_name != var_decl->getName())
               continue;
 
-            swift::Type error_type = var_decl->getType();
+            swift::Type error_type = var_decl->getInterfaceType();
             CompilerType error_ast_type(&ast_context, error_type.getPointer());
             SwiftASTManipulatorBase::VariableMetadataSP error_metadata_sp(
                 new VariableMetadataError());
@@ -1203,8 +1205,10 @@ GetPatternBindingForVarDecl(swift::VarDecl *var_decl,
   swift::NamedPattern *named_pattern =
       new (ast_context) swift::NamedPattern(var_decl, is_implicit);
 
+  swift::Type type = containing_context->mapTypeIntoContext(
+      var_decl->getInterfaceType());
   swift::TypedPattern *typed_pattern = new (ast_context) swift::TypedPattern(
-      named_pattern, swift::TypeLoc::withoutLoc(var_decl->getType()));
+      named_pattern, swift::TypeLoc::withoutLoc(type));
 
   swift::PatternBindingDecl *pattern_binding =
       swift::PatternBindingDecl::create(
@@ -1356,8 +1360,7 @@ bool SwiftASTManipulator::AddExternalVariables(
       swift::VarDecl *redirected_var_decl = new (ast_context) swift::VarDecl(
           is_static, is_let, loc, name, var_type, containing_function);
       redirected_var_decl->setInterfaceType(
-        swift::ArchetypeBuilder::mapTypeOutOfContext(
-          containing_function, var_type));
+          containing_function->mapTypeOutOfContext(var_type));
       redirected_var_decl->setDebuggerVar(true);
       redirected_var_decl->setImplicit(true);
 
@@ -1511,8 +1514,8 @@ swift::ValueDecl *SwiftASTManipulator::MakeGlobalTypealias(
   llvm::MutableArrayRef<swift::TypeLoc> inherited;
   swift::TypeAliasDecl *type_alias_decl = new (ast_context)
       swift::TypeAliasDecl(source_loc, name, source_loc,
-                           swift::TypeLoc::withoutLoc(GetSwiftType(type)),
                            nullptr, &m_source_file);
+  type_alias_decl->setUnderlyingType(GetSwiftType(type));
 
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
   if (log) {
@@ -1554,8 +1557,8 @@ SwiftASTManipulator::GetTypesForResultFixup(uint32_t language_flags) {
 
           if (name_alias_type) {
             // FIXME: What if the generic parameter is concrete?
-            ret.Wrapper_archetype = swift::ArchetypeBuilder::mapTypeIntoContext(
-                extension_decl, type_parameter->getDeclaredInterfaceType())
+            ret.Wrapper_archetype = extension_decl->mapTypeIntoContext(
+                type_parameter->getDeclaredInterfaceType())
                     ->castTo<swift::ArchetypeType>();
             ret.context_alias = name_alias_type;
             ret.context_real = name_alias_type->getSinglyDesugaredType();
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp b/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp
index e0e1df75c..b0b7253ae 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp
@@ -139,21 +139,19 @@ bool SwiftPersistentExpressionState::SwiftDeclMap::DeclsAreEquivalent(
         auto *lhs_param = lhs_patterns[idx];
         auto *rhs_param = rhs_patterns[idx];
 
-        auto lhs_type = lhs_param->getType(context).getCanonicalTypeOrNull();
-        auto rhs_type = rhs_param->getType(context).getCanonicalTypeOrNull();
-        if (lhs_type != rhs_type) {
+        auto lhs_type = lhs_param->getInterfaceType(context);
+        auto rhs_type = rhs_param->getInterfaceType(context);
+        if (!lhs_type->isEqual(rhs_type)) {
           body_params_equal = false;
           break;
         }
       }
       if (body_params_equal) {
         // The bodies look the same, now try the return values:
-        swift::CanType lhs_result_type =
-            lhs_func_decl->getResultInterfaceType().getCanonicalTypeOrNull();
-        swift::CanType rhs_result_type =
-            rhs_func_decl->getResultInterfaceType().getCanonicalTypeOrNull();
+        auto lhs_result_type = lhs_func_decl->getResultInterfaceType();
+        auto rhs_result_type = rhs_func_decl->getResultInterfaceType();
 
-        if (lhs_result_type == rhs_result_type) {
+        if (lhs_result_type->isEqual(rhs_result_type)) {
           equivalent = true;
         }
       }
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp b/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp
index 09607b5a6..400cd5c2e 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp
@@ -100,10 +100,12 @@ swift::SILValue SwiftSILManipulator::emitLValueForVariable(
   swift::LoadInst *pointer_to_variable =
       m_builder.createLoad(null_loc, pointer_to_return_slot,
                            swift::LoadOwnershipQualifier::Trivial);
+  auto type = var->getDeclContext()->mapTypeIntoContext(
+      var->getInterfaceType());
   swift::PointerToAddressInst *address_of_variable =
       m_builder.createPointerToAddress(
           null_loc, pointer_to_variable,
-          converter.getLoweredType(var->getType()).getAddressType(),
+          converter.getLoweredType(type).getAddressType(),
           /*isStrict*/ true);
 
   if (info.needs_init) {
diff --git a/source/Symbol/SwiftASTContext.cpp b/source/Symbol/SwiftASTContext.cpp
index 992ee22df..8b3dd5e5a 100644
--- a/source/Symbol/SwiftASTContext.cpp
+++ b/source/Symbol/SwiftASTContext.cpp
@@ -438,7 +438,7 @@ CachedMemberInfo *SwiftASTContext::GetCachedMemberInfo(void *type) {
               if (var_decl->hasStorage() && !var_decl->isStatic()) {
                 MemberInfo member_info(MemberType::Field);
                 member_info.clang_type = CompilerType(
-                    GetASTContext(), var_decl->getType().getPointer());
+                    GetASTContext(), var_decl->getInterfaceType().getPointer());
                 member_info.byte_size =
                     member_info.clang_type.GetByteSize(nullptr);
                 member_info.is_fragile =
@@ -4154,8 +4153,8 @@ static CompilerType ValueDeclToType(swift::ValueDecl *decl,
     switch (decl->getKind()) {
     case swift::DeclKind::TypeAlias: {
       swift::TypeAliasDecl *alias_decl = llvm::cast<swift::TypeAliasDecl>(decl);
-      if (alias_decl->getAliasType()) {
-        swift::Type swift_type = alias_decl->getAliasType();
+      if (alias_decl->hasInterfaceType()) {
+        swift::Type swift_type = alias_decl->getDeclaredInterfaceType();
         return CompilerType(ast, swift_type.getPointer());
       }
       break;
@@ -4237,8 +4236,8 @@ static SwiftASTContext::TypeOrDecl DeclToTypeOrDecl(swift::ASTContext *ast,
     case swift::DeclKind::TypeAlias: {
       swift::TypeAliasDecl *alias_decl =
           llvm::dyn_cast_or_null<swift::TypeAliasDecl>(decl);
-      if (alias_decl->getAliasType()) {
-        swift::Type swift_type = alias_decl->getAliasType();
+      if (alias_decl->hasInterfaceType()) {
+        swift::Type swift_type = alias_decl->getDeclaredInterfaceType();
         return CompilerType(ast, swift_type.getPointer());
       }
     } break;
@@ -8444,8 +8443,7 @@ SwiftASTContext::GetTemplateArgument(void *type, size_t arg_idx,
       for (auto depTy : generic_sig->getAllDependentTypes()) {
         if (arg_idx == 0) {
           return CompilerType(GetASTContext(),
-                              swift::ArchetypeBuilder::mapTypeIntoContext(
-                                  nominal_type_decl, depTy)
+                              nominal_type_decl->mapTypeIntoContext(depTy)
                                   ->castTo<swift::ArchetypeType>());
         }
 
diff --git a/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.cpp b/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.cpp
index ed86dfcf8..ce50d170d 100644
--- a/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.cpp
+++ b/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.cpp
@@ -1412,6 +1412,20 @@ void StructuredDataDarwinLog::ModulesDidLoad(Process &process,
   EnableNow();
 }
 
+// -----------------------------------------------------------------------------
+// public destructor
+// -----------------------------------------------------------------------------
+
+StructuredDataDarwinLog::~StructuredDataDarwinLog() {
+  if (m_breakpoint_id != LLDB_INVALID_BREAK_ID) {
+    ProcessSP process_sp(GetProcess());
+    if (process_sp) {
+      process_sp->GetTarget().RemoveBreakpointByID(m_breakpoint_id);
+      m_breakpoint_id = LLDB_INVALID_BREAK_ID;
+    }
+  }
+}
+
 #pragma mark -
 #pragma mark Private instance methods
 
@@ -1422,7 +1436,8 @@ void StructuredDataDarwinLog::ModulesDidLoad(Process &process,
 StructuredDataDarwinLog::StructuredDataDarwinLog(const ProcessWP &process_wp)
     : StructuredDataPlugin(process_wp), m_recorded_first_timestamp(false),
       m_first_timestamp_seen(0), m_is_enabled(false),
-      m_added_breakpoint_mutex(), m_added_breakpoint() {}
+      m_added_breakpoint_mutex(), m_added_breakpoint(),
+      m_breakpoint_id(LLDB_INVALID_BREAK_ID) {}
 
 // -----------------------------------------------------------------------------
 // Private static methods
@@ -1741,6 +1756,7 @@ void StructuredDataDarwinLog::AddInitCompletionHook(Process &process) {
 
   // Set our callback.
   breakpoint_sp->SetCallback(InitCompletionHookCallback, nullptr);
+  m_breakpoint_id = breakpoint_sp->GetID();
   if (log)
     log->Printf("StructuredDataDarwinLog::%s() breakpoint set in module %s,"
                 "function %s (process uid %u)",
diff --git a/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.h b/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.h
index 91bd7a6a5..7eaab127c 100644
--- a/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.h
+++ b/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.h
@@ -74,6 +74,8 @@ public:
 
   void ModulesDidLoad(Process &process, ModuleList &module_list) override;
 
+  ~StructuredDataDarwinLog();
+
 private:
   // -------------------------------------------------------------------------
   // Private constructors
@@ -129,6 +131,7 @@ private:
   bool m_is_enabled;
   std::mutex m_added_breakpoint_mutex;
   bool m_added_breakpoint;
+  lldb::user_id_t m_breakpoint_id;
 };
 }
 
diff --git a/source/Target/Process.cpp b/source/Target/Process.cpp
index b74ed9fd7..7027c86db 100644
--- a/source/Target/Process.cpp
+++ b/source/Target/Process.cpp
@@ -893,6 +893,7 @@ void Process::Finalize() {
   m_public_run_lock.SetStopped();
   m_private_run_lock.TrySetRunning(); // This will do nothing if already locked
   m_private_run_lock.SetStopped();
+  m_structured_data_plugin_map.clear();
   m_finalize_called = true;
 }
 

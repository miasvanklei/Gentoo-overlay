diff --git a/CMakeLists.txt b/CMakeLists.txt
index ada293811..058e4db9c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -11,6 +11,14 @@ include(LLDBStandalone)
 include(LLDBConfig)
 include(AddLLDB)
 
+if(NOT LLDB_BUILT_STANDALONE AND EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../swift)
+   list(APPEND CMAKE_MODULE_PATH
+        "${CMAKE_CURRENT_SOURCE_DIR}/../swift/cmake"
+        "${CMAKE_CURRENT_SOURCE_DIR}/../swift/cmake/modules")
+else()
+    list(APPEND CMAKE_MODULE_PATH "/usr/lib/cmake/swift")
+endif()
+
 if (CMAKE_SYSTEM_NAME MATCHES "Windows|Android")
   set(LLDB_DEFAULT_DISABLE_LIBEDIT 1)
 else()
diff --git a/cmake/LLDBDependencies.cmake b/cmake/LLDBDependencies.cmake
index 55ce37908..d53e1c215 100644
--- a/cmake/LLDBDependencies.cmake
+++ b/cmake/LLDBDependencies.cmake
@@ -8,6 +8,9 @@ if ( CMAKE_SYSTEM_NAME MATCHES "Windows" )
     )
 endif ()
 
+list(APPEND LLDB_SYSTEM_LIBS uuid)
+list(APPEND LLDB_SYSTEM_LIBS cmark)
+
 if (NOT LLDB_DISABLE_LIBEDIT)
   list(APPEND LLDB_SYSTEM_LIBS edit)
 endif()
diff --git a/cmake/modules/LLDBConfig.cmake b/cmake/modules/LLDBConfig.cmake
index 726552675..298626ed2 100644
--- a/cmake/modules/LLDBConfig.cmake
+++ b/cmake/modules/LLDBConfig.cmake
@@ -203,6 +203,15 @@ else ()
 endif ()
 include_directories("${CMAKE_CURRENT_BINARY_DIR}/../clang/include")
 
+if(NOT LLDB_BUILT_STANDALONE)
+  if (LLVM_EXTERNAL_SWIFT_SOURCE_DIR)
+    include_directories(${LLVM_EXTERNAL_SWIFT_SOURCE_DIR}/include)
+  else ()
+    include_directories(${CMAKE_SOURCE_DIR}/tools/swift/include)
+  endif ()
+  include_directories("${CMAKE_CURRENT_BINARY_DIR}/../swift/include")
+endif()
+
 # Disable GCC warnings
 check_cxx_compiler_flag("-Wno-deprecated-declarations"
                         CXX_SUPPORTS_NO_DEPRECATED_DECLARATIONS)
diff --git a/docs/lldb.1 b/docs/lldb.1
index a28cabe7a..4dcefc6e1 100644
--- a/docs/lldb.1
+++ b/docs/lldb.1
@@ -18,7 +18,7 @@
 .Nm
 is the command line interface for the LLDB debugger library.
 .Nm
-can debug C, C++, Objective-C, and Objective-C++ programs.
+can debug C, C++, Objective-C, Objective-C++ and Swift programs.
 .Pp
 The following options are available:
 .Bl -tag -width indent
diff --git a/include/lldb/API/SBError.h b/include/lldb/API/SBError.h
index a099a9be2..ec341a922 100644
--- a/include/lldb/API/SBError.h
+++ b/include/lldb/API/SBError.h
@@ -57,6 +57,7 @@ protected:
   friend class SBDebugger;
   friend class SBCommunication;
   friend class SBHostOS;
+  friend class SBModule;
   friend class SBPlatform;
   friend class SBProcess;
   friend class SBStructuredData;
diff --git a/include/lldb/API/SBExpressionOptions.h b/include/lldb/API/SBExpressionOptions.h
index 370811d0c..af5f0c506 100644
--- a/include/lldb/API/SBExpressionOptions.h
+++ b/include/lldb/API/SBExpressionOptions.h
@@ -73,6 +73,14 @@ public:
 
   void SetCancelCallback(lldb::ExpressionCancelCallback callback, void *baton);
 
+  bool GetPlaygroundTransformEnabled() const;
+
+  void SetPlaygroundTransformEnabled(bool enable_playground_transform = true);
+
+  bool GetREPLMode() const;
+
+  void SetREPLMode(bool enable_repl_mode = true);
+
   bool GetGenerateDebugInfo();
 
   void SetGenerateDebugInfo(bool b = true);
diff --git a/include/lldb/API/SBFrame.h b/include/lldb/API/SBFrame.h
index 58339750d..9aa611cd1 100644
--- a/include/lldb/API/SBFrame.h
+++ b/include/lldb/API/SBFrame.h
@@ -83,6 +83,7 @@ public:
   // guess the language type from the mangled name.
   lldb::LanguageType GuessLanguage() const;
 
+  bool IsSwiftThunk() const;
   /// Return true if this frame represents an inlined function.
   ///
   /// See also GetFunctionName().
diff --git a/include/lldb/API/SBModule.h b/include/lldb/API/SBModule.h
index bcc3997a2..5bc4529a7 100644
--- a/include/lldb/API/SBModule.h
+++ b/include/lldb/API/SBModule.h
@@ -295,6 +295,8 @@ public:
 
   lldb::SBAddress GetObjectFileHeaderAddress() const;
 
+  lldb::SBError IsTypeSystemCompatible(lldb::LanguageType language);
+
 private:
   friend class SBAddress;
   friend class SBFrame;
diff --git a/include/lldb/API/SBTarget.h b/include/lldb/API/SBTarget.h
index 62398fcd4..1310af0f1 100644
--- a/include/lldb/API/SBTarget.h
+++ b/include/lldb/API/SBTarget.h
@@ -569,12 +569,14 @@ public:
   lldb::SBBreakpoint BreakpointCreateByName(const char *symbol_name,
                                             const char *module_name = nullptr);
 
-  // This version uses name_type_mask = eFunctionNameTypeAuto
+  // This version uses name_type_mask = eFunctionNameTypeAuto, symbol_language =
+  // eLanguageTypeUnknown
   lldb::SBBreakpoint
   BreakpointCreateByName(const char *symbol_name,
                          const SBFileSpecList &module_list,
                          const SBFileSpecList &comp_unit_list);
 
+  // symbol_language = eLanguageTypeUnknown.
   lldb::SBBreakpoint BreakpointCreateByName(
       const char *symbol_name,
       uint32_t
@@ -640,6 +642,15 @@ public:
   lldb::SBBreakpoint BreakpointCreateForException(lldb::LanguageType language,
                                                   bool catch_bp, bool throw_bp);
 
+  // The extra_args parameter will hold any number of pairs, the first element
+  // is the extra
+  // argument type, and the second the value.
+  // The argument types all follow the option long name from "breakpoint set -E
+  // <Language>".
+  lldb::SBBreakpoint BreakpointCreateForException(lldb::LanguageType language,
+                                                  bool catch_bp, bool throw_bp,
+                                                  SBStringList &extra_args);
+
   lldb::SBBreakpoint BreakpointCreateByAddress(addr_t address);
 
   lldb::SBBreakpoint BreakpointCreateBySBAddress(SBAddress &address);
diff --git a/include/lldb/API/SBThread.h b/include/lldb/API/SBThread.h
index 502e5c973..65ad45686 100644
--- a/include/lldb/API/SBThread.h
+++ b/include/lldb/API/SBThread.h
@@ -79,6 +79,10 @@ public:
 
   SBValue GetStopReturnValue();
 
+  SBValue GetStopErrorValue();
+
+  SBValue GetStopReturnOrErrorValue(bool &is_swift_error_value);
+
   lldb::tid_t GetThreadID() const;
 
   uint32_t GetIndexID() const;
diff --git a/include/lldb/Core/ClangForward.h b/include/lldb/Core/ClangForward.h
index b3cab8a22..4335be050 100644
--- a/include/lldb/Core/ClangForward.h
+++ b/include/lldb/Core/ClangForward.h
@@ -133,6 +133,11 @@ class APInt;
 class APSInt;
 class LLVMContext;
 class ExecutionEngine;
+class LLVMContext;
+class MemoryBuffer;
+class Module;
+class SourceMgr;
+class TargetOptions;
 }
 
 #endif // #if defined(__cplusplus)
diff --git a/include/lldb/Core/Debugger.h b/include/lldb/Core/Debugger.h
index 34d35ffe7..34b869e00 100644
--- a/include/lldb/Core/Debugger.h
+++ b/include/lldb/Core/Debugger.h
@@ -200,6 +200,9 @@ public:
 
   bool PopIOHandler(const lldb::IOHandlerSP &reader_sp);
 
+  uint32_t PopIOHandlers(const lldb::IOHandlerSP &reader1_sp,
+                         const lldb::IOHandlerSP &reader2_sp);
+
   // Synchronously run an input reader until it is done
   void RunIOHandler(const lldb::IOHandlerSP &reader_sp);
 
@@ -322,6 +325,10 @@ public:
 
   Status RunREPL(lldb::LanguageType language, const char *repl_options);
 
+  bool REPLIsActive() { return m_input_reader_stack.REPLIsActive(); }
+
+  bool REPLIsEnabled() { return m_input_reader_stack.REPLIsEnabled(); }
+
   // This is for use in the command interpreter, when you either want the
   // selected target, or if no target
   // is present you want to prime the dummy target with entities that will be
@@ -335,6 +342,7 @@ public:
 
 protected:
   friend class CommandInterpreter;
+  friend class SwiftREPL;
   friend class REPL;
 
   bool StartEventHandlerThread();
diff --git a/include/lldb/Core/IOHandler.h b/include/lldb/Core/IOHandler.h
index ebf56d790..cf0fbcb6e 100644
--- a/include/lldb/Core/IOHandler.h
+++ b/include/lldb/Core/IOHandler.h
@@ -518,7 +518,9 @@ protected:
 
 class IOHandlerStack {
 public:
-  IOHandlerStack() : m_stack(), m_mutex(), m_top(nullptr) {}
+  IOHandlerStack()
+      : m_stack(), m_mutex(), m_top(nullptr), m_repl_active(false),
+        m_repl_enabled(false) {}
 
   ~IOHandlerStack() = default;
 
@@ -534,6 +536,8 @@ public:
       m_stack.push_back(sp);
       // Set m_top the non-locking IsTop() call
       m_top = sp.get();
+
+      UpdateREPLIsActive();
     }
   }
 
@@ -560,8 +564,9 @@ public:
       sp->SetPopped(true);
     }
     // Set m_top the non-locking IsTop() call
-
     m_top = (m_stack.empty() ? nullptr : m_stack.back().get());
+
+    UpdateREPLIsActive();
   }
 
   std::recursive_mutex &GetMutex() { return m_mutex; }
@@ -591,13 +596,67 @@ public:
     return ((m_top != nullptr) ? m_top->GetHelpPrologue() : nullptr);
   }
 
+  // Returns true if the REPL is the active IOHandler or if it is just
+  // below the Process IOHandler.
+  bool REPLIsActive() {
+    // This is calculated and cached by UpdateREPLIsActive() as IOHandlers
+    // are pushed and popped since it gets called for all process events.
+    return m_repl_active;
+  }
+
+  // Returns true if any REPL IOHandlers are anywhere on the stack
+  bool REPLIsEnabled() {
+    // This is calculated and cached by UpdateREPLIsActive() as IOHandlers
+    // are pushed and popped since it gets called for all process events.
+    return m_repl_enabled;
+  }
+
   void PrintAsync(Stream *stream, const char *s, size_t len);
 
 protected:
+  void UpdateREPLIsActive() {
+    m_repl_active = false;
+    m_repl_enabled = false;
+    // This function should only be called when the mutex is locked...
+    if (m_top) {
+      switch (m_top->GetType()) {
+      case IOHandler::Type::ProcessIO:
+        // Check the REPL is underneath the process IO handler...
+        if (m_stack.size() > 1) {
+          if (m_stack[m_stack.size() - 2]->GetType() == IOHandler::Type::REPL) {
+            m_repl_active = true;
+            m_repl_enabled = true;
+          }
+        }
+        break;
+
+      case IOHandler::Type::REPL:
+        m_repl_active = true;
+        m_repl_enabled = true;
+        break;
+
+      default:
+        break;
+      }
+    }
+
+    if (!m_repl_enabled) {
+      for (const auto &io_handler_sp : m_stack) {
+        if (io_handler_sp->GetType() == IOHandler::Type::REPL) {
+          m_repl_enabled = true;
+          break;
+        }
+      }
+    }
+  }
+
   typedef std::vector<lldb::IOHandlerSP> collection;
   collection m_stack;
   mutable std::recursive_mutex m_mutex;
   IOHandler *m_top;
+  bool m_repl_active;  // REPL is the active IOHandler or right underneath the
+                       // process IO handler
+  bool m_repl_enabled; // REPL is on IOHandler stack somewhere
 
 private:
   DISALLOW_COPY_AND_ASSIGN(IOHandlerStack);
diff --git a/include/lldb/Core/Module.h b/include/lldb/Core/Module.h
index 2ffe57ad8..f29dc64b2 100644
--- a/include/lldb/Core/Module.h
+++ b/include/lldb/Core/Module.h
@@ -933,7 +933,13 @@ public:
 
   bool GetIsDynamicLinkEditor();
 
+  // This function must be called immediately after construction of the Module
+  // in the cases where the AST is to be shared.
+  void SetTypeSystemForLanguage(lldb::LanguageType language,
+                                const lldb::TypeSystemSP &type_system_sp);
+
   TypeSystem *GetTypeSystemForLanguage(lldb::LanguageType language);
+  TypeSystem *GetTypeSystemForLanguageNoCreate(lldb::LanguageType language);
 
   // Special error functions that can do printf style formatting that will
   // prepend the message with
@@ -1035,6 +1041,12 @@ public:
   //------------------------------------------------------------------
   Status LoadInMemory(Target &target, bool set_pc);
 
+  void ClearModuleDependentCaches();
+
+  void SetTypeSystemMap(const TypeSystemMap &type_system_map) {
+    m_type_system_map = type_system_map;
+  }
+
   //----------------------------------------------------------------------
   /// @class LookupInfo Module.h "lldb/Core/Module.h"
   /// @brief A class that encapsulates name lookup information.
diff --git a/include/lldb/Core/ModuleList.h b/include/lldb/Core/ModuleList.h
index 4b637c9b0..4090c2357 100644
--- a/include/lldb/Core/ModuleList.h
+++ b/include/lldb/Core/ModuleList.h
@@ -555,6 +555,8 @@ public:
   void ForEach(std::function<bool(const lldb::ModuleSP &module_sp)> const
                    &callback) const;
 
+  void ClearModuleDependentCaches();
+
 protected:
   //------------------------------------------------------------------
   // Class typedefs.
diff --git a/include/lldb/Core/SwiftForward.h b/include/lldb/Core/SwiftForward.h
index e69de29bb..225ac671a 100644
--- a/include/lldb/Core/SwiftForward.h
+++ b/include/lldb/Core/SwiftForward.h
@@ -0,0 +1,81 @@
+//===-- SwiftForward.h ------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftForward_h_
+#define liblldb_SwiftForward_h_
+
+// C Includes
+// C++ Includes
+// Other libraries and framework includes
+// Project includes
+
+#if defined(__cplusplus)
+
+namespace swift {
+class ArchetypeType;
+class ArrayType;
+class ASTContext;
+class ASTMutationListener;
+class BoundGenericType;
+class ClangImporter;
+class ClangImporterOptions;
+class ClangModule;
+class CompilerInvocation;
+class DebuggerClient;
+class Decl;
+class DeclContext;
+class DiagnosticConsumer;
+class DiagnosticEngine;
+class Expr;
+class ExtensionDecl;
+class FuncDecl;
+class FunctionType;
+class Identifier;
+class IRGenOptions;
+class LangOptions;
+class ModuleDecl;
+class ModuleLoader;
+class ModuleLoadListener;
+class NameAliasType;
+class NominalType;
+class NominalTypeDecl;
+class ProtocolDecl;
+class SearchPathOptions;
+class SerializedModuleLoader;
+class SILModule;
+class SILOptions;
+class SourceFile;
+class SourceLoc;
+class SourceManager;
+class StructDecl;
+class Substitution;
+class SubstitutableType;
+class TupleType;
+class TupleTypeElt;
+class Type;
+class TypeBase;
+class TypeDecl;
+class TypeInfo;
+class UnionElementDecl;
+class ValueDecl;
+class VarDecl;
+
+namespace irgen {
+class FixedTypeInfo;
+class IRGenModule;
+class IRGenerator;
+class TypeInfo;
+} // namespace irgen
+} // namespace swift
+
+#endif // #if defined(__cplusplus)
+#endif // liblldb_SwiftForward_h_
diff --git a/include/lldb/Core/ThreadSafeDenseSet.h b/include/lldb/Core/ThreadSafeDenseSet.h
index 49c55e96a..44ec24643 100644
--- a/include/lldb/Core/ThreadSafeDenseSet.h
+++ b/include/lldb/Core/ThreadSafeDenseSet.h
@@ -46,7 +46,7 @@ public:
   }
 
   void Clear() {
-    stds::lock_guard<_MutexType> guard(m_mutex);
+    std::lock_guard<_MutexType> guard(m_mutex);
     m_set.clear();
   }
 
diff --git a/include/lldb/Core/ValueObject.h b/include/lldb/Core/ValueObject.h
index fa1d14870..09496ec32 100644
--- a/include/lldb/Core/ValueObject.h
+++ b/include/lldb/Core/ValueObject.h
@@ -612,6 +612,8 @@ public:
 
   virtual bool HasSyntheticValue();
 
+  SwiftASTContext *GetSwiftASTContext();
+
   virtual bool IsSynthetic() { return false; }
 
   lldb::ValueObjectSP
@@ -1023,6 +1025,11 @@ protected:
   const char *GetLocationAsCStringImpl(const Value &value,
                                        const DataExtractor &data);
 
+  virtual lldb_private::Status
+  GetValueAsData(ExecutionContext *exe_ctx, DataExtractor &data,
+                 uint32_t data_offset, Module *module,
+                 bool mask_error_on_zerosize_type = true);
+
   bool IsChecksumEmpty();
 
   void SetPreferredDisplayLanguageIfNeeded(lldb::LanguageType);
diff --git a/include/lldb/Core/ValueObjectSyntheticFilter.h b/include/lldb/Core/ValueObjectSyntheticFilter.h
index e32e14030..ac2f54533 100644
--- a/include/lldb/Core/ValueObjectSyntheticFilter.h
+++ b/include/lldb/Core/ValueObjectSyntheticFilter.h
@@ -77,6 +77,12 @@ public:
 
   bool IsSynthetic() override { return true; }
 
+  bool IsBaseClass() override {
+    if (m_parent)
+      return m_parent->IsBaseClass();
+    return false;
+  }
+
   void CalculateSyntheticValue(bool use_synthetic) override {}
 
   bool IsDynamic() override {
@@ -108,6 +114,16 @@ public:
     return (UpdateValueIfNeeded(), m_provides_value == eLazyBoolYes);
   }
 
+  lldb::ValueObjectSP
+  GetSyntheticChildAtOffset(uint32_t offset, const CompilerType &type,
+                            bool can_create,
+                            ConstString name = ConstString()) override {
+    if (m_parent)
+      return m_parent->GetSyntheticChildAtOffset(offset, type, can_create,
+                                                 name);
+    return nullptr;
+  }
+
   bool GetIsConstant() const override { return false; }
 
   bool SetValueFromCString(const char *value_str, Status &error) override;
diff --git a/include/lldb/DataFormatters/DumpValueObjectOptions.h b/include/lldb/DataFormatters/DumpValueObjectOptions.h
index 00baea77f..f3ed23898 100644
--- a/include/lldb/DataFormatters/DumpValueObjectOptions.h
+++ b/include/lldb/DataFormatters/DumpValueObjectOptions.h
@@ -27,7 +27,7 @@ namespace lldb_private {
 class DumpValueObjectOptions {
 public:
   struct PointerDepth {
-    enum class Mode { Always, Default, Never } m_mode;
+    enum class Mode { Always, Formatters, Default, Never } m_mode;
     uint32_t m_count;
 
     PointerDepth operator--() const {
@@ -37,6 +37,9 @@ public:
     }
 
     bool CanAllowExpansion() const;
+
+    bool CanAllowExpansion(bool is_root, TypeSummaryImpl *entry,
+                          ValueObject *valobj, const std::string &summary);
   };
 
   struct PointerAsArraySettings {
diff --git a/include/lldb/DataFormatters/FormatManager.h b/include/lldb/DataFormatters/FormatManager.h
index 924ef0cdf..27f3939fc 100644
--- a/include/lldb/DataFormatters/FormatManager.h
+++ b/include/lldb/DataFormatters/FormatManager.h
@@ -237,6 +237,7 @@ private:
   ConstString m_default_category_name;
   ConstString m_system_category_name;
   ConstString m_vectortypes_category_name;
+  ConstString m_runtime_synths_category_name;
 
   lldb::TypeFormatImplSP GetHardcodedFormat(FormattersMatchData &);
 
diff --git a/include/lldb/Expression/Expression.h b/include/lldb/Expression/Expression.h
index 860444e9c..16de6737f 100644
--- a/include/lldb/Expression/Expression.h
+++ b/include/lldb/Expression/Expression.h
@@ -20,9 +20,12 @@
 // Project includes
 
 #include "lldb/Expression/ExpressionTypeSystemHelper.h"
+#include "lldb/Symbol/CompilerType.h"
 #include "lldb/lldb-forward.h"
 #include "lldb/lldb-private.h"
 
+#include "llvm/ADT/SmallVector.h"
+
 namespace lldb_private {
 
 class RecordingMemoryManager;
@@ -69,6 +72,14 @@ public:
   //------------------------------------------------------------------
   virtual lldb::LanguageType Language() { return lldb::eLanguageTypeUnknown; }
 
+  //------------------------------------------------------------------
+  /// Return the object that the parser should use when registering external
+  /// values (assuming it doesn't use a ClangExpressionDeclMap).  May be
+  /// NULL if there is a ClangExpressionDeclMap or everything should be
+  /// self-contained.
+  //------------------------------------------------------------------
+  virtual Materializer *GetMaterializer() { return NULL; }
+
   //------------------------------------------------------------------
   /// Return the desired result type of the function, or
   /// eResultTypeAny if indifferent.
@@ -109,6 +120,17 @@ public:
   //------------------------------------------------------------------
   virtual void DidFinishExecuting() {}
 
+  struct SwiftGenericInfo {
+    struct Binding {
+      const char *name;
+      CompilerType type;
+    };
+    llvm::SmallVector<Binding, 3> function_bindings;
+    llvm::SmallVector<Binding, 3> class_bindings;
+  };
+
+  const SwiftGenericInfo &GetSwiftGenericInfo() { return m_swift_generic_info; }
+
   virtual ExpressionTypeSystemHelper *GetTypeSystemHelper() { return nullptr; }
 
 protected:
@@ -122,6 +144,7 @@ protected:
   lldb::addr_t m_jit_end_addr;   ///< The address of the JITted function within
                                  ///the JIT allocation.  LLDB_INVALID_ADDRESS if
                                  ///invalid.
+  SwiftGenericInfo m_swift_generic_info;
 };
 
 } // namespace lldb_private
diff --git a/include/lldb/Expression/ExpressionParser.h b/include/lldb/Expression/ExpressionParser.h
index 19526d28b..6d69dac6a 100644
--- a/include/lldb/Expression/ExpressionParser.h
+++ b/include/lldb/Expression/ExpressionParser.h
@@ -59,7 +59,10 @@ public:
   ///     The number of errors encountered during parsing.  0 means
   ///     success.
   //------------------------------------------------------------------
-  virtual unsigned Parse(DiagnosticManager &diagnostic_manager) = 0;
+  virtual unsigned Parse(DiagnosticManager &diagnostic_manager,
+                         uint32_t first_line = 0,
+                         uint32_t last_line = UINT32_MAX,
+                         uint32_t line_offset = 0) = 0;
 
   //------------------------------------------------------------------
   /// Try to use the FixIts in the diagnostic_manager to rewrite the
diff --git a/include/lldb/Expression/ExpressionSourceCode.h b/include/lldb/Expression/ExpressionSourceCode.h
index 02fc72aaf..87151776b 100644
--- a/include/lldb/Expression/ExpressionSourceCode.h
+++ b/include/lldb/Expression/ExpressionSourceCode.h
@@ -10,7 +10,10 @@
 #ifndef liblldb_ExpressionSourceCode_h
 #define liblldb_ExpressionSourceCode_h
 
+#include "lldb/Expression/Expression.h"
 #include "lldb/lldb-enumerations.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringRef.h"
 
 #include <string>
 
@@ -36,9 +39,18 @@ public:
 
   const char *GetName() const { return m_name.c_str(); }
 
-  bool GetText(std::string &text, lldb::LanguageType wrapping_language,
-               bool static_method, ExecutionContext &exe_ctx) const;
+  uint32_t GetNumBodyLines();
 
+  bool GetText(std::string &text, lldb::LanguageType wrapping_language,
+               uint32_t language_flags,
+               const EvaluateExpressionOptions &options,
+               const Expression::SwiftGenericInfo &generic_info,
+               ExecutionContext &exe_ctx, uint32_t &first_body_line) const;
+
+  static bool
+  SaveExpressionTextToTempFile(llvm::StringRef text,
+                               const EvaluateExpressionOptions &options,
+                               std::string &expr_source_path);
   // Given a string returned by GetText, find the beginning and end of the body
   // passed to CreateWrapped.
   // Return true if the bounds could be found.  This will also work on text with
@@ -50,11 +62,13 @@ public:
 private:
   ExpressionSourceCode(const char *name, const char *prefix, const char *body,
                        bool wrap)
-      : m_name(name), m_prefix(prefix), m_body(body), m_wrap(wrap) {}
+      : m_name(name), m_prefix(prefix), m_body(body), m_num_body_lines(0),
+        m_wrap(wrap) {}
 
   std::string m_name;
   std::string m_prefix;
   std::string m_body;
+  uint32_t m_num_body_lines;
   bool m_wrap;
 };
 
diff --git a/include/lldb/Expression/ExpressionVariable.h b/include/lldb/Expression/ExpressionVariable.h
index c7570932c..a05b52ec1 100644
--- a/include/lldb/Expression/ExpressionVariable.h
+++ b/include/lldb/Expression/ExpressionVariable.h
@@ -242,7 +242,7 @@ public:
                            lldb::ByteOrder byte_order,
                            uint32_t addr_byte_size) = 0;
 
-  virtual ConstString GetNextPersistentVariableName() = 0;
+  virtual ConstString GetNextPersistentVariableName(bool is_error = false) = 0;
 
   virtual void
   RemovePersistentVariable(lldb::ExpressionVariableSP variable) = 0;
@@ -251,6 +251,8 @@ public:
 
   void RegisterExecutionUnit(lldb::IRExecutionUnitSP &execution_unit_sp);
 
+  void RegisterSymbol(const ConstString &name, lldb::addr_t address);
+
 private:
   LLVMCastKind m_kind;
 
diff --git a/include/lldb/Expression/IRExecutionUnit.h b/include/lldb/Expression/IRExecutionUnit.h
index b0b4d7a5c..5ab7a6375 100644
--- a/include/lldb/Expression/IRExecutionUnit.h
+++ b/include/lldb/Expression/IRExecutionUnit.h
@@ -14,6 +14,7 @@
 // C++ Includes
 #include <atomic>
 #include <memory>
+#include <mutex>
 #include <string>
 #include <vector>
 
@@ -116,6 +117,16 @@ public:
 
   lldb::ModuleSP GetJITModule();
 
+  lldb::ModuleSP CreateJITModule(const char *name,
+                                 const FileSpec *limit_file_ptr = NULL,
+                                 uint32_t limit_start_line = 0,
+                                 uint32_t limit_end_line = 0);
+
+  //------------------------------------------------------------------
+  /// Accessor for the mutex that guards LLVM::getGlobalContext()
+  //------------------------------------------------------------------
+  static std::recursive_mutex &GetLLVMGlobalContextMutex();
+
   lldb::addr_t FindSymbol(const ConstString &name);
 
   void GetStaticInitializers(std::vector<lldb::addr_t> &static_initializers);
@@ -335,6 +346,10 @@ private:
     void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,
                           size_t Size) override {}
 
+    virtual void deregisterEHFrames() override {
+      return;
+    }
+
     uint64_t getSymbolAddress(const std::string &Name) override;
 
     void *getPointerToNamedFunction(const std::string &Name,
@@ -401,7 +416,8 @@ private:
   std::unique_ptr<llvm::ExecutionEngine> m_execution_engine_ap;
   std::unique_ptr<llvm::ObjectCache> m_object_cache_ap;
   std::unique_ptr<llvm::Module>
-      m_module_ap;        ///< Holder for the module until it's been handed off
+      m_module_ap; ///< Holder for the module until it's been handed off
+  lldb::ModuleWP m_jit_module_wp;
   llvm::Module *m_module; ///< Owned by the execution engine
   std::vector<std::string> m_cpu_features;
   std::vector<JittedFunction> m_jitted_functions; ///< A vector of all functions
diff --git a/include/lldb/Expression/LLVMUserExpression.h b/include/lldb/Expression/LLVMUserExpression.h
index 745d413e0..ed6988c58 100644
--- a/include/lldb/Expression/LLVMUserExpression.h
+++ b/include/lldb/Expression/LLVMUserExpression.h
@@ -65,6 +65,10 @@ public:
 
   bool CanInterpret() override { return m_can_interpret; }
 
+  virtual Materializer *GetMaterializer() override {
+    return m_materializer_ap.get();
+  }
+
   //------------------------------------------------------------------
   /// Return the string that the parser should parse.  Must be a full
   /// translation unit.
@@ -73,6 +77,8 @@ public:
 
   lldb::ModuleSP GetJITModule() override;
 
+  uint32_t GetLanguageFlags() { return m_language_flags; }
+
 protected:
   lldb::ExpressionResults
   DoExecute(DiagnosticManager &diagnostic_manager, ExecutionContext &exe_ctx,
@@ -107,22 +113,10 @@ protected:
                                                    ///when running the
                                                    ///expression.
   lldb::ModuleWP m_jit_module_wp;
-  bool m_enforce_valid_object; ///< True if the expression parser should enforce
-                               ///the presence of a valid class pointer
-  /// in order to generate the expression as a method.
-  bool m_in_cplusplus_method;  ///< True if the expression is compiled as a C++
-                               ///member function (true if it was parsed
-                               /// when exe_ctx was in a C++ method).
-  bool m_in_objectivec_method; ///< True if the expression is compiled as an
-                               ///Objective-C method (true if it was parsed
-                               /// when exe_ctx was in an Objective-C method).
-  bool m_in_static_method; ///< True if the expression is compiled as a static
-                           ///(or class) method (currently true if it
-  /// was parsed when exe_ctx was in an Objective-C class method).
-  bool m_needs_object_ptr; ///< True if "this" or "self" must be looked up and
-                           ///passed in.  False if the expression
-                           /// doesn't really use them and they can be NULL.
-  bool m_const_object;     ///< True if "this" is const.
+
+  uint32_t
+      m_language_flags; ///< Populated by the language-specific ScanContext()
+
   Target *m_target; ///< The target for storing persistent data like types and
                     ///variables.
 
diff --git a/include/lldb/Expression/Materializer.h b/include/lldb/Expression/Materializer.h
index b86bc656d..9cd23f252 100644
--- a/include/lldb/Expression/Materializer.h
+++ b/include/lldb/Expression/Materializer.h
@@ -27,8 +27,16 @@ namespace lldb_private {
 
 class Materializer {
 public:
+  //----------------------------------------------------------------------
+  // See TypeSystem.h for how to add subclasses to this.
+  //----------------------------------------------------------------------
+  enum LLVMCastKind { eKindBasic, eKindSwiftREPL };
+
+  LLVMCastKind getKind() const { return m_kind; }
+
+  Materializer(LLVMCastKind kind);
   Materializer();
-  ~Materializer();
+  virtual ~Materializer();
 
   class Dematerializer {
   public:
@@ -43,10 +51,7 @@ public:
 
     void Wipe();
 
-    bool IsValid() {
-      return m_materializer && m_map &&
-             (m_process_address != LLDB_INVALID_ADDRESS);
-    }
+    bool IsValid() { return m_materializer && m_map; }
 
   private:
     friend class Materializer;
@@ -81,7 +86,7 @@ public:
     virtual void DidDematerialize(lldb::ExpressionVariableSP &variable) = 0;
   };
 
-  uint32_t
+  virtual uint32_t
   AddPersistentVariable(lldb::ExpressionVariableSP &persistent_variable_sp,
                         PersistentVariableDelegate *delegate, Status &err);
   uint32_t AddVariable(lldb::VariableSP &variable_sp, Status &err);
@@ -127,12 +132,13 @@ public:
     uint32_t m_offset;
   };
 
-private:
+protected:
   uint32_t AddStructMember(Entity &entity);
 
   typedef std::unique_ptr<Entity> EntityUP;
   typedef std::vector<EntityUP> EntityVector;
 
+  LLVMCastKind m_kind;
   DematerializerWP m_dematerializer_wp;
   EntityVector m_entities;
   uint32_t m_current_offset;
diff --git a/include/lldb/Expression/UserExpression.h b/include/lldb/Expression/UserExpression.h
index ced5cb2bf..78f15d120 100644
--- a/include/lldb/Expression/UserExpression.h
+++ b/include/lldb/Expression/UserExpression.h
@@ -96,7 +96,8 @@ public:
   virtual bool Parse(DiagnosticManager &diagnostic_manager,
                      ExecutionContext &exe_ctx,
                      lldb_private::ExecutionPolicy execution_policy,
-                     bool keep_result_in_memory, bool generate_debug_info) = 0;
+                     bool keep_result_in_memory, bool generate_debug_info,
+                     uint32_t line_offset) = 0;
 
   virtual bool CanInterpret() = 0;
 
@@ -213,6 +214,8 @@ public:
     return lldb::ExpressionVariableSP();
   }
 
+  // FIXME: This doesn't make sense in UserExpression.  It is only used in
+  // UserExpression::Evaluate.
   virtual lldb::ModuleSP GetJITModule() { return lldb::ModuleSP(); }
 
   //------------------------------------------------------------------
diff --git a/include/lldb/Host/File.h b/include/lldb/Host/File.h
index 1dfa12ea5..8c8735de7 100644
--- a/include/lldb/Host/File.h
+++ b/include/lldb/Host/File.h
@@ -54,13 +54,15 @@ public:
       : IOObject(eFDTypeFile, false), m_descriptor(kInvalidDescriptor),
         m_stream(kInvalidStream), m_options(0), m_own_stream(false),
         m_is_interactive(eLazyBoolCalculate),
-        m_is_real_terminal(eLazyBoolCalculate) {}
+        m_is_real_terminal(eLazyBoolCalculate),
+        m_supports_colors(eLazyBoolCalculate) {}
 
   File(FILE *fh, bool transfer_ownership)
       : IOObject(eFDTypeFile, false), m_descriptor(kInvalidDescriptor),
         m_stream(fh), m_options(0), m_own_stream(transfer_ownership),
         m_is_interactive(eLazyBoolCalculate),
-        m_is_real_terminal(eLazyBoolCalculate) {}
+        m_is_real_terminal(eLazyBoolCalculate),
+        m_supports_colors(eLazyBoolCalculate) {}
 
   //------------------------------------------------------------------
   /// Constructor with path.
@@ -109,7 +111,8 @@ public:
       : IOObject(eFDTypeFile, transfer_ownership), m_descriptor(fd),
         m_stream(kInvalidStream), m_options(0), m_own_stream(false),
         m_is_interactive(eLazyBoolCalculate),
-        m_is_real_terminal(eLazyBoolCalculate) {}
+        m_is_real_terminal(eLazyBoolCalculate),
+        m_supports_colors(eLazyBoolCalculate) {}
 
   //------------------------------------------------------------------
   /// Destructor.
@@ -476,6 +479,7 @@ protected:
   FILE *m_stream;
   uint32_t m_options;
   bool m_own_stream;
+  bool m_own_descriptor;
   LazyBool m_is_interactive;
   LazyBool m_is_real_terminal;
   LazyBool m_supports_colors;
diff --git a/include/lldb/Host/HostInfoBase.h b/include/lldb/Host/HostInfoBase.h
index 42e3fc3fd..d66ac8c54 100644
--- a/include/lldb/Host/HostInfoBase.h
+++ b/include/lldb/Host/HostInfoBase.h
@@ -84,12 +84,14 @@ public:
 protected:
   static bool ComputeSharedLibraryDirectory(FileSpec &file_spec);
   static bool ComputeSupportExeDirectory(FileSpec &file_spec);
+  static bool ComputeSupportFileDirectory(FileSpec &file_spec);
   static bool ComputeProcessTempFileDirectory(FileSpec &file_spec);
   static bool ComputeGlobalTempFileDirectory(FileSpec &file_spec);
   static bool ComputeTempFileBaseDirectory(FileSpec &file_spec);
   static bool ComputeHeaderDirectory(FileSpec &file_spec);
   static bool ComputeSystemPluginsDirectory(FileSpec &file_spec);
   static bool ComputeClangDirectory(FileSpec &file_spec);
+  static bool ComputeSwiftDirectory(FileSpec &file_spec);
   static bool ComputeUserPluginsDirectory(FileSpec &file_spec);
 
   static void ComputeHostArchitectureSupport(ArchSpec &arch_32,
diff --git a/include/lldb/Host/macosx/HostInfoMacOSX.h b/include/lldb/Host/macosx/HostInfoMacOSX.h
index eee842bee..a0d192e26 100644
--- a/include/lldb/Host/macosx/HostInfoMacOSX.h
+++ b/include/lldb/Host/macosx/HostInfoMacOSX.h
@@ -33,11 +33,13 @@ public:
 
 protected:
   static bool ComputeSupportExeDirectory(FileSpec &file_spec);
+  static bool ComputeSupportFileDirectory(FileSpec &file_spec);
   static void ComputeHostArchitectureSupport(ArchSpec &arch_32,
                                              ArchSpec &arch_64);
   static bool ComputeHeaderDirectory(FileSpec &file_spec);
   static bool ComputePythonDirectory(FileSpec &file_spec);
   static bool ComputeClangDirectory(FileSpec &file_spec);
+  static bool ComputeSwiftDirectory(FileSpec &file_spec);
   static bool ComputeSystemPluginsDirectory(FileSpec &file_spec);
   static bool ComputeUserPluginsDirectory(FileSpec &file_spec);
 };
diff --git a/include/lldb/Host/posix/HostInfoPosix.h b/include/lldb/Host/posix/HostInfoPosix.h
index 34994aea4..bfda01787 100644
--- a/include/lldb/Host/posix/HostInfoPosix.h
+++ b/include/lldb/Host/posix/HostInfoPosix.h
@@ -35,9 +35,11 @@ public:
 
 protected:
   static bool ComputeSupportExeDirectory(FileSpec &file_spec);
+  static bool ComputeSupportFileDirectory(FileSpec &file_spec);
   static bool ComputeHeaderDirectory(FileSpec &file_spec);
   static bool ComputePythonDirectory(FileSpec &file_spec);
   static bool ComputeClangDirectory(FileSpec &file_spec);
+  static bool ComputeSwiftDirectory(FileSpec &file_spec);
   static bool ComputePathRelativeToLibrary(FileSpec &file_spec,
                                            llvm::StringRef dir);
 };
diff --git a/include/lldb/Interpreter/Args.h b/include/lldb/Interpreter/Args.h
index 98046cd59..f7a725932 100644
--- a/include/lldb/Interpreter/Args.h
+++ b/include/lldb/Interpreter/Args.h
@@ -339,6 +339,11 @@ public:
                               OptionElementVector &option_element_vector,
                               uint32_t cursor_index);
 
+  bool GetOptionValueAsString(const char *option, std::string &value);
+
+  int GetOptionValuesAsStrings(const char *option,
+                               std::vector<std::string> &values);
+
   //------------------------------------------------------------------
   // Clear the arguments.
   //
diff --git a/include/lldb/Symbol/ClangASTContext.h b/include/lldb/Symbol/ClangASTContext.h
index 9d0a08414..b99d0dbf9 100644
--- a/include/lldb/Symbol/ClangASTContext.h
+++ b/include/lldb/Symbol/ClangASTContext.h
@@ -61,6 +61,8 @@ public:
   //------------------------------------------------------------------
   ClangASTContext(const char *triple = nullptr);
 
+  ClangASTContext(clang::ASTContext *ast_ctx);
+
   ~ClangASTContext() override;
 
   void Finalize() override;
@@ -75,7 +77,8 @@ public:
   static ConstString GetPluginNameStatic();
 
   static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,
-                                           Module *module, Target *target);
+                                           Module *module, Target *target,
+                                           const char *compiler_options);
 
   static void EnumerateSupportedLanguages(
       std::set<lldb::LanguageType> &languages_for_types,
@@ -199,6 +202,11 @@ public:
     return GetTranslationUnitDecl(getASTContext());
   }
 
+  //----------------------------------------------------------------------
+  // Copy "src" into this ClangASTContext.
+  //----------------------------------------------------------------------
+  CompilerType CopyType(const CompilerType &src);
+
   static clang::Decl *CopyDecl(clang::ASTContext *dest_context,
                                clang::ASTContext *source_context,
                                clang::Decl *source_decl);
@@ -265,6 +273,11 @@ public:
   static uint32_t GetNumBaseClasses(const clang::CXXRecordDecl *cxx_record_decl,
                                     bool omit_empty_base_classes);
 
+  static uint32_t
+  GetIndexForRecordBase(const clang::RecordDecl *record_decl,
+                        const clang::CXXBaseSpecifier *base_spec,
+                        bool omit_empty_base_classes);
+
   CompilerType CreateRecordType(clang::DeclContext *decl_ctx,
                                 lldb::AccessType access_type, const char *name,
                                 int kind, lldb::LanguageType language,
@@ -576,7 +589,8 @@ public:
 
   bool IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                              CompilerType *target_type, // Can pass nullptr
-                             bool check_cplusplus, bool check_objc) override;
+                             bool check_cplusplus, bool check_objc,
+                             bool check_swift) override;
 
   bool IsRuntimeGeneratedType(lldb::opaque_compiler_type_t type) override;
 
@@ -644,6 +658,8 @@ public:
 
   CompilerType GetCanonicalType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetInstanceType(lldb::opaque_compiler_type_t type) override;
+
   CompilerType
   GetFullyUnqualifiedType(lldb::opaque_compiler_type_t type) override;
 
@@ -664,14 +680,18 @@ public:
   GetMemberFunctionAtIndex(lldb::opaque_compiler_type_t type,
                            size_t idx) override;
 
+  static CompilerType GetLValueReferenceType(const CompilerType &compiler_type);
+
+  CompilerType
+  GetLValueReferenceType(lldb::opaque_compiler_type_t type) override;
+
   CompilerType GetNonReferenceType(lldb::opaque_compiler_type_t type) override;
 
   CompilerType GetPointeeType(lldb::opaque_compiler_type_t type) override;
 
   CompilerType GetPointerType(lldb::opaque_compiler_type_t type) override;
 
-  CompilerType
-  GetLValueReferenceType(lldb::opaque_compiler_type_t type) override;
+  CompilerType GetRValueReferenceType(const CompilerType &type);
 
   CompilerType
   GetRValueReferenceType(lldb::opaque_compiler_type_t type) override;
@@ -689,6 +709,10 @@ public:
   // If the current object represents a typedef type, get the underlying type
   CompilerType GetTypedefedType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) override;
+
+  static CompilerType RemoveFastQualifiers(const CompilerType &type);
+
   //----------------------------------------------------------------------
   // Create related types using the current type's AST
   //----------------------------------------------------------------------
@@ -706,6 +730,8 @@ public:
   uint64_t GetBitSize(lldb::opaque_compiler_type_t type,
                       ExecutionContextScope *exe_scope) override;
 
+  uint64_t GetByteStride(lldb::opaque_compiler_type_t type) override;
+
   lldb::Encoding GetEncoding(lldb::opaque_compiler_type_t type,
                              uint64_t &count) override;
 
@@ -903,7 +929,8 @@ public:
                      lldb::Format format, const DataExtractor &data,
                      lldb::offset_t data_offset, size_t data_byte_size,
                      uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-                     ExecutionContextScope *exe_scope) override;
+                     ExecutionContextScope *exe_scope,
+                     bool is_base_class) override;
 
   void DumpSummary(lldb::opaque_compiler_type_t type, ExecutionContext *exe_ctx,
                    Stream *s, const DataExtractor &data,
diff --git a/include/lldb/Symbol/CompilerType.h b/include/lldb/Symbol/CompilerType.h
index c5bca54ed..7391df5c6 100644
--- a/include/lldb/Symbol/CompilerType.h
+++ b/include/lldb/Symbol/CompilerType.h
@@ -19,6 +19,7 @@
 // Other libraries and framework includes
 // Project includes
 #include "lldb/Core/ClangForward.h"
+#include "lldb/Core/SwiftForward.h"
 #include "lldb/lldb-private.h"
 
 namespace lldb_private {
@@ -42,6 +43,7 @@ public:
   //----------------------------------------------------------------------
   CompilerType(TypeSystem *type_system, lldb::opaque_compiler_type_t type);
   CompilerType(clang::ASTContext *ast_context, clang::QualType qual_type);
+  CompilerType(swift::ASTContext *ast_context, swift::Type qual_type);
 
   CompilerType(const CompilerType &rhs)
       : m_type(rhs.m_type), m_type_system(rhs.m_type_system) {}
@@ -125,11 +127,12 @@ public:
 
   bool
   IsPossibleCPlusPlusDynamicType(CompilerType *target_type = nullptr) const {
-    return IsPossibleDynamicType(target_type, true, false);
+    return IsPossibleDynamicType(target_type, true, false, false);
   }
 
   bool IsPossibleDynamicType(CompilerType *target_type, // Can pass nullptr
-                             bool check_cplusplus, bool check_objc) const;
+                             bool check_cplusplus, bool check_objc,
+                             bool check_swift) const;
 
   bool IsPointerToScalarType() const;
 
@@ -176,6 +179,10 @@ public:
 
   ConstString GetDisplayTypeName() const;
 
+  ConstString GetTypeSymbolName() const;
+
+  ConstString GetMangledTypeName() const;
+
   uint32_t
   GetTypeInfo(CompilerType *pointee_or_element_compiler_type = nullptr) const;
 
@@ -202,6 +209,8 @@ public:
 
   CompilerType GetCanonicalType() const;
 
+  CompilerType GetInstanceType() const;
+
   CompilerType GetFullyUnqualifiedType() const;
 
   // Returns -1 if this isn't a function of if the function doesn't have a
@@ -281,6 +290,8 @@ public:
   // If the current object represents a typedef type, get the underlying type
   CompilerType GetTypedefedType() const;
 
+  CompilerType GetUnboundType() const;
+
   //----------------------------------------------------------------------
   // Create related types using the current type's AST
   //----------------------------------------------------------------------
@@ -294,6 +305,10 @@ public:
 
   uint64_t GetBitSize(ExecutionContextScope *exe_scope) const;
 
+  uint64_t GetByteStride() const;
+
+  uint64_t GetAlignedBitSize() const;
+
   lldb::Encoding GetEncoding(uint64_t &count) const;
 
   lldb::Format GetFormat() const;
@@ -395,7 +410,7 @@ public:
   bool DumpTypeValue(Stream *s, lldb::Format format, const DataExtractor &data,
                      lldb::offset_t data_offset, size_t data_byte_size,
                      uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-                     ExecutionContextScope *exe_scope);
+                     ExecutionContextScope *exe_scope, bool is_base_class);
 
   void DumpSummary(ExecutionContext *exe_ctx, Stream *s,
                    const DataExtractor &data, lldb::offset_t data_offset,
diff --git a/include/lldb/Symbol/Function.h b/include/lldb/Symbol/Function.h
index 9d376007a..7cf30a361 100644
--- a/include/lldb/Symbol/Function.h
+++ b/include/lldb/Symbol/Function.h
@@ -346,10 +346,14 @@ public:
   ///
   /// @param[in] range
   ///     The section offset based address for this function.
+  ///
+  /// @param[in] can_throw
+  ///     Pass in true if this is a function know to throw
   //------------------------------------------------------------------
   Function(CompileUnit *comp_unit, lldb::user_id_t func_uid,
            lldb::user_id_t func_type_uid, const Mangled &mangled,
-           Type *func_type, const AddressRange &range);
+           Type *func_type, const AddressRange &range,
+           bool can_throw = false);
 
   //------------------------------------------------------------------
   /// Construct with a compile unit, function UID, function type UID,
@@ -381,10 +385,13 @@ public:
   ///
   /// @param[in] range
   ///     The section offset based address for this function.
+  ///
+  /// @param[in] can_throw
+  ///     Pass in true if this is a function know to throw
   //------------------------------------------------------------------
   Function(CompileUnit *comp_unit, lldb::user_id_t func_uid,
            lldb::user_id_t func_type_uid, const char *mangled, Type *func_type,
-           const AddressRange &range);
+           const AddressRange &range, bool can_throw = false);
 
   //------------------------------------------------------------------
   /// Destructor.
@@ -596,6 +603,8 @@ public:
   //------------------------------------------------------------------
   bool IsTopLevelFunction();
 
+  bool CanThrow() const { return m_flags.Test(flagsFunctionCanThrow); }
+
   lldb::DisassemblerSP GetInstructions(const ExecutionContext &exe_ctx,
                                        const char *flavor,
                                        bool prefer_file_cache);
@@ -606,7 +615,9 @@ public:
 protected:
   enum {
     flagsCalculatedPrologueSize =
-        (1 << 0) ///< Have we already tried to calculate the prologue size?
+        (1 << 0), ///< Have we already tried to calculate the prologue size?
+    flagsFunctionCanThrow =
+        (1 << 1) ///< Do we know whether this function throws?
   };
 
   //------------------------------------------------------------------
diff --git a/include/lldb/Symbol/GoASTContext.h b/include/lldb/Symbol/GoASTContext.h
index 6feac7abf..84f4897f4 100644
--- a/include/lldb/Symbol/GoASTContext.h
+++ b/include/lldb/Symbol/GoASTContext.h
@@ -44,7 +44,8 @@ public:
   static ConstString GetPluginNameStatic();
 
   static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,
-                                           Module *module, Target *target);
+                                           Module *module, Target *target,
+                                           const char *compiler_options);
 
   static void EnumerateSupportedLanguages(
       std::set<lldb::LanguageType> &languages_for_types,
@@ -168,7 +169,8 @@ public:
 
   bool IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                              CompilerType *target_type, // Can pass nullptr
-                             bool check_cplusplus, bool check_objc) override;
+                             bool check_cplusplus, bool check_objc,
+                             bool check_swift) override;
 
   bool IsPointerType(lldb::opaque_compiler_type_t type,
                      CompilerType *pointee_type = nullptr) override;
@@ -215,6 +217,10 @@ public:
 
   CompilerType GetCanonicalType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetInstanceType(lldb::opaque_compiler_type_t type) override {
+    return CompilerType(this, type);
+  }
+
   // Returns -1 if this isn't a function of if the function doesn't have a
   // prototype
   // Returns a value >= 0 if there is a prototype.
@@ -243,6 +249,10 @@ public:
   uint64_t GetBitSize(lldb::opaque_compiler_type_t type,
                       ExecutionContextScope *exe_scope) override;
 
+  uint64_t GetByteStride(lldb::opaque_compiler_type_t type) override {
+    return 0;
+  }
+
   lldb::Encoding GetEncoding(lldb::opaque_compiler_type_t type,
                              uint64_t &count) override;
 
@@ -331,11 +341,13 @@ public:
                  bool show_types, bool show_summary, bool verbose,
                  uint32_t depth) override;
 
-  bool DumpTypeValue(lldb::opaque_compiler_type_t type, Stream *s,
-                     lldb::Format format, const DataExtractor &data,
-                     lldb::offset_t data_offset, size_t data_byte_size,
-                     uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-                     ExecutionContextScope *exe_scope) override;
+  virtual bool DumpTypeValue(lldb::opaque_compiler_type_t type, Stream *s,
+                             lldb::Format format, const DataExtractor &data,
+                             lldb::offset_t data_offset, size_t data_byte_size,
+                             uint32_t bitfield_bit_size,
+                             uint32_t bitfield_bit_offset,
+                             ExecutionContextScope *exe_scope,
+                             bool is_base_class) override;
 
   void DumpTypeDescription(
       lldb::opaque_compiler_type_t type) override; // Dump to stdout
@@ -387,7 +399,11 @@ public:
   bool IsTypedefType(lldb::opaque_compiler_type_t type) override;
 
   // If the current object represents a typedef type, get the underlying type
-  CompilerType GetTypedefedType(lldb::opaque_compiler_type_t type) override;
+  CompilerType GetTypedefedType(void *type) override;
+
+  CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) override {
+    return CompilerType(this, type);
+  }
 
   bool IsVectorType(lldb::opaque_compiler_type_t type,
                     CompilerType *element_type, uint64_t *size) override;
@@ -397,6 +413,11 @@ public:
 
   CompilerType GetNonReferenceType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType
+  GetLValueReferenceType(lldb::opaque_compiler_type_t type) override {
+    return CompilerType(this, type);
+  }
+
   bool IsReferenceType(lldb::opaque_compiler_type_t type,
                        CompilerType *pointee_type = nullptr,
                        bool *is_rvalue = nullptr) override;
diff --git a/include/lldb/Symbol/JavaASTContext.h b/include/lldb/Symbol/JavaASTContext.h
index 4fdd2371b..f701746f3 100644
--- a/include/lldb/Symbol/JavaASTContext.h
+++ b/include/lldb/Symbol/JavaASTContext.h
@@ -41,7 +41,8 @@ public:
   static ConstString GetPluginNameStatic();
 
   static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,
-                                           Module *module, Target *target);
+                                           Module *module, Target *target,
+                                           const char *extra_options);
 
   static void EnumerateSupportedLanguages(
       std::set<lldb::LanguageType> &languages_for_types,
@@ -111,7 +112,7 @@ public:
 
   bool IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                              CompilerType *target_type, bool check_cplusplus,
-                             bool check_objc) override;
+                             bool check_objc, bool check_swift) override;
 
   bool IsPointerType(lldb::opaque_compiler_type_t type,
                      CompilerType *pointee_type = nullptr) override;
@@ -174,6 +175,8 @@ public:
 
   CompilerType GetCanonicalType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetInstanceType(lldb::opaque_compiler_type_t type) override;
+
   CompilerType
   GetFullyUnqualifiedType(lldb::opaque_compiler_type_t type) override;
 
@@ -181,6 +184,8 @@ public:
 
   CompilerType GetTypedefedType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) override;
+
   CompilerType GetBasicTypeFromAST(lldb::BasicType basic_type) override;
 
   CompilerType GetBuiltinTypeForEncodingAndBitSize(lldb::Encoding encoding,
@@ -194,6 +199,8 @@ public:
   uint64_t GetBitSize(lldb::opaque_compiler_type_t type,
                       ExecutionContextScope *exe_scope) override;
 
+  uint64_t GetByteStride(lldb::opaque_compiler_type_t type) override;
+
   lldb::Encoding GetEncoding(lldb::opaque_compiler_type_t type,
                              uint64_t &count) override;
 
@@ -258,8 +265,8 @@ public:
                      lldb::Format format, const DataExtractor &data,
                      lldb::offset_t data_offset, size_t data_byte_size,
                      uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-                     ExecutionContextScope *exe_scope) override;
-
+                     ExecutionContextScope *exe_scope,
+                     bool is_base_class) override;
   void DumpTypeDescription(lldb::opaque_compiler_type_t type) override;
 
   void DumpTypeDescription(lldb::opaque_compiler_type_t type,
diff --git a/include/lldb/Symbol/OCamlASTContext.h b/include/lldb/Symbol/OCamlASTContext.h
index a261d4351..82f56c8ac 100644
--- a/include/lldb/Symbol/OCamlASTContext.h
+++ b/include/lldb/Symbol/OCamlASTContext.h
@@ -42,7 +42,8 @@ public:
   static ConstString GetPluginNameStatic();
 
   static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,
-                                           Module *module, Target *target);
+                                           Module *module, Target *target,
+                                           const char *compiler_options);
 
   static void EnumerateSupportedLanguages(
       std::set<lldb::LanguageType> &languages_for_types,
@@ -118,8 +119,9 @@ public:
                      bool &is_signed) override;
 
   bool IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
-                             CompilerType *target_type, bool check_cplusplus,
-                             bool check_objc) override;
+                             CompilerType *target_type, // Can pass NULL
+                             bool check_cplusplus, bool check_objc,
+                             bool check_swift) override;
 
   bool IsPointerType(lldb::opaque_compiler_type_t type,
                      CompilerType *pointee_type = nullptr) override;
@@ -146,6 +148,8 @@ public:
 
   CompilerType GetCanonicalType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetInstanceType(lldb::opaque_compiler_type_t type) override;
+
   int GetFunctionArgumentCount(lldb::opaque_compiler_type_t type) override;
 
   CompilerType GetFunctionArgumentTypeAtIndex(lldb::opaque_compiler_type_t type,
@@ -167,6 +171,8 @@ public:
   uint64_t GetBitSize(lldb::opaque_compiler_type_t type,
                       ExecutionContextScope *exe_scope) override;
 
+  uint64_t GetByteStride(lldb::opaque_compiler_type_t type) override;
+
   lldb::Encoding GetEncoding(lldb::opaque_compiler_type_t type,
                              uint64_t &count) override;
 
@@ -248,7 +254,8 @@ public:
                      lldb::Format format, const DataExtractor &data,
                      lldb::offset_t data_offset, size_t data_byte_size,
                      uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-                     ExecutionContextScope *exe_scope) override;
+                     ExecutionContextScope *exe_scope,
+                     bool is_base_class) override;
 
   void DumpTypeDescription(lldb::opaque_compiler_type_t type) override;
 
@@ -290,6 +297,8 @@ public:
 
   CompilerType GetTypedefedType(lldb::opaque_compiler_type_t type) override;
 
+  CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) override;
+
   bool IsVectorType(lldb::opaque_compiler_type_t type,
                     CompilerType *element_type, uint64_t *size) override;
 
diff --git a/include/lldb/Symbol/SwiftASTContext.h b/include/lldb/Symbol/SwiftASTContext.h
index e69de29bb..63cdec1e9 100644
--- a/include/lldb/Symbol/SwiftASTContext.h
+++ b/include/lldb/Symbol/SwiftASTContext.h
@@ -0,0 +1,885 @@
+//===-- SwiftASTContext.h ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftASTContext_h_
+#define liblldb_SwiftASTContext_h_
+
+#include "Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.h"
+#include "lldb/Core/ClangForward.h"
+#include "lldb/Core/ThreadSafeDenseMap.h"
+#include "lldb/Core/ThreadSafeDenseSet.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Symbol/TypeSystem.h"
+#include "lldb/Utility/ConstString.h"
+#include "lldb/lldb-private.h"
+
+#include "lldb/Utility/Either.h"
+#include "lldb/Utility/Status.h"
+
+#include "llvm/ADT/Optional.h"
+
+#include <map>
+#include <set>
+
+namespace swift {
+enum class IRGenDebugInfoKind : unsigned;
+class CanType;
+class IRGenOptions;
+struct PrintOptions;
+class SILModule;
+namespace irgen {
+class FixedTypeInfo;
+class TypeInfo;
+} // namespace irgen
+} // namespace swift
+
+struct CachedMemberInfo;
+class DWARFASTParser;
+class SwiftEnumDescriptor;
+
+namespace lldb_private {
+
+class SwiftASTContext : public TypeSystem {
+public:
+  typedef lldb_utility::Either<CompilerType, swift::Decl *> TypeOrDecl;
+
+private:
+  struct EitherComparator {
+    bool operator()(const TypeOrDecl &r1, const TypeOrDecl &r2) {
+      auto r1_as1 = r1.GetAs<CompilerType>();
+      auto r1_as2 = r1.GetAs<swift::Decl *>();
+
+      auto r2_as1 = r2.GetAs<CompilerType>();
+      auto r2_as2 = r2.GetAs<swift::Decl *>();
+
+      if (r1_as1.hasValue() && r2_as1.hasValue())
+        return r1_as1.getValue() < r2_as1.getValue();
+
+      if (r1_as2.hasValue() && r2_as2.hasValue())
+        return r1_as2.getValue() < r2_as2.getValue();
+
+      if (r1_as1.hasValue() && r2_as2.hasValue())
+        return (void *)r1_as1->GetOpaqueQualType() < (void *)r2_as2.getValue();
+
+      if (r1_as2.hasValue() && r2_as1.hasValue())
+        return (void *)r1_as2.getValue() < (void *)r2_as1->GetOpaqueQualType();
+
+      return false;
+    }
+  };
+
+public:
+  typedef std::set<TypeOrDecl, EitherComparator> TypesOrDecls;
+
+  class LanguageFlags {
+  public:
+    enum : uint64_t {
+      eIsIndirectEnumCase = 0x1ULL,
+      eIgnoreInstancePointerness = 0x2ULL
+    };
+
+  private:
+    LanguageFlags() = delete;
+  };
+
+  //------------------------------------------------------------------
+  // llvm casting support
+  //------------------------------------------------------------------
+  static bool classof(const TypeSystem *ts) {
+    return ts->getKind() == TypeSystem::eKindSwift;
+  }
+
+  //------------------------------------------------------------------
+  // Provide a global LLVMContext
+  //------------------------------------------------------------------
+  static llvm::LLVMContext &GetGlobalLLVMContext();
+
+  //------------------------------------------------------------------
+  // Constructors and destructors
+  //------------------------------------------------------------------
+  SwiftASTContext(const char *triple = NULL, Target *target = NULL);
+
+  SwiftASTContext(const SwiftASTContext &rhs);
+
+  ~SwiftASTContext();
+
+  //------------------------------------------------------------------
+  // PluginInterface functions
+  //------------------------------------------------------------------
+  ConstString GetPluginName() override;
+
+  uint32_t GetPluginVersion() override;
+
+  static ConstString GetPluginNameStatic();
+
+  static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,
+                                           Module *module, Target *target,
+                                           const char *compiler_options);
+
+  static void EnumerateSupportedLanguages(
+      std::set<lldb::LanguageType> &languages_for_types,
+      std::set<lldb::LanguageType> &languages_for_expressions);
+
+  static void Initialize();
+
+  static void Terminate();
+
+  bool SupportsLanguage(lldb::LanguageType language) override;
+
+  Status IsCompatible() override;
+
+  swift::SourceManager &GetSourceManager();
+
+  swift::LangOptions &GetLanguageOptions();
+
+  swift::DiagnosticEngine &GetDiagnosticEngine();
+
+  swift::SearchPathOptions &GetSearchPathOptions();
+
+  swift::ClangImporterOptions &GetClangImporterOptions();
+
+  swift::CompilerInvocation &GetCompilerInvocation();
+
+  swift::SILOptions &GetSILOptions();
+
+  swift::ASTContext *GetASTContext();
+
+  swift::IRGenDebugInfoKind GetGenerateDebugInfo();
+
+  static swift::PrintOptions
+  GetUserVisibleTypePrintingOptions(bool print_help_if_available);
+
+  void SetGenerateDebugInfo(swift::IRGenDebugInfoKind b);
+
+  bool AddModuleSearchPath(const char *path);
+
+  bool AddFrameworkSearchPath(const char *path);
+
+  bool AddClangArgument(const char *arg, bool force = false);
+
+  bool AddClangArgumentPair(const char *arg1, const char *arg2);
+
+  const char *GetPlatformSDKPath() const {
+    if (m_platform_sdk_path.empty())
+      return NULL;
+    return m_platform_sdk_path.c_str();
+  }
+
+  void SetPlatformSDKPath(std::string &&sdk_path) {
+    m_platform_sdk_path = sdk_path;
+  }
+
+  void SetPlatformSDKPath(const char *path) {
+    if (path)
+      m_platform_sdk_path = path;
+    else
+      m_platform_sdk_path.clear();
+  }
+
+  const char *GetResourceDir() const {
+    if (m_resource_dir.empty())
+      return NULL;
+    return m_resource_dir.c_str();
+  }
+
+  void SetResourceDir(const char *path) {
+    if (path)
+      m_resource_dir = path;
+    else
+      m_resource_dir.clear();
+  }
+
+  size_t GetNumModuleSearchPaths() const;
+
+  const char *GetModuleSearchPathAtIndex(size_t idx) const;
+
+  size_t GetNumFrameworkSearchPaths() const;
+
+  const char *GetFrameworkSearchPathAtIndex(size_t idx) const;
+
+  size_t GetNumClangArguments();
+
+  const char *GetClangArgumentAtIndex(size_t idx);
+
+  swift::ModuleDecl *CreateModule(const ConstString &module_basename,
+                                  Status &error);
+
+  // This function should only be called when all search paths
+  // for all items in a swift::ASTContext have been setup to
+  // allow for imports to happen correctly. Use with caution,
+  // or use the GetModule() call that takes a FileSpec.
+  swift::ModuleDecl *GetModule(const ConstString &module_name, Status &error);
+
+  swift::ModuleDecl *GetModule(const FileSpec &module_spec, Status &error);
+
+  void CacheModule(swift::ModuleDecl *module);
+
+  // Call this after the search paths are set up, it will find the module given
+  // by module, load the module into the AST context, and also load any
+  // "LinkLibraries" that the module requires.
+
+  swift::ModuleDecl *FindAndLoadModule(const ConstString &module_basename,
+                                       Process &process, Status &error);
+
+  swift::ModuleDecl *FindAndLoadModule(const FileSpec &module_spec,
+                                       Process &process, Status &error);
+
+  void LoadModule(swift::ModuleDecl *swift_module, Process &process,
+                  Status &error);
+
+  bool RegisterSectionModules(Module &module,
+                              std::vector<std::string> &module_names);
+
+  void ValidateSectionModules(Module &module, // this is used to print errors
+                              const std::vector<std::string> &module_names);
+
+  // Swift modules that are backed by dylibs (libFoo.dylib) rather than
+  // frameworks don't actually record the library dependencies in the module.
+  // This will hand load any libraries that are on the IRGen LinkLibraries list
+  // using the compiler's search paths.
+  // It doesn't do frameworks since frameworks don't need it and this is kind of
+  // a hack anyway.
+
+  void LoadExtraDylibs(Process &process, Status &error);
+
+  swift::Identifier GetIdentifier(const char *name);
+
+  swift::Identifier GetIdentifier(const llvm::StringRef &name);
+
+  // Find a type by a fully qualified name that includes the module name
+  // (the format being "<module_name>.<type_name>").
+  CompilerType FindQualifiedType(const char *qualified_name);
+
+  CompilerType FindType(const char *name, swift::ModuleDecl *swift_module);
+
+  llvm::Optional<SwiftASTContext::TypeOrDecl>
+  FindTypeOrDecl(const char *name, swift::ModuleDecl *swift_module);
+
+  size_t FindTypes(const char *name, swift::ModuleDecl *swift_module,
+                   std::set<CompilerType> &results, bool append = true);
+
+  size_t FindTypesOrDecls(const char *name, swift::ModuleDecl *swift_module,
+                          TypesOrDecls &results, bool append = true);
+
+  size_t FindContainedType(llvm::StringRef name, CompilerType container_type,
+                           std::set<CompilerType> &results, bool append = true);
+
+  size_t FindContainedTypeOrDecl(llvm::StringRef name,
+                                 TypeOrDecl container_type_or_decl,
+                                 TypesOrDecls &results, bool append = true);
+
+  size_t FindType(const char *name, std::set<CompilerType> &results,
+                  bool append = true);
+
+  CompilerType FindFirstType(const char *name, const ConstString &module_name);
+
+  CompilerType GetTypeFromMangledTypename(const char *mangled_typename,
+                                          Status &error);
+
+  // Get a function type that returns nothing and take no parameters
+  CompilerType GetVoidFunctionType();
+
+  static SwiftASTContext *GetSwiftASTContext(swift::ASTContext *ast);
+
+  swift::irgen::IRGenerator &GetIRGenerator(swift::IRGenOptions &opts,
+                                            swift::SILModule &module);
+
+  swift::irgen::IRGenModule &GetIRGenModule();
+
+  std::string GetTriple() const;
+
+  bool SetTriple(const char *triple, lldb_private::Module *module = NULL);
+
+  uint32_t GetPointerBitAlignment();
+
+  // Imports the type from the passed in type into this SwiftASTContext. The
+  // type must be a Swift type. If the type can be imported, returns the
+  // CompilerType for the imported type.
+  // If it cannot be, returns an invalid CompilerType, and sets the error to
+  // indicate what went wrong.
+  CompilerType ImportType(CompilerType &type, Status &error);
+
+  swift::ClangImporter *GetClangImporter();
+
+  // ***********************************************************
+  //  these calls create non-nominal types which are given in
+  //  metadata just in terms of their building blocks and for
+  //  which there is no one basic type to compose from
+  // ***********************************************************
+  CompilerType CreateTupleType(const std::vector<CompilerType> &elements);
+
+  struct TupleElement {
+    ConstString element_name;
+    CompilerType element_type;
+  };
+
+  CompilerType CreateTupleType(const std::vector<TupleElement> &elements);
+
+  CompilerType CreateFunctionType(CompilerType arg_type, CompilerType ret_type,
+                                  bool throws = false);
+
+  CompilerType GetErrorType();
+
+  CompilerType GetNSErrorType(Status &error);
+
+  CompilerType CreateMetatypeType(CompilerType instance_type);
+
+  bool HasErrors();
+
+  // NEVER call this without checking HasFatalErrors() first.
+  // This clears the fatal-error state which is terrible.
+  // We will assert if you clear an actual fatal error.
+  void ClearDiagnostics();
+
+  bool SetColorizeDiagnostics(bool b);
+
+  void PrintDiagnostics(DiagnosticManager &diagnostic_manager,
+                        uint32_t bufferID = UINT32_MAX, uint32_t first_line = 0,
+                        uint32_t last_line = UINT32_MAX,
+                        uint32_t line_offset = 0);
+
+  ConstString GetMangledTypeName(swift::TypeBase *);
+
+  swift::IRGenOptions &GetIRGenOptions();
+
+  void ModulesDidLoad(ModuleList &module_list);
+
+  void ClearModuleDependentCaches();
+
+  void DumpConfiguration(Log *log);
+
+  bool HasTarget() const;
+
+  bool CheckProcessChanged();
+
+  // FIXME: this should be removed once we figure out who should really own the
+  // DebuggerClient's that we are sticking into the Swift Modules.
+  void AddDebuggerClient(swift::DebuggerClient *debugger_client);
+
+  typedef llvm::DenseMap<const char *, swift::ModuleDecl *> SwiftModuleMap;
+
+  const SwiftModuleMap &GetModuleCache() { return m_swift_module_cache; }
+
+  static bool HasFatalErrors(swift::ASTContext *ast_context);
+
+  bool HasFatalErrors() const {
+    return m_fatal_errors.Fail() || HasFatalErrors(m_ast_context_ap.get());
+  }
+
+  Status GetFatalErrors();
+
+  union ExtraTypeInformation {
+    uint64_t m_intValue;
+    struct ExtraTypeInformationFlags {
+      ExtraTypeInformationFlags(bool is_trivial_option_set, bool is_zero_size)
+          : m_is_trivial_option_set(is_trivial_option_set),
+            m_is_zero_size(is_zero_size) {}
+
+      bool m_is_trivial_option_set : 1;
+      bool m_is_zero_size : 1;
+    } m_flags;
+
+    ExtraTypeInformation();
+
+    ExtraTypeInformation(swift::CanType);
+  };
+
+  const swift::irgen::TypeInfo *GetSwiftTypeInfo(void *type);
+
+  const swift::irgen::TypeInfo *GetSwiftTypeInfo(swift::Type container_type,
+                                                 swift::VarDecl *item_decl);
+
+  const swift::irgen::FixedTypeInfo *GetSwiftFixedTypeInfo(void *type);
+
+  DWARFASTParser *GetDWARFParser() override;
+
+  CompilerType GetIntTypeFromBitSize(size_t bit_size, bool is_signed);
+
+  CompilerType GetFloatTypeFromBitSize(size_t bit_size);
+
+  //----------------------------------------------------------------------
+  // CompilerDecl functions
+  //----------------------------------------------------------------------
+  ConstString DeclGetName(void *opaque_decl) override {
+    return ConstString("");
+  }
+
+  //----------------------------------------------------------------------
+  // CompilerDeclContext functions
+  //----------------------------------------------------------------------
+
+  std::vector<CompilerDecl>
+  DeclContextFindDeclByName(void *opaque_decl_ctx, ConstString name,
+                            const bool ignore_imported_decls) override {
+    return {};
+  }
+
+  bool DeclContextIsStructUnionOrClass(void *opaque_decl_ctx) override;
+
+  ConstString DeclContextGetName(void *opaque_decl_ctx) override;
+
+  ConstString DeclContextGetScopeQualifiedName(void *opaque_decl_ctx) override;
+
+  bool DeclContextIsClassMethod(void *opaque_decl_ctx,
+                                lldb::LanguageType *language_ptr,
+                                bool *is_instance_method_ptr,
+                                ConstString *language_object_name_ptr) override;
+
+  //----------------------------------------------------------------------
+  // Tests
+  //----------------------------------------------------------------------
+
+  bool IsArrayType(void *type, CompilerType *element_type, uint64_t *size,
+                   bool *is_incomplete) override;
+
+  bool IsAggregateType(void *type) override;
+
+  bool IsCharType(void *type) override;
+
+  bool IsCompleteType(void *type) override;
+
+  bool IsDefined(void *type) override;
+
+  bool IsFloatingPointType(void *type, uint32_t &count,
+                           bool &is_complex) override;
+
+  bool IsFunctionType(void *type, bool *is_variadic_ptr) override;
+
+  size_t GetNumberOfFunctionArguments(void *type) override;
+
+  CompilerType GetFunctionArgumentAtIndex(void *type,
+                                          const size_t index) override;
+
+  bool IsFunctionPointerType(void *type) override;
+
+  bool IsBlockPointerType(void *type,
+                          CompilerType *function_pointer_type_ptr) override;
+
+  bool IsIntegerType(void *type, bool &is_signed) override;
+
+  bool IsPossibleDynamicType(void *type,
+                             CompilerType *target_type, // Can pass NULL
+                             bool check_cplusplus, bool check_objc,
+                             bool check_swift) override;
+
+  bool IsPointerType(void *type, CompilerType *pointee_type) override;
+
+  bool IsScalarType(void *type) override;
+
+  bool IsVoidType(void *type) override;
+
+  static bool IsArchetypeType(const CompilerType &compiler_type);
+
+  static bool IsSelfArchetypeType(const CompilerType &compiler_type);
+
+  static bool IsPossibleZeroSizeType(const CompilerType &compiler_type);
+
+  bool IsTrivialOptionSetType(const CompilerType &compiler_type);
+
+  bool IsErrorType(const CompilerType &compiler_type);
+
+  static bool IsFullyRealized(const CompilerType &compiler_type);
+
+  struct ProtocolInfo {
+    uint32_t m_num_protocols;
+    uint32_t m_num_payload_words;
+    uint32_t m_num_storage_words;
+    bool m_is_class_only;
+    bool m_is_objc;
+    bool m_is_anyobject;
+    bool m_is_errortype;
+  };
+
+  static bool GetProtocolTypeInfo(const CompilerType &type,
+                                  ProtocolInfo &protocol_info);
+
+  static bool IsOptionalChain(CompilerType type, CompilerType &payload_type,
+                              uint32_t &depth);
+
+  enum class TypeAllocationStrategy { eInline, ePointer, eDynamic, eUnknown };
+
+  static TypeAllocationStrategy GetAllocationStrategy(const CompilerType &type);
+
+  enum class NonTriviallyManagedReferenceStrategy {
+    eWeak,
+    eUnowned,
+    eUnmanaged
+  };
+
+  static bool IsNonTriviallyManagedReferenceType(
+      const CompilerType &type, NonTriviallyManagedReferenceStrategy &strategy,
+      CompilerType *underlying_type = nullptr);
+
+  bool IsObjCObjectPointerType(const CompilerType &type,
+                               CompilerType *class_type_ptr);
+
+  //----------------------------------------------------------------------
+  // Type Completion
+  //----------------------------------------------------------------------
+
+  bool GetCompleteType(void *type) override;
+
+  //----------------------------------------------------------------------
+  // AST related queries
+  //----------------------------------------------------------------------
+
+  uint32_t GetPointerByteSize() override;
+
+  //----------------------------------------------------------------------
+  // Accessors
+  //----------------------------------------------------------------------
+
+  ConstString GetTypeName(void *type) override;
+
+  ConstString GetDisplayTypeName(void *type) override;
+
+  ConstString GetTypeSymbolName(void *type) override;
+
+  ConstString GetMangledTypeName(void *type) override;
+
+  uint32_t GetTypeInfo(void *type,
+                       CompilerType *pointee_or_element_clang_type) override;
+
+  lldb::LanguageType GetMinimumLanguage(void *type) override;
+
+  lldb::TypeClass GetTypeClass(void *type) override;
+
+  //----------------------------------------------------------------------
+  // Creating related types
+  //----------------------------------------------------------------------
+
+  CompilerType GetArrayElementType(void *type, uint64_t *stride) override;
+
+  CompilerType GetCanonicalType(void *type) override;
+
+  CompilerType GetInstanceType(void *type) override;
+
+  // Returns -1 if this isn't a function of if the function doesn't have a
+  // prototype. Returns a value >override if there is a prototype.
+  int GetFunctionArgumentCount(void *type) override;
+
+  CompilerType GetFunctionArgumentTypeAtIndex(void *type, size_t idx) override;
+
+  CompilerType GetFunctionReturnType(void *type) override;
+
+  size_t GetNumMemberFunctions(void *type) override;
+
+  TypeMemberFunctionImpl GetMemberFunctionAtIndex(void *type,
+                                                  size_t idx) override;
+
+  CompilerType GetPointeeType(void *type) override;
+
+  CompilerType GetPointerType(void *type) override;
+
+  //----------------------------------------------------------------------
+  // Exploring the type
+  //----------------------------------------------------------------------
+
+  uint64_t GetBitSize(lldb::opaque_compiler_type_t type,
+                      ExecutionContextScope *exe_scope) override;
+
+  uint64_t GetByteStride(lldb::opaque_compiler_type_t type) override;
+
+  lldb::Encoding GetEncoding(void *type, uint64_t &count) override;
+
+  lldb::Format GetFormat(void *type) override;
+
+  uint32_t GetNumChildren(void *type, bool omit_empty_base_classes) override;
+
+  lldb::BasicType GetBasicTypeEnumeration(void *type) override;
+
+  uint32_t GetNumFields(void *type) override;
+
+  CompilerType GetFieldAtIndex(void *type, size_t idx, std::string &name,
+                               uint64_t *bit_offset_ptr,
+                               uint32_t *bitfield_bit_size_ptr,
+                               bool *is_bitfield_ptr) override;
+
+  CompilerType GetChildCompilerTypeAtIndex(
+      void *type, ExecutionContext *exe_ctx, size_t idx,
+      bool transparent_pointers, bool omit_empty_base_classes,
+      bool ignore_array_bounds, std::string &child_name,
+      uint32_t &child_byte_size, int32_t &child_byte_offset,
+      uint32_t &child_bitfield_bit_size, uint32_t &child_bitfield_bit_offset,
+      bool &child_is_base_class, bool &child_is_deref_of_parent,
+      ValueObject *valobj, uint64_t &language_flags) override;
+
+  // Lookup a child given a name. This function will match base class names
+  // and member names in "clang_type" only, not descendants.
+  uint32_t GetIndexOfChildWithName(void *type, const char *name,
+                                   bool omit_empty_base_classes) override;
+
+  // Lookup a child member given a name. This function will match member names
+  // only and will descend into "clang_type" children in search for the first
+  // member in this class, or any base class that matches "name".
+  // TODO: Return all matches for a given name by returning a
+  // vector<vector<uint32_t>> so we catch all names that match a given child
+  // name, not just the first.
+  size_t
+  GetIndexOfChildMemberWithName(void *type, const char *name,
+                                bool omit_empty_base_classes,
+                                std::vector<uint32_t> &child_indexes) override;
+
+  size_t GetNumTemplateArguments(void *type) override;
+
+  CompilerType GetTemplateArgument(void *type, size_t idx,
+                                   lldb::TemplateArgumentKind &kind) override;
+
+  CompilerType GetTypeForFormatters(void *type) override;
+
+  LazyBool ShouldPrintAsOneLiner(void *type, ValueObject *valobj) override;
+
+  bool IsMeaninglessWithoutDynamicResolution(void *type) override;
+
+  static bool GetSelectedEnumCase(const CompilerType &type,
+                                  const DataExtractor &data, ConstString *name,
+                                  bool *has_payload, CompilerType *payload,
+                                  bool *is_indirect);
+
+  //----------------------------------------------------------------------
+  // Dumping types
+  //----------------------------------------------------------------------
+  void DumpValue(void *type, ExecutionContext *exe_ctx, Stream *s,
+                 lldb::Format format, const DataExtractor &data,
+                 lldb::offset_t data_offset, size_t data_byte_size,
+                 uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
+                 bool show_types, bool show_summary, bool verbose,
+                 uint32_t depth) override;
+
+  bool DumpTypeValue(void *type, Stream *s, lldb::Format format,
+                     const DataExtractor &data, lldb::offset_t data_offset,
+                     size_t data_byte_size, uint32_t bitfield_bit_size,
+                     uint32_t bitfield_bit_offset,
+                     ExecutionContextScope *exe_scope,
+                     bool is_base_class) override;
+
+  void DumpTypeDescription(void *type) override; // Dump to stdout
+
+  void DumpTypeDescription(void *type, Stream *s) override;
+
+  void DumpTypeDescription(void *type, bool print_help_if_available,
+                           bool print_extensions_if_available);
+
+  void DumpTypeDescription(void *type, Stream *s, bool print_help_if_available,
+                           bool print_extensions_if_available);
+
+  //----------------------------------------------------------------------
+  // TODO: These methods appear unused. Should they be removed?
+  //----------------------------------------------------------------------
+
+  bool IsRuntimeGeneratedType(void *type) override;
+
+  void DumpSummary(void *type, ExecutionContext *exe_ctx, Stream *s,
+                   const DataExtractor &data, lldb::offset_t data_offset,
+                   size_t data_byte_size) override;
+
+  // Converts "s" to a floating point value and place resulting floating
+  // point bytes in the "dst" buffer.
+  size_t ConvertStringToFloatValue(void *type, const char *s, uint8_t *dst,
+                                   size_t dst_size) override;
+
+  //----------------------------------------------------------------------
+  // TODO: Determine if these methods should move to ClangASTContext.
+  //----------------------------------------------------------------------
+
+  bool IsPointerOrReferenceType(void *type,
+                                CompilerType *pointee_type) override;
+
+  unsigned GetTypeQualifiers(void *type) override;
+
+  bool IsCStringType(void *type, uint32_t &length) override;
+
+  size_t GetTypeBitAlign(void *type) override;
+
+  CompilerType GetBasicTypeFromAST(lldb::BasicType basic_type) override;
+
+  CompilerType GetBuiltinTypeForEncodingAndBitSize(lldb::Encoding encoding,
+                                                   size_t bit_size) override {
+    return CompilerType();
+  }
+
+  bool IsBeingDefined(void *type) override;
+
+  bool IsConst(void *type) override;
+
+  uint32_t IsHomogeneousAggregate(void *type,
+                                  CompilerType *base_type_ptr) override;
+
+  bool IsPolymorphicClass(void *type) override;
+
+  bool IsTypedefType(void *type) override;
+
+  // If the current object represents a typedef type, get the underlying type
+  CompilerType GetTypedefedType(void *type) override;
+
+  CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) override;
+
+  bool IsVectorType(void *type, CompilerType *element_type,
+                    uint64_t *size) override;
+
+  CompilerType GetFullyUnqualifiedType(void *type) override;
+
+  CompilerType GetNonReferenceType(void *type) override;
+
+  CompilerType GetLValueReferenceType(void *type) override;
+
+  CompilerType GetRValueReferenceType(void *opaque_type) override;
+
+  uint32_t GetNumDirectBaseClasses(void *opaque_type) override;
+
+  uint32_t GetNumVirtualBaseClasses(void *opaque_type) override;
+
+  CompilerType GetDirectBaseClassAtIndex(void *opaque_type, size_t idx,
+                                         uint32_t *bit_offset_ptr) override;
+
+  CompilerType GetVirtualBaseClassAtIndex(void *opaque_type, size_t idx,
+                                          uint32_t *bit_offset_ptr) override;
+
+  bool IsReferenceType(void *type, CompilerType *pointee_type,
+                       bool *is_rvalue) override;
+
+  static bool IsInoutType(const CompilerType &compiler_type,
+                          CompilerType *original_type);
+
+  bool
+  ShouldTreatScalarValueAsAddress(lldb::opaque_compiler_type_t type) override;
+
+  uint32_t GetNumPointeeChildren(void *type);
+
+  static bool IsImportedType(const CompilerType &type,
+                             CompilerType *original_type);
+
+  static bool IsImportedObjectiveCType(const CompilerType &type,
+                                       CompilerType *original_type);
+
+  CompilerType GetReferentType(const CompilerType &compiler_type);
+
+  lldb::TypeSP GetCachedType(const ConstString &mangled);
+
+  void SetCachedType(const ConstString &mangled, const lldb::TypeSP &type_sp);
+
+protected:
+  // This map uses the string value of ConstStrings as the key, and the TypeBase
+  // * as the value. Since the ConstString strings are uniqued, we can use
+  // pointer equality for string value equality.
+  typedef llvm::DenseMap<const char *, swift::TypeBase *>
+      SwiftTypeFromMangledNameMap;
+  // Similar logic applies to this "reverse" map
+  typedef llvm::DenseMap<swift::TypeBase *, const char *>
+      SwiftMangledNameFromTypeMap;
+
+  llvm::TargetOptions *getTargetOptions();
+
+  swift::ModuleDecl *GetScratchModule();
+
+  swift::SILModule *GetSILModule();
+
+  swift::SerializedModuleLoader *GetSerializeModuleLoader();
+
+  swift::ModuleDecl *GetCachedModule(const ConstString &module_name);
+
+  void CacheDemangledType(const char *, swift::TypeBase *);
+
+  void CacheDemangledTypeFailure(const char *);
+
+  bool LoadOneImage(Process &process, FileSpec &link_lib_spec, Status &error);
+
+  bool LoadLibraryUsingPaths(Process &process, llvm::StringRef library_name,
+                             std::vector<std::string> &search_paths,
+                             bool check_rpath, StreamString &all_dlopen_errors);
+
+  bool TargetHasNoSDK();
+
+  std::vector<lldb::DataBufferSP> &GetASTVectorForModule(const Module *module);
+
+  std::unique_ptr<swift::SourceManager> m_source_manager_ap;
+  std::unique_ptr<swift::DiagnosticEngine> m_diagnostic_engine_ap;
+  std::unique_ptr<swift::ASTContext> m_ast_context_ap;
+  std::unique_ptr<llvm::TargetOptions> m_target_options_ap;
+  std::unique_ptr<swift::irgen::IRGenerator> m_ir_generator_ap;
+  std::unique_ptr<swift::irgen::IRGenModule> m_ir_gen_module_ap;
+  std::unique_ptr<swift::DiagnosticConsumer> m_diagnostic_consumer_ap;
+  std::unique_ptr<swift::CompilerInvocation> m_compiler_invocation_ap;
+  std::unique_ptr<DWARFASTParser> m_dwarf_ast_parser_ap;
+  Status m_error; // Any errors that were found while creating or using the AST
+                  // context
+  swift::ModuleDecl *m_scratch_module;
+  std::unique_ptr<swift::SILModule> m_sil_module_ap;
+  swift::SerializedModuleLoader *m_serialized_module_loader; // Owned by the AST
+  swift::ClangImporter *m_clang_importer;
+  SwiftModuleMap m_swift_module_cache;
+  SwiftTypeFromMangledNameMap m_mangled_name_to_type_map;
+  SwiftMangledNameFromTypeMap m_type_to_mangled_name_map;
+  uint32_t m_pointer_byte_size;
+  uint32_t m_pointer_bit_align;
+  CompilerType m_void_function_type;
+  lldb::TargetWP m_target_wp; // Only if this AST belongs to a target will this
+                              // contain a valid target weak pointer
+  lldb_private::Process *m_process; // Only if this AST belongs to a target, and
+                                    // an expression has been evaluated will the
+                                    // target's process pointer be filled in
+  std::string m_platform_sdk_path;
+  std::string m_resource_dir;
+  typedef std::map<Module *, std::vector<lldb::DataBufferSP>> ASTFileDataMap;
+  ASTFileDataMap m_ast_file_data_map;
+  // FIXME: this vector is needed because the LLDBNameLookup debugger clients
+  // are being put into the Module for the SourceFile that we compile the
+  // expression into, and so have to live as long as the Module. But it's too
+  // late to change swift to get it to take ownership of these DebuggerClients.
+  // Since we use the same Target SwiftASTContext for all our compilations,
+  // holding them here will keep them alive as long as we need.
+  std::vector<std::unique_ptr<swift::DebuggerClient>> m_debugger_clients;
+  bool m_initialized_language_options;
+  bool m_initialized_search_path_options;
+  bool m_initialized_clang_importer_options;
+  bool m_reported_fatal_error;
+  Status m_fatal_errors;
+
+  typedef ThreadSafeDenseSet<const char *> SwiftMangledNameSet;
+  SwiftMangledNameSet m_negative_type_cache;
+
+  typedef ThreadSafeDenseMap<void *, ExtraTypeInformation>
+      ExtraTypeInformationMap;
+  ExtraTypeInformationMap m_extra_type_info_cache;
+
+  typedef ThreadSafeDenseMap<const char *, lldb::TypeSP> SwiftTypeMap;
+  SwiftTypeMap m_swift_type_map;
+
+  ExtraTypeInformation GetExtraTypeInformation(void *type);
+
+  CachedMemberInfo *GetCachedMemberInfo(void *type);
+
+  SwiftEnumDescriptor *GetCachedEnumInfo(void *type);
+
+  friend class CompilerType;
+};
+
+class SwiftASTContextForExpressions : public SwiftASTContext {
+public:
+  SwiftASTContextForExpressions(Target &target);
+
+  virtual ~SwiftASTContextForExpressions() {}
+
+  UserExpression *
+  GetUserExpression(llvm::StringRef expr, llvm::StringRef prefix,
+                    lldb::LanguageType language,
+                    Expression::ResultType desired_type,
+                    const EvaluateExpressionOptions &options) override;
+
+  PersistentExpressionState *GetPersistentExpressionState() override;
+
+private:
+  std::unique_ptr<SwiftPersistentExpressionState> m_persistent_state_up;
+};
+} // namespace lldb_private
+
+#endif // #ifndef liblldb_SwiftASTContext_h_
diff --git a/include/lldb/Symbol/SwiftMangledNameVisitor.h b/include/lldb/Symbol/SwiftMangledNameVisitor.h
index e69de29bb..433310b1b 100644
--- a/include/lldb/Symbol/SwiftMangledNameVisitor.h
+++ b/include/lldb/Symbol/SwiftMangledNameVisitor.h
@@ -0,0 +1,35 @@
+//===-- SwiftMangledNameVisitor.h -------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftMangledNameVisitor_h_
+#define liblldb_SwiftMangledNameVisitor_h_
+
+#include "swift/Demangling/Demangle.h"
+
+namespace lldb_private {
+class SwiftMangledNameVisitor {
+public:
+#define NODE(e)                                                                \
+  virtual void visit##e(swift::Demangle::NodePointer pointer);                 \
+  void accept##e(swift::Demangle::NodePointer cur_node);
+#include "swift/Demangling/DemangleNodes.def"
+
+  virtual ~SwiftMangledNameVisitor() {}
+
+  void visit(const char *mangled_name);
+
+private:
+  void accept(swift::Demangle::NodePointer pointer);
+};
+} // namespace lldb_private
+
+#endif // #ifndef liblldb_SwiftMangledNameVisitor_h_
diff --git a/include/lldb/Symbol/Symbol.h b/include/lldb/Symbol/Symbol.h
index 44c67f6f4..998b6a500 100644
--- a/include/lldb/Symbol/Symbol.h
+++ b/include/lldb/Symbol/Symbol.h
@@ -47,7 +47,9 @@ public:
 
   bool Compare(const ConstString &name, lldb::SymbolType type) const;
 
-  void Dump(Stream *s, Target *target, uint32_t index) const;
+  void Dump(Stream *s, Target *target, uint32_t index,
+            Mangled::NamePreference name_preference =
+                Mangled::ePreferDemangled) const;
 
   bool ValueIsAddress() const;
 
diff --git a/include/lldb/Symbol/SymbolFile.h b/include/lldb/Symbol/SymbolFile.h
index 69110dc68..cef1dc068 100644
--- a/include/lldb/Symbol/SymbolFile.h
+++ b/include/lldb/Symbol/SymbolFile.h
@@ -10,6 +10,8 @@
 #ifndef liblldb_SymbolFile_h_
 #define liblldb_SymbolFile_h_
 
+#include <vector>
+
 #include "lldb/Core/PluginInterface.h"
 #include "lldb/Symbol/CompilerDecl.h"
 #include "lldb/Symbol/CompilerDeclContext.h"
@@ -200,10 +202,76 @@ public:
   //------------------------------------------------------------------
   virtual void SectionFileAddressesChanged() {}
 
+  virtual bool GetCompileOption(const char *option, std::string &value,
+                                CompileUnit *cu = nullptr) {
+    value.clear();
+    return false;
+  }
+
+  virtual int GetCompileOptions(const char *option,
+                                std::vector<std::string> &values,
+                                CompileUnit *cu = nullptr) {
+    values.clear();
+    return false;
+  }
+
+  virtual void GetLoadedModules(lldb::LanguageType language,
+                                FileSpecList &modules) {}
+
+  //------------------------------------------------------------------
+  // Some symbol files might know if we should always check for inline
+  // source file and line entries. This virtual function lets
+  // SymbolFile subclasses control that, but a default implementation
+  // is supplied.
+  //------------------------------------------------------------------
+  virtual bool ForceInlineSourceFileCheck();
+
+  //------------------------------------------------------------------
+  /// Retrieve all the AST data blobs from the SymbolFile.
+  ///
+  /// Symbol files can store AST data for any language that wants to
+  /// store the native AST format supported by the current compiler.
+  /// This information is often only usable by a compiler that is in
+  /// sync with the compiler sources that were used to build LLDB so
+  /// any data should be versioned appropriately so the compiler can
+  /// try to load the data and know if the data will be able to be
+  /// used.
+  ///
+  /// @param[in] language
+  ///   The language for which AST data is being requested.
+  ///   A given file can contain ASTs for more than one language.
+  ///
+  /// @return
+  ///   Zero or more buffers, each of which contain the raw data
+  ///   of an AST in the requested language.
+  //------------------------------------------------------------------
+  virtual std::vector<lldb::DataBufferSP>
+  GetASTData(lldb::LanguageType language);
+
+  // Used for the REPL to limit source file ranges that are valid within "file".
+  // Since
+  // breakpoint setting call fall through, we need to stop the fall through from
+  // happening
+  virtual bool SetLimitSourceFileRange(const FileSpec &file,
+                                       uint32_t first_line, uint32_t last_line);
+
+  virtual bool SymbolContextShouldBeExcluded(const SymbolContext &sc,
+                                             uint32_t actual_line);
+
 protected:
+  class SourceRange {
+  public:
+    SourceRange(const FileSpec &f, uint32_t first, uint32_t last)
+        : file(f), first_line(first), last_line(last) {}
+    FileSpec file;
+    uint32_t first_line;
+    uint32_t last_line;
+  };
+
   ObjectFile *m_obj_file; // The object file that symbols can be extracted from.
   uint32_t m_abilities;
   bool m_calculated_abilities;
+  std::vector<SourceRange> m_limit_source_ranges;
 
 private:
   DISALLOW_COPY_AND_ASSIGN(SymbolFile);
diff --git a/include/lldb/Symbol/SymbolVendor.h b/include/lldb/Symbol/SymbolVendor.h
index 7db3de6e6..6ca6cd3cf 100644
--- a/include/lldb/Symbol/SymbolVendor.h
+++ b/include/lldb/Symbol/SymbolVendor.h
@@ -136,6 +136,14 @@ public:
   // Clear module unified section list symbol table.
   virtual void ClearSymtab();
 
+  bool GetCompileOption(const char *option, std::string &value,
+                        CompileUnit *cu = nullptr);
+
+  int GetCompileOptions(const char *option, std::vector<std::string> &values,
+                        CompileUnit *cu = nullptr);
+
+  void GetLoadedModules(lldb::LanguageType language, FileSpecList &modules);
+
   //------------------------------------------------------------------
   /// Notify the SymbolVendor that the file addresses in the Sections
   /// for this module have been changed.
@@ -149,6 +157,17 @@ public:
 
   uint32_t GetPluginVersion() override;
 
+  virtual bool SetLimitSourceFileRange(const FileSpec &file,
+                                       uint32_t first_line, uint32_t last_line);
+
+  virtual bool SymbolContextShouldBeExcluded(const SymbolContext &sc,
+                                             uint32_t actual_line);
+
+  virtual std::vector<lldb::DataBufferSP>
+  GetASTData(lldb::LanguageType language);
+
+  virtual bool ForceInlineSourceFileCheck();
+
 protected:
   //------------------------------------------------------------------
   // Classes that inherit from SymbolVendor can see and modify these
diff --git a/include/lldb/Symbol/Symtab.h b/include/lldb/Symbol/Symtab.h
index 3d24862af..472d3d043 100644
--- a/include/lldb/Symbol/Symtab.h
+++ b/include/lldb/Symbol/Symtab.h
@@ -45,9 +45,13 @@ public:
   Symbol *Resize(size_t count);
   uint32_t AddSymbol(const Symbol &symbol);
   size_t GetNumSymbols() const;
+  void
+  Dump(Stream *s, Target *target, SortOrder sort_type,
+       Mangled::NamePreference name_preference = Mangled::ePreferDemangled);
+  void Dump(Stream *s, Target *target, std::vector<uint32_t> &indexes,
+            Mangled::NamePreference name_preference =
+                Mangled::ePreferDemangled) const;
   void SectionFileAddressesChanged();
-  void Dump(Stream *s, Target *target, SortOrder sort_type);
-  void Dump(Stream *s, Target *target, std::vector<uint32_t> &indexes) const;
   uint32_t GetIndexForSymbol(const Symbol *symbol) const;
   std::recursive_mutex &GetMutex() { return m_mutex; }
   Symbol *FindSymbolByID(lldb::user_id_t uid) const;
diff --git a/include/lldb/Symbol/Type.h b/include/lldb/Symbol/Type.h
index 9740dc25a..bbe78176f 100644
--- a/include/lldb/Symbol/Type.h
+++ b/include/lldb/Symbol/Type.h
@@ -369,6 +369,9 @@ protected:
 // the two classes here are used by the public API as a backend to
 // the SBType and SBTypeList classes
 
+// the two classes here are used by the public API as a backend to
+// the SBType and SBTypeList classes
+
 class TypeImpl {
 public:
   TypeImpl();
diff --git a/include/lldb/Symbol/TypeSystem.h b/include/lldb/Symbol/TypeSystem.h
index b4f84c0dd..cb71d3e19 100644
--- a/include/lldb/Symbol/TypeSystem.h
+++ b/include/lldb/Symbol/TypeSystem.h
@@ -91,7 +91,8 @@ public:
                                            Module *module);
 
   static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,
-                                           Target *target);
+                                           Target *target,
+                                           const char *compiler_options);
 
   // Free up any resources associated with this TypeSystem.  Done before
   // removing
@@ -187,7 +188,8 @@ public:
 
   virtual bool IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                                      CompilerType *target_type, // Can pass NULL
-                                     bool check_cplusplus, bool check_objc) = 0;
+                                     bool check_cplusplus, bool check_objc,
+                                     bool check_swift) = 0;
 
   virtual bool IsPointerType(lldb::opaque_compiler_type_t type,
                              CompilerType *pointee_type) = 0;
@@ -199,6 +201,17 @@ public:
   // TypeSystems can support more than one language
   virtual bool SupportsLanguage(lldb::LanguageType language) = 0;
 
+  //----------------------------------------------------------------------
+  // Check if the current module or target that was used to create this
+  // type system is compatible with the TypeSystem plug-in.
+  //
+  // Sometimes as languages are being developed the language can change
+  // and the version of the runtime information in a module is out of date
+  // with this type system. For such cases, languages can check and return
+  // an error.
+  //----------------------------------------------------------------------
+  virtual Status IsCompatible();
+
   //----------------------------------------------------------------------
   // Type Completion
   //----------------------------------------------------------------------
@@ -217,6 +230,18 @@ public:
 
   virtual ConstString GetTypeName(lldb::opaque_compiler_type_t type) = 0;
 
+  // Defaults to GetTypeName(type).  Override if your language desires
+  // specialized behavior.
+  virtual ConstString GetDisplayTypeName(lldb::opaque_compiler_type_t type);
+
+  // Defaults to GetTypeName(type).  Override if your language desires
+  // specialized behavior.
+  virtual ConstString GetTypeSymbolName(lldb::opaque_compiler_type_t type);
+
+  // Defaults to GetTypeName(type).  Override if your language desires
+  // specialized behavior.
+  virtual ConstString GetMangledTypeName(lldb::opaque_compiler_type_t type);
+
   virtual uint32_t
   GetTypeInfo(lldb::opaque_compiler_type_t type,
               CompilerType *pointee_or_element_compiler_type) = 0;
@@ -238,6 +263,8 @@ public:
 
   virtual CompilerType GetCanonicalType(lldb::opaque_compiler_type_t type) = 0;
 
+  virtual CompilerType GetInstanceType(lldb::opaque_compiler_type_t type) = 0;
+
   // Returns -1 if this isn't a function of if the function doesn't have a
   // prototype
   // Returns a value >= 0 if there is a prototype.
@@ -282,6 +309,8 @@ public:
   virtual uint64_t GetBitSize(lldb::opaque_compiler_type_t type,
                               ExecutionContextScope *exe_scope) = 0;
 
+  virtual uint64_t GetByteStride(lldb::opaque_compiler_type_t type) = 0;
+
   virtual lldb::Encoding GetEncoding(lldb::opaque_compiler_type_t type,
                                      uint64_t &count) = 0;
 
@@ -372,7 +401,8 @@ public:
                              lldb::offset_t data_offset, size_t data_byte_size,
                              uint32_t bitfield_bit_size,
                              uint32_t bitfield_bit_offset,
-                             ExecutionContextScope *exe_scope) = 0;
+                             ExecutionContextScope *exe_scope,
+                             bool is_base_class) = 0;
 
   virtual void
   DumpTypeDescription(lldb::opaque_compiler_type_t type) = 0; // Dump to stdout
@@ -432,6 +462,8 @@ public:
   // If the current object represents a typedef type, get the underlying type
   virtual CompilerType GetTypedefedType(lldb::opaque_compiler_type_t type) = 0;
 
+  virtual CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) = 0;
+
   virtual bool IsVectorType(lldb::opaque_compiler_type_t type,
                             CompilerType *element_type, uint64_t *size) = 0;
 
@@ -505,8 +537,13 @@ protected:
 class TypeSystemMap {
 public:
   TypeSystemMap();
+  TypeSystemMap(const TypeSystemMap &rhs);
   ~TypeSystemMap();
 
+  // Clear calls Finalize on all the TypeSystems managed by this map, and then
+  // empties the map.
+  void operator=(const TypeSystemMap &rhs);
+
   // Clear calls Finalize on all the TypeSystems managed by this map, and then
   // empties the map.
   void Clear();
@@ -519,7 +556,10 @@ public:
                                        Module *module, bool can_create);
 
   TypeSystem *GetTypeSystemForLanguage(lldb::LanguageType language,
-                                       Target *target, bool can_create);
+                                       Target *target, bool can_create,
+                                       const char *compiler_options);
+
+  void RemoveTypeSystemsForLanguage(lldb::LanguageType language);
 
 protected:
   // This function does not take the map mutex, and should only be called from
diff --git a/include/lldb/Target/LanguageRuntime.h b/include/lldb/Target/LanguageRuntime.h
index 98db94166..75f1a6575 100644
--- a/include/lldb/Target/LanguageRuntime.h
+++ b/include/lldb/Target/LanguageRuntime.h
@@ -128,6 +128,11 @@ public:
                               bool throw_bp);
   Process *GetProcess() { return m_process; }
 
+  static lldb::LanguageType
+  GuessLanguageForSymbolByName(Target &target, const char *symbol_name);
+
+  virtual bool IsSymbolARuntimeThunk(const Symbol &symbol) { return false; }
+
   Target &GetTargetRef() { return m_process->GetTarget(); }
 
   virtual lldb::BreakpointResolverSP
@@ -160,6 +165,9 @@ public:
     return false;
   }
 
+  static bool
+  IsSymbolAnyRuntimeThunk(lldb::ProcessSP process, Symbol &symbol);
+
 protected:
   //------------------------------------------------------------------
   // Classes that inherit from LanguageRuntime can see and modify these
diff --git a/include/lldb/Target/Process.h b/include/lldb/Target/Process.h
index df0957005..e5c681e43 100644
--- a/include/lldb/Target/Process.h
+++ b/include/lldb/Target/Process.h
@@ -534,7 +534,7 @@ public:
   //------------------------------------------------------------------
   /// Process warning types.
   //------------------------------------------------------------------
-  enum Warnings { eWarningsOptimization = 1 };
+  enum Warnings { eWarningsOptimization = 1, eWarningsCantLoadSwift };
 
   typedef Range<lldb::addr_t, lldb::addr_t> LoadRange;
   // We use a read/write lock to allow on or more clients to
@@ -1594,6 +1594,21 @@ public:
   //------------------------------------------------------------------
   void PrintWarningOptimization(const SymbolContext &sc);
 
+  //------------------------------------------------------------------
+  /// Print a user-visible warning about a module having Swift settings
+  /// incompatible with the current system
+  ///
+  /// Prints a async warning message to the user one time per Process for a
+  /// Module
+  /// whose Swift AST sections couldn't be loaded because they aren't buildable
+  /// on
+  /// the current machine.
+  ///
+  /// @param [in] module
+  ///     The affected Module.
+  //------------------------------------------------------------------
+  void PrintWarningCantLoadSwift(const Module &module);
+
   virtual bool GetProcessInfo(ProcessInstanceInfo &info);
 
 public:
@@ -2462,13 +2477,19 @@ public:
   ///     the process
   ///     needs to have its process IOHandler popped.
   ///
+  /// @param[out] pop_command_interpreter
+  ///     This variable will be set to \b true or \b false ot indicate if the
+  ///     process needs
+  ///     to have its command interpreter popped.
+  ///
   /// @return
   ///     \b true if the event describes a process state changed event, \b false
   ///     otherwise.
   //--------------------------------------------------------------------------------------
   static bool HandleProcessStateChangedEvent(const lldb::EventSP &event_sp,
                                              Stream *stream,
-                                             bool &pop_process_io_handler);
+                                             bool &pop_process_io_handler,
+                                             bool &pop_command_interpreter);
 
   Event *PeekAtStateChangedEvents();
 
@@ -2526,6 +2547,9 @@ public:
   virtual ObjCLanguageRuntime *
   GetObjCLanguageRuntime(bool retry_if_null = true);
 
+  virtual SwiftLanguageRuntime *
+  GetSwiftLanguageRuntime(bool retry_if_null = true);
+
   bool IsPossibleDynamicValue(ValueObject &in_value);
 
   bool IsRunning() const;
@@ -3118,11 +3142,12 @@ protected:
   bool m_finalize_called; // This is set at the end of Process::Finalize()
   bool m_clear_thread_plans_on_stop;
   bool m_force_next_event_delivery;
+  bool m_destroy_in_process;
+  bool m_destroy_complete;
   lldb::StateType m_last_broadcast_state; /// This helps with the Public event
                                           /// coalescing in
                                           /// ShouldBroadcastEvent.
   std::map<lldb::addr_t, lldb::addr_t> m_resolved_indirect_addresses;
-  bool m_destroy_in_process;
   bool m_can_interpret_function_calls;  // Some targets, e.g the OSX kernel,
                                         // don't support the ability to modify
                                         // the stack.
@@ -3205,7 +3230,7 @@ protected:
 
   bool PushProcessIOHandler();
 
-  bool PopProcessIOHandler();
+  bool PopProcessIOHandler(bool pop_command_interpreter);
 
   bool ProcessIOHandlerIsActive();
 
diff --git a/include/lldb/Target/StopInfo.h b/include/lldb/Target/StopInfo.h
index c99877cbd..0b812a0fa 100644
--- a/include/lldb/Target/StopInfo.h
+++ b/include/lldb/Target/StopInfo.h
@@ -133,7 +133,8 @@ public:
   static lldb::StopInfoSP
   CreateStopReasonWithPlan(lldb::ThreadPlanSP &plan,
                            lldb::ValueObjectSP return_valobj_sp,
-                           lldb::ExpressionVariableSP expression_variable_sp);
+                           lldb::ExpressionVariableSP expression_variable_sp,
+                           bool return_is_swift_error_value = false);
 
   static lldb::StopInfoSP
   CreateStopReasonWithException(Thread &thread, const char *description);
@@ -141,7 +142,8 @@ public:
   static lldb::StopInfoSP CreateStopReasonWithExec(Thread &thread);
 
   static lldb::ValueObjectSP
-  GetReturnValueObject(lldb::StopInfoSP &stop_info_sp);
+  GetReturnValueObject(lldb::StopInfoSP &stop_info_sp,
+                       bool &is_swift_error_result);
 
   static lldb::ExpressionVariableSP
   GetExpressionVariable(lldb::StopInfoSP &stop_info_sp);
diff --git a/include/lldb/Target/SwiftLanguageRuntime.h b/include/lldb/Target/SwiftLanguageRuntime.h
index e69de29bb..214104883 100644
--- a/include/lldb/Target/SwiftLanguageRuntime.h
+++ b/include/lldb/Target/SwiftLanguageRuntime.h
@@ -0,0 +1,514 @@
+//===-- SwiftLanguageRuntime.h ----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftLanguageRuntime_h_
+#define liblldb_SwiftLanguageRuntime_h_
+
+// C Includes
+// C++ Includes
+#include <mutex>
+#include <tuple>
+#include <vector>
+// Other libraries and framework includes
+// Project includes
+#include "Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.h"
+#include "lldb/Core/PluginInterface.h"
+#include "lldb/Target/LanguageRuntime.h"
+#include "lldb/lldb-private.h"
+
+#include "llvm/ADT/Optional.h"
+#include "llvm/Support/Casting.h"
+
+namespace swift {
+namespace remote {
+class MemoryReader;
+class RemoteAddress;
+} // namespace remote
+namespace remoteAST {
+class RemoteASTContext;
+}
+enum class MetadataKind : uint32_t;
+class TypeBase;
+} // namespace swift
+
+namespace lldb_private {
+
+class SwiftLanguageRuntime : public LanguageRuntime {
+public:
+  class MetadataPromise;
+  typedef std::shared_ptr<MetadataPromise> MetadataPromiseSP;
+
+  class MemberVariableOffsetResolver;
+  typedef std::shared_ptr<MemberVariableOffsetResolver>
+      MemberVariableOffsetResolverSP;
+
+  //------------------------------------------------------------------
+  // Static Functions
+  //------------------------------------------------------------------
+  static void Initialize();
+
+  static void Terminate();
+
+  static lldb_private::LanguageRuntime *
+  CreateInstance(Process *process, lldb::LanguageType language);
+
+  static lldb_private::ConstString GetPluginNameStatic();
+
+  //------------------------------------------------------------------
+  // PluginInterface protocol
+  //------------------------------------------------------------------
+  lldb_private::ConstString GetPluginName() override;
+
+  uint32_t GetPluginVersion() override;
+
+  class MethodName {
+  public:
+    enum Type {
+      eTypeInvalid,
+      eTypeUnknownMethod,
+      eTypeClassMethod,
+      eTypeInstanceMethod,
+      eTypeOperator,
+      eTypeConstructor,
+      eTypeDestructor,
+      eTypeAllocator,
+      eTypeDeallocator
+    };
+
+    MethodName()
+        : m_full(), m_basename(), m_context(), m_arguments(), m_qualifiers(),
+          m_type(eTypeInvalid), m_parsed(false), m_parse_error(false) {}
+
+    MethodName(const ConstString &s, bool do_parse = false)
+        : m_full(s), m_basename(), m_context(), m_arguments(), m_qualifiers(),
+          m_type(eTypeInvalid), m_parsed(false), m_parse_error(false) {
+      if (do_parse)
+        Parse();
+    }
+
+    void Clear();
+
+    bool IsValid() const {
+      if (m_parse_error)
+        return false;
+      if (m_type == eTypeInvalid)
+        return false;
+      return (bool)m_full;
+    }
+
+    Type GetType() const { return m_type; }
+
+    const ConstString &GetFullName() const { return m_full; }
+
+    llvm::StringRef GetBasename();
+
+    llvm::StringRef GetContext();
+
+    llvm::StringRef GetMetatypeReference();
+
+    llvm::StringRef GetTemplateArguments();
+
+    llvm::StringRef GetArguments();
+
+    llvm::StringRef GetQualifiers();
+
+    llvm::StringRef GetReturnType();
+
+    static bool ExtractFunctionBasenameFromMangled(const ConstString &mangled,
+                                                   ConstString &basename,
+                                                   bool &is_method);
+
+  protected:
+    void Parse();
+
+    ConstString m_full;         // Full name:    "foo.bar.baz : <A : AProtocol>
+                                // (foo.bar.metatype)(x : Swift.Int64) -> A"
+    llvm::StringRef m_basename; // Basename:     "baz"
+    llvm::StringRef m_context;  // Decl context: "foo.bar"
+    llvm::StringRef m_metatype_ref;  // Meta type:    "(foo.bar.metatype)"
+    llvm::StringRef m_template_args; // Generic args: "<A: AProtocol>
+    llvm::StringRef m_arguments;     // Arguments:    "(x : Swift.Int64)"
+    llvm::StringRef m_qualifiers;    // Qualifiers:   "const"
+    llvm::StringRef m_return_type;   // Return type:  "A"
+    Type m_type;
+    bool m_parsed;
+    bool m_parse_error;
+  };
+
+  class MetadataPromise {
+    friend class SwiftLanguageRuntime;
+
+    MetadataPromise(swift::ASTContext *, SwiftLanguageRuntime *, lldb::addr_t);
+
+    swift::ASTContext *m_swift_ast;
+    std::unique_ptr<swift::remoteAST::RemoteASTContext> m_remote_ast;
+    SwiftLanguageRuntime *m_swift_runtime;
+    lldb::addr_t m_metadata_location;
+    llvm::Optional<swift::MetadataKind> m_metadata_kind;
+    llvm::Optional<CompilerType> m_compiler_type;
+
+  public:
+    CompilerType FulfillTypePromise(Status *error = nullptr);
+
+    llvm::Optional<swift::MetadataKind>
+    FulfillKindPromise(Status *error = nullptr);
+
+    bool IsStaticallyDetermined();
+  };
+
+  class MemberVariableOffsetResolver {
+    friend class SwiftLanguageRuntime;
+
+    MemberVariableOffsetResolver(swift::ASTContext *, SwiftLanguageRuntime *,
+                                 swift::TypeBase *);
+
+    swift::ASTContext *m_swift_ast;
+    std::unique_ptr<swift::remoteAST::RemoteASTContext> m_remote_ast;
+    SwiftLanguageRuntime *m_swift_runtime;
+    swift::TypeBase *m_swift_type;
+    std::unordered_map<const char *, uint64_t> m_offsets;
+
+  public:
+    llvm::Optional<uint64_t> ResolveOffset(ValueObject *valobj,
+                                           ConstString ivar_name,
+                                           Status * = nullptr);
+  };
+
+  class SwiftExceptionPrecondition : public Breakpoint::BreakpointPrecondition {
+  public:
+    SwiftExceptionPrecondition();
+
+    virtual ~SwiftExceptionPrecondition() {}
+
+    bool EvaluatePrecondition(StoppointCallbackContext &context) override;
+    void GetDescription(Stream &stream, lldb::DescriptionLevel level) override;
+    Status ConfigurePrecondition(Args &args) override;
+
+  protected:
+    void AddTypeName(const char *type_name);
+    void AddEnumSpec(const char *enum_name, const char *element_name);
+
+  private:
+    std::unordered_set<std::string> m_type_names;
+    std::unordered_map<std::string, std::vector<std::string>> m_enum_spec;
+  };
+
+  virtual ~SwiftLanguageRuntime();
+
+  virtual lldb::LanguageType GetLanguageType() const override {
+    return lldb::eLanguageTypeSwift;
+  }
+
+  void ModulesDidLoad(const ModuleList &module_list) override;
+
+  virtual bool GetObjectDescription(Stream &str, ValueObject &object) override;
+
+  virtual bool GetObjectDescription(Stream &str, Value &value,
+                                    ExecutionContextScope *exe_scope) override;
+
+  static std::string DemangleSymbolAsString(const char *symbol,
+                                            bool simplified = false);
+
+  static std::string DemangleSymbolAsString(const ConstString &symbol,
+                                            bool simplified = false);
+
+  // Use these passthrough functions rather than calling into Swift directly,
+  // since some day we may want to support more than one swift variant.
+  static bool IsSwiftMangledName(const char *name);
+
+  static bool IsSwiftClassName(const char *name);
+
+  static bool IsMetadataSymbol(const char *symbol);
+
+  static bool IsIvarOffsetSymbol(const char *symbol);
+
+  static const std::string GetCurrentMangledName(const char *mangled_name);
+
+  struct SwiftErrorDescriptor {
+  public:
+    struct SwiftBridgeableNativeError {
+    public:
+      lldb::addr_t metadata_location;
+      lldb::addr_t metadata_ptr_value;
+    };
+
+    struct SwiftPureNativeError {
+    public:
+      lldb::addr_t metadata_location;
+      lldb::addr_t witness_table_location;
+      lldb::addr_t payload_ptr;
+    };
+
+    struct SwiftNSError {
+    public:
+      lldb::addr_t instance_ptr_value;
+    };
+
+    enum class Kind {
+      eSwiftBridgeableNative,
+      eSwiftPureNative,
+      eBridged,
+      eNotAnError
+    };
+
+    Kind m_kind;
+    SwiftBridgeableNativeError m_bridgeable_native;
+    SwiftPureNativeError m_pure_native;
+    SwiftNSError m_bridged;
+
+    operator bool() { return m_kind != Kind::eNotAnError; }
+
+    SwiftErrorDescriptor();
+
+    SwiftErrorDescriptor(const SwiftErrorDescriptor &rhs) = default;
+  };
+
+  // provide a quick and yet somewhat reasonable guess as to whether
+  // this ValueObject represents something that validly conforms
+  // to the magic ErrorType protocol
+  virtual bool
+  IsValidErrorValue(ValueObject &in_value,
+                    SwiftErrorDescriptor *out_error_descriptor = nullptr);
+
+  virtual lldb::BreakpointResolverSP
+  CreateExceptionResolver(Breakpoint *bkpt, bool catch_bp,
+                          bool throw_bp) override;
+
+  SwiftExceptionPrecondition *GetExceptionPrecondition();
+
+  static lldb::ValueObjectSP
+  CalculateErrorValueFromFirstArgument(lldb::StackFrameSP frame_sp,
+                                       ConstString name);
+
+  lldb::ValueObjectSP CalculateErrorValueObjectFromValue(Value &value,
+                                                         ConstString name,
+                                                         bool persistent);
+
+  llvm::Optional<Value>
+  GetErrorReturnLocationAfterReturn(lldb::StackFrameSP frame_sp);
+
+  llvm::Optional<Value>
+  GetErrorReturnLocationBeforeReturn(lldb::StackFrameSP frame_sp,
+                                     bool &need_to_check_after_return);
+
+  static void RegisterGlobalError(Target &target, ConstString name,
+                                  lldb::addr_t addr);
+
+  // If you are at the initial instruction of the frame passed in, then this
+  // will examine the call
+  // arguments, and if any of them is a function pointer, this will push the
+  // address of the function
+  // into addresses.  If debug_only is true, then it will only push function
+  // pointers that are in user
+  // code.
+
+  void FindFunctionPointersInCall(StackFrame &frame,
+                                  std::vector<Address> &addresses,
+                                  bool debug_only = true,
+                                  bool resolve_thunks = true);
+
+  virtual lldb::ThreadPlanSP GetStepThroughTrampolinePlan(Thread &thread,
+                                                          bool stop_others);
+
+  bool IsSymbolARuntimeThunk(const Symbol &symbol) override;
+
+  // in some cases, compilers will output different names for one same type.
+  // when tht happens, it might be impossible
+  // to construct SBType objects for a valid type, because the name that is
+  // available is not the same as the name that
+  // can be used as a search key in FindTypes(). the equivalents map here is
+  // meant to return possible alternative names
+  // for a type through which a search can be conducted. Currently, this is only
+  // enabled for C++ but can be extended
+  // to ObjC or other languages if necessary
+  static uint32_t FindEquivalentNames(ConstString type_name,
+                                      std::vector<ConstString> &equivalents);
+
+  // this call should return true if it could set the name and/or the type
+  virtual bool GetDynamicTypeAndAddress(ValueObject &in_value,
+                                        lldb::DynamicValueType use_dynamic,
+                                        TypeAndOrName &class_type_or_name,
+                                        Address &address,
+                                        Value::ValueType &value_type) override;
+
+  virtual TypeAndOrName FixUpDynamicType(const TypeAndOrName &type_and_or_name,
+                                         ValueObject &static_value) override;
+
+  bool IsRuntimeSupportValue(ValueObject &valobj) override;
+
+  virtual CompilerType
+  DoArchetypeBindingForType(StackFrame &stack_frame, CompilerType base_type,
+                            SwiftASTContext *ast_context = nullptr);
+
+  virtual CompilerType GetConcreteType(ExecutionContextScope *exe_scope,
+                                       ConstString abstract_type_name) override;
+
+  virtual bool CouldHaveDynamicValue(ValueObject &in_value) override;
+
+  virtual MetadataPromiseSP
+  GetMetadataPromise(lldb::addr_t addr,
+                     SwiftASTContext *swift_ast_ctx = nullptr);
+
+  virtual MemberVariableOffsetResolverSP
+  GetMemberVariableOffsetResolver(CompilerType compiler_type);
+
+  void AddToLibraryNegativeCache(const char *library_name);
+
+  bool IsInLibraryNegativeCache(const char *library_name);
+
+  // Swift uses a few known-unused bits in ObjC pointers
+  // to record useful-for-bridging information
+  // This API's task is to return such pointer+info aggregates
+  // back to a pure pointer
+  lldb::addr_t MaskMaybeBridgedPointer(lldb::addr_t, lldb::addr_t * = nullptr);
+
+  // Swift uses a few known-unused bits in weak,unowned,unmanaged references
+  // to record useful runtime information
+  // This API's task is to strip those bits if necessary and return
+  // a pure pointer (or a tagged pointer)
+  lldb::addr_t MaybeMaskNonTrivialReferencePointer(
+      lldb::addr_t,
+      SwiftASTContext::NonTriviallyManagedReferenceStrategy strategy);
+
+  ConstString GetErrorBackstopName();
+
+  ConstString GetStandardLibraryName();
+
+  ConstString GetStandardLibraryBaseName();
+
+  virtual bool GetReferenceCounts(ValueObject &valobj, size_t &strong,
+                                  size_t &weak);
+
+  lldb::SyntheticChildrenSP
+  GetBridgedSyntheticChildProvider(ValueObject &valobj);
+
+  void WillStartExecutingUserExpression();
+  void DidFinishExecutingUserExpression();
+
+protected:
+  //------------------------------------------------------------------
+  // Classes that inherit from SwiftLanguageRuntime can see and modify these
+  //------------------------------------------------------------------
+  SwiftLanguageRuntime(Process *process);
+
+  Value::ValueType GetValueType(Value::ValueType static_value_type,
+                                const CompilerType &static_type,
+                                const CompilerType &dynamic_type,
+                                bool is_indirect_enum_case);
+
+  virtual bool GetDynamicTypeAndAddress_Class(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_Protocol(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_ErrorType(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_Archetype(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_Tuple(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_Struct(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_Enum(ValueObject &in_value,
+                                             lldb::DynamicValueType use_dynamic,
+                                             TypeAndOrName &class_type_or_name,
+                                             Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_IndirectEnumCase(
+      ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+      TypeAndOrName &class_type_or_name, Address &address);
+
+  virtual bool GetDynamicTypeAndAddress_Promise(
+      ValueObject &in_value, MetadataPromiseSP promise_sp,
+      lldb::DynamicValueType use_dynamic, TypeAndOrName &class_type_or_name,
+      Address &address);
+
+  virtual MetadataPromiseSP GetPromiseForTypeNameAndFrame(const char *type_name,
+                                                          StackFrame *frame);
+
+  bool GetTargetOfPartialApply(SymbolContext &curr_sc, ConstString &apply_name,
+                               SymbolContext &sc);
+
+  AppleObjCRuntimeV2 *GetObjCRuntime();
+
+  void SetupSwiftError();
+  void SetupExclusivity();
+
+  const CompilerType &GetBoxMetadataType();
+
+  std::shared_ptr<swift::remote::MemoryReader> GetMemoryReader();
+
+  SwiftASTContext *GetScratchSwiftASTContext();
+
+  std::unordered_set<std::string> m_library_negative_cache; // We have to load
+                                                            // swift dependent
+                                                            // libraries by
+                                                            // hand,
+  std::mutex m_negative_cache_mutex; // but if they are missing, we shouldn't
+                                     // keep trying.
+
+  llvm::Optional<lldb::addr_t> m_SwiftNativeNSErrorISA;
+
+  std::shared_ptr<swift::remote::MemoryReader> m_memory_reader_sp;
+
+  template <typename Key1, typename Key2, typename Value1> struct KeyHasher {
+    using KeyType = std::tuple<Key1, Key2>;
+    using HasherType = KeyHasher<Key1, Key2, Value1>;
+    using MapType = std::unordered_map<KeyType, Value1, HasherType>;
+
+    size_t operator()(const std::tuple<Key1, Key2> &key) const {
+      // fairly trivial hash combiner function
+      auto hash1 = std::hash<Key1>()(std::get<0>(key));
+      auto hash2 = std::hash<Key2>()(std::get<1>(key));
+      return hash2 + 0x9e3779b9 + (hash1 << 6) + (hash1 >> 2);
+    }
+  };
+
+  typename KeyHasher<swift::ASTContext *, lldb::addr_t,
+                     MetadataPromiseSP>::MapType m_promises_map;
+  typename KeyHasher<swift::ASTContext *, swift::TypeBase *,
+                     MemberVariableOffsetResolverSP>::MapType m_resolvers_map;
+
+  std::unordered_map<const char *, lldb::SyntheticChildrenSP>
+      m_bridged_synthetics_map;
+
+  CompilerType m_box_metadata_type;
+
+  // These members are used to track and toggle the state of the "dynamic
+  // exclusivity enforcement flag" in the swift runtime. This flag is set to
+  // true when an LLDB expression starts running, and reset to its original
+  // state after that expression (and any other concurrently running
+  // expressions) terminates.
+  std::mutex m_active_user_expr_mutex;
+  uint32_t m_active_user_expr_count = 0;
+  llvm::Optional<lldb::addr_t> m_dynamic_exclusivity_flag_addr =
+      llvm::Optional<lldb::addr_t>();
+  bool m_original_dynamic_exclusivity_flag_state = false;
+
+private:
+  DISALLOW_COPY_AND_ASSIGN(SwiftLanguageRuntime);
+};
+
+} // namespace lldb_private
+
+#endif // liblldb_SwiftLanguageRuntime_h_
diff --git a/include/lldb/Target/Target.h b/include/lldb/Target/Target.h
index ff9451939..34f59e4ab 100644
--- a/include/lldb/Target/Target.h
+++ b/include/lldb/Target/Target.h
@@ -16,10 +16,13 @@
 #include <map>
 #include <memory>
 #include <string>
+#include <unordered_set>
 #include <vector>
 
 // Other libraries and framework includes
 // Project includes
+#include "Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.h"
+#include "Plugins/ExpressionParser/Clang/ClangPersistentVariables.h"
 #include "lldb/Breakpoint/BreakpointList.h"
 #include "lldb/Breakpoint/WatchpointList.h"
 #include "lldb/Core/ArchSpec.h"
@@ -28,7 +31,14 @@
 #include "lldb/Core/ModuleList.h"
 #include "lldb/Core/UserSettingsController.h"
 #include "lldb/Expression/Expression.h"
+#include "lldb/Interpreter/Args.h"
+#include "lldb/Interpreter/OptionValueBoolean.h"
+#include "lldb/Interpreter/OptionValueEnumeration.h"
+#include "lldb/Interpreter/OptionValueFileSpec.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Symbol/SymbolContext.h"
 #include "lldb/Symbol/TypeSystem.h"
+#include "lldb/Target/ABI.h"
 #include "lldb/Target/ExecutionContextScope.h"
 #include "lldb/Target/PathMappingList.h"
 #include "lldb/Target/ProcessLaunchInfo.h"
@@ -125,10 +135,20 @@ public:
 
   FileSpecList &GetDebugFileSearchPaths();
 
+  FileSpec &GetSDKPath();
+
   FileSpecList &GetClangModuleSearchPaths();
 
+  FileSpecList &GetSwiftFrameworkSearchPaths();
+
+  FileSpecList &GetSwiftModuleSearchPaths();
+
+  FileSpec &GetModuleCachePath();
+
   bool GetEnableAutoImportClangModules() const;
 
+  bool GetUseAllCompilerFlags() const;
+
   bool GetEnableAutoApplyFixIts() const;
 
   bool GetEnableNotifyAboutFixIts() const;
@@ -337,6 +357,14 @@ public:
 
   void SetREPLEnabled(bool b) { m_repl = b; }
 
+  bool GetPlaygroundTransformEnabled() const { return m_playground; }
+
+  void SetPlaygroundTransformEnabled(bool b) {
+    m_playground = b;
+    if (b)
+      m_language = lldb::eLanguageTypeSwift;
+  }
+
   void SetCancelCallback(lldb::ExpressionCancelCallback callback, void *baton) {
     m_cancel_callback_baton = baton;
     m_cancel_callback = callback;
@@ -367,6 +395,8 @@ public:
 
   uint32_t GetPoundLineLine() const { return m_pound_line_line; }
 
+  uint32_t GetExpressionNumber() const;
+
   void SetResultIsInternal(bool b) { m_result_is_internal = b; }
 
   bool GetResultIsInternal() const { return m_result_is_internal; }
@@ -388,6 +418,7 @@ private:
   bool m_debug = false;
   bool m_trap_exceptions = true;
   bool m_repl = false;
+  bool m_playground = false;
   bool m_generate_debug_info = false;
   bool m_ansi_color_errors = false;
   bool m_result_is_internal = false;
@@ -396,6 +427,9 @@ private:
   Timeout<std::micro> m_timeout = default_timeout;
   Timeout<std::micro> m_one_thread_timeout = llvm::None;
   lldb::ExpressionCancelCallback m_cancel_callback = nullptr;
+  mutable uint32_t m_expr_number = 0; // A 1 based integer that increases with
+                                      // each expression type (normal, expr,
+                                      // function, etc)
   void *m_cancel_callback_baton = nullptr;
   // If m_pound_line_file is not empty and m_pound_line_line is non-zero,
   // use #line %u "%s" before the expression content to remap where the source
@@ -979,13 +1013,16 @@ public:
 
   PathMappingList &GetImageSearchPathList();
 
-  TypeSystem *GetScratchTypeSystemForLanguage(Status *error,
-                                              lldb::LanguageType language,
-                                              bool create_on_demand = true);
+  TypeSystem *
+  GetScratchTypeSystemForLanguage(Status *error, lldb::LanguageType language,
+                                  bool create_on_demand = true,
+                                  const char *compiler_options = nullptr);
 
   PersistentExpressionState *
   GetPersistentExpressionStateForLanguage(lldb::LanguageType language);
 
+  const TypeSystemMap &GetTypeSystemMap();
+
   // Creates a UserExpression for the given language, the rest of the parameters
   // have the
   // same meaning as for the UserExpression constructor.
@@ -1025,6 +1062,10 @@ public:
 
   lldb::ClangASTImporterSP GetClangASTImporter();
 
+  SwiftASTContext *
+  GetScratchSwiftASTContext(Status &error, bool create_on_demand = true,
+                            const char *extra_options = nullptr);
+
   //----------------------------------------------------------------------
   // Install any files through the platform that need be to installed
   // prior to launching or attaching.
@@ -1062,6 +1103,14 @@ public:
       const EvaluateExpressionOptions &options = EvaluateExpressionOptions(),
       std::string *fixed_expression = nullptr);
 
+  // Look up a symbol by name and type in both the target's symbols and the
+  // persistent symbols from the
+  // expression parser.  The symbol_type is ignored in that case, for now we
+  // don't have symbol types for the
+  // persistent variables.
+  lldb::addr_t FindLoadAddrForNameInSymbolsAndPersistentVariables(
+      ConstString name_const_str, lldb::SymbolType symbol_type);
+
   lldb::ExpressionVariableSP GetPersistentVariable(const ConstString &name);
 
   lldb::addr_t GetPersistentSymbol(const ConstString &name);
@@ -1228,6 +1277,7 @@ protected:
   lldb::SearchFilterSP m_search_filter_sp;
   PathMappingList m_image_search_paths;
   TypeSystemMap m_scratch_type_system_map;
+  std::map<lldb::LanguageType, bool> m_cant_make_scratch_type_system;
 
   typedef std::map<lldb::LanguageType, lldb::REPLSP> REPLMap;
   REPLMap m_repl_map;
diff --git a/include/lldb/Target/Thread.h b/include/lldb/Target/Thread.h
index 1b0b6ef55..5c84a523b 100644
--- a/include/lldb/Target/Thread.h
+++ b/include/lldb/Target/Thread.h
@@ -778,6 +778,13 @@ public:
       LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate,
       LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);
 
+  virtual lldb::ThreadPlanSP QueueThreadPlanForStepInRangeNoShouldStop(
+      bool abort_other_plans, const AddressRange &range,
+      const SymbolContext &addr_context, const char *step_in_target,
+      lldb::RunMode stop_other_threads,
+      LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate,
+      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);
+
   // Helper function that takes a LineEntry to step, insted of an AddressRange.
   // This may combine multiple
   // LineEntries of the same source line number to step over a longer address
@@ -987,11 +994,15 @@ public:
   //------------------------------------------------------------------
   /// Gets the outer-most return value from the completed plans
   ///
+  /// @param[out] is_swift_error_value
+  ///     If non-NULL, will be set to true if this is a Swift error value
+  ///     not a true return.
+  ///
   /// @return
   ///     A ValueObjectSP, either empty if there is no return value,
   ///     or containing the return value.
   //------------------------------------------------------------------
-  lldb::ValueObjectSP GetReturnValueObject();
+  lldb::ValueObjectSP GetReturnValueObject(bool *is_swift_error_value);
 
   //------------------------------------------------------------------
   /// Gets the outer-most expression variable from the completed plans
diff --git a/include/lldb/Target/ThreadPlan.h b/include/lldb/Target/ThreadPlan.h
index acc63ffe5..9a6f5b837 100644
--- a/include/lldb/Target/ThreadPlan.h
+++ b/include/lldb/Target/ThreadPlan.h
@@ -526,6 +526,8 @@ public:
     return lldb::ValueObjectSP();
   }
 
+  virtual bool IsReturnValueSwiftErrorValue() { return false; }
+
   // If the thread plan managing the evaluation of a user expression lives
   // longer than the command
   // that instigated the expression (generally because the expression evaluation
diff --git a/include/lldb/Target/ThreadPlanCallFunction.h b/include/lldb/Target/ThreadPlanCallFunction.h
index 1c75b0a36..71bd07424 100644
--- a/include/lldb/Target/ThreadPlanCallFunction.h
+++ b/include/lldb/Target/ThreadPlanCallFunction.h
@@ -16,6 +16,7 @@
 // Project includes
 #include "lldb/Target/Thread.h"
 #include "lldb/Target/ThreadPlan.h"
+#include "lldb/lldb-enumerations.h"
 #include "lldb/lldb-private.h"
 
 #include "llvm/ADT/ArrayRef.h"
@@ -104,7 +105,11 @@ public:
 
   void ThreadDestroyed() override { m_takedown_done = true; }
 
-  void SetStopOthers(bool new_value) override;
+  virtual void SetStopOthers(bool new_value) override;
+
+  lldb::LanguageType GetExpressionLanguage() { return m_expression_language; }
+
+  bool HitErrorBackstop() { return m_hit_error_backstop; }
 
 protected:
   void ReportRegisterState(const char *message);
@@ -153,6 +158,10 @@ protected:
   bool m_should_clear_cxx_exception_bp;
   lldb::addr_t m_stop_address; // This is the address we stopped at.  Also set
                                // in DoTakedown;
+  lldb::LanguageType
+      m_expression_language; // Set from the incoming ExpressionOptions.
+  lldb::BreakpointSP m_error_backstop_bp_sp;
+  bool m_hit_error_backstop;
 
 private:
   CompilerType m_return_type;
diff --git a/include/lldb/Target/ThreadPlanStepInRange.h b/include/lldb/Target/ThreadPlanStepInRange.h
index c3116eac8..7696ba96f 100644
--- a/include/lldb/Target/ThreadPlanStepInRange.h
+++ b/include/lldb/Target/ThreadPlanStepInRange.h
@@ -54,6 +54,8 @@ public:
 
   bool IsVirtualStep() override;
 
+  bool MischiefManaged() override;
+
 protected:
   static bool DefaultShouldStopHereCallback(ThreadPlan *current_plan,
                                             Flags &flags,
@@ -90,6 +92,13 @@ private:
 
   void SetupAvoidNoDebug(LazyBool step_in_avoids_code_without_debug_info,
                          LazyBool step_out_avoids_code_without_debug_info);
+
+  bool DefaultShouldStopHereImpl(Flags &flags, bool should_step_out);
+
+  bool StepInDeepBreakpointExplainsStop(lldb::StopInfoSP stop_info_sp);
+
+  void ClearStepInDeepBreakpoints();
+
   // Need an appropriate marker for the current stack so we can tell step out
   // from step in.
 
@@ -104,6 +113,9 @@ private:
   bool m_virtual_step; // true if we've just done a "virtual step", i.e. just
                        // moved the inline stack depth.
   ConstString m_step_into_target;
+  std::vector<lldb::break_id_t> m_step_in_deep_bps; // Places where we might
+                                                    // want to stop when we do a
+                                                    // step out.
   DISALLOW_COPY_AND_ASSIGN(ThreadPlanStepInRange);
 };
 
diff --git a/include/lldb/Target/ThreadPlanStepOut.h b/include/lldb/Target/ThreadPlanStepOut.h
index 285f4cab1..2d597bf11 100644
--- a/include/lldb/Target/ThreadPlanStepOut.h
+++ b/include/lldb/Target/ThreadPlanStepOut.h
@@ -45,6 +45,10 @@ public:
     return m_return_valobj_sp;
   }
 
+  bool IsReturnValueSwiftErrorValue() override {
+    return m_is_swift_error_value;
+  }
+
 protected:
   void SetFlagsToDefault() override {
     GetFlags().Set(ThreadPlanStepOut::s_default_flag_values);
@@ -63,6 +67,8 @@ private:
   StackID m_immediate_step_from_id;
   lldb::break_id_t m_return_bp_id;
   lldb::addr_t m_return_addr;
+  llvm::Optional<Value> m_swift_error_return;
+  bool m_swift_error_check_after_return;
   bool m_stop_others;
   lldb::ThreadPlanSP m_step_out_to_inline_plan_sp; // This plan implements step
                                                    // out to the real function
@@ -75,6 +81,7 @@ private:
                                                  // to.
   Function *m_immediate_step_from_function;
   lldb::ValueObjectSP m_return_valobj_sp;
+  bool m_is_swift_error_value;
   bool m_calculate_return_value;
 
   friend lldb::ThreadPlanSP Thread::QueueThreadPlanForStepOut(
diff --git a/include/lldb/Utility/Either.h b/include/lldb/Utility/Either.h
index 0dc340b64..f3913e217 100644
--- a/include/lldb/Utility/Either.h
+++ b/include/lldb/Utility/Either.h
@@ -80,6 +80,8 @@ public:
     case Selected::Two:
       return if_T2(m_t2);
     }
+
+    llvm_unreachable("Unhandled Selected in switch.");
   }
 
   bool operator==(const Either<T1, T2> &rhs) {
@@ -93,6 +95,8 @@ public:
     case Selected::Two:
       return (bool)m_t2;
     }
+
+    llvm_unreachable("Unhandled Selected in switch.");
   }
 
   Either<T1, T2> &operator=(const Either<T1, T2> &rhs) {
diff --git a/include/lldb/Utility/Stream.h b/include/lldb/Utility/Stream.h
index 5a00f0a50..d1fa28e6c 100644
--- a/include/lldb/Utility/Stream.h
+++ b/include/lldb/Utility/Stream.h
@@ -33,8 +33,16 @@ public:
   /// \a m_flags bit values.
   //------------------------------------------------------------------
   enum {
-    eBinary = (1 << 0) ///< Get and put data as binary instead of as the default
+    eBinary = (1 << 0), ///< Get and put data as binary instead of as the default
                        /// string mode.
+// START SWIFT PATCH
+    eVerbose = (1 << 1),   ///< If set, verbose logging is enabled
+    eDebug = (eVerbose << 1),     ///< If set, debug logging is enabled
+    eAddPrefix = (eVerbose << 2), ///< Add number prefixes for binary, octal and hex
+                           ///when eBinary is clear
+    eANSIColor = (eVerbose << 3), ///< If set, then it is ok to colorize the output
+                           ///with ANSI escape sequences
+// END SWIFT PATCH
   };
 
   //------------------------------------------------------------------
diff --git a/include/lldb/lldb-enumerations.h b/include/lldb/lldb-enumerations.h
index 14bae6ca2..9c5a88bf4 100644
--- a/include/lldb/lldb-enumerations.h
+++ b/include/lldb/lldb-enumerations.h
@@ -604,7 +604,12 @@ enum SymbolType {
   eSymbolTypeObjCClass,
   eSymbolTypeObjCMetaClass,
   eSymbolTypeObjCIVar,
-  eSymbolTypeReExported
+  eSymbolTypeIVarOffset, // A symbol that contains an offset for an instance
+                         // variable
+  eSymbolTypeReExported,
+  eSymbolTypeMetadata, // A symbol that contains the location of a direct
+                       // metadata for a type
+  eSymbolTypeASTFile   // A symbol whose name is the path to a compiler AST file
 };
 
 enum SectionType {
@@ -639,6 +644,7 @@ enum SectionType {
   eSectionTypeDWARFDebugStrOffsets,
   eSectionTypeDWARFAppleNames,
   eSectionTypeDWARFAppleTypes,
+  eSectionTypeDWARFAppleExternalTypes,
   eSectionTypeDWARFAppleNamespaces,
   eSectionTypeDWARFAppleObjC,
   eSectionTypeELFSymbolTable,       // Elf SHT_SYMTAB section
@@ -646,6 +652,7 @@ enum SectionType {
   eSectionTypeELFRelocationEntries, // Elf SHT_REL or SHT_REL section
   eSectionTypeELFDynamicLinkInfo,   // Elf SHT_DYNAMIC section
   eSectionTypeEHFrame,
+  eSectionTypeSwiftModules,
   eSectionTypeARMexidx,
   eSectionTypeARMextab,
   eSectionTypeCompactUnwind, // compact unwind section in Mach-O,
@@ -953,6 +960,8 @@ enum PathType {
                          // mach-o file in LLDB.framework (MacOSX) exists
   ePathTypeSupportExecutableDir, // Find LLDB support executable directory
                                  // (debugserver, etc)
+  ePathTypeSupportFileDir,       // Find LLDB support file directory (non-executable
+                                 // files)
   ePathTypeHeaderDir,            // Find LLDB header file directory
   ePathTypePythonDir,            // Find Python modules (PYTHONPATH) directory
   ePathTypeLLDBSystemPlugins,    // System plug-ins directory
@@ -961,7 +970,8 @@ enum PathType {
                                  // will be cleaned up on exit
   ePathTypeGlobalLLDBTempSystemDir, // The LLDB temp directory for this system,
                                     // NOT cleaned up on a process exit.
-  ePathTypeClangDir                 // Find path to Clang builtin headers
+  ePathTypeClangDir,                // Find path to Clang builtin headers
+  ePathTypeSwiftDir                 // Find path to Swift libraries
 };
 
 //----------------------------------------------------------------------
@@ -988,18 +998,21 @@ enum MatchType { eMatchTypeNormal, eMatchTypeRegex, eMatchTypeStartsWith };
 // Bitmask that describes details about a type
 //----------------------------------------------------------------------
 FLAGS_ENUM(TypeFlags){
-    eTypeHasChildren = (1u << 0),       eTypeHasValue = (1u << 1),
-    eTypeIsArray = (1u << 2),           eTypeIsBlock = (1u << 3),
-    eTypeIsBuiltIn = (1u << 4),         eTypeIsClass = (1u << 5),
-    eTypeIsCPlusPlus = (1u << 6),       eTypeIsEnumeration = (1u << 7),
-    eTypeIsFuncPrototype = (1u << 8),   eTypeIsMember = (1u << 9),
-    eTypeIsObjC = (1u << 10),           eTypeIsPointer = (1u << 11),
-    eTypeIsReference = (1u << 12),      eTypeIsStructUnion = (1u << 13),
-    eTypeIsTemplate = (1u << 14),       eTypeIsTypedef = (1u << 15),
-    eTypeIsVector = (1u << 16),         eTypeIsScalar = (1u << 17),
-    eTypeIsInteger = (1u << 18),        eTypeIsFloat = (1u << 19),
-    eTypeIsComplex = (1u << 20),        eTypeIsSigned = (1u << 21),
-    eTypeInstanceIsPointer = (1u << 22)};
+    eTypeHasChildren = (1u << 0),        eTypeHasValue = (1u << 1),
+    eTypeIsArray = (1u << 2),            eTypeIsBlock = (1u << 3),
+    eTypeIsBuiltIn = (1u << 4),          eTypeIsClass = (1u << 5),
+    eTypeIsCPlusPlus = (1u << 6),        eTypeIsEnumeration = (1u << 7),
+    eTypeIsFuncPrototype = (1u << 8),    eTypeIsMember = (1u << 9),
+    eTypeIsObjC = (1u << 10),            eTypeIsPointer = (1u << 11),
+    eTypeIsReference = (1u << 12),       eTypeIsStructUnion = (1u << 13),
+    eTypeIsTemplate = (1u << 14),        eTypeIsTypedef = (1u << 15),
+    eTypeIsVector = (1u << 16),          eTypeIsScalar = (1u << 17),
+    eTypeIsInteger = (1u << 18),         eTypeIsFloat = (1u << 19),
+    eTypeIsComplex = (1u << 20),         eTypeIsSigned = (1u << 21),
+    eTypeInstanceIsPointer = (1u << 22), eTypeIsSwift = (1u << 23),
+    eTypeIsArchetype = (1u << 24),       eTypeIsProtocol = (1u << 25),
+    eTypeIsTuple = (1u << 26),           eTypeIsMetatype = (1u << 27),
+    eTypeIsGeneric = (1u << 28),         eTypeIsBound = (1u << 29)};
 
 FLAGS_ENUM(CommandFlags){
     //----------------------------------------------------------------------
diff --git a/include/lldb/lldb-forward.h b/include/lldb/lldb-forward.h
index 392dc6415..8a4295216 100644
--- a/include/lldb/lldb-forward.h
+++ b/include/lldb/lldb-forward.h
@@ -199,6 +199,9 @@ class SectionList;
 class SectionLoadHistory;
 class SectionLoadList;
 class Settings;
+class SwiftASTContext;
+class SwiftLanguageRuntime;
+class SwiftREPL;
 class SourceManager;
 class SourceManagerImpl;
 class StackFrame;
@@ -420,6 +423,7 @@ typedef std::weak_ptr<lldb_private::Section> SectionWP;
 typedef std::shared_ptr<lldb_private::SectionLoadList> SectionLoadListSP;
 typedef std::shared_ptr<lldb_private::SearchFilter> SearchFilterSP;
 typedef std::shared_ptr<lldb_private::Settings> SettingsSP;
+typedef std::shared_ptr<lldb_private::SwiftASTContext> SwiftASTContextSP;
 typedef std::unique_ptr<lldb_private::SourceManager> SourceManagerUP;
 typedef std::shared_ptr<lldb_private::StackFrame> StackFrameSP;
 typedef std::unique_ptr<lldb_private::StackFrame> StackFrameUP;
diff --git a/include/lldb/lldb-private-interfaces.h b/include/lldb/lldb-private-interfaces.h
index 806068ece..d4601cd3f 100644
--- a/include/lldb/lldb-private-interfaces.h
+++ b/include/lldb/lldb-private-interfaces.h
@@ -95,7 +95,8 @@ typedef lldb::InstrumentationRuntimeType (*InstrumentationRuntimeGetType)();
 typedef lldb::InstrumentationRuntimeSP (*InstrumentationRuntimeCreateInstance)(
     const lldb::ProcessSP &process_sp);
 typedef lldb::TypeSystemSP (*TypeSystemCreateInstance)(
-    lldb::LanguageType language, Module *module, Target *target);
+    lldb::LanguageType language, Module *module, Target *target,
+    const char *compiler_options);
 typedef lldb::REPLSP (*REPLCreateInstance)(Status &error,
                                            lldb::LanguageType language,
                                            Debugger *debugger, Target *target,
diff --git a/lit/CMakeLists.txt b/lit/CMakeLists.txt
index 07d490619..639084ffc 100644
--- a/lit/CMakeLists.txt
+++ b/lit/CMakeLists.txt
@@ -12,6 +12,7 @@ else()
 endif(BUILD_SHARED_LIBS)
 
 option(LLDB_TEST_CLANG "Use in-tree clang when testing lldb" Off)
+option(LLDB_TEST_SWIFT "Use in-tree swift when testing lldb" Off)
 set(LLDB_TEST_C_COMPILER "" CACHE STRING "C compiler to use when testing LLDB")
 set(LLDB_TEST_CXX_COMPILER "" CACHE STRING "C++ compiler to use when testing LLDB")
 
diff --git a/source/API/CMakeLists.txt b/source/API/CMakeLists.txt
index 9dd21bcf2..d180a5225 100644
--- a/source/API/CMakeLists.txt
+++ b/source/API/CMakeLists.txt
@@ -1,3 +1,8 @@
+set(LLVM_NO_RTTI 1)
+
+include(AddLLVM)
+include(SwiftAddCustomCommandTarget)
+
 if ( CMAKE_SYSTEM_NAME MATCHES "Windows" )
   add_definitions( -DEXPORT_LIBLLDB )
 endif()
@@ -86,6 +91,8 @@ add_lldb_library(liblldb SHARED
   ${LLDB_WRAP_PYTHON}
 
   LINK_LIBS
+    clangAnalysis
+    clangIndex
     lldbBase
     lldbBreakpoint
     lldbCore
@@ -97,9 +104,23 @@ add_lldb_library(liblldb SHARED
     lldbSymbol
     lldbTarget
     lldbUtility
+    swiftLLVMPasses
+    swiftMarkup
+    swiftOption
+    swiftParseSIL
+    swiftSyntax
     ${LLDB_ALL_PLUGINS}
   LINK_COMPONENTS
+    BitWriter
+    BitReader
+    Coverage
+    Instrumentation
+    ObjCARCOpts
+    Object
+    Option
+    ProfileData
     Support
+    TransformUtils
   )
 
 if (LLVM_ENABLE_WERROR)
@@ -171,4 +191,3 @@ if(LLDB_BUILD_FRAMEWORK)
     COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX}/clang/${LLDB_VERSION} $<TARGET_FILE_DIR:liblldb>/Resources/Clang
     )
 endif()
-
diff --git a/source/API/SBExpressionOptions.cpp b/source/API/SBExpressionOptions.cpp
index e26fa1165..9588987a8 100644
--- a/source/API/SBExpressionOptions.cpp
+++ b/source/API/SBExpressionOptions.cpp
@@ -118,6 +118,23 @@ void SBExpressionOptions::SetCancelCallback(
   m_opaque_ap->SetCancelCallback(callback, baton);
 }
 
+bool SBExpressionOptions::GetPlaygroundTransformEnabled() const {
+  return m_opaque_ap->GetPlaygroundTransformEnabled();
+}
+
+void SBExpressionOptions::SetPlaygroundTransformEnabled(
+    bool enable_playground_transform) {
+  m_opaque_ap->SetPlaygroundTransformEnabled(enable_playground_transform);
+}
+
+bool SBExpressionOptions::GetREPLMode() const {
+  return m_opaque_ap->GetREPLEnabled();
+}
+
+void SBExpressionOptions::SetREPLMode(bool enable_repl_mode) {
+  m_opaque_ap->SetREPLEnabled(enable_repl_mode);
+}
+
 bool SBExpressionOptions::GetGenerateDebugInfo() {
   return m_opaque_ap->GetGenerateDebugInfo();
 }
diff --git a/source/API/SBFrame.cpp b/source/API/SBFrame.cpp
index 684a707dd..202d50931 100644
--- a/source/API/SBFrame.cpp
+++ b/source/API/SBFrame.cpp
@@ -37,6 +37,7 @@
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/StackFrame.h"
 #include "lldb/Target/StackID.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/Thread.h"
 #include "lldb/Utility/ConstString.h"
@@ -1389,6 +1390,32 @@ lldb::LanguageType SBFrame::GuessLanguage() const {
   return eLanguageTypeUnknown;
 }
 
+bool SBFrame::IsSwiftThunk() const {
+  std::unique_lock<std::recursive_mutex> lock;
+  ExecutionContext exe_ctx(m_opaque_sp.get(), lock);
+
+  StackFrame *frame = nullptr;
+  Target *target = exe_ctx.GetTargetPtr();
+  Process *process = exe_ctx.GetProcessPtr();
+  if (target && process) {
+    Process::StopLocker stop_locker;
+    if (stop_locker.TryLock(&process->GetRunLock())) {
+      frame = exe_ctx.GetFramePtr();
+      if (frame) {
+        SwiftLanguageRuntime *runtime = process->GetSwiftLanguageRuntime();
+        if (!runtime)
+          return false;
+        SymbolContext sc;
+        sc = frame->GetSymbolContext(eSymbolContextSymbol);
+        if (!sc.symbol)
+          return false;
+        return runtime->IsSymbolARuntimeThunk(*sc.symbol);
+      }
+    }
+  }
+  return false;
+}
+
 const char *SBFrame::GetFunctionName() const {
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_API));
   const char *name = nullptr;
diff --git a/source/API/SBModule.cpp b/source/API/SBModule.cpp
index 17f3dcc56..84829dc5f 100644
--- a/source/API/SBModule.cpp
+++ b/source/API/SBModule.cpp
@@ -24,6 +24,7 @@
 #include "lldb/Symbol/Symtab.h"
 #include "lldb/Symbol/TypeSystem.h"
 #include "lldb/Symbol/VariableList.h"
+#include "lldb/Target/Language.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/StreamString.h"
@@ -565,3 +566,21 @@ lldb::SBAddress SBModule::GetObjectFileHeaderAddress() const {
   }
   return sb_addr;
 }
+
+lldb::SBError SBModule::IsTypeSystemCompatible(lldb::LanguageType language) {
+  SBError sb_error;
+  ModuleSP module_sp(GetSP());
+  if (module_sp) {
+    TypeSystem *type_system = module_sp->GetTypeSystemForLanguage(language);
+    if (type_system) {
+      sb_error.SetError(type_system->IsCompatible());
+    } else {
+      sb_error.SetErrorStringWithFormat(
+          "no type system for language %s",
+          Language::GetNameForLanguageType(language));
+    }
+  } else {
+    sb_error.SetErrorString("invalid module");
+  }
+  return sb_error;
+}
diff --git a/source/API/SBTarget.cpp b/source/API/SBTarget.cpp
index c706344ee..d6c76421c 100644
--- a/source/API/SBTarget.cpp
+++ b/source/API/SBTarget.cpp
@@ -23,7 +23,9 @@
 #include "lldb/API/SBSourceManager.h"
 #include "lldb/API/SBStream.h"
 #include "lldb/API/SBStringList.h"
+#include "lldb/API/SBStringList.h"
 #include "lldb/API/SBSymbolContextList.h"
+#include "lldb/Breakpoint/Breakpoint.h"
 #include "lldb/Breakpoint/BreakpointID.h"
 #include "lldb/Breakpoint/BreakpointIDList.h"
 #include "lldb/Breakpoint/BreakpointList.h"
@@ -1002,6 +1004,15 @@ lldb::SBBreakpoint SBTarget::BreakpointCreateBySourceRegex(
 lldb::SBBreakpoint
 SBTarget::BreakpointCreateForException(lldb::LanguageType language,
                                        bool catch_bp, bool throw_bp) {
+  SBStringList no_extra_args;
+  return BreakpointCreateForException(language, catch_bp, throw_bp,
+                                      no_extra_args);
+}
+
+lldb::SBBreakpoint
+SBTarget::BreakpointCreateForException(lldb::LanguageType language,
+                                       bool catch_bp, bool throw_bp,
+                                       SBStringList &extra_args) {
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_API));
 
   SBBreakpoint sb_bp;
@@ -1011,6 +1022,22 @@ SBTarget::BreakpointCreateForException(lldb::LanguageType language,
     const bool hardware = false;
     sb_bp = target_sp->CreateExceptionBreakpoint(language, catch_bp, throw_bp,
                                                   hardware);
+    size_t num_extra_args = extra_args.GetSize();
+    if (num_extra_args > 0) {
+      // Have to convert this to Args, and pass it to the precondition:
+      if (num_extra_args % 2 == 0) {
+        Args args;
+        for (size_t i = 0; i < num_extra_args; i += 2) {
+          args.AppendArgument(extra_args.GetStringAtIndex(i));
+          args.AppendArgument(extra_args.GetStringAtIndex(i + 1));
+        }
+        BreakpointSP bkpt = sb_bp.GetSP();
+        Breakpoint::BreakpointPreconditionSP pre_condition_sp =
+            bkpt->GetPrecondition();
+        if (pre_condition_sp)
+          pre_condition_sp->ConfigurePrecondition(args);
+      }
+    }
   }
 
   if (log)
diff --git a/source/API/SBThread.cpp b/source/API/SBThread.cpp
index b34489603..bfc0ed665 100644
--- a/source/API/SBThread.cpp
+++ b/source/API/SBThread.cpp
@@ -422,6 +422,24 @@ size_t SBThread::GetStopDescription(char *dst, size_t dst_len) {
 }
 
 SBValue SBThread::GetStopReturnValue() {
+  bool is_swift_error_value = false;
+  SBValue return_value = GetStopReturnOrErrorValue(is_swift_error_value);
+  if (is_swift_error_value)
+    return SBValue();
+  else
+    return return_value;
+}
+
+SBValue SBThread::GetStopErrorValue() {
+  bool is_swift_error_value = false;
+  SBValue return_value = GetStopReturnOrErrorValue(is_swift_error_value);
+  if (!is_swift_error_value)
+    return SBValue();
+  else
+    return return_value;
+}
+
+SBValue SBThread::GetStopReturnOrErrorValue(bool &is_swift_error_value) {
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_API));
   ValueObjectSP return_valobj_sp;
   std::unique_lock<std::recursive_mutex> lock;
@@ -432,7 +450,8 @@ SBValue SBThread::GetStopReturnValue() {
     if (stop_locker.TryLock(&exe_ctx.GetProcessPtr()->GetRunLock())) {
       StopInfoSP stop_info_sp = exe_ctx.GetThreadPtr()->GetStopInfo();
       if (stop_info_sp) {
-        return_valobj_sp = StopInfo::GetReturnValueObject(stop_info_sp);
+        return_valobj_sp =
+            StopInfo::GetReturnValueObject(stop_info_sp, is_swift_error_value);
       }
     } else {
       if (log)
diff --git a/source/API/SBType.cpp b/source/API/SBType.cpp
index e2ef07cf5..4cf139ccf 100644
--- a/source/API/SBType.cpp
+++ b/source/API/SBType.cpp
@@ -131,6 +131,18 @@ bool SBType::IsVectorType() {
 bool SBType::IsReferenceType() {
   if (!IsValid())
     return false;
+  // FIXME: Swift class types are really like references, they are
+  // accessed by the same operator as Values, but their value is the
+  // location of the type.  But reporting true from the Compiler Type
+  // was causing problems that I couldn't unwind this time around.  So
+  // I'll work around that here.  The only Swift types that have a value
+  // are reference types.  All other Swift types are complex.  So use that
+  // as the discriminator.
+  CompilerType type = m_opaque_sp->GetCompilerType(true);
+  uint32_t flags = type.GetTypeInfo();
+  if (flags & eTypeIsSwift)
+    return flags & eTypeHasValue;
+
   return m_opaque_sp->GetCompilerType(true).IsReferenceType();
 }
 
diff --git a/source/API/SystemInitializerFull.cpp b/source/API/SystemInitializerFull.cpp
index c505f61e4..b5eae14fd 100644
--- a/source/API/SystemInitializerFull.cpp
+++ b/source/API/SystemInitializerFull.cpp
@@ -27,6 +27,7 @@
 #include "lldb/Symbol/GoASTContext.h"
 #include "lldb/Symbol/JavaASTContext.h"
 #include "lldb/Symbol/OCamlASTContext.h"
+#include "lldb/Symbol/SwiftASTContext.h"
 #include "lldb/Utility/Timer.h"
 
 #include "Plugins/ABI/MacOSX-arm/ABIMacOSX_arm.h"
@@ -53,6 +54,7 @@
 #include "Plugins/InstrumentationRuntime/TSan/TSanRuntime.h"
 #include "Plugins/InstrumentationRuntime/UBSan/UBSanRuntime.h"
 #include "Plugins/InstrumentationRuntime/MainThreadChecker/MainThreadCheckerRuntime.h"
+#include "Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.h"
 #include "Plugins/JITLoader/GDB/JITLoaderGDB.h"
 #include "Plugins/Language/CPlusPlus/CPlusPlusLanguage.h"
 #include "Plugins/Language/Go/GoLanguage.h"
@@ -115,6 +117,11 @@
 #include "lldb/Host/windows/windows.h"
 #endif
 
+#if defined(__APPLE__) || defined(__linux__)
+#include "Plugins/Language/Swift/SwiftLanguage.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#endif
+
 #include "llvm/Support/TargetSelect.h"
 
 #include <string>
@@ -247,6 +254,20 @@ SystemInitializerFull::SystemInitializerFull() {}
 
 SystemInitializerFull::~SystemInitializerFull() {}
 
+static void SwiftInitialize() {
+#if defined(__APPLE__) || defined(__linux__)
+  SwiftLanguage::Initialize();
+  SwiftLanguageRuntime::Initialize();
+#endif
+}
+
+static void SwiftTerminate() {
+#if defined(__APPLE__) || defined(__linux__)
+  SwiftLanguage::Terminate();
+  SwiftLanguageRuntime::Terminate();
+#endif
+}
+
 void SystemInitializerFull::Initialize() {
   SystemInitializerCommon::Initialize();
   ScriptInterpreterNone::Initialize();
@@ -290,6 +311,7 @@ void SystemInitializerFull::Initialize() {
   GoASTContext::Initialize();
   JavaASTContext::Initialize();
   OCamlASTContext::Initialize();
+  SwiftASTContext::Initialize();
 
   ABIMacOSX_i386::Initialize();
   ABIMacOSX_arm::Initialize();
@@ -314,6 +336,7 @@ void SystemInitializerFull::Initialize() {
   ThreadSanitizerRuntime::Initialize();
   UndefinedBehaviorSanitizerRuntime::Initialize();
   MainThreadCheckerRuntime::Initialize();
+  SwiftRuntimeReporting::Initialize();
 
   SymbolVendorELF::Initialize();
   SymbolFileDWARF::Initialize();
@@ -337,6 +360,7 @@ void SystemInitializerFull::Initialize() {
   ObjCLanguage::Initialize();
   ObjCPlusPlusLanguage::Initialize();
   OCamlLanguage::Initialize();
+  ::SwiftInitialize();
 
 #if defined(_WIN32)
   ProcessWindows::Initialize();
@@ -416,6 +440,7 @@ void SystemInitializerFull::Terminate() {
   GoASTContext::Terminate();
   JavaASTContext::Terminate();
   OCamlASTContext::Terminate();
+  SwiftASTContext::Terminate();
 
   ABIMacOSX_i386::Terminate();
   ABIMacOSX_arm::Terminate();
@@ -440,6 +465,7 @@ void SystemInitializerFull::Terminate() {
   ThreadSanitizerRuntime::Terminate();
   UndefinedBehaviorSanitizerRuntime::Terminate();
   MainThreadCheckerRuntime::Terminate();
+  SwiftRuntimeReporting::Terminate();
   SymbolVendorELF::Terminate();
   SymbolFileDWARF::Terminate();
   SymbolFilePDB::Terminate();
@@ -455,6 +481,8 @@ void SystemInitializerFull::Terminate() {
   RenderScriptRuntime::Terminate();
   JavaLanguageRuntime::Terminate();
 
+  ::SwiftTerminate();
+
   CPlusPlusLanguage::Terminate();
   GoLanguage::Terminate();
   JavaLanguage::Terminate();
diff --git a/source/Breakpoint/BreakpointLocation.cpp b/source/Breakpoint/BreakpointLocation.cpp
index ec8f141e8..8ed67d796 100644
--- a/source/Breakpoint/BreakpointLocation.cpp
+++ b/source/Breakpoint/BreakpointLocation.cpp
@@ -236,7 +236,7 @@ bool BreakpointLocation::ConditionSaysStop(ExecutionContext &exe_ctx,
 
     if (!m_user_expression_sp->Parse(diagnostics, exe_ctx,
                                      eExecutionPolicyOnlyWhenNeeded, true,
-                                     false)) {
+                                     false, 0)) {
       error.SetErrorStringWithFormat(
           "Couldn't parse conditional expression:\n%s",
           diagnostics.GetString().c_str());
diff --git a/source/Breakpoint/BreakpointResolverFileLine.cpp b/source/Breakpoint/BreakpointResolverFileLine.cpp
index 780d25db9..e034e706d 100644
--- a/source/Breakpoint/BreakpointResolverFileLine.cpp
+++ b/source/Breakpoint/BreakpointResolverFileLine.cpp
@@ -17,6 +17,7 @@
 #include "lldb/Core/Module.h"
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/Function.h"
+#include "lldb/Symbol/SymbolVendor.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/StreamString.h"
 
@@ -195,13 +196,15 @@ BreakpointResolverFileLine::SearchCallback(SearchFilter &filter,
   // in their line_entry and treat each set separately.
 
   const size_t num_comp_units = context.module_sp->GetNumCompileUnits();
+  const bool force_check_inlines =
+      context.module_sp->GetSymbolVendor()->ForceInlineSourceFileCheck();
   for (size_t i = 0; i < num_comp_units; i++) {
     CompUnitSP cu_sp(context.module_sp->GetCompileUnitAtIndex(i));
     if (cu_sp) {
       if (filter.CompUnitPasses(*cu_sp))
-        cu_sp->ResolveSymbolContext(m_file_spec, m_line_number, m_inlines,
-                                    m_exact_match, eSymbolContextEverything,
-                                    sc_list);
+        cu_sp->ResolveSymbolContext(
+            m_file_spec, m_line_number, m_inlines | force_check_inlines,
+            m_exact_match, eSymbolContextEverything, sc_list);
     }
   }
 
diff --git a/source/Breakpoint/BreakpointResolverName.cpp b/source/Breakpoint/BreakpointResolverName.cpp
index 468de35db..f0739cf92 100644
--- a/source/Breakpoint/BreakpointResolverName.cpp
+++ b/source/Breakpoint/BreakpointResolverName.cpp
@@ -23,6 +23,7 @@
 #include "lldb/Symbol/SymbolContext.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/StreamString.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 
 using namespace lldb;
 using namespace lldb_private;
@@ -233,6 +234,25 @@ void BreakpointResolverName::AddNameLookup(const ConstString &name,
   } else {
     Module::LookupInfo lookup(name, name_type_mask, m_language);
     m_lookups.push_back(lookup);
+
+    // we need to do this because we don't have a proper parser for Swift
+    // function name syntax
+    // so we try to ensure that if we autocomplete to something, we'll look for
+    // its mangled
+    // equivalent and use the mangled version as a lookup as well - to avoid
+    // overhead
+    // only do it for mangled names that start with _T - i.e. Swift mangled
+    // names!
+    ConstString counterpart;
+    if (name.GetMangledCounterpart(counterpart)) {
+      if (SwiftLanguageRuntime::IsSwiftMangledName(counterpart.GetCString())) {
+        Module::LookupInfo lookup;
+        lookup.SetName(counterpart);
+        lookup.SetLookupName(counterpart);
+        lookup.SetNameTypeMask(eFunctionNameTypeAuto);
+        m_lookups.push_back(lookup);
+      }
+    }
   }
 }
 
diff --git a/source/Commands/CMakeLists.txt b/source/Commands/CMakeLists.txt
index 55b41b105..f9f44ed0f 100644
--- a/source/Commands/CMakeLists.txt
+++ b/source/Commands/CMakeLists.txt
@@ -31,6 +31,8 @@ add_lldb_library(lldbCommands
   CommandObjectLanguage.cpp
 
   LINK_LIBS
+    swiftAST
+    swiftIDE
     lldbBase
     lldbBreakpoint
     lldbCore
diff --git a/source/Commands/CommandObjectBreakpoint.cpp b/source/Commands/CommandObjectBreakpoint.cpp
index 266864d1a..70bdd8d53 100644
--- a/source/Commands/CommandObjectBreakpoint.cpp
+++ b/source/Commands/CommandObjectBreakpoint.cpp
@@ -115,11 +115,11 @@ static OptionDefinition g_breakpoint_set_options[] = {
   "options, on throw but not catch.)" },
   { LLDB_OPT_SET_10,               false, "on-throw",               'w', OptionParser::eRequiredArgument, nullptr, nullptr, 0,                                         eArgTypeBoolean,             "Set the breakpoint on exception throW." },
   { LLDB_OPT_SET_10,               false, "on-catch",               'h', OptionParser::eRequiredArgument, nullptr, nullptr, 0,                                         eArgTypeBoolean,             "Set the breakpoint on exception catcH." },
-
-  //  Don't add this option till it actually does something useful...
-  //    { LLDB_OPT_SET_10, false, "exception-typename", 'O', OptionParser::eRequiredArgument, nullptr, nullptr, 0, eArgTypeTypeName,
-  //        "The breakpoint will only stop if an exception Object of this type is thrown.  Can be repeated multiple times to stop for multiple object types" },
-
+  { LLDB_OPT_SET_10,               false, "exception-typename",     'O', OptionParser::eRequiredArgument, nullptr, nullptr, 0,                                         eArgTypeTypeName,            "The breakpoint will only stop if an exception Object of this type is thrown. "
+  "Can be repeated multiple times to stop for multiple object types. "
+  "If you just specify the type's base name it will match against that type in all modules, "
+  "or you can specify the full type name including modules.  Other submatches are not supported at present."
+  "Only supported for Swift at present."},
   { LLDB_OPT_EXPR_LANGUAGE,        false, "language",               'L', OptionParser::eRequiredArgument, nullptr, nullptr, 0,                                         eArgTypeLanguage,            "Specifies the Language to use when interpreting the breakpoint's expression "
   "(note: currently only implemented for setting breakpoints on identifiers).  "
   "If not set the target.language setting is used." },
@@ -235,6 +235,9 @@ public:
           error.SetErrorStringWithFormat(
               "Set exception breakpoints separately for c++ and objective-c");
           break;
+        case eLanguageTypeSwift:
+          m_exception_language = eLanguageTypeSwift;
+          break;
         case eLanguageTypeUnknown:
           error.SetErrorStringWithFormat(
               "Unknown language type: '%s' for exception breakpoint",
@@ -435,6 +438,7 @@ public:
       m_catch_bp = false;
       m_throw_bp = true;
       m_hardware = false;
+      m_language = eLanguageTypeUnknown;
       m_exception_language = eLanguageTypeUnknown;
       m_language = lldb::eLanguageTypeUnknown;
       m_skip_prologue = eLazyBoolCalculate;
diff --git a/source/Commands/CommandObjectCommands.cpp b/source/Commands/CommandObjectCommands.cpp
index c9d71a657..ff68e9f9d 100644
--- a/source/Commands/CommandObjectCommands.cpp
+++ b/source/Commands/CommandObjectCommands.cpp
@@ -1049,6 +1049,20 @@ protected:
     }
   }
 
+  bool IOHandlerIsInputComplete(IOHandler &io_handler,
+                                StringList &lines) override {
+    // An empty lines is used to indicate the end of input
+    const size_t num_lines = lines.GetSize();
+    if (num_lines > 0 && lines[num_lines - 1].empty()) {
+      // Remove the last empty line from "lines" so it doesn't appear
+      // in our resulting input and return true to indicate we are done
+      // getting lines
+      lines.PopBack();
+      return true;
+    }
+    return false;
+  }
+
   bool DoExecute(Args &command, CommandReturnObject &result) override {
     const size_t argc = command.GetArgumentCount();
     if (argc == 0) {
diff --git a/source/Commands/CommandObjectExpression.cpp b/source/Commands/CommandObjectExpression.cpp
index b6e0016c8..c24a4d352 100644
--- a/source/Commands/CommandObjectExpression.cpp
+++ b/source/Commands/CommandObjectExpression.cpp
@@ -10,8 +10,14 @@
 // C Includes
 // C++ Includes
 // Other libraries and framework includes
+#include "swift/AST/Identifier.h"
+#include "swift/AST/Module.h"
+#include "swift/IDE/REPLCodeCompletion.h"
+#include "swift/IDE/Utils.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Support/MemoryBuffer.h"
 
 // Project includes
 #include "CommandObjectExpression.h"
@@ -27,6 +33,7 @@
 #include "lldb/Host/OptionParser.h"
 #include "lldb/Interpreter/CommandInterpreter.h"
 #include "lldb/Interpreter/CommandReturnObject.h"
+#include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/ObjectFile.h"
 #include "lldb/Symbol/Variable.h"
 #include "lldb/Target/Language.h"
@@ -60,7 +67,7 @@ static OptionDefinition g_expression_options[] = {
                                                                                                                                                                                   "and forcing breakpoints to not be ignored (-i0) and no unwinding to happen on error (-u0)."},
   {LLDB_OPT_SET_1 | LLDB_OPT_SET_2, false, "language",              'l', OptionParser::eRequiredArgument, nullptr, nullptr,                      0, eArgTypeLanguage,             "Specifies the Language to use when parsing the expression.  If not set the target.language "
                                                                                                                                                                                   "setting is used." },
-  {LLDB_OPT_SET_1 | LLDB_OPT_SET_2, false, "apply-fixits",          'X', OptionParser::eRequiredArgument, nullptr, nullptr,                      0, eArgTypeLanguage,             "If true, simple fix-it hints will be automatically applied to the expression." },
+  {LLDB_OPT_SET_1 | LLDB_OPT_SET_2, false, "apply-fixits",          'X', OptionParser::eRequiredArgument, nullptr, nullptr,                      0, eArgTypeBoolean,              "If true, simple fix-it hints will be automatically applied to the expression." },
   {LLDB_OPT_SET_1,                  false, "description-verbosity", 'v', OptionParser::eOptionalArgument, nullptr, g_description_verbosity_type, 0, eArgTypeDescriptionVerbosity, "How verbose should the output of this expression be, if the object description is asked for."},
   {LLDB_OPT_SET_1 | LLDB_OPT_SET_2, false, "top-level",             'p', OptionParser::eNoArgument,       nullptr, nullptr,                      0, eArgTypeNone,                 "Interpret the expression as a complete translation unit, without injecting it into the local "
                                                                                                                                                                                   "context.  Allows declaration of persistent, top-level entities without a $ prefix."},
@@ -202,6 +209,9 @@ void CommandObjectExpression::CommandOptions::OptionParsingStarting(
   try_all_threads = true;
   timeout = 0;
   debug = false;
+#ifdef LLDB_CONFIGURATION_DEBUG
+  playground = false;
+#endif
   language = eLanguageTypeUnknown;
   m_verbosity = eLanguageRuntimeDescriptionDisplayVerbosityCompact;
   auto_apply_fixits = eLazyBoolCalculate;
@@ -223,8 +233,13 @@ CommandObjectExpression::CommandObjectExpression(
           "", eCommandProcessMustBePaused | eCommandTryTargetAPILock),
       IOHandlerDelegate(IOHandlerDelegate::Completion::Expression),
       m_option_group(), m_format_options(eFormatDefault),
-      m_repl_option(LLDB_OPT_SET_1, false, "repl", 'r', "Drop into REPL", false,
-                    true),
+      m_repl_option(LLDB_OPT_SET_1, false, "repl", 'r', "Drop into Swift REPL",
+                    false, true),
+#ifdef LLDB_CONFIGURATION_DEBUG
+      m_playground_option(LLDB_OPT_SET_1, false, "playground", 'z',
+                          "Execute the expresssion as a playground expression",
+                          false, true),
+#endif
       m_command_options(), m_expr_line_count(0), m_expr_lines() {
   SetHelpLong(
       R"(
@@ -288,6 +303,9 @@ Examples:
   m_option_group.Append(&m_varobj_options, LLDB_OPT_SET_ALL,
                         LLDB_OPT_SET_1 | LLDB_OPT_SET_2);
   m_option_group.Append(&m_repl_option, LLDB_OPT_SET_ALL, LLDB_OPT_SET_3);
+#ifdef LLDB_CONFIGURATION_DEBUG
+  m_option_group.Append(&m_playground_option, LLDB_OPT_SET_ALL, LLDB_OPT_SET_1);
+#endif
   m_option_group.Finalize();
 }
 
@@ -333,7 +351,15 @@ bool CommandObjectExpression::EvaluateExpression(const char *expr,
     options.SetUseDynamic(m_varobj_options.use_dynamic);
     options.SetTryAllThreads(m_command_options.try_all_threads);
     options.SetDebug(m_command_options.debug);
-    options.SetLanguage(m_command_options.language);
+#ifdef LLDB_CONFIGURATION_DEBUG
+    options.SetPlaygroundTransformEnabled(m_command_options.playground);
+#endif
+
+    // If the language was not specified in the expression command,
+    // set it to the language in the target's properties if
+    // specified, else default to the language for the frame.
+    if (m_command_options.language != eLanguageTypeUnknown)
+      options.SetLanguage(m_command_options.language);
     options.SetExecutionPolicy(
         m_command_options.allow_jit
             ? EvaluateExpressionOptions::default_execution_policy
@@ -378,8 +404,20 @@ bool CommandObjectExpression::EvaluateExpression(const char *expr,
     if (result_valobj_sp) {
       Format format = m_format_options.GetFormat();
 
-      if (result_valobj_sp->GetError().Success()) {
-        if (format != eFormatVoid) {
+      const Status &expr_error = result_valobj_sp->GetError();
+      if (expr_error.Success()) {
+        bool treat_as_void = (format == eFormatVoid);
+        // if we are asked to suppress void, check if this is the empty tuple
+        // type, and if so suppress it
+        if (!treat_as_void && !m_interpreter.GetDebugger().GetNotifyVoid()) {
+          const CompilerType &expr_type(result_valobj_sp->GetCompilerType());
+          Flags expr_type_flags(expr_type.GetTypeInfo());
+          if (expr_type_flags.AllSet(eTypeIsSwift | eTypeIsTuple)) {
+            treat_as_void = (expr_type.GetNumFields() == 0);
+          }
+        }
+
+        if (!treat_as_void) {
           if (format != eFormatDefault)
             result_valobj_sp->SetFormat(format);
 
@@ -414,8 +452,22 @@ bool CommandObjectExpression::EvaluateExpression(const char *expr,
 
           if (result)
             result->SetStatus(eReturnStatusSuccessFinishResult);
+        } else if (expr_error.GetError() == lldb::eExpressionStoppedForDebug) {
+          const char *error_cstr = expr_error.AsCString();
+          if (error_cstr && error_cstr[0]) {
+            const size_t error_cstr_len = strlen(error_cstr);
+            const bool ends_with_newline =
+                error_cstr[error_cstr_len - 1] == '\n';
+            error_stream->Write(error_cstr, error_cstr_len);
+            if (!ends_with_newline)
+              error_stream->EOL();
+          } else {
+            error_stream->PutCString("error: unknown error\n");
+          }
+          if (result)
+            result->SetStatus(eReturnStatusSuccessFinishNoResult);
         } else {
-          const char *error_cstr = result_valobj_sp->GetError().AsCString();
+          const char *error_cstr = expr_error.AsCString();
           if (error_cstr && error_cstr[0]) {
             const size_t error_cstr_len = strlen(error_cstr);
             const bool ends_with_newline =
@@ -476,12 +528,32 @@ void CommandObjectExpression::GetMultilineExpression() {
   m_expr_lines.clear();
   m_expr_line_count = 0;
 
+  // If we didn't set the language, make sure we get the Swift language right
+  // if we are stopped in a swift compile unit. This will help us use the
+  // correct input reader name so our C/C++/ObjC expression history will be
+  // separate from the Swift expression history
+  if (m_command_options.language == eLanguageTypeUnknown) {
+    StackFrame *frame = m_exe_ctx.GetFramePtr();
+    if (frame) {
+      SymbolContext sym_ctx =
+          frame->GetSymbolContext(lldb::eSymbolContextCompUnit);
+      if (sym_ctx.comp_unit &&
+          sym_ctx.comp_unit->GetLanguage() == lldb::eLanguageTypeSwift)
+        m_command_options.language = lldb::eLanguageTypeSwift;
+    }
+  }
+
   Debugger &debugger = GetCommandInterpreter().GetDebugger();
   bool color_prompt = debugger.GetUseColor();
   const bool multiple_lines = true; // Get multiple lines
+
+  const char *input_reader_name =
+      m_command_options.language == lldb::eLanguageTypeSwift ? "lldb-swift"
+                                                             : "lldb-expr";
+
   IOHandlerSP io_handler_sp(
       new IOHandlerEditline(debugger, IOHandler::Type::Expression,
-                            "lldb-expr", // Name of input reader for history
+                            input_reader_name, // Name of input reader for history
                             llvm::StringRef(), // No prompt
                             llvm::StringRef(), // Continuation prompt
                             multiple_lines, color_prompt,
@@ -539,9 +611,19 @@ bool CommandObjectExpression::DoExecute(const char *command,
         result.SetStatus(eReturnStatusFailed);
         return false;
       }
+#ifdef LLDB_CONFIGURATION_DEBUG
+      m_command_options.playground =
+          m_playground_option.GetOptionValue().GetCurrentValue();
+#endif
 
       if (m_repl_option.GetOptionValue().GetCurrentValue()) {
         Target *target = m_interpreter.GetExecutionContext().GetTargetPtr();
+
+        // If we weren't passed in a target, let's see if the dummy target can
+        // make a REPL:
+        if (!target)
+          target = GetDummyTarget();
+
         if (target) {
           // Drop into REPL
           m_expr_lines.clear();
diff --git a/source/Commands/CommandObjectExpression.h b/source/Commands/CommandObjectExpression.h
index 0cf2a7263..0621d9d66 100644
--- a/source/Commands/CommandObjectExpression.h
+++ b/source/Commands/CommandObjectExpression.h
@@ -49,6 +49,9 @@ public:
     bool show_types;
     bool show_summary;
     bool debug;
+#ifdef LLDB_CONFIGURATION_DEBUG
+    bool playground;
+#endif
     uint32_t timeout;
     bool try_all_threads;
     lldb::LanguageType language;
@@ -72,7 +75,8 @@ protected:
   bool IOHandlerIsInputComplete(IOHandler &io_handler,
                                 StringList &lines) override;
 
-  bool DoExecute(const char *command, CommandReturnObject &result) override;
+  virtual bool DoExecute(const char *command,
+                         CommandReturnObject &result) override;
 
   bool EvaluateExpression(const char *expr, Stream *output_stream,
                           Stream *error_stream,
@@ -84,6 +88,9 @@ protected:
   OptionGroupFormat m_format_options;
   OptionGroupValueObjectDisplay m_varobj_options;
   OptionGroupBoolean m_repl_option;
+#ifdef LLDB_CONFIGURATION_DEBUG
+  OptionGroupBoolean m_playground_option;
+#endif
   CommandOptions m_command_options;
   uint32_t m_expr_line_count;
   std::string m_expr_lines;       // Multi-line expression support
diff --git a/source/Commands/CommandObjectFrame.cpp b/source/Commands/CommandObjectFrame.cpp
index 0bcc35062..e7845a6fe 100644
--- a/source/Commands/CommandObjectFrame.cpp
+++ b/source/Commands/CommandObjectFrame.cpp
@@ -745,8 +745,10 @@ CommandObjectMultiwordFrame::CommandObjectMultiwordFrame(
                                                    "examing the current "
                                                    "thread's stack frames.",
                              "frame <subcommand> [<subcommand-options>]") {
-  LoadSubCommand("diagnose",
-                 CommandObjectSP(new CommandObjectFrameDiagnose(interpreter)));
+  if (false) {
+    LoadSubCommand("diagnose",
+        CommandObjectSP(new CommandObjectFrameDiagnose(interpreter)));
+  }
   LoadSubCommand("info",
                  CommandObjectSP(new CommandObjectFrameInfo(interpreter)));
   LoadSubCommand("select",
diff --git a/source/Commands/CommandObjectTarget.cpp b/source/Commands/CommandObjectTarget.cpp
index a80acf19b..151145d85 100644
--- a/source/Commands/CommandObjectTarget.cpp
+++ b/source/Commands/CommandObjectTarget.cpp
@@ -1413,14 +1413,15 @@ static size_t DumpModuleObjfileHeaders(Stream &strm, ModuleList &module_list) {
 }
 
 static void DumpModuleSymtab(CommandInterpreter &interpreter, Stream &strm,
-                             Module *module, SortOrder sort_order) {
+                             Module *module, SortOrder sort_order,
+                             Mangled::NamePreference name_preference) {
   if (module) {
     SymbolVendor *sym_vendor = module->GetSymbolVendor();
     if (sym_vendor) {
       Symtab *symtab = sym_vendor->GetSymtab();
       if (symtab)
         symtab->Dump(&strm, interpreter.GetExecutionContext().GetTargetPtr(),
-                     sort_order);
+                     sort_order, name_preference);
     }
   }
 }
@@ -1970,7 +1971,8 @@ static OptionEnumValueElement g_sort_option_enumeration[4] = {
 
 static OptionDefinition g_target_modules_dump_symtab_options[] = {
     // clang-format off
-  { LLDB_OPT_SET_1, false, "sort", 's', OptionParser::eRequiredArgument, nullptr, g_sort_option_enumeration, 0, eArgTypeSortOrder, "Supply a sort order when dumping the symbol table." }
+    { LLDB_OPT_SET_1, false, "sort",               's', OptionParser::eRequiredArgument, nullptr, g_sort_option_enumeration, 0, eArgTypeSortOrder, "Supply a sort order when dumping the symbol table." },
+    { LLDB_OPT_SET_1, false, "show-mangled-names", 'm', OptionParser::eNoArgument,       nullptr, nullptr,                   0, eArgTypeNone,      "Do not demangle symbol names before showing them." },
     // clang-format on
 };
 
@@ -1989,7 +1991,9 @@ public:
 
   class CommandOptions : public Options {
   public:
-    CommandOptions() : Options(), m_sort_order(eSortOrderNone) {}
+    CommandOptions()
+        : Options(), m_sort_order(eSortOrderNone),
+          m_prefer_mangled(false, false) {}
 
     ~CommandOptions() override = default;
 
@@ -1999,6 +2003,11 @@ public:
       const int short_option = m_getopt_table[option_idx].val;
 
       switch (short_option) {
+      case 'm':
+        m_prefer_mangled.SetCurrentValue(true);
+        m_prefer_mangled.SetOptionWasSet();
+        break;
+
       case 's':
         m_sort_order = (SortOrder)Args::StringToOptionEnum(
             option_arg, GetDefinitions()[option_idx].enum_values,
@@ -2015,6 +2024,7 @@ public:
 
     void OptionParsingStarting(ExecutionContext *execution_context) override {
       m_sort_order = eSortOrderNone;
+      m_prefer_mangled.Clear();
     }
 
     llvm::ArrayRef<OptionDefinition> GetDefinitions() override {
@@ -2022,6 +2032,7 @@ public:
     }
 
     SortOrder m_sort_order;
+    OptionValueBoolean m_prefer_mangled;
   };
 
 protected:
@@ -2035,6 +2046,10 @@ protected:
     } else {
       uint32_t num_dumped = 0;
 
+      Mangled::NamePreference preference =
+          (m_options.m_prefer_mangled ? Mangled::ePreferMangled
+                                      : Mangled::ePreferDemangled);
+
       uint32_t addr_byte_size = target->GetArchitecture().GetAddressByteSize();
       result.GetOutputStream().SetAddressByteSize(addr_byte_size);
       result.GetErrorStream().SetAddressByteSize(addr_byte_size);
@@ -2057,7 +2072,7 @@ protected:
             DumpModuleSymtab(
                 m_interpreter, result.GetOutputStream(),
                 target->GetImages().GetModulePointerAtIndexUnlocked(image_idx),
-                m_options.m_sort_order);
+                m_options.m_sort_order, preference);
           }
         } else {
           result.AppendError("the target has no associated executable images");
@@ -2083,7 +2098,7 @@ protected:
                 }
                 num_dumped++;
                 DumpModuleSymtab(m_interpreter, result.GetOutputStream(),
-                                 module, m_options.m_sort_order);
+                                 module, m_options.m_sort_order, preference);
               }
             }
           } else
@@ -3705,7 +3720,7 @@ public:
       break;
     }
 
-    return true;
+    return false;
   }
 
   bool LookupInModule(CommandInterpreter &interpreter, Module *module,
diff --git a/source/Commands/CommandObjectType.cpp b/source/Commands/CommandObjectType.cpp
index 2d4271cab..e73965c61 100644
--- a/source/Commands/CommandObjectType.cpp
+++ b/source/Commands/CommandObjectType.cpp
@@ -2848,7 +2848,8 @@ public:
     StreamString stream;
     // FIXME: hardcoding languages is not good
     lldb::LanguageType languages[] = {eLanguageTypeObjC,
-                                      eLanguageTypeC_plus_plus};
+                                      eLanguageTypeC_plus_plus,
+                                      eLanguageTypeSwift};
 
     for (const auto lang_type : languages) {
       if (auto language = Language::FindPlugin(lang_type)) {
@@ -2928,6 +2929,7 @@ public:
       // FIXME: hardcoding languages is not good
       languages.push_back(Language::FindPlugin(eLanguageTypeObjC));
       languages.push_back(Language::FindPlugin(eLanguageTypeC_plus_plus));
+      languages.push_back(Language::FindPlugin(eLanguageTypeSwift));
     } else {
       languages.push_back(Language::FindPlugin(m_command_options.m_language));
     }
diff --git a/source/Core/CMakeLists.txt b/source/Core/CMakeLists.txt
index c345afb40..100797eec 100644
--- a/source/Core/CMakeLists.txt
+++ b/source/Core/CMakeLists.txt
@@ -58,6 +58,9 @@ add_lldb_library(lldbCore
   ValueObjectVariable.cpp
 
   LINK_LIBS
+    swiftBasic
+    swiftFrontend
+    swiftSerialization
     clangAST
     lldbBreakpoint
     lldbDataFormatters
diff --git a/source/Core/Debugger.cpp b/source/Core/Debugger.cpp
index d42e4df56..62346f5dd 100644
--- a/source/Core/Debugger.cpp
+++ b/source/Core/Debugger.cpp
@@ -1091,6 +1091,42 @@ void Debugger::PushIOHandler(const IOHandlerSP &reader_sp) {
   }
 }
 
+// Pop 2 IOHandlers and don't active the second one after the first is popped
+uint32_t Debugger::PopIOHandlers(const IOHandlerSP &reader1_sp,
+                                 const IOHandlerSP &reader2_sp) {
+  uint32_t result = 0;
+
+  std::lock_guard<std::recursive_mutex> guard(m_input_reader_stack.GetMutex());
+
+  // The reader on the stop of the stack is done, so let the next
+  // read on the stack refresh its prompt and if there is one...
+  if (!m_input_reader_stack.IsEmpty()) {
+    IOHandlerSP reader_sp(m_input_reader_stack.Top());
+
+    if (!reader1_sp || reader1_sp.get() == reader_sp.get()) {
+      reader_sp->Deactivate();
+      reader_sp->Cancel();
+      m_input_reader_stack.Pop();
+      ++result;
+
+      reader_sp = m_input_reader_stack.Top();
+
+      if (reader2_sp && reader2_sp.get() == reader_sp.get()) {
+        m_input_reader_stack.Pop();
+        ++result;
+        reader_sp = m_input_reader_stack.Top();
+      }
+
+      if (reader_sp)
+        reader_sp->Activate();
+
+    } else if (PopIOHandler(reader2_sp)) {
+      ++result;
+    }
+  }
+  return result;
+}
+
 bool Debugger::PopIOHandler(const IOHandlerSP &pop_reader_sp) {
   if (!pop_reader_sp)
     return false;
@@ -1452,6 +1488,7 @@ void Debugger::HandleProcessEvent(const EventSP &event_sp) {
 
   if (!gui_enabled) {
     bool pop_process_io_handler = false;
+    bool pop_command_interpreter = false;
     assert(process_sp);
 
     bool state_is_stopped = false;
@@ -1471,7 +1508,7 @@ void Debugger::HandleProcessEvent(const EventSP &event_sp) {
     // Display running state changes first before any STDIO
     if (got_state_changed && !state_is_stopped) {
       Process::HandleProcessStateChangedEvent(event_sp, output_stream_sp.get(),
-                                              pop_process_io_handler);
+                                              pop_process_io_handler, pop_command_interpreter);
     }
 
     // Now display and STDOUT
@@ -1517,14 +1554,14 @@ void Debugger::HandleProcessEvent(const EventSP &event_sp) {
     // Now display any stopped state changes after any STDIO
     if (got_state_changed && state_is_stopped) {
       Process::HandleProcessStateChangedEvent(event_sp, output_stream_sp.get(),
-                                              pop_process_io_handler);
+                                              pop_process_io_handler, pop_command_interpreter);
     }
 
     output_stream_sp->Flush();
     error_stream_sp->Flush();
 
     if (pop_process_io_handler)
-      process_sp->PopProcessIOHandler();
+      process_sp->PopProcessIOHandler(pop_command_interpreter);
   }
 }
 
diff --git a/source/Core/FormatEntity.cpp b/source/Core/FormatEntity.cpp
index 6002efe92..4ef8902e7 100644
--- a/source/Core/FormatEntity.cpp
+++ b/source/Core/FormatEntity.cpp
@@ -1303,10 +1303,16 @@ bool FormatEntity::Format(const Entry &entry, Stream &s,
       if (thread) {
         StopInfoSP stop_info_sp = thread->GetStopInfo();
         if (stop_info_sp && stop_info_sp->IsValid()) {
-          ValueObjectSP return_valobj_sp =
-              StopInfo::GetReturnValueObject(stop_info_sp);
+          bool is_swift_error_return = false;
+          ValueObjectSP return_valobj_sp = StopInfo::GetReturnValueObject(
+              stop_info_sp, is_swift_error_return);
           if (return_valobj_sp) {
-            return_valobj_sp->Dump(s);
+            DumpValueObjectOptions options;
+            if (return_valobj_sp->IsDynamic())
+              options.SetUseDynamicType(eDynamicCanRunTarget);
+            if (return_valobj_sp->DoesProvideSyntheticValue())
+              options.SetUseSyntheticValue(true);
+            return_valobj_sp->Dump(s, options);
             return true;
           }
         }
diff --git a/source/Core/IOHandler.cpp b/source/Core/IOHandler.cpp
index 194fec8a8..1739e026f 100644
--- a/source/Core/IOHandler.cpp
+++ b/source/Core/IOHandler.cpp
@@ -314,6 +314,7 @@ IOHandlerEditline::IOHandlerEditline(
     m_editline_ap.reset(new Editline(editline_name, GetInputFILE(),
                                      GetOutputFILE(), GetErrorFILE(),
                                      m_color_prompts));
+    SetBaseLineNumber(m_base_line_number);
     m_editline_ap->SetIsInputCompleteCallback(IsInputCompleteCallback, this);
     m_editline_ap->SetAutoCompleteCallback(AutoCompleteCallback, this);
     // See if the delegate supports fixing indentation
@@ -541,6 +542,7 @@ bool IOHandlerEditline::GetLines(StringList &lines, bool &interrupted) {
 #ifndef LLDB_DISABLE_LIBEDIT
   }
 #endif
+  m_current_lines_ptr = NULL;
   return success;
 }
 
diff --git a/source/Core/Mangled.cpp b/source/Core/Mangled.cpp
index 211a0c32c..9f8da22a7 100644
--- a/source/Core/Mangled.cpp
+++ b/source/Core/Mangled.cpp
@@ -27,12 +27,18 @@
 #include <cxxabi.h>
 #endif
 
+#include "swift/Demangling/Demangle.h"
+#include "llvm/ADT/DenseMap.h"
+
+#include "lldb/Core/Mangled.h"
+
 #include "lldb/Utility/ConstString.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/Logging.h"
 #include "lldb/Utility/RegularExpression.h"
 #include "lldb/Utility/Stream.h"
 #include "lldb/Utility/Timer.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/lldb-enumerations.h" // for LanguageType
 
 #include "Plugins/Language/CPlusPlus/CPlusPlusLanguage.h"
@@ -44,7 +50,10 @@
 #include <mutex>   // for mutex, loc...
 #include <string>  // for string
 #include <utility> // for pair
+#include <functional>
+#include <mutex>
 
+#include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
 using namespace lldb_private;
@@ -79,7 +88,8 @@ static inline Mangled::ManglingScheme cstring_mangling_scheme(const char *s) {
 }
 
 static inline bool cstring_is_mangled(const char *s) {
-  return cstring_mangling_scheme(s) != Mangled::eManglingSchemeNone;
+  return cstring_mangling_scheme(s) != Mangled::eManglingSchemeNone ||
+         SwiftLanguageRuntime::IsSwiftMangledName(s);
 }
 
 static const ConstString &
@@ -105,6 +115,7 @@ get_demangled_name_without_arguments(ConstString mangled,
   g_last_mangled = mangled;
 
   const char *mangled_name_cstr = mangled.GetCString();
+  const char *demangled_name_cstr = demangled.GetCString();
 
   if (demangled && mangled_name_cstr && mangled_name_cstr[0]) {
     if (mangled_name_cstr[0] == '_' && mangled_name_cstr[1] == 'Z' &&
@@ -127,6 +138,17 @@ get_demangled_name_without_arguments(ConstString mangled,
         g_most_recent_mangled_to_name_sans_args.second = result;
         return g_most_recent_mangled_to_name_sans_args.second;
       }
+    } else if (SwiftLanguageRuntime::IsSwiftMangledName(demangled_name_cstr)) {
+      lldb_private::ConstString basename;
+      bool is_method = false;
+      if (SwiftLanguageRuntime::MethodName::ExtractFunctionBasenameFromMangled(
+              mangled, basename, is_method)) {
+        if (basename && basename != mangled) {
+          g_most_recent_mangled_to_name_sans_args.first = mangled;
+          g_most_recent_mangled_to_name_sans_args.second = basename;
+          return (g_most_recent_mangled_to_name_sans_args.second);
+        }
+      }
     }
   }
 
@@ -135,6 +157,27 @@ get_demangled_name_without_arguments(ConstString mangled,
   return g_last_mangled;
 }
 
+#pragma mark DisplayDemangledNamesCache
+
+// make the key type be a const char* because that gives us usable DenseMapInfo
+// for free
+// making DenseMap work for ConstString requires us to provide two "invalid"
+// values:
+// the empty key and the tombstone key; but for ConstString, we really don't
+// have any
+// well-known invalid value other than ConstString(nullptr)
+// so, just use const char* as the key as LLVM knows how to do proper
+// DenseMapInfo for pointers
+static ThreadSafeDenseMap<const char *, ConstString> *
+GetDisplayDemangledNamesCache() {
+  ThreadSafeDenseMap<const char *, ConstString> *g_cache;
+  llvm::once_flag g_flag;
+  std::call_once(g_flag, [&g_cache]() -> void {
+    g_cache = new ThreadSafeDenseMap<const char *, ConstString>();
+  });
+  return g_cache;
+}
+
 #pragma mark Mangled
 //----------------------------------------------------------------------
 // Default constructor
@@ -329,6 +372,24 @@ Mangled::GetDemangledName(lldb::LanguageType language) const {
         m_demangled.SetCStringWithMangledCounterpart(demangled_name, m_mangled);
         free(demangled_name);
       }
+    } else if (mangling_scheme == eManglingSchemeNone &&
+               !m_mangled.GetMangledCounterpart(m_demangled) &&
+               SwiftLanguageRuntime::IsSwiftMangledName(mangled_name)) {
+      if (log)
+        log->Printf("demangle swift: %s", mangled_name);
+      std::string demangled(SwiftLanguageRuntime::DemangleSymbolAsString(
+          mangled_name));
+      if (!demangled.empty()) {
+        m_demangled.SetCStringWithMangledCounterpart(demangled.c_str(),
+                                                     m_mangled);
+        if (log)
+          log->Printf("demangle swift: %s -> \"%s\"", mangled_name,
+                      demangled.c_str());
+      } else {
+        if (log)
+          log->Printf("demangle swift: %s -> error: failed to demangle",
+                      mangled_name);
+      }
     }
     if (!m_demangled) {
       // Set the demangled string to the empty string to indicate we
@@ -342,7 +403,32 @@ Mangled::GetDemangledName(lldb::LanguageType language) const {
 
 ConstString
 Mangled::GetDisplayDemangledName(lldb::LanguageType language) const {
-  return GetDemangledName(language);
+  ConstString demangled;
+  if (m_mangled) {
+    do {
+      const char *mangled = m_mangled.GetCString();
+
+      if (mangled) {
+        if (SwiftLanguageRuntime::IsSwiftMangledName(mangled)) {
+          auto display_cache = ::GetDisplayDemangledNamesCache();
+          if (display_cache && display_cache->Lookup(mangled, demangled) &&
+              demangled)
+            break;
+
+          std::string demangled_std
+              = SwiftLanguageRuntime::DemangleSymbolAsString(m_mangled, true);
+          if (!demangled_std.empty()) {
+            demangled.SetCString(demangled_std.c_str());
+            display_cache->Insert(mangled, demangled);
+            break;
+          }
+        }
+      }
+    } while (0);
+  }
+  if (!demangled)
+    demangled = GetDemangledName(language);
+  return demangled ? demangled : m_mangled;
 }
 
 bool Mangled::NameMatches(const RegularExpression &regex,
@@ -431,6 +517,8 @@ lldb::LanguageType Mangled::GuessLanguage() const {
         return lldb::eLanguageTypeC_plus_plus;
       else if (ObjCLanguage::IsPossibleObjCMethodName(mangled_name))
         return lldb::eLanguageTypeObjC;
+      else if (SwiftLanguageRuntime::IsSwiftMangledName(mangled_name))
+        return lldb::eLanguageTypeSwift;
     }
   } else {
     // ObjC names aren't really mangled, so they won't necessarily be in the 
diff --git a/source/Core/Module.cpp b/source/Core/Module.cpp
index aaae4700d..6463a5884 100644
--- a/source/Core/Module.cpp
+++ b/source/Core/Module.cpp
@@ -24,6 +24,7 @@
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/Function.h" // for Function
 #include "lldb/Symbol/ObjectFile.h"
+#include "lldb/Symbol/SwiftASTContext.h"
 #include "lldb/Symbol/Symbol.h" // for Symbol
 #include "lldb/Symbol/SymbolContext.h"
 #include "lldb/Symbol/SymbolFile.h"
@@ -36,6 +37,7 @@
 #include "lldb/Target/Language.h"
 #include "lldb/Target/Platform.h" // for Platform
 #include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/DataBufferHeap.h"
 #include "lldb/Utility/Log.h"
@@ -54,6 +56,9 @@
 #include "Plugins/Language/ObjC/ObjCLanguage.h"
 #include "Plugins/ObjectFile/JIT/ObjectFileJIT.h"
 
+#include "swift/Basic/LangOptions.h"
+#include "swift/Frontend/Frontend.h"
+#include "swift/Serialization/Validation.h"
 #include "llvm/ADT/STLExtras.h"    // for make_unique
 #include "llvm/Support/Compiler.h" // for LLVM_PRETT...
 #include "llvm/Support/FileSystem.h"
@@ -689,6 +694,8 @@ Module::LookupInfo::LookupInfo(const ConstString &name, uint32_t name_type_mask,
               Language::LanguageIsObjC(language)) &&
              ObjCLanguage::IsPossibleObjCMethodName(name_cstr))
       m_name_type_mask = eFunctionNameTypeFull;
+    else if (SwiftLanguageRuntime::IsSwiftMangledName(name_cstr))
+      m_name_type_mask = eFunctionNameTypeFull;
     else if (Language::LanguageIsC(language)) {
       m_name_type_mask = eFunctionNameTypeFull;
     } else {
@@ -698,7 +705,19 @@ Module::LookupInfo::LookupInfo(const ConstString &name, uint32_t name_type_mask,
         m_name_type_mask |= eFunctionNameTypeSelector;
 
       CPlusPlusLanguage::MethodName cpp_method(name);
-      basename = cpp_method.GetBasename();
+      SwiftLanguageRuntime::MethodName swift_method(name, true);
+
+      if ((language == eLanguageTypeUnknown ||
+           language == eLanguageTypeSwift) &&
+          swift_method.IsValid())
+        basename = swift_method.GetBasename();
+      else if ((language == eLanguageTypeUnknown ||
+                Language::LanguageIsCPlusPlus(language) ||
+                Language::LanguageIsC(language) ||
+                language == eLanguageTypeObjC_plus_plus) &&
+               cpp_method.IsValid())
+        basename = cpp_method.GetBasename();
+
       if (basename.empty()) {
         if (CPlusPlusLanguage::ExtractContextAndIdentifier(name_cstr, context,
                                                            basename))
@@ -717,9 +736,12 @@ Module::LookupInfo::LookupInfo(const ConstString &name, uint32_t name_type_mask,
       // that, we don't
       // even need to search for CPP methods or names.
       CPlusPlusLanguage::MethodName cpp_method(name);
-      if (cpp_method.IsValid()) {
+      SwiftLanguageRuntime::MethodName swift_method(name, true);
+      if (swift_method.IsValid())
+        basename = swift_method.GetBasename();
+      if (cpp_method.IsValid())
         basename = cpp_method.GetBasename();
-
+      if (!basename.empty()) {
         if (!cpp_method.GetQualifiers().empty()) {
           // There is a "const" or other qualifier following the end of the
           // function parens,
@@ -1615,6 +1637,10 @@ bool Module::LoadScriptingResourceInTarget(Target *target, Status &error,
 bool Module::SetArchitecture(const ArchSpec &new_arch) {
   if (!m_arch.IsValid()) {
     m_arch = new_arch;
+    if (SwiftASTContext *swift_ast = llvm::dyn_cast_or_null<SwiftASTContext>(
+            m_type_system_map.GetTypeSystemForLanguage(eLanguageTypeSwift, this,
+                                                       false)))
+      swift_ast->SetTriple(new_arch.GetTriple().str().c_str());
     return true;
   }
   return m_arch.IsCompatibleMatch(new_arch);
@@ -1714,6 +1740,13 @@ Module::CreateJITModule(const lldb::ObjectFileJITDelegateSP &delegate_sp) {
   return ModuleSP();
 }
 
+void Module::ClearModuleDependentCaches() {
+  if (SwiftASTContext *swift_ast = llvm::dyn_cast_or_null<SwiftASTContext>(
+          m_type_system_map.GetTypeSystemForLanguage(eLanguageTypeSwift, this,
+                                                     false)))
+    swift_ast->ClearModuleDependentCaches();
+}
+
 bool Module::GetIsDynamicLinkEditor() {
   ObjectFile *obj_file = GetObjectFile();
 
diff --git a/source/Core/ModuleList.cpp b/source/Core/ModuleList.cpp
index b04299ead..8ddcf3120 100644
--- a/source/Core/ModuleList.cpp
+++ b/source/Core/ModuleList.cpp
@@ -61,6 +61,8 @@ class TypeList;
 using namespace lldb;
 using namespace lldb_private;
 
+static bool KeepLookingInDylinker(SymbolContextList &sc_list, size_t start_idx);
+
 ModuleList::ModuleList()
     : m_modules(), m_modules_mutex(), m_notifier(nullptr) {}
 
@@ -358,16 +360,27 @@ size_t ModuleList::FindFunctionSymbols(const ConstString &name,
 size_t ModuleList::FindFunctions(const RegularExpression &name,
                                  bool include_symbols, bool include_inlines,
                                  bool append, SymbolContextList &sc_list) {
-  const size_t old_size = sc_list.GetSize();
+  const size_t initial_size = sc_list.GetSize();
 
   std::lock_guard<std::recursive_mutex> guard(m_modules_mutex);
   collection::const_iterator pos, end = m_modules.end();
+  collection dylinker_modules;
   for (pos = m_modules.begin(); pos != end; ++pos) {
-    (*pos)->FindFunctions(name, include_symbols, include_inlines, append,
-                          sc_list);
+    if (!(*pos)->GetIsDynamicLinkEditor())
+      (*pos)->FindFunctions(name, include_symbols, include_inlines, append,
+                            sc_list);
+    else
+      dylinker_modules.push_back(*pos);
   }
+  bool keep_looking = KeepLookingInDylinker(sc_list, initial_size);
 
-  return sc_list.GetSize() - old_size;
+  if (keep_looking) {
+    end = dylinker_modules.end();
+    for (pos = dylinker_modules.begin(); pos != end; pos++)
+      (*pos)->FindFunctions(name, include_symbols, include_inlines, append,
+                            sc_list);
+  }
+  return sc_list.GetSize() - initial_size;
 }
 
 size_t ModuleList::FindCompileUnits(const FileSpec &path, bool append,
@@ -409,6 +422,36 @@ size_t ModuleList::FindGlobalVariables(const RegularExpression &regex,
   return variable_list.GetSize() - initial_size;
 }
 
+// We don't want to find symbols in the dylinker file if we've found
+// a viable candidate anywhere else.  This function looks at the symbols
+// added to the sc_list since start_idx, and if there's one in there that
+// looks real, returns false, in which case we should terminate the search.
+// If it returns true, we should go on to look in the dylinker.
+
+static bool KeepLookingInDylinker(SymbolContextList &sc_list,
+                                  size_t start_idx) {
+  bool keep_looking = true;
+  if (sc_list.GetSize() == start_idx) {
+    return true;
+  }
+
+  SymbolContext sc;
+  size_t num_symbols = sc_list.GetSize();
+  for (size_t idx = start_idx; idx < num_symbols; idx++) {
+    sc_list.GetContextAtIndex(idx, sc);
+    if (sc.symbol && sc.symbol->GetType() != lldb::eSymbolTypeUndefined) {
+      keep_looking = false;
+      break;
+    }
+    // If we have a function it's not going to be an undefined symbol...
+    if (sc.function) {
+      keep_looking = false;
+      break;
+    }
+  }
+  return keep_looking;
+}
+
 size_t ModuleList::FindSymbolsWithNameAndType(const ConstString &name,
                                               SymbolType symbol_type,
                                               SymbolContextList &sc_list,
@@ -419,8 +462,24 @@ size_t ModuleList::FindSymbolsWithNameAndType(const ConstString &name,
   size_t initial_size = sc_list.GetSize();
 
   collection::const_iterator pos, end = m_modules.end();
-  for (pos = m_modules.begin(); pos != end; ++pos)
-    (*pos)->FindSymbolsWithNameAndType(name, symbol_type, sc_list);
+  collection dylinker_modules;
+  for (pos = m_modules.begin(); pos != end; ++pos) {
+    if (!(*pos)->GetIsDynamicLinkEditor())
+      (*pos)->FindSymbolsWithNameAndType(name, symbol_type, sc_list);
+    else
+      dylinker_modules.push_back(*pos);
+  }
+
+  // Lets see if we found anything but undefined symbols.  If so, then we'll
+  // also look in the dylinker.
+  bool keep_looking = KeepLookingInDylinker(sc_list, initial_size);
+
+  if (keep_looking) {
+    end = dylinker_modules.end();
+    for (pos = dylinker_modules.begin(); pos != end; ++pos)
+      (*pos)->FindSymbolsWithNameAndType(name, symbol_type, sc_list);
+  }
+
   return sc_list.GetSize() - initial_size;
 }
 
@@ -433,8 +492,21 @@ size_t ModuleList::FindSymbolsMatchingRegExAndType(
   size_t initial_size = sc_list.GetSize();
 
   collection::const_iterator pos, end = m_modules.end();
-  for (pos = m_modules.begin(); pos != end; ++pos)
-    (*pos)->FindSymbolsMatchingRegExAndType(regex, symbol_type, sc_list);
+  collection dylinker_modules;
+  for (pos = m_modules.begin(); pos != end; ++pos) {
+    if (!(*pos)->GetIsDynamicLinkEditor())
+      (*pos)->FindSymbolsMatchingRegExAndType(regex, symbol_type, sc_list);
+    else
+      dylinker_modules.push_back(*pos);
+  }
+
+  bool keep_looking = KeepLookingInDylinker(sc_list, initial_size);
+
+  if (keep_looking) {
+    end = dylinker_modules.end();
+    for (pos = dylinker_modules.begin(); pos != end; ++pos)
+      (*pos)->FindSymbolsMatchingRegExAndType(regex, symbol_type, sc_list);
+  }
   return sc_list.GetSize() - initial_size;
 }
 
@@ -993,3 +1065,9 @@ void ModuleList::ForEach(
       break;
   }
 }
+
+void ModuleList::ClearModuleDependentCaches() {
+  std::lock_guard<std::recursive_mutex> guard(m_modules_mutex);
+  for (const auto &module : m_modules)
+    module->ClearModuleDependentCaches();
+}
diff --git a/source/Core/SearchFilter.cpp b/source/Core/SearchFilter.cpp
index 070195523..796ca9d14 100644
--- a/source/Core/SearchFilter.cpp
+++ b/source/Core/SearchFilter.cpp
@@ -15,6 +15,10 @@
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/SymbolContext.h" // for SymbolContext
 #include "lldb/Target/Target.h"
+
+#include "lldb/Utility/FileSpec.h"
+#include "lldb/lldb-private.h"
+
 #include "lldb/Utility/ConstString.h" // for ConstString
 #include "lldb/Utility/Status.h"      // for Status
 #include "lldb/Utility/Stream.h"      // for Stream
@@ -756,17 +760,20 @@ bool SearchFilterByModuleListAndCU::CompUnitPasses(FileSpec &fileSpec) {
 }
 
 bool SearchFilterByModuleListAndCU::CompUnitPasses(CompileUnit &compUnit) {
+  // If it comes from "<stdin>" then we should check it
+  static ConstString g_stdin_filename("<stdin>");
   bool in_cu_list =
-      m_cu_spec_list.FindFileIndex(0, compUnit, false) != UINT32_MAX;
+      (m_cu_spec_list.FindFileIndex(0, compUnit, false) != UINT32_MAX) ||
+      (compUnit.GetFilename() == g_stdin_filename);
   if (in_cu_list) {
     ModuleSP module_sp(compUnit.GetModule());
     if (module_sp) {
-      bool module_passes = SearchFilterByModuleList::ModulePasses(module_sp);
+      bool module_passes = ModulePasses(module_sp);
       return module_passes;
     } else
       return true;
-  } else
-    return false;
+  }
+  return false;
 }
 
 void SearchFilterByModuleListAndCU::Search(Searcher &searcher) {
@@ -783,7 +790,6 @@ void SearchFilterByModuleListAndCU::Search(Searcher &searcher) {
   // filespec that passes.  Otherwise, we need to go through all modules and
   // find the ones that match the file name.
 
-  ModuleList matching_modules;
   const ModuleList &target_images = m_target_sp->GetImages();
   std::lock_guard<std::recursive_mutex> guard(target_images.GetMutex());
 
@@ -791,7 +797,7 @@ void SearchFilterByModuleListAndCU::Search(Searcher &searcher) {
   bool no_modules_in_filter = m_module_spec_list.GetSize() == 0;
   for (size_t i = 0; i < num_modules; i++) {
     lldb::ModuleSP module_sp = target_images.GetModuleAtIndexUnlocked(i);
-    if (no_modules_in_filter ||
+    if (no_modules_in_filter || ModulePasses(module_sp) ||
         m_module_spec_list.FindFileIndex(0, module_sp->GetFileSpec(), false) !=
             UINT32_MAX) {
       SymbolContext matchingContext(m_target_sp, module_sp);
diff --git a/source/Core/SourceManager.cpp b/source/Core/SourceManager.cpp
index b284ff1db..f6705a413 100644
--- a/source/Core/SourceManager.cpp
+++ b/source/Core/SourceManager.cpp
@@ -289,6 +289,57 @@ bool SourceManager::SetDefaultFileAndLine(const FileSpec &file_spec,
   }
 }
 
+// this is a vector of pairs that each represent a legitimate interesting
+// entry point to the user program. the bool argument means whether
+// we want to skip the prologue code or not when trying to resolve
+// this name to a line entry
+// FindEntryPoint() will attempt to resolve these to a valid line entry in the
+// order
+// in which they are provided. This could probably be extended with a notion
+// of "main language", i.e. the language in which the main executable module is
+// coded
+static const std::vector<std::pair<ConstString, bool>> &GetEntryPointNames() {
+  static std::vector<std::pair<ConstString, bool>> g_entry_point_names;
+  if (g_entry_point_names.size() == 0) {
+    g_entry_point_names.push_back({ConstString("main"), false});
+    g_entry_point_names.push_back({ConstString("top_level_code"), true});
+  }
+  return g_entry_point_names;
+}
+
+static lldb_private::LineEntry FindEntryPoint(Module *exe_module) {
+  if (!exe_module)
+    return LineEntry();
+  const std::vector<std::pair<ConstString, bool>> &entry_points(
+      GetEntryPointNames());
+  for (std::pair<ConstString, bool> entry_point : entry_points) {
+    const ConstString entry_point_name = entry_point.first;
+    const bool skip_prologue = entry_point.second;
+    SymbolContextList sc_list;
+    bool symbols_okay = false; // Force it to be a debug symbol.
+    bool inlines_okay = true;
+    bool append = false;
+    size_t num_matches = exe_module->FindFunctions(
+        entry_point_name, NULL, lldb::eFunctionNameTypeBase, inlines_okay,
+        symbols_okay, append, sc_list);
+    for (size_t idx = 0; idx < num_matches; idx++) {
+      SymbolContext sc;
+      sc_list.GetContextAtIndex(idx, sc);
+      if (sc.function) {
+        lldb_private::LineEntry line_entry;
+        Address base_address = sc.function->GetAddressRange().GetBaseAddress();
+        if (skip_prologue)
+          base_address.SetOffset(sc.function->GetPrologueByteSize() +
+                                 base_address.GetOffset());
+        if (base_address.CalculateSymbolContextLineEntry(line_entry)) {
+          return line_entry;
+        }
+      }
+    }
+  }
+  return LineEntry();
+}
+
 bool SourceManager::GetDefaultFileAndLine(FileSpec &file_spec, uint32_t &line) {
   if (m_last_file_sp) {
     file_spec = m_last_file_sp->GetFileSpec();
@@ -305,28 +356,12 @@ bool SourceManager::GetDefaultFileAndLine(FileSpec &file_spec, uint32_t &line) {
       // somebody will have to set it (for instance when we stop somewhere...)
       Module *executable_ptr = target_sp->GetExecutableModulePointer();
       if (executable_ptr) {
-        SymbolContextList sc_list;
-        ConstString main_name("main");
-        bool symbols_okay = false; // Force it to be a debug symbol.
-        bool inlines_okay = true;
-        bool append = false;
-        size_t num_matches = executable_ptr->FindFunctions(
-            main_name, NULL, lldb::eFunctionNameTypeBase, inlines_okay,
-            symbols_okay, append, sc_list);
-        for (size_t idx = 0; idx < num_matches; idx++) {
-          SymbolContext sc;
-          sc_list.GetContextAtIndex(idx, sc);
-          if (sc.function) {
-            lldb_private::LineEntry line_entry;
-            if (sc.function->GetAddressRange()
-                    .GetBaseAddress()
-                    .CalculateSymbolContextLineEntry(line_entry)) {
-              SetDefaultFileAndLine(line_entry.file, line_entry.line);
-              file_spec = m_last_file_sp->GetFileSpec();
-              line = m_last_line;
-              return true;
-            }
-          }
+        lldb_private::LineEntry line_entry(FindEntryPoint(executable_ptr));
+        if (line_entry.IsValid()) {
+          SetDefaultFileAndLine(line_entry.file, line_entry.line);
+          file_spec = m_last_file_sp->GetFileSpec();
+          line = m_last_line;
+          return true;
         }
       }
     }
diff --git a/source/Core/Value.cpp b/source/Core/Value.cpp
index 63385511e..57888502b 100644
--- a/source/Core/Value.cpp
+++ b/source/Core/Value.cpp
@@ -224,6 +224,8 @@ uint64_t Value::GetValueByteSize(Status *error_ptr, ExecutionContext *exe_ctx) {
     if (ast_type.IsValid())
       byte_size = ast_type.GetByteSize(
           exe_ctx ? exe_ctx->GetBestExecutionContextScope() : nullptr);
+    if (byte_size == 0 && SwiftASTContext::IsPossibleZeroSizeType(ast_type))
+      return 0;
   } break;
   }
 
@@ -542,6 +544,9 @@ Status Value::GetValueAsData(ExecutionContext *exe_ctx, DataExtractor &data,
   // Bail if we encountered any errors getting the byte size
   if (error.Fail())
     return error;
+  else if (byte_size == 0 &&
+           SwiftASTContext::IsPossibleZeroSizeType(GetCompilerType()))
+    return error;
 
   // Make sure we have enough room within "data", and if we don't make
   // something large enough that does
diff --git a/source/Core/ValueObject.cpp b/source/Core/ValueObject.cpp
index c09139fe2..c00d37fb1 100644
--- a/source/Core/ValueObject.cpp
+++ b/source/Core/ValueObject.cpp
@@ -29,6 +29,7 @@
 #include "lldb/Symbol/ClangASTContext.h"
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/CompilerType.h"
+#include "lldb/Symbol/SwiftASTContext.h"
 #include "lldb/Symbol/Declaration.h"   // for Declaration
 #include "lldb/Symbol/SymbolContext.h" // for SymbolContext
 #include "lldb/Symbol/Type.h"
@@ -102,6 +103,8 @@ ValueObject::ValueObject(ValueObject &parent)
       m_did_calculate_complete_objc_class_type(false),
       m_is_synthetic_children_generated(
           parent.m_is_synthetic_children_generated) {
+  m_data.SetByteOrder(parent.GetDataExtractor().GetByteOrder());
+  m_data.SetAddressByteSize(parent.GetDataExtractor().GetAddressByteSize());
   m_manager->ManageObject(this);
 }
 
@@ -130,6 +133,14 @@ ValueObject::ValueObject(ExecutionContextScope *exe_scope,
       m_is_getting_summary(false),
       m_did_calculate_complete_objc_class_type(false),
       m_is_synthetic_children_generated(false) {
+  if (exe_scope) {
+    TargetSP target_sp(exe_scope->CalculateTarget());
+    if (target_sp) {
+      const ArchSpec &arch = target_sp->GetArchitecture();
+      m_data.SetByteOrder(arch.GetByteOrder());
+      m_data.SetAddressByteSize(arch.GetAddressByteSize());
+    }
+  }
   m_manager = new ValueObjectManager();
   m_manager->ManageObject(this);
 }
@@ -241,7 +252,8 @@ bool ValueObject::UpdateFormatsIfNeeded() {
 
   bool any_change = false;
 
-  if ((m_last_format_mgr_revision != DataVisualization::GetCurrentRevision())) {
+  if (GetCompilerType().IsValid() &&
+      (m_last_format_mgr_revision != DataVisualization::GetCurrentRevision())) {
     m_last_format_mgr_revision = DataVisualization::GetCurrentRevision();
     any_change = true;
 
@@ -286,6 +298,9 @@ CompilerType ValueObject::MaybeCalculateCompleteType() {
       return compiler_type;
   }
 
+  if (!compiler_type.IsValid())
+    return compiler_type;
+
   CompilerType class_type;
   bool is_pointer_type = false;
 
@@ -297,6 +312,13 @@ CompilerType ValueObject::MaybeCalculateCompleteType() {
     return compiler_type;
   }
 
+  auto make_pointer_if_needed = [](CompilerType compiler_type,
+                                   bool is_pointer_type) -> CompilerType {
+    if (is_pointer_type)
+      return compiler_type.GetPointerType();
+    return compiler_type;
+  };
+
   m_did_calculate_complete_objc_class_type = true;
 
   if (class_type) {
@@ -319,16 +341,47 @@ CompilerType ValueObject::MaybeCalculateCompleteType() {
                 complete_objc_class_type_sp->GetFullCompilerType());
 
             if (complete_class.GetCompleteType()) {
-              if (is_pointer_type) {
-                m_override_type = complete_class.GetPointerType();
-              } else {
-                m_override_type = complete_class;
+              m_override_type =
+                  make_pointer_if_needed(complete_class, is_pointer_type);
+              if (m_override_type.IsValid())
+                return m_override_type;
+            }
+          }
+
+          std::vector<clang::NamedDecl *> decls;
+
+          // try the modules
+          if (TargetSP target_sp = GetTargetSP()) {
+            if (auto clang_modules_decl_vendor =
+                    target_sp->GetClangModulesDeclVendor()) {
+              if (clang_modules_decl_vendor->FindDecls(class_name, false,
+                                                       UINT32_MAX, decls) > 0 &&
+                  decls.size() > 0) {
+                CompilerType module_type =
+                    ClangASTContext::GetTypeForDecl(decls.front());
+                m_override_type =
+                    make_pointer_if_needed(module_type, is_pointer_type);
               }
 
               if (m_override_type.IsValid())
                 return m_override_type;
             }
           }
+
+          // then try the runtime
+          if (auto runtime_vendor = objc_language_runtime->GetDeclVendor()) {
+            if (runtime_vendor->FindDecls(class_name, false, UINT32_MAX,
+                                          decls) > 0 &&
+                decls.size() > 0) {
+              CompilerType runtime_type =
+                  ClangASTContext::GetTypeForDecl(decls.front());
+              m_override_type =
+                  make_pointer_if_needed(runtime_type, is_pointer_type);
+            }
+
+            if (m_override_type.IsValid())
+              return m_override_type;
+          }
         }
       }
     }
@@ -401,6 +454,17 @@ const char *ValueObject::GetLocationAsCStringImpl(const Value &value,
   return m_location_str.c_str();
 }
 
+lldb_private::Status
+ValueObject::GetValueAsData(ExecutionContext *exe_ctx, DataExtractor &data,
+                            uint32_t data_offset, Module *module,
+                            bool mask_error_on_zerosize_type) {
+  Status err = m_value.GetValueAsData(exe_ctx, data, data_offset, module);
+  if (err.Fail() && mask_error_on_zerosize_type &&
+      SwiftASTContext::IsPossibleZeroSizeType(GetCompilerType()))
+    return Status();
+  return err;
+}
+
 Value &ValueObject::GetValue() { return m_value; }
 
 const Value &ValueObject::GetValue() const { return m_value; }
@@ -567,6 +631,10 @@ ValueObjectSP ValueObject::GetChildMemberWithName(const ConstString &name,
 
   std::vector<uint32_t> child_indexes;
   bool omit_empty_base_classes = true;
+
+  if (!GetCompilerType().IsValid())
+    return ValueObjectSP();
+
   const size_t num_child_indexes =
       GetCompilerType().GetIndexOfChildMemberWithName(
           name.GetCString(), omit_empty_base_classes, child_indexes);
@@ -1660,7 +1728,25 @@ ConstString ValueObject::GetQualifiedTypeName() {
 }
 
 LanguageType ValueObject::GetObjectRuntimeLanguage() {
-  return GetCompilerType().GetMinimumLanguage();
+  if (GetCompilerType().IsValid())
+    return GetCompilerType().GetMinimumLanguage();
+  return lldb::eLanguageTypeUnknown;
+}
+
+SwiftASTContext *ValueObject::GetSwiftASTContext() {
+  if (GetObjectRuntimeLanguage() != lldb::eLanguageTypeSwift)
+    return nullptr;
+  lldb::ModuleSP module_sp(GetModule());
+  if (module_sp)
+    return llvm::dyn_cast_or_null<SwiftASTContext>(
+        module_sp->GetTypeSystemForLanguage(lldb::eLanguageTypeSwift));
+
+  lldb::TargetSP target_sp(GetTargetSP());
+  if (target_sp) {
+    Status error;
+    return target_sp->GetScratchSwiftASTContext(error);
+  }
+  return nullptr;
 }
 
 void ValueObject::AddSyntheticChild(const ConstString &key,
@@ -1704,7 +1790,7 @@ bool ValueObject::IsPossibleDynamicType() {
   if (process)
     return process->IsPossibleDynamicValue(*this);
   else
-    return GetCompilerType().IsPossibleDynamicType(NULL, true, true);
+    return GetCompilerType().IsPossibleDynamicType(NULL, true, true, true);
 }
 
 bool ValueObject::IsRuntimeSupportValue() {
diff --git a/source/Core/ValueObjectDynamicValue.cpp b/source/Core/ValueObjectDynamicValue.cpp
index bb39caa76..6254102cf 100644
--- a/source/Core/ValueObjectDynamicValue.cpp
+++ b/source/Core/ValueObjectDynamicValue.cpp
@@ -31,6 +31,7 @@ class Declaration;
 }
 
 using namespace lldb_private;
+using namespace lldb;
 
 ValueObjectDynamicValue::ValueObjectDynamicValue(
     ValueObject &parent, lldb::DynamicValueType use_dynamic)
@@ -57,6 +58,8 @@ CompilerType ValueObjectDynamicValue::GetCompilerTypeImpl() {
 ConstString ValueObjectDynamicValue::GetTypeName() {
   const bool success = UpdateValueIfNeeded(false);
   if (success) {
+    if (m_dynamic_type_info.HasType())
+      return GetCompilerType().GetConstTypeName();
     if (m_dynamic_type_info.HasName())
       return m_dynamic_type_info.GetName();
   }
@@ -74,6 +77,8 @@ TypeImpl ValueObjectDynamicValue::GetTypeImpl() {
 ConstString ValueObjectDynamicValue::GetQualifiedTypeName() {
   const bool success = UpdateValueIfNeeded(false);
   if (success) {
+    if (m_dynamic_type_info.HasType())
+      return GetCompilerType().GetConstQualifiedTypeName();
     if (m_dynamic_type_info.HasName())
       return m_dynamic_type_info.GetName();
   }
@@ -114,6 +119,11 @@ lldb::ValueType ValueObjectDynamicValue::GetValueType() const {
 }
 
 bool ValueObjectDynamicValue::UpdateValue() {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  Log *verbose_log(
+      GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
   SetValueIsValid(false);
   m_error.Clear();
 
@@ -181,11 +191,25 @@ bool ValueObjectDynamicValue::UpdateValue() {
   m_update_point.SetUpdated();
 
   if (runtime && found_dynamic_type) {
+    if (verbose_log)
+      verbose_log->Printf("[%s %p] might have a dynamic type",
+                          GetName().GetCString(), (void *)this);
     if (class_type_or_name.HasType()) {
-      m_type_impl =
-          TypeImpl(m_parent->GetCompilerType(),
-                   runtime->FixUpDynamicType(class_type_or_name, *m_parent)
-                       .GetCompilerType());
+      // TypeSP are always generated from debug info
+      const bool prefer_parent_type = false;
+
+      if (prefer_parent_type) {
+        m_type_impl =
+            TypeImpl(m_parent->GetCompilerType(),
+                     runtime->FixUpDynamicType(class_type_or_name, *m_parent)
+                         .GetCompilerType());
+        class_type_or_name.SetCompilerType(CompilerType());
+      } else {
+        m_type_impl =
+            TypeImpl(m_parent->GetCompilerType(),
+                     runtime->FixUpDynamicType(class_type_or_name, *m_parent)
+                         .GetCompilerType());
+      }
     } else {
       m_type_impl.Clear();
     }
@@ -202,14 +226,12 @@ bool ValueObjectDynamicValue::UpdateValue() {
     ClearDynamicTypeInformation();
     m_dynamic_type_info.Clear();
     m_value = m_parent->GetValue();
-    m_error = m_value.GetValueAsData(&exe_ctx, m_data, 0, GetModule().get());
+    m_error = GetValueAsData(&exe_ctx, m_data, 0, GetModule().get());
     return m_error.Success();
   }
 
   Value old_value(m_value);
 
-  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
-
   bool has_changed_type = false;
 
   if (!m_dynamic_type_info) {
@@ -252,7 +274,7 @@ bool ValueObjectDynamicValue::UpdateValue() {
   if (m_address.IsValid() && m_dynamic_type_info) {
     // The variable value is in the Scalar value inside the m_value.
     // We can point our m_data right to it.
-    m_error = m_value.GetValueAsData(&exe_ctx, m_data, 0, GetModule().get());
+    m_error = GetValueAsData(&exe_ctx, m_data, 0, GetModule().get());
     if (m_error.Success()) {
       if (!CanProvideValue()) {
         // this value object represents an aggregate type whose
diff --git a/source/Core/ValueObjectSyntheticFilter.cpp b/source/Core/ValueObjectSyntheticFilter.cpp
index 87310c423..06b04d23c 100644
--- a/source/Core/ValueObjectSyntheticFilter.cpp
+++ b/source/Core/ValueObjectSyntheticFilter.cpp
@@ -312,7 +312,7 @@ lldb::ValueObjectSP ValueObjectSynthetic::GetNonSyntheticValue() {
 void ValueObjectSynthetic::CopyValueData(ValueObject *source) {
   m_value = (source->UpdateValueIfNeeded(), source->GetValue());
   ExecutionContext exe_ctx(GetExecutionContextRef());
-  m_error = m_value.GetValueAsData(&exe_ctx, m_data, 0, GetModule().get());
+  m_error = GetValueAsData(&exe_ctx, m_data, 0, GetModule().get());
 }
 
 bool ValueObjectSynthetic::CanProvideValue() {
diff --git a/source/Core/ValueObjectVariable.cpp b/source/Core/ValueObjectVariable.cpp
index 9b9e51a0a..8925790dd 100644
--- a/source/Core/ValueObjectVariable.cpp
+++ b/source/Core/ValueObjectVariable.cpp
@@ -131,12 +131,22 @@ bool ValueObjectVariable::UpdateValue() {
   if (variable->GetLocationIsConstantValueData()) {
     // expr doesn't contain DWARF bytes, it contains the constant variable
     // value bytes themselves...
-    if (expr.GetExpressionData(m_data))
+    if (expr.GetExpressionData(m_data)) {
+      if (m_data.GetDataStart() && m_data.GetByteSize())
+        m_value.SetBytes(m_data.GetDataStart(), m_data.GetByteSize());
       m_value.SetContext(Value::eContextTypeVariable, variable);
-    else
-      m_error.SetErrorString("empty constant data");
+    } else {
+      CompilerType var_type(GetCompilerTypeImpl());
+      if (var_type.IsValid()) {
+        if (SwiftASTContext::IsPossibleZeroSizeType(var_type))
+          m_value.SetCompilerType(var_type);
+        else
+          m_error.SetErrorString("empty constant data");
+      }
+    }
     // constant bytes can't be edited - sorry
     m_resolved_value.SetContext(Value::eContextTypeInvalid, NULL);
+    SetAddressTypeOfChildren(eAddressTypeInvalid);
   } else {
     lldb::addr_t loclist_base_load_addr = LLDB_INVALID_ADDRESS;
     ExecutionContext exe_ctx(GetExecutionContextRef());
@@ -170,7 +180,8 @@ bool ValueObjectVariable::UpdateValue() {
 
       Process *process = exe_ctx.GetProcessPtr();
       const bool process_is_alive = process && process->IsAlive();
-      const uint32_t type_info = compiler_type.GetTypeInfo();
+      const uint32_t type_info =
+          compiler_type.IsValid() ? compiler_type.GetTypeInfo() : 0;
       const bool is_pointer_or_ref =
           (type_info & (lldb::eTypeIsPointer | lldb::eTypeIsReference)) != 0;
 
diff --git a/source/DataFormatters/FormatManager.cpp b/source/DataFormatters/FormatManager.cpp
index 7619b6f6f..57d875d3d 100644
--- a/source/DataFormatters/FormatManager.cpp
+++ b/source/DataFormatters/FormatManager.cpp
@@ -16,6 +16,7 @@
 // Other libraries and framework includes
 // Project includes
 
+#include "Plugins/ScriptInterpreter/Python/lldb-python.h"
 #include "lldb/Core/Debugger.h"
 #include "lldb/DataFormatters/FormattersHelpers.h"
 #include "lldb/DataFormatters/LanguageCategory.h"
@@ -603,6 +604,10 @@ FormatManager::GetCandidateLanguages(ValueObject &valobj) {
 std::vector<lldb::LanguageType>
 FormatManager::GetCandidateLanguages(lldb::LanguageType lang_type) {
   switch (lang_type) {
+  case lldb::eLanguageTypeSwift:
+    return {lldb::eLanguageTypeSwift, lldb::eLanguageTypeObjC};
+  case lldb::eLanguageTypeObjC:
+    return {lldb::eLanguageTypeObjC, lldb::eLanguageTypeSwift};
   case lldb::eLanguageTypeC:
   case lldb::eLanguageTypeC89:
   case lldb::eLanguageTypeC99:
@@ -950,12 +955,20 @@ FormatManager::FormatManager()
       m_language_categories_map(), m_named_summaries_map(this),
       m_categories_map(this), m_default_category_name(ConstString("default")),
       m_system_category_name(ConstString("system")),
-      m_vectortypes_category_name(ConstString("VectorTypes")) {
+      m_vectortypes_category_name(ConstString("VectorTypes")),
+      m_runtime_synths_category_name(ConstString("runtime-synthetics")) {
   LoadSystemFormatters();
   LoadVectorFormatters();
 
+  GetCategory(m_runtime_synths_category_name); // EnableCategory() won't enable
+                                               // a non-existant category, so
+                                               // create this one first even if
+                                               // empty
+
   EnableCategory(m_vectortypes_category_name, TypeCategoryMap::Last,
                  lldb::eLanguageTypeObjC_plus_plus);
+  EnableCategory(m_runtime_synths_category_name, TypeCategoryMap::Last,
+                 {lldb::eLanguageTypeObjC_plus_plus, lldb::eLanguageTypeSwift});
   EnableCategory(m_system_category_name, TypeCategoryMap::Last,
                  lldb::eLanguageTypeObjC_plus_plus);
 }
diff --git a/source/DataFormatters/TypeCategory.cpp b/source/DataFormatters/TypeCategory.cpp
index 184a8c98d..d2150373c 100644
--- a/source/DataFormatters/TypeCategory.cpp
+++ b/source/DataFormatters/TypeCategory.cpp
@@ -40,6 +40,12 @@ static bool IsApplicable(lldb::LanguageType category_lang,
   default:
     return category_lang == valobj_lang;
 
+  // Swift knows about itself, and about ObjC++ bridgings
+  case eLanguageTypeSwift:
+    return valobj_lang == eLanguageTypeSwift ||
+           valobj_lang == eLanguageTypeObjC ||
+           valobj_lang == eLanguageTypeObjC_plus_plus;
+
   // the C family, we consider it as one
   case eLanguageTypeC89:
   case eLanguageTypeC:
diff --git a/source/DataFormatters/TypeFormat.cpp b/source/DataFormatters/TypeFormat.cpp
index 333fe91b7..e6f5f198d 100644
--- a/source/DataFormatters/TypeFormat.cpp
+++ b/source/DataFormatters/TypeFormat.cpp
@@ -94,7 +94,8 @@ bool TypeFormatImpl_Format::FormatObject(ValueObject *valobj,
         } else {
           Status error;
           valobj->GetData(data, error);
-          if (error.Fail())
+          if (error.Fail() &&
+              !SwiftASTContext::IsPossibleZeroSizeType(compiler_type))
             return false;
         }
 
@@ -110,7 +111,8 @@ bool TypeFormatImpl_Format::FormatObject(ValueObject *valobj,
                 exe_scope),                 // Byte size of item in "m_data"
             valobj->GetBitfieldBitSize(),   // Bitfield bit size
             valobj->GetBitfieldBitOffset(), // Bitfield bit offset
-            exe_scope);
+            exe_scope,
+            valobj->IsBaseClass());
         // Given that we do not want to set the ValueObject's m_error
         // for a formatting error (or else we wouldn't be able to reformat
         // until a next update), an empty string is treated as a "false"
@@ -191,9 +193,9 @@ bool TypeFormatImpl_EnumType::FormatObject(ValueObject *valobj,
     return false;
   ExecutionContext exe_ctx(valobj->GetExecutionContextRef());
   StreamString sstr;
-  valobj_enum_type.DumpTypeValue(&sstr, lldb::eFormatEnum, data, 0,
-                                 data.GetByteSize(), 0, 0,
-                                 exe_ctx.GetBestExecutionContextScope());
+  valobj_enum_type.DumpTypeValue(
+      &sstr, lldb::eFormatEnum, data, 0, data.GetByteSize(), 0, 0,
+      exe_ctx.GetBestExecutionContextScope(), valobj->IsBaseClass());
   if (!sstr.GetString().empty())
     dest = sstr.GetString();
   return !dest.empty();
diff --git a/source/DataFormatters/ValueObjectPrinter.cpp b/source/DataFormatters/ValueObjectPrinter.cpp
index 863ff3af1..a7736cf37 100644
--- a/source/DataFormatters/ValueObjectPrinter.cpp
+++ b/source/DataFormatters/ValueObjectPrinter.cpp
@@ -473,10 +473,31 @@ bool ValueObjectPrinter::PrintObjectDescriptionIfNeeded(bool value_printed,
   return true;
 }
 
+bool DumpValueObjectOptions::PointerDepth::CanAllowExpansion(
+    bool is_root, TypeSummaryImpl *entry, ValueObject *valobj,
+    const std::string &summary) {
+  switch (m_mode) {
+  case Mode::Always:
+    return (m_count > 0);
+  case Mode::Never:
+    return false;
+  case Mode::Default:
+    if (is_root)
+      m_count = std::min<decltype(m_count)>(m_count, 1);
+    return m_count > 0;
+  case Mode::Formatters:
+    if (!entry || entry->DoesPrintChildren(valobj) || summary.empty())
+      return m_count > 0;
+    return false;
+  }
+  return false;
+}
+
 bool DumpValueObjectOptions::PointerDepth::CanAllowExpansion() const {
   switch (m_mode) {
   case Mode::Always:
   case Mode::Default:
+  case Mode::Formatters:
     return m_count > 0;
   case Mode::Never:
     return false;
@@ -530,7 +551,8 @@ bool ValueObjectPrinter::ShouldPrintChildren(
         return true;
       }
 
-      return curr_ptr_depth.CanAllowExpansion();
+      return curr_ptr_depth.CanAllowExpansion(false, entry, m_valobj,
+                                              m_summary);
     }
 
     return (!entry || entry->DoesPrintChildren(m_valobj) || m_summary.empty());
diff --git a/source/Expression/CMakeLists.txt b/source/Expression/CMakeLists.txt
index 7d9643a45..efa8529c3 100644
--- a/source/Expression/CMakeLists.txt
+++ b/source/Expression/CMakeLists.txt
@@ -30,9 +30,11 @@ add_lldb_library(lldbExpression
     lldbTarget
     lldbUtility
     lldbPluginExpressionParserClang
+    lldbPluginExpressionParserSwift
 
   LINK_COMPONENTS
     Core
     ExecutionEngine
+    RuntimeDyld
     Support
   )
diff --git a/source/Expression/ExpressionSourceCode.cpp b/source/Expression/ExpressionSourceCode.cpp
index d60a12888..01a19f248 100644
--- a/source/Expression/ExpressionSourceCode.cpp
+++ b/source/Expression/ExpressionSourceCode.cpp
@@ -9,8 +9,14 @@
 
 #include "lldb/Expression/ExpressionSourceCode.h"
 
+#include <algorithm>
+
 #include "Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.h"
 #include "Plugins/ExpressionParser/Clang/ClangPersistentVariables.h"
+#include "Plugins/ExpressionParser/Clang/ClangUserExpression.h"
+#include "Plugins/ExpressionParser/Swift/SwiftASTManipulator.h"
+#include "lldb/Host/FileSystem.h"
+#include "lldb/Host/HostInfo.h"
 #include "lldb/Symbol/Block.h"
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/DebugMacros.h"
@@ -23,6 +29,10 @@
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/StreamString.h"
 
+#include "llvm/ADT/SmallString.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/FileSystem.h"
+
 using namespace lldb_private;
 
 const char *ExpressionSourceCode::g_expression_prefix = R"(
@@ -60,6 +70,13 @@ extern "C"
 }
 )";
 
+uint32_t ExpressionSourceCode::GetNumBodyLines() {
+  if (m_num_body_lines == 0)
+    // 2 = <one for zero indexing> + <one for the body start marker>
+    m_num_body_lines = 2 + std::count(m_body.begin(), m_body.end(), '\n');
+  return m_num_body_lines;
+}
+
 static const char *c_start_marker = "    /*LLDB_BODY_START*/\n    ";
 static const char *c_end_marker = ";\n    /*LLDB_BODY_END*/\n";
 
@@ -179,65 +196,131 @@ static void AddLocalVariableDecls(const lldb::VariableListSP &var_list_sp,
   }
 }
 
-bool ExpressionSourceCode::GetText(std::string &text,
-                                   lldb::LanguageType wrapping_language,
-                                   bool static_method,
-                                   ExecutionContext &exe_ctx) const {
+bool ExpressionSourceCode::SaveExpressionTextToTempFile(
+    llvm::StringRef text, const EvaluateExpressionOptions &options,
+    std::string &expr_source_path) {
+  bool success = false;
+
+  const uint32_t expr_number = options.GetExpressionNumber();
+
+  const bool playground = options.GetPlaygroundTransformEnabled();
+  const bool repl = options.GetREPLEnabled();
+
+  llvm::StringRef file_prefix;
+  if (playground)
+    file_prefix = "playground";
+  else if (repl)
+    file_prefix = "repl";
+  else
+    file_prefix = "expr";
+
+  llvm::Twine prefix = llvm::Twine(file_prefix).concat(llvm::Twine(expr_number));
+
+  llvm::StringRef suffix;
+  switch (options.GetLanguage()) {
+  default:
+    suffix = ".cpp";
+    break;
+
+  case lldb::eLanguageTypeSwift:
+    suffix = ".swift";
+    break;
+  }
+
+  int temp_fd;
+  llvm::SmallString<128> buffer;
+  std::error_code err =
+      llvm::sys::fs::createTemporaryFile(prefix, suffix, temp_fd, buffer);
+  if (!err) {
+    lldb_private::File file(temp_fd, true);
+    const size_t text_len = text.size();
+    size_t bytes_written = text_len;
+    if (file.Write(text.data(), bytes_written).Success()) {
+      if (bytes_written == text_len) {
+        // Make sure we have a newline in the file at the end
+        bytes_written = 1;
+        file.Write("\n", bytes_written);
+        if (bytes_written == 1)
+          success = true;
+      }
+    }
+    if (!success)
+      llvm::sys::fs::remove(expr_source_path);
+  }
+  if (!success)
+    expr_source_path.clear();
+  else
+    expr_source_path = buffer.str().str();
+
+  return success;
+}
+
+bool ExpressionSourceCode::GetText(
+    std::string &text, lldb::LanguageType wrapping_language,
+    uint32_t language_flags, const EvaluateExpressionOptions &options,
+    const Expression::SwiftGenericInfo &generic_info, ExecutionContext &exe_ctx,
+    uint32_t &first_body_line) const {
+  first_body_line = 0;
+
   const char *target_specific_defines = "typedef signed char BOOL;\n";
   std::string module_macros;
 
   Target *target = exe_ctx.GetTargetPtr();
-  if (target) {
-    if (target->GetArchitecture().GetMachine() == llvm::Triple::aarch64) {
-      target_specific_defines = "typedef bool BOOL;\n";
-    }
-    if (target->GetArchitecture().GetMachine() == llvm::Triple::x86_64) {
-      if (lldb::PlatformSP platform_sp = target->GetPlatform()) {
-        static ConstString g_platform_ios_simulator("ios-simulator");
-        if (platform_sp->GetPluginName() == g_platform_ios_simulator) {
-          target_specific_defines = "typedef bool BOOL;\n";
+  if (ClangModulesDeclVendor::LanguageSupportsClangModules(wrapping_language)) {
+    if (target) {
+      if (target->GetArchitecture().GetMachine() == llvm::Triple::aarch64) {
+        target_specific_defines = "typedef bool BOOL;\n";
+      }
+      if (target->GetArchitecture().GetMachine() == llvm::Triple::x86_64) {
+        if (lldb::PlatformSP platform_sp = target->GetPlatform()) {
+          static ConstString g_platform_ios_simulator("ios-simulator");
+          if (platform_sp->GetPluginName() == g_platform_ios_simulator) {
+            target_specific_defines = "typedef bool BOOL;\n";
+          }
         }
       }
-    }
 
-    if (ClangModulesDeclVendor *decl_vendor =
-            target->GetClangModulesDeclVendor()) {
       ClangPersistentVariables *persistent_vars =
-          llvm::cast<ClangPersistentVariables>(
+          llvm::dyn_cast_or_null<ClangPersistentVariables>(
               target->GetPersistentExpressionStateForLanguage(
                   lldb::eLanguageTypeC));
-      const ClangModulesDeclVendor::ModuleVector &hand_imported_modules =
-          persistent_vars->GetHandLoadedClangModules();
-      ClangModulesDeclVendor::ModuleVector modules_for_macros;
+      ClangModulesDeclVendor *decl_vendor = target->GetClangModulesDeclVendor();
 
-      for (ClangModulesDeclVendor::ModuleID module : hand_imported_modules) {
-        modules_for_macros.push_back(module);
-      }
+      if (persistent_vars && decl_vendor) {
+        const ClangModulesDeclVendor::ModuleVector &hand_imported_modules =
+            persistent_vars->GetHandLoadedClangModules();
+
+        ClangModulesDeclVendor::ModuleVector modules_for_macros;
+
+        for (ClangModulesDeclVendor::ModuleID module : hand_imported_modules) {
+          modules_for_macros.push_back(module);
+        }
 
-      if (target->GetEnableAutoImportClangModules()) {
-        if (StackFrame *frame = exe_ctx.GetFramePtr()) {
-          if (Block *block = frame->GetFrameBlock()) {
-            SymbolContext sc;
+        if (target->GetEnableAutoImportClangModules()) {
+          if (StackFrame *frame = exe_ctx.GetFramePtr()) {
+            if (Block *block = frame->GetFrameBlock()) {
+              SymbolContext sc;
 
-            block->CalculateSymbolContext(&sc);
+              block->CalculateSymbolContext(&sc);
 
-            if (sc.comp_unit) {
-              StreamString error_stream;
+              if (sc.comp_unit) {
+                StreamString error_stream;
 
-              decl_vendor->AddModulesForCompileUnit(
-                  *sc.comp_unit, modules_for_macros, error_stream);
+                decl_vendor->AddModulesForCompileUnit(
+                    *sc.comp_unit, modules_for_macros, error_stream);
+              }
             }
           }
         }
-      }
 
-      decl_vendor->ForEachMacro(
-          modules_for_macros,
-          [&module_macros](const std::string &expansion) -> bool {
-            module_macros.append(expansion);
-            module_macros.append("\n");
-            return false;
-          });
+        decl_vendor->ForEachMacro(
+            modules_for_macros,
+            [&module_macros](const std::string &expansion) -> bool {
+              module_macros.append(expansion);
+              module_macros.append("\n");
+              return false;
+            });
+      }
     }
   }
 
@@ -266,20 +349,38 @@ bool ExpressionSourceCode::GetText(std::string &text,
   }
 
   if (m_wrap) {
+    const char *body = m_body.c_str();
+    const char *pound_file = options.GetPoundLineFilePath();
+    const uint32_t pound_line = options.GetPoundLineLine();
+    StreamString pound_body;
+    if (pound_file && pound_line) {
+      if (wrapping_language == lldb::eLanguageTypeSwift) {
+        pound_body.Printf("#sourceLocation(file: \"%s\", line: %u)\n%s",
+                          pound_file, pound_line, body);
+      } else {
+        pound_body.Printf("#line %u \"%s\"\n%s", pound_line, pound_file, body);
+      }
+      body = pound_body.GetString().data();
+    }
+
     switch (wrapping_language) {
     default:
       return false;
     case lldb::eLanguageTypeC:
     case lldb::eLanguageTypeC_plus_plus:
     case lldb::eLanguageTypeObjC:
+    case lldb::eLanguageTypeSwift:
       break;
     }
 
     StreamString wrap_stream;
 
-    wrap_stream.Printf("%s\n%s\n%s\n%s\n%s\n", module_macros.c_str(),
-                       debug_macros_stream.GetData(), g_expression_prefix,
-                       target_specific_defines, m_prefix.c_str());
+    if (ClangModulesDeclVendor::LanguageSupportsClangModules(
+            wrapping_language)) {
+      wrap_stream.Printf("%s\n%s\n%s\n%s\n%s\n", module_macros.c_str(),
+                         debug_macros_stream.GetData(), g_expression_prefix,
+                         target_specific_defines, m_prefix.c_str());
+    }
 
     // First construct a tagged form of the user expression so we can find it
     // later:
@@ -320,7 +421,7 @@ bool ExpressionSourceCode::GetText(std::string &text,
                          tagged_body.c_str());
       break;
     case lldb::eLanguageTypeObjC:
-      if (static_method) {
+      if (language_flags & ClangUserExpression::eLanguageFlagInStaticMethod) {
         wrap_stream.Printf(
             "@interface $__lldb_objc_class ($__lldb_category)        \n"
             "+(void)%s:(void *)$__lldb_arg;                          \n"
@@ -346,6 +447,11 @@ bool ExpressionSourceCode::GetText(std::string &text,
             m_name.c_str(), m_name.c_str(), tagged_body.c_str());
       }
       break;
+    case lldb::eLanguageTypeSwift: {
+      SwiftASTManipulator::WrapExpression(wrap_stream, m_body.c_str(),
+                                          language_flags, options, generic_info,
+                                          first_body_line);
+    }
     }
 
     text = wrap_stream.GetString();
@@ -365,6 +471,10 @@ bool ExpressionSourceCode::GetOriginalBodyBounds(
   switch (wrapping_language) {
   default:
     return false;
+  case lldb::eLanguageTypeSwift:
+    start_marker = SwiftASTManipulator::GetUserCodeStartMarker();
+    end_marker = SwiftASTManipulator::GetUserCodeEndMarker();
+    break;
   case lldb::eLanguageTypeC:
   case lldb::eLanguageTypeC_plus_plus:
   case lldb::eLanguageTypeObjC:
diff --git a/source/Expression/ExpressionVariable.cpp b/source/Expression/ExpressionVariable.cpp
index a97180029..1c4de28f6 100644
--- a/source/Expression/ExpressionVariable.cpp
+++ b/source/Expression/ExpressionVariable.cpp
@@ -30,6 +30,11 @@ uint8_t *ExpressionVariable::GetValueBytes() {
 
 PersistentExpressionState::~PersistentExpressionState() {}
 
+void PersistentExpressionState::RegisterSymbol(const ConstString &name,
+                                               lldb::addr_t addr) {
+  m_symbol_map[name.GetCString()] = addr;
+}
+
 lldb::addr_t PersistentExpressionState::LookupSymbol(const ConstString &name) {
   SymbolMap::iterator si = m_symbol_map.find(name.GetCString());
 
diff --git a/source/Expression/FunctionCaller.cpp b/source/Expression/FunctionCaller.cpp
index 6f60f8bf9..e20a62bda 100644
--- a/source/Expression/FunctionCaller.cpp
+++ b/source/Expression/FunctionCaller.cpp
@@ -93,18 +93,9 @@ bool FunctionCaller::WriteFunctionWrapper(
   if (!jit_error.Success())
     return false;
 
-  if (m_parser->GetGenerateDebugInfo()) {
-    lldb::ModuleSP jit_module_sp(m_execution_unit_sp->GetJITModule());
-
-    if (jit_module_sp) {
-      ConstString const_func_name(FunctionName());
-      FileSpec jit_file;
-      jit_file.GetFilename() = const_func_name;
-      jit_module_sp->SetFileSpecAndObjectName(jit_file, ConstString());
-      m_jit_module_wp = jit_module_sp;
-      process->GetTarget().GetImages().Append(jit_module_sp);
-    }
-  }
+  if (m_parser->GetGenerateDebugInfo())
+    m_execution_unit_sp->CreateJITModule(FunctionName());
+
   if (process && m_jit_start_addr)
     m_jit_process_wp = process->shared_from_this();
 
diff --git a/source/Expression/IRExecutionUnit.cpp b/source/Expression/IRExecutionUnit.cpp
index 363e6fe86..299aeb148 100644
--- a/source/Expression/IRExecutionUnit.cpp
+++ b/source/Expression/IRExecutionUnit.cpp
@@ -26,6 +26,7 @@
 #include "lldb/Symbol/SymbolVendor.h"
 #include "lldb/Target/ExecutionContext.h"
 #include "lldb/Target/ObjCLanguageRuntime.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/DataBufferHeap.h"
 #include "lldb/Utility/DataExtractor.h"
@@ -43,12 +44,30 @@ IRExecutionUnit::IRExecutionUnit(std::unique_ptr<llvm::LLVMContext> &context_ap,
                                  const SymbolContext &sym_ctx,
                                  std::vector<std::string> &cpu_features)
     : IRMemoryMap(target_sp), m_context_ap(context_ap.release()),
-      m_module_ap(module_ap.release()), m_module(m_module_ap.get()),
-      m_cpu_features(cpu_features), m_name(name), m_sym_ctx(sym_ctx),
-      m_did_jit(false), m_function_load_addr(LLDB_INVALID_ADDRESS),
+      m_module_ap(module_ap.release()), m_jit_module_wp(),
+      m_module(m_module_ap.get()), m_cpu_features(cpu_features), m_name(name),
+      m_sym_ctx(sym_ctx), m_did_jit(false),
+      m_function_load_addr(LLDB_INVALID_ADDRESS),
       m_function_end_load_addr(LLDB_INVALID_ADDRESS),
       m_reported_allocations(false) {}
 
+IRExecutionUnit::~IRExecutionUnit() {
+  std::lock_guard<std::recursive_mutex> global_context_locker(
+      IRExecutionUnit::GetLLVMGlobalContextMutex());
+
+  m_module_ap.reset();
+  m_execution_engine_ap.reset();
+  m_context_ap.reset();
+
+  lldb::ModuleSP jit_module_sp(m_jit_module_wp.lock());
+  if (jit_module_sp) {
+    ExecutionContext exe_ctx(GetBestExecutionContextScope());
+    Target *target = exe_ctx.GetTargetPtr();
+    if (target)
+      target->GetImages().Remove(jit_module_sp);
+  }
+}
+
 lldb::addr_t IRExecutionUnit::WriteNow(const uint8_t *bytes, size_t size,
                                        Status &error) {
   const bool zero_memory = false;
@@ -495,12 +514,6 @@ void IRExecutionUnit::GetRunnableInfo(Status &error, lldb::addr_t &func_addr,
   return;
 }
 
-IRExecutionUnit::~IRExecutionUnit() {
-  m_module_ap.reset();
-  m_execution_engine_ap.reset();
-  m_context_ap.reset();
-}
-
 IRExecutionUnit::MemoryManager::MemoryManager(IRExecutionUnit &parent)
     : m_default_mm_ap(new llvm::SectionMemoryManager()), m_parent(parent) {}
 
@@ -1220,7 +1233,90 @@ uint32_t IRExecutionUnit::GetAddressByteSize() const {
 
 void IRExecutionUnit::PopulateSymtab(lldb_private::ObjectFile *obj_file,
                                      lldb_private::Symtab &symtab) {
-  // No symbols yet...
+  if (m_execution_engine_ap) {
+    uint32_t symbol_id = 0;
+    lldb_private::SectionList *section_list = obj_file->GetSectionList();
+    for (llvm::Function &function : *m_module) {
+      if (function.isDeclaration() ||
+          !(function.hasExternalLinkage() || function.hasLinkOnceODRLinkage()))
+        continue;
+
+      const lldb::addr_t function_addr =
+          (intptr_t)m_execution_engine_ap->getPointerToFunction(&function);
+
+      if (function_addr != 0) {
+        lldb::SectionSP section_sp(
+            section_list->FindSectionContainingFileAddress(function_addr));
+        const lldb::addr_t section_addr =
+            section_sp ? section_sp->GetFileAddress() : 0;
+        const lldb::addr_t function_offset = function_addr - section_addr;
+        llvm::GlobalValue::LinkageTypes linkage = function.getLinkage();
+        llvm::StringRef function_name_ref = function.getName();
+        std::string function_name = function_name_ref.str();
+        bool is_mangled = SwiftLanguageRuntime::IsSwiftMangledName(function_name.c_str())
+                          || function_name_ref.startswith("_Z");
+        Symbol symbol(++symbol_id, function_name.c_str(),
+                      is_mangled,
+                      lldb::eSymbolTypeCode,
+                      linkage ==
+                          llvm::GlobalValue::ExternalLinkage, //  external
+                      false,                                  // is_debug,
+                      false,                                  // is_trampoline,
+                      false,                                  // is_artificial,
+                      section_sp,                             // section
+                      function_offset,                        // offset
+                      0,     // Don't know the size of functions that I know of
+                      false, // size_is_valid
+                      false, // contains_linker_annotations
+                      0);    // flags
+        symbol.SetType(ObjectFile::GetSymbolTypeFromName(
+            symbol.GetMangled().GetMangledName().GetStringRef(),
+            symbol.GetType()));
+        symtab.AddSymbol(symbol);
+      }
+    }
+
+    for (llvm::GlobalVariable &global_var : m_module->getGlobalList()) {
+      if (global_var.isDeclaration() ||
+          !(global_var.hasExternalLinkage() ||
+            global_var.hasLinkOnceODRLinkage()))
+        continue;
+      llvm::StringRef global_name = global_var.getName();
+      if (global_name.empty())
+        continue;
+      const lldb::addr_t global_addr =
+          m_execution_engine_ap->getGlobalValueAddress(global_name.str());
+      if (global_addr != 0) {
+        lldb::SectionSP section_sp(
+            section_list->FindSectionContainingFileAddress(global_addr));
+        const lldb::addr_t section_addr =
+            section_sp ? section_sp->GetFileAddress() : 0;
+        const lldb::addr_t global_offset = global_addr - section_addr;
+        llvm::StringRef global_name_ref = global_var.getName();
+        std::string global_name = global_name_ref.str();
+        bool is_mangled = SwiftLanguageRuntime::IsSwiftMangledName(global_name.c_str())
+                          || global_name_ref.startswith("_Z");
+        Symbol symbol(++symbol_id, global_name_ref.str().c_str(),
+                      is_mangled,
+                      lldb::eSymbolTypeData,
+                      global_var.hasExternalLinkage(), // is_external
+                      false,                           // is_debug,
+                      false,                           // is_trampoline,
+                      false,                           // is_artificial,
+                      section_sp,                      // section
+                      global_offset,                   // offset
+                      0,     // Don't know the size of functions that I know of
+                      false, // size_is_valid
+                      false, // contains_linker_annotations
+                      0);    // flags
+        symbol.SetType(ObjectFile::GetSymbolTypeFromName(
+            symbol.GetMangled().GetMangledName().GetStringRef(),
+            symbol.GetType()));
+        symtab.AddSymbol(symbol);
+      }
+    }
+    symtab.CalculateSymbolSizes();
+  }
 }
 
 void IRExecutionUnit::PopulateSectionList(
@@ -1253,17 +1349,55 @@ bool IRExecutionUnit::GetArchitecture(lldb_private::ArchSpec &arch) {
 }
 
 lldb::ModuleSP IRExecutionUnit::GetJITModule() {
-  ExecutionContext exe_ctx(GetBestExecutionContextScope());
-  Target *target = exe_ctx.GetTargetPtr();
-  if (target) {
-    lldb::ModuleSP jit_module_sp = lldb_private::Module::CreateJITModule(
-        std::static_pointer_cast<lldb_private::ObjectFileJITDelegate>(
-            shared_from_this()));
-    if (jit_module_sp) {
-      bool changed = false;
-      jit_module_sp->SetLoadAddress(*target, 0, true, changed);
-    }
+  // Accessor only, might return empty shared pointer
+  return m_jit_module_wp.lock();
+}
+
+lldb::ModuleSP IRExecutionUnit::CreateJITModule(const char *name,
+                                                const FileSpec *limit_file_ptr,
+                                                uint32_t limit_start_line,
+                                                uint32_t limit_end_line) {
+  lldb::ModuleSP jit_module_sp(m_jit_module_wp.lock());
+  if (jit_module_sp)
     return jit_module_sp;
+
+  // Only create a JIT module if we are going to run it in the target
+  if (m_execution_engine_ap) {
+    ExecutionContext exe_ctx(GetBestExecutionContextScope());
+    Target *target = exe_ctx.GetTargetPtr();
+    if (target) {
+      jit_module_sp = lldb_private::Module::CreateJITModule(
+          std::static_pointer_cast<lldb_private::ObjectFileJITDelegate>(
+              shared_from_this()));
+      if (jit_module_sp) {
+        m_jit_module_wp = jit_module_sp;
+        bool changed = false;
+        jit_module_sp->SetLoadAddress(*target, 0, true, changed);
+
+        jit_module_sp->SetTypeSystemMap(target->GetTypeSystemMap());
+
+        ConstString const_name(name);
+        FileSpec jit_file;
+        jit_file.GetFilename() = const_name;
+        jit_module_sp->SetFileSpecAndObjectName(jit_file, ConstString());
+
+        if (limit_file_ptr) {
+          SymbolVendor *symbol_vendor = jit_module_sp->GetSymbolVendor();
+          if (symbol_vendor)
+            symbol_vendor->SetLimitSourceFileRange(
+                *limit_file_ptr, limit_start_line, limit_end_line);
+        }
+
+        target->GetImages().Append(jit_module_sp);
+      }
+      return jit_module_sp;
+    }
   }
   return lldb::ModuleSP();
 }
+
+std::recursive_mutex &IRExecutionUnit::GetLLVMGlobalContextMutex() {
+  static std::recursive_mutex s_llvm_context_mutex;
+
+  return s_llvm_context_mutex;
+}
diff --git a/source/Expression/LLVMUserExpression.cpp b/source/Expression/LLVMUserExpression.cpp
index 83acb8249..6f77bdad7 100644
--- a/source/Expression/LLVMUserExpression.cpp
+++ b/source/Expression/LLVMUserExpression.cpp
@@ -54,9 +54,7 @@ LLVMUserExpression::LLVMUserExpression(ExecutionContextScope &exe_scope,
       m_allow_objc(false),
       m_transformed_text(),
       m_execution_unit_sp(), m_materializer_ap(), m_jit_module_wp(),
-      m_enforce_valid_object(true), m_in_cplusplus_method(false),
-      m_in_objectivec_method(false), m_in_static_method(false),
-      m_needs_object_ptr(false), m_target(NULL), m_can_interpret(false),
+      m_language_flags(0), m_target(NULL), m_can_interpret(false),
       m_materialized_address(LLDB_INVALID_ADDRESS) {}
 
 LLVMUserExpression::~LLVMUserExpression() {
@@ -95,6 +93,8 @@ LLVMUserExpression::DoExecute(DiagnosticManager &diagnostic_manager,
     lldb::addr_t function_stack_bottom = LLDB_INVALID_ADDRESS;
     lldb::addr_t function_stack_top = LLDB_INVALID_ADDRESS;
 
+    lldb::ValueObjectSP error_backstop_result_sp;
+
     if (m_can_interpret) {
       llvm::Module *module = m_execution_unit_sp->GetModule();
       llvm::Function *function = m_execution_unit_sp->GetFunction();
@@ -230,7 +230,23 @@ LLVMUserExpression::DoExecute(DiagnosticManager &diagnostic_manager,
             "Use \"thread return -x\" to return to the state before expression "
             "evaluation.");
         return execution_result;
-      } else if (execution_result != lldb::eExpressionCompleted) {
+      } else if (execution_result == lldb::eExpressionCompleted) {
+        if (user_expression_plan->HitErrorBackstop()) {
+          // This should only happen in Playground & REPL.  The code threw an
+          // uncaught error, so we already rolled up
+          // the stack past our execution point.  We're not going to be able to
+          // get any or our expression variables
+          // since they've already gone out of scope.  But at least we can
+          // gather the error result...
+          if (user_expression_plan->GetReturnValueObject() &&
+              user_expression_plan->GetReturnValueObject()
+                  ->GetError()
+                  .Success()) {
+            error_backstop_result_sp =
+                user_expression_plan->GetReturnValueObject();
+          }
+        }
+      } else {
         diagnostic_manager.Printf(
             eDiagnosticSeverityError,
             "Couldn't execute function; result was %s",
@@ -239,8 +255,24 @@ LLVMUserExpression::DoExecute(DiagnosticManager &diagnostic_manager,
       }
     }
 
-    if (FinalizeJITExecution(diagnostic_manager, exe_ctx, result,
-                             function_stack_bottom, function_stack_top)) {
+    if (error_backstop_result_sp) {
+      // This should only happen in Playground & REPL.  The code threw an
+      // uncaught error, so we already rolled up
+      // the stack past our execution point.  We're not going to be able to get
+      // any or our expression variables
+      // since they've already gone out of scope.  But at least we can gather
+      // the error result...
+      Target *target = exe_ctx.GetTargetPtr();
+      PersistentExpressionState *expression_state =
+          target->GetPersistentExpressionStateForLanguage(Language());
+      if (expression_state)
+        result = expression_state->CreatePersistentVariable(
+            error_backstop_result_sp);
+
+      return lldb::eExpressionCompleted;
+    } else if (FinalizeJITExecution(diagnostic_manager, exe_ctx, result,
+                                    function_stack_bottom,
+                                    function_stack_top)) {
       return lldb::eExpressionCompleted;
     } else {
       return lldb::eExpressionResultUnavailable;
@@ -307,6 +339,22 @@ bool LLVMUserExpression::PrepareToExecuteJITExpression(
     return false;
   }
 
+  if (m_options.GetREPLEnabled()) {
+    Status materialize_error;
+
+    m_dematerializer_sp = m_materializer_ap->Materialize(
+        frame, *m_execution_unit_sp, LLDB_INVALID_ADDRESS, materialize_error);
+
+    if (!materialize_error.Success()) {
+      diagnostic_manager.Printf(eDiagnosticSeverityError,
+                                "Couldn't materialize: %s\n",
+                                materialize_error.AsCString());
+      return false;
+    }
+
+    return true;
+  }
+
   if (m_jit_start_addr != LLDB_INVALID_ADDRESS || m_can_interpret) {
     if (m_materialized_address == LLDB_INVALID_ADDRESS) {
       Status alloc_error;
diff --git a/source/Expression/Materializer.cpp b/source/Expression/Materializer.cpp
index 39fc5c8c2..3ec3f9ed7 100644
--- a/source/Expression/Materializer.cpp
+++ b/source/Expression/Materializer.cpp
@@ -17,13 +17,13 @@
 #include "lldb/Core/ValueObjectConstResult.h"
 #include "lldb/Core/ValueObjectVariable.h"
 #include "lldb/Expression/ExpressionVariable.h"
-#include "lldb/Symbol/ClangASTContext.h"
 #include "lldb/Symbol/Symbol.h"
 #include "lldb/Symbol/Type.h"
 #include "lldb/Symbol/Variable.h"
 #include "lldb/Target/ExecutionContext.h"
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/StackFrame.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/Thread.h"
 #include "lldb/Utility/Log.h"
@@ -428,7 +428,7 @@ class EntityVariable : public Materializer::Entity {
 public:
   EntityVariable(lldb::VariableSP &variable_sp)
       : Entity(), m_variable_sp(variable_sp), m_is_reference(false),
-        m_temporary_allocation(LLDB_INVALID_ADDRESS),
+        m_is_archetype(false), m_temporary_allocation(LLDB_INVALID_ADDRESS),
         m_temporary_allocation_size(0) {
     // Hard-coding to maximum size of a pointer since all variables are
     // materialized by reference
@@ -436,6 +436,8 @@ public:
     m_alignment = 8;
     m_is_reference =
         m_variable_sp->GetType()->GetForwardCompilerType().IsReferenceType();
+    m_is_archetype = SwiftASTContext::IsArchetypeType(
+        m_variable_sp->GetType()->GetForwardCompilerType());
   }
 
   void Materialize(lldb::StackFrameSP &frame_sp, IRMemoryMap &map,
@@ -473,6 +475,16 @@ public:
       return;
     }
 
+    // In the case where the value is of Swift archetype type, we need to unbox
+    // it
+    CompilerType valobj_type = valobj_sp->GetCompilerType();
+
+    if (m_is_archetype) {
+      valobj_sp = valobj_sp->GetDynamicValue(lldb::eDynamicDontRunTarget);
+      valobj_type = valobj_sp->GetCompilerType(); // update the type to refer to
+                                                  // the dynamic type
+    }
+
     if (m_is_reference) {
       DataExtractor valobj_extractor;
       Status extract_error;
@@ -500,9 +512,19 @@ public:
       }
     } else {
       AddressType address_type = eAddressTypeInvalid;
-      const bool scalar_is_load_address = false;
+      const bool is_dynamic_class_type =
+          m_is_archetype &&
+          (valobj_type.GetTypeClass() == lldb::eTypeClassClass);
+      const bool scalar_is_load_address = m_is_archetype; // this is the only
+                                                          // time we're dealing
+                                                          // with dynamic values
+
+      // if the dynamic type is a class, bypass the GetAddressOf() optimization
+      // as it doesn't do the right thing
       lldb::addr_t addr_of_valobj =
-          valobj_sp->GetAddressOf(scalar_is_load_address, &address_type);
+          is_dynamic_class_type
+              ? LLDB_INVALID_ADDRESS
+              : valobj_sp->GetAddressOf(scalar_is_load_address, &address_type);
       if (addr_of_valobj != LLDB_INVALID_ADDRESS) {
         Status write_error;
         map.WritePointerToMemory(load_addr, addr_of_valobj, write_error);
@@ -518,6 +540,11 @@ public:
         Status extract_error;
         valobj_sp->GetData(data, extract_error);
         if (!extract_error.Success()) {
+          if (valobj_type.GetMinimumLanguage() == lldb::eLanguageTypeSwift &&
+              valobj_type.GetByteSize(frame_sp.get()) == 0) {
+            // We don't need to materialize empty structs in Swift.
+            return;
+          }
           err.SetErrorStringWithFormat("couldn't get the value of %s: %s",
                                        m_variable_sp->GetName().AsCString(),
                                        extract_error.AsCString());
@@ -629,6 +656,16 @@ public:
         return;
       }
 
+      // In the case where the value is of Swift archetype type, resolve its
+      // dynamic type, because we may
+      // need to unbox the target.
+
+      CompilerType valobj_type = valobj_sp->GetCompilerType();
+
+      if (SwiftASTContext::IsArchetypeType(valobj_type)) {
+        valobj_sp = valobj_sp->GetDynamicValue(lldb::eDynamicDontRunTarget);
+      }
+
       lldb_private::DataExtractor data;
 
       Status extract_error;
@@ -637,6 +674,12 @@ public:
                         extract_error);
 
       if (!extract_error.Success()) {
+        if (valobj_type.GetMinimumLanguage() == lldb::eLanguageTypeSwift &&
+            valobj_type.GetByteSize(frame_sp.get()) == 0) {
+          // We don't need to dematerialize empty structs in Swift.
+          return;
+        }
+
         err.SetErrorStringWithFormat("couldn't get the data for variable %s",
                                      m_variable_sp->GetName().AsCString());
         return;
@@ -758,6 +801,7 @@ public:
 private:
   lldb::VariableSP m_variable_sp;
   bool m_is_reference;
+  bool m_is_archetype;
   lldb::addr_t m_temporary_allocation;
   size_t m_temporary_allocation_size;
   lldb::DataBufferSP m_original_data;
@@ -867,6 +911,11 @@ public:
       return;
     }
 
+    lldb::LanguageType lang =
+        (m_type.GetMinimumLanguage() == lldb::eLanguageTypeSwift)
+            ? lldb::eLanguageTypeSwift
+            : lldb::eLanguageTypeObjC_plus_plus;
+
     Status type_system_error;
     TypeSystem *type_system = target_sp->GetScratchTypeSystemForLanguage(
         &type_system_error, m_type.GetMinimumLanguage());
@@ -893,6 +942,17 @@ public:
                            ? m_delegate->GetName()
                            : persistent_state->GetNextPersistentVariableName();
 
+    lldb::ProcessSP process_sp =
+        map.GetBestExecutionContextScope()->CalculateProcess();
+
+    if (lang == lldb::eLanguageTypeSwift) {
+      SwiftLanguageRuntime *language_runtime =
+          process_sp->GetSwiftLanguageRuntime();
+
+      if (language_runtime && frame_sp)
+        m_type = language_runtime->DoArchetypeBindingForType(*frame_sp, m_type);
+    }
+
     lldb::ExpressionVariableSP ret = persistent_state->CreatePersistentVariable(
         exe_scope, name, m_type, map.GetByteOrder(), map.GetAddressByteSize());
 
@@ -903,9 +963,6 @@ public:
       return;
     }
 
-    lldb::ProcessSP process_sp =
-        map.GetBestExecutionContextScope()->CalculateProcess();
-
     if (m_delegate) {
       m_delegate->DidDematerialize(ret);
     }
@@ -1026,6 +1083,7 @@ private:
   CompilerType m_type;
   bool m_is_program_reference;
   bool m_keep_in_memory;
+  bool m_is_error_result;
 
   lldb::addr_t m_temporary_allocation;
   size_t m_temporary_allocation_size;
@@ -1334,8 +1392,13 @@ uint32_t Materializer::AddRegister(const RegisterInfo &register_info,
   return ret;
 }
 
+Materializer::Materializer(LLVMCastKind kind)
+    : m_kind(kind), m_dematerializer_wp(), m_current_offset(0),
+      m_struct_alignment(8) {}
+
 Materializer::Materializer()
-    : m_dematerializer_wp(), m_current_offset(0), m_struct_alignment(8) {}
+    : m_kind(eKindBasic), m_dematerializer_wp(), m_current_offset(0),
+      m_struct_alignment(8) {}
 
 Materializer::~Materializer() {
   DematerializerSP dematerializer_sp = m_dematerializer_wp.lock();
@@ -1425,6 +1488,9 @@ void Materializer::Dematerializer::Dematerialize(Status &error,
       if (!error.Success())
         break;
     }
+
+    // Okay now if there's an error and it is not empty, then report that,
+    // otherwise report the regular error...
   }
 
   Wipe();
diff --git a/source/Expression/REPL.cpp b/source/Expression/REPL.cpp
index 84a6405f3..e89e26f02 100644
--- a/source/Expression/REPL.cpp
+++ b/source/Expression/REPL.cpp
@@ -305,6 +305,13 @@ void REPL::IOHandlerInputComplete(IOHandler &io_handler, std::string &code) {
       PersistentExpressionState *persistent_state =
           m_target.GetPersistentExpressionStateForLanguage(GetLanguage());
 
+      if (!persistent_state)
+      {
+        error_sp->PutCString("error getting the expression "
+                             "context for the REPL.\n");
+        io_handler.SetIsDone(true);
+        return;
+      }
       const size_t var_count_before = persistent_state->GetSize();
 
       const char *expr_prefix = nullptr;
diff --git a/source/Expression/UserExpression.cpp b/source/Expression/UserExpression.cpp
index 3386bc457..c9d3e5fd0 100644
--- a/source/Expression/UserExpression.cpp
+++ b/source/Expression/UserExpression.cpp
@@ -208,6 +208,16 @@ lldb::ExpressionResults UserExpression::Evaluate(
       language = frame->GetLanguage();
   }
 
+  // If the language was not specified in the expression command,
+  // set it to the language in the target's properties if
+  // specified, else default to the langage for the frame.
+  if (language == lldb::eLanguageTypeUnknown) {
+    if (target->GetLanguage() != lldb::eLanguageTypeUnknown)
+      language = target->GetLanguage();
+    else if (StackFrame *frame = exe_ctx.GetFramePtr())
+      language = frame->GetLanguage();
+  }
+
   lldb::UserExpressionSP user_expression_sp(
       target->GetUserExpressionForLanguage(expr, full_prefix, language,
                                            desired_type, options, error));
@@ -234,9 +244,9 @@ lldb::ExpressionResults UserExpression::Evaluate(
 
   DiagnosticManager diagnostic_manager;
 
-  bool parse_success =
-      user_expression_sp->Parse(diagnostic_manager, exe_ctx, execution_policy,
-                                keep_expression_in_memory, generate_debug_info);
+  bool parse_success = user_expression_sp->Parse(
+      diagnostic_manager, exe_ctx, execution_policy, keep_expression_in_memory,
+      generate_debug_info, 0);
 
   // Calculate the fixed expression always, since we need it for errors.
   std::string tmp_fixed_expression;
@@ -259,7 +269,7 @@ lldb::ExpressionResults UserExpression::Evaluate(
       DiagnosticManager fixed_diagnostic_manager;
       parse_success = fixed_expression_sp->Parse(
           fixed_diagnostic_manager, exe_ctx, execution_policy,
-          keep_expression_in_memory, generate_debug_info);
+          keep_expression_in_memory, generate_debug_info, 0);
       if (parse_success) {
         diagnostic_manager.Clear();
         user_expression_sp = fixed_expression_sp;
diff --git a/source/Host/common/Editline.cpp b/source/Host/common/Editline.cpp
index 7b580dde6..89a73f502 100644
--- a/source/Host/common/Editline.cpp
+++ b/source/Host/common/Editline.cpp
@@ -1339,7 +1339,8 @@ bool Editline::GetLines(int first_line_number, StringList &lines,
   interrupted = m_editor_status == EditorStatus::Interrupted;
   if (!interrupted) {
     // Save the completed entry in history before returning
-    m_history_sp->Enter(CombineLines(m_input_lines).c_str());
+    if (m_input_lines.size() > 1 || !m_input_lines[0].empty())
+      m_history_sp->Enter(CombineLines(m_input_lines).c_str());
 
     lines = GetInputAsStringList();
   }
diff --git a/source/Host/common/File.cpp b/source/Host/common/File.cpp
index 6ee4e8947..04f0c1116 100644
--- a/source/Host/common/File.cpp
+++ b/source/Host/common/File.cpp
@@ -75,7 +75,8 @@ File::File(const char *path, uint32_t options, uint32_t permissions)
     : IOObject(eFDTypeFile, false), m_descriptor(kInvalidDescriptor),
       m_stream(kInvalidStream), m_options(), m_own_stream(false),
       m_is_interactive(eLazyBoolCalculate),
-      m_is_real_terminal(eLazyBoolCalculate) {
+      m_is_real_terminal(eLazyBoolCalculate),
+      m_supports_colors(eLazyBoolCalculate) {
   Open(path, options, permissions);
 }
 
@@ -83,9 +84,8 @@ File::File(const FileSpec &filespec, uint32_t options, uint32_t permissions)
     : IOObject(eFDTypeFile, false), m_descriptor(kInvalidDescriptor),
       m_stream(kInvalidStream), m_options(0), m_own_stream(false),
       m_is_interactive(eLazyBoolCalculate),
-      m_is_real_terminal(eLazyBoolCalculate)
-
-{
+      m_is_real_terminal(eLazyBoolCalculate),
+      m_supports_colors(eLazyBoolCalculate) {
   if (filespec) {
     Open(filespec.GetPath().c_str(), options, permissions);
   }
@@ -802,6 +802,7 @@ void File::CalculateInteractiveAndTerminal() {
   if (fd >= 0) {
     m_is_interactive = eLazyBoolNo;
     m_is_real_terminal = eLazyBoolNo;
+    m_supports_colors = eLazyBoolNo;
 #if defined(_WIN32)
     if (_isatty(fd)) {
       m_is_interactive = eLazyBoolYes;
diff --git a/source/Host/common/HostInfoBase.cpp b/source/Host/common/HostInfoBase.cpp
index a6c9e91a9..25a9836bc 100644
--- a/source/Host/common/HostInfoBase.cpp
+++ b/source/Host/common/HostInfoBase.cpp
@@ -57,9 +57,11 @@ struct HostInfoBaseFields {
 
   FileSpec m_lldb_so_dir;
   FileSpec m_lldb_support_exe_dir;
+  FileSpec m_lldb_support_file_dir;
   FileSpec m_lldb_headers_dir;
   FileSpec m_lldb_python_dir;
   FileSpec m_lldb_clang_resource_dir;
+  FileSpec m_lldb_swift_resource_dir;
   FileSpec m_lldb_system_plugin_dir;
   FileSpec m_lldb_user_plugin_dir;
   FileSpec m_lldb_process_tmp_dir;
@@ -142,6 +144,21 @@ bool HostInfoBase::GetLLDBPath(lldb::PathType type, FileSpec &file_spec) {
     if (success)
       result = &g_fields->m_lldb_support_exe_dir;
   } break;
+  case lldb::ePathTypeSupportFileDir: {
+    static llvm::once_flag g_once_flag;
+    static bool success = false;
+    std::call_once(g_once_flag, []() {
+      success = HostInfo::ComputeSupportFileDirectory(
+          g_fields->m_lldb_support_file_dir);
+      Log *log = lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_HOST);
+      if (log)
+        log->Printf(
+            "HostInfoBase::GetLLDBPath(ePathTypeSupportFileDir) => '%s'",
+            g_fields->m_lldb_support_file_dir.GetPath().c_str());
+    });
+    if (success)
+      result = &g_fields->m_lldb_support_file_dir;
+  } break;
   case lldb::ePathTypeHeaderDir: {
     static llvm::once_flag g_once_flag;
     static bool success = false;
@@ -183,6 +200,21 @@ bool HostInfoBase::GetLLDBPath(lldb::PathType type, FileSpec &file_spec) {
     if (success)
       result = &g_fields->m_lldb_clang_resource_dir;
   } break;
+  case lldb::ePathTypeSwiftDir: {
+    static llvm::once_flag g_once_flag;
+    static bool success = false;
+    std::call_once(g_once_flag, []() {
+      success =
+          HostInfo::ComputeSwiftDirectory(g_fields->m_lldb_swift_resource_dir);
+      Log *log = lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_HOST);
+      if (log)
+        log->Printf(
+            "HostInfoBase::GetLLDBPath(ePathTypeSwiftResourceDir) => '%s'",
+            g_fields->m_lldb_swift_resource_dir.GetPath().c_str());
+    });
+    if (success)
+      result = &g_fields->m_lldb_swift_resource_dir;
+  } break;
   case lldb::ePathTypeLLDBSystemPlugins: {
     static llvm::once_flag g_once_flag;
     static bool success = false;
@@ -276,6 +308,19 @@ bool HostInfoBase::ComputeSupportExeDirectory(FileSpec &file_spec) {
   return GetLLDBPath(lldb::ePathTypeLLDBShlibDir, file_spec);
 }
 
+bool HostInfoBase::ComputeSupportFileDirectory(FileSpec &file_spec) {
+  FileSpec temp_file_spec;
+
+  if (!GetLLDBPath(lldb::ePathTypeLLDBShlibDir, temp_file_spec))
+    return false;
+
+  temp_file_spec.AppendPathComponent("lldb");
+
+  file_spec = temp_file_spec;
+
+  return true;
+}
+
 bool HostInfoBase::ComputeProcessTempFileDirectory(FileSpec &file_spec) {
   FileSpec temp_file_spec;
   if (!HostInfo::ComputeGlobalTempFileDirectory(temp_file_spec))
@@ -324,7 +369,17 @@ bool HostInfoBase::ComputeSystemPluginsDirectory(FileSpec &file_spec) {
   return false;
 }
 
-bool HostInfoBase::ComputeClangDirectory(FileSpec &file_spec) { return false; }
+bool HostInfoBase::ComputeClangDirectory(FileSpec &file_spec) {
+  // TODO(zturner): Figure out how to compute the clang directory for all
+  // platforms.
+  return false;
+}
+
+bool HostInfoBase::ComputeSwiftDirectory(FileSpec &file_spec) {
+  // TODO(zturner): Figure out how to compute the swift directory for all
+  // platforms.
+  return false;
+}
 
 bool HostInfoBase::ComputeUserPluginsDirectory(FileSpec &file_spec) {
   // TODO(zturner): Figure out how to compute the user plugins directory for all
diff --git a/source/Host/macosx/HostInfoMacOSX.mm b/source/Host/macosx/HostInfoMacOSX.mm
index 8774c76ef..b5a8de5fb 100644
--- a/source/Host/macosx/HostInfoMacOSX.mm
+++ b/source/Host/macosx/HostInfoMacOSX.mm
@@ -178,6 +178,11 @@ bool HostInfoMacOSX::ComputeSupportExeDirectory(FileSpec &file_spec) {
   return (bool)file_spec.GetDirectory();
 }
 
+bool HostInfoMacOSX::ComputeSupportFileDirectory(FileSpec &file_spec) {
+  // The bundle's Resources directory, just like for executables
+  return HostInfoMacOSX::ComputeSupportExeDirectory(file_spec);
+}
+
 bool HostInfoMacOSX::ComputeHeaderDirectory(FileSpec &file_spec) {
   FileSpec lldb_file_spec;
   if (!HostInfo::GetLLDBPath(lldb::ePathTypeLLDBShlibDir, lldb_file_spec))
@@ -245,6 +250,26 @@ bool HostInfoMacOSX::ComputeClangDirectory(FileSpec &file_spec) {
   return true;
 }
 
+bool HostInfoMacOSX::ComputeSwiftDirectory(FileSpec &file_spec) {
+  FileSpec lldb_file_spec;
+  if (!GetLLDBPath(lldb::ePathTypeLLDBShlibDir, lldb_file_spec))
+    return false;
+
+  std::string raw_path = lldb_file_spec.GetPath();
+
+  size_t framework_pos = raw_path.find("LLDB.framework");
+  if (framework_pos == std::string::npos)
+    return HostInfoPosix::ComputeSwiftDirectory(file_spec);
+
+  if (framework_pos != std::string::npos) {
+    framework_pos += strlen("LLDB.framework");
+    raw_path.resize(framework_pos);
+    raw_path.append("/Resources/Swift");
+  }
+  file_spec.SetFile(raw_path.c_str(), true);
+  return true;
+}
+
 bool HostInfoMacOSX::ComputeSystemPluginsDirectory(FileSpec &file_spec) {
   FileSpec lldb_file_spec;
   if (!GetLLDBPath(lldb::ePathTypeLLDBShlibDir, lldb_file_spec))
diff --git a/source/Host/macosx/Symbols.cpp b/source/Host/macosx/Symbols.cpp
index 9d1e8fe96..301106ddf 100644
--- a/source/Host/macosx/Symbols.cpp
+++ b/source/Host/macosx/Symbols.cpp
@@ -517,10 +517,12 @@ bool Symbols::DownloadObjectAndSymbolFile(ModuleSpec &module_spec,
 
       StreamString command;
       if (!uuid_str.empty())
-        command.Printf("%s --ignoreNegativeCache --copyExecutable %s",
+        command.Printf("%s --ignoreNegativeCache --copyExecutable --databases "
+                       "bursar.apple.com,uuidsymmap.apple.com %s",
                        g_dsym_for_uuid_exe_path, uuid_str.c_str());
       else if (file_path[0] != '\0')
-        command.Printf("%s --ignoreNegativeCache --copyExecutable %s",
+        command.Printf("%s --ignoreNegativeCache --copyExecutable --databases "
+                       "bursar.apple.com,uuidsymmap.apple.com %s",
                        g_dsym_for_uuid_exe_path, file_path);
 
       if (!command.GetString().empty()) {
diff --git a/source/Host/posix/HostInfoPosix.cpp b/source/Host/posix/HostInfoPosix.cpp
index da9e1fb36..606414675 100644
--- a/source/Host/posix/HostInfoPosix.cpp
+++ b/source/Host/posix/HostInfoPosix.cpp
@@ -165,6 +165,19 @@ bool HostInfoPosix::ComputePathRelativeToLibrary(FileSpec &file_spec,
   return (bool)file_spec.GetDirectory();
 }
 
+bool HostInfoPosix::ComputeSupportFileDirectory(FileSpec &file_spec) {
+  FileSpec temp_file_spec;
+
+  if (!GetLLDBPath(lldb::ePathTypeLLDBShlibDir, temp_file_spec))
+    return false;
+
+  temp_file_spec.AppendPathComponent("lldb");
+
+  file_spec = temp_file_spec;
+
+  return true;
+}
+
 bool HostInfoPosix::ComputeSupportExeDirectory(FileSpec &file_spec) {
   return ComputePathRelativeToLibrary(file_spec, "/bin");
 }
@@ -222,6 +235,17 @@ bool HostInfoPosix::ComputePythonDirectory(FileSpec &file_spec) {
 #endif
 }
 
+bool HostInfoPosix::ComputeSwiftDirectory(FileSpec &file_spec) {
+  FileSpec lldb_file_spec;
+  if (!GetLLDBPath(lldb::ePathTypeLLDBShlibDir, lldb_file_spec))
+    return false;
+
+  lldb_file_spec.AppendPathComponent("swift");
+
+  file_spec = lldb_file_spec;
+  return true;
+}
+
 bool HostInfoPosix::GetEnvironmentVar(const std::string &var_name,
                                       std::string &var) {
   if (const char *pvar = ::getenv(var_name.c_str())) {
diff --git a/source/Initialization/CMakeLists.txt b/source/Initialization/CMakeLists.txt
index 7a100588e..0d33d91dc 100644
--- a/source/Initialization/CMakeLists.txt
+++ b/source/Initialization/CMakeLists.txt
@@ -26,6 +26,7 @@ add_lldb_library(lldbInitialization
     lldbPluginObjectFileELF
     lldbPluginObjectFilePECOFF
     lldbPluginProcessGDBRemote
+    lldbPluginExpressionParserSwift
     ${EXTRA_PLUGINS}
     ${LLDB_SYSTEM_LIBS}
   LINK_COMPONENTS
diff --git a/source/Initialization/SystemInitializerCommon.cpp b/source/Initialization/SystemInitializerCommon.cpp
index e76ba4122..91d32694c 100644
--- a/source/Initialization/SystemInitializerCommon.cpp
+++ b/source/Initialization/SystemInitializerCommon.cpp
@@ -9,6 +9,10 @@
 
 #include "lldb/Initialization/SystemInitializerCommon.h"
 
+#include "Plugins/DynamicLoader/MacOSX-DYLD/DynamicLoaderMacOSXDYLD.h"
+#include "Plugins/DynamicLoader/POSIX-DYLD/DynamicLoaderPOSIXDYLD.h"
+#include "Plugins/DynamicLoader/Windows-DYLD/DynamicLoaderWindowsDYLD.h"
+#include "Plugins/ExpressionParser/Swift/SwiftREPL.h"
 #include "Plugins/Instruction/ARM/EmulateInstructionARM.h"
 #include "Plugins/Instruction/MIPS/EmulateInstructionMIPS.h"
 #include "Plugins/Instruction/MIPS64/EmulateInstructionMIPS64.h"
@@ -19,6 +23,9 @@
 #include "Plugins/Process/gdb-remote/ProcessGDBRemoteLog.h"
 #include "lldb/Host/Host.h"
 #include "lldb/Host/HostInfo.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/GoASTContext.h"
+#include "lldb/Symbol/SwiftASTContext.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/Timer.h"
 
@@ -78,6 +85,12 @@ void SystemInitializerCommon::Initialize() {
   process_gdb_remote::ProcessGDBRemoteLog::Initialize();
 
   // Initialize plug-ins
+  ClangASTContext::Initialize();
+  GoASTContext::Initialize();
+  SwiftASTContext::Initialize();
+
+  SwiftREPL::Initialize();
+
   ObjectContainerBSDArchive::Initialize();
   ObjectFileELF::Initialize();
   ObjectFilePECOFF::Initialize();
@@ -109,6 +122,12 @@ void SystemInitializerCommon::Terminate() {
   ObjectFileELF::Terminate();
   ObjectFilePECOFF::Terminate();
 
+  ClangASTContext::Terminate();
+  GoASTContext::Terminate();
+  SwiftASTContext::Terminate();
+
+  SwiftREPL::Terminate();
+
   EmulateInstructionARM::Terminate();
   EmulateInstructionMIPS::Terminate();
   EmulateInstructionMIPS64::Terminate();
diff --git a/source/Interpreter/Args.cpp b/source/Interpreter/Args.cpp
index a23ba3094..0a822766d 100644
--- a/source/Interpreter/Args.cpp
+++ b/source/Interpreter/Args.cpp
@@ -1317,6 +1317,88 @@ void Args::ParseArgsForCompletion(Options &options,
   }
 }
 
+bool Args::GetOptionValueAsString(const char *option, std::string &value) {
+  for (size_t ai = 0, ae = GetArgumentCount(); ai != ae; ++ai) {
+    const char *arg = GetArgumentAtIndex(ai);
+    const char *option_loc = strstr(arg, option);
+
+    const bool is_long_option = (option[0] == '-' && option[1] == '-');
+
+    if (option_loc == arg) {
+      const char *after_option = option_loc + strlen(option);
+
+      switch (*after_option) {
+      default:
+        if (is_long_option) {
+          continue;
+        } else {
+          value = after_option;
+          return true;
+        }
+        break;
+      case '=':
+        value = after_option + 1;
+        return true;
+      case '\0': {
+        const char *next_value = GetArgumentAtIndex(ai + 1);
+        if (next_value) {
+          value = next_value;
+          return true;
+        } else {
+          return false;
+        }
+      }
+      }
+    }
+  }
+
+  return false;
+}
+
+int Args::GetOptionValuesAsStrings(const char *option,
+                                   std::vector<std::string> &value) {
+  int ret = 0;
+
+  for (size_t ai = 0, ae = GetArgumentCount(); ai != ae; ++ai) {
+    const char *arg = GetArgumentAtIndex(ai);
+    const char *option_loc = strstr(arg, option);
+
+    const bool is_long_option = (option[0] == '-' && option[1] == '-');
+
+    if (option_loc == arg) {
+      const char *after_option = option_loc + strlen(option);
+
+      switch (*after_option) {
+      default:
+        if (is_long_option) {
+          continue;
+        } else {
+          value.push_back(after_option);
+          ++ret;
+        }
+        break;
+      case '=':
+        value.push_back(after_option + 1);
+        ++ret;
+        break;
+      case '\0': {
+        const char *next_value = GetArgumentAtIndex(ai + 1);
+        if (next_value) {
+          value.push_back(next_value);
+          ++ret;
+          ++ai;
+          break;
+        } else {
+          return ret;
+        }
+      }
+      }
+    }
+  }
+
+  return ret;
+}
+
 void Args::EncodeEscapeSequences(const char *src, std::string &dst) {
   dst.clear();
   if (src) {
diff --git a/source/Interpreter/CommandInterpreter.cpp b/source/Interpreter/CommandInterpreter.cpp
index 986be7ffb..2bb6ef74b 100644
--- a/source/Interpreter/CommandInterpreter.cpp
+++ b/source/Interpreter/CommandInterpreter.cpp
@@ -319,12 +319,16 @@ void CommandInterpreter::Initialize() {
     AddAlias("p", cmd_obj_sp, "--")->SetHelpLong("");
     AddAlias("print", cmd_obj_sp, "--")->SetHelpLong("");
     AddAlias("call", cmd_obj_sp, "--")->SetHelpLong("");
+
     if (auto po = AddAlias("po", cmd_obj_sp, "-O --")) {
       po->SetHelp("Evaluate an expression on the current thread.  Displays any "
                   "returned value with formatting "
                   "controlled by the type's author.");
       po->SetHelpLong("");
     }
+
+    AddAlias("repl", cmd_obj_sp, "--repl -- ");
+
     AddAlias("parray", cmd_obj_sp, "--element-count %1 --")->SetHelpLong("");
     AddAlias("poarray", cmd_obj_sp,
              "--object-description --element-count %1 --")
@@ -726,6 +730,8 @@ void CommandInterpreter::LoadCommandDictionary() {
         list_regex_cmd_ap->AddRegexCommand(
             "^-([[:digit:]]+)[[:space:]]*$",
             "source list --reverse --count %1") &&
+        list_regex_cmd_ap->AddRegexCommand("^([^.]+)\\.([^.]+)$",
+                                           "source list --file \"%1.%2\"") &&
         list_regex_cmd_ap->AddRegexCommand("^(.+)$",
                                            "source list --name \"%1\"") &&
         list_regex_cmd_ap->AddRegexCommand("^$", "source list")) {
diff --git a/source/Interpreter/OptionGroupValueObjectDisplay.cpp b/source/Interpreter/OptionGroupValueObjectDisplay.cpp
index ce27d948c..ac820faab 100644
--- a/source/Interpreter/OptionGroupValueObjectDisplay.cpp
+++ b/source/Interpreter/OptionGroupValueObjectDisplay.cpp
@@ -46,7 +46,7 @@ static OptionDefinition g_option_table[] = {
      nullptr, 0, eArgTypeNone, "Show variable location information."},
     {LLDB_OPT_SET_1, false, "object-description", 'O',
      OptionParser::eNoArgument, nullptr, nullptr, 0, eArgTypeNone,
-     "Print as an Objective-C object."},
+     "Display using a language-specific description API, if possible."},
     {LLDB_OPT_SET_1, false, "ptr-depth", 'P', OptionParser::eRequiredArgument,
      nullptr, nullptr, 0, eArgTypeCount, "The number of pointers to be "
                                          "traversed when dumping values "
diff --git a/source/Plugins/ABI/SysV-x86_64/ABISysV_x86_64.cpp b/source/Plugins/ABI/SysV-x86_64/ABISysV_x86_64.cpp
index 10bbae566..5e40a252a 100644
--- a/source/Plugins/ABI/SysV-x86_64/ABISysV_x86_64.cpp
+++ b/source/Plugins/ABI/SysV-x86_64/ABISysV_x86_64.cpp
@@ -1516,7 +1516,8 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectSimple(
     if (success)
       return_valobj_sp = ValueObjectConstResult::Create(
           thread.GetStackFrameAtIndex(0).get(), value, ConstString(""));
-  } else if (type_flags & eTypeIsPointer) {
+  } else if ((type_flags & eTypeIsPointer) ||
+             (type_flags & eTypeInstanceIsPointer)) {
     unsigned rax_id =
         reg_ctx->GetRegisterInfoByName("rax", 0)->kinds[eRegisterKindLLDB];
     value.GetScalar() =
@@ -1596,6 +1597,243 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectSimple(
   return return_valobj_sp;
 }
 
+static bool ExtractBytesFromRegisters(
+    ExecutionContext &exe_ctx, CompilerType &clang_type,
+    const DataExtractor &rax_data, const DataExtractor &rdx_data,
+    const DataExtractor &rcx_data, const DataExtractor &r8_data,
+    const DataExtractor &xmm0_data,
+    const DataExtractor &xmm1_data, const DataExtractor &xmm2_data,
+    const ByteOrder byte_order, DataBufferSP &data_sp,
+    uint32_t data_byte_offset, uint32_t &integer_bytes, uint32_t &fp_bytes,
+    bool &is_memory) {
+  const bool is_swift_type = (clang_type.GetTypeInfo() & eTypeIsSwift);
+  const uint32_t num_children = clang_type.GetNumFields();
+  for (uint32_t idx = 0; idx < num_children; ++idx) {
+    std::string name;
+    bool is_signed;
+
+    const bool transparent_pointers = false;
+    const bool omit_empty_base_classes = true;
+    const bool ignore_array_bounds = false;
+    uint32_t child_byte_size = 0;
+    int32_t child_byte_offset = 0;
+    uint32_t child_bitfield_bit_size = 0;
+    uint32_t child_bitfield_bit_offset = 0;
+    bool child_is_base_class = false;
+    bool child_is_deref_of_parent = false;
+    uint64_t language_flags;
+    CompilerType field_clang_type = clang_type.GetChildCompilerTypeAtIndex(
+        &exe_ctx, idx, transparent_pointers, omit_empty_base_classes,
+        ignore_array_bounds, name, child_byte_size, child_byte_offset,
+        child_bitfield_bit_size, child_bitfield_bit_offset, child_is_base_class,
+        child_is_deref_of_parent, nullptr, language_flags);
+
+    const uint64_t field_bit_offset = child_byte_offset * 8;
+    const size_t field_bit_width =
+        child_byte_size * 8 + child_bitfield_bit_size;
+
+    // If there are any unaligned fields, this is stored in memory.
+    if (field_bit_offset % field_bit_width != 0) {
+      is_memory = true;
+      return false;
+    }
+
+    uint32_t field_byte_width = field_bit_width / 8;
+    uint32_t field_byte_offset = field_bit_offset / 8 + data_byte_offset;
+
+    const DataExtractor *copy_from_extractor = NULL;
+    uint32_t copy_from_offset = 0;
+    bool already_copied = false;
+
+    const uint32_t field_type_flags = field_clang_type.GetTypeInfo();
+    const bool is_swift_enum = (field_type_flags & eTypeIsEnumeration) &&
+                               (field_type_flags & eTypeIsSwift);
+    // HACK: Swift enums are really hard to figure out the return value ABI for.
+    // We really need compiler assistance but we don't have it. We need
+    // Swift.Dictionary
+    // objects to work though for return values, so we check for that simple
+    // case here
+    // and just assume that of the value is less than a pointer size that it can
+    // be treated
+    // as a integer type...
+    const bool is_simple_swift_enum = is_swift_enum && field_byte_width <= 8;
+
+    if (field_type_flags & eTypeIsInteger ||
+        field_type_flags & eTypeIsPointer ||
+        field_type_flags & eTypeIsReference ||
+        (field_type_flags & eTypeInstanceIsPointer &&
+         child_is_base_class == false) ||
+        is_simple_swift_enum) {
+          if (integer_bytes < 8) {
+            if (integer_bytes + field_byte_width <= 8) {
+              // This is in RAX, copy from register to our result structure:
+              copy_from_extractor = &rax_data;
+              copy_from_offset = integer_bytes;
+              integer_bytes += field_byte_width;
+            } else {
+              // The next field wouldn't fit in the remaining space, so we
+              // pushed it to rdx.
+              copy_from_extractor = &rdx_data;
+              copy_from_offset = 0;
+              integer_bytes = 8 + field_byte_width;
+            }
+          } else if (integer_bytes < 16) {
+            if (integer_bytes + field_byte_width <= 16) {
+              copy_from_extractor = &rdx_data;
+              copy_from_offset = integer_bytes - 8;
+              integer_bytes += field_byte_width;
+            } else if (is_swift_type) {
+              // This one got pushed to rcx
+              copy_from_extractor = &rcx_data;
+              copy_from_offset = 0;
+              integer_bytes = 8 + field_byte_width;
+            }
+          } else if (is_swift_type && integer_bytes < 24) {
+            if (integer_bytes + field_byte_width <= 24) {
+              copy_from_extractor = &rcx_data;
+              copy_from_offset = integer_bytes - 16;
+              integer_bytes += field_byte_width;
+            } else {
+              // This one got pushed to r8:
+              copy_from_extractor = &r8_data;
+              copy_from_offset = 0;
+              integer_bytes = 16 + field_byte_width;
+            }
+          } else if (is_swift_type && integer_bytes + field_byte_width <= 32) {
+            copy_from_extractor = &r8_data;
+            copy_from_offset = integer_bytes - 24;
+            integer_bytes += field_byte_width;
+          } else {
+            // The last field didn't fit.  I can't see how that would happen w/o
+            // the overall size being
+            // greater than 16 bytes.  For now, return a nullptr return value
+            // object.
+            return false;
+          }
+    } else if (field_type_flags & eTypeIsFloat ||
+               field_type_flags & eTypeIsVector) {
+      // Structs with long doubles are always passed in memory.
+      if (field_bit_width == 128) {
+        is_memory = true;
+        break;
+      } else if (field_bit_width == 64) {
+        // These have to be in a single xmm register.
+        if (fp_bytes == 0)
+          copy_from_extractor = &xmm0_data;
+        else if (fp_bytes >= 8)
+          copy_from_extractor = &xmm1_data;
+        else if (fp_bytes >= 16)
+          copy_from_extractor = &xmm2_data;
+
+        copy_from_offset = 0;
+        fp_bytes += field_byte_width;
+      } else if (field_bit_width == 32) {
+        // This one is kind of complicated.  If we are in an "eightbyte" with
+        // another float, we'll
+        // be stuffed into an xmm register with it.  If we are in an "eightbyte"
+        // with one or more ints,
+        // then we will be stuffed into the appropriate GPR with them.
+        bool in_gpr;
+        if (field_byte_offset % 8 == 0) {
+          // We are at the beginning of one of the eightbytes, so check the next
+          // element (if any)
+          if (idx == num_children - 1)
+            in_gpr = false;
+          else {
+            uint64_t next_field_bit_offset = 0;
+            CompilerType next_field_clang_type = clang_type.GetFieldAtIndex(
+                idx + 1, name, &next_field_bit_offset, NULL, NULL);
+            if (next_field_clang_type.IsIntegerType(is_signed))
+              in_gpr = true;
+            else {
+              copy_from_offset = 0;
+              in_gpr = false;
+            }
+          }
+
+        } else if (field_byte_offset % 4 == 0) {
+          // We are inside of an eightbyte, so see if the field before us is
+          // floating point:
+          // This could happen if somebody put padding in the structure.
+          if (idx == 0)
+            in_gpr = false;
+          else {
+            uint64_t prev_field_bit_offset = 0;
+            CompilerType prev_field_clang_type = clang_type.GetFieldAtIndex(
+                idx - 1, name, &prev_field_bit_offset, NULL, NULL);
+            if (prev_field_clang_type.IsIntegerType(is_signed))
+              in_gpr = true;
+            else {
+              copy_from_offset = 4;
+              in_gpr = false;
+            }
+          }
+
+        } else {
+          is_memory = true;
+          return false;
+        }
+
+        // Okay, we've figured out whether we are in GPR or XMM, now figure out
+        // which one.
+        if (in_gpr) {
+          if (integer_bytes < 8) {
+            // This is in RAX, copy from register to our result structure:
+            copy_from_extractor = &rax_data;
+            copy_from_offset = integer_bytes;
+            integer_bytes += field_byte_width;
+          } else {
+            copy_from_extractor = &rdx_data;
+            copy_from_offset = integer_bytes - 8;
+            integer_bytes += field_byte_width;
+          }
+        } else {
+          if (fp_bytes < 8)
+            copy_from_extractor = &xmm0_data;
+          else if (fp_bytes < 16)
+            copy_from_extractor = &xmm1_data;
+          else if (is_swift_type && fp_bytes < 24)
+            copy_from_extractor = &xmm2_data;
+
+          fp_bytes += field_byte_width;
+        }
+      }
+    } else if (field_type_flags & eTypeHasChildren) {
+      // Swift enums are unions and we can't just iterate through the fields. We
+      // need
+      // help from the compiler to do enums correctly.
+      if (is_swift_enum)
+        return false;
+
+      if (ExtractBytesFromRegisters(
+              exe_ctx, field_clang_type, rax_data, rdx_data, rcx_data, r8_data,
+              xmm0_data, xmm1_data, xmm2_data, byte_order, data_sp,
+              data_byte_offset + child_byte_offset, integer_bytes, fp_bytes,
+              is_memory) == false) {
+        return false;
+      } else {
+        already_copied = true;
+      }
+    }
+
+    // These two tests are just sanity checks.  If I somehow get the
+    // type calculation wrong above it is better to just return nothing
+    // than to assert or crash.
+    if (!already_copied)
+    {
+      if (copy_from_extractor &&
+          copy_from_offset + field_byte_width <=
+              copy_from_extractor->GetByteSize()) {
+        copy_from_extractor->CopyByteOrderedData(
+            copy_from_offset, field_byte_width,
+            data_sp->GetBytes() + field_byte_offset, field_byte_width,
+            byte_order);
+      }
+    }
+  }
+  return true;
+}
+
 ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
     Thread &thread, CompilerType &return_compiler_type) const {
   ValueObjectSP return_valobj_sp;
@@ -1616,38 +1854,70 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
   if (return_compiler_type.IsAggregateType()) {
     Target *target = exe_ctx.GetTargetPtr();
     bool is_memory = true;
-    if (bit_width <= 128) {
-      ByteOrder target_byte_order = target->GetArchitecture().GetByteOrder();
-      DataBufferSP data_sp(new DataBufferHeap(16, 0));
-      DataExtractor return_ext(data_sp, target_byte_order,
-                               target->GetArchitecture().GetAddressByteSize());
-
+    const bool is_swift_type =
+        (return_compiler_type.GetTypeInfo() & eTypeIsSwift);
+    uint32_t max_register_value_bit_width = 128;
+    if (is_swift_type)
+      max_register_value_bit_width += 128;
+    if (bit_width <= max_register_value_bit_width) {
+      const ArchSpec &arch = target->GetArchitecture();
+      ByteOrder byte_order = arch.GetByteOrder();
+      DataBufferSP data_sp(
+          new DataBufferHeap(max_register_value_bit_width / 8, 0));
+      DataExtractor return_ext(data_sp, byte_order, arch.GetAddressByteSize());
       const RegisterInfo *rax_info =
           reg_ctx_sp->GetRegisterInfoByName("rax", 0);
       const RegisterInfo *rdx_info =
           reg_ctx_sp->GetRegisterInfoByName("rdx", 0);
+      const RegisterInfo *rcx_info =
+          reg_ctx_sp->GetRegisterInfoByName("rcx", 0);
+      const RegisterInfo *r8_info =
+          reg_ctx_sp->GetRegisterInfoByName("r8", 0);
       const RegisterInfo *xmm0_info =
           reg_ctx_sp->GetRegisterInfoByName("xmm0", 0);
       const RegisterInfo *xmm1_info =
           reg_ctx_sp->GetRegisterInfoByName("xmm1", 0);
-
-      RegisterValue rax_value, rdx_value, xmm0_value, xmm1_value;
+      const RegisterInfo *xmm2_info =
+          reg_ctx_sp->GetRegisterInfoByName("xmm2", 0);
+
+      RegisterValue rax_value;
+      RegisterValue rdx_value;
+      RegisterValue rcx_value;
+      RegisterValue r8_value;
+      RegisterValue xmm0_value;
+      RegisterValue xmm1_value;
+      RegisterValue xmm2_value;
       reg_ctx_sp->ReadRegister(rax_info, rax_value);
       reg_ctx_sp->ReadRegister(rdx_info, rdx_value);
+      reg_ctx_sp->ReadRegister(rcx_info, rcx_value);
+      reg_ctx_sp->ReadRegister(r8_info,  r8_value);
       reg_ctx_sp->ReadRegister(xmm0_info, xmm0_value);
       reg_ctx_sp->ReadRegister(xmm1_info, xmm1_value);
+      reg_ctx_sp->ReadRegister(xmm2_info, xmm2_value);
 
-      DataExtractor rax_data, rdx_data, xmm0_data, xmm1_data;
+      DataExtractor rax_data;
+      DataExtractor rdx_data;
+      DataExtractor rcx_data;
+      DataExtractor r8_data;
+      DataExtractor xmm0_data;
+      DataExtractor xmm1_data;
+      DataExtractor xmm2_data;
 
       rax_value.GetData(rax_data);
       rdx_value.GetData(rdx_data);
+      rcx_value.GetData(rcx_data);
+      r8_value.GetData(r8_data);
+
       xmm0_value.GetData(xmm0_data);
       xmm1_value.GetData(xmm1_data);
+      xmm2_value.GetData(xmm2_data);
 
       uint32_t fp_bytes =
           0; // Tracks how much of the xmm registers we've consumed so far
       uint32_t integer_bytes =
           0; // Tracks how much of the rax/rds registers we've consumed so far
+      uint32_t data_byte_offset =
+          0; // The offset into "data_sp" where to place the next chunk of data
 
       const uint32_t num_children = return_compiler_type.GetNumFields();
 
@@ -1659,12 +1929,34 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
         uint64_t field_bit_offset = 0;
         bool is_signed;
         bool is_complex;
+        bool already_copied = false;
         uint32_t count;
 
         CompilerType field_compiler_type = return_compiler_type.GetFieldAtIndex(
             idx, name, &field_bit_offset, nullptr, nullptr);
         const size_t field_bit_width = field_compiler_type.GetBitSize(&thread);
 
+        bool child_is_base_class = false;
+        int32_t child_byte_offset = 0;
+
+        {
+          const bool transparent_pointers = false;
+          const bool omit_empty_base_classes = true;
+          const bool ignore_array_bounds = false;
+          uint32_t child_byte_size = 0;
+          uint32_t child_bitfield_bit_size = 0;
+          uint32_t child_bitfield_bit_offset = 0;
+          bool child_is_deref_of_parent = false;
+          uint64_t language_flags;
+          CompilerType field_compiler_type =
+              return_compiler_type.GetChildCompilerTypeAtIndex(
+                  &exe_ctx, idx, transparent_pointers, omit_empty_base_classes,
+                  ignore_array_bounds, name, child_byte_size, child_byte_offset,
+                  child_bitfield_bit_size, child_bitfield_bit_offset,
+                  child_is_base_class, child_is_deref_of_parent, nullptr,
+                  language_flags);
+        }
+
         // if we don't know the size of the field (e.g. invalid type), just bail
         // out
         if (field_bit_width == 0)
@@ -1682,8 +1974,27 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
         DataExtractor *copy_from_extractor = nullptr;
         uint32_t copy_from_offset = 0;
 
+        const uint32_t field_type_flags = field_compiler_type.GetTypeInfo();
+        const bool is_swift_enum = (field_type_flags & eTypeIsEnumeration) &&
+                                   (field_type_flags & eTypeIsSwift);
+        // HACK: Swift enums are really hard to figure out the return value ABI
+        // for.
+        // We really need compiler assistance but we don't have it. We need
+        // Swift.Dictionary
+        // objects to work though for return values, so we check for that simple
+        // case here
+        // and just assume that of the value is less than a pointer size that it
+        // can be treated
+        // as a integer type...
+        const bool is_simple_swift_enum =
+            is_swift_enum && field_byte_width <= 8;
+
         if (field_compiler_type.IsIntegerOrEnumerationType(is_signed) ||
-            field_compiler_type.IsPointerType()) {
+            field_compiler_type.IsPointerType() ||
+            field_compiler_type.IsReferenceType() ||
+            (field_type_flags & eTypeInstanceIsPointer &&
+             child_is_base_class == false) ||
+            is_simple_swift_enum) {
           if (integer_bytes < 8) {
             if (integer_bytes + field_byte_width <= 8) {
               // This is in RAX, copy from register to our result structure:
@@ -1697,9 +2008,31 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
               copy_from_offset = 0;
               integer_bytes = 8 + field_byte_width;
             }
-          } else if (integer_bytes + field_byte_width <= 16) {
-            copy_from_extractor = &rdx_data;
-            copy_from_offset = integer_bytes - 8;
+          } else if (integer_bytes < 16) {
+            if (integer_bytes + field_byte_width <= 16) {
+              copy_from_extractor = &rdx_data;
+              copy_from_offset = integer_bytes - 8;
+              integer_bytes += field_byte_width;
+            } else if (is_swift_type) {
+              // This one got pushed to rcx
+              copy_from_extractor = &rcx_data;
+              copy_from_offset = 0;
+              integer_bytes = 8 + field_byte_width;
+            }
+          } else if (is_swift_type && integer_bytes < 24) {
+            if (integer_bytes + field_byte_width <= 24) {
+              copy_from_extractor = &rcx_data;
+              copy_from_offset = integer_bytes - 16;
+              integer_bytes += field_byte_width;
+            } else {
+              // This one got pushed to r8:
+              copy_from_extractor = &r8_data;
+              copy_from_offset = 0;
+              integer_bytes = 16 + field_byte_width;
+            }
+          } else if (is_swift_type && integer_bytes + field_byte_width <= 32) {
+            copy_from_extractor = &r8_data;
+            copy_from_offset = integer_bytes - 24;
             integer_bytes += field_byte_width;
           } else {
             // The last field didn't fit.  I can't see how that would happen w/o
@@ -1795,21 +2128,39 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
               fp_bytes += field_byte_width;
             }
           }
+        } else if (field_type_flags & eTypeHasChildren) {
+          // Swift enums are unions and we can't just iterate through the
+          // fields. We need
+          // help from the compiler to do enums correctly.
+          if (is_swift_enum)
+            return return_valobj_sp;
+
+          if (ExtractBytesFromRegisters(
+                  exe_ctx, field_compiler_type, rax_data, rdx_data, rcx_data, r8_data,
+                  xmm0_data, xmm1_data, xmm2_data, byte_order, data_sp,
+                  data_byte_offset + child_byte_offset, integer_bytes, fp_bytes,
+                  is_memory) == false) {
+            return return_valobj_sp;
+          } else
+            copy_from_extractor = &return_ext;
+            already_copied = true;
         }
 
+        if (!already_copied) {
         // These two tests are just sanity checks.  If I somehow get the
         // type calculation wrong above it is better to just return nothing
         // than to assert or crash.
-        if (!copy_from_extractor)
-          return return_valobj_sp;
-        if (copy_from_offset + field_byte_width >
-            copy_from_extractor->GetByteSize())
-          return return_valobj_sp;
+          if (!copy_from_extractor)
+            return return_valobj_sp;
+          if (copy_from_offset + field_byte_width >
+              copy_from_extractor->GetByteSize())
+            return return_valobj_sp;
 
-        copy_from_extractor->CopyByteOrderedData(
-            copy_from_offset, field_byte_width,
-            data_sp->GetBytes() + field_byte_offset, field_byte_width,
-            target_byte_order);
+          copy_from_extractor->CopyByteOrderedData(
+              copy_from_offset, field_byte_width,
+              data_sp->GetBytes() + field_byte_offset, field_byte_width,
+              byte_order);
+        }
       }
 
       if (!is_memory) {
@@ -1820,15 +2171,15 @@ ValueObjectSP ABISysV_x86_64::GetReturnValueObjectImpl(
       }
     }
 
-    // FIXME: This is just taking a guess, rax may very well no longer hold the
-    // return storage location.
-    // If we are going to do this right, when we make a new frame we should
-    // check to see if it uses a memory
-    // return, and if we are at the first instruction and if so stash away the
-    // return location.  Then we would
-    // only return the memory return value if we know it is valid.
+    // The SysV x86_64 ABI specifies that the return address for MEMORY
+    // objects be placed in rax on exit from the function.  However, the
+    // Swift variant of the ABI does not do that.  It passes the value in
+    // in rax, but relies on the caller knowing where it allocated the space
+    // on the way out.  Since rax is volatile, there's no way for me to recover
+    // the original value on the way out, so for Swift I can't reconstruct
+    // the return value from a MEMORY struct.
 
-    if (is_memory) {
+    if (is_memory && !is_swift_type) {
       unsigned rax_id =
           reg_ctx_sp->GetRegisterInfoByName("rax", 0)->kinds[eRegisterKindLLDB];
       lldb::addr_t storage_addr =
diff --git a/source/Plugins/Disassembler/llvm/CMakeLists.txt b/source/Plugins/Disassembler/llvm/CMakeLists.txt
index a25a436d4..fe07aba09 100644
--- a/source/Plugins/Disassembler/llvm/CMakeLists.txt
+++ b/source/Plugins/Disassembler/llvm/CMakeLists.txt
@@ -11,4 +11,5 @@ add_lldb_library(lldbPluginDisassemblerLLVM PLUGIN
     MCDisassembler
     RuntimeDyld
     Support
+    MCDisassembler
   )
diff --git a/source/Plugins/ExpressionParser/CMakeLists.txt b/source/Plugins/ExpressionParser/CMakeLists.txt
index dc0540ad3..600c0d312 100644
--- a/source/Plugins/ExpressionParser/CMakeLists.txt
+++ b/source/Plugins/ExpressionParser/CMakeLists.txt
@@ -1,2 +1,3 @@
 add_subdirectory(Clang)
 add_subdirectory(Go)
+add_subdirectory(Swift)
diff --git a/source/Plugins/ExpressionParser/Clang/ClangASTSource.cpp b/source/Plugins/ExpressionParser/Clang/ClangASTSource.cpp
index 762279177..4e4157be1 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangASTSource.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangASTSource.cpp
@@ -477,10 +477,13 @@ void ClangASTSource::FindExternalLexicalDecls(
   }
 
   if (TagDecl *original_tag_decl = dyn_cast<TagDecl>(original_decl)) {
-    ExternalASTSource *external_source = original_ctx->getExternalSource();
+    if (original_tag_decl->hasExternalLexicalStorage() ||
+        original_tag_decl->hasExternalVisibleStorage()) {
+      ExternalASTSource *external_source = original_ctx->getExternalSource();
 
-    if (external_source)
-      external_source->CompleteType(original_tag_decl);
+      if (external_source)
+        external_source->CompleteType(original_tag_decl);
+    }
   }
 
   const DeclContext *original_decl_context =
diff --git a/source/Plugins/ExpressionParser/Clang/ClangExpressionDeclMap.cpp b/source/Plugins/ExpressionParser/Clang/ClangExpressionDeclMap.cpp
index 8fde41052..ee6cdecee 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangExpressionDeclMap.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangExpressionDeclMap.cpp
@@ -563,6 +563,9 @@ addr_t ClangExpressionDeclMap::GetSymbolAddress(Target &target,
     case eSymbolTypeObjCClass:
     case eSymbolTypeObjCMetaClass:
     case eSymbolTypeObjCIVar:
+    case eSymbolTypeIVarOffset:
+    case eSymbolTypeMetadata:
+    case eSymbolTypeASTFile:
       symbol_load_addr = sym_address.GetLoadAddress(&target);
       break;
     }
@@ -717,8 +720,9 @@ void ClangExpressionDeclMap::FindExternalVisibleDecls(
     FindExternalVisibleDecls(context, lldb::ModuleSP(), namespace_decl,
                              current_id);
   }
-  
-  ClangASTSource::FindExternalVisibleDecls(context);
+
+  if (!context.m_found.variable && !context.m_found.local_vars_nsp)
+    ClangASTSource::FindExternalVisibleDecls(context);
 }
 
 void ClangExpressionDeclMap::FindExternalVisibleDecls(
@@ -1119,7 +1123,7 @@ void ClangExpressionDeclMap::FindExternalVisibleDecls(
             }
           }
 
-          if (var && !variable_found) {
+          if (var) {
             variable_found = true;
             valobj = ValueObjectVariable::Create(frame, var);
             AddOneVariable(context, var, valobj, current_id);
@@ -1150,374 +1154,396 @@ void ClangExpressionDeclMap::FindExternalVisibleDecls(
       }
     }
 
-    const bool include_inlines = false;
-    const bool append = false;
-
-    if (namespace_decl && module_sp) {
-      const bool include_symbols = false;
+    if (!context.m_found.variable) {
+      const bool include_inlines = false;
+      const bool append = false;
 
-      module_sp->FindFunctions(name, &namespace_decl, eFunctionNameTypeBase,
-                               include_symbols, include_inlines, append,
-                               sc_list);
-    } else if (target && !namespace_decl) {
-      const bool include_symbols = true;
+      if (namespace_decl && module_sp) {
+        const bool include_symbols = false;
 
-      // TODO Fix FindFunctions so that it doesn't return
-      //   instance methods for eFunctionNameTypeBase.
+        module_sp->FindFunctions(name, &namespace_decl, eFunctionNameTypeBase,
+                                 include_symbols, include_inlines, append,
+                                 sc_list);
+      } else if (target && !namespace_decl) {
+        const bool include_symbols = true;
 
-      target->GetImages().FindFunctions(name, eFunctionNameTypeFull,
-                                        include_symbols, include_inlines,
-                                        append, sc_list);
-    }
+        // TODO Fix FindFunctions so that it doesn't return
+        //   instance methods for eFunctionNameTypeBase.
 
-    // If we found more than one function, see if we can use the
-    // frame's decl context to remove functions that are shadowed
-    // by other functions which match in type but are nearer in scope.
-    //
-    // AddOneFunction will not add a function whose type has already been
-    // added, so if there's another function in the list with a matching
-    // type, check to see if their decl context is a parent of the current
-    // frame's or was imported via a and using statement, and pick the
-    // best match according to lookup rules.
-    if (sc_list.GetSize() > 1) {
-      // Collect some info about our frame's context.
-      StackFrame *frame = m_parser_vars->m_exe_ctx.GetFramePtr();
-      SymbolContext frame_sym_ctx;
-      if (frame != nullptr)
-        frame_sym_ctx = frame->GetSymbolContext(lldb::eSymbolContextFunction |
-                                                lldb::eSymbolContextBlock);
-      CompilerDeclContext frame_decl_context =
-          frame_sym_ctx.block != nullptr ? frame_sym_ctx.block->GetDeclContext()
-                                         : CompilerDeclContext();
-
-      // We can't do this without a compiler decl context for our frame.
-      if (frame_decl_context) {
-        clang::DeclContext *frame_decl_ctx =
-            (clang::DeclContext *)frame_decl_context.GetOpaqueDeclContext();
-        ClangASTContext *ast = llvm::dyn_cast_or_null<ClangASTContext>(
-            frame_decl_context.GetTypeSystem());
+        target->GetImages().FindFunctions(name, eFunctionNameTypeFull,
+                                          include_symbols, include_inlines,
+                                          append, sc_list);
+      }
 
-        // Structure to hold the info needed when comparing function
-        // declarations.
-        struct FuncDeclInfo {
-          ConstString m_name;
-          CompilerType m_copied_type;
-          uint32_t m_decl_lvl;
-          SymbolContext m_sym_ctx;
-        };
-
-        // First, symplify things by looping through the symbol contexts
-        // to remove unwanted functions and separate out the functions we
-        // want to compare and prune into a separate list.
-        // Cache the info needed about the function declarations in a
-        // vector for efficiency.
-        SymbolContextList sc_sym_list;
-        uint32_t num_indices = sc_list.GetSize();
-        std::vector<FuncDeclInfo> fdi_cache;
-        fdi_cache.reserve(num_indices);
-        for (uint32_t index = 0; index < num_indices; ++index) {
-          FuncDeclInfo fdi;
-          SymbolContext sym_ctx;
-          sc_list.GetContextAtIndex(index, sym_ctx);
+      // If we found more than one function, see if we can use the
+      // frame's decl context to remove functions that are shadowed
+      // by other functions which match in type but are nearer in scope.
+      //
+      // AddOneFunction will not add a function whose type has already been
+      // added, so if there's another function in the list with a matching
+      // type, check to see if their decl context is a parent of the current
+      // frame's or was imported via a and using statement, and pick the
+      // best match according to lookup rules.
+      if (sc_list.GetSize() > 1) {
+        // Collect some info about our frame's context.
+        StackFrame *frame = m_parser_vars->m_exe_ctx.GetFramePtr();
+        SymbolContext frame_sym_ctx;
+        if (frame != nullptr)
+          frame_sym_ctx = frame->GetSymbolContext(lldb::eSymbolContextFunction |
+                                                  lldb::eSymbolContextBlock);
+        CompilerDeclContext frame_decl_context =
+            frame_sym_ctx.block != nullptr
+                ? frame_sym_ctx.block->GetDeclContext()
+                : CompilerDeclContext();
+
+        // We can't do this without a compiler decl context for our frame.
+        if (frame_decl_context) {
+          clang::DeclContext *frame_decl_ctx =
+              (clang::DeclContext *)frame_decl_context.GetOpaqueDeclContext();
+          ClangASTContext *ast = llvm::dyn_cast_or_null<ClangASTContext>(
+              frame_decl_context.GetTypeSystem());
+
+          // Structure to hold the info needed when comparing function
+          // declarations.
+          struct FuncDeclInfo {
+            ConstString m_name;
+            CompilerType m_copied_type;
+            uint32_t m_decl_lvl;
+            SymbolContext m_sym_ctx;
+          };
+
+          // First, symplify things by looping through the symbol contexts
+          // to remove unwanted functions and separate out the functions we
+          // want to compare and prune into a separate list.
+          // Cache the info needed about the function declarations in a
+          // vector for efficiency.
+          SymbolContextList sc_sym_list;
+          uint32_t num_indices = sc_list.GetSize();
+          std::vector<FuncDeclInfo> fdi_cache;
+          fdi_cache.reserve(num_indices);
+          for (uint32_t index = 0; index < num_indices; ++index) {
+            FuncDeclInfo fdi;
+            SymbolContext sym_ctx;
+            sc_list.GetContextAtIndex(index, sym_ctx);
+
+            // We don't know enough about symbols to compare them,
+            // but we should keep them in the list.
+            Function *function = sym_ctx.function;
+            if (!function) {
+              sc_sym_list.Append(sym_ctx);
+              continue;
+            }
+            // Filter out functions without declaration contexts, as well as
+            // class/instance methods, since they'll be skipped in the
+            // code that follows anyway.
+            CompilerDeclContext func_decl_context = function->GetDeclContext();
+            if (!func_decl_context ||
+                func_decl_context.IsClassMethod(nullptr, nullptr, nullptr))
+              continue;
+            // We can only prune functions for which we can copy the type.
+            CompilerType func_clang_type =
+                function->GetType()->GetFullCompilerType();
+            CompilerType copied_func_type = GuardedCopyType(func_clang_type);
+            if (!copied_func_type) {
+              sc_sym_list.Append(sym_ctx);
+              continue;
+            }
 
-          // We don't know enough about symbols to compare them,
-          // but we should keep them in the list.
-          Function *function = sym_ctx.function;
-          if (!function) {
-            sc_sym_list.Append(sym_ctx);
-            continue;
-          }
-          // Filter out functions without declaration contexts, as well as
-          // class/instance methods, since they'll be skipped in the
-          // code that follows anyway.
-          CompilerDeclContext func_decl_context = function->GetDeclContext();
-          if (!func_decl_context ||
-              func_decl_context.IsClassMethod(nullptr, nullptr, nullptr))
-            continue;
-          // We can only prune functions for which we can copy the type.
-          CompilerType func_clang_type =
-              function->GetType()->GetFullCompilerType();
-          CompilerType copied_func_type = GuardedCopyType(func_clang_type);
-          if (!copied_func_type) {
-            sc_sym_list.Append(sym_ctx);
-            continue;
+            fdi.m_sym_ctx = sym_ctx;
+            fdi.m_name = function->GetName();
+            fdi.m_copied_type = copied_func_type;
+            fdi.m_decl_lvl = LLDB_INVALID_DECL_LEVEL;
+            if (fdi.m_copied_type && func_decl_context) {
+              // Call CountDeclLevels to get the number of parent scopes we
+              // have to look through before we find the function declaration.
+              // When comparing functions of the same type, the one with a
+              // lower count will be closer to us in the lookup scope and
+              // shadows the other.
+              clang::DeclContext *func_decl_ctx =
+                  (clang::DeclContext *)
+                      func_decl_context.GetOpaqueDeclContext();
+              fdi.m_decl_lvl =
+                  ast->CountDeclLevels(frame_decl_ctx, func_decl_ctx,
+                                       &fdi.m_name, &fdi.m_copied_type);
+            }
+            fdi_cache.emplace_back(fdi);
           }
 
-          fdi.m_sym_ctx = sym_ctx;
-          fdi.m_name = function->GetName();
-          fdi.m_copied_type = copied_func_type;
-          fdi.m_decl_lvl = LLDB_INVALID_DECL_LEVEL;
-          if (fdi.m_copied_type && func_decl_context) {
-            // Call CountDeclLevels to get the number of parent scopes we
-            // have to look through before we find the function declaration.
-            // When comparing functions of the same type, the one with a
-            // lower count will be closer to us in the lookup scope and
-            // shadows the other.
-            clang::DeclContext *func_decl_ctx =
-                (clang::DeclContext *)func_decl_context.GetOpaqueDeclContext();
-            fdi.m_decl_lvl = ast->CountDeclLevels(
-                frame_decl_ctx, func_decl_ctx, &fdi.m_name, &fdi.m_copied_type);
+          // Loop through the functions in our cache looking for matching types,
+          // then compare their scope levels to see which is closer.
+          std::multimap<CompilerType, const FuncDeclInfo *> matches;
+          for (const FuncDeclInfo &fdi : fdi_cache) {
+            const CompilerType t = fdi.m_copied_type;
+            auto q = matches.find(t);
+            if (q != matches.end()) {
+              if (q->second->m_decl_lvl > fdi.m_decl_lvl)
+                // This function is closer; remove the old set.
+                matches.erase(t);
+              else if (q->second->m_decl_lvl < fdi.m_decl_lvl)
+                // The functions in our set are closer - skip this one.
+                continue;
+            }
+            matches.insert(std::make_pair(t, &fdi));
           }
-          fdi_cache.emplace_back(fdi);
-        }
 
-        // Loop through the functions in our cache looking for matching types,
-        // then compare their scope levels to see which is closer.
-        std::multimap<CompilerType, const FuncDeclInfo *> matches;
-        for (const FuncDeclInfo &fdi : fdi_cache) {
-          const CompilerType t = fdi.m_copied_type;
-          auto q = matches.find(t);
-          if (q != matches.end()) {
-            if (q->second->m_decl_lvl > fdi.m_decl_lvl)
-              // This function is closer; remove the old set.
-              matches.erase(t);
-            else if (q->second->m_decl_lvl < fdi.m_decl_lvl)
-              // The functions in our set are closer - skip this one.
-              continue;
-          }
-          matches.insert(std::make_pair(t, &fdi));
-        }
+          // Loop through our matches and add their symbol contexts to our list.
+          SymbolContextList sc_func_list;
+          for (const auto &q : matches)
+            sc_func_list.Append(q.second->m_sym_ctx);
 
-        // Loop through our matches and add their symbol contexts to our list.
-        SymbolContextList sc_func_list;
-        for (const auto &q : matches)
-          sc_func_list.Append(q.second->m_sym_ctx);
-
-        // Rejoin the lists with the functions in front.
-        sc_list = sc_func_list;
-        sc_list.Append(sc_sym_list);
+          // Rejoin the lists with the functions in front.
+          sc_list = sc_func_list;
+          sc_list.Append(sc_sym_list);
+        }
       }
-    }
 
-    if (sc_list.GetSize()) {
-      Symbol *extern_symbol = NULL;
-      Symbol *non_extern_symbol = NULL;
+      if (sc_list.GetSize()) {
+        Symbol *extern_symbol = NULL;
+        Symbol *non_extern_symbol = NULL;
 
-      for (uint32_t index = 0, num_indices = sc_list.GetSize();
-           index < num_indices; ++index) {
-        SymbolContext sym_ctx;
-        sc_list.GetContextAtIndex(index, sym_ctx);
-
-        if (sym_ctx.function) {
-          CompilerDeclContext decl_ctx = sym_ctx.function->GetDeclContext();
+        for (uint32_t index = 0, num_indices = sc_list.GetSize();
+             index < num_indices; ++index) {
+          SymbolContext sym_ctx;
+          sc_list.GetContextAtIndex(index, sym_ctx);
 
-          if (!decl_ctx)
-            continue;
+          if (sym_ctx.function) {
+            CompilerDeclContext decl_ctx = sym_ctx.function->GetDeclContext();
 
-          // Filter out class/instance methods.
-          if (decl_ctx.IsClassMethod(nullptr, nullptr, nullptr))
-            continue;
+            if (!decl_ctx)
+              continue;
 
-          AddOneFunction(context, sym_ctx.function, NULL, current_id);
-          context.m_found.function_with_type_info = true;
-          context.m_found.function = true;
-        } else if (sym_ctx.symbol) {
-          if (sym_ctx.symbol->GetType() == eSymbolTypeReExported && target) {
-            sym_ctx.symbol = sym_ctx.symbol->ResolveReExportedSymbol(*target);
-            if (sym_ctx.symbol == NULL)
+            // Filter out class/instance methods.
+            if (decl_ctx.IsClassMethod(nullptr, nullptr, nullptr))
               continue;
-          }
 
-          if (sym_ctx.symbol->IsExternal())
-            extern_symbol = sym_ctx.symbol;
-          else
-            non_extern_symbol = sym_ctx.symbol;
+            AddOneFunction(context, sym_ctx.function, NULL, current_id);
+            context.m_found.function_with_type_info = true;
+            context.m_found.function = true;
+          } else if (sym_ctx.symbol) {
+            if (sym_ctx.symbol->GetType() == eSymbolTypeReExported && target) {
+              sym_ctx.symbol = sym_ctx.symbol->ResolveReExportedSymbol(*target);
+              if (sym_ctx.symbol == NULL)
+                continue;
+            }
+
+            if (sym_ctx.symbol->IsExternal())
+              extern_symbol = sym_ctx.symbol;
+            else
+              non_extern_symbol = sym_ctx.symbol;
+          }
         }
-      }
 
-      if (!context.m_found.function_with_type_info) {
-        for (clang::NamedDecl *decl : decls_from_modules) {
-          if (llvm::isa<clang::FunctionDecl>(decl)) {
-            clang::NamedDecl *copied_decl =
-                llvm::cast_or_null<FunctionDecl>(m_ast_importer_sp->CopyDecl(
-                    m_ast_context, &decl->getASTContext(), decl));
-            if (copied_decl) {
-              context.AddNamedDecl(copied_decl);
-              context.m_found.function_with_type_info = true;
+        if (!context.m_found.function_with_type_info) {
+          for (clang::NamedDecl *decl : decls_from_modules) {
+            if (llvm::isa<clang::FunctionDecl>(decl)) {
+              clang::NamedDecl *copied_decl =
+                  llvm::cast_or_null<FunctionDecl>(m_ast_importer_sp->CopyDecl(
+                      m_ast_context, &decl->getASTContext(), decl));
+              if (copied_decl) {
+                context.AddNamedDecl(copied_decl);
+                context.m_found.function_with_type_info = true;
+              }
             }
           }
         }
-      }
 
-      if (!context.m_found.function_with_type_info) {
-        if (extern_symbol) {
-          AddOneFunction(context, NULL, extern_symbol, current_id);
-          context.m_found.function = true;
-        } else if (non_extern_symbol) {
-          AddOneFunction(context, NULL, non_extern_symbol, current_id);
-          context.m_found.function = true;
+        if (!context.m_found.function_with_type_info) {
+          if (extern_symbol) {
+            AddOneFunction(context, NULL, extern_symbol, current_id);
+            context.m_found.function = true;
+          } else if (non_extern_symbol) {
+            AddOneFunction(context, NULL, non_extern_symbol, current_id);
+            context.m_found.function = true;
+          }
         }
       }
-    }
 
-    if (!context.m_found.function_with_type_info) {
-      // Try the modules next.
+      if (!context.m_found.function_with_type_info) {
+        // Try the modules next.
 
-      do {
-        if (ClangModulesDeclVendor *modules_decl_vendor =
-                m_target->GetClangModulesDeclVendor()) {
-          bool append = false;
-          uint32_t max_matches = 1;
-          std::vector<clang::NamedDecl *> decls;
+        do {
+          if (ClangModulesDeclVendor *modules_decl_vendor =
+                  m_target->GetClangModulesDeclVendor()) {
+            bool append = false;
+            uint32_t max_matches = 1;
+            std::vector<clang::NamedDecl *> decls;
 
-          if (!modules_decl_vendor->FindDecls(name, append, max_matches, decls))
-            break;
+            if (!modules_decl_vendor->FindDecls(name, append, max_matches,
+                                                decls))
+              break;
 
-          clang::NamedDecl *const decl_from_modules = decls[0];
+            clang::NamedDecl *const decl_from_modules = decls[0];
 
-          if (llvm::isa<clang::FunctionDecl>(decl_from_modules)) {
-            if (log) {
-              log->Printf("  CAS::FEVD[%u] Matching function found for "
-                          "\"%s\" in the modules",
-                          current_id, name.GetCString());
-            }
+            if (llvm::isa<clang::FunctionDecl>(decl_from_modules)) {
+              if (log) {
+                log->Printf("  CAS::FEVD[%u] Matching function found for "
+                            "\"%s\" in the modules",
+                            current_id, name.GetCString());
+              }
 
-            clang::Decl *copied_decl = m_ast_importer_sp->CopyDecl(
-                m_ast_context, &decl_from_modules->getASTContext(),
-                decl_from_modules);
-            clang::FunctionDecl *copied_function_decl =
-                copied_decl ? dyn_cast<clang::FunctionDecl>(copied_decl)
-                            : nullptr;
+              clang::Decl *copied_decl = m_ast_importer_sp->CopyDecl(
+                  m_ast_context, &decl_from_modules->getASTContext(),
+                  decl_from_modules);
+              clang::FunctionDecl *copied_function_decl =
+                  copied_decl ? dyn_cast<clang::FunctionDecl>(copied_decl)
+                              : nullptr;
 
-            if (!copied_function_decl) {
-              if (log)
-                log->Printf("  CAS::FEVD[%u] - Couldn't export a function "
-                            "declaration from the modules",
-                            current_id);
+              if (!copied_function_decl) {
+                if (log)
+                  log->Printf("  CAS::FEVD[%u] - Couldn't export a function "
+                              "declaration from the modules",
+                              current_id);
 
-              break;
-            }
+                break;
+              }
 
-            MaybeRegisterFunctionBody(copied_function_decl);
+              MaybeRegisterFunctionBody(copied_function_decl);
 
-            context.AddNamedDecl(copied_function_decl);
+              context.AddNamedDecl(copied_function_decl);
 
-            context.m_found.function_with_type_info = true;
-            context.m_found.function = true;
-          } else if (llvm::isa<clang::VarDecl>(decl_from_modules)) {
-            if (log) {
-              log->Printf("  CAS::FEVD[%u] Matching variable found for "
-                          "\"%s\" in the modules",
-                          current_id, name.GetCString());
+              context.m_found.function_with_type_info = true;
+              context.m_found.function = true;
+            } else if (llvm::isa<clang::VarDecl>(decl_from_modules)) {
+              if (log) {
+                log->Printf("  CAS::FEVD[%u] Matching variable found for "
+                            "\"%s\" in the modules",
+                            current_id, name.GetCString());
+              }
+
+              clang::Decl *copied_decl = m_ast_importer_sp->CopyDecl(
+                  m_ast_context, &decl_from_modules->getASTContext(),
+                  decl_from_modules);
+              clang::VarDecl *copied_var_decl =
+                  copied_decl ? dyn_cast_or_null<clang::VarDecl>(copied_decl)
+                              : nullptr;
+
+              if (!copied_var_decl) {
+                if (log)
+                  log->Printf("  CAS::FEVD[%u] - Couldn't export a variable "
+                              "declaration from the modules",
+                              current_id);
+
+                break;
+              }
+
+              context.AddNamedDecl(copied_var_decl);
+
+              context.m_found.variable = true;
             }
+          }
+        } while (0);
+      }
 
-            clang::Decl *copied_decl = m_ast_importer_sp->CopyDecl(
-                m_ast_context, &decl_from_modules->getASTContext(),
-                decl_from_modules);
-            clang::VarDecl *copied_var_decl =
-                copied_decl ? dyn_cast_or_null<clang::VarDecl>(copied_decl)
-                            : nullptr;
-
-            if (!copied_var_decl) {
-              if (log)
-                log->Printf("  CAS::FEVD[%u] - Couldn't export a variable "
-                            "declaration from the modules",
-                            current_id);
-
-              break;
-            }
+      if (target && !context.m_found.variable && !namespace_decl) {
+        // We couldn't find a non-symbol variable for this.  Now we'll hunt for
+        // a generic
+        // data symbol, and -- if it is found -- treat it as a variable.
+        Status error;
 
-            context.AddNamedDecl(copied_var_decl);
+        const Symbol *data_symbol =
+            m_parser_vars->m_sym_ctx.FindBestGlobalDataSymbol(name, error);
 
-            context.m_found.variable = true;
-          }
+        if (!error.Success()) {
+          const unsigned diag_id =
+              m_ast_context->getDiagnostics().getCustomDiagID(
+                  clang::DiagnosticsEngine::Level::Error, "%0");
+          m_ast_context->getDiagnostics().Report(diag_id) << error.AsCString();
         }
-      } while (0);
-    }
 
-    if (target && !context.m_found.variable && !namespace_decl) {
-      // We couldn't find a non-symbol variable for this.  Now we'll hunt for
-      // a generic
-      // data symbol, and -- if it is found -- treat it as a variable.
-      Status error;
-      
-      const Symbol *data_symbol =
-          m_parser_vars->m_sym_ctx.FindBestGlobalDataSymbol(name, error);
-      
-      if (!error.Success()) {
-        const unsigned diag_id =
-            m_ast_context->getDiagnostics().getCustomDiagID(
-                clang::DiagnosticsEngine::Level::Error, "%0");
-        m_ast_context->getDiagnostics().Report(diag_id) << error.AsCString();
-      }
-                                          
-      if (data_symbol) {
-        std::string warning("got name from symbols: ");
-        warning.append(name.AsCString());
-        const unsigned diag_id =
-            m_ast_context->getDiagnostics().getCustomDiagID(
-                clang::DiagnosticsEngine::Level::Warning, "%0");
-        m_ast_context->getDiagnostics().Report(diag_id) << warning.c_str();
-        AddOneGenericVariable(context, *data_symbol, current_id);
-        context.m_found.variable = true;
+        if (data_symbol) {
+          std::string warning("got name from symbols: ");
+          warning.append(name.AsCString());
+          const unsigned diag_id =
+              m_ast_context->getDiagnostics().getCustomDiagID(
+                  clang::DiagnosticsEngine::Level::Warning, "%0");
+          m_ast_context->getDiagnostics().Report(diag_id) << warning.c_str();
+          AddOneGenericVariable(context, *data_symbol, current_id);
+          context.m_found.variable = true;
+        }
       }
     }
   }
 }
 
-// static opaque_compiler_type_t
-// MaybePromoteToBlockPointerType
-//(
-//    ASTContext *ast_context,
-//    opaque_compiler_type_t candidate_type
-//)
-//{
-//    if (!candidate_type)
-//        return candidate_type;
-//
-//    QualType candidate_qual_type = QualType::getFromOpaquePtr(candidate_type);
-//
-//    const PointerType *candidate_pointer_type =
-//    dyn_cast<PointerType>(candidate_qual_type);
-//
-//    if (!candidate_pointer_type)
-//        return candidate_type;
-//
-//    QualType pointee_qual_type = candidate_pointer_type->getPointeeType();
-//
-//    const RecordType *pointee_record_type =
-//    dyn_cast<RecordType>(pointee_qual_type);
-//
-//    if (!pointee_record_type)
-//        return candidate_type;
-//
-//    RecordDecl *pointee_record_decl = pointee_record_type->getDecl();
-//
-//    if (!pointee_record_decl->isRecord())
-//        return candidate_type;
-//
-//    if
-//    (!pointee_record_decl->getName().startswith(llvm::StringRef("__block_literal_")))
-//        return candidate_type;
-//
-//    QualType generic_function_type =
-//    ast_context->getFunctionNoProtoType(ast_context->UnknownAnyTy);
-//    QualType block_pointer_type =
-//    ast_context->getBlockPointerType(generic_function_type);
-//
-//    return block_pointer_type.getAsOpaquePtr();
-//}
+  // static opaque_compiler_type_t
+  // MaybePromoteToBlockPointerType
+  //(
+  //    ASTContext *ast_context,
+  //    opaque_compiler_type_t candidate_type
+  //)
+  //{
+  //    if (!candidate_type)
+  //        return candidate_type;
+  //
+  //    QualType candidate_qual_type =
+  //    QualType::getFromOpaquePtr(candidate_type);
+  //
+  //    const PointerType *candidate_pointer_type =
+  //    dyn_cast<PointerType>(candidate_qual_type);
+  //
+  //    if (!candidate_pointer_type)
+  //        return candidate_type;
+  //
+  //    QualType pointee_qual_type = candidate_pointer_type->getPointeeType();
+  //
+  //    const RecordType *pointee_record_type =
+  //    dyn_cast<RecordType>(pointee_qual_type);
+  //
+  //    if (!pointee_record_type)
+  //        return candidate_type;
+  //
+  //    RecordDecl *pointee_record_decl = pointee_record_type->getDecl();
+  //
+  //    if (!pointee_record_decl->isRecord())
+  //        return candidate_type;
+  //
+  //    if
+  //    (!pointee_record_decl->getName().startswith(llvm::StringRef("__block_literal_")))
+  //        return candidate_type;
+  //
+  //    QualType generic_function_type =
+  //    ast_context->getFunctionNoProtoType(ast_context->UnknownAnyTy);
+  //    QualType block_pointer_type =
+  //    ast_context->getBlockPointerType(generic_function_type);
+  //
+  //    return block_pointer_type.getAsOpaquePtr();
+  //}
+
+  bool ClangExpressionDeclMap::GetVariableValue(
+      VariableSP & var, lldb_private::Value & var_location,
+      TypeFromUser * user_type, TypeFromParser * parser_type) {
+    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
 
-bool ClangExpressionDeclMap::GetVariableValue(VariableSP &var,
-                                              lldb_private::Value &var_location,
-                                              TypeFromUser *user_type,
-                                              TypeFromParser *parser_type) {
-  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+    Type *var_type = var->GetType();
+
+    if (!var_type) {
+      if (log)
+        log->PutCString("Skipped a definition because it has no type");
+      return false;
+    }
 
-  Type *var_type = var->GetType();
+    CompilerType var_clang_type = var_type->GetFullCompilerType();
 
-  if (!var_type) {
-    if (log)
-      log->PutCString("Skipped a definition because it has no type");
-    return false;
-  }
+    if (!var_clang_type) {
+      if (log)
+        log->PutCString("Skipped a definition because it has no Clang type");
+      return false;
+    }
 
-  CompilerType var_clang_type = var_type->GetFullCompilerType();
+    if (llvm::isa<SwiftASTContext>(var_clang_type.GetTypeSystem())) {
+#ifdef CAN_IMPORT_SWIFT_CLANG_TYPES // <rdar://problem/16102770> ASTImporter
+                                    // can't import Swift-generated types
+    // Try to get a Clang type for the Swift type.
 
-  if (!var_clang_type) {
-    if (log)
-      log->PutCString("Skipped a definition because it has no Clang type");
+    if (!var_clang_type.IsImportedType(&var_clang_type)) {
+      if (log)
+        log->PutCString("Skipped a definition because it has a Swift type and "
+                        "we can't get a Clang type for it");
+      return false;
+    }
+#else
     return false;
+#endif
   }
 
   ClangASTContext *clang_ast = llvm::dyn_cast_or_null<ClangASTContext>(
diff --git a/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.cpp b/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.cpp
index 4e20be79f..01e2204d5 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.cpp
@@ -20,6 +20,7 @@
 #include "clang/Basic/Version.h"
 #include "clang/CodeGen/CodeGenAction.h"
 #include "clang/CodeGen/ModuleBuilder.h"
+#include "clang/CodeGen/ObjectFilePCHContainerOperations.h"
 #include "clang/Edit/Commit.h"
 #include "clang/Edit/EditedSource.h"
 #include "clang/Edit/EditsReceiver.h"
@@ -30,6 +31,7 @@
 #include "clang/Frontend/FrontendPluginRegistry.h"
 #include "clang/Frontend/TextDiagnosticBuffer.h"
 #include "clang/Frontend/TextDiagnosticPrinter.h"
+#include "clang/Lex/HeaderSearch.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Parse/ParseAST.h"
 #include "clang/Rewrite/Core/Rewriter.h"
@@ -71,6 +73,7 @@
 #include "lldb/Core/Disassembler.h"
 #include "lldb/Core/Module.h"
 #include "lldb/Core/StreamFile.h"
+#include "lldb/Expression/ExpressionSourceCode.h"
 #include "lldb/Expression/IRDynamicChecks.h"
 #include "lldb/Expression/IRExecutionUnit.h"
 #include "lldb/Expression/IRInterpreter.h"
@@ -216,6 +219,50 @@ private:
   std::shared_ptr<clang::TextDiagnosticBuffer> m_passthrough;
 };
 
+class LoggingDiagnosticConsumer : public clang::DiagnosticConsumer {
+public:
+  LoggingDiagnosticConsumer() {
+    m_log = lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS);
+    m_passthrough.reset(new clang::TextDiagnosticBuffer);
+  }
+
+  LoggingDiagnosticConsumer(
+      const std::shared_ptr<clang::TextDiagnosticBuffer> &passthrough) {
+    m_log = lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS);
+    m_passthrough = passthrough;
+  }
+
+  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,
+                        const clang::Diagnostic &Info) {
+    if (m_log) {
+      llvm::SmallVector<char, 32> diag_str;
+      Info.FormatDiagnostic(diag_str);
+      diag_str.push_back('\0');
+      const char *data = diag_str.data();
+      m_log->Printf("[clang] COMPILER DIAGNOSTIC: %s", data);
+
+      lldbassert(Info.getID() != clang::diag::err_unsupported_ast_node &&
+                 "'log enable lldb expr' to investigate.");
+    }
+
+    m_passthrough->HandleDiagnostic(DiagLevel, Info);
+  }
+
+  void FlushDiagnostics(DiagnosticsEngine &Diags) {
+    m_passthrough->FlushDiagnostics(Diags);
+  }
+
+  DiagnosticConsumer *clone(DiagnosticsEngine &Diags) const {
+    return new LoggingDiagnosticConsumer(m_passthrough);
+  }
+
+  clang::TextDiagnosticBuffer *GetPassthrough() { return m_passthrough.get(); }
+
+private:
+  Log *m_log;
+  std::shared_ptr<clang::TextDiagnosticBuffer> m_passthrough;
+};
+
 //===----------------------------------------------------------------------===//
 // Implementation of ClangExpressionParser
 //===----------------------------------------------------------------------===//
@@ -224,7 +271,8 @@ ClangExpressionParser::ClangExpressionParser(ExecutionContextScope *exe_scope,
                                              Expression &expr,
                                              bool generate_debug_info)
     : ExpressionParser(exe_scope, expr, generate_debug_info), m_compiler(),
-      m_code_generator(), m_pp_callbacks(nullptr) {
+      m_builtin_context(), m_selector_table(), m_code_generator(),
+      m_pp_callbacks(nullptr) {
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
 
   // We can't compile expressions without a target.  So if the exe_scope is null
@@ -252,6 +300,17 @@ ClangExpressionParser::ClangExpressionParser(ExecutionContextScope *exe_scope,
 
   // 1. Create a new compiler instance.
   m_compiler.reset(new CompilerInstance());
+
+  // Register the support for object-file-wrapped Clang modules.
+  std::shared_ptr<clang::PCHContainerOperations> pch_operations =
+      m_compiler->getPCHContainerOperations();
+  pch_operations->registerWriter(
+      llvm::make_unique<ObjectFilePCHContainerWriter>());
+  pch_operations->registerReader(
+      llvm::make_unique<ObjectFilePCHContainerReader>());
+
+  // 2. Install the target.
+
   lldb::LanguageType frame_lang =
       expr.Language(); // defaults to lldb::eLanguageTypeUnknown
   bool overridden_target_opts = false;
@@ -304,6 +363,9 @@ ClangExpressionParser::ClangExpressionParser(ExecutionContextScope *exe_scope,
       log->Printf("Using default target triple of %s",
                   m_compiler->getTargetOpts().Triple.c_str());
   }
+
+  m_compiler->getTargetOpts().CPU = "";
+
   // Now add some special fixes for known architectures:
   // Any arm32 iOS environment, but not on arm64
   if (m_compiler->getTargetOpts().Triple.find("arm64") == std::string::npos &&
@@ -538,6 +600,7 @@ ClangExpressionParser::ClangExpressionParser(ExecutionContextScope *exe_scope,
   std::string module_name("$__lldb_module");
 
   m_llvm_context.reset(new LLVMContext());
+
   m_code_generator.reset(CreateLLVMCodeGen(
       m_compiler->getDiagnostics(), module_name,
       m_compiler->getHeaderSearchOpts(), m_compiler->getPreprocessorOpts(),
@@ -546,7 +609,9 @@ ClangExpressionParser::ClangExpressionParser(ExecutionContextScope *exe_scope,
 
 ClangExpressionParser::~ClangExpressionParser() {}
 
-unsigned ClangExpressionParser::Parse(DiagnosticManager &diagnostic_manager) {
+unsigned ClangExpressionParser::Parse(DiagnosticManager &diagnostic_manager,
+                                      uint32_t first_line, uint32_t last_line,
+                                      uint32_t line_offset) {
   ClangDiagnosticManagerAdapter *adapter =
       static_cast<ClangDiagnosticManagerAdapter *>(
           m_compiler->getDiagnostics().getClient());
@@ -557,34 +622,20 @@ unsigned ClangExpressionParser::Parse(DiagnosticManager &diagnostic_manager) {
 
   const char *expr_text = m_expr.Text();
 
-  clang::SourceManager &source_mgr = m_compiler->getSourceManager();
+  clang::SourceManager &SourceMgr = m_compiler->getSourceManager();
   bool created_main_file = false;
-  if (m_compiler->getCodeGenOpts().getDebugInfo() ==
-      codegenoptions::FullDebugInfo) {
-    int temp_fd = -1;
-    llvm::SmallString<PATH_MAX> result_path;
-    FileSpec tmpdir_file_spec;
-    if (HostInfo::GetLLDBPath(lldb::ePathTypeLLDBTempSystemDir,
-                              tmpdir_file_spec)) {
-      tmpdir_file_spec.AppendPathComponent("lldb-%%%%%%.expr");
-      std::string temp_source_path = tmpdir_file_spec.GetPath();
-      llvm::sys::fs::createUniqueFile(temp_source_path, temp_fd, result_path);
-    } else {
-      llvm::sys::fs::createTemporaryFile("lldb", "expr", temp_fd, result_path);
-    }
-
-    if (temp_fd != -1) {
-      lldb_private::File file(temp_fd, true);
-      const size_t expr_text_len = strlen(expr_text);
-      size_t bytes_written = expr_text_len;
-      if (file.Write(expr_text, bytes_written).Success()) {
-        if (bytes_written == expr_text_len) {
-          file.Close();
-          source_mgr.setMainFileID(
-              source_mgr.createFileID(m_file_manager->getFile(result_path),
-                                      SourceLocation(), SrcMgr::C_User));
-          created_main_file = true;
-        }
+  if (m_expr.GetOptions() &&
+      m_expr.GetOptions()->GetPoundLineFilePath() == NULL &&
+      m_compiler->getCodeGenOpts().getDebugInfo() ==
+          codegenoptions::FullDebugInfo) {
+    std::string temp_source_path;
+    if (ExpressionSourceCode::SaveExpressionTextToTempFile(
+            expr_text, *m_expr.GetOptions(), temp_source_path)) {
+      auto file = m_file_manager->getFile(temp_source_path);
+      if (file) {
+        SourceMgr.setMainFileID(
+            SourceMgr.createFileID(file, SourceLocation(), SrcMgr::C_User));
+        created_main_file = true;
       }
     }
   }
@@ -592,7 +643,7 @@ unsigned ClangExpressionParser::Parse(DiagnosticManager &diagnostic_manager) {
   if (!created_main_file) {
     std::unique_ptr<MemoryBuffer> memory_buffer =
         MemoryBuffer::getMemBufferCopy(expr_text, __FUNCTION__);
-    source_mgr.setMainFileID(source_mgr.createFileID(std::move(memory_buffer)));
+    SourceMgr.setMainFileID(SourceMgr.createFileID(std::move(memory_buffer)));
   }
 
   diag_buf->BeginSourceFile(m_compiler->getLangOpts(),
@@ -775,6 +826,17 @@ lldb_private::Status ClangExpressionParser::PrepareForExecution(
     return err;
   }
 
+  for (llvm::Function &function : *llvm_module_ap.get()) {
+    llvm::AttributeList attributes = function.getAttributes();
+    llvm::AttrBuilder attributes_to_remove;
+
+    attributes_to_remove.addAttribute("target-cpu");
+
+    function.setAttributes(attributes.removeAttributes(
+        function.getContext(), llvm::AttributeList::FunctionIndex,
+        attributes_to_remove));
+  }
+
   ConstString function_name;
 
   if (execution_policy != eExecutionPolicyTopLevel) {
diff --git a/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.h b/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.h
index 3e6a109a4..cf3effde9 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.h
+++ b/source/Plugins/ExpressionParser/Clang/ClangExpressionParser.h
@@ -69,7 +69,9 @@ public:
   ///     The number of errors encountered during parsing.  0 means
   ///     success.
   //------------------------------------------------------------------
-  unsigned Parse(DiagnosticManager &diagnostic_manager) override;
+  unsigned Parse(DiagnosticManager &diagnostic_manager, uint32_t first_line = 0,
+                 uint32_t last_line = UINT32_MAX,
+                 uint32_t line_offset = 0) override;
 
   bool RewriteExpression(DiagnosticManager &diagnostic_manager) override;
 
diff --git a/source/Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.cpp b/source/Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.cpp
index bce0eaf6d..d90386a7d 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.cpp
@@ -13,6 +13,7 @@
 
 // Other libraries and framework includes
 #include "clang/Basic/TargetInfo.h"
+#include "clang/CodeGen/ObjectFilePCHContainerOperations.h"
 #include "clang/Frontend/CompilerInstance.h"
 #include "clang/Frontend/FrontendActions.h"
 #include "clang/Lex/Preprocessor.h"
@@ -639,7 +640,14 @@ ClangModulesDeclVendor::Create(Target &target) {
                                                     source_buffer.release());
 
   std::unique_ptr<clang::CompilerInstance> instance(
-      new clang::CompilerInstance);
+      new clang::CompilerInstance());
+
+  std::shared_ptr<clang::PCHContainerOperations> pch_operations =
+      instance->getPCHContainerOperations();
+  pch_operations->registerWriter(
+      llvm::make_unique<clang::ObjectFilePCHContainerWriter>());
+  pch_operations->registerReader(
+      llvm::make_unique<clang::ObjectFilePCHContainerReader>());
 
   instance->setDiagnostics(diagnostics_engine.get());
   instance->setInvocation(invocation);
diff --git a/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.cpp b/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.cpp
index 8ebf78409..fcdf147f8 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.cpp
@@ -8,12 +8,18 @@
 //===----------------------------------------------------------------------===//
 
 #include "ClangPersistentVariables.h"
+#include "lldb/Expression/IRExecutionUnit.h"
 
 #include "lldb/Core/Value.h"
 #include "lldb/Utility/DataExtractor.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/StreamString.h"
 
+#include "lldb/Symbol/SwiftASTContext.h" // Needed for llvm::isa<SwiftASTContext>(...)
+#include "lldb/Symbol/TypeSystem.h"
+
+#include "swift/AST/Decl.h"
+#include "swift/AST/Pattern.h"
 #include "clang/AST/Decl.h"
 
 #include "llvm/ADT/StringMap.h"
@@ -23,7 +29,7 @@ using namespace lldb_private;
 
 ClangPersistentVariables::ClangPersistentVariables()
     : lldb_private::PersistentExpressionState(LLVMCastKind::eKindClang),
-      m_next_persistent_variable_id(0) {}
+      m_next_persistent_variable_id(0), m_next_persistent_error_id(0) {}
 
 ExpressionVariableSP ClangPersistentVariables::CreatePersistentVariable(
     const lldb::ValueObjectSP &valobj_sp) {
@@ -40,6 +46,9 @@ ExpressionVariableSP ClangPersistentVariables::CreatePersistentVariable(
 
 void ClangPersistentVariables::RemovePersistentVariable(
     lldb::ExpressionVariableSP variable) {
+  if (!variable)
+    return;
+
   RemoveVariable(variable);
 
   const char *name = variable->GetName().AsCString();
@@ -48,14 +57,56 @@ void ClangPersistentVariables::RemovePersistentVariable(
     return;
   name++;
 
-  if (strtoul(name, NULL, 0) == m_next_persistent_variable_id - 1)
-    m_next_persistent_variable_id--;
+  bool is_error = false;
+
+  if (llvm::isa<SwiftASTContext>(variable->GetCompilerType().GetTypeSystem())) {
+    switch (*name) {
+    case 'R':
+      break;
+    case 'E':
+      is_error = true;
+      break;
+    default:
+      return;
+    }
+    name++;
+  }
+
+  uint32_t value = strtoul(name, NULL, 0);
+  if (is_error) {
+    if (value == m_next_persistent_error_id - 1)
+      m_next_persistent_error_id--;
+  } else {
+    if (value == m_next_persistent_variable_id - 1)
+      m_next_persistent_variable_id--;
+  }
 }
 
-ConstString ClangPersistentVariables::GetNextPersistentVariableName() {
+ConstString
+ClangPersistentVariables::GetNextPersistentVariableName(bool is_error) {
   char name_cstr[256];
-  ::snprintf(name_cstr, sizeof(name_cstr), "$%u",
-             m_next_persistent_variable_id++);
+
+  const char *prefix = "$";
+
+  /* THIS NEEDS TO BE HANDLED BY SWIFT-SPECIFIC CODE
+      switch (language_type)
+      {
+      default:
+          break;
+      case lldb::eLanguageTypePLI:
+      case lldb::eLanguageTypeSwift:
+          if (is_error)
+              prefix = "$E";
+          else
+              prefix = "$R";
+          break;
+      }
+   */
+
+  ::snprintf(name_cstr, sizeof(name_cstr), "%s%u", prefix,
+             is_error ? m_next_persistent_error_id++
+                      : m_next_persistent_variable_id++);
+
   ConstString name(name_cstr);
   return name;
 }
diff --git a/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.h b/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.h
index 16981a7fe..920d47ba5 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.h
+++ b/source/Plugins/ExpressionParser/Clang/ClangPersistentVariables.h
@@ -21,6 +21,13 @@
 
 #include "lldb/Expression/ExpressionVariable.h"
 
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/StringRef.h"
+
+#include <set>
+#include <string>
+#include <unordered_map>
+
 namespace lldb_private {
 
 //----------------------------------------------------------------------
@@ -35,6 +42,9 @@ namespace lldb_private {
 //----------------------------------------------------------------------
 class ClangPersistentVariables : public PersistentExpressionState {
 public:
+  //----------------------------------------------------------------------
+  /// Constructor
+  //----------------------------------------------------------------------
   ClangPersistentVariables();
 
   ~ClangPersistentVariables() override = default;
@@ -58,13 +68,35 @@ public:
   /// Return the next entry in the sequence of strings "$0", "$1", ... for
   /// use naming persistent expression convenience variables.
   ///
+  /// @param[in] language_type
+  ///     The language for the expression, which can affect the prefix
+  ///
+  /// @param[in] is_error
+  ///     If true, an error variable name is produced.
+  ///
   /// @return
   ///     A string that contains the next persistent variable name.
   //----------------------------------------------------------------------
-  ConstString GetNextPersistentVariableName() override;
+  ConstString GetNextPersistentVariableName(bool is_error = false) override;
 
   void RemovePersistentVariable(lldb::ExpressionVariableSP variable) override;
 
+  // This just adds this module to the list of hand-loaded modules, it doesn't
+  // actually load it.
+  void AddHandLoadedModule(const ConstString &module_name) {
+    m_hand_loaded_modules.insert(module_name);
+  }
+
+  using HandLoadedModuleCallback = std::function<bool(const ConstString)>;
+
+  bool RunOverHandLoadedModules(HandLoadedModuleCallback callback) {
+    for (ConstString name : m_hand_loaded_modules) {
+      if (!callback(name))
+        return false;
+    }
+    return true;
+  }
+
   void RegisterPersistentDecl(const ConstString &name, clang::NamedDecl *decl);
 
   clang::NamedDecl *GetPersistentDecl(const ConstString &name);
@@ -80,6 +112,27 @@ public:
 private:
   uint32_t m_next_persistent_variable_id; ///< The counter used by
                                           ///GetNextResultName().
+  uint32_t m_next_persistent_error_id;    ///< The counter used by
+                                       ///GetNextResultName() when is_error is
+                                       ///true.
+
+  typedef llvm::DenseMap<const char *, clang::TypeDecl *>
+      ClangPersistentTypeMap;
+  ClangPersistentTypeMap
+      m_clang_persistent_types; ///< The persistent types declared by the user.
+
+  typedef std::set<lldb::IRExecutionUnitSP> ExecutionUnitSet;
+  ExecutionUnitSet
+      m_execution_units; ///< The execution units that contain valuable symbols.
+
+  typedef std::set<lldb_private::ConstString> HandLoadedModuleSet;
+  HandLoadedModuleSet m_hand_loaded_modules; ///< These are the names of modules
+                                             ///that we have loaded by
+  ///< hand into the Contexts we make for parsing.
+
+  typedef llvm::DenseMap<const char *, lldb::addr_t> SymbolMap;
+  SymbolMap
+      m_symbol_map; ///< The addresses of the symbols in m_execution_units.
 
   typedef llvm::DenseMap<const char *, clang::NamedDecl *> PersistentDeclMap;
   PersistentDeclMap
diff --git a/source/Plugins/ExpressionParser/Clang/ClangUserExpression.cpp b/source/Plugins/ExpressionParser/Clang/ClangUserExpression.cpp
index 2a6261a6d..78c25376d 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangUserExpression.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangUserExpression.cpp
@@ -66,6 +66,8 @@ ClangUserExpression::ClangUserExpression(
       m_type_system_helper(*m_target_wp.lock().get(),
                            options.GetExecutionPolicy() ==
                                eExecutionPolicyTopLevel) {
+  m_language_flags |= eLanguageFlagEnforceValidObject;
+
   switch (m_language) {
   case lldb::eLanguageTypeC_plus_plus:
     m_allow_cxx = true;
@@ -91,6 +93,12 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
 
   m_target = exe_ctx.GetTargetPtr();
 
+  if (!m_target) {
+    if (log)
+      log->Printf("  [CUE::SC] Null target");
+    return;
+  }
+
   if (!(m_allow_cxx || m_allow_objc)) {
     if (log)
       log->Printf("  [CUE::SC] Settings inhibit C++ and Objective-C");
@@ -133,7 +141,7 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
   if (clang::CXXMethodDecl *method_decl =
           ClangASTContext::DeclContextGetAsCXXMethodDecl(decl_context)) {
     if (m_allow_cxx && method_decl->isInstance()) {
-      if (m_enforce_valid_object) {
+      if (m_language_flags & eLanguageFlagEnforceValidObject) {
         lldb::VariableListSP variable_list_sp(
             function_block->GetBlockVariableList(true));
 
@@ -156,14 +164,14 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
         }
       }
 
-      m_in_cplusplus_method = true;
-      m_needs_object_ptr = true;
+      m_language_flags |= eLanguageFlagInCPlusPlusMethod;
+      m_language_flags |= eLanguageFlagNeedsObjectPointer;
     }
   } else if (clang::ObjCMethodDecl *method_decl =
                  ClangASTContext::DeclContextGetAsObjCMethodDecl(
                      decl_context)) {
     if (m_allow_objc) {
-      if (m_enforce_valid_object) {
+      if (m_language_flags & eLanguageFlagEnforceValidObject) {
         lldb::VariableListSP variable_list_sp(
             function_block->GetBlockVariableList(true));
 
@@ -186,11 +194,11 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
         }
       }
 
-      m_in_objectivec_method = true;
-      m_needs_object_ptr = true;
+      m_language_flags |= eLanguageFlagInObjectiveCMethod;
+      m_language_flags |= eLanguageFlagNeedsObjectPointer;
 
       if (!method_decl->isInstanceMethod())
-        m_in_static_method = true;
+        m_language_flags |= eLanguageFlagInStaticMethod;
     }
   } else if (clang::FunctionDecl *function_decl =
                  ClangASTContext::DeclContextGetAsFunctionDecl(decl_context)) {
@@ -207,7 +215,7 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
     if (metadata && metadata->HasObjectPtr()) {
       lldb::LanguageType language = metadata->GetObjectPtrLanguage();
       if (language == lldb::eLanguageTypeC_plus_plus) {
-        if (m_enforce_valid_object) {
+        if (m_language_flags & eLanguageFlagEnforceValidObject) {
           lldb::VariableListSP variable_list_sp(
               function_block->GetBlockVariableList(true));
 
@@ -231,10 +239,10 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
           }
         }
 
-        m_in_cplusplus_method = true;
-        m_needs_object_ptr = true;
+        m_language_flags |= eLanguageFlagInCPlusPlusMethod;
+        m_language_flags |= eLanguageFlagNeedsObjectPointer;
       } else if (language == lldb::eLanguageTypeObjC) {
-        if (m_enforce_valid_object) {
+        if (m_language_flags & eLanguageFlagEnforceValidObject) {
           lldb::VariableListSP variable_list_sp(
               function_block->GetBlockVariableList(true));
 
@@ -275,15 +283,15 @@ void ClangUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
             return;
           } else if (ClangASTContext::IsObjCObjectPointerType(
                          self_clang_type)) {
-            m_in_objectivec_method = true;
-            m_needs_object_ptr = true;
+            m_language_flags |= eLanguageFlagInObjectiveCMethod;
+            m_language_flags |= eLanguageFlagNeedsObjectPointer;
           } else {
             err.SetErrorString(selfErrorString);
             return;
           }
         } else {
-          m_in_objectivec_method = true;
-          m_needs_object_ptr = true;
+          m_language_flags |= eLanguageFlagInObjectiveCMethod;
+          m_language_flags |= eLanguageFlagNeedsObjectPointer;
         }
       }
     }
@@ -312,7 +320,8 @@ bool ClangUserExpression::Parse(DiagnosticManager &diagnostic_manager,
                                 ExecutionContext &exe_ctx,
                                 lldb_private::ExecutionPolicy execution_policy,
                                 bool keep_result_in_memory,
-                                bool generate_debug_info) {
+                                bool generate_debug_info,
+                                uint32_t line_offset) {
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
 
   Status err;
@@ -391,17 +400,21 @@ bool ClangUserExpression::Parse(DiagnosticManager &diagnostic_manager,
         ExpressionSourceCode::CreateWrapped(prefix.c_str(),
                                             m_expr_text.c_str()));
 
-    if (m_in_cplusplus_method)
+    if (m_language_flags & eLanguageFlagInCPlusPlusMethod)
       lang_type = lldb::eLanguageTypeC_plus_plus;
-    else if (m_in_objectivec_method)
+    else if (m_language_flags & eLanguageFlagInObjectiveCMethod)
       lang_type = lldb::eLanguageTypeObjC;
     else
       lang_type = lldb::eLanguageTypeC;
 
-    if (!source_code->GetText(m_transformed_text, lang_type, m_in_static_method,
-                              exe_ctx)) {
+    m_options.SetLanguage(lang_type);
+    uint32_t first_body_line = 0;
+
+    if (!source_code->GetText(m_transformed_text, lang_type, m_language_flags,
+                              m_options, m_swift_generic_info, exe_ctx,
+                              first_body_line)) {
       diagnostic_manager.PutString(eDiagnosticSeverityError,
-                                   "couldn't construct expression body");
+                                    "couldn't construct expression body");
       return false;
     }
   }
@@ -504,7 +517,6 @@ bool ClangUserExpression::Parse(DiagnosticManager &diagnostic_manager,
     Status jit_error = parser.PrepareForExecution(
         m_jit_start_addr, m_jit_end_addr, m_execution_unit_sp, exe_ctx,
         m_can_interpret, execution_policy);
-
     if (!jit_error.Success()) {
       const char *error_cstr = jit_error.AsCString();
       if (error_cstr && error_cstr[0])
@@ -556,17 +568,23 @@ bool ClangUserExpression::Parse(DiagnosticManager &diagnostic_manager,
     }
   }
 
-  if (generate_debug_info) {
-    lldb::ModuleSP jit_module_sp(m_execution_unit_sp->GetJITModule());
-
-    if (jit_module_sp) {
-      ConstString const_func_name(FunctionName());
-      FileSpec jit_file;
-      jit_file.GetFilename() = const_func_name;
-      jit_module_sp->SetFileSpecAndObjectName(jit_file, ConstString());
-      m_jit_module_wp = jit_module_sp;
-      target->GetImages().Append(jit_module_sp);
+  if (m_options.GetGenerateDebugInfo()) {
+    StreamString jit_module_name;
+    jit_module_name.Printf("%s%u", FunctionName(),
+                           m_options.GetExpressionNumber());
+    const char *limit_file = m_options.GetPoundLineFilePath();
+    FileSpec limit_file_spec;
+    uint32_t limit_start_line = 0;
+    uint32_t limit_end_line = 0;
+    if (limit_file) {
+      limit_file_spec.SetFile(limit_file, false);
+      limit_start_line = m_options.GetPoundLineLine();
+      limit_end_line = limit_start_line +
+                       std::count(m_expr_text.begin(), m_expr_text.end(), '\n');
     }
+    m_execution_unit_sp->CreateJITModule(jit_module_name.GetString().data(),
+                                         limit_file ? &limit_file_spec : NULL,
+                                         limit_start_line, limit_end_line);
   }
 
   ResetDeclMap(); // Make this go away since we don't need any of its state
@@ -585,16 +603,16 @@ bool ClangUserExpression::AddArguments(ExecutionContext &exe_ctx,
   lldb::addr_t object_ptr = LLDB_INVALID_ADDRESS;
   lldb::addr_t cmd_ptr = LLDB_INVALID_ADDRESS;
 
-  if (m_needs_object_ptr) {
+  if (m_language_flags & eLanguageFlagNeedsObjectPointer) {
     lldb::StackFrameSP frame_sp = exe_ctx.GetFrameSP();
     if (!frame_sp)
       return true;
 
     ConstString object_name;
 
-    if (m_in_cplusplus_method) {
+    if (m_language_flags & eLanguageFlagInCPlusPlusMethod) {
       object_name.SetCString("this");
-    } else if (m_in_objectivec_method) {
+    } else if (m_language_flags & eLanguageFlagInObjectiveCMethod) {
       object_name.SetCString("self");
     } else {
       diagnostic_manager.PutString(
@@ -614,7 +632,7 @@ bool ClangUserExpression::AddArguments(ExecutionContext &exe_ctx,
       object_ptr = 0;
     }
 
-    if (m_in_objectivec_method) {
+    if (m_language_flags & eLanguageFlagInObjectiveCMethod) {
       ConstString cmd_name("_cmd");
 
       cmd_ptr = GetObjectPointer(frame_sp, cmd_name, object_ptr_error);
@@ -630,7 +648,7 @@ bool ClangUserExpression::AddArguments(ExecutionContext &exe_ctx,
 
     args.push_back(object_ptr);
 
-    if (m_in_objectivec_method)
+    if (m_language_flags & eLanguageFlagInObjectiveCMethod)
       args.push_back(cmd_ptr);
 
     args.push_back(struct_address);
diff --git a/source/Plugins/ExpressionParser/Clang/ClangUserExpression.h b/source/Plugins/ExpressionParser/Clang/ClangUserExpression.h
index 88a78798b..b6be79c32 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangUserExpression.h
+++ b/source/Plugins/ExpressionParser/Clang/ClangUserExpression.h
@@ -28,6 +28,7 @@
 #include "lldb/Expression/LLVMUserExpression.h"
 #include "lldb/Expression/Materializer.h"
 #include "lldb/Target/ExecutionContext.h"
+#include "lldb/Target/Target.h"
 #include "lldb/lldb-forward.h"
 #include "lldb/lldb-private.h"
 
@@ -47,6 +48,15 @@ class ClangUserExpression : public LLVMUserExpression {
 public:
   enum { kDefaultTimeout = 500000u };
 
+  enum {
+    eLanguageFlagNeedsObjectPointer = 1 << 0,
+    eLanguageFlagEnforceValidObject = 1 << 1,
+    eLanguageFlagInCPlusPlusMethod = 1 << 2,
+    eLanguageFlagInObjectiveCMethod = 1 << 3,
+    eLanguageFlagInStaticMethod = 1 << 4,
+    eLanguageFlagConstObject = 1 << 5
+  };
+
   class ClangUserExpressionHelper : public ClangExpressionHelper {
   public:
     ClangUserExpressionHelper(Target &target, bool top_level)
@@ -110,6 +120,9 @@ public:
   /// @param[in] desired_type
   ///     If not eResultTypeAny, the type to use for the expression
   ///     result.
+  ///
+  /// @param[in] options
+  ///     Additional options for the expression.
   //------------------------------------------------------------------
   ClangUserExpression(ExecutionContextScope &exe_scope, llvm::StringRef expr,
                       llvm::StringRef prefix, lldb::LanguageType language,
@@ -141,7 +154,8 @@ public:
   //------------------------------------------------------------------
   bool Parse(DiagnosticManager &diagnostic_manager, ExecutionContext &exe_ctx,
              lldb_private::ExecutionPolicy execution_policy,
-             bool keep_result_in_memory, bool generate_debug_info) override;
+             bool keep_result_in_memory, bool generate_debug_info,
+             uint32_t line_offset = 0) override;
 
   ExpressionTypeSystemHelper *GetTypeSystemHelper() override {
     return &m_type_system_helper;
diff --git a/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp b/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp
index 065e5db4c..92feed808 100644
--- a/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp
+++ b/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp
@@ -124,18 +124,8 @@ bool ClangUtilityFunction::Install(DiagnosticManager &diagnostic_manager,
 
   if (m_jit_start_addr != LLDB_INVALID_ADDRESS) {
     m_jit_process_wp = process->shared_from_this();
-    if (parser.GetGenerateDebugInfo()) {
-      lldb::ModuleSP jit_module_sp(m_execution_unit_sp->GetJITModule());
-
-      if (jit_module_sp) {
-        ConstString const_func_name(FunctionName());
-        FileSpec jit_file;
-        jit_file.GetFilename() = const_func_name;
-        jit_module_sp->SetFileSpecAndObjectName(jit_file, ConstString());
-        m_jit_module_wp = jit_module_sp;
-        target->GetImages().Append(jit_module_sp);
-      }
-    }
+    if (parser.GetGenerateDebugInfo())
+      m_execution_unit_sp->CreateJITModule(FunctionName());
   }
 
 #if 0
diff --git a/source/Plugins/ExpressionParser/Clang/IRForTarget.cpp b/source/Plugins/ExpressionParser/Clang/IRForTarget.cpp
index 13f5657ee..f358b1cff 100644
--- a/source/Plugins/ExpressionParser/Clang/IRForTarget.cpp
+++ b/source/Plugins/ExpressionParser/Clang/IRForTarget.cpp
@@ -2043,7 +2043,7 @@ llvm::Constant *IRForTarget::BuildRelocation(llvm::Type *type,
   llvm::Constant *reloc_placeholder_bitcast =
       ConstantExpr::getBitCast(m_reloc_placeholder, char_pointer_type);
   llvm::Constant *reloc_getelementptr = ConstantExpr::getGetElementPtr(
-      char_type, reloc_placeholder_bitcast, offsets);
+      nullptr, reloc_placeholder_bitcast, offsets);
   llvm::Constant *reloc_bitcast =
       ConstantExpr::getBitCast(reloc_getelementptr, type);
 
diff --git a/source/Plugins/ExpressionParser/Go/GoUserExpression.cpp b/source/Plugins/ExpressionParser/Go/GoUserExpression.cpp
index f4b8cfbe0..528b38459 100644
--- a/source/Plugins/ExpressionParser/Go/GoUserExpression.cpp
+++ b/source/Plugins/ExpressionParser/Go/GoUserExpression.cpp
@@ -209,7 +209,7 @@ bool GoUserExpression::Parse(DiagnosticManager &diagnostic_manager,
                              ExecutionContext &exe_ctx,
                              lldb_private::ExecutionPolicy execution_policy,
                              bool keep_result_in_memory,
-                             bool generate_debug_info) {
+                             bool generate_debug_info, uint32_t line_offset) {
   InstallContext(exe_ctx);
   m_interpreter.reset(new GoInterpreter(exe_ctx, GetUserText()));
   if (m_interpreter->Parse())
@@ -651,7 +651,8 @@ ValueObjectSP GoUserExpression::GoInterpreter::VisitCallExpr(
 GoPersistentExpressionState::GoPersistentExpressionState()
     : PersistentExpressionState(eKindGo) {}
 
-ConstString GoPersistentExpressionState::GetNextPersistentVariableName() {
+ConstString
+GoPersistentExpressionState::GetNextPersistentVariableName(bool is_error) {
   char name_cstr[256];
   // We can't use the same variable format as clang.
   ::snprintf(name_cstr, sizeof(name_cstr), "$go%u",
diff --git a/source/Plugins/ExpressionParser/Go/GoUserExpression.h b/source/Plugins/ExpressionParser/Go/GoUserExpression.h
index 03ceb76b8..8ed0eeaa6 100644
--- a/source/Plugins/ExpressionParser/Go/GoUserExpression.h
+++ b/source/Plugins/ExpressionParser/Go/GoUserExpression.h
@@ -29,7 +29,7 @@ class GoPersistentExpressionState : public PersistentExpressionState {
 public:
   GoPersistentExpressionState();
 
-  ConstString GetNextPersistentVariableName() override;
+  ConstString GetNextPersistentVariableName(bool is_error = false) override;
 
   void RemovePersistentVariable(lldb::ExpressionVariableSP variable) override;
 
@@ -64,9 +64,11 @@ public:
 
   bool Parse(DiagnosticManager &diagnostic_manager, ExecutionContext &exe_ctx,
              lldb_private::ExecutionPolicy execution_policy,
-             bool keep_result_in_memory, bool generate_debug_info) override;
+             bool keep_result_in_memory, bool generate_debug_info,
+             uint32_t line_offset) override;
 
   bool CanInterpret() override { return true; }
+
   bool FinalizeJITExecution(
       DiagnosticManager &diagnostic_manager, ExecutionContext &exe_ctx,
       lldb::ExpressionVariableSP &result,
diff --git a/source/Plugins/ExpressionParser/Swift/CMakeLists.txt b/source/Plugins/ExpressionParser/Swift/CMakeLists.txt
index e69de29bb..d6f22a443 100644
--- a/source/Plugins/ExpressionParser/Swift/CMakeLists.txt
+++ b/source/Plugins/ExpressionParser/Swift/CMakeLists.txt
@@ -0,0 +1,38 @@
+add_lldb_library(lldbPluginExpressionParserSwift PLUGIN
+  SwiftASTManipulator.cpp
+  SwiftExpressionParser.cpp
+  SwiftExpressionVariable.cpp
+  SwiftPersistentExpressionState.cpp
+  SwiftREPL.cpp
+  SwiftREPLMaterializer.cpp
+  SwiftUserExpression.cpp
+  SwiftSILManipulator.cpp
+
+   LINK_LIBS
+    lldbCore
+    lldbDataFormatters
+    lldbExpression
+    lldbHost
+    lldbInterpreter
+    lldbSymbol
+    lldbTarget
+    lldbUtility
+    swiftAST
+    swiftBasic
+    swiftClangImporter
+    swiftFrontend
+    swiftIDE
+    swiftParse
+    swiftSIL
+    swiftSILGen
+    swiftSILOptimizer
+    swiftSema
+    swiftSerialization
+    clangAST
+    clangBasic
+    clangRewrite
+  LINK_COMPONENTS
+    Support
+    Core
+    Analysis
+)
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp b/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp
index e69de29bb..42679c3d4 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.cpp
@@ -0,0 +1,1640 @@
+//===-- SwiftASTManipulator.cpp ---------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftASTManipulator.h"
+
+#include "lldb/Expression/ExpressionParser.h"
+#include "lldb/Expression/ExpressionSourceCode.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+#include "lldb/Utility/Log.h"
+#include "lldb/Utility/Status.h"
+#include "swift/AST/ASTContext.h"
+#include "swift/AST/ASTWalker.h"
+#include "swift/AST/Decl.h"
+#include "swift/AST/DiagnosticEngine.h"
+#include "swift/AST/DiagnosticsFrontend.h"
+#include "swift/AST/Expr.h"
+#include "swift/AST/Initializer.h"
+#include "swift/AST/Module.h"
+#include "swift/AST/NameLookup.h"
+#include "swift/AST/ParameterList.h"
+#include "swift/AST/Pattern.h"
+#include "swift/AST/Stmt.h"
+#include "swift/AST/TypeRepr.h"
+#include "swift/AST/Types.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include "SwiftUserExpression.h"
+
+using namespace lldb_private;
+
+static void DumpGenericNames(
+    lldb_private::Stream &wrapped_stream,
+    llvm::ArrayRef<Expression::SwiftGenericInfo::Binding> generic_bindings) {
+  if (generic_bindings.empty())
+    return;
+
+  wrapped_stream.PutChar('<');
+
+  bool comma = false;
+
+  for (const Expression::SwiftGenericInfo::Binding &binding :
+       generic_bindings) {
+    if (comma)
+      wrapped_stream.PutCString(", ");
+    comma = true;
+
+    wrapped_stream.PutCString(binding.name);
+  }
+
+  wrapped_stream.PutChar('>');
+}
+
+static void DumpPlaceholderArguments(
+    lldb_private::Stream &wrapped_stream,
+    llvm::ArrayRef<Expression::SwiftGenericInfo::Binding> generic_bindings) {
+  if (generic_bindings.empty())
+    return;
+
+  for (const Expression::SwiftGenericInfo::Binding &binding :
+       generic_bindings) {
+    const char *name = binding.name;
+
+    wrapped_stream.Printf(", _ __lldb_placeholder_%s : UnsafePointer<%s>!",
+                          name, name);
+  }
+}
+
+static void DumpPlaceholdersIntoCall(
+    lldb_private::Stream &wrapped_stream,
+    llvm::ArrayRef<Expression::SwiftGenericInfo::Binding> generic_bindings) {
+  if (generic_bindings.empty())
+    return;
+
+  for (const Expression::SwiftGenericInfo::Binding &binding :
+       generic_bindings) {
+    wrapped_stream.Printf(
+        ",\n"
+        "      (nil as UnsafePointer<$__lldb_typeof_generic_%s>?)",
+        binding.name);
+  }
+}
+
+swift::VarDecl::Specifier
+SwiftASTManipulator::VariableInfo::GetVarSpecifier() const {
+  if (m_decl)
+    return m_decl->getSpecifier();
+  else
+    return m_var_specifier;
+}
+
+bool SwiftASTManipulator::VariableInfo::GetIsCaptureList() const {
+  if (m_decl)
+    return m_decl->isCaptureList();
+  else
+    return m_is_capture_list;
+}
+
+void SwiftASTManipulator::WrapExpression(
+    lldb_private::Stream &wrapped_stream, const char *orig_text,
+    uint32_t language_flags, const EvaluateExpressionOptions &options,
+    const Expression::SwiftGenericInfo &generic_info,
+    uint32_t &first_body_line) {
+  first_body_line = 0; // set to invalid
+  // TODO make the extension private so we're not polluting the class
+  static unsigned int counter = 0;
+  unsigned int current_counter = counter++;
+
+  const bool playground = options.GetPlaygroundTransformEnabled();
+  const bool repl = options.GetREPLEnabled();
+  const bool generate_debug_info = options.GetGenerateDebugInfo();
+  const char *pound_file = options.GetPoundLineFilePath();
+  const uint32_t pound_line = options.GetPoundLineLine();
+  const char *text = orig_text;
+  StreamString fixed_text;
+
+  if (playground) {
+    const char *playground_prefix = R"(
+@_silgen_name ("playground_logger_initialize") func $builtin_logger_initialize ()
+@_silgen_name ("playground_log_hidden") func $builtin_log_with_id<T> (_ object : T, _ name : String, _ id : Int, _ sl : Int, _ el : Int, _ sc : Int, _ ec: Int) -> AnyObject
+@_silgen_name ("playground_log_scope_entry") func $builtin_log_scope_entry (_ sl : Int, _ el : Int, _ sc : Int, _ ec: Int) -> AnyObject
+@_silgen_name ("playground_log_scope_exit") func $builtin_log_scope_exit (_ sl : Int, _ el : Int, _ sc : Int, _ ec: Int) -> AnyObject
+@_silgen_name ("playground_log_postprint") func $builtin_postPrint (_ sl : Int, _ el : Int, _ sc : Int, _ ec: Int) -> AnyObject
+@_silgen_name ("DVTSendPlaygroundLogData") func $builtin_send_data (_ :  AnyObject!)
+$builtin_logger_initialize()
+)";
+    if (pound_file && pound_line) {
+      wrapped_stream.Printf("%s#sourceLocation(file: \"%s\", line: %u)\n%s\n",
+                            playground_prefix, pound_file, pound_line,
+                            orig_text);
+      first_body_line = 1;
+    } else {
+      wrapped_stream.Printf("%s%s", playground_prefix, orig_text);
+      first_body_line = 7;
+    }
+    return;
+  } else if (repl) {
+    if (pound_file && pound_line) {
+      wrapped_stream.Printf("#sourceLocation(file: \"%s\", line:  %u)\n%s\n",
+                            llvm::sys::path::filename(pound_file).str().c_str(),
+                            pound_line, orig_text);
+    } else {
+      wrapped_stream.Printf("%s", orig_text);
+    }
+    first_body_line = 1;
+    return;
+  }
+
+  std::string expr_source_path;
+
+  if (pound_file && pound_line) {
+    fixed_text.Printf("#sourceLocation(file: \"%s\", line: %u)\n%s\n",
+                      pound_file, pound_line, orig_text);
+    text = fixed_text.GetString().data();
+  } else if (generate_debug_info) {
+    if (ExpressionSourceCode::SaveExpressionTextToTempFile(orig_text, options,
+                                                           expr_source_path)) {
+      fixed_text.Printf("#sourceLocation(file: \"%s\", line: 1)\n%s\n",
+                        expr_source_path.c_str(), orig_text);
+      text = fixed_text.GetString().data();
+    }
+  }
+
+  // Note: All the wrapper functions we make are marked with the
+  // @LLDBDebuggerFunction macro so that the compiler
+  // can do whatever special treatment it need to do on them.  If you add new
+  // variants be sure to mark them this way.
+  // Also, any function that might end up being in an extension of swift class
+  // needs to be marked final, since otherwise
+  // the compiler might try to dispatch them dynamically, which it can't do
+  // correctly for these functions.
+
+  StreamString wrapped_expr_text;
+  wrapped_expr_text.Printf("do\n"
+                           "{\n"
+                           "%s%s%s\n" // Don't indent the code so error columns
+                                      // match up with errors from compiler
+                           "}\n"
+                           "catch (let __lldb_tmp_error)\n"
+                           "{\n"
+                           "    var %s = __lldb_tmp_error\n"
+                           "}\n",
+                           GetUserCodeStartMarker(), text,
+                           GetUserCodeEndMarker(), GetErrorName());
+
+  if (Flags(language_flags)
+          .AnySet(SwiftUserExpression::eLanguageFlagNeedsObjectPointer |
+                  SwiftUserExpression::eLanguageFlagInStaticMethod)) {
+    const char *func_decorator = "";
+    if (language_flags & SwiftUserExpression::eLanguageFlagInStaticMethod) {
+      if (language_flags & SwiftUserExpression::eLanguageFlagIsClass)
+        func_decorator = "final class";
+      else
+        func_decorator = "static";
+    } else if (language_flags & SwiftUserExpression::eLanguageFlagIsClass &&
+               !(language_flags &
+                 SwiftUserExpression::eLanguageFlagIsWeakSelf)) {
+      func_decorator = "final";
+    } else {
+      func_decorator = "mutating";
+    }
+
+    const char *optional_extension =
+        (language_flags & SwiftUserExpression::eLanguageFlagIsWeakSelf)
+            ? "Optional where Wrapped: "
+            : "";
+
+    if (generic_info.class_bindings.size()) {
+      if (generic_info.function_bindings.size()) {
+        wrapped_stream.Printf(
+            "extension %s$__lldb_context {\n"
+            "  @LLDBDebuggerFunction                                 \n"
+            "  %s func $__lldb_wrapped_expr_%u",
+            optional_extension, func_decorator, current_counter);
+        DumpGenericNames(wrapped_stream, generic_info.function_bindings);
+        wrapped_stream.Printf("(_ $__lldb_arg : UnsafeMutablePointer<Any>");
+        DumpPlaceholderArguments(wrapped_stream,
+                                 generic_info.function_bindings);
+        wrapped_stream.Printf(
+            ") {\n"
+            "%s" // This is the expression text.  It has all the newlines it
+                 // needs.
+            "  }                                                    \n"
+            "}                                                      \n"
+            "func $__lldb_expr(_ $__lldb_arg : UnsafeMutablePointer<Any>) {    "
+            "  \n"
+            "  do {                                          \n"
+            "    $__lldb_injected_self.$__lldb_wrapped_expr_%u(     \n"
+            "      $__lldb_arg                                        ",
+            wrapped_expr_text.GetData(), current_counter);
+        DumpPlaceholdersIntoCall(wrapped_stream,
+                                 generic_info.function_bindings);
+        wrapped_stream.Printf(
+            "\n"
+            "    )                                                  \n"
+            "  }                                                    \n"
+            "}                                                      \n");
+        first_body_line = 5;
+      } else {
+        wrapped_stream.Printf(
+            "extension %s$__lldb_context {                            \n"
+            "  @LLDBDebuggerFunction                                \n"
+            "  %s func $__lldb_wrapped_expr_%u(_ $__lldb_arg : "
+            "UnsafeMutablePointer<Any>) {\n"
+            "%s" // This is the expression text.  It has all the newlines it
+                 // needs.
+            "  }                                                    \n"
+            "}                                                      \n"
+            "func $__lldb_expr(_ $__lldb_arg : UnsafeMutablePointer<Any>) {    "
+            "  \n"
+            "  do {                                          \n"
+            "    $__lldb_injected_self.$__lldb_wrapped_expr_%u(     \n"
+            "      $__lldb_arg                                      \n"
+            "    )                                                  \n"
+            "  }                                                    \n"
+            "}                                                      \n",
+            optional_extension, func_decorator, current_counter,
+            wrapped_expr_text.GetData(), current_counter);
+
+        first_body_line = 5;
+      }
+    } else {
+      if (generic_info.function_bindings.size()) {
+        wrapped_stream.Printf(
+            "extension %s$__lldb_context {                            \n"
+            "  @LLDBDebuggerFunction                                \n"
+            "  %s func $__lldb_wrapped_expr_%u                        ",
+            optional_extension, func_decorator, current_counter);
+        DumpGenericNames(wrapped_stream, generic_info.function_bindings);
+        wrapped_stream.Printf("(_ $__lldb_arg : UnsafeMutablePointer<Any>");
+        DumpPlaceholderArguments(wrapped_stream,
+                                 generic_info.function_bindings);
+        wrapped_stream.Printf(
+            ") {\n"
+            "%s" // This is the expression text.  It has all the newlines it
+                 // needs.
+            "  }                                                    \n"
+            "}                                                      \n"
+            "func $__lldb_expr(_ $__lldb_arg : UnsafeMutablePointer<Any>) {    "
+            "  \n"
+            "  do {                                          \n"
+            "    $__lldb_injected_self.$__lldb_wrapped_expr_%u(     \n"
+            "      $__lldb_arg                                        ",
+            wrapped_expr_text.GetData(), current_counter);
+        DumpPlaceholdersIntoCall(wrapped_stream,
+                                 generic_info.function_bindings);
+        wrapped_stream.Printf(
+            "\n"
+            "    )                                                  \n"
+            "  }                                                    \n"
+            "}                                                      \n");
+        first_body_line = 5;
+
+      } else {
+        wrapped_stream.Printf(
+            "extension %s$__lldb_context {                            \n"
+            "@LLDBDebuggerFunction                                  \n"
+            "  %s func $__lldb_wrapped_expr_%u(_ $__lldb_arg : "
+            "UnsafeMutablePointer<Any>) {\n"
+            "%s" // This is the expression text.  It has all the newlines it
+                 // needs.
+            "  }                                                    \n"
+            "}                                                      \n"
+            "func $__lldb_expr(_ $__lldb_arg : UnsafeMutablePointer<Any>) {    "
+            "  \n"
+            "  do {                                          \n"
+            "    $__lldb_injected_self.$__lldb_wrapped_expr_%u(     \n"
+            "      $__lldb_arg                                      \n"
+            "    )                                                  \n"
+            "  }                                                    \n"
+            "}                                                      \n",
+            optional_extension, func_decorator, current_counter,
+            wrapped_expr_text.GetData(), current_counter);
+
+        first_body_line = 5;
+      }
+    }
+  } else {
+    if (generic_info.function_bindings.size()) {
+      wrapped_stream.Printf(
+          "@LLDBDebuggerFunction                                  \n"
+          "func $__lldb_wrapped_expr_%u",
+          current_counter);
+      DumpGenericNames(wrapped_stream, generic_info.function_bindings);
+      wrapped_stream.Printf("(_ $__lldb_arg : UnsafeMutablePointer<Any>");
+      DumpPlaceholderArguments(wrapped_stream, generic_info.function_bindings);
+      wrapped_stream.Printf(
+          ") { \n"
+          "%s" // This is the expression text.  It has all the newlines it
+               // needs.
+          "}                                                      \n"
+          "func $__lldb_expr(_ $__lldb_arg : UnsafeMutablePointer<Any>) {      "
+          "\n"
+          "  do {                                          \n"
+          "    $__lldb_wrapped_expr_%u(                           \n"
+          "      $__lldb_arg",
+          wrapped_expr_text.GetData(), current_counter);
+      DumpPlaceholdersIntoCall(wrapped_stream, generic_info.function_bindings);
+      wrapped_stream.Printf(
+          "\n"
+          "    )                                                  \n"
+          "  }                                                    \n"
+          "}                                                      \n");
+      first_body_line = 4;
+    } else {
+      wrapped_stream.Printf(
+          "@LLDBDebuggerFunction                                  \n"
+          "func $__lldb_expr(_ $__lldb_arg : UnsafeMutablePointer<Any>) {      "
+          "\n"
+          "%s" // This is the expression text.  It has all the newlines it
+               // needs.
+          "}                                                      \n",
+          wrapped_expr_text.GetData());
+      first_body_line = 4;
+    }
+  }
+}
+
+SwiftASTManipulatorBase::VariableMetadataResult::~VariableMetadataResult() {}
+
+SwiftASTManipulatorBase::VariableMetadataError::~VariableMetadataError() {}
+
+void SwiftASTManipulatorBase::VariableInfo::Print(
+    lldb_private::Stream &stream) const {
+  stream.Printf("[name=%s, type = ", m_name.str().str().c_str());
+
+  if (m_type.IsValid())
+    stream.PutCString(m_type.GetTypeName().AsCString("<no type name>"));
+  else
+    stream.PutCString("<no type>");
+
+  if (MetadataIs<VariableMetadataResult>())
+    stream.Printf(", is_result");
+
+  if (MetadataIs<VariableMetadataError>())
+    stream.Printf(", is_error");
+
+  stream.PutChar(']');
+}
+
+void SwiftASTManipulatorBase::DoInitialization() {
+  if (m_repl)
+    return;
+
+  static llvm::StringRef s_wrapped_func_prefix_str("$__lldb_wrapped_expr");
+  static llvm::StringRef s_func_prefix_str("$__lldb_expr");
+
+  // First pass: find whether we're dealing with a wrapped function or not
+
+  class FuncAndExtensionFinder : public swift::ASTWalker {
+  public:
+    swift::FuncDecl *m_function_decl = nullptr; // This is the function in which
+                                                // the expression code is
+                                                // inserted.
+    // It is always marked with the DebuggerFunction attribute.
+    swift::ExtensionDecl *m_extension_decl =
+        nullptr; // This is an optional extension holding the function
+    swift::FuncDecl *m_wrapper_decl = nullptr; // This is an optional wrapper
+                                               // function that calls
+                                               // m_function_decl.
+    llvm::StringRef m_wrapper_func_prefix; // This is the prefix name for the
+                                           // wrapper function.  One tricky bit
+    // is that in the case where there is no wrapper, the m_function_decl
+    // has this name.  That's why we check first for the debugger attribute.
+
+    FuncAndExtensionFinder(llvm::StringRef &wrapped_func_prefix)
+        : m_wrapper_func_prefix(wrapped_func_prefix) {}
+
+    virtual bool walkToDeclPre(swift::Decl *D) {
+      swift::FuncDecl *func_decl = llvm::dyn_cast<swift::FuncDecl>(D);
+
+      if (func_decl) {
+        if (func_decl->getAttrs()
+                .hasAttribute<swift::LLDBDebuggerFunctionAttr>()) {
+          m_function_decl = func_decl;
+
+          // Now walk back up the containing DeclContexts, and if we find an
+          // extension Decl, that's our extension:
+          swift::DeclContext *cur_ctx = m_function_decl->getDeclContext();
+          while (cur_ctx) {
+            swift::ExtensionDecl *extension_decl =
+                llvm::dyn_cast<swift::ExtensionDecl>(cur_ctx);
+            if (extension_decl) {
+              m_extension_decl = extension_decl;
+              break;
+            }
+            cur_ctx = cur_ctx->getParent();
+          }
+        } else if (func_decl->hasName() &&
+                   func_decl->getName().str().startswith(m_wrapper_func_prefix))
+          m_wrapper_decl = func_decl;
+
+        // There's nothing buried in a function that we need to find in this
+        // search.
+        return false;
+      }
+      return true;
+    }
+  };
+
+  FuncAndExtensionFinder func_finder(s_func_prefix_str);
+  m_source_file.walk(func_finder);
+
+  m_function_decl = func_finder.m_function_decl;
+  m_wrapper_decl = func_finder.m_wrapper_decl;
+  m_extension_decl = func_finder.m_extension_decl;
+
+  assert(m_function_decl);
+
+  // Find the body in the function
+
+  if (m_function_decl) {
+    swift::BraceStmt *function_body = m_function_decl->getBody();
+
+    swift::DoCatchStmt *do_stmt = nullptr;
+
+    for (swift::ASTNode &element : function_body->getElements()) {
+      if (swift::Stmt *stmt = element.dyn_cast<swift::Stmt *>())
+        if ((do_stmt = llvm::dyn_cast<swift::DoCatchStmt>(stmt)))
+          break;
+    }
+
+    m_do_stmt = do_stmt;
+    if (do_stmt) {
+      // There should only be one catch:
+      assert(m_do_stmt->getCatches().size() == 1);
+      swift::CatchStmt *our_catch = m_do_stmt->getCatches().front();
+      if (our_catch)
+        m_catch_stmt = our_catch;
+    }
+  }
+}
+
+swift::BraceStmt *SwiftASTManipulatorBase::GetUserBody() {
+  if (!IsValid())
+    return nullptr;
+
+  swift::Stmt *body_stmt = m_do_stmt->getBody();
+
+  swift::BraceStmt *do_body = llvm::dyn_cast<swift::BraceStmt>(body_stmt);
+
+  return do_body;
+}
+
+SwiftASTManipulator::SwiftASTManipulator(swift::SourceFile &source_file,
+                                         bool repl)
+    : SwiftASTManipulatorBase(source_file, repl) {}
+
+void SwiftASTManipulator::FindSpecialNames(
+    llvm::SmallVectorImpl<swift::Identifier> &names, llvm::StringRef prefix) {
+  names.clear();
+
+  class SpecialNameFinder : public swift::ASTWalker {
+  public:
+    typedef llvm::SmallVectorImpl<swift::Identifier> NameVector;
+
+    SpecialNameFinder(NameVector &names, llvm::StringRef &prefix)
+        : m_names(names), m_prefix(prefix) {}
+
+    virtual std::pair<bool, swift::Expr *> walkToExprPre(swift::Expr *expr) {
+      if (swift::UnresolvedDeclRefExpr *decl_ref_expr =
+              llvm::dyn_cast<swift::UnresolvedDeclRefExpr>(expr)) {
+        swift::Identifier name = decl_ref_expr->getName().getBaseIdentifier();
+
+        if (m_prefix.empty() || name.str().startswith(m_prefix))
+          m_names.push_back(name);
+      }
+
+      return {true, expr};
+    }
+
+  private:
+    NameVector &m_names;
+    llvm::StringRef m_prefix;
+  };
+
+  SpecialNameFinder special_name_finder(names, prefix);
+
+  if (m_function_decl)
+    m_function_decl->walkContext(special_name_finder);
+}
+
+// This call replaces:
+//
+//      <EXPR>
+//
+//  with:
+//
+//       do {
+//           var __lldb_tmp_ret_<N> = <EXPR>
+//       } while (false)
+//
+// and adds a "return" in the do-while if in_return is true.
+// It records what it has done in a ResultLocationInfo, which gets pushed to the
+// back of the ResultLocationInfo stack
+// maintained by the SwiftASTManipulator, and returns the statement which
+// effects the change.
+//
+// May return NULL if we can't make an appropriate variable assignment (e.g. for
+// a bare "nil".)
+
+swift::Stmt *SwiftASTManipulator::ConvertExpressionToTmpReturnVarAccess(
+    swift::Expr *expr, const swift::SourceLoc &source_loc, bool in_return,
+    swift::DeclContext *decl_context) {
+  // swift doesn't know how to infer the type of a variable by assignment to
+  // "nil".  So if the
+  // expression is "nil" then we just drop it on the floor.
+  if (swift::dyn_cast<swift::NilLiteralExpr>(expr))
+    return nullptr;
+
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+  char name_buffer[64];
+  snprintf(name_buffer, 64, "__lldb_tmp_ret_%d", m_tmpname_idx++);
+  swift::Identifier name = ast_context.getIdentifier(name_buffer);
+  swift::Identifier equalequal_name = ast_context.getIdentifier("==");
+
+  ResultLocationInfo result_loc_info(source_loc);
+  result_loc_info.orig_expr = expr;
+
+  swift::DeclContext *new_decl_context = m_function_decl;
+
+  if (m_repl) {
+    new_decl_context = decl_context;
+  }
+
+  llvm::SmallVector<swift::ASTNode, 3> body;
+  llvm::SmallVector<swift::Expr *, 3> false_body;
+  const bool is_static = false;
+  const auto specifier = swift::VarDecl::Specifier::Var;
+  const bool is_capture_list = false;
+  result_loc_info.tmp_var_decl = new (ast_context)
+      swift::VarDecl(is_static, specifier, is_capture_list, source_loc, name,
+                     swift::Type(), new_decl_context);
+  result_loc_info.tmp_var_decl->setImplicit();
+  result_loc_info.tmp_var_decl->setAccess(swift::AccessLevel::Internal);
+  result_loc_info.tmp_var_decl->setSetterAccess(swift::AccessLevel::Internal);
+
+  swift::NamedPattern *var_pattern =
+      new (ast_context) swift::NamedPattern(result_loc_info.tmp_var_decl, true);
+
+  const swift::StaticSpellingKind static_spelling_kind =
+      swift::StaticSpellingKind::KeywordStatic;
+  result_loc_info.binding_decl = swift::PatternBindingDecl::create(
+      ast_context, source_loc, static_spelling_kind, source_loc, var_pattern,
+      expr, new_decl_context);
+  result_loc_info.binding_decl->setImplicit();
+  result_loc_info.binding_decl->setStatic(false);
+
+  body.push_back(result_loc_info.binding_decl);
+  body.push_back(result_loc_info.tmp_var_decl);
+
+  if (in_return) {
+    result_loc_info.return_stmt =
+        new (ast_context) swift::ReturnStmt(source_loc, nullptr);
+    body.push_back(result_loc_info.return_stmt);
+  }
+  swift::IntegerLiteralExpr *one_expr = new (ast_context)
+      swift::IntegerLiteralExpr(swift::StringRef("1"), source_loc, true);
+  false_body.push_back(one_expr);
+  swift::UnresolvedDeclRefExpr *equalequal_expr = new (ast_context)
+      swift::UnresolvedDeclRefExpr(equalequal_name,
+                                   swift::DeclRefKind::BinaryOperator,
+                                   swift::DeclNameLoc(source_loc));
+  false_body.push_back(equalequal_expr);
+  swift::IntegerLiteralExpr *zero_expr = new (ast_context)
+      swift::IntegerLiteralExpr(swift::StringRef("0"), source_loc, true);
+  false_body.push_back(zero_expr);
+  swift::SequenceExpr *zero_equals_one_expr = swift::SequenceExpr::create(
+      ast_context, llvm::ArrayRef<swift::Expr *>(false_body));
+
+  zero_equals_one_expr->setImplicit();
+  swift::BraceStmt *body_stmt = swift::BraceStmt::create(
+      ast_context, source_loc, llvm::ArrayRef<swift::ASTNode>(body), source_loc,
+      true);
+
+  // Default construct a label info that contains nothing for the while
+  // statement
+  swift::LabeledStmtInfo label_info;
+
+  swift::RepeatWhileStmt *assign_stmt = new (ast_context)
+      swift::RepeatWhileStmt(label_info, source_loc, zero_equals_one_expr,
+                             source_loc, body_stmt, true);
+  result_loc_info.wrapper_stmt = assign_stmt;
+
+  m_result_info.push_back(result_loc_info);
+  return assign_stmt;
+}
+
+bool SwiftASTManipulator::RewriteResult() {
+  class ReturnFinder : public swift::ASTWalker {
+  public:
+    ReturnFinder(SwiftASTManipulator &manipulator)
+        : m_manipulator(manipulator) {}
+
+    void SetDeclContext(swift::DeclContext *decl_context) {
+      m_decl_context = decl_context;
+    }
+
+    virtual bool walkToDeclPre(swift::Decl *decl) {
+      // Don't step into function declarations, they may have returns, but we
+      // don't want
+      // to instrument them.
+      swift::DeclKind kind = decl->getKind();
+      switch (kind) {
+      case swift::DeclKind::Func:
+      case swift::DeclKind::Class:
+      case swift::DeclKind::Struct:
+        return false;
+      default:
+        return true;
+      }
+    }
+
+    virtual std::pair<bool, swift::Expr *> walkToExprPre(swift::Expr *expr) {
+      // Don't step into closure definitions, they may have returns, but we
+      // don't want
+      // to instrument them either.
+      swift::ExprKind kind = expr->getKind();
+      if (kind == swift::ExprKind::Closure)
+        return {false, expr};
+      else
+        return {true, expr};
+    }
+
+    virtual swift::Stmt *walkToStmtPost(swift::Stmt *stmt) {
+      swift::ReturnStmt *possible_return =
+          swift::dyn_cast<swift::ReturnStmt>(stmt);
+      if (possible_return && possible_return->hasResult()) {
+        swift::Expr *return_expr = possible_return->getResult();
+        if (return_expr) {
+          const bool add_return = true;
+          swift::Stmt *return_stmt;
+
+          return_stmt = m_manipulator.ConvertExpressionToTmpReturnVarAccess(
+              return_expr, possible_return->getStartLoc(), add_return,
+              m_decl_context);
+          if (return_stmt)
+            stmt = return_stmt;
+        }
+      }
+      return stmt;
+    }
+
+  private:
+    SwiftASTManipulator &m_manipulator;
+    swift::DeclContext *m_decl_context = nullptr;
+  };
+
+  if (!IsValid())
+    return false;
+
+  if (m_repl) {
+    ReturnFinder return_finder(*this);
+
+    // First step, walk the function body converting returns to assignments to
+    // temp variables + return:
+
+    for (swift::Decl *decl : m_source_file.Decls) {
+      if (auto top_level_code_decl =
+              llvm::dyn_cast<swift::TopLevelCodeDecl>(decl)) {
+        return_finder.SetDeclContext(top_level_code_decl);
+        top_level_code_decl->getBody()->walk(return_finder);
+      }
+    }
+
+    // Second step, fetch the last expression, and if it is non-null, set it to
+    // a temp result as well:
+
+    if (!m_source_file.Decls.empty()) {
+      swift::Decl *last_decl = *(m_source_file.Decls.end() - 1);
+
+      if (auto last_top_level_code_decl =
+              llvm::dyn_cast<swift::TopLevelCodeDecl>(last_decl)) {
+        llvm::MutableArrayRef<swift::ASTNode>::iterator back_iterator;
+
+        back_iterator =
+            last_top_level_code_decl->getBody()->getElements().end() - 1;
+        swift::ASTNode last_element = *back_iterator;
+
+        swift::Expr *last_expr = last_element.dyn_cast<swift::Expr *>();
+
+        if (last_expr) {
+          swift::Stmt *temp_result_decl = ConvertExpressionToTmpReturnVarAccess(
+              last_expr, last_expr->getStartLoc(), false,
+              last_top_level_code_decl);
+          if (temp_result_decl)
+            *back_iterator = temp_result_decl;
+        }
+      }
+    }
+  } else {
+    swift::BraceStmt *user_body = GetUserBody();
+
+    llvm::MutableArrayRef<swift::ASTNode> orig_elements =
+        user_body->getElements();
+    llvm::SmallVector<swift::Expr *, 1> return_values;
+
+    // The function body is wrapped in an "if (true)" when constructed, so the
+    // function body can not be empty
+    // or it was one we didn't make (or the optimizer is getting smart on us
+    // when it has no business doing that.)
+    if (orig_elements.size() == 0) {
+      // This is an empty expression, nothing to do here...
+      return true;
+    }
+
+    // First step, walk the function body converting returns to assignments to
+    // temp variables + return:
+    ReturnFinder return_finder(*this);
+    user_body->walk(return_finder);
+
+    // Second step, fetch the last expression, and if it is non-null, set it to
+    // a temp result as well:
+
+    llvm::MutableArrayRef<swift::ASTNode>::iterator back_iterator;
+    back_iterator = user_body->getElements().end() - 1;
+    swift::ASTNode last_element = *back_iterator;
+
+    swift::Expr *last_expr = last_element.dyn_cast<swift::Expr *>();
+
+    if (last_expr) {
+      swift::Stmt *temp_result_decl = ConvertExpressionToTmpReturnVarAccess(
+          last_expr, last_expr->getStartLoc(), false, nullptr);
+      if (temp_result_decl)
+        *back_iterator = temp_result_decl;
+    }
+  }
+
+  return true;
+}
+
+namespace {
+class AssignmentMaker {
+private:
+  llvm::SmallSet<swift::VarDecl *, 1> &m_persistent_vars;
+  swift::ASTContext &m_ast_context;
+  llvm::SmallVector<swift::ASTNode, 3> &m_elements;
+  llvm::SmallVectorImpl<swift::ASTNode>::iterator &m_ei;
+
+public:
+  void MakeOneAssignment(swift::VarDecl *var_decl, swift::Expr *initializer,
+                         swift::SourceLoc location) {
+    if (!m_persistent_vars.count(var_decl))
+      return;
+
+    swift::Type target_type = var_decl->getDeclContext()->mapTypeIntoContext(
+        var_decl->getInterfaceType());
+    swift::LValueType *target_lvalue_type = swift::LValueType::get(target_type);
+
+    const bool implicit = true;
+    const swift::AccessSemantics uses_direct_property_access =
+        swift::AccessSemantics::Ordinary;
+
+    swift::DeclRefExpr *decl_ref = new (m_ast_context)
+        swift::DeclRefExpr(var_decl, swift::DeclNameLoc(location), implicit,
+                           uses_direct_property_access, target_lvalue_type);
+
+    swift::AssignExpr *assignment = new (m_ast_context)
+        swift::AssignExpr(decl_ref, location, initializer, implicit);
+
+    assignment->setType(m_ast_context.TheEmptyTupleType);
+
+    llvm::SmallVectorImpl<swift::ASTNode>::iterator next_iter = m_ei + 1;
+
+    swift::ASTNode assignment_node((swift::Expr *)assignment);
+
+    m_ei = m_elements.insert(next_iter, swift::ASTNode(assignment_node));
+  }
+
+  AssignmentMaker(llvm::SmallSet<swift::VarDecl *, 1> &persistent_vars,
+                  swift::ASTContext &ast_context,
+                  llvm::SmallVector<swift::ASTNode, 3> &elements,
+                  llvm::SmallVectorImpl<swift::ASTNode>::iterator &ei)
+      : m_persistent_vars(persistent_vars), m_ast_context(ast_context),
+        m_elements(elements), m_ei(ei) {}
+};
+} // namespace
+
+void SwiftASTManipulator::MakeDeclarationsPublic() {
+  if (!IsValid())
+    return;
+
+  class Publicist : public swift::ASTWalker {
+    virtual bool walkToDeclPre(swift::Decl *decl) {
+      if (swift::ValueDecl *value_decl =
+              llvm::dyn_cast<swift::ValueDecl>(decl)) {
+        auto access = swift::AccessLevel::Public;
+        if (swift::isa<swift::ClassDecl>(value_decl) ||
+            swift::isa<swift::ClassDecl>(value_decl->getDeclContext())) {
+          access = swift::AccessLevel::Open;
+        }
+
+        value_decl->overwriteAccess(access);
+        if (swift::AbstractStorageDecl *var_decl =
+                llvm::dyn_cast<swift::AbstractStorageDecl>(decl))
+          var_decl->overwriteSetterAccess(access);
+      }
+
+      return true;
+    }
+  };
+
+  Publicist p;
+
+  for (swift::Decl *decl : m_source_file.Decls) {
+    decl->walk(p);
+  }
+}
+
+static bool hasInit(swift::PatternBindingDecl *pattern_binding) {
+  for (unsigned i = 0, e = pattern_binding->getNumPatternEntries(); i != e; ++i)
+    if (pattern_binding->getInit(i))
+      return true;
+  return false;
+}
+
+static swift::Expr *getFirstInit(swift::PatternBindingDecl *pattern_binding) {
+  for (unsigned i = 0, e = pattern_binding->getNumPatternEntries(); i != e; ++i)
+    if (pattern_binding->getInit(i))
+      return pattern_binding->getInit(i);
+  return nullptr;
+}
+
+bool SwiftASTManipulator::CheckPatternBindings() {
+  for (swift::Decl *top_level_decl : m_source_file.Decls) {
+    if (swift::TopLevelCodeDecl *top_level_code =
+            llvm::dyn_cast<swift::TopLevelCodeDecl>(top_level_decl)) {
+      for (swift::ASTNode &node : top_level_code->getBody()->getElements()) {
+        if (swift::Decl *decl = node.dyn_cast<swift::Decl *>()) {
+          if (swift::PatternBindingDecl *pattern_binding =
+                  llvm::dyn_cast<swift::PatternBindingDecl>(decl)) {
+            if (!(pattern_binding->isImplicit() || hasInit(pattern_binding))) {
+              m_source_file.getASTContext().Diags.diagnose(
+                  pattern_binding->getStartLoc(),
+                  swift::diag::repl_must_be_initialized);
+
+              return false;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return true;
+}
+void SwiftASTManipulator::FindVariableDeclarations(
+    llvm::SmallVectorImpl<size_t> &found_declarations, bool repl) {
+  if (!IsValid())
+    return;
+
+  auto register_one_var = [this,
+                           &found_declarations](swift::VarDecl *var_decl) {
+    VariableInfo persistent_info;
+
+    swift::Identifier name = var_decl->getName();
+
+    size_t persistent_info_location = m_variables.size();
+
+    auto type = var_decl->getDeclContext()->mapTypeIntoContext(
+        var_decl->getInterfaceType());
+    persistent_info.m_name = name;
+    persistent_info.m_type =
+        CompilerType(&var_decl->getASTContext(), type.getPointer());
+    persistent_info.m_decl = var_decl;
+
+    m_variables.push_back(persistent_info);
+
+    found_declarations.push_back(persistent_info_location);
+  };
+
+  if (m_repl) {
+    for (swift::Decl *decl : m_source_file.Decls) {
+      if (swift::VarDecl *var_decl = llvm::dyn_cast<swift::VarDecl>(decl)) {
+        if (!var_decl->getName().str().startswith("$")) {
+          register_one_var(var_decl);
+        }
+      }
+    }
+  } else {
+    swift::BraceStmt *user_body = GetUserBody();
+
+    llvm::ArrayRef<swift::ASTNode> body_elements = user_body->getElements();
+
+    llvm::SmallVector<swift::ASTNode, 3> elements(body_elements.begin(),
+                                                  body_elements.end());
+
+    for (swift::ASTNode &element : elements) {
+      if (swift::Decl *element_decl = element.dyn_cast<swift::Decl *>()) {
+        if (swift::VarDecl *var_decl =
+                llvm::dyn_cast<swift::VarDecl>(element_decl)) {
+          if (!var_decl->isDebuggerVar()) // skip bona fide external variables
+                                          // or variables we've already tagged
+          {
+            swift::Identifier name = var_decl->getName();
+
+            if (name.str().startswith("$")) {
+              var_decl->setDebuggerVar(true);
+              register_one_var(var_decl);
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+void SwiftASTManipulator::FindNonVariableDeclarations(
+    llvm::SmallVectorImpl<swift::ValueDecl *> &non_variables) {
+  if (!IsValid())
+    return;
+
+  if (!m_repl)
+    return; // we don't do this for non-REPL expressions... yet
+
+  for (swift::Decl *decl : m_source_file.Decls) {
+    if (swift::ValueDecl *value_decl = llvm::dyn_cast<swift::ValueDecl>(decl)) {
+      if (!llvm::isa<swift::VarDecl>(value_decl) && value_decl->hasName()) {
+        non_variables.push_back(value_decl);
+      }
+    }
+  }
+}
+
+void SwiftASTManipulator::InsertResult(
+    swift::VarDecl *result_var, swift::Type &result_type,
+    SwiftASTManipulator::ResultLocationInfo &result_info) {
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+
+  CompilerType return_ast_type(&ast_context, result_type.getPointer());
+
+  result_var->overwriteAccess(swift::AccessLevel::Public);
+  result_var->overwriteSetterAccess(swift::AccessLevel::Public);
+
+  // Finally, go reset the return expression to the new result variable for each
+  // of the return expressions.
+
+  // Make an LValueType of our result type for use in the assign expression.
+  swift::LValueType *lvalue_result = swift::LValueType::get(result_type);
+
+  // QUERY: Can I just make one of the LHS decl's and reuse it for all the
+  // assigns?
+  const swift::AccessSemantics uses_direct_property_access =
+      swift::AccessSemantics::Ordinary;
+  swift::DeclRefExpr *lhs_expr = new (ast_context)
+      swift::DeclRefExpr(result_var, swift::DeclNameLoc(result_info.source_loc),
+                         true, uses_direct_property_access, lvalue_result);
+
+  swift::Expr *init_expr = getFirstInit(result_info.binding_decl);
+  swift::AssignExpr *assign_expr = new (ast_context)
+      swift::AssignExpr(lhs_expr, result_info.source_loc, init_expr, true);
+  assign_expr->setType(ast_context.TheEmptyTupleType);
+
+  llvm::SmallVector<swift::ASTNode, 2> new_body;
+  new_body.push_back(assign_expr);
+  if (result_info.return_stmt != nullptr)
+    new_body.push_back(result_info.return_stmt);
+  swift::BraceStmt *body_stmt = swift::BraceStmt::create(
+      ast_context, result_info.source_loc,
+      llvm::ArrayRef<swift::ASTNode>(new_body), result_info.source_loc, true);
+  result_info.wrapper_stmt->setBody(body_stmt);
+}
+
+void SwiftASTManipulator::InsertError(swift::VarDecl *error_var,
+                                      swift::Type &error_type) {
+  if (!m_do_stmt)
+    return;
+
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+
+  CompilerType error_ast_type(&ast_context, error_type.getPointer());
+
+  error_var->overwriteAccess(swift::AccessLevel::Public);
+  error_var->overwriteSetterAccess(swift::AccessLevel::Public);
+
+  // Finally, go reset the return expression to the new result variable for each
+  // of the return expressions.
+
+  // Make an LValueType of our result type for use in the assign expression.
+  swift::LValueType *lvalue_result = swift::LValueType::get(error_type);
+
+  // QUERY: Can I just make one of the LHS decl's and reuse it for all the
+  // assigns?
+  swift::SourceLoc error_loc = m_do_stmt->getBody()->getStartLoc();
+
+  const swift::AccessSemantics uses_direct_property_access =
+      swift::AccessSemantics::Ordinary;
+  swift::DeclRefExpr *lhs_expr = new (ast_context)
+      swift::DeclRefExpr(error_var, swift::DeclNameLoc(error_loc), true,
+                         uses_direct_property_access, lvalue_result);
+
+  swift::BraceStmt *catch_body =
+      llvm::dyn_cast<swift::BraceStmt>(m_catch_stmt->getBody());
+  if (!catch_body) {
+    // Fixme - log this error somehow.
+    return;
+  }
+  llvm::ArrayRef<swift::ASTNode> body_elements = catch_body->getElements();
+
+  llvm::SmallVector<swift::ASTNode, 3> elements(body_elements.begin(),
+                                                body_elements.end());
+  swift::PatternBindingDecl *binding_decl = nullptr;
+
+  for (swift::ASTNode &element : elements) {
+    if (swift::Decl *element_decl = element.dyn_cast<swift::Decl *>()) {
+      binding_decl = llvm::dyn_cast<swift::PatternBindingDecl>(element_decl);
+      if (binding_decl)
+        break;
+    }
+  }
+
+  swift::Expr *init_expr = getFirstInit(binding_decl);
+  swift::AssignExpr *assign_expr =
+      new (ast_context) swift::AssignExpr(lhs_expr, error_loc, init_expr, true);
+  assign_expr->setType(ast_context.TheEmptyTupleType);
+
+  llvm::SmallVector<swift::ASTNode, 2> new_body;
+  new_body.push_back(assign_expr);
+
+  swift::BraceStmt *body_stmt = swift::BraceStmt::create(
+      ast_context, error_loc, llvm::ArrayRef<swift::ASTNode>(new_body),
+      error_loc, true);
+  m_catch_stmt->setBody(body_stmt);
+}
+
+bool SwiftASTManipulator::FixupResultAfterTypeChecking(Status &error) {
+  if (!IsValid()) {
+    error.SetErrorString("Operating on invalid SwiftASTManipulator");
+    return false;
+  }
+  // Run through the result decls and figure out the return type.
+
+  size_t num_results = m_result_info.size();
+  if (num_results == 0)
+    return true;
+
+  swift::Type result_type;
+  for (size_t i = 0; i < num_results; i++) {
+    swift::VarDecl *the_decl = m_result_info[i].tmp_var_decl;
+    if (the_decl->hasType()) {
+      swift::Type its_type = the_decl->getType();
+      if (result_type.isNull()) {
+        result_type = its_type;
+      } else if (!its_type.getPointer()->isEqual(result_type)) {
+        std::string prev_type_name = result_type.getPointer()->getString();
+        std::string cur_type_name = its_type.getPointer()->getString();
+
+        error.SetErrorStringWithFormat(
+            "Type for %zuth return value is inconsistent, previous type: %s, "
+            "current type: %s.",
+            i, prev_type_name.c_str(), cur_type_name.c_str());
+        return false;
+      }
+    } else {
+      error.SetErrorStringWithFormat(
+          "Type of %zuth return value could not be determined.", i);
+      return false;
+    }
+  }
+
+  if (result_type.isNull()) {
+    error.SetErrorString("Could not find the result type for this expression.");
+    return false;
+  } else if (result_type->is<swift::ErrorType>()) {
+    error.SetErrorString("Result type is the error type.");
+    return false;
+  }
+
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+
+  CompilerType return_ast_type(&ast_context, result_type.getPointer());
+  swift::Identifier result_var_name =
+      ast_context.getIdentifier(GetResultName());
+  SwiftASTManipulatorBase::VariableMetadataSP metadata_sp(
+      new VariableMetadataResult());
+
+  swift::VarDecl *result_var =
+      AddExternalVariable(result_var_name, return_ast_type, metadata_sp);
+
+  result_var->overwriteAccess(swift::AccessLevel::Public);
+  result_var->overwriteSetterAccess(swift::AccessLevel::Public);
+
+  // Finally, go reset the return expression to the new result variable for each
+  // of the return expressions.
+
+  for (SwiftASTManipulator::ResultLocationInfo &result_info : m_result_info) {
+    InsertResult(result_var, result_type, result_info);
+  }
+
+  // Finally we have to do pretty much the same transformation on the error
+  // object.
+  // First we need to find it:
+  if (m_catch_stmt) {
+    // Search for the error variable, so we can read it and its type,
+    // then call InsertError to replace it with an assignment to the error
+    // variable.
+    swift::BraceStmt *catch_body =
+        llvm::dyn_cast<swift::BraceStmt>(m_catch_stmt->getBody());
+    llvm::ArrayRef<swift::ASTNode> body_elements = catch_body->getElements();
+
+    llvm::SmallVector<swift::ASTNode, 3> elements(body_elements.begin(),
+                                                  body_elements.end());
+
+    for (swift::ASTNode &element : elements) {
+      if (swift::Decl *element_decl = element.dyn_cast<swift::Decl *>()) {
+        if (swift::VarDecl *var_decl =
+                llvm::dyn_cast<swift::VarDecl>(element_decl)) {
+          if (var_decl->hasType()) {
+            swift::Identifier error_var_name =
+                ast_context.getIdentifier(GetErrorName());
+            if (error_var_name != var_decl->getName())
+              continue;
+
+            swift::Type error_type = var_decl->getInterfaceType();
+            CompilerType error_ast_type(&ast_context, error_type.getPointer());
+            SwiftASTManipulatorBase::VariableMetadataSP error_metadata_sp(
+                new VariableMetadataError());
+
+            swift::VarDecl *error_var = AddExternalVariable(
+                error_var_name, error_ast_type, error_metadata_sp);
+
+            error_var->overwriteAccess(swift::AccessLevel::Public);
+            error_var->overwriteSetterAccess(swift::AccessLevel::Public);
+
+            InsertError(error_var, error_type);
+            break;
+          }
+        }
+      }
+    }
+  }
+
+  return true;
+}
+
+swift::VarDecl *
+SwiftASTManipulator::AddExternalVariable(swift::Identifier name,
+                                         CompilerType &type,
+                                         VariableMetadataSP &metadata_sp) {
+  if (!IsValid())
+    return nullptr;
+
+  VariableInfo variables[1];
+
+  variables[0].m_name = name;
+  variables[0].m_type = type;
+  variables[0].m_metadata = metadata_sp;
+
+  if (!AddExternalVariables(variables))
+    return nullptr;
+
+  return variables[0].m_decl;
+}
+
+static swift::PatternBindingDecl *
+GetPatternBindingForVarDecl(swift::VarDecl *var_decl,
+                            swift::DeclContext *containing_context) {
+  swift::ASTContext &ast_context = var_decl->getASTContext();
+
+  const bool is_implicit = true;
+
+  swift::NamedPattern *named_pattern =
+      new (ast_context) swift::NamedPattern(var_decl, is_implicit);
+
+  swift::Type type =
+      containing_context->mapTypeIntoContext(var_decl->getInterfaceType());
+  swift::TypedPattern *typed_pattern = new (ast_context)
+      swift::TypedPattern(named_pattern, swift::TypeLoc::withoutLoc(type));
+
+  swift::PatternBindingDecl *pattern_binding =
+      swift::PatternBindingDecl::create(
+          ast_context, swift::SourceLoc(), swift::StaticSpellingKind::None,
+          var_decl->getLoc(), typed_pattern, nullptr, containing_context);
+  pattern_binding->setImplicit(true);
+
+  return pattern_binding;
+}
+
+static inline swift::Type GetSwiftType(CompilerType type) {
+  return swift::Type(
+      reinterpret_cast<swift::TypeBase *>(type.GetOpaqueQualType()));
+}
+
+bool SwiftASTManipulator::AddExternalVariables(
+    llvm::MutableArrayRef<VariableInfo> variables) {
+  if (!IsValid())
+    return false;
+
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+
+  if (m_repl) {
+    // In the REPL, we're only adding the result variable.
+
+    if (variables.empty()) {
+      return true;
+    }
+
+    assert(variables.size() == 1);
+
+    SwiftASTManipulator::VariableInfo &variable = variables[0];
+
+    const bool is_static = false;
+    auto specifier = variable.GetVarSpecifier();
+    bool is_capture_list = variable.GetIsCaptureList();
+    swift::SourceLoc loc;
+    swift::Identifier name = variable.m_name;
+    swift::Type var_type = GetSwiftType(variable.m_type);
+
+    // If the type is an inout or lvalue type (happens if this is an argument)
+    // strip that part off:
+
+    swift::VarDecl *redirected_var_decl =
+        new (ast_context) swift::VarDecl(is_static, specifier, is_capture_list,
+                                         loc, name, var_type, &m_source_file);
+    redirected_var_decl->setInterfaceType(var_type);
+
+    swift::TopLevelCodeDecl *top_level_code =
+        new (ast_context) swift::TopLevelCodeDecl(&m_source_file);
+
+    swift::PatternBindingDecl *pattern_binding =
+        GetPatternBindingForVarDecl(redirected_var_decl, top_level_code);
+
+    swift::ASTNode elements[] = {pattern_binding};
+
+    swift::BraceStmt *brace_stmt =
+        swift::BraceStmt::create(ast_context, loc, elements, loc, true);
+
+    top_level_code->setBody(brace_stmt);
+
+    redirected_var_decl->setImplicit(true);
+
+    m_source_file.Decls.insert(m_source_file.Decls.begin(), top_level_code);
+    m_source_file.Decls.insert(m_source_file.Decls.begin(),
+                               redirected_var_decl);
+
+    variable.m_decl = redirected_var_decl;
+
+    if (log) {
+      std::string s;
+      llvm::raw_string_ostream ss(s);
+      variable.m_decl->dump(ss);
+      ss.flush();
+
+      log->Printf(
+          "[SwiftASTManipulator::AddExternalVariables] Injected variable %s",
+          s.c_str());
+    }
+
+    m_variables.push_back(variable);
+  } else {
+    swift::BraceStmt *body = m_function_decl->getBody();
+    llvm::ArrayRef<swift::ASTNode> body_elements = body->getElements();
+
+    llvm::SmallVector<swift::ASTNode, 3> elements(body_elements.begin(),
+                                                  body_elements.end());
+    llvm::SmallVectorImpl<swift::ASTNode>::iterator element_iterator =
+        elements.begin();
+    const bool is_static = false;
+
+    for (SwiftASTManipulator::VariableInfo &variable : variables) {
+      swift::SourceLoc loc = m_function_decl->getBody()->getLBraceLoc();
+      swift::FuncDecl *containing_function = m_function_decl;
+      swift::Identifier name = variable.m_name;
+      auto specifier = variable.GetVarSpecifier();
+      bool is_capture_list = variable.GetIsCaptureList();
+
+      bool is_self = !variable.m_name.str().compare("$__lldb_injected_self");
+
+      if (is_self) {
+        if (!m_wrapper_decl)
+          continue;
+
+        loc = m_wrapper_decl->getBody()->getLBraceLoc();
+        containing_function = m_wrapper_decl;
+      }
+
+      // This might be a referenced type, which will confuse the type checker.
+      // The access pattern for these types is the same as for the referent
+      // type, so it is fine to
+      // just strip it off.
+      // FIXME: If this is a weak managed type, then it could ostensibly go away
+      // out from under us,
+      // but for now we aren't playing with reference counts to keep things
+      // alive in the expression parser.
+      SwiftASTContext *swift_ast_ctx = llvm::dyn_cast_or_null<SwiftASTContext>(
+          variable.m_type.GetTypeSystem());
+
+      CompilerType referent_type;
+
+      if (swift_ast_ctx)
+        referent_type = swift_ast_ctx->GetReferentType(variable.m_type);
+
+      // One tricky bit here is that this var may be an argument to the function
+      // whose context we are
+      // emulating, and that argument might be of "inout" type.  We need to
+      // strip the inout off the type
+      // or the initial parse will fail.  Fortunately, the variable access goes
+      // the same regardless of whether
+      // it is inout or not, so we don't have to do anything more to get this to
+      // work.
+      swift::Type var_type =
+          GetSwiftType(referent_type)->getWithoutSpecifierType();
+      if (is_self) {
+        // Another tricky bit is that the Metatype types we get have the
+        // "Representation" already attached (i.e.
+        // "@thick", "@thin".)  But the representation is a SIL level thing, and
+        // if it is attached to types that
+        // we hand the parser, it throws a verifier error & aborts.  So we strip
+        // it off here:
+        swift::MetatypeType *metatype_type =
+            llvm::dyn_cast<swift::MetatypeType>(var_type.getPointer());
+        if (metatype_type) {
+          var_type = swift::Type(
+              swift::MetatypeType::get(metatype_type->getInstanceType()));
+        }
+      }
+
+      swift::VarDecl *redirected_var_decl = new (ast_context)
+          swift::VarDecl(is_static, specifier, is_capture_list, loc, name,
+                         var_type, containing_function);
+      redirected_var_decl->setInterfaceType(
+          var_type->mapTypeOutOfContext());
+      redirected_var_decl->setDebuggerVar(true);
+      redirected_var_decl->setImplicit(true);
+
+      swift::PatternBindingDecl *pattern_binding =
+          GetPatternBindingForVarDecl(redirected_var_decl, containing_function);
+
+      if (var_type->getAs<swift::WeakStorageType>()) {
+        redirected_var_decl->getAttrs().add(
+            new (ast_context) swift::OwnershipAttr(swift::SourceRange(),
+                                                   swift::Ownership::Weak));
+      }
+
+      if (is_self) {
+        // we need to inject into the wrapper
+
+        swift::BraceStmt *wrapper_body = m_wrapper_decl->getBody();
+        llvm::ArrayRef<swift::ASTNode> wrapper_elements =
+            wrapper_body->getElements();
+
+        llvm::SmallVector<swift::ASTNode, 3> wrapper_elements_copy(
+            wrapper_elements.begin(), wrapper_elements.end());
+        llvm::SmallVectorImpl<swift::ASTNode>::iterator
+            wrapper_element_iterator = wrapper_elements_copy.begin();
+
+        wrapper_element_iterator = wrapper_elements_copy.insert(
+            wrapper_element_iterator, swift::ASTNode(pattern_binding));
+        wrapper_element_iterator = wrapper_elements_copy.insert(
+            wrapper_element_iterator, swift::ASTNode(redirected_var_decl));
+
+        m_wrapper_decl->setBody(swift::BraceStmt::create(
+            ast_context, wrapper_body->getLBraceLoc(),
+            ast_context.AllocateCopy(wrapper_elements_copy),
+            wrapper_body->getRBraceLoc()));
+      } else {
+        element_iterator =
+            elements.insert(element_iterator, swift::ASTNode(pattern_binding));
+        element_iterator = elements.insert(element_iterator,
+                                           swift::ASTNode(redirected_var_decl));
+      }
+
+      variable.m_decl = redirected_var_decl;
+
+      if (log) {
+        std::string s;
+        llvm::raw_string_ostream ss(s);
+        variable.m_decl->dump(ss);
+        ss.flush();
+
+        log->Printf(
+            "[SwiftASTManipulator::AddExternalVariables] Injected variable %s",
+            s.c_str());
+      }
+
+      m_variables.push_back(variable);
+    }
+
+    m_function_decl->setBody(swift::BraceStmt::create(
+        ast_context, body->getLBraceLoc(), ast_context.AllocateCopy(elements),
+        body->getRBraceLoc()));
+  }
+
+  return true;
+}
+
+static void AppendToCaptures(swift::ASTContext &ast_context,
+                             swift::FuncDecl *func_decl,
+                             swift::VarDecl *capture_decl) {
+  llvm::ArrayRef<swift::CapturedValue> old_captures =
+      func_decl->getCaptureInfo().getCaptures();
+  llvm::SmallVector<swift::CapturedValue, 2> captures(old_captures.begin(),
+                                                      old_captures.end());
+
+  captures.push_back(swift::CapturedValue(capture_decl, 0));
+
+  func_decl->getCaptureInfo().setCaptures(ast_context.AllocateCopy(captures));
+}
+
+static swift::VarDecl *FindArgInFunction(swift::ASTContext &ast_context,
+                                         swift::FuncDecl *func_decl) {
+  auto name = ast_context.getIdentifier("$__lldb_arg");
+
+  for (auto *paramList : func_decl->getParameterLists()) {
+    for (auto param : *paramList)
+      if (param->getName() == name)
+        return param;
+  }
+
+  return nullptr;
+}
+
+bool SwiftASTManipulator::FixCaptures() {
+  if (!IsValid())
+    return false;
+
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+
+  swift::VarDecl *function_arg_decl =
+      FindArgInFunction(ast_context, m_function_decl);
+  swift::VarDecl *wrapper_arg_decl = nullptr;
+
+  if (m_wrapper_decl)
+    wrapper_arg_decl = FindArgInFunction(ast_context, m_wrapper_decl);
+
+  if (!function_arg_decl)
+    return false;
+
+  if (m_wrapper_decl && (!wrapper_arg_decl))
+    return false;
+
+  for (VariableInfo &variable : m_variables) {
+    if (!variable.m_decl)
+      continue;
+
+    if (variable.m_decl->getStorageKind() !=
+        swift::AbstractStorageDecl::Computed)
+      continue;
+
+    swift::FuncDecl *getter_decl = variable.m_decl->getGetter();
+    swift::FuncDecl *setter_decl = variable.m_decl->getSetter();
+
+    swift::DeclContext *decl_context = variable.m_decl->getDeclContext();
+
+    if (decl_context == (swift::DeclContext *)m_function_decl) {
+      AppendToCaptures(ast_context, getter_decl, function_arg_decl);
+      AppendToCaptures(ast_context, setter_decl, function_arg_decl);
+    } else if (decl_context == (swift::DeclContext *)m_wrapper_decl) {
+      AppendToCaptures(ast_context, getter_decl, wrapper_arg_decl);
+      AppendToCaptures(ast_context, setter_decl, wrapper_arg_decl);
+    } else {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+swift::ValueDecl *SwiftASTManipulator::MakeGlobalTypealias(
+    swift::Identifier name, CompilerType &type, bool make_private) {
+  if (!IsValid())
+    return nullptr;
+
+  swift::SourceLoc source_loc;
+
+  if (m_extension_decl)
+    source_loc = m_extension_decl->getEndLoc();
+  else
+    source_loc = m_function_decl->getEndLoc();
+
+  swift::ASTContext &ast_context = m_source_file.getASTContext();
+
+  llvm::MutableArrayRef<swift::TypeLoc> inherited;
+  swift::TypeAliasDecl *type_alias_decl = new (ast_context)
+      swift::TypeAliasDecl(source_loc, swift::SourceLoc(), name, source_loc,
+                           nullptr, &m_source_file);
+  type_alias_decl->setUnderlyingType(GetSwiftType(type));
+
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+  if (log) {
+
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    type_alias_decl->dump(ss);
+    ss.flush();
+
+    log->Printf("Made global type alias for %s (%p) in context (%p):\n%s",
+                name.get(), GetSwiftType(type).getPointer(), &ast_context,
+                s.c_str());
+  }
+
+  if (type_alias_decl) {
+    if (make_private) {
+      type_alias_decl->overwriteAccess(swift::AccessLevel::Private);
+    }
+    m_source_file.Decls.push_back(type_alias_decl);
+  }
+
+  return type_alias_decl;
+}
+
+SwiftASTManipulator::TypesForResultFixup
+SwiftASTManipulator::GetTypesForResultFixup(uint32_t language_flags) {
+  TypesForResultFixup ret;
+
+  for (swift::Decl *decl : m_source_file.Decls) {
+    if (auto extension_decl = llvm::dyn_cast<swift::ExtensionDecl>(decl)) {
+      if (language_flags & SwiftUserExpression::eLanguageFlagIsWeakSelf) {
+        if (extension_decl->getGenericParams() &&
+            extension_decl->getGenericParams()->getParams().size() == 1) {
+          swift::GenericTypeParamDecl *type_parameter =
+              extension_decl->getGenericParams()->getParams()[0];
+          swift::NameAliasType *name_alias_type =
+              llvm::dyn_cast_or_null<swift::NameAliasType>(
+                  type_parameter->getSuperclass().getPointer());
+
+          if (name_alias_type) {
+            // FIXME: What if the generic parameter is concrete?
+            ret.Wrapper_archetype =
+                extension_decl
+                    ->mapTypeIntoContext(
+                        type_parameter->getDeclaredInterfaceType())
+                    ->castTo<swift::ArchetypeType>();
+            ret.context_alias = name_alias_type;
+            ret.context_real = name_alias_type->getSinglyDesugaredType();
+          } else {
+            ret.Wrapper_archetype =
+                extension_decl
+                    ->mapTypeIntoContext(
+                        type_parameter->getDeclaredInterfaceType())
+                    ->castTo<swift::ArchetypeType>();
+            ret.context_real =
+                (swift::TypeBase *)type_parameter->getSuperclass().getPointer();
+          }
+        }
+      } else if (!ret.context_alias) {
+        swift::NameAliasType *name_alias_type =
+            llvm::dyn_cast<swift::NameAliasType>(
+                extension_decl->getExtendedType().getPointer());
+
+        if (name_alias_type) {
+          ret.context_alias = name_alias_type;
+          ret.context_real = name_alias_type->getSinglyDesugaredType();
+        }
+      }
+    }
+  }
+
+  return ret;
+}
+
+static swift::Type ReplaceInType(swift::Type orig, swift::TypeBase *from,
+                                 swift::TypeBase *to) {
+  std::function<swift::Type(swift::Type)> Replacer =
+      [from, to](swift::Type orig_type) {
+        if (orig_type.getPointer() == from) {
+          return swift::Type(to);
+        } else {
+          return orig_type;
+        }
+      };
+
+  return orig.transform(Replacer);
+}
+
+swift::Type SwiftASTManipulator::FixupResultType(swift::Type &result_type,
+                                                 uint32_t language_flags) {
+  TypesForResultFixup result_fixup_types =
+      GetTypesForResultFixup(language_flags);
+
+  if (result_fixup_types.Wrapper_archetype && result_fixup_types.context_real) {
+    result_type =
+        ReplaceInType(result_type, result_fixup_types.Wrapper_archetype,
+                      result_fixup_types.context_real);
+  }
+
+  if (result_fixup_types.context_alias && result_fixup_types.context_real) {
+    // This is what we ought to do, but the printing logic doesn't handle the
+    // resulting types properly yet.
+    // result_type = ReplaceInType(result_type,
+    // result_fixup_types.context_alias, result_fixup_types.context_real);
+    if (result_type.getPointer() == result_fixup_types.context_alias) {
+      result_type = result_fixup_types.context_alias->getSinglyDesugaredType();
+    }
+  }
+
+  return result_type;
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.h b/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.h
index e69de29bb..54a861b8a 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftASTManipulator.h
@@ -0,0 +1,231 @@
+//===-- SwiftASTManipulator.h -----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftASTManipulator_h
+#define liblldb_SwiftASTManipulator_h
+
+#include "lldb/Core/ClangForward.h"
+#include "lldb/Expression/Expression.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Utility/Stream.h"
+
+#include "swift/AST/Decl.h"
+#include "swift/AST/Identifier.h"
+#include "swift/AST/Stmt.h"
+#include "llvm/ADT/SmallVector.h"
+
+namespace lldb_private {
+
+class SwiftASTManipulatorBase {
+public:
+  class VariableMetadata {
+  public:
+    VariableMetadata() {}
+    virtual ~VariableMetadata() {}
+    virtual unsigned GetType() = 0;
+  };
+
+  class VariableMetadataResult
+      : public SwiftASTManipulatorBase::VariableMetadata {
+  public:
+    virtual ~VariableMetadataResult();
+    constexpr static unsigned Type() { return 'Resu'; }
+    virtual unsigned GetType() { return Type(); }
+  };
+
+  class VariableMetadataError
+      : public SwiftASTManipulatorBase::VariableMetadata {
+  public:
+    virtual ~VariableMetadataError();
+    constexpr static unsigned Type() { return 'Erro'; }
+    virtual unsigned GetType() { return Type(); }
+  };
+
+  typedef std::shared_ptr<VariableMetadata> VariableMetadataSP;
+
+  struct VariableInfo {
+    CompilerType GetType() const { return m_type; }
+    swift::Identifier GetName() const { return m_name; }
+    swift::VarDecl *GetDecl() const { return m_decl; }
+    swift::VarDecl::Specifier GetVarSpecifier() const;
+    bool GetIsCaptureList() const;
+
+    VariableInfo() : m_type(), m_name(), m_metadata() {}
+
+    VariableInfo(CompilerType &type, swift::Identifier name,
+                 VariableMetadataSP metadata,
+                 swift::VarDecl::Specifier specifier,
+                 bool is_capture_list = false)
+        : m_type(type), m_name(name), m_var_specifier(specifier),
+          m_is_capture_list(is_capture_list), m_metadata(metadata) {}
+
+    template <class T> bool MetadataIs() const {
+      return (m_metadata && m_metadata->GetType() == T::Type());
+    }
+
+    void Print(Stream &stream) const;
+
+    void SetType(CompilerType new_type) { m_type = new_type; }
+
+    friend class SwiftASTManipulator;
+
+  protected:
+    CompilerType m_type;
+    swift::Identifier m_name;
+    swift::VarDecl *m_decl = nullptr;
+    swift::VarDecl::Specifier m_var_specifier = swift::VarDecl::Specifier::Var;
+    bool m_is_capture_list = false;
+
+  public:
+    VariableMetadataSP m_metadata;
+  };
+
+  SwiftASTManipulatorBase(swift::SourceFile &source_file, bool repl)
+      : m_source_file(source_file), m_variables(), m_repl(repl) {
+    DoInitialization();
+  }
+
+  llvm::MutableArrayRef<VariableInfo> GetVariableInfo() { return m_variables; }
+
+  bool IsValid() {
+    return m_repl || (m_function_decl &&
+                      (m_wrapper_decl || (!m_extension_decl)) && m_do_stmt);
+  }
+
+  swift::BraceStmt *GetUserBody();
+
+private:
+  void DoInitialization();
+
+protected:
+  swift::SourceFile &m_source_file;
+  llvm::SmallVector<VariableInfo, 1> m_variables;
+
+  bool m_repl = false;
+
+  swift::FuncDecl *m_function_decl =
+      nullptr; // the function containing the expression's code
+  swift::FuncDecl *m_wrapper_decl =
+      nullptr; // the wrapper that invokes the right generic function.
+  swift::ExtensionDecl *m_extension_decl =
+      nullptr; // the extension m_function_decl lives in, if it's a method.
+  swift::DoCatchStmt *m_do_stmt =
+      nullptr; // the do{}catch(){} statement whose body is the main body.
+  swift::CatchStmt *m_catch_stmt =
+      nullptr; // the body of the catch - we patch the assignment there to
+               // capture any error thrown.
+};
+
+class SwiftASTManipulator : public SwiftASTManipulatorBase {
+public:
+  SwiftASTManipulator(swift::SourceFile &source_file, bool repl);
+
+  static void WrapExpression(Stream &wrapped_stream, const char *text,
+                             uint32_t language_flags,
+                             const EvaluateExpressionOptions &options,
+                             const Expression::SwiftGenericInfo &generic_info,
+                             uint32_t &first_body_line);
+
+  void FindSpecialNames(llvm::SmallVectorImpl<swift::Identifier> &names,
+                        llvm::StringRef prefix);
+
+  swift::VarDecl *AddExternalVariable(swift::Identifier name,
+                                      CompilerType &type,
+                                      VariableMetadataSP &metadata_sp);
+
+  bool AddExternalVariables(llvm::MutableArrayRef<VariableInfo> variables);
+
+  bool RewriteResult();
+
+  void MakeDeclarationsPublic();
+
+  bool CheckPatternBindings();
+
+  void
+  FindVariableDeclarations(llvm::SmallVectorImpl<size_t> &found_declarations,
+                           bool repl);
+
+  void FindNonVariableDeclarations(
+      llvm::SmallVectorImpl<swift::ValueDecl *> &non_variables);
+
+  bool FixCaptures();
+
+  swift::ValueDecl *MakeGlobalTypealias(swift::Identifier name,
+                                        CompilerType &type,
+                                        bool make_private = true);
+
+  swift::Type FixupResultType(swift::Type &result_type,
+                              uint32_t language_flags);
+
+  bool FixupResultAfterTypeChecking(Status &error);
+
+  static const char *GetArgumentName() { return "$__lldb_arg"; }
+  static const char *GetResultName() { return "$__lldb_result"; }
+  static const char *GetErrorName() { return "$__lldb_error_result"; }
+  static const char *GetUserCodeStartMarker() {
+    return "/*__LLDB_USER_START__*/\n";
+  }
+  static const char *GetUserCodeEndMarker() {
+    return "\n/*__LLDB_USER_END__*/";
+  }
+
+private:
+  uint32_t m_tmpname_idx = 0;
+
+  typedef llvm::SmallVectorImpl<swift::ASTNode> Body;
+
+  swift::Stmt *ConvertExpressionToTmpReturnVarAccess(
+      swift::Expr *expr, const swift::SourceLoc &source_loc, bool in_return,
+      swift::DeclContext *decl_context);
+
+  struct ResultLocationInfo {
+    swift::VarDecl
+        *tmp_var_decl; // This points to the first stage tmp result decl
+    swift::RepeatWhileStmt
+        *wrapper_stmt; // This is the RepeatWhile statement that we make up.
+    swift::PatternBindingDecl
+        *binding_decl;      // This is the expression returned by this block
+    swift::Expr *orig_expr; // This is the original expression that we resolved
+                            // to this type
+    swift::ReturnStmt *return_stmt; // If this block does a return, this is the
+                                    // return statement
+    const swift::SourceLoc source_loc; // This is the source location of this
+                                       // return in the overall expression.
+
+    ResultLocationInfo(const swift::SourceLoc &in_source_loc)
+        : tmp_var_decl(nullptr), wrapper_stmt(nullptr), binding_decl(nullptr),
+          orig_expr(nullptr), return_stmt(nullptr), source_loc(in_source_loc) {}
+
+    ResultLocationInfo(const ResultLocationInfo &rhs)
+        : tmp_var_decl(rhs.tmp_var_decl), wrapper_stmt(rhs.wrapper_stmt),
+          binding_decl(rhs.binding_decl), orig_expr(rhs.orig_expr),
+          return_stmt(rhs.return_stmt), source_loc(rhs.source_loc) {}
+  };
+
+  void InsertResult(swift::VarDecl *result_var, swift::Type &result_type,
+                    ResultLocationInfo &result_info);
+
+  void InsertError(swift::VarDecl *error_var, swift::Type &error_type);
+
+  struct TypesForResultFixup {
+    swift::ArchetypeType *Wrapper_archetype = nullptr;
+    swift::NameAliasType *context_alias = nullptr;
+    swift::TypeBase *context_real = nullptr;
+  };
+
+  TypesForResultFixup GetTypesForResultFixup(uint32_t language_flags);
+
+  std::vector<ResultLocationInfo> m_result_info;
+};
+} // namespace lldb_private
+
+#endif
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftDiagnostic.h b/source/Plugins/ExpressionParser/Swift/SwiftDiagnostic.h
index e69de29bb..0ace58949 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftDiagnostic.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftDiagnostic.h
@@ -0,0 +1,56 @@
+//===-- SwiftDiagnostic.h -------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef lldb_SwiftDiagnostic_h
+#define lldb_SwiftDiagnostic_h
+
+#include <vector>
+
+#include "swift/AST/DiagnosticConsumer.h"
+
+#include "lldb/lldb-defines.h"
+#include "lldb/lldb-types.h"
+
+#include "lldb/Expression/DiagnosticManager.h"
+
+namespace lldb_private {
+
+class SwiftDiagnostic : public Diagnostic {
+public:
+  typedef std::vector<swift::DiagnosticInfo::FixIt> FixItList;
+
+  static inline bool classof(const SwiftDiagnostic *) { return true; }
+  static inline bool classof(const Diagnostic *diag) {
+    return diag->getKind() == eDiagnosticOriginSwift;
+  }
+
+  SwiftDiagnostic(const char *message, DiagnosticSeverity severity,
+                  uint32_t compiler_id, uint32_t buffer_id)
+      : Diagnostic(message, severity, eDiagnosticOriginSwift, compiler_id),
+        m_buffer_id(buffer_id) {}
+
+  virtual ~SwiftDiagnostic() = default;
+
+  bool HasFixIts() const override { return !m_fixit_vec.empty(); }
+
+  void AddFixIt(const swift::DiagnosticInfo::FixIt &fixit) {
+    m_fixit_vec.push_back(fixit);
+  }
+
+  const FixItList &FixIts() const { return m_fixit_vec; }
+
+  uint32_t GetBufferID() const { return m_buffer_id; }
+
+private:
+  uint32_t m_buffer_id;
+  FixItList m_fixit_vec;
+};
+
+} // namespace lldb_private
+#endif /* lldb_SwiftDiagnostic_h */
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.cpp b/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.cpp
index e69de29bb..eb4ac0b49 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.cpp
@@ -0,0 +1,2038 @@
+//===-- SwiftExpressionParser.cpp -------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftExpressionParser.h"
+
+#include "SwiftASTManipulator.h"
+#include "SwiftREPLMaterializer.h"
+#include "SwiftSILManipulator.h"
+#include "SwiftUserExpression.h"
+
+#include "Plugins/ExpressionParser/Swift/SwiftDiagnostic.h"
+#include "Plugins/ExpressionParser/Swift/SwiftExpressionVariable.h"
+#include "lldb/Core/Module.h"
+#include "lldb/Core/ModuleList.h"
+#include "lldb/Core/ModuleSpec.h"
+#include "lldb/Core/ValueObject.h"
+#include "lldb/Expression/DiagnosticManager.h"
+#include "lldb/Expression/Expression.h"
+#include "lldb/Expression/ExpressionSourceCode.h"
+#include "lldb/Expression/IRExecutionUnit.h"
+#include "lldb/Symbol/CompileUnit.h"
+#include "lldb/Symbol/SymbolVendor.h"
+#include "lldb/Symbol/Type.h"
+#include "lldb/Symbol/VariableList.h"
+#include "lldb/Target/ExecutionContext.h"
+#include "lldb/Target/StackFrame.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Target/Thread.h"
+#include "lldb/Utility/Log.h"
+#include "lldb/Utility/Stream.h"
+
+#include "llvm-c/Analysis.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Verifier.h"
+#include "llvm/Support/Host.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/TargetSelect.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include "clang/Basic/Module.h"
+#include "clang/Rewrite/Core/RewriteBuffer.h"
+
+#include "swift/AST/ASTContext.h"
+#include "swift/AST/DiagnosticConsumer.h"
+#include "swift/AST/DiagnosticEngine.h"
+#include "swift/AST/IRGenOptions.h"
+#include "swift/AST/Module.h"
+#include "swift/AST/ModuleLoader.h"
+#include "swift/Basic/SourceManager.h"
+#include "swift/ClangImporter/ClangImporter.h"
+#include "swift/Demangling/Demangle.h"
+#include "swift/Frontend/Frontend.h"
+#include "swift/Parse/LocalContext.h"
+#include "swift/Parse/PersistentParserState.h"
+#include "swift/SIL/SILDebuggerClient.h"
+#include "swift/SIL/SILFunction.h"
+#include "swift/SIL/SILModule.h"
+#include "swift/SILOptimizer/PassManager/Passes.h"
+#include "swift/Serialization/SerializedModuleLoader.h"
+#include "swift/Subsystems.h"
+
+using namespace lldb_private;
+
+SwiftExpressionParser::SwiftExpressionParser(
+    ExecutionContextScope *exe_scope, Expression &expr,
+    const EvaluateExpressionOptions &options)
+    : ExpressionParser(exe_scope, expr, options.GetGenerateDebugInfo()),
+      m_expr(expr), m_triple(), m_llvm_context(), m_module(),
+      m_execution_unit_sp(), m_swift_ast_context(NULL), m_sc(),
+      m_stack_frame_wp(), m_options(options) {
+  assert(expr.Language() == lldb::eLanguageTypeSwift);
+
+  // TODO This code is copied from ClangExpressionParser.cpp.
+  // Factor this out into common code.
+
+  lldb::TargetSP target_sp;
+  if (exe_scope) {
+    target_sp = exe_scope->CalculateTarget();
+
+    lldb::StackFrameSP stack_frame = exe_scope->CalculateStackFrame();
+
+    if (stack_frame) {
+      m_stack_frame_wp = stack_frame;
+      m_sc = stack_frame->GetSymbolContext(lldb::eSymbolContextEverything);
+    } else {
+      m_sc.target_sp = target_sp;
+    }
+  }
+
+  if (target_sp && target_sp->GetArchitecture().IsValid()) {
+    std::string triple = target_sp->GetArchitecture().GetTriple().str();
+
+    int dash_count = 0;
+    for (size_t i = 0; i < triple.size(); ++i) {
+      if (triple[i] == '-')
+        dash_count++;
+      if (dash_count == 3) {
+        triple.resize(i);
+        break;
+      }
+    }
+
+    m_triple = triple;
+  } else {
+    m_triple = llvm::sys::getDefaultTargetTriple();
+  }
+
+  if (target_sp) {
+    m_swift_ast_context = llvm::cast_or_null<SwiftASTContext>(
+        target_sp->GetScratchTypeSystemForLanguage(nullptr,
+                                                   lldb::eLanguageTypeSwift));
+  }
+}
+
+static void DescribeFileUnit(Stream &s, swift::FileUnit *file_unit) {
+  s.PutCString("kind = ");
+
+  switch (file_unit->getKind()) {
+  default: { s.PutCString("<unknown>"); }
+  case swift::FileUnitKind::Source: {
+    s.PutCString("Source, ");
+    if (swift::SourceFile *source_file =
+            llvm::dyn_cast<swift::SourceFile>(file_unit)) {
+      s.Printf("filename = '%s', ", source_file->getFilename().str().c_str());
+      s.PutCString("source file kind = ");
+      switch (source_file->Kind) {
+      case swift::SourceFileKind::Library:
+        s.PutCString("Library");
+      case swift::SourceFileKind::Main:
+        s.PutCString("Main");
+      case swift::SourceFileKind::REPL:
+        s.PutCString("REPL");
+      case swift::SourceFileKind::SIL:
+        s.PutCString("SIL");
+      }
+    }
+  } break;
+  case swift::FileUnitKind::Builtin: {
+    s.PutCString("Builtin");
+  } break;
+  case swift::FileUnitKind::SerializedAST:
+  case swift::FileUnitKind::ClangModule: {
+    s.PutCString("SerializedAST, ");
+    swift::LoadedFile *loaded_file = llvm::cast<swift::LoadedFile>(file_unit);
+    s.Printf("filename = '%s'", loaded_file->getFilename().str().c_str());
+  } break;
+  };
+}
+
+// Gets the full module name from the module passed in.
+
+static void GetNameFromModule(swift::ModuleDecl *module, std::string &result) {
+  result.clear();
+  if (module) {
+    const char *name = module->getName().get();
+    if (!name)
+      return;
+    result.append(name);
+    const clang::Module *clang_module = module->findUnderlyingClangModule();
+
+    // At present, there doesn't seem to be any way to get the full module path
+    // from the Swift side.
+    if (!clang_module)
+      return;
+
+    for (const clang::Module *cur_module = clang_module->Parent; cur_module;
+         cur_module = cur_module->Parent) {
+      if (!cur_module->Name.empty()) {
+        result.insert(0, 1, '.');
+        result.insert(0, cur_module->Name);
+      }
+    }
+  }
+}
+
+// Largely lifted from swift::performAutoImport, but serves our own nefarious
+// purposes.
+bool SwiftExpressionParser::PerformAutoImport(swift::SourceFile &source_file,
+                                              bool user_imports,
+                                              Status &error) {
+  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  const std::vector<ConstString> *cu_modules = nullptr;
+
+  CompileUnit *compile_unit = m_sc.comp_unit;
+
+  if (compile_unit)
+    cu_modules = &compile_unit->GetImportedModules();
+
+  llvm::SmallVector<swift::ModuleDecl::ImportedModule, 2> imported_modules;
+  llvm::SmallVector<std::pair<swift::ModuleDecl::ImportedModule,
+                              swift::SourceFile::ImportOptions>,
+                    2>
+      additional_imports;
+
+  source_file.getImportedModules(imported_modules,
+                                 swift::ModuleDecl::ImportFilter::All);
+
+  std::set<ConstString> loaded_modules;
+
+  auto load_one_module = [this, log, &loaded_modules, &imported_modules,
+                          &additional_imports,
+                          &error](const ConstString &module_name) {
+    error.Clear();
+    if (loaded_modules.count(module_name))
+      return true;
+
+    if (log)
+      log->Printf("[PerformAutoImport] Importing module %s",
+                  module_name.AsCString());
+
+    loaded_modules.insert(module_name);
+
+    swift::ModuleDecl *swift_module = nullptr;
+    lldb::StackFrameSP this_frame_sp(m_stack_frame_wp.lock());
+
+    if (module_name == ConstString(m_swift_ast_context->GetClangImporter()
+                                       ->getImportedHeaderModule()
+                                       ->getName()
+                                       .str()))
+      swift_module =
+          m_swift_ast_context->GetClangImporter()->getImportedHeaderModule();
+    else if (this_frame_sp) {
+      lldb::ProcessSP process_sp(this_frame_sp->CalculateProcess());
+      if (process_sp)
+        swift_module = m_swift_ast_context->FindAndLoadModule(
+            module_name, *process_sp.get(), error);
+    } else
+      swift_module = m_swift_ast_context->GetModule(module_name, error);
+
+    if (!swift_module || !error.Success() ||
+        m_swift_ast_context->HasFatalErrors()) {
+      if (log)
+        log->Printf("[PerformAutoImport] Couldnt import module %s: %s",
+                    module_name.AsCString(), error.AsCString());
+
+      if (!swift_module || m_swift_ast_context->HasFatalErrors()) {
+        return false;
+      }
+    }
+
+    if (log) {
+      log->Printf("Importing %s with source files:", module_name.AsCString());
+
+      for (swift::FileUnit *file_unit : swift_module->getFiles()) {
+        StreamString ss;
+        DescribeFileUnit(ss, file_unit);
+        log->Printf("  %s", ss.GetData());
+      }
+    }
+
+    additional_imports.push_back(std::make_pair(
+        std::make_pair(swift::ModuleDecl::AccessPathTy(), swift_module),
+        swift::SourceFile::ImportOptions()));
+    imported_modules.push_back(
+        std::make_pair(swift::ModuleDecl::AccessPathTy(), swift_module));
+
+    return true;
+  };
+
+  if (!user_imports) {
+    if (!load_one_module(ConstString("Swift")))
+      return false;
+
+    if (cu_modules) {
+      for (const ConstString &module_name : *cu_modules) {
+        if (!load_one_module(module_name))
+          return false;
+      }
+    }
+  } else {
+    llvm::SmallVector<swift::ModuleDecl::ImportedModule, 2> parsed_imports;
+
+    source_file.getImportedModules(parsed_imports,
+                                   swift::ModuleDecl::ImportFilter::All);
+
+    SwiftPersistentExpressionState *persistent_expression_state =
+        llvm::cast<SwiftPersistentExpressionState>(
+            m_sc.target_sp->GetPersistentExpressionStateForLanguage(
+                lldb::eLanguageTypeSwift));
+
+    for (auto module_pair : parsed_imports) {
+      swift::ModuleDecl *module = module_pair.second;
+      if (module) {
+        std::string module_name;
+        GetNameFromModule(module, module_name);
+        if (!module_name.empty()) {
+          ConstString module_const_str(module_name);
+          if (log)
+            log->Printf("[PerformAutoImport] Performing auto import on found "
+                        "module: %s.\n",
+                        module_name.c_str());
+          if (!load_one_module(module_const_str))
+            return false;
+          if (1 /* How do we tell we are in REPL or playground mode? */) {
+            persistent_expression_state->AddHandLoadedModule(module_const_str);
+          }
+        }
+      }
+    }
+
+    // Finally get the hand-loaded modules from the
+    // SwiftPersistentExpressionState and load them into this context:
+    if (!persistent_expression_state->RunOverHandLoadedModules(load_one_module))
+      return false;
+  }
+
+  source_file.addImports(additional_imports);
+
+  return true;
+}
+
+class VariableMetadataPersistent
+    : public SwiftASTManipulatorBase::VariableMetadata {
+public:
+  VariableMetadataPersistent(lldb::ExpressionVariableSP &persistent_variable_sp)
+      : m_persistent_variable_sp(persistent_variable_sp) {}
+
+  static constexpr unsigned Type() { return 'Pers'; }
+  virtual unsigned GetType() { return Type(); }
+  lldb::ExpressionVariableSP m_persistent_variable_sp;
+};
+
+class VariableMetadataVariable
+    : public SwiftASTManipulatorBase::VariableMetadata {
+public:
+  VariableMetadataVariable(lldb::VariableSP &variable_sp)
+      : m_variable_sp(variable_sp) {}
+
+  static constexpr unsigned Type() { return 'Vari'; }
+  virtual unsigned GetType() { return Type(); }
+  lldb::VariableSP m_variable_sp;
+};
+
+static CompilerType ImportType(SwiftASTContext &target_context,
+                               CompilerType source_type) {
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(source_type.GetTypeSystem());
+
+  if (swift_ast_ctx == nullptr)
+    return CompilerType();
+
+  if (swift_ast_ctx == &target_context)
+    return source_type;
+
+  Status error, mangled_error;
+  CompilerType target_type;
+
+  // First try to get the type by using the mangled name,
+  // That will save the mangling step ImportType would have to do:
+
+  ConstString type_name = source_type.GetTypeName();
+  ConstString mangled_counterpart;
+  bool found_counterpart = type_name.GetMangledCounterpart(mangled_counterpart);
+  if (found_counterpart)
+    target_type = target_context.GetTypeFromMangledTypename(
+        mangled_counterpart.GetCString(), mangled_error);
+
+  if (!target_type.IsValid())
+    target_type = target_context.ImportType(source_type, error);
+
+  return target_type;
+}
+
+namespace {
+class LLDBNameLookup : public swift::SILDebuggerClient {
+public:
+  LLDBNameLookup(SwiftExpressionParser &parser, swift::SourceFile &source_file,
+                 SwiftExpressionParser::SILVariableMap &variable_map,
+                 SymbolContext &sc)
+      : SILDebuggerClient(source_file.getASTContext()), m_parser(parser),
+        m_log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS)),
+        m_source_file(source_file), m_variable_map(variable_map), m_sc(sc) {
+    source_file.getParentModule()->setDebugClient(this);
+
+    if (m_sc.target_sp) {
+      m_persistent_vars = llvm::cast<SwiftPersistentExpressionState>(
+          m_sc.target_sp->GetPersistentExpressionStateForLanguage(
+              lldb::eLanguageTypeSwift));
+    }
+  }
+
+  virtual ~LLDBNameLookup() {}
+
+  virtual bool shouldGlobalize(swift::Identifier Name, swift::DeclKind Kind) {
+    if (m_parser.GetOptions().GetREPLEnabled())
+      return true;
+    else {
+      // Extensions have to be globalized, there's no way to mark them as local
+      // to the function, since their
+      // name is the name of the thing being extended...
+      if (Kind == swift::DeclKind::Extension)
+        return true;
+
+      // Operators need to be parsed at the global scope regardless of name.
+      if (Kind == swift::DeclKind::Func && Name.isOperator())
+        return true;
+
+      const char *name_cstr = Name.get();
+      if (name_cstr && name_cstr[0] == '$') {
+        if (m_log)
+          m_log->Printf("[LLDBNameLookup::shouldGlobalize] Returning true to "
+                        "globalizing %s",
+                        name_cstr);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  virtual void didGlobalize(swift::Decl *decl) {
+    swift::ValueDecl *value_decl = swift::dyn_cast<swift::ValueDecl>(decl);
+    if (value_decl) {
+      // It seems weird to be asking this again, but some DeclKinds must be
+      // moved to
+      // the source-file level to be legal.  But we don't want to register them
+      // with
+      // lldb unless they are of the kind lldb explicitly wants to globalize.
+      if (shouldGlobalize(value_decl->getBaseName().getIdentifier(),
+                          value_decl->getKind()))
+        m_staged_decls.AddDecl(value_decl, false, ConstString());
+    }
+  }
+
+  virtual bool lookupOverrides(swift::DeclBaseName Name, swift::DeclContext *DC,
+                               swift::SourceLoc Loc, bool IsTypeLookup,
+                               ResultVector &RV) {
+    static unsigned counter = 0;
+    unsigned count = counter++;
+
+    if (m_log) {
+      m_log->Printf("[LLDBNameLookup::lookupOverrides(%u)] Searching for %s",
+                    count, Name.getIdentifier().get());
+    }
+
+    return false;
+  }
+
+  virtual bool lookupAdditions(swift::DeclBaseName Name, swift::DeclContext *DC,
+                               swift::SourceLoc Loc, bool IsTypeLookup,
+                               ResultVector &RV) {
+    static unsigned counter = 0;
+    unsigned count = counter++;
+
+    StringRef NameStr = Name.getIdentifier().str();
+
+    if (m_log) {
+      m_log->Printf("[LLDBNameLookup::lookupAdditions (%u)] Searching for %s",
+                    count, Name.getIdentifier().str().str().c_str());
+    }
+
+    ConstString name_const_str(NameStr);
+    std::vector<swift::ValueDecl *> results;
+
+    // First look up the matching Decl's we've made in this compile, then pass
+    // that list to the
+    // persistent decls, which will only add decls it has that are NOT
+    // equivalent to the decls
+    // we made locally.
+
+    m_staged_decls.FindMatchingDecls(name_const_str, results);
+
+    // Next look up persistent decls matching this name.  Then, if we are in the
+    // plain expression parser, and we
+    // aren't looking at a debugger variable, filter out persistent results of
+    // the same kind as one found by the
+    // ordinary lookup mechanism in the parser .  The problem
+    // we are addressing here is the case where the user has entered the REPL
+    // while in an ordinary debugging session
+    // to play around.  While there, e.g., they define a class that happens to
+    // have the same name as one in the
+    // program, then in some other context "expr" will call the class they've
+    // defined, not the one in the program
+    // itself would use.  Plain "expr" should behave as much like code in the
+    // program would, so we want to favor
+    // entities of the same DeclKind & name from the program over ones defined
+    // in the REPL.  For function decls we
+    // check the interface type and full name so we don't remove overloads that
+    // don't exist in the current scope.
+    //
+    // Note also, we only do this for the persistent decls.  Anything in the
+    // "staged" list has been defined in this
+    // expr setting and so is more local than local.
+
+    bool skip_results_with_matching_kind =
+        !(m_parser.GetOptions().GetREPLEnabled() ||
+          m_parser.GetOptions().GetPlaygroundTransformEnabled() ||
+          (!NameStr.empty() && NameStr.front() == '$'));
+
+    size_t num_external_results = RV.size();
+    if (skip_results_with_matching_kind && num_external_results > 0) {
+      std::vector<swift::ValueDecl *> persistent_results;
+      m_persistent_vars->GetSwiftPersistentDecls(name_const_str,
+                                                 persistent_results);
+
+      size_t num_persistent_results = persistent_results.size();
+      for (size_t idx = 0; idx < num_persistent_results; idx++) {
+        swift::ValueDecl *value_decl = persistent_results[idx];
+        if (!value_decl)
+          continue;
+        swift::DeclName value_decl_name = value_decl->getFullName();
+        swift::DeclKind value_decl_kind = value_decl->getKind();
+        swift::CanType value_interface_type =
+            value_decl->getInterfaceType()->getCanonicalType();
+
+        bool is_function = swift::isa<swift::AbstractFunctionDecl>(value_decl);
+
+        bool skip_it = false;
+        for (size_t rv_idx = 0; rv_idx < num_external_results; rv_idx++) {
+          if (swift::ValueDecl *rv_decl = RV[rv_idx].getValueDecl()) {
+            if (value_decl_kind == rv_decl->getKind()) {
+              if (is_function) {
+                swift::DeclName rv_full_name = rv_decl->getFullName();
+                if (rv_full_name.matchesRef(value_decl_name)) {
+                  // If the full names match, make sure the interface types
+                  // match:
+                  if (rv_decl->getInterfaceType()->getCanonicalType() ==
+                      value_interface_type)
+                    skip_it = true;
+                }
+              } else {
+                skip_it = true;
+              }
+
+              if (skip_it)
+                break;
+            }
+          }
+        }
+        if (!skip_it)
+          results.push_back(value_decl);
+      }
+    } else {
+      m_persistent_vars->GetSwiftPersistentDecls(name_const_str, results);
+    }
+
+    for (size_t idx = 0; idx < results.size(); idx++) {
+      swift::ValueDecl *value_decl = results[idx];
+      assert(&DC->getASTContext() ==
+             &value_decl->getASTContext()); // no import required
+      RV.push_back(swift::LookupResultEntry(value_decl));
+    }
+
+    return results.size() > 0;
+  }
+
+  virtual swift::SILValue emitLValueForVariable(swift::VarDecl *var,
+                                                swift::SILBuilder &builder) {
+    SwiftSILManipulator manipulator(builder);
+
+    swift::Identifier variable_name = var->getName();
+    ConstString variable_const_string(variable_name.get());
+
+    SwiftExpressionParser::SILVariableMap::iterator vi =
+        m_variable_map.find(variable_const_string.AsCString());
+
+    if (vi == m_variable_map.end())
+      return swift::SILValue();
+
+    return manipulator.emitLValueForVariable(var, vi->second);
+  }
+
+  SwiftPersistentExpressionState::SwiftDeclMap &GetStagedDecls() {
+    return m_staged_decls;
+  }
+
+  virtual swift::Identifier getPreferredPrivateDiscriminator() {
+    if (m_sc.comp_unit) {
+      if (lldb_private::Module *module = m_sc.module_sp.get()) {
+        if (lldb_private::SymbolVendor *symbol_vendor =
+                module->GetSymbolVendor()) {
+          std::string private_discriminator_string;
+          if (symbol_vendor->GetCompileOption("-private-discriminator",
+                                              private_discriminator_string,
+                                              m_sc.comp_unit)) {
+            return m_source_file.getASTContext().getIdentifier(
+                private_discriminator_string);
+          }
+        }
+      }
+    }
+
+    return swift::Identifier();
+  }
+
+private:
+  SwiftExpressionParser &m_parser;
+  Log *m_log;
+  swift::SourceFile &m_source_file;
+  SwiftExpressionParser::SILVariableMap &m_variable_map;
+  SymbolContext m_sc;
+  SwiftPersistentExpressionState *m_persistent_vars = nullptr;
+  SwiftPersistentExpressionState::SwiftDeclMap
+      m_staged_decls; // We stage the decls we are globalize in this map.
+  // They will get copied over to the SwiftPersistentVariable
+  // store if the parse succeeds.
+};
+} // END Anonymous namespace
+
+static void
+AddRequiredAliases(Block *block, lldb::StackFrameSP &stack_frame_sp,
+                   SwiftASTContext &swift_ast_context,
+                   SwiftASTManipulator &manipulator,
+                   const Expression::SwiftGenericInfo &generic_info) {
+  // First, emit the typealias for "$__lldb_context"
+
+  do {
+    if (!block)
+      break;
+
+    Function *function = block->CalculateSymbolContextFunction();
+
+    if (!function)
+      break;
+
+    constexpr bool can_create = true;
+    Block &function_block(function->GetBlock(can_create));
+
+    lldb::VariableListSP variable_list_sp(
+        function_block.GetBlockVariableList(true));
+
+    if (!variable_list_sp)
+      break;
+
+    lldb::VariableSP self_var_sp(
+        variable_list_sp->FindVariable(ConstString("self")));
+
+    if (!self_var_sp)
+      break;
+
+    CompilerType self_type;
+
+    if (stack_frame_sp) {
+      lldb::ValueObjectSP valobj_sp =
+          stack_frame_sp->GetValueObjectForFrameVariable(
+              self_var_sp, lldb::eNoDynamicValues);
+
+      if (valobj_sp)
+        self_type = valobj_sp->GetCompilerType();
+    }
+
+    if (!self_type.IsValid()) {
+      if (Type *type = self_var_sp->GetType()) {
+        self_type = type->GetForwardCompilerType();
+      }
+    }
+
+    if (!self_type.IsValid() ||
+        !llvm::isa<SwiftASTContext>(self_type.GetTypeSystem()))
+      break;
+
+    // Import before getting the unbound version, because the unbound version
+    // may not be in the mangled name map
+
+    CompilerType imported_self_type = ImportType(swift_ast_context, self_type);
+
+    if (!imported_self_type.IsValid())
+      break;
+
+    // This might be a referenced type, in which case we really want to extend
+    // the referent:
+    imported_self_type =
+        llvm::cast<SwiftASTContext>(imported_self_type.GetTypeSystem())
+            ->GetReferentType(imported_self_type);
+
+    // If we are extending a generic class it's going to be a metatype, and we
+    // have to grab the instance type:
+    imported_self_type =
+        llvm::cast<SwiftASTContext>(imported_self_type.GetTypeSystem())
+            ->GetInstanceType(imported_self_type.GetOpaqueQualType());
+
+    Flags imported_self_type_flags(imported_self_type.GetTypeInfo());
+
+    // If 'self' is the Self archetype, resolve it to the actual metatype it is
+    if (SwiftASTContext::IsSelfArchetypeType(imported_self_type)) {
+      SwiftLanguageRuntime *swift_runtime =
+          stack_frame_sp->GetThread()->GetProcess()->GetSwiftLanguageRuntime();
+      if (CompilerType concrete_self_type = swift_runtime->GetConcreteType(
+              stack_frame_sp.get(), ConstString("Self"))) {
+        if (SwiftASTContext *concrete_self_type_ast_ctx =
+                llvm::dyn_cast_or_null<SwiftASTContext>(
+                    concrete_self_type.GetTypeSystem())) {
+          imported_self_type = concrete_self_type_ast_ctx->CreateMetatypeType(
+              concrete_self_type);
+          imported_self_type_flags.Reset(imported_self_type.GetTypeInfo());
+          imported_self_type =
+              ImportType(swift_ast_context, imported_self_type);
+          if (imported_self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                              lldb::eTypeIsMetatype)) {
+            imported_self_type = imported_self_type.GetInstanceType();
+          }
+        }
+      }
+    }
+
+    // Get the instance type:
+    if (imported_self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                        lldb::eTypeIsMetatype)) {
+      imported_self_type = imported_self_type.GetInstanceType();
+      imported_self_type_flags.Reset(imported_self_type.GetTypeInfo());
+    }
+
+    swift::Type object_type =
+        swift::Type((swift::TypeBase *)(imported_self_type.GetOpaqueQualType()))
+            ->getWithoutSpecifierType();
+
+    if (object_type.getPointer() &&
+        (object_type.getPointer() != imported_self_type.GetOpaqueQualType()))
+      imported_self_type = CompilerType(imported_self_type.GetTypeSystem(),
+                                        object_type.getPointer());
+
+    // If the type of 'self' is a bound generic type, get the unbound version
+
+    bool is_generic = imported_self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                                      lldb::eTypeIsGeneric);
+    bool is_bound = imported_self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                                    lldb::eTypeIsBound);
+
+    if (is_generic) {
+      if (is_bound)
+        imported_self_type = imported_self_type.GetUnboundType();
+    }
+
+    // if 'self' is a weak storage type, it must be an optional.  Look through
+    // it and unpack the argument of "optional".
+
+    if (swift::WeakStorageType *weak_storage_type =
+            ((swift::TypeBase *)imported_self_type.GetOpaqueQualType())
+                ->getAs<swift::WeakStorageType>()) {
+      swift::Type referent_type = weak_storage_type->getReferentType();
+
+      swift::BoundGenericEnumType *optional_type =
+          referent_type->getAs<swift::BoundGenericEnumType>();
+
+      if (!optional_type) {
+        break;
+      }
+
+      swift::Type first_arg_type = optional_type->getGenericArgs()[0];
+
+      swift::ClassType *self_class_type =
+          first_arg_type->getAs<swift::ClassType>();
+
+      if (!self_class_type) {
+        break;
+      }
+
+      imported_self_type =
+          CompilerType(imported_self_type.GetTypeSystem(), self_class_type);
+    }
+
+    imported_self_type_flags.Reset(imported_self_type.GetTypeInfo());
+    if (imported_self_type_flags.AllClear(lldb::eTypeIsArchetype)) {
+      swift::ValueDecl *type_alias_decl = nullptr;
+
+      type_alias_decl = manipulator.MakeGlobalTypealias(
+          swift_ast_context.GetASTContext()->getIdentifier("$__lldb_context"),
+          imported_self_type);
+
+      if (!type_alias_decl) {
+        Log *log(
+            lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+        if (log)
+          log->Printf("SEP:AddRequiredAliases: Failed to make the "
+                      "$__lldb_context typealias.");
+      }
+    } else {
+      Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+      if (log)
+        log->Printf("SEP:AddRequiredAliases: Failed to resolve the self "
+                    "archetype - could not make the $__lldb_context "
+                    "typealias.");
+    }
+
+  } while (0);
+
+  // Emit the typedefs
+
+  for (const Expression::SwiftGenericInfo::Binding &binding :
+       generic_info.function_bindings) {
+    CompilerType bound_type = binding.type;
+
+    if (!llvm::isa<SwiftASTContext>(bound_type.GetTypeSystem()))
+      continue;
+
+    CompilerType imported_bound_type =
+        ImportType(swift_ast_context, bound_type);
+
+    if (!imported_bound_type.IsValid())
+      continue;
+
+    std::string alias_name("$__lldb_typeof_generic_");
+    alias_name.append(binding.name);
+
+    swift::ValueDecl *type_alias_decl = manipulator.MakeGlobalTypealias(
+        swift_ast_context.GetASTContext()->getIdentifier(alias_name),
+        imported_bound_type);
+
+    if (!type_alias_decl)
+      continue;
+  }
+}
+
+static void CountLocals(
+    SymbolContext &sc, lldb::StackFrameSP &stack_frame_sp,
+    SwiftASTContext &ast_context,
+    llvm::SmallVectorImpl<SwiftASTManipulator::VariableInfo> &local_variables) {
+  std::set<ConstString> counted_names; // avoids shadowing
+
+  if (!sc.block && !sc.function)
+    return;
+
+  Block *block = sc.block;
+  Block *top_block = block->GetContainingInlinedBlock();
+
+  if (!top_block)
+    top_block = &sc.function->GetBlock(true);
+
+  static ConstString s_self_name("self");
+
+  SwiftLanguageRuntime *language_runtime = nullptr;
+  ExecutionContextScope *scope = nullptr;
+
+  if (stack_frame_sp) {
+    language_runtime =
+        stack_frame_sp->GetThread()->GetProcess()->GetSwiftLanguageRuntime();
+    scope = stack_frame_sp.get();
+  }
+
+  // The module scoped variables are stored at the CompUnit level, so after we
+  // go through the current context,
+  // then we have to take one more pass through the variables in the CompUnit.
+  bool handling_globals = false;
+
+  while (true) {
+    VariableList variables;
+
+    if (!handling_globals) {
+
+      constexpr bool can_create = true;
+      constexpr bool get_parent_variables = false;
+      constexpr bool stop_if_block_is_inlined_function = true;
+
+      block->AppendVariables(can_create, get_parent_variables,
+                             stop_if_block_is_inlined_function,
+                             [](Variable *) { return true; }, &variables);
+    } else {
+      if (sc.comp_unit) {
+        lldb::VariableListSP globals_sp = sc.comp_unit->GetVariableList(true);
+        if (globals_sp)
+          variables.AddVariables(globals_sp.get());
+      }
+    }
+
+    for (size_t vi = 0, ve = variables.GetSize(); vi != ve; ++vi) {
+      lldb::VariableSP variable_sp(variables.GetVariableAtIndex(vi));
+
+      const ConstString &name(variable_sp->GetName());
+      const char *name_cstring = variable_sp->GetName().GetCString();
+
+      if (name.IsEmpty())
+        continue;
+
+      if (counted_names.count(name))
+        continue;
+
+      CompilerType var_type;
+
+      if (stack_frame_sp) {
+        lldb::ValueObjectSP valobj_sp =
+            stack_frame_sp->GetValueObjectForFrameVariable(
+                variable_sp, lldb::eNoDynamicValues);
+
+        if (!valobj_sp || valobj_sp->GetError().Fail()) {
+          // Ignore the variable if we couldn't find its corresponding value
+          // object.
+          // TODO if the expression tries to use an ignored variable, produce a
+          // sensible error.
+          continue;
+        } else {
+          var_type = valobj_sp->GetCompilerType();
+        }
+
+        if (var_type.IsValid() && !SwiftASTContext::IsFullyRealized(var_type)) {
+          lldb::ValueObjectSP dynamic_valobj_sp =
+              valobj_sp->GetDynamicValue(lldb::eDynamicDontRunTarget);
+
+          if (!dynamic_valobj_sp || dynamic_valobj_sp->GetError().Fail()) {
+            continue;
+          }
+        }
+      }
+
+      if (!var_type.IsValid()) {
+        Type *var_lldb_type = variable_sp->GetType();
+
+        if (var_lldb_type)
+          var_type = var_lldb_type->GetFullCompilerType();
+      }
+
+      if (!var_type.IsValid())
+        continue;
+
+      if (!llvm::isa<SwiftASTContext>(var_type.GetTypeSystem()))
+        continue;
+
+      Status error;
+      CompilerType target_type = ast_context.ImportType(var_type, error);
+
+      // If the import failed, give up
+
+      if (!target_type.IsValid())
+        continue;
+
+      // Make sure to resolve all archetypes in the variable type.
+
+      if (language_runtime && stack_frame_sp)
+        target_type = language_runtime->DoArchetypeBindingForType(
+            *stack_frame_sp, target_type, &ast_context);
+
+      // If we couldn't fully realize the type, then we aren't going to get very
+      // far making a local out of it,
+      // so discard it here.
+      Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_TYPES |
+                                                      LIBLLDB_LOG_EXPRESSIONS));
+      if (!SwiftASTContext::IsFullyRealized(target_type)) {
+        if (log) {
+          log->Printf("Discarding local %s because we couldn't fully realize "
+                      "it, our best attempt was: %s.",
+                      name_cstring,
+                      target_type.GetTypeName().AsCString("<unknown>"));
+        }
+        continue;
+      }
+
+      SwiftASTManipulatorBase::VariableMetadataSP metadata_sp(
+          new VariableMetadataVariable(variable_sp));
+
+      const char *overridden_name = name_cstring;
+
+      if (name == s_self_name) {
+        overridden_name = ConstString("$__lldb_injected_self").AsCString();
+        if (log) {
+          swift::TypeBase *swift_type =
+              (swift::TypeBase *)target_type.GetOpaqueQualType();
+          if (swift_type) {
+            std::string s;
+            llvm::raw_string_ostream ss(s);
+            swift_type->dump(ss);
+            ss.flush();
+            log->Printf("Adding injected self: type (%p) context(%p) is: %s",
+                        swift_type, ast_context.GetASTContext(), s.c_str());
+          }
+        }
+      }
+
+      SwiftASTManipulator::VariableInfo variable_info(
+          target_type,
+          ast_context.GetASTContext()->getIdentifier(overridden_name),
+          metadata_sp, swift::VarDecl::Specifier::Var);
+
+      local_variables.push_back(variable_info);
+
+      counted_names.insert(name);
+    }
+
+    if (handling_globals) {
+      // Okay, now we're done...
+      break;
+    } else if (block == top_block) {
+      // Now add the containing module block, that's what holds the module
+      // globals:
+      handling_globals = true;
+    } else
+      block = block->GetParent();
+  }
+}
+
+static void ResolveSpecialNames(
+    SymbolContext &sc, SwiftASTContext &ast_context,
+    llvm::SmallVectorImpl<swift::Identifier> &special_names,
+    llvm::SmallVectorImpl<SwiftASTManipulator::VariableInfo> &local_variables) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  if (!sc.target_sp)
+    return;
+
+  SwiftPersistentExpressionState *persistent_state =
+      llvm::cast<SwiftPersistentExpressionState>(
+          sc.target_sp->GetPersistentExpressionStateForLanguage(
+              lldb::eLanguageTypeSwift));
+
+  std::set<ConstString> resolved_names;
+
+  for (swift::Identifier &name : special_names) {
+    ConstString name_cs = ConstString(name.str());
+
+    if (resolved_names.count(name_cs))
+      continue;
+
+    resolved_names.insert(name_cs);
+
+    if (log)
+      log->Printf("Resolving special name %s", name_cs.AsCString());
+
+    lldb::ExpressionVariableSP expr_var_sp =
+        persistent_state->GetVariable(name_cs);
+
+    if (!expr_var_sp)
+      continue;
+
+    CompilerType var_type = expr_var_sp->GetCompilerType();
+
+    if (!var_type.IsValid())
+      continue;
+
+    if (!llvm::isa<SwiftASTContext>(var_type.GetTypeSystem()))
+      continue;
+
+    CompilerType target_type;
+    Status error;
+
+    target_type = ast_context.ImportType(var_type, error);
+
+    if (!target_type)
+      continue;
+
+    SwiftASTManipulatorBase::VariableMetadataSP metadata_sp(
+        new VariableMetadataPersistent(expr_var_sp));
+
+    auto specifier = llvm::cast<SwiftExpressionVariable>(expr_var_sp.get())
+                             ->GetIsModifiable()
+                         ? swift::VarDecl::Specifier::Var
+                         : swift::VarDecl::Specifier::Let;
+    SwiftASTManipulator::VariableInfo variable_info(
+        target_type, ast_context.GetASTContext()->getIdentifier(name.str()),
+        metadata_sp, specifier);
+
+    local_variables.push_back(variable_info);
+  }
+}
+
+//----------------------------------------------------------------------
+// Diagnostics are part of the ShintASTContext and we must enable and
+// disable colorization manually in the ShintASTContext. We need to
+// ensure that if we modify the setting that we restore it to what it
+// was. This class helps us to do that without having to intrument all
+// returns from a function, like in SwiftExpressionParser::Parse(...).
+//----------------------------------------------------------------------
+class SetColorize {
+public:
+  SetColorize(SwiftASTContext *swift_ast, bool colorize)
+      : m_swift_ast(swift_ast),
+        m_saved_colorize(swift_ast->SetColorizeDiagnostics(colorize)) {}
+
+  ~SetColorize() { m_swift_ast->SetColorizeDiagnostics(m_saved_colorize); }
+
+protected:
+  SwiftASTContext *m_swift_ast;
+  const bool m_saved_colorize;
+};
+
+unsigned SwiftExpressionParser::Parse(DiagnosticManager &diagnostic_manager,
+                                      uint32_t first_line, uint32_t last_line,
+                                      uint32_t line_offset) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  // In the case of playgrounds, we turn all rewriting functionality off.
+
+  const bool repl = m_options.GetREPLEnabled();
+  const bool playground = m_options.GetPlaygroundTransformEnabled();
+
+  if (!m_swift_ast_context) {
+    diagnostic_manager.PutString(
+        eDiagnosticSeverityError,
+        "No AST context to parse into.  Please parse with a target.\n");
+    return 1;
+  }
+
+  // Lazily get the clang importer if we can to make sure it exists in case we
+  // need it
+  if (!m_swift_ast_context->GetClangImporter()) {
+    diagnostic_manager.PutString(
+        eDiagnosticSeverityError,
+        "Swift expressions require OS X 10.10 / iOS 8 SDKs or later.\n");
+    return 1;
+  }
+
+  if (m_swift_ast_context->HasFatalErrors()) {
+    diagnostic_manager.PutString(eDiagnosticSeverityError,
+                                 "The AST context is in a fatal error state.");
+    return 1;
+  }
+
+  swift::ASTContext *ast_context = m_swift_ast_context->GetASTContext();
+
+  if (!ast_context) {
+    diagnostic_manager.PutString(
+        eDiagnosticSeverityError,
+        "Couldn't initialize the AST context.  Please check your settings.");
+    return 1;
+  }
+
+  if (m_swift_ast_context->HasFatalErrors()) {
+    diagnostic_manager.PutString(eDiagnosticSeverityError,
+                                 "The AST context is in a fatal error state.");
+    return 1;
+  }
+
+  // If we are using the playground, hand import the necessary modules.
+  // FIXME: We won't have to do this once the playground adds import statements
+  // for the things it needs itself.
+  if (playground) {
+    SwiftPersistentExpressionState *persistent_state =
+        llvm::cast<SwiftPersistentExpressionState>(
+            m_sc.target_sp->GetPersistentExpressionStateForLanguage(
+                lldb::eLanguageTypeSwift));
+    persistent_state->AddHandLoadedModule(ConstString("Swift"));
+  }
+
+  // TODO find a way to get contraint-solver output sent to a stream so we can
+  // log it
+  // m_swift_ast_context->GetLanguageOptions().DebugConstraintSolver = true;
+
+  m_swift_ast_context->ClearDiagnostics();
+
+  // Make a class that will set/restore the colorize setting in the
+  // SwiftASTContext for us
+  // SetColorize colorize(m_swift_ast_context,
+  // stream.GetFlags().Test(Stream::eANSIColor));
+
+  m_swift_ast_context->GetLanguageOptions().DebuggerSupport = true;
+  m_swift_ast_context->GetLanguageOptions().EnableDollarIdentifiers =
+      true; // No longer part of debugger support, set it separately.
+  m_swift_ast_context->GetLanguageOptions().EnableAccessControl =
+      (repl || playground);
+  m_swift_ast_context->GetLanguageOptions().EnableTargetOSChecking = false;
+
+  {
+    lldb::StackFrameSP this_frame_sp(m_stack_frame_wp.lock());
+    if (this_frame_sp) {
+      lldb::ProcessSP process_sp(this_frame_sp->CalculateProcess());
+      if (process_sp) {
+        Status error;
+        if (!process_sp->GetObjCLanguageRuntime()) {
+          m_swift_ast_context->GetLanguageOptions().EnableObjCInterop = false;
+        }
+      }
+    }
+  }
+
+  if (repl || playground) {
+    m_swift_ast_context->GetLanguageOptions().Playground = true;
+    m_swift_ast_context->GetIRGenOptions().Playground = true;
+  } else {
+    m_swift_ast_context->GetLanguageOptions().Playground = true;
+    m_swift_ast_context->GetIRGenOptions().Playground = false;
+  }
+
+  // For the expression parser and REPL we want to relax the requirement that
+  // you put "try" in
+  // front of every expression that might throw.
+  if (!playground) {
+    m_swift_ast_context->GetLanguageOptions().EnableThrowWithoutTry = true;
+  }
+
+  m_swift_ast_context->GetIRGenOptions().OptMode
+          = swift::OptimizationMode::NoOptimization;
+  m_swift_ast_context->GetIRGenOptions().Verify =
+      false; // normally we'd like to verify, but unfortunately the verifier's
+             // error mode is abort().
+
+  bool created_main_file = false;
+
+  unsigned buffer_id = 0;
+
+  const bool generate_debug_info = m_options.GetGenerateDebugInfo();
+  m_swift_ast_context->SetGenerateDebugInfo(
+      generate_debug_info ? swift::IRGenDebugInfoKind::Normal
+                          : swift::IRGenDebugInfoKind::None);
+  swift::IRGenOptions &ir_gen_options = m_swift_ast_context->GetIRGenOptions();
+
+  if (generate_debug_info) {
+    std::string temp_source_path;
+    if (ExpressionSourceCode::SaveExpressionTextToTempFile(
+            m_expr.Text(), m_options, temp_source_path)) {
+      auto error_or_buffer_ap =
+          llvm::MemoryBuffer::getFile(temp_source_path.c_str());
+      if (error_or_buffer_ap.getError() == std::error_condition()) {
+        buffer_id = m_swift_ast_context->GetSourceManager().addNewSourceBuffer(
+            std::move(error_or_buffer_ap.get()));
+        ir_gen_options.MainInputFilename = temp_source_path;
+
+        llvm::SmallString<256> source_dir(temp_source_path);
+        llvm::sys::path::remove_filename(source_dir);
+        ir_gen_options.DebugCompilationDir = source_dir.str();
+
+        created_main_file = true;
+      }
+    }
+  }
+
+  if (!created_main_file) {
+    const char *filename = repl ? "<REPL>" : "<EXPR>";
+    ir_gen_options.MainInputFilename = filename;
+    std::unique_ptr<llvm::MemoryBuffer> expr_buffer(
+        llvm::MemoryBuffer::getMemBufferCopy(m_expr.Text(), filename));
+    buffer_id = m_swift_ast_context->GetSourceManager().addNewSourceBuffer(
+        std::move(expr_buffer));
+  }
+
+  char expr_name_buf[32];
+
+  snprintf(expr_name_buf, sizeof(expr_name_buf), "__lldb_expr_%u",
+           m_options.GetExpressionNumber());
+
+  swift::Identifier module_id(ast_context->getIdentifier(expr_name_buf));
+  swift::ModuleDecl *module =
+      swift::ModuleDecl::create(module_id, *ast_context);
+  const swift::SourceFile::ImplicitModuleImportKind implicit_import_kind =
+      swift::SourceFile::ImplicitModuleImportKind::Stdlib;
+
+  m_swift_ast_context->GetCompilerInvocation().getFrontendOptions().ModuleName =
+      expr_name_buf;
+  m_swift_ast_context->GetCompilerInvocation().getIRGenOptions().ModuleName =
+      expr_name_buf;
+
+  swift::SourceFileKind source_file_kind = swift::SourceFileKind::Library;
+
+  if (playground || repl) {
+    source_file_kind = swift::SourceFileKind::Main;
+  }
+
+  swift::SourceFile *source_file = new (*ast_context) swift::SourceFile(
+      *module, source_file_kind, buffer_id, implicit_import_kind, false);
+  module->addFile(*source_file);
+
+  bool done = false;
+
+  SILVariableMap variable_map;
+
+  LLDBNameLookup *external_lookup =
+      new LLDBNameLookup(*this, *source_file, variable_map, m_sc);
+
+  // FIXME: This call is here just so that the we keep the DebuggerClients alive
+  // as long as the Module we are not
+  // inserting them in.
+  m_swift_ast_context->AddDebuggerClient(external_lookup);
+
+  swift::PersistentParserState persistent_state;
+
+  while (!done) {
+    swift::parseIntoSourceFile(*source_file, buffer_id, &done, nullptr,
+                               &persistent_state);
+
+    if (m_swift_ast_context->HasErrors()) {
+      m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                            first_line, last_line, line_offset);
+      return 1;
+    }
+  }
+
+  // This currently crashes with Assertion failed: (BufferID != -1), function
+  // findBufferContainingLoc, file
+  // llvm/tools/swift/include/swift/Basic/SourceManager.h, line 92.
+  //    if (log)
+  //    {
+  //        std::string s;
+  //        llvm::raw_string_ostream ss(s);
+  //        source_file->dump(ss);
+  //        ss.flush();
+  //
+  //        log->Printf("Source file after parsing:");
+  //        log->PutCString(s.c_str());
+  //    }
+
+  if (!done) {
+    diagnostic_manager.PutString(eDiagnosticSeverityError,
+                                 "Parse did not consume the whole expression.");
+    return 1;
+  }
+
+  std::unique_ptr<SwiftASTManipulator> code_manipulator;
+
+  if (!playground) {
+    code_manipulator.reset(new SwiftASTManipulator(*source_file, repl));
+
+    code_manipulator->RewriteResult();
+  }
+
+  Status auto_import_error;
+  if (!PerformAutoImport(*source_file, false, auto_import_error)) {
+    diagnostic_manager.Printf(eDiagnosticSeverityError, "in auto-import:\n%s",
+                              auto_import_error.AsCString());
+    return 1;
+  }
+
+  // Swift Modules that rely on shared libraries (not frameworks) don't record
+  // the link information in the
+  // swiftmodule file, so we can't really make them work without outside
+  // information.  However, in the REPL you can
+  // added -L & -l options to the initial compiler startup, and we should dlopen
+  // anything that's been stuffed
+  // on there and hope it will be useful later on.
+
+  if (repl) {
+    lldb::StackFrameSP this_frame_sp(m_stack_frame_wp.lock());
+
+    if (this_frame_sp) {
+      lldb::ProcessSP process_sp(this_frame_sp->CalculateProcess());
+      if (process_sp) {
+        Status error;
+        m_swift_ast_context->LoadExtraDylibs(*process_sp.get(), error);
+      }
+    }
+  }
+
+  if (!playground && !repl) {
+    lldb::StackFrameSP stack_frame_sp = m_stack_frame_wp.lock();
+
+    bool local_context_is_swift = true;
+
+    if (m_sc.block) {
+      Function *function = m_sc.block->CalculateSymbolContextFunction();
+      if (function && function->GetLanguage() != lldb::eLanguageTypeSwift)
+        local_context_is_swift = false;
+    }
+
+    llvm::SmallVector<SwiftASTManipulator::VariableInfo, 5> local_variables;
+
+    if (local_context_is_swift) {
+      AddRequiredAliases(m_sc.block, stack_frame_sp, *m_swift_ast_context,
+                         *code_manipulator, m_expr.GetSwiftGenericInfo());
+
+      // Register all local variables so that lookups to them resolve
+
+      CountLocals(m_sc, stack_frame_sp, *m_swift_ast_context, local_variables);
+    }
+
+    // Register all magic variables
+
+    llvm::SmallVector<swift::Identifier, 2> special_names;
+
+    llvm::StringRef persistent_var_prefix;
+    if (!repl)
+      persistent_var_prefix = "$";
+
+    code_manipulator->FindSpecialNames(special_names, persistent_var_prefix);
+
+    ResolveSpecialNames(m_sc, *m_swift_ast_context, special_names,
+                        local_variables);
+
+    code_manipulator->AddExternalVariables(local_variables);
+
+    // This currently crashes with Assertion failed: (BufferID != -1), function
+    // findBufferContainingLoc, file
+    // llvm/tools/swift/include/swift/Basic/SourceManager.h, line 92.
+    //        if (log)
+    //        {
+    //            std::string s;
+    //            llvm::raw_string_ostream ss(s);
+    //            source_file->dump(ss);
+    //            ss.flush();
+    //
+    //            log->Printf("Source file after code manipulation:");
+    //            log->PutCString(s.c_str());
+    //        }
+
+    stack_frame_sp.reset();
+  }
+
+  swift::performNameBinding(*source_file);
+
+  if (m_swift_ast_context->HasErrors()) {
+    m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                          first_line, last_line, line_offset);
+    return 1;
+  }
+
+  // Do the auto-importing after Name Binding, that's when the Imports for the
+  // source file are figured out.
+  {
+    std::lock_guard<std::recursive_mutex> global_context_locker(
+        IRExecutionUnit::GetLLVMGlobalContextMutex());
+
+    Status auto_import_error;
+    if (!PerformAutoImport(*source_file, true, auto_import_error)) {
+      diagnostic_manager.Printf(eDiagnosticSeverityError, "in auto-import:\n%s",
+                                auto_import_error.AsCString());
+      return 1;
+    }
+  }
+
+  swift::TopLevelContext top_level_context; // not persistent because we're
+                                            // building source files one at a
+                                            // time
+
+  swift::OptionSet<swift::TypeCheckingFlags> type_checking_options;
+
+  swift::performTypeChecking(*source_file, top_level_context,
+                             type_checking_options);
+
+  if (m_swift_ast_context->HasErrors()) {
+    m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                          first_line, last_line, line_offset);
+    return 1;
+  }
+  if (log) {
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    source_file->dump(ss);
+    ss.flush();
+
+    log->Printf("Source file after type checking:");
+    log->PutCString(s.c_str());
+  }
+
+  if (repl) {
+    code_manipulator->MakeDeclarationsPublic();
+  }
+
+  Status error;
+  if (!playground) {
+    code_manipulator->FixupResultAfterTypeChecking(error);
+
+    if (!error.Success()) {
+      diagnostic_manager.PutString(eDiagnosticSeverityError, error.AsCString());
+      return 1;
+    }
+  } else {
+    swift::performPlaygroundTransform(*source_file, true);
+    swift::typeCheckExternalDefinitions(*source_file);
+  }
+
+  // I think we now have to do the name binding and type checking again, but
+  // there should be only the result
+  // variable to bind up at this point.
+
+  if (log) {
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    source_file->dump(ss);
+    ss.flush();
+
+    log->Printf("Source file after FixupResult:");
+    log->PutCString(s.c_str());
+  }
+
+  if (m_sc.target_sp && !playground) {
+    if (!code_manipulator->CheckPatternBindings()) // Do this first, so we don't
+                                                   // pollute the persistent
+                                                   // variable namespace
+    {
+      m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                            first_line, last_line, line_offset);
+      return 1;
+    }
+
+    Status error;
+    SwiftASTContext *scratch_ast_context =
+        m_sc.target_sp->GetScratchSwiftASTContext(error);
+
+    if (scratch_ast_context) {
+      SwiftPersistentExpressionState *persistent_state =
+          llvm::dyn_cast<SwiftPersistentExpressionState>(
+              scratch_ast_context->GetPersistentExpressionState());
+
+      llvm::SmallVector<size_t, 1> declaration_indexes;
+      code_manipulator->FindVariableDeclarations(declaration_indexes, repl);
+
+      for (size_t declaration_index : declaration_indexes) {
+        SwiftASTManipulator::VariableInfo &variable_info =
+            code_manipulator->GetVariableInfo()[declaration_index];
+
+        CompilerType imported_type =
+            ImportType(*scratch_ast_context, variable_info.GetType());
+
+        if (imported_type) {
+          lldb::ExpressionVariableSP persistent_variable =
+              persistent_state->AddNewlyConstructedVariable(
+                  new SwiftExpressionVariable(
+                      m_sc.target_sp.get(),
+                      ConstString(variable_info.GetName().str()), imported_type,
+                      m_sc.target_sp->GetArchitecture().GetByteOrder(),
+                      m_sc.target_sp->GetArchitecture().GetAddressByteSize()));
+
+          if (repl) {
+            persistent_variable->m_flags |= ExpressionVariable::EVKeepInTarget;
+            persistent_variable->m_flags |=
+                ExpressionVariable::EVIsProgramReference;
+          } else {
+            persistent_variable->m_flags |=
+                ExpressionVariable::EVNeedsAllocation;
+            persistent_variable->m_flags |= ExpressionVariable::EVKeepInTarget;
+            llvm::cast<SwiftExpressionVariable>(persistent_variable.get())
+                ->m_swift_flags |= SwiftExpressionVariable::EVSNeedsInit;
+          }
+
+          swift::VarDecl *decl = variable_info.GetDecl();
+          if (decl) {
+            if (decl->isLet()) {
+              llvm::cast<SwiftExpressionVariable>(persistent_variable.get())
+                  ->SetIsModifiable(false);
+            }
+            if (decl->getStorageKind() ==
+                swift::VarDecl::StorageKindTy::Computed) {
+              llvm::cast<SwiftExpressionVariable>(persistent_variable.get())
+                  ->SetIsComputed(true);
+            }
+          }
+
+          variable_info.m_metadata.reset(
+              new VariableMetadataPersistent(persistent_variable));
+
+          persistent_state->RegisterSwiftPersistentDecl(decl);
+        }
+      }
+
+      if (repl) {
+        llvm::SmallVector<swift::ValueDecl *, 1> non_variables;
+        code_manipulator->FindNonVariableDeclarations(non_variables);
+
+        for (swift::ValueDecl *decl : non_variables) {
+          persistent_state->RegisterSwiftPersistentDecl(decl);
+        }
+      }
+    }
+  }
+
+  if (!playground && !repl) {
+    code_manipulator->FixCaptures();
+
+    // This currently crashes with Assertion failed: (BufferID != -1), function
+    // findBufferContainingLoc, file
+    // llvm/tools/swift/include/swift/Basic/SourceManager.h, line 92.
+    //        if (log)
+    //        {
+    //            std::string s;
+    //            llvm::raw_string_ostream ss(s);
+    //            source_file->dump(ss);
+    //            ss.flush();
+    //
+    //            log->Printf("Source file after capture fixing:");
+    //            log->PutCString(s.c_str());
+    //        }
+
+    if (log) {
+      log->Printf("Variables:");
+
+      for (const SwiftASTManipulatorBase::VariableInfo &variable :
+           code_manipulator->GetVariableInfo()) {
+        StreamString ss;
+        variable.Print(ss);
+        log->Printf("  %s", ss.GetData());
+      }
+    }
+  }
+
+  Materializer *materializer = m_expr.GetMaterializer();
+
+  if (materializer && !playground) {
+    for (SwiftASTManipulatorBase::VariableInfo &variable :
+         code_manipulator->GetVariableInfo()) {
+      uint64_t offset = 0;
+      bool needs_init = false;
+
+      bool is_result =
+          variable
+              .MetadataIs<SwiftASTManipulatorBase::VariableMetadataResult>();
+      bool is_error =
+          variable.MetadataIs<SwiftASTManipulatorBase::VariableMetadataError>();
+
+      SwiftUserExpression *user_expression = static_cast<SwiftUserExpression *>(
+          &m_expr); // this is the only thing that has a materializer
+
+      if (is_result || is_error) {
+        needs_init = true;
+
+        Status error;
+
+        if (repl) {
+          if (swift::TypeBase *swift_type =
+                  (swift::TypeBase *)variable.GetType().GetOpaqueQualType()) {
+            if (!swift_type->getCanonicalType()->isVoid()) {
+              if (is_result)
+                offset = llvm::cast<SwiftREPLMaterializer>(materializer)
+                             ->AddREPLResultVariable(
+                                 variable.GetType(), variable.GetDecl(),
+                                 &user_expression->GetResultDelegate(), error);
+              else
+                offset = llvm::cast<SwiftREPLMaterializer>(materializer)
+                             ->AddREPLResultVariable(
+                                 variable.GetType(), variable.GetDecl(),
+                                 &user_expression->GetErrorDelegate(), error);
+            }
+          }
+        } else {
+          CompilerType actual_type(variable.GetType());
+          if (Flags(actual_type.GetTypeInfo())
+                  .AllSet(lldb::eTypeIsSwift | lldb::eTypeIsArchetype)) {
+            lldb::StackFrameSP stack_frame_sp = m_stack_frame_wp.lock();
+            if (stack_frame_sp && stack_frame_sp->GetThread() &&
+                stack_frame_sp->GetThread()->GetProcess()) {
+              SwiftLanguageRuntime *swift_runtime =
+                  stack_frame_sp->GetThread()
+                      ->GetProcess()
+                      ->GetSwiftLanguageRuntime();
+              if (swift_runtime) {
+                actual_type = swift_runtime->GetConcreteType(
+                    stack_frame_sp.get(), actual_type.GetTypeName());
+                if (actual_type.IsValid())
+                  variable.SetType(actual_type);
+                else
+                  actual_type = variable.GetType();
+              }
+            }
+          }
+          swift::Type actual_swift_type =
+              swift::Type((swift::TypeBase *)actual_type.GetOpaqueQualType());
+
+          swift::Type fixed_type = code_manipulator->FixupResultType(
+              actual_swift_type, user_expression->GetLanguageFlags());
+
+          if (!fixed_type.isNull()) {
+            actual_type = CompilerType(actual_type.GetTypeSystem(),
+                                       fixed_type.getPointer());
+            variable.SetType(actual_type);
+          }
+
+          if (is_result)
+            offset = materializer->AddResultVariable(
+                actual_type, false, true, &user_expression->GetResultDelegate(),
+                error);
+          else
+            offset = materializer->AddResultVariable(
+                actual_type, false, true, &user_expression->GetErrorDelegate(),
+                error);
+        }
+
+        if (!error.Success()) {
+          diagnostic_manager.Printf(eDiagnosticSeverityError,
+                                    "couldn't add %s variable to struct: %s.\n",
+                                    is_result ? "result" : "error",
+                                    error.AsCString());
+          return 1;
+        }
+
+        if (log)
+          log->Printf("Added %s variable to struct at offset %llu",
+                      is_result ? "result" : "error",
+                      (unsigned long long)offset);
+      } else if (variable.MetadataIs<VariableMetadataVariable>()) {
+        Status error;
+
+        VariableMetadataVariable *variable_metadata =
+            static_cast<VariableMetadataVariable *>(variable.m_metadata.get());
+
+        offset =
+            materializer->AddVariable(variable_metadata->m_variable_sp, error);
+
+        if (!error.Success()) {
+          diagnostic_manager.Printf(eDiagnosticSeverityError,
+                                    "couldn't add variable to struct: %s.\n",
+                                    error.AsCString());
+          return 1;
+        }
+
+        if (log)
+          log->Printf("Added variable %s to struct at offset %llu",
+                      variable_metadata->m_variable_sp->GetName().AsCString(),
+                      (unsigned long long)offset);
+      } else if (variable.MetadataIs<VariableMetadataPersistent>()) {
+        VariableMetadataPersistent *variable_metadata =
+            static_cast<VariableMetadataPersistent *>(
+                variable.m_metadata.get());
+
+        needs_init = llvm::cast<SwiftExpressionVariable>(
+                         variable_metadata->m_persistent_variable_sp.get())
+                         ->m_swift_flags &
+                     SwiftExpressionVariable::EVSNeedsInit;
+
+        Status error;
+
+        offset = materializer->AddPersistentVariable(
+            variable_metadata->m_persistent_variable_sp,
+            &user_expression->GetPersistentVariableDelegate(), error);
+
+        if (!error.Success()) {
+          diagnostic_manager.Printf(eDiagnosticSeverityError,
+                                    "couldn't add variable to struct: %s.\n",
+                                    error.AsCString());
+          return 1;
+        }
+
+        if (log)
+          log->Printf("Added persistent variable %s with flags 0x%llx to "
+                      "struct at offset %llu",
+                      variable_metadata->m_persistent_variable_sp->GetName()
+                          .AsCString(),
+                      (unsigned long long)
+                          variable_metadata->m_persistent_variable_sp->m_flags,
+                      (unsigned long long)offset);
+      }
+
+      variable_map[ConstString(variable.GetName().get()).GetCString()] =
+          SILVariableInfo(variable.GetType(), offset, needs_init);
+    }
+  }
+
+  std::unique_ptr<swift::SILModule> sil_module(swift::performSILGeneration(
+      *source_file, m_swift_ast_context->GetSILOptions()));
+
+  if (log) {
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    const bool verbose = false;
+    sil_module->print(ss, verbose, module);
+    ss.flush();
+
+    log->Printf("SIL module before linking:");
+    log->PutCString(s.c_str());
+  }
+
+  swift::performSILLinking(sil_module.get());
+
+  if (m_swift_ast_context->HasErrors()) {
+    m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                          first_line, last_line, line_offset);
+    return 1;
+  }
+
+  if (log) {
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    const bool verbose = false;
+    sil_module->print(ss, verbose, module);
+    ss.flush();
+
+    log->Printf("Generated SIL module:");
+    log->PutCString(s.c_str());
+  }
+
+  runSILDiagnosticPasses(*sil_module);
+
+  if (log) {
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    const bool verbose = false;
+    sil_module->print(ss, verbose, module);
+    ss.flush();
+
+    log->Printf("SIL module after diagnostic passes:");
+    log->PutCString(s.c_str());
+  }
+
+  if (m_swift_ast_context->HasErrors()) {
+    m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                          first_line, last_line, line_offset);
+    return 1;
+  }
+
+  {
+    std::lock_guard<std::recursive_mutex> global_context_locker(
+        IRExecutionUnit::GetLLVMGlobalContextMutex());
+
+    m_module = swift::performIRGeneration(
+        m_swift_ast_context->GetIRGenOptions(), module, std::move(sil_module),
+        "lldb_module", SwiftASTContext::GetGlobalLLVMContext());
+  }
+
+  if (m_swift_ast_context->HasErrors()) {
+    m_swift_ast_context->PrintDiagnostics(diagnostic_manager, buffer_id,
+                                          first_line, last_line, line_offset);
+    return 1;
+  }
+
+  if (!m_module) {
+    diagnostic_manager.PutString(
+        eDiagnosticSeverityError,
+        "Couldn't IRGen expression, no additional error");
+    return 1;
+  }
+
+  if (log) {
+    std::string s;
+    llvm::raw_string_ostream ss(s);
+    m_module->print(ss, NULL);
+    ss.flush();
+
+    log->Printf("Generated IR module:");
+    log->PutCString(s.c_str());
+  }
+
+  {
+    std::lock_guard<std::recursive_mutex> global_context_locker(
+        IRExecutionUnit::GetLLVMGlobalContextMutex());
+
+    LLVMVerifyModule((LLVMOpaqueModule *)m_module.get(), LLVMReturnStatusAction,
+                     nullptr);
+  }
+
+  bool fail = m_swift_ast_context->HasErrors();
+  if (!fail) {
+    // The Parse succeeded!  Now put this module into the context's list of
+    // loaded modules,
+    // and copy the Decls that were globalized as part of the parse from the
+    // staging area in the
+    // external lookup object into the SwiftPersistentExpressionState.
+    ast_context->LoadedModules.insert(std::make_pair(module_id, module));
+    if (m_swift_ast_context)
+      m_swift_ast_context->CacheModule(module);
+    if (m_sc.target_sp) {
+      SwiftPersistentExpressionState *persistent_state =
+          llvm::cast<SwiftPersistentExpressionState>(
+              m_sc.target_sp->GetPersistentExpressionStateForLanguage(
+                  lldb::eLanguageTypeSwift));
+      persistent_state->CopyInSwiftPersistentDecls(
+          external_lookup->GetStagedDecls());
+    }
+  }
+  return fail ? 1 : 0;
+}
+
+static bool FindFunctionInModule(ConstString &mangled_name,
+                                 llvm::Module *module, const char *orig_name,
+                                 bool exact) {
+  swift::Demangle::Context demangle_ctx;
+  for (llvm::Module::iterator fi = module->getFunctionList().begin(),
+                              fe = module->getFunctionList().end();
+       fi != fe; ++fi) {
+    if (exact) {
+      if (!fi->getName().str().compare(orig_name)) {
+        mangled_name.SetCString(fi->getName().str().c_str());
+        return true;
+      }
+    } else {
+      if (fi->getName().str().find(orig_name) != std::string::npos) {
+        mangled_name.SetCString(fi->getName().str().c_str());
+        return true;
+      }
+
+      // The new demangling is cannier about compression, so the name may
+      // not be in the mangled name plain.  Let's demangle it and see if we
+      // can find it in the demangled nodes.
+      demangle_ctx.clear();
+
+      swift::Demangle::NodePointer node_ptr =
+          demangle_ctx.demangleSymbolAsNode(fi->getName());
+      if (node_ptr) {
+        if (node_ptr->getKind() != swift::Demangle::Node::Kind::Global)
+          continue;
+        if (node_ptr->getNumChildren() != 1)
+          continue;
+        node_ptr = node_ptr->getFirstChild();
+        if (node_ptr->getKind() != swift::Demangle::Node::Kind::Function)
+          continue;
+        size_t num_children = node_ptr->getNumChildren();
+        for (size_t i = 0; i < num_children; i++) {
+          swift::Demangle::NodePointer child_ptr = node_ptr->getChild(i);
+          if (child_ptr->getKind() == swift::Demangle::Node::Kind::Identifier) {
+            if (!child_ptr->hasText())
+              continue;
+            if (child_ptr->getText().contains(orig_name)) {
+              mangled_name.SetCString(fi->getName().str().c_str());
+              return true;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+Status SwiftExpressionParser::PrepareForExecution(
+    lldb::addr_t &func_addr, lldb::addr_t &func_end,
+    lldb::IRExecutionUnitSP &execution_unit_sp, ExecutionContext &exe_ctx,
+    bool &can_interpret, ExecutionPolicy execution_policy) {
+  Status err;
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  if (!m_module) {
+    err.SetErrorString("Can't prepare a NULL module for execution");
+    return err;
+  }
+
+  const char *orig_name = nullptr;
+
+  bool exact = false;
+
+  if (m_options.GetPlaygroundTransformEnabled() || m_options.GetREPLEnabled()) {
+    orig_name = "main";
+    exact = true;
+  } else {
+    orig_name = "$__lldb_expr";
+  }
+
+  ConstString function_name;
+
+  if (!FindFunctionInModule(function_name, m_module.get(), orig_name, exact)) {
+    err.SetErrorToGenericError();
+    err.SetErrorStringWithFormat("Couldn't find %s() in the module", orig_name);
+    return err;
+  } else {
+    if (log)
+      log->Printf("Found function %s for %s", function_name.AsCString(),
+                  "$__lldb_expr");
+  }
+
+  // Retrieve an appropriate symbol context.
+  SymbolContext sc;
+
+  if (lldb::StackFrameSP frame_sp = exe_ctx.GetFrameSP()) {
+    sc = frame_sp->GetSymbolContext(lldb::eSymbolContextEverything);
+  } else if (lldb::TargetSP target_sp = exe_ctx.GetTargetSP()) {
+    sc.target_sp = target_sp;
+  }
+
+  std::vector<std::string> features;
+
+  std::unique_ptr<llvm::LLVMContext> llvm_context_up;
+  m_execution_unit_sp.reset(
+      new IRExecutionUnit(llvm_context_up,
+                          m_module, // handed off here
+                          function_name, exe_ctx.GetTargetSP(), sc, features));
+
+  // TODO figure out some way to work ClangExpressionDeclMap into this or do the
+  // equivalent
+  //   for Swift
+
+  m_execution_unit_sp->GetRunnableInfo(err, func_addr, func_end);
+
+  execution_unit_sp = m_execution_unit_sp;
+  m_execution_unit_sp.reset();
+
+  return err;
+}
+
+bool SwiftExpressionParser::RewriteExpression(
+    DiagnosticManager &diagnostic_manager) {
+  // There isn't a Swift equivalent to clang::Rewriter, so we'll just use
+  // that...
+  if (!m_swift_ast_context)
+    return false;
+
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  swift::SourceManager &source_manager =
+      m_swift_ast_context->GetSourceManager();
+
+  const DiagnosticList &diagnostics = diagnostic_manager.Diagnostics();
+  size_t num_diags = diagnostics.size();
+  if (num_diags == 0)
+    return false;
+
+  clang::RewriteBuffer rewrite_buf;
+  llvm::StringRef text_ref(m_expr.Text());
+  rewrite_buf.Initialize(text_ref);
+
+  for (const Diagnostic *diag : diagnostic_manager.Diagnostics()) {
+    const SwiftDiagnostic *diagnostic = llvm::dyn_cast<SwiftDiagnostic>(diag);
+    if (!(diagnostic && diagnostic->HasFixIts()))
+      continue;
+
+    const SwiftDiagnostic::FixItList &fixits = diagnostic->FixIts();
+    std::vector<swift::CharSourceRange> source_ranges;
+    for (const swift::DiagnosticInfo::FixIt &fixit : fixits) {
+      const swift::CharSourceRange &range = fixit.getRange();
+      swift::SourceLoc start_loc = range.getStart();
+      if (!start_loc.isValid()) {
+        // getLocOffsetInBuffer will assert if you pass it an invalid location,
+        // so we have to check that first.
+        if (log)
+          log->Printf(
+              "SwiftExpressionParser::RewriteExpression: ignoring fixit since "
+              "it contains an invalid source location: %s.",
+              range.str().str().c_str());
+        return false;
+      }
+
+      // ReplaceText can't handle replacing the same source range more than
+      // once, so we have to check that
+      // before we proceed:
+      if (std::find(source_ranges.begin(), source_ranges.end(), range) !=
+          source_ranges.end()) {
+        if (log)
+          log->Printf(
+              "SwiftExpressionParser::RewriteExpression: ignoring fix-it since "
+              "source range appears twice: %s.\n",
+              range.str().str().c_str());
+        return false;
+      } else
+        source_ranges.push_back(range);
+
+      // ReplaceText will either assert or crash if the start_loc isn't inside
+      // the buffer it is said to
+      // reside in.  That shouldn't happen, but it doesn't hurt to check before
+      // we call ReplaceText.
+
+      auto *Buffer = source_manager.getLLVMSourceMgr().getMemoryBuffer(
+          diagnostic->GetBufferID());
+      if (!(start_loc.getOpaquePointerValue() >= Buffer->getBuffer().begin() &&
+            start_loc.getOpaquePointerValue() <= Buffer->getBuffer().end())) {
+        if (log)
+          log->Printf(
+              "SwiftExpressionParser::RewriteExpression: ignoring fixit since "
+              "it contains a source location not in the specified buffer: %s.",
+              range.str().str().c_str());
+      }
+
+      unsigned offset = source_manager.getLocOffsetInBuffer(
+          range.getStart(), diagnostic->GetBufferID());
+      rewrite_buf.ReplaceText(offset, range.getByteLength(), fixit.getText());
+    }
+  }
+
+  std::string fixed_expression;
+  llvm::raw_string_ostream out_stream(fixed_expression);
+
+  rewrite_buf.write(out_stream);
+  out_stream.flush();
+  diagnostic_manager.SetFixedExpression(fixed_expression);
+
+  return true;
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.h b/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.h
index e69de29bb..c059cb1e8 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftExpressionParser.h
@@ -0,0 +1,169 @@
+//===-- SwiftExpressionParser.h ---------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftExpressionParser_h_
+#define liblldb_SwiftExpressionParser_h_
+
+#include "Plugins/ExpressionParser/Clang/IRForTarget.h"
+#include "lldb/Core/ArchSpec.h"
+#include "lldb/Core/ClangForward.h"
+#include "lldb/Expression/ExpressionParser.h"
+#include "lldb/Expression/Materializer.h"
+#include "lldb/Symbol/SymbolContext.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/Status.h"
+#include "lldb/lldb-public.h"
+
+#include <string>
+#include <vector>
+
+namespace lldb_private {
+
+class IRExecutionUnit;
+
+//----------------------------------------------------------------------
+/// @class SwiftExpressionParser SwiftExpressionParser.h
+/// "lldb/Expression/SwiftExpressionParser.h"
+/// @brief Encapsulates an instance of Swift that can parse expressions.
+///
+/// SwiftExpressionParser is responsible for preparing an instance of
+/// ClangExpression for execution.  SwiftExpressionParser uses ClangExpression
+/// as a glorified parameter list, performing the required parsing and
+/// conversion to formats (DWARF bytecode, or JIT compiled machine code)
+/// that can be executed.
+//----------------------------------------------------------------------
+class SwiftExpressionParser : public ExpressionParser {
+public:
+  //------------------------------------------------------------------
+  /// Constructor
+  ///
+  /// Initializes class variabes.
+  ///
+  /// @param[in] exe_scope,
+  ///     If non-NULL, an execution context scope that can help to
+  ///     correctly create an expression with a valid process for
+  ///     optional tuning Objective-C runtime support. Can be NULL.
+  ///
+  /// @param[in] expr
+  ///     The expression to be parsed.
+  ///
+  /// @param[in] options
+  ///     Additional options for the parser.
+  //------------------------------------------------------------------
+  SwiftExpressionParser(ExecutionContextScope *exe_scope, Expression &expr,
+                        const EvaluateExpressionOptions &options);
+
+  //------------------------------------------------------------------
+  /// Parse a single expression and convert it to IR using Swift.  Don't
+  /// wrap the expression in anything at all.
+  ///
+  /// @param[in] diagnostic_manager
+  ///     The diagnostic manager to report errors to.
+  ///
+  /// @return
+  ///     The number of errors encountered during parsing.  0 means
+  ///     success.
+  //------------------------------------------------------------------
+  unsigned Parse(DiagnosticManager &diagnostic_manager, uint32_t first_line = 0,
+                 uint32_t last_line = UINT32_MAX,
+                 uint32_t line_offset = 0) override;
+
+  //------------------------------------------------------------------
+  /// Ready an already-parsed expression for execution, possibly
+  /// evaluating it statically.
+  ///
+  /// @param[out] func_addr
+  ///     The address to which the function has been written.
+  ///
+  /// @param[out] func_end
+  ///     The end of the function's allocated memory region.  (func_addr
+  ///     and func_end do not delimit an allocated region; the allocated
+  ///     region may begin before func_addr.)
+  ///
+  /// @param[in] execution_unit_ap
+  ///     After parsing, ownership of the execution unit for
+  ///     for the expression is handed to this unique pointer.
+  ///
+  /// @param[in] exe_ctx
+  ///     The execution context to write the function into.
+  ///
+  /// @param[out] evaluated_statically
+  ///     Set to true if the expression could be interpreted statically;
+  ///     untouched otherwise.
+  ///
+  /// @param[out] const_result
+  ///     If the result of the expression is constant, and the
+  ///     expression has no side effects, this is set to the result of the
+  ///     expression.
+  ///
+  /// @param[in] execution_policy
+  ///     Determines whether the expression must be JIT-compiled, must be
+  ///     evaluated statically, or whether this decision may be made
+  ///     opportunistically.
+  ///
+  /// @return
+  ///     An error code indicating the success or failure of the operation.
+  ///     Test with Success().
+  //------------------------------------------------------------------
+  Status
+  PrepareForExecution(lldb::addr_t &func_addr, lldb::addr_t &func_end,
+                      lldb::IRExecutionUnitSP &execution_unit_ap,
+                      ExecutionContext &exe_ctx, bool &can_interpret,
+                      lldb_private::ExecutionPolicy execution_policy) override;
+
+  const EvaluateExpressionOptions &GetOptions() const { return m_options; }
+
+  bool RewriteExpression(DiagnosticManager &diagnostic_manager) override;
+
+  //------------------------------------------------------------------
+  /// Information about each variable provided to the expression, so
+  /// that we can generate proper accesses in the SIL.
+  //------------------------------------------------------------------
+  struct SILVariableInfo {
+    CompilerType type;
+    uint64_t offset;
+    bool needs_init;
+
+    SILVariableInfo(CompilerType t, uint64_t o, bool ni)
+        : type(t), offset(o), needs_init(ni) {}
+
+    SILVariableInfo() : type(), offset(0), needs_init(false) {}
+  };
+
+  //------------------------------------------------------------------
+  /// A container for variables, created during a parse and discarded
+  /// when done.
+  //------------------------------------------------------------------
+  typedef std::map<const char *, SILVariableInfo> SILVariableMap;
+
+private:
+  bool PerformAutoImport(swift::SourceFile &source_file, bool user_imports,
+                         Status &error);
+
+  Expression &m_expr;   ///< The expression to be parsed
+  std::string m_triple; ///< The triple to use when compiling
+  std::unique_ptr<llvm::LLVMContext>
+      m_llvm_context; ///< The context to use for IR generation
+  std::unique_ptr<llvm::Module> m_module; ///< The module to build IR into
+  lldb::IRExecutionUnitSP
+      m_execution_unit_sp; ///< The container for the IR, to
+                           /// be JIT-compiled or interpreted
+  SwiftASTContext
+      *m_swift_ast_context; ///< The AST context to build the expression into
+  SymbolContext m_sc;       ///< The symbol context to use when parsing
+  lldb::StackFrameWP m_stack_frame_wp; ///< The stack frame to use (if possible)
+                                       /// when determining dynamic types.
+  EvaluateExpressionOptions m_options; ///< If true, we are running in REPL mode
+};
+} // namespace lldb_private
+
+#endif // liblldb_SwiftExpressionParser_h_
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.cpp b/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.cpp
index e69de29bb..39b4e6dcc 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.cpp
@@ -0,0 +1,52 @@
+//===-- SwiftExpressionVariable.cpp -----------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftExpressionVariable.h"
+
+#include "lldb/Core/Value.h"
+#include "lldb/Core/ValueObjectConstResult.h"
+#include "lldb/Target/ExecutionContext.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Utility/ConstString.h"
+#include "lldb/Utility/DataExtractor.h"
+#include "lldb/Utility/Stream.h"
+#include "clang/AST/ASTContext.h"
+
+using namespace lldb_private;
+
+SwiftExpressionVariable::SwiftExpressionVariable(
+    ExecutionContextScope *exe_scope, lldb::ByteOrder byte_order,
+    uint32_t addr_byte_size)
+    : ExpressionVariable(LLVMCastKind::eKindSwift) {
+  m_swift_flags = EVSNone;
+  m_frozen_sp =
+      ValueObjectConstResult::Create(exe_scope, byte_order, addr_byte_size);
+}
+
+SwiftExpressionVariable::SwiftExpressionVariable(
+    const lldb::ValueObjectSP &valobj_sp)
+    : ExpressionVariable(LLVMCastKind::eKindSwift) {
+  m_swift_flags = EVSNone;
+  m_frozen_sp = valobj_sp;
+}
+
+SwiftExpressionVariable::SwiftExpressionVariable(
+    ExecutionContextScope *exe_scope, const ConstString &name,
+    const TypeFromUser &type, lldb::ByteOrder byte_order,
+    uint32_t addr_byte_size)
+    : ExpressionVariable(LLVMCastKind::eKindSwift) {
+  m_swift_flags = EVSNone;
+  m_frozen_sp =
+      ValueObjectConstResult::Create(exe_scope, byte_order, addr_byte_size);
+  SetName(name);
+  SetCompilerType(type);
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.h b/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.h
index e69de29bb..fa74e218d 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftExpressionVariable.h
@@ -0,0 +1,123 @@
+//===-- SwiftExpressionVariable.h -------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftExpressionVariable_h_
+#define liblldb_SwiftExpressionVariable_h_
+
+// C Includes
+#include <signal.h>
+#include <stdint.h>
+#include <string.h>
+
+// C++ Includes
+#include <map>
+#include <string>
+#include <vector>
+
+// Other libraries and framework includes
+#include "llvm/Support/Casting.h"
+
+// Project includes
+#include "lldb/Core/ClangForward.h"
+#include "lldb/Core/Value.h"
+#include "lldb/Expression/ExpressionVariable.h"
+#include "lldb/Symbol/TaggedASTType.h"
+#include "lldb/Utility/ConstString.h"
+#include "lldb/lldb-public.h"
+
+namespace llvm {
+class Value;
+}
+
+namespace lldb_private {
+
+class SwiftExpressionVariable : public ExpressionVariable {
+public:
+  SwiftExpressionVariable(ExecutionContextScope *exe_scope,
+                          lldb::ByteOrder byte_order, uint32_t addr_byte_size);
+
+  SwiftExpressionVariable(const lldb::ValueObjectSP &valobj_sp);
+
+  SwiftExpressionVariable(ExecutionContextScope *exe_scope,
+                          const ConstString &name,
+                          const TypeFromUser &user_type,
+                          lldb::ByteOrder byte_order, uint32_t addr_byte_size);
+
+  //----------------------------------------------------------------------
+  /// Utility functions for dealing with ExpressionVariableLists in
+  /// Clang-specific ways
+  //----------------------------------------------------------------------
+
+  static SwiftExpressionVariable *
+  CreateVariableInList(ExpressionVariableList &list,
+                       ExecutionContextScope *exe_scope,
+                       const ConstString &name, const TypeFromUser &user_type,
+                       lldb::ByteOrder byte_order, uint32_t addr_byte_size) {
+    SwiftExpressionVariable *swift_var =
+        new SwiftExpressionVariable(exe_scope, byte_order, addr_byte_size);
+    lldb::ExpressionVariableSP var_sp(swift_var);
+    swift_var->SetName(name);
+    swift_var->SetCompilerType(user_type);
+    list.AddVariable(var_sp);
+    return swift_var;
+  }
+
+  bool GetIsModifiable() const { return (m_swift_flags & EVSIsModifiable); }
+
+  void SetIsModifiable(bool is_modifiable) {
+    if (is_modifiable)
+      m_swift_flags |= EVSIsModifiable;
+    else
+      m_swift_flags &= ~EVSIsModifiable;
+  }
+
+  bool GetIsComputed() const { return (m_swift_flags & EVSIsComputed); }
+
+  void SetIsComputed(bool is_computed) {
+    if (is_computed)
+      m_swift_flags |= EVSIsComputed;
+    else
+      m_swift_flags &= ~EVSIsComputed;
+  }
+
+  enum SwiftFlags {
+    EVSNone = 0,
+    EVSNeedsInit = 1 << 0, ///< This variable's contents are not yet initialized
+                           ///(for result variables and new persistent
+                           /// variables)
+    EVSIsModifiable =
+        1 << 1, ///< This variable is a "let" and should not be modified.
+    EVSIsComputed =
+        1
+        << 2 ///< This variable is a computed property and has no backing store.
+  };
+
+  typedef uint8_t SwiftFlagType;
+
+  SwiftFlagType m_swift_flags; // takes elements of Flags
+
+  //------------------------------------------------------------------
+  // llvm casting support
+  //------------------------------------------------------------------
+  static bool classof(const ExpressionVariable *ev) {
+    return ev->getKind() == ExpressionVariable::eKindSwift;
+  }
+
+  //----------------------------------------------------------------------
+  /// Members
+  //----------------------------------------------------------------------
+  DISALLOW_COPY_AND_ASSIGN(SwiftExpressionVariable);
+};
+
+} // namespace lldb_private
+
+#endif // liblldb_SwiftExpressionVariable_h_
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp b/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp
index e69de29bb..a989c2e33 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.cpp
@@ -0,0 +1,262 @@
+//===-- SwiftPersistentExpressionState.cpp ----------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftPersistentExpressionState.h"
+#include "SwiftExpressionVariable.h"
+#include "lldb/Expression/IRExecutionUnit.h"
+
+#include "lldb/Core/Value.h"
+
+#include "lldb/Symbol/SwiftASTContext.h" // Needed for llvm::isa<SwiftASTContext>(...)
+#include "lldb/Symbol/TypeSystem.h"
+
+#include "lldb/Utility/DataExtractor.h"
+#include "lldb/Utility/Log.h"
+#include "lldb/Utility/StreamString.h"
+
+#include "swift/AST/Decl.h"
+#include "swift/AST/ParameterList.h"
+#include "swift/AST/Pattern.h"
+
+#include "llvm/ADT/StringMap.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+SwiftPersistentExpressionState::SwiftPersistentExpressionState()
+    : lldb_private::PersistentExpressionState(LLVMCastKind::eKindClang),
+      m_next_persistent_variable_id(0), m_next_persistent_error_id(0) {}
+
+ExpressionVariableSP SwiftPersistentExpressionState::CreatePersistentVariable(
+    const lldb::ValueObjectSP &valobj_sp) {
+  return AddNewlyConstructedVariable(new SwiftExpressionVariable(valobj_sp));
+}
+
+ExpressionVariableSP SwiftPersistentExpressionState::CreatePersistentVariable(
+    ExecutionContextScope *exe_scope, const ConstString &name,
+    const CompilerType &compiler_type, lldb::ByteOrder byte_order,
+    uint32_t addr_byte_size) {
+  return AddNewlyConstructedVariable(new SwiftExpressionVariable(
+      exe_scope, name, compiler_type, byte_order, addr_byte_size));
+}
+
+void SwiftPersistentExpressionState::RemovePersistentVariable(
+    lldb::ExpressionVariableSP variable) {
+  if (!variable)
+    return;
+
+  RemoveVariable(variable);
+
+  const char *name = variable->GetName().AsCString();
+
+  if (*name != '$')
+    return;
+  name++;
+
+  bool is_error = false;
+
+  switch (*name) {
+  case 'R':
+    break;
+  case 'E':
+    is_error = true;
+    break;
+  default:
+    return;
+  }
+  name++;
+
+  uint32_t value = strtoul(name, NULL, 0);
+  if (is_error) {
+    if (value == m_next_persistent_error_id - 1)
+      m_next_persistent_error_id--;
+  } else {
+    if (value == m_next_persistent_variable_id - 1)
+      m_next_persistent_variable_id--;
+  }
+}
+
+ConstString
+SwiftPersistentExpressionState::GetNextPersistentVariableName(bool is_error) {
+  char name_cstr[256];
+
+  const char *prefix = nullptr;
+
+  if (is_error)
+    prefix = "$E";
+  else
+    prefix = "$R";
+
+  ::snprintf(name_cstr, sizeof(name_cstr), "%s%u", prefix,
+             is_error ? m_next_persistent_error_id++
+                      : m_next_persistent_variable_id++);
+
+  ConstString name(name_cstr);
+  return name;
+}
+
+bool SwiftPersistentExpressionState::SwiftDeclMap::DeclsAreEquivalent(
+    swift::Decl *lhs_decl, swift::Decl *rhs_decl) {
+  swift::DeclKind lhs_kind = lhs_decl->getKind();
+  swift::DeclKind rhs_kind = rhs_decl->getKind();
+  if (lhs_kind != rhs_kind)
+    return false;
+
+  bool equivalent = false;
+  switch (lhs_kind) {
+  // All the decls that define types of things should only allow one
+  // instance, so in this case, erase what is there, and copy in the new
+  // version.
+  case swift::DeclKind::Class:
+  case swift::DeclKind::Struct:
+  case swift::DeclKind::Enum:
+  case swift::DeclKind::TypeAlias:
+  case swift::DeclKind::Protocol:
+    equivalent = true;
+    break;
+  // For functions, we check that the signature is the same, and only replace it
+  // if it
+  // is, otherwise we just add it.
+  case swift::DeclKind::Func: {
+    swift::FuncDecl *lhs_func_decl = llvm::cast<swift::FuncDecl>(lhs_decl);
+    swift::FuncDecl *rhs_func_decl = llvm::cast<swift::FuncDecl>(rhs_decl);
+    // Okay, they have the same number of arguments, are they of the same type?
+    auto lhs_patterns = lhs_func_decl->getParameterLists();
+    auto rhs_patterns = rhs_func_decl->getParameterLists();
+    size_t num_patterns = lhs_patterns.size();
+    bool body_params_equal = true;
+    if (num_patterns == rhs_patterns.size()) {
+      auto &context = lhs_func_decl->getASTContext();
+      for (int idx = 0; idx < num_patterns; idx++) {
+        auto *lhs_param = lhs_patterns[idx];
+        auto *rhs_param = rhs_patterns[idx];
+
+        auto lhs_type = lhs_param->getInterfaceType(context);
+        auto rhs_type = rhs_param->getInterfaceType(context);
+        if (!lhs_type->isEqual(rhs_type)) {
+          body_params_equal = false;
+          break;
+        }
+      }
+      if (body_params_equal) {
+        // The bodies look the same, now try the return values:
+        auto lhs_result_type = lhs_func_decl->getResultInterfaceType();
+        auto rhs_result_type = rhs_func_decl->getResultInterfaceType();
+
+        if (lhs_result_type->isEqual(rhs_result_type)) {
+          equivalent = true;
+        }
+      }
+    }
+  } break;
+  // Not really sure how to compare operators, so we just do last one wins...
+  case swift::DeclKind::InfixOperator:
+  case swift::DeclKind::PrefixOperator:
+  case swift::DeclKind::PostfixOperator:
+    equivalent = true;
+    break;
+  default:
+    equivalent = true;
+    break;
+  }
+  return equivalent;
+}
+
+void SwiftPersistentExpressionState::SwiftDeclMap::AddDecl(
+    swift::ValueDecl *value_decl, bool check_existing,
+    const ConstString &alias) {
+  std::string name_str;
+
+  if (alias.IsEmpty()) {
+    name_str = (value_decl->getBaseName().getIdentifier().str());
+  } else {
+    name_str.assign(alias.GetCString());
+  }
+
+  if (!check_existing) {
+    m_swift_decls.insert(std::make_pair(name_str, value_decl));
+    return;
+  }
+
+  SwiftDeclMapTy::iterator map_end = m_swift_decls.end();
+  std::pair<SwiftDeclMapTy::iterator, SwiftDeclMapTy::iterator> found_range =
+      m_swift_decls.equal_range(name_str);
+
+  if (found_range.first == map_end) {
+    m_swift_decls.insert(std::make_pair(name_str, value_decl));
+    return;
+  } else {
+    SwiftDeclMapTy::iterator cur_item;
+    bool done = false;
+    for (cur_item = found_range.first; !done && cur_item != found_range.second;
+         cur_item++) {
+      swift::ValueDecl *cur_decl = (*cur_item).second;
+      if (DeclsAreEquivalent(cur_decl, value_decl)) {
+        m_swift_decls.erase(cur_item);
+        break;
+      }
+    }
+
+    m_swift_decls.insert(std::make_pair(name_str, value_decl));
+  }
+}
+
+bool SwiftPersistentExpressionState::SwiftDeclMap::FindMatchingDecls(
+    const ConstString &name, std::vector<swift::ValueDecl *> &matches) {
+  std::vector<swift::ValueDecl *> found_elements;
+  size_t start_num_items = matches.size();
+  std::string name_str(name.AsCString());
+
+  std::pair<SwiftDeclMapTy::iterator, SwiftDeclMapTy::iterator> found_range =
+      m_swift_decls.equal_range(name_str);
+  for (SwiftDeclMapTy::iterator cur_item = found_range.first;
+       cur_item != found_range.second; cur_item++) {
+    bool add_it = true;
+    swift::ValueDecl *cur_decl = (*cur_item).second;
+
+    for (size_t idx = 0; idx < start_num_items; idx++) {
+      if (DeclsAreEquivalent(matches[idx], cur_decl)) {
+        add_it = false;
+        break;
+      }
+    }
+    if (add_it)
+      matches.push_back((*cur_item).second);
+  }
+  return start_num_items != matches.size();
+}
+
+void SwiftPersistentExpressionState::SwiftDeclMap::CopyDeclsTo(
+    SwiftPersistentExpressionState::SwiftDeclMap &target_map) {
+  for (auto elem : m_swift_decls)
+    target_map.AddDecl(elem.second, true, ConstString());
+}
+
+void SwiftPersistentExpressionState::RegisterSwiftPersistentDecl(
+    swift::ValueDecl *value_decl) {
+  m_swift_persistent_decls.AddDecl(value_decl, true, ConstString());
+}
+
+void SwiftPersistentExpressionState::RegisterSwiftPersistentDeclAlias(
+    swift::ValueDecl *value_decl, const ConstString &name) {
+  m_swift_persistent_decls.AddDecl(value_decl, true, name);
+}
+
+void SwiftPersistentExpressionState::CopyInSwiftPersistentDecls(
+    SwiftPersistentExpressionState::SwiftDeclMap &target_map) {
+  target_map.CopyDeclsTo(m_swift_persistent_decls);
+}
+
+bool SwiftPersistentExpressionState::GetSwiftPersistentDecls(
+    const ConstString &name, std::vector<swift::ValueDecl *> &matches) {
+  return m_swift_persistent_decls.FindMatchingDecls(name, matches);
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.h b/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.h
index e69de29bb..f3a653862 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftPersistentExpressionState.h
@@ -0,0 +1,139 @@
+//===-- SwiftPersistentExpressionState.h ------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftPersistentExpressionState_h_
+#define liblldb_SwiftPersistentExpressionState_h_
+
+#include "SwiftExpressionVariable.h"
+
+#include "lldb/Expression/ExpressionVariable.h"
+
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/StringRef.h"
+
+#include <set>
+#include <string>
+#include <unordered_map>
+
+namespace lldb_private {
+
+//----------------------------------------------------------------------
+/// @class SwiftPersistentExpressionState SwiftPersistentExpressionState.h
+/// "lldb/Expression/SwiftPersistentExpressionState.h"
+/// @brief Manages persistent values that need to be preserved between
+/// expression invocations.
+///
+/// A list of variables that can be accessed and updated by any expression.  See
+/// ClangPersistentVariable for more discussion.  Also provides an increasing,
+/// 0-based counter for naming result variables.
+//----------------------------------------------------------------------
+class SwiftPersistentExpressionState : public PersistentExpressionState {
+public:
+  class SwiftDeclMap {
+  public:
+    void AddDecl(swift::ValueDecl *decl, bool check_existing,
+                 const ConstString &name);
+    bool FindMatchingDecls(const ConstString &name,
+                           std::vector<swift::ValueDecl *> &matches);
+    void CopyDeclsTo(SwiftDeclMap &target_map);
+    static bool DeclsAreEquivalent(swift::Decl *lhs, swift::Decl *rhs);
+
+  private:
+    typedef std::unordered_multimap<std::string, swift::ValueDecl *>
+        SwiftDeclMapTy;
+    typedef SwiftDeclMapTy::iterator iterator;
+    SwiftDeclMapTy m_swift_decls;
+  };
+
+  //----------------------------------------------------------------------
+  /// Constructor
+  //----------------------------------------------------------------------
+  SwiftPersistentExpressionState();
+
+  ~SwiftPersistentExpressionState() {}
+
+  //------------------------------------------------------------------
+  // llvm casting support
+  //------------------------------------------------------------------
+  static bool classof(const PersistentExpressionState *pv) {
+    return pv->getKind() == PersistentExpressionState::eKindClang;
+  }
+
+  lldb::ExpressionVariableSP
+  CreatePersistentVariable(const lldb::ValueObjectSP &valobj_sp) override;
+
+  lldb::ExpressionVariableSP CreatePersistentVariable(
+      ExecutionContextScope *exe_scope, const ConstString &name,
+      const CompilerType &compiler_type, lldb::ByteOrder byte_order,
+      uint32_t addr_byte_size) override;
+
+  //----------------------------------------------------------------------
+  /// Return the next entry in the sequence of strings "$0", "$1", ... for
+  /// use naming persistent expression convenience variables.
+  ///
+  /// @param[in] language_type
+  ///     The language for the expression, which can affect the prefix
+  ///
+  /// @param[in] is_error
+  ///     If true, an error variable name is produced.
+  ///
+  /// @return
+  ///     A string that contains the next persistent variable name.
+  //----------------------------------------------------------------------
+  ConstString GetNextPersistentVariableName(bool is_error = false) override;
+
+  void RemovePersistentVariable(lldb::ExpressionVariableSP variable) override;
+
+  void RegisterSwiftPersistentDecl(swift::ValueDecl *value_decl);
+
+  void RegisterSwiftPersistentDeclAlias(swift::ValueDecl *value_decl,
+                                        const ConstString &name);
+
+  void CopyInSwiftPersistentDecls(SwiftDeclMap &source_map);
+
+  bool GetSwiftPersistentDecls(const ConstString &name,
+                               std::vector<swift::ValueDecl *> &matches);
+
+  // This just adds this module to the list of hand-loaded modules, it doesn't
+  // actually load it.
+  void AddHandLoadedModule(const ConstString &module_name) {
+    m_hand_loaded_modules.insert(module_name);
+  }
+
+  using HandLoadedModuleCallback = std::function<bool(const ConstString)>;
+
+  bool RunOverHandLoadedModules(HandLoadedModuleCallback callback) {
+    for (ConstString name : m_hand_loaded_modules) {
+      if (!callback(name))
+        return false;
+    }
+    return true;
+  }
+
+private:
+  uint32_t m_next_persistent_variable_id; ///< The counter used by
+                                          /// GetNextResultName().
+  uint32_t m_next_persistent_error_id;    ///< The counter used by
+                                       /// GetNextResultName() when is_error is
+                                       /// true.
+
+  SwiftDeclMap m_swift_persistent_decls; ///< The persistent functions declared
+                                         /// by the user.
+
+  typedef std::set<lldb_private::ConstString> HandLoadedModuleSet;
+  HandLoadedModuleSet m_hand_loaded_modules; ///< These are the names of modules
+                                             /// that we have loaded by
+  ///< hand into the Contexts we make for parsing.
+};
+} // namespace lldb_private
+
+#endif
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftREPL.cpp b/source/Plugins/ExpressionParser/Swift/SwiftREPL.cpp
index e69de29bb..d5093a106 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftREPL.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftREPL.cpp
@@ -0,0 +1,610 @@
+//===-- SwiftREPL.cpp -------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftREPL.h"
+
+#include "SwiftExpressionVariable.h"
+
+#include "lldb/Core/Debugger.h"
+#include "lldb/Core/Module.h"
+#include "lldb/Core/PluginManager.h"
+#include "lldb/Core/StreamFile.h"
+#include "lldb/Core/ValueObject.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/ValueObjectPrinter.h"
+#include "lldb/Host/HostInfo.h"
+#include "lldb/Interpreter/CommandInterpreter.h"
+#include "lldb/Interpreter/CommandReturnObject.h"
+#include "lldb/Symbol/ObjectFile.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Symbol/SymbolVendor.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Target/Thread.h"
+#include "lldb/Utility/AnsiTerminal.h"
+
+#include "swift/Basic/Version.h"
+#include "swift/Frontend/Frontend.h"
+#include "swift/IDE/REPLCodeCompletion.h"
+#include "swift/IDE/Utils.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+lldb::REPLSP SwiftREPL::CreateInstance(Status &err, lldb::LanguageType language,
+                                       Debugger *debugger, Target *target,
+                                       const char *repl_options) {
+  if (language != eLanguageTypeSwift) {
+    return lldb::REPLSP();
+  }
+
+  if (target) {
+    // Sanity check the target to make sure a REPL would work here.
+    if (!target->GetProcessSP() || !target->GetProcessSP()->IsAlive()) {
+      err.SetErrorString("can't launch a Swift REPL without a running process");
+      return lldb::REPLSP();
+    }
+
+    SymbolContextList sc_list;
+    target->GetImages().FindSymbolsWithNameAndType(
+        ConstString("_swift_release"), eSymbolTypeAny, sc_list);
+
+    if (!sc_list.GetSize()) {
+      err.SetErrorString("can't launch a Swift REPL in a process that doesn't "
+                         "have the Swift standard library");
+      return lldb::REPLSP();
+    }
+
+    // Check that we can get a type system, or we aren't going anywhere:
+    TypeSystem *type_system = target->GetScratchTypeSystemForLanguage(
+        nullptr, eLanguageTypeSwift, true, repl_options);
+    if (!type_system) {
+      err.SetErrorString("Could not construct an expression "
+                         "context for the REPL.\n");
+      return lldb::REPLSP();
+    }
+    // Sanity checks succeeded.  Go ahead.
+    SwiftREPL *repl = new SwiftREPL(*target);
+    REPLSP repl_sp(repl);
+    repl->SetCompilerOptions(repl_options);
+    return repl_sp;
+  } else if (debugger) {
+    const char *bp_name = "repl_main";
+
+    FileSpec repl_executable;
+
+    if (HostInfo::GetLLDBPath(ePathTypeSupportExecutableDir, repl_executable)) {
+      repl_executable.GetFilename().SetCString("repl_swift");
+      std::string repl_exe_path(repl_executable.GetPath());
+      if (repl_executable.Exists()) {
+        const char *target_triple = NULL;
+        bool add_dependent_modules = true;
+        TargetSP target_sp;
+        err = debugger->GetTargetList().CreateTarget(
+            *debugger, repl_exe_path.c_str(), target_triple,
+            add_dependent_modules, NULL, target_sp);
+        if (err.Success()) {
+          // Limit the breakpoint to our executable module
+          FileSpecList containingModules;
+          ModuleSP exe_module_sp(target_sp->GetExecutableModule());
+          if (exe_module_sp) {
+            FileSpec exe_spec(exe_module_sp->GetFileSpec());
+            containingModules.Append(exe_spec);
+            BreakpointSP main_bp_sp = target_sp->CreateBreakpoint(
+                &containingModules, // Limit to these modules
+                NULL,    // Don't limit the breakpoint to any source files
+                bp_name, // Function name
+                eFunctionNameTypeAuto, // Name type
+                eLanguageTypeUnknown,  // Language
+                0,                     // offset
+                eLazyBoolYes,          // skip_prologue,
+                true,                  // internal
+                false);                // request_hardware
+
+            if (main_bp_sp->GetNumLocations() > 0) {
+              main_bp_sp->SetBreakpointKind("REPL");
+
+              assert(main_bp_sp->IsInternal()); // We made an internal
+                                                // breakpoint above, it better
+                                                // say it is internal
+
+              lldb_private::ProcessLaunchInfo launch_info;
+              llvm::StringRef target_settings_argv0 = target_sp->GetArg0();
+
+              if (target_sp->GetDisableASLR())
+                launch_info.GetFlags().Set(eLaunchFlagDisableASLR);
+
+              if (target_sp->GetDisableSTDIO())
+                launch_info.GetFlags().Set(eLaunchFlagDisableSTDIO);
+
+              if (!target_settings_argv0.empty()) {
+                launch_info.GetArguments().AppendArgument(
+                    target_settings_argv0);
+                launch_info.SetExecutableFile(
+                    exe_module_sp->GetPlatformFileSpec(), false);
+              } else {
+                launch_info.SetExecutableFile(
+                    exe_module_sp->GetPlatformFileSpec(), true);
+              }
+
+              debugger->SetAsyncExecution(false);
+              err = target_sp->Launch(launch_info, nullptr);
+              debugger->SetAsyncExecution(true);
+
+              if (err.Success()) {
+                ProcessSP process_sp(target_sp->GetProcessSP());
+                if (process_sp) {
+                  // Start handling process events automatically
+                  debugger->StartEventHandlerThread();
+
+                  StateType state = process_sp->GetState();
+
+                  if (state == eStateStopped) {
+                    ThreadList &thread_list = process_sp->GetThreadList();
+                    const uint32_t num_threads = thread_list.GetSize();
+                    if (num_threads > 0) {
+                      ThreadSP thread_sp = thread_list.GetSelectedThread();
+                      if (!thread_sp) {
+                        thread_sp = thread_list.GetThreadAtIndex(0);
+                        thread_list.SetSelectedThreadByID(thread_sp->GetID());
+                      }
+                      if (thread_sp) {
+                        thread_sp->SetSelectedFrameByIndex(0);
+
+                        REPLSP repl_sp(new SwiftREPL(*target_sp));
+                        ((SwiftREPL *)repl_sp.get())
+                            ->SetCompilerOptions(repl_options);
+                        target_sp->SetREPL(lldb::eLanguageTypeSwift, repl_sp);
+
+                        // Check that we can get a type system, or we aren't
+                        // going anywhere.  Remember to pass in the repl_options
+                        // in case they set up framework paths we need, etc.
+                        TypeSystem *type_system =
+                            target_sp->GetScratchTypeSystemForLanguage(
+                                nullptr, eLanguageTypeSwift, true,
+                                repl_options);
+                        if (!type_system) {
+                          err.SetErrorString("Could not construct an expression"
+                                             " context for the REPL.\n");
+                          return lldb::REPLSP();
+                        }
+
+                        std::string swift_full_version(
+                            swift::version::getSwiftFullVersion());
+                        printf("Welcome to %s. Type :help for assistance.\n",
+                               swift_full_version.c_str());
+
+                        return repl_sp;
+                      }
+                    } else {
+                      err.SetErrorString(
+                          "process is not in valid state (no threads)");
+                    }
+                  } else {
+                    err.SetErrorString(
+                        "failed to stop process at REPL breakpoint");
+                  }
+
+                  process_sp->Destroy(false);
+
+                  debugger->StopEventHandlerThread();
+                } else {
+                  err.SetErrorString("failed to launch REPL process");
+                }
+              } else {
+                err.SetErrorStringWithFormat(
+                    "failed to launch REPL process: %s", err.AsCString());
+              }
+            } else {
+              err.SetErrorStringWithFormat(
+                  "failed to resolve REPL breakpoint for '%s'", bp_name);
+            }
+          } else {
+            err.SetErrorString("unable to resolve REPL executable module");
+
+            target_sp->Destroy();
+          }
+        } else {
+          err.SetErrorStringWithFormat("failed to create REPL target: %s",
+                                       err.AsCString());
+        }
+      } else {
+        err.SetErrorStringWithFormat("REPL executable does not exist: '%s'",
+                                     repl_exe_path.c_str());
+      }
+    } else {
+      err.SetErrorString("unable to locate REPL executable");
+    }
+
+    return lldb::REPLSP();
+  } else {
+    err.SetErrorString("must have a debugger or a target to create a REPL");
+    return lldb::REPLSP();
+  }
+}
+
+void SwiftREPL::EnumerateSupportedLanguages(
+    std::set<lldb::LanguageType> &languages) {
+  static std::vector<lldb::LanguageType> s_supported_languages(
+      {lldb::eLanguageTypeSwift});
+
+  languages.insert(s_supported_languages.begin(), s_supported_languages.end());
+}
+
+void SwiftREPL::Initialize() {
+  PluginManager::RegisterPlugin(ConstString("swift"), "The Swift REPL",
+                                &CreateInstance, &EnumerateSupportedLanguages);
+}
+
+void SwiftREPL::Terminate() {
+  PluginManager::UnregisterPlugin(&CreateInstance);
+}
+
+SwiftREPL::SwiftREPL(Target &target)
+    : REPL(LLVMCastKind::eKindSwift, target), m_swift_ast_sp() {}
+
+SwiftREPL::~SwiftREPL() {}
+
+Status SwiftREPL::DoInitialization() {
+  Status error;
+
+  if (!m_compiler_options.empty()) {
+    (void)m_target.GetScratchSwiftASTContext(error, true,
+                                             m_compiler_options.c_str());
+  }
+
+  return error;
+}
+
+ConstString SwiftREPL::GetSourceFileBasename() {
+  static ConstString s_basename("repl.swift");
+  return s_basename;
+}
+
+bool SwiftREPL::SourceIsComplete(const std::string &source) {
+  std::unique_ptr<llvm::MemoryBuffer> source_buffer_ap(
+      llvm::MemoryBuffer::getMemBuffer(source));
+  swift::ide::SourceCompleteResult result =
+      swift::ide::isSourceInputComplete(std::move(source_buffer_ap));
+  return result.IsComplete;
+}
+
+static bool GetIdentifier(llvm::StringRef &s, llvm::StringRef &identifier) {
+  if (!s.empty()) {
+    char ch = s[0];
+    if (isalpha(ch) || ch == '_') {
+      size_t i;
+      for (i = 1; i < s.size(); ++i) {
+        ch = s[i];
+        if (isalnum(ch) || ch == '_')
+          continue;
+        else
+          break;
+      }
+      identifier = s.substr(0, i);
+      s = s.drop_front(i);
+      return true;
+    }
+  }
+  return false;
+}
+
+lldb::offset_t SwiftREPL::GetDesiredIndentation(const StringList &lines,
+                                                int cursor_position,
+                                                int tab_size) {
+  // Determine appropriate indentation after the initial N-1 lines
+  StringList prior_lines = lines;
+  prior_lines.PopBack();
+  std::string source_string(prior_lines.CopyList());
+  std::unique_ptr<llvm::MemoryBuffer> source_buffer_ap(
+      llvm::MemoryBuffer::getMemBuffer(source_string));
+  swift::ide::SourceCompleteResult result =
+      swift::ide::isSourceInputComplete(std::move(source_buffer_ap));
+
+  int desired_indent =
+      (result.IndentLevel * tab_size) + result.IndentPrefix.length();
+
+  const std::string &last_line = lines[lines.GetSize() - 1];
+
+  // Unindent for an initial closed brace on a line break, or when the brace was
+  // just typed
+  if (cursor_position == 0 || last_line[cursor_position - 1] == '}') {
+
+    // The brace must be the first non-space character
+    const int actual_indent = REPL::CalculateActualIndentation(lines);
+
+    if (last_line.length() > actual_indent && last_line[actual_indent] == '}') {
+      // Stop searching once a reason to unindent was found
+      desired_indent -= tab_size;
+      if (desired_indent < 0)
+        desired_indent = 0;
+      return desired_indent;
+    }
+  }
+
+  // Unindent for a case clause on a line break, or when the colon was just
+  // typed
+  if (cursor_position == 0 || last_line[cursor_position - 1] == ':') {
+    size_t colon_pos = last_line.find_last_of(':');
+    if (colon_pos != std::string::npos) {
+      std::string line_to_colon = last_line.substr(0, colon_pos);
+      llvm::StringRef line(line_to_colon);
+      line = line.ltrim(); // Skip leading spaces
+      if (!line.empty()) {
+        llvm::StringRef identifier;
+        if (GetIdentifier(line, identifier)) {
+          line = line.ltrim(); // Skip leading spaces
+          // If we have an empty line now, we have a simple label followed by a
+          // ':'
+          // and if it isn't we have "case" followed by a space, then we handle
+          // this as a cast statement
+          bool outdent = false;
+          if (line.empty())
+            outdent = !identifier.equals("case");
+          else if (identifier.equals("case")) {
+            outdent = true;
+          } else {
+            line = line.rtrim(); // Skip trailing spaces
+            // Check for any identifier followed by an optional paren expression
+            // and a colon
+            if (line.front() == '(' && line.back() == ')')
+              outdent = true;
+          }
+
+          if (outdent) {
+            // Stop searching once a reason to unindent was found
+            desired_indent -= tab_size;
+            if (desired_indent < 0)
+              desired_indent = 0;
+            return desired_indent;
+          }
+        }
+      }
+    }
+  }
+
+  // Otherwise, only change indentation when creating a new line
+  if (cursor_position == 0)
+    return desired_indent;
+
+  return LLDB_INVALID_OFFSET;
+}
+
+lldb::LanguageType SwiftREPL::GetLanguage() { return eLanguageTypeSwift; }
+
+bool isThrownError(ValueObjectSP valobj_sp) {
+  ConstString name = valobj_sp->GetName();
+  size_t length = name.GetLength();
+  if (length < 3)
+    return false;
+
+  const char *name_cstr = name.AsCString();
+  if (name_cstr[0] != '$')
+    return false;
+  if (name_cstr[1] != 'E')
+    return false;
+  for (int index = 2; index < length; index++) {
+
+    char digit = name_cstr[index];
+    if (digit < '0' || digit > '9')
+      return false;
+  }
+  return true;
+}
+
+bool SwiftREPL::PrintOneVariable(Debugger &debugger, StreamFileSP &output_sp,
+                                 ValueObjectSP &valobj_sp,
+                                 ExpressionVariable *var) {
+  bool is_computed = false;
+
+  if (var) {
+    if (lldb::ValueObjectSP valobj_sp = var->GetValueObject()) {
+      Flags valobj_type_flags(valobj_sp->GetCompilerType().GetTypeInfo());
+      const bool is_swift(valobj_type_flags.AllSet(eTypeIsSwift));
+      if ((var->GetName().AsCString("anonymous")[0] != '$') && is_swift) {
+        is_computed = llvm::cast<SwiftExpressionVariable>(var)->GetIsComputed();
+      } else {
+        return false;
+      }
+    } else {
+      return false;
+    }
+  }
+
+  const bool colorize_out = output_sp->GetFile().GetIsTerminalWithColors();
+
+  bool handled = false;
+
+  Format format = m_format_options.GetFormat();
+
+  bool treat_as_void = (format == eFormatVoid);
+  // if we are asked to suppress void, check if this is the empty tuple type,
+  // and if so suppress it
+  if (!treat_as_void && !debugger.GetNotifyVoid()) {
+    const CompilerType &expr_type(valobj_sp->GetCompilerType());
+    Flags expr_type_flags(expr_type.GetTypeInfo());
+    if (expr_type_flags.AllSet(eTypeIsSwift | eTypeIsTuple)) {
+      treat_as_void = (expr_type.GetNumFields() == 0);
+    }
+  }
+
+  if (!treat_as_void) {
+    if (format != eFormatDefault)
+      valobj_sp->SetFormat(format);
+
+    DumpValueObjectOptions options;
+    options.SetUseDynamicType(lldb::eDynamicCanRunTarget);
+    options.SetMaximumPointerDepth(
+        {DumpValueObjectOptions::PointerDepth::Mode::Formatters, 1});
+    options.SetUseSyntheticValue(true);
+    options.SetRevealEmptyAggregates(false);
+    options.SetHidePointerValue(true);
+    options.SetVariableFormatDisplayLanguage(lldb::eLanguageTypeSwift);
+    options.SetDeclPrintingHelper([](ConstString type_name,
+                                     ConstString var_name,
+                                     const DumpValueObjectOptions &options,
+                                     Stream &stream) -> bool {
+      if (!type_name || !var_name)
+        return false;
+
+      std::string type_name_str(type_name ? type_name.GetCString() : "");
+      for (auto iter = type_name_str.find(" *"); iter != std::string::npos;
+           iter = type_name_str.find(" *")) {
+        type_name_str.erase(iter, 2);
+      }
+      if (!type_name_str.empty()) {
+        stream.Printf("%s: %s =", var_name.GetCString(), type_name_str.c_str());
+        return true;
+      }
+
+      return false;
+    });
+
+    if (is_computed) {
+      StringSummaryFormat::Flags flags;
+      flags.SetDontShowChildren(true);
+      flags.SetDontShowValue(true);
+      flags.SetHideItemNames(true);
+      flags.SetShowMembersOneLiner(false);
+      flags.SetSkipPointers(false);
+      flags.SetSkipReferences(false);
+      options.SetHideValue(true);
+      options.SetShowSummary(true);
+      options.SetSummary(lldb::TypeSummaryImplSP(
+          new StringSummaryFormat(flags, "<computed property>")));
+    }
+
+    if (colorize_out) {
+      const char *color = isThrownError(valobj_sp)
+                              ? ANSI_ESCAPE1(ANSI_FG_COLOR_RED)
+                              : ANSI_ESCAPE1(ANSI_FG_COLOR_CYAN);
+      fprintf(output_sp->GetFile().GetStream(), "%s", color);
+    }
+
+    valobj_sp->Dump(*output_sp, options);
+
+    if (colorize_out)
+      fprintf(output_sp->GetFile().GetStream(), ANSI_ESCAPE1(ANSI_CTRL_NORMAL));
+
+    handled = true;
+  }
+
+  return handled;
+}
+
+int SwiftREPL::CompleteCode(const std::string &current_code,
+                            lldb_private::StringList &matches) {
+  //----------------------------------------------------------------------g
+  // If we use the target's SwiftASTContext for completion, it reaaallly
+  // slows down subsequent expressions. The compiler team doesn't have time
+  // to fix this issue currently, so we need to work around it by making
+  // our own copy of the AST and using this separate AST for completion.
+  //----------------------------------------------------------------------
+  Status error;
+#define USE_SEPARATE_AST_FOR_COMPLETION
+#if defined(USE_SEPARATE_AST_FOR_COMPLETION)
+  if (!m_swift_ast_sp) {
+    SwiftASTContext *target_swift_ast =
+        m_target.GetScratchSwiftASTContext(error);
+    if (target_swift_ast)
+      m_swift_ast_sp.reset(new SwiftASTContext(*target_swift_ast));
+  }
+  SwiftASTContext *swift_ast = m_swift_ast_sp.get();
+#else
+  SwiftASTContext *swift_ast = m_target.GetScratchSwiftASTContext(error);
+#endif
+
+  if (swift_ast) {
+    swift::ASTContext *ast = swift_ast->GetASTContext();
+    swift::REPLCompletions completions;
+    static ConstString g_repl_module_name("repl");
+    swift::ModuleDecl *repl_module =
+        swift_ast->GetModule(g_repl_module_name, error);
+    if (repl_module == NULL) {
+      repl_module = swift_ast->CreateModule(g_repl_module_name, error);
+      const swift::SourceFile::ImplicitModuleImportKind implicit_import_kind =
+          swift::SourceFile::ImplicitModuleImportKind::Stdlib;
+      llvm::Optional<unsigned> bufferID;
+      swift::SourceFile *repl_source_file = new (*ast)
+          swift::SourceFile(*repl_module, swift::SourceFileKind::REPL, bufferID,
+                            implicit_import_kind, false);
+      repl_module->addFile(*repl_source_file);
+    }
+    if (repl_module) {
+      swift::SourceFile &repl_source_file =
+          repl_module->getMainSourceFile(swift::SourceFileKind::REPL);
+
+      llvm::StringRef current_code_ref(current_code);
+      completions.populate(repl_source_file, current_code_ref);
+      llvm::StringRef root = completions.getRoot();
+      if (!root.empty()) {
+        matches.AppendString(root.data(), root.size());
+        return 1;
+      }
+      //                    llvm::StringRef prev_stem =
+      //                    completions.getPreviousStem();
+      //                    llvm::StringRef next_stem =
+      //                    completions.getNextStem();
+      //                    printf ("\nroot: '%*s'", (int)root.size(),
+      //                    root.data());
+      //                    printf ("\nprev_stem: '%*s'", (int)prev_stem.size(),
+      //                    prev_stem.data());
+      //                    printf ("\nnext_stem: '%*s'", (int)next_stem.size(),
+      //                    next_stem.data());
+      //                    printf ("\nvalid: %i", completions.isValid());
+      //                    printf ("\nempty: %i", completions.isEmpty());
+      //                    printf ("\nunique: %i", completions.isUnique());
+
+      // Otherwise, advance through the completion state machine.
+      const swift::CompletionState completion_state = completions.getState();
+      switch (completion_state) {
+      case swift::CompletionState::CompletedRoot: {
+        // We completed the root. Next step is to display the completion list.
+        matches.AppendString(""); // Empty string to indicate no completion,
+        // just display other strings that come after it
+        llvm::ArrayRef<llvm::StringRef> llvm_matches =
+            completions.getCompletionList();
+        for (const auto &llvm_match : llvm_matches) {
+          if (!llvm_match.empty())
+            matches.AppendString(llvm_match.data(), llvm_match.size());
+        }
+        // Don't include the empty string we appended above or we will display
+        // one
+        // too many we need to return the magical value of one less than our
+        // actual matches.
+        // TODO: modify all IOHandlerDelegate::IOHandlerComplete() to use a
+        // CompletionMatches
+        // class that wraps up the "StringList matches;" along with other smarts
+        // so we don't
+        // have to return magic values and incorrect sizes.
+        return matches.GetSize() - 1;
+      } break;
+
+      case swift::CompletionState::DisplayedCompletionList: {
+        // Complete the next completion stem in the cycle.
+        llvm::StringRef stem = completions.getPreviousStem().InsertableString;
+        matches.AppendString(stem.data(), stem.size());
+      } break;
+
+      case swift::CompletionState::Empty:
+      case swift::CompletionState::Unique:
+        // We already provided a definitive completion--nothing else to do.
+        break;
+
+      case swift::CompletionState::Invalid:
+        llvm_unreachable("got an invalid completion set?!");
+      }
+    }
+  }
+
+  return matches.GetSize();
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftREPL.h b/source/Plugins/ExpressionParser/Swift/SwiftREPL.h
index e69de29bb..d7c1f5900 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftREPL.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftREPL.h
@@ -0,0 +1,82 @@
+//===-- SwiftREPL.h ---------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftREPL_h_
+#define liblldb_SwiftREPL_h_
+
+#include "lldb/Expression/REPL.h"
+#include "lldb/Utility/Status.h"
+#include "lldb/lldb-public.h"
+
+#include <string>
+#include <vector>
+
+namespace lldb_private {
+
+class IRExecutionUnit;
+
+//----------------------------------------------------------------------
+/// @class SwiftREPL SwiftREPL.h "lldb/Expression/SwiftREPL.h"
+/// @brief Encapsulates a swift REPL session.
+//----------------------------------------------------------------------
+class SwiftREPL : public REPL {
+public:
+  SwiftREPL(Target &target);
+  ~SwiftREPL();
+
+  static void Initialize();
+
+  static void Terminate();
+
+protected:
+  static lldb::REPLSP CreateInstance(Status &error, lldb::LanguageType language,
+                                     Debugger *debugger, Target *target,
+                                     const char *repl_options);
+
+  static void
+  EnumerateSupportedLanguages(std::set<lldb::LanguageType> &languages);
+
+  Status DoInitialization() override;
+
+  ConstString GetSourceFileBasename() override;
+
+  const char *GetAutoIndentCharacters() override { return "}:"; }
+
+  bool SourceIsComplete(const std::string &source) override;
+
+  lldb::offset_t GetDesiredIndentation(const StringList &lines,
+                                       int cursor_position,
+                                       int tab_size) override;
+
+  lldb::LanguageType GetLanguage() override;
+
+  bool PrintOneVariable(Debugger &debugger, lldb::StreamFileSP &output_sp,
+                        lldb::ValueObjectSP &valobj_sp,
+                        ExpressionVariable *var = nullptr) override;
+
+  int CompleteCode(const std::string &current_code,
+                   StringList &matches) override;
+
+public:
+  //------------------------------------------------------------------
+  // llvm casting support
+  //------------------------------------------------------------------
+  static bool classof(const REPL *repl) {
+    return repl->getKind() == LLVMCastKind::eKindSwift;
+  }
+
+private:
+  lldb::SwiftASTContextSP m_swift_ast_sp;
+};
+} // namespace lldb_private
+
+#endif // liblldb_SwiftREPL_h_
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.cpp b/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.cpp
index e69de29bb..d309c7a28 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.cpp
@@ -0,0 +1,461 @@
+//===-- SwiftREPLMaterializer.cpp -------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftREPLMaterializer.h"
+#include "SwiftASTManipulator.h"
+
+#include "lldb/Core/DumpDataExtractor.h"
+#include "lldb/Core/ValueObjectConstResult.h"
+#include "lldb/Expression/IRExecutionUnit.h"
+#include "lldb/Expression/IRMemoryMap.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/Log.h"
+
+#include "swift/Demangling/Demangle.h"
+
+using namespace lldb_private;
+
+static llvm::StringRef
+GetNameOfDemangledVariable(swift::Demangle::NodePointer node_pointer) {
+  if (!node_pointer ||
+      node_pointer->getKind() != swift::Demangle::Node::Kind::Global)
+    return llvm::StringRef();
+
+  swift::Demangle::NodePointer variable_pointer = node_pointer->getFirstChild();
+
+  if (!variable_pointer ||
+      variable_pointer->getKind() != swift::Demangle::Node::Kind::Variable)
+    return llvm::StringRef();
+
+  for (swift::Demangle::NodePointer child : *variable_pointer) {
+    if (child && child->getKind() == swift::Demangle::Node::Kind::Identifier &&
+        child->hasText()) {
+      return child->getText();
+    }
+  }
+  return llvm::StringRef();
+}
+
+class EntityREPLResultVariable : public Materializer::Entity {
+public:
+  EntityREPLResultVariable(const CompilerType &type,
+                           swift::ValueDecl *swift_decl,
+                           SwiftREPLMaterializer *parent,
+                           Materializer::PersistentVariableDelegate *delegate)
+      : Entity(), m_type(type), m_parent(parent), m_swift_decl(swift_decl),
+        m_temporary_allocation(LLDB_INVALID_ADDRESS),
+        m_temporary_allocation_size(0), m_delegate(delegate) {
+    // Hard-coding to maximum size of a pointer since all results are
+    // materialized by reference
+    m_size = 8;
+    m_alignment = 8;
+  }
+
+  void Materialize(lldb::StackFrameSP &frame_sp, IRMemoryMap &map,
+                   lldb::addr_t process_address, Status &err) {
+    // no action required
+  }
+
+  void MakeREPLResult(IRExecutionUnit &execution_unit, Status &err,
+                      const IRExecutionUnit::JittedGlobalVariable *variable) {
+    err.Clear();
+
+    ExecutionContextScope *exe_scope =
+        execution_unit.GetBestExecutionContextScope();
+
+    if (!exe_scope) {
+      err.SetErrorString("Couldn't dematerialize a result variable: invalid "
+                         "execution context scope");
+      return;
+    }
+
+    lldb::TargetSP target_sp = exe_scope->CalculateTarget();
+
+    if (!target_sp) {
+      err.SetErrorString("Couldn't dematerialize a result variable: no target");
+      return;
+    }
+
+    lldb::LanguageType lang =
+        (m_type.GetMinimumLanguage() == lldb::eLanguageTypeSwift)
+            ? lldb::eLanguageTypeSwift
+            : lldb::eLanguageTypeObjC_plus_plus;
+
+    PersistentExpressionState *persistent_state =
+        target_sp->GetPersistentExpressionStateForLanguage(lang);
+
+    if (!persistent_state) {
+      err.SetErrorString("Couldn't dematerialize a result variable: language "
+                         "doesn't have persistent state");
+    }
+
+    ConstString name =
+        m_delegate ? m_delegate->GetName()
+                   : persistent_state->GetNextPersistentVariableName(false);
+
+    lldb::ExpressionVariableSP ret;
+
+    ret = persistent_state
+              ->CreatePersistentVariable(exe_scope, name, m_type,
+                                         execution_unit.GetByteOrder(),
+                                         execution_unit.GetAddressByteSize())
+              ->shared_from_this();
+
+    if (!ret) {
+      err.SetErrorStringWithFormat("couldn't dematerialize a result variable: "
+                                   "failed to make persistent variable %s",
+                                   name.AsCString());
+      return;
+    }
+
+    lldb::ProcessSP process_sp =
+        execution_unit.GetBestExecutionContextScope()->CalculateProcess();
+
+    ret->m_live_sp = ValueObjectConstResult::Create(
+        exe_scope, m_type, name,
+        variable ? variable->m_remote_addr : LLDB_INVALID_ADDRESS,
+        eAddressTypeLoad, execution_unit.GetAddressByteSize());
+
+    ret->ValueUpdated();
+
+    if (variable) {
+      const size_t pvar_byte_size = ret->GetByteSize();
+      uint8_t *pvar_data = ret->GetValueBytes();
+
+      Status read_error;
+
+      execution_unit.ReadMemory(pvar_data, variable->m_remote_addr,
+                                pvar_byte_size, read_error);
+
+      if (!read_error.Success()) {
+        err.SetErrorString("Couldn't dematerialize a result variable: couldn't "
+                           "read its memory");
+        return;
+      }
+    }
+
+    if (m_delegate) {
+      m_delegate->DidDematerialize(ret);
+    }
+
+    // Register the variable with the persistent decls under the assumed,
+    // just-generated name so it can be reused.
+
+    if (m_swift_decl) {
+      llvm::cast<SwiftPersistentExpressionState>(persistent_state)
+          ->RegisterSwiftPersistentDeclAlias(m_swift_decl, name);
+    }
+
+    return;
+  }
+
+  void Dematerialize(lldb::StackFrameSP &frame_sp, IRMemoryMap &map,
+                     lldb::addr_t process_address, lldb::addr_t frame_top,
+                     lldb::addr_t frame_bottom, Status &err) {
+    IRExecutionUnit *execution_unit =
+        llvm::cast<SwiftREPLMaterializer>(m_parent)->GetExecutionUnit();
+
+    if (!execution_unit) {
+      return;
+    }
+
+    swift::Demangle::Context demangle_ctx;
+    llvm::StringRef result_name = SwiftASTManipulator::GetResultName();
+
+    for (const IRExecutionUnit::JittedGlobalVariable &variable :
+         execution_unit->GetJittedGlobalVariables()) {
+      swift::Demangle::NodePointer node_pointer =
+          demangle_ctx.demangleSymbolAsNode(variable.m_name.GetStringRef());
+
+      llvm::StringRef variable_name = GetNameOfDemangledVariable(node_pointer);
+      if (variable_name == result_name) {
+        MakeREPLResult(*execution_unit, err, &variable);
+        return;
+      }
+
+      demangle_ctx.clear();
+    }
+
+    if (SwiftASTContext::IsPossibleZeroSizeType(m_type)) {
+      MakeREPLResult(*execution_unit, err, nullptr);
+      return;
+    }
+
+    err.SetErrorToGenericError();
+    err.SetErrorStringWithFormat(
+        "Couldn't dematerialize result: corresponding symbol wasn't found");
+  }
+
+  void DumpToLog(IRMemoryMap &map, lldb::addr_t process_address, Log *log) {
+    StreamString dump_stream;
+
+    const lldb::addr_t load_addr = process_address + m_offset;
+
+    dump_stream.Printf("0x%" PRIx64 ": EntityResultVariable\n", load_addr);
+
+    Status err;
+
+    lldb::addr_t ptr = LLDB_INVALID_ADDRESS;
+
+    {
+      dump_stream.Printf("Pointer:\n");
+
+      DataBufferHeap data(m_size, 0);
+
+      map.ReadMemory(data.GetBytes(), load_addr, m_size, err);
+
+      if (!err.Success()) {
+        dump_stream.Printf("  <could not be read>\n");
+      } else {
+        DataExtractor extractor(data.GetBytes(), data.GetByteSize(),
+                                map.GetByteOrder(), map.GetAddressByteSize());
+
+        DumpHexBytes(&dump_stream, data.GetBytes(), data.GetByteSize(), 16,
+                     load_addr);
+
+        lldb::offset_t offset;
+
+        ptr = extractor.GetPointer(&offset);
+
+        dump_stream.PutChar('\n');
+      }
+    }
+
+    if (m_temporary_allocation == LLDB_INVALID_ADDRESS) {
+      dump_stream.Printf("Points to process memory:\n");
+    } else {
+      dump_stream.Printf("Temporary allocation:\n");
+    }
+
+    if (ptr == LLDB_INVALID_ADDRESS) {
+      dump_stream.Printf("  <could not be be found>\n");
+    } else {
+      DataBufferHeap data(m_temporary_allocation_size, 0);
+
+      map.ReadMemory(data.GetBytes(), m_temporary_allocation,
+                     m_temporary_allocation_size, err);
+
+      if (!err.Success()) {
+        dump_stream.Printf("  <could not be read>\n");
+      } else {
+        DumpHexBytes(&dump_stream, data.GetBytes(), data.GetByteSize(), 16,
+                     m_temporary_allocation);
+
+        dump_stream.PutChar('\n');
+      }
+    }
+
+    log->PutCString(dump_stream.GetData());
+  }
+
+  void Wipe(IRMemoryMap &map, lldb::addr_t process_address) {
+    m_temporary_allocation = LLDB_INVALID_ADDRESS;
+    m_temporary_allocation_size = 0;
+  }
+
+private:
+  CompilerType m_type;
+
+  SwiftREPLMaterializer *m_parent;
+  swift::ValueDecl *m_swift_decl; // only used for the REPL; nullptr otherwise
+
+  lldb::addr_t m_temporary_allocation;
+  size_t m_temporary_allocation_size;
+
+  Materializer::PersistentVariableDelegate *m_delegate;
+};
+
+uint32_t SwiftREPLMaterializer::AddREPLResultVariable(
+    const CompilerType &type, swift::ValueDecl *decl,
+    PersistentVariableDelegate *delegate, Status &err) {
+  EntityVector::iterator iter = m_entities.insert(m_entities.end(), EntityUP());
+
+  iter->reset(new EntityREPLResultVariable(type, decl, this, delegate));
+  uint32_t ret = AddStructMember(**iter);
+  (*iter)->SetOffset(ret);
+
+  return ret;
+}
+
+class EntityREPLPersistentVariable : public Materializer::Entity {
+public:
+  EntityREPLPersistentVariable(
+      lldb::ExpressionVariableSP &persistent_variable_sp,
+      SwiftREPLMaterializer *parent,
+      Materializer::PersistentVariableDelegate *delegate)
+      : Entity(), m_persistent_variable_sp(persistent_variable_sp),
+        m_parent(parent), m_delegate(delegate) {
+    // Hard-coding to maximum size of a pointer since persistent variables are
+    // materialized by reference
+    m_size = 8;
+    m_alignment = 8;
+  }
+
+  void Materialize(lldb::StackFrameSP &frame_sp, IRMemoryMap &map,
+                   lldb::addr_t process_address, Status &err) {
+    // no action required
+  }
+
+  void Dematerialize(lldb::StackFrameSP &frame_sp, IRMemoryMap &map,
+                     lldb::addr_t process_address, lldb::addr_t frame_top,
+                     lldb::addr_t frame_bottom, Status &err) {
+    if (llvm::cast<SwiftExpressionVariable>(m_persistent_variable_sp.get())
+            ->GetIsComputed())
+      return;
+
+    IRExecutionUnit *execution_unit = m_parent->GetExecutionUnit();
+
+    if (!execution_unit) {
+      return;
+    }
+
+    swift::Demangle::Context demangle_ctx;
+
+    for (const IRExecutionUnit::JittedGlobalVariable &variable :
+         execution_unit->GetJittedGlobalVariables()) {
+      // e.g.
+      // kind=Global
+      //   kind=Variable
+      //     kind=Module, text="lldb_expr_0"
+      //     kind=Identifier, text="a"
+
+      swift::Demangle::NodePointer node_pointer =
+          demangle_ctx.demangleSymbolAsNode(variable.m_name.GetStringRef());
+
+      llvm::StringRef last_component = GetNameOfDemangledVariable(node_pointer);
+
+      if (last_component.empty())
+        continue;
+
+      if (m_persistent_variable_sp->GetName().GetStringRef().equals(
+              last_component)) {
+        ExecutionContextScope *exe_scope =
+            execution_unit->GetBestExecutionContextScope();
+
+        if (!exe_scope) {
+          err.SetErrorString("Couldn't dematerialize a persistent variable: "
+                             "invalid execution context scope");
+          return;
+        }
+
+        m_persistent_variable_sp->m_live_sp = ValueObjectConstResult::Create(
+            exe_scope, m_persistent_variable_sp->GetCompilerType(),
+            m_persistent_variable_sp->GetName(), variable.m_remote_addr,
+            eAddressTypeLoad, execution_unit->GetAddressByteSize());
+
+        // Read the contents of the spare memory area
+
+        m_persistent_variable_sp->ValueUpdated();
+
+        Status read_error;
+
+        execution_unit->ReadMemory(
+            m_persistent_variable_sp->GetValueBytes(), variable.m_remote_addr,
+            m_persistent_variable_sp->GetByteSize(), read_error);
+
+        if (!read_error.Success()) {
+          err.SetErrorStringWithFormat(
+              "couldn't read the contents of %s from memory: %s",
+              m_persistent_variable_sp->GetName().GetCString(),
+              read_error.AsCString());
+          return;
+        }
+
+        m_persistent_variable_sp->m_flags &=
+            ~ExpressionVariable::EVNeedsFreezeDry;
+
+        return;
+      }
+      demangle_ctx.clear();
+    }
+
+    err.SetErrorToGenericError();
+    err.SetErrorStringWithFormat(
+        "Couldn't dematerialize %s: corresponding symbol wasn't found",
+        m_persistent_variable_sp->GetName().GetCString());
+  }
+
+  void DumpToLog(IRMemoryMap &map, lldb::addr_t process_address, Log *log) {
+    StreamString dump_stream;
+
+    Status err;
+
+    const lldb::addr_t load_addr = process_address + m_offset;
+
+    dump_stream.Printf("0x%" PRIx64 ": EntityPersistentVariable (%s)\n",
+                       load_addr,
+                       m_persistent_variable_sp->GetName().AsCString());
+
+    {
+      dump_stream.Printf("Pointer:\n");
+
+      DataBufferHeap data(m_size, 0);
+
+      map.ReadMemory(data.GetBytes(), load_addr, m_size, err);
+
+      if (!err.Success()) {
+        dump_stream.Printf("  <could not be read>\n");
+      } else {
+        DumpHexBytes(&dump_stream, data.GetBytes(), data.GetByteSize(), 16,
+                     load_addr);
+
+        dump_stream.PutChar('\n');
+      }
+    }
+
+    {
+      dump_stream.Printf("Target:\n");
+
+      lldb::addr_t target_address;
+
+      map.ReadPointerFromMemory(&target_address, load_addr, err);
+
+      if (!err.Success()) {
+        dump_stream.Printf("  <could not be read>\n");
+      } else {
+        DataBufferHeap data(m_persistent_variable_sp->GetByteSize(), 0);
+
+        map.ReadMemory(data.GetBytes(), target_address,
+                       m_persistent_variable_sp->GetByteSize(), err);
+
+        if (!err.Success()) {
+          dump_stream.Printf("  <could not be read>\n");
+        } else {
+          DumpHexBytes(&dump_stream, data.GetBytes(), data.GetByteSize(), 16,
+                       target_address);
+
+          dump_stream.PutChar('\n');
+        }
+      }
+    }
+
+    log->PutCString(dump_stream.GetData());
+  }
+
+  void Wipe(IRMemoryMap &map, lldb::addr_t process_address) {}
+
+private:
+  lldb::ExpressionVariableSP m_persistent_variable_sp;
+  SwiftREPLMaterializer *m_parent;
+  Materializer::PersistentVariableDelegate *m_delegate;
+};
+
+uint32_t SwiftREPLMaterializer::AddPersistentVariable(
+    lldb::ExpressionVariableSP &persistent_variable_sp,
+    PersistentVariableDelegate *delegate, Status &err) {
+  EntityVector::iterator iter = m_entities.insert(m_entities.end(), EntityUP());
+  iter->reset(
+      new EntityREPLPersistentVariable(persistent_variable_sp, this, delegate));
+  uint32_t ret = AddStructMember(**iter);
+  (*iter)->SetOffset(ret);
+  return ret;
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.h b/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.h
index e69de29bb..6ccf56cbd 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftREPLMaterializer.h
@@ -0,0 +1,52 @@
+//===-- SwiftREPLMaterializer.h ---------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftREPLMaterializer_h
+#define liblldb_SwiftREPLMaterializer_h
+
+#include "lldb/Expression/Materializer.h"
+
+namespace lldb_private {
+
+class SwiftREPLMaterializer : public Materializer {
+public:
+  SwiftREPLMaterializer() : Materializer(eKindSwiftREPL) {}
+
+  uint32_t AddREPLResultVariable(const CompilerType &type,
+                                 swift::ValueDecl *decl,
+                                 PersistentVariableDelegate *delegate,
+                                 Status &err);
+
+  uint32_t
+  AddPersistentVariable(lldb::ExpressionVariableSP &persistent_variable_sp,
+                        PersistentVariableDelegate *delegate,
+                        Status &err) override;
+
+  void RegisterExecutionUnit(IRExecutionUnit *execution_unit) {
+    m_execution_unit = execution_unit;
+  }
+
+  IRExecutionUnit *GetExecutionUnit() { return m_execution_unit; }
+
+  //------------------------------------------------------------------
+  // llvm casting support
+  //------------------------------------------------------------------
+  static bool classof(const Materializer *m) {
+    return m->getKind() == Materializer::eKindSwiftREPL;
+  }
+
+private:
+  IRExecutionUnit *m_execution_unit;
+};
+} // namespace lldb_private
+
+#endif /* SwiftREPLMaterializer_h */
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp b/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp
index e69de29bb..0f31a5465 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.cpp
@@ -0,0 +1,117 @@
+//===-- SwiftSILManipulator.cpp ---------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftSILManipulator.h"
+
+#include "SwiftASTManipulator.h"
+
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Utility/Log.h"
+
+#include "swift/SIL/SILArgument.h"
+#include "swift/SIL/SILBasicBlock.h"
+#include "swift/SIL/SILBuilder.h"
+#include "swift/SIL/SILFunction.h"
+#include "swift/SIL/SILLocation.h"
+#include "swift/SIL/SILModule.h"
+#include "swift/SIL/SILType.h"
+#include "swift/SIL/SILValue.h"
+#include "swift/SIL/TypeLowering.h"
+
+using namespace lldb_private;
+
+SwiftSILManipulator::SwiftSILManipulator(swift::SILBuilder &builder)
+    : m_builder(builder),
+      m_log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS)) {}
+
+swift::SILValue SwiftSILManipulator::emitLValueForVariable(
+    swift::VarDecl *var, SwiftExpressionParser::SILVariableInfo &info) {
+  swift::SILFunction &function = m_builder.getFunction();
+
+  swift::SILBasicBlock &entry_block = *function.getBlocks().begin();
+
+  swift::SILArgument *struct_argument = nullptr;
+
+  for (swift::SILArgument *argument : entry_block.getArguments()) {
+    swift::Identifier argument_name =
+        argument->getDecl()->getBaseName().getIdentifier();
+
+    if (!strcmp(argument_name.get(), SwiftASTManipulator::GetArgumentName())) {
+      struct_argument = argument;
+      break;
+    }
+  }
+
+  if (!struct_argument)
+    return swift::SILValue();
+
+  assert(struct_argument->getType().getAsString().find(
+             "UnsafeMutablePointer") != std::string::npos);
+
+  swift::CanType unsafe_mutable_pointer_can_type =
+      struct_argument->getType().getSwiftRValueType();
+
+  swift::BoundGenericStructType *unsafe_mutable_pointer_struct_type =
+      llvm::cast<swift::BoundGenericStructType>(
+          unsafe_mutable_pointer_can_type.getPointer());
+  swift::StructDecl *unsafe_mutable_pointer_struct_decl =
+      unsafe_mutable_pointer_struct_type->getDecl();
+
+  swift::VarDecl *value_member_decl = nullptr;
+
+  for (swift::Decl *member : unsafe_mutable_pointer_struct_decl->getMembers()) {
+    if (swift::VarDecl *member_var = llvm::dyn_cast<swift::VarDecl>(member)) {
+      if (member_var->getName().str().equals("_rawValue")) {
+        value_member_decl = member_var;
+        break;
+      }
+    }
+  }
+
+  if (!value_member_decl)
+    return swift::SILValue();
+
+  swift::ASTContext &ast_ctx = m_builder.getASTContext();
+  swift::Lowering::TypeConverter converter(m_builder.getModule());
+
+  swift::SILLocation null_loc((swift::Decl *)nullptr);
+  swift::SILType raw_pointer_type = swift::SILType::getRawPointerType(ast_ctx);
+
+  swift::StructExtractInst *struct_extract = m_builder.createStructExtract(
+      null_loc, struct_argument, value_member_decl, raw_pointer_type);
+  swift::IntegerLiteralInst *integer_literal = m_builder.createIntegerLiteral(
+      null_loc, swift::SILType::getBuiltinIntegerType(64, ast_ctx),
+      (intmax_t)info.offset);
+  swift::IndexRawPointerInst *index_raw_pointer =
+      m_builder.createIndexRawPointer(null_loc, struct_extract,
+                                      integer_literal);
+  swift::PointerToAddressInst *pointer_to_return_slot =
+      m_builder.createPointerToAddress(null_loc, index_raw_pointer,
+                                       raw_pointer_type.getAddressType(),
+                                       /*isStrict*/ true);
+  swift::LoadInst *pointer_to_variable = m_builder.createLoad(
+      null_loc, pointer_to_return_slot, swift::LoadOwnershipQualifier::Trivial);
+  auto type =
+      var->getDeclContext()->mapTypeIntoContext(var->getInterfaceType());
+  swift::PointerToAddressInst *address_of_variable =
+      m_builder.createPointerToAddress(
+          null_loc, pointer_to_variable,
+          converter.getLoweredType(type).getAddressType(),
+          /*isStrict*/ true);
+
+  if (info.needs_init) {
+    info.needs_init = false;
+    return swift::SILValue(m_builder.createMarkUninitialized(
+        null_loc, address_of_variable, swift::MarkUninitializedInst::Var));
+  } else
+    return swift::SILValue(address_of_variable);
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.h b/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.h
index e69de29bb..22c603f39 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftSILManipulator.h
@@ -0,0 +1,46 @@
+//===-- SwiftSILManipulator.h -----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftSILManipulator_h
+#define liblldb_SwiftSILManipulator_h
+
+#include "SwiftExpressionParser.h"
+
+#include "lldb/lldb-types.h"
+
+#include "swift/SIL/SILLocation.h"
+#include "swift/SIL/SILValue.h"
+
+namespace swift {
+class SILBuilder;
+};
+
+namespace lldb_private {
+
+class CompilerType;
+class Log;
+
+class SwiftSILManipulator {
+public:
+  SwiftSILManipulator(swift::SILBuilder &builder);
+
+  swift::SILValue
+  emitLValueForVariable(swift::VarDecl *var,
+                        SwiftExpressionParser::SILVariableInfo &info);
+
+protected:
+  swift::SILBuilder &m_builder;
+  Log *m_log;
+};
+} // namespace lldb_private
+
+#endif
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.cpp b/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.cpp
index e69de29bb..b0da2c4d5 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.cpp
+++ b/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.cpp
@@ -0,0 +1,756 @@
+//===-- SwiftUserExpression.cpp ---------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#include "SwiftExpressionParser.h"
+#include "SwiftREPLMaterializer.h"
+
+#include "lldb/Core/Module.h"
+#include "lldb/Expression/DiagnosticManager.h"
+#include "lldb/Expression/ExpressionParser.h"
+#include "lldb/Expression/ExpressionSourceCode.h"
+#include "lldb/Expression/IRExecutionUnit.h"
+#include "lldb/Symbol/CompileUnit.h"
+#include "lldb/Symbol/Symbol.h"
+#include "lldb/Symbol/Type.h"
+#include "lldb/Symbol/Variable.h"
+#include "lldb/Symbol/VariableList.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Utility/LLDBAssert.h"
+#include "lldb/Utility/Log.h"
+
+#include "swift/AST/Type.h"
+#include "swift/AST/Types.h"
+
+#include <cstdlib>
+#include <map>
+#include <string>
+
+#include "SwiftUserExpression.h"
+
+using namespace lldb_private;
+
+SwiftUserExpression::SwiftUserExpression(
+    ExecutionContextScope &exe_scope, llvm::StringRef expr,
+    llvm::StringRef prefix, lldb::LanguageType language,
+    ResultType desired_type, const EvaluateExpressionOptions &options)
+    : LLVMUserExpression(exe_scope, expr, prefix, language, desired_type,
+                         options),
+      m_type_system_helper(*m_target_wp.lock().get()),
+      m_result_delegate(*this, false), m_error_delegate(*this, true),
+      m_persistent_variable_delegate(*this) {}
+
+SwiftUserExpression::~SwiftUserExpression() {}
+
+void SwiftUserExpression::WillStartExecuting() {
+  if (auto process = m_jit_process_wp.lock()) {
+    if (auto *swift_runtime = process->GetSwiftLanguageRuntime())
+      swift_runtime->WillStartExecutingUserExpression();
+    else
+      llvm_unreachable("Can't execute a swift expression without a runtime");
+  } else
+    llvm_unreachable("Can't execute an expression without a process");
+}
+
+void SwiftUserExpression::DidFinishExecuting() {
+  if (auto process = m_jit_process_wp.lock()) {
+    if (auto swift_runtime = process->GetSwiftLanguageRuntime())
+      swift_runtime->DidFinishExecutingUserExpression();
+    else
+      llvm_unreachable("Can't execute a swift expression without a runtime");
+  }
+}
+
+void SwiftUserExpression::ScanContext(ExecutionContext &exe_ctx, Status &err) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  if (log)
+    log->Printf("SwiftUserExpression::ScanContext()");
+
+  m_target = exe_ctx.GetTargetPtr();
+
+  if (!m_target) {
+    if (log)
+      log->Printf("  [SUE::SC] Null target");
+    return;
+  }
+
+  StackFrame *frame = exe_ctx.GetFramePtr();
+  if (frame == NULL) {
+    if (log)
+      log->Printf("  [SUE::SC] Null stack frame");
+    return;
+  }
+
+  SymbolContext sym_ctx = frame->GetSymbolContext(
+      lldb::eSymbolContextFunction | lldb::eSymbolContextBlock |
+      lldb::eSymbolContextCompUnit | lldb::eSymbolContextSymbol);
+
+  // This stage of the scan is only for Swift, but when we are going to do Swift
+  // evaluation we need to do this scan.
+  // So be sure to cover both cases:
+  // 1) When the langauge is eLanguageTypeUnknown, to determine if this IS Swift
+  // 2) When the language is explicitly set to eLanguageTypeSwift.
+
+  bool frame_is_swift = false;
+
+  if (sym_ctx.comp_unit && (m_language == lldb::eLanguageTypeUnknown ||
+                            m_language == lldb::eLanguageTypeSwift)) {
+    if (sym_ctx.comp_unit->GetLanguage() == lldb::eLanguageTypeSwift ||
+        sym_ctx.comp_unit->GetLanguage() == lldb::eLanguageTypePLI)
+      frame_is_swift = true;
+  } else if (sym_ctx.symbol && m_language == lldb::eLanguageTypeUnknown) {
+    if (sym_ctx.symbol->GetMangled().GuessLanguage() ==
+        lldb::eLanguageTypeSwift)
+      frame_is_swift = true;
+  }
+
+  if (frame_is_swift) {
+    m_language_flags &= ~eLanguageFlagIsClass;
+    m_language_flags &= ~eLanguageFlagNeedsObjectPointer;
+
+    // we need to make sure the Target's SwiftASTContext has been setup BEFORE
+    // we do any Swift name lookups
+    if (m_target) {
+      SwiftASTContext *swift_ast_ctx = m_target->GetScratchSwiftASTContext(err);
+      if (!swift_ast_ctx) {
+        if (log)
+          log->Printf("  [SUE::SC] NULL Swift AST Context");
+        return;
+      }
+
+      if (!swift_ast_ctx->GetClangImporter()) {
+        if (log)
+          log->Printf("  [SUE::SC] Swift AST Context has no Clang importer");
+        return;
+      }
+
+      if (swift_ast_ctx->HasFatalErrors()) {
+        if (log)
+          log->Printf("  [SUE::SC] Swift AST Context has fatal errors");
+        return;
+      }
+    }
+
+    if (log)
+      log->Printf("  [SUE::SC] Compilation unit is swift");
+
+    Block *function_block = sym_ctx.GetFunctionBlock();
+
+    if (function_block) {
+      lldb::VariableListSP variable_list_sp(
+          function_block->GetBlockVariableList(true));
+
+      if (variable_list_sp) {
+        lldb::VariableSP self_var_sp(
+            variable_list_sp->FindVariable(ConstString("self")));
+
+        do {
+          if (!self_var_sp)
+            break;
+
+          CompilerType self_type;
+
+          lldb::StackFrameSP stack_frame_sp = exe_ctx.GetFrameSP();
+
+          if (stack_frame_sp) {
+            // If we have a self variable, but it has no location at the current
+            // PC, then we can't use
+            // it.  Set the self var back to empty and we'll just pretend we are
+            // in a regular frame,
+            // which is really the best we can do.
+
+            if (!self_var_sp->LocationIsValidForFrame(stack_frame_sp.get())) {
+              self_var_sp.reset();
+              break;
+            }
+
+            lldb::ValueObjectSP valobj_sp =
+                stack_frame_sp->GetValueObjectForFrameVariable(
+                    self_var_sp, lldb::eDynamicDontRunTarget);
+
+            if (valobj_sp && valobj_sp->GetError().Success())
+              self_type = valobj_sp->GetCompilerType();
+          }
+
+          if (!self_type.IsValid()) {
+            Type *self_lldb_type = self_var_sp->GetType();
+
+            if (self_lldb_type)
+              self_type = self_var_sp->GetType()->GetForwardCompilerType();
+          }
+
+          if (!self_type.IsValid()) {
+            // If the self_type is invalid at this point, reset it.  Code below
+            // the phony do/while will
+            // assume the existence of this var means something, but it is
+            // useless in this condition.
+            self_var_sp.reset();
+            break;
+          }
+
+          // Check to see if we are in a class func of a class (or static func
+          // of a struct) and adjust our
+          // self_type to point to the instance type.
+
+          m_language_flags |= eLanguageFlagNeedsObjectPointer;
+
+          Flags self_type_flags(self_type.GetTypeInfo());
+
+          if (self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                     lldb::eTypeIsMetatype)) {
+            self_type = self_type.GetInstanceType();
+            self_type_flags = self_type.GetTypeInfo();
+            if (self_type_flags.Test(lldb::eTypeIsClass))
+              m_language_flags |= eLanguageFlagIsClass;
+            m_language_flags |= eLanguageFlagInStaticMethod;
+          }
+
+          if (self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                     lldb::eTypeInstanceIsPointer)) {
+            if (self_type_flags.Test(lldb::eTypeIsClass))
+              m_language_flags |= eLanguageFlagIsClass;
+          }
+
+          swift::Type object_type =
+              swift::Type((swift::TypeBase *)(self_type.GetOpaqueQualType()))
+                  ->getWithoutSpecifierType();
+
+          if (object_type.getPointer() &&
+              (object_type.getPointer() != self_type.GetOpaqueQualType()))
+            self_type = CompilerType(self_type.GetTypeSystem(),
+                                     object_type.getPointer());
+
+          if (Flags(self_type.GetTypeInfo())
+                  .AllSet(lldb::eTypeIsSwift | lldb::eTypeIsEnumeration |
+                          lldb::eTypeIsGeneric)) {
+            // Optional<T> means a weak 'self.'  Make sure this really is
+            // Optional<T>
+            if (self_type.GetTypeName().GetStringRef().startswith(
+                    "Swift.Optional<")) {
+              m_language_flags |= eLanguageFlagIsClass;
+              m_language_flags |= eLanguageFlagIsWeakSelf;
+            } else {
+              // Something else is going on that we don't handle.
+              m_language_flags &= ~eLanguageFlagNeedsObjectPointer;
+              self_var_sp.reset();
+              break;
+            }
+          }
+
+          if (Flags(self_type.GetTypeInfo())
+                  .AllSet(lldb::eTypeIsSwift | lldb::eTypeIsStructUnion |
+                          lldb::eTypeIsGeneric) &&
+              self_type_flags.AllSet(lldb::eTypeIsSwift |
+                                     lldb::eTypeIsReference |
+                                     lldb::eTypeHasValue)) {
+            // We can't extend generic structs when "self" is mutating at the
+            // moment.
+            m_language_flags &= ~eLanguageFlagNeedsObjectPointer;
+            self_var_sp.reset();
+            break;
+          }
+
+          if (log)
+            log->Printf("  [SUE::SC] Containing class name: %s",
+                        self_type.GetTypeName().AsCString());
+
+          bool is_generic =
+              self_type_flags.AllSet(lldb::eTypeIsSwift | lldb::eTypeIsGeneric);
+          bool is_bound =
+              is_generic && self_type_flags.AllSet(lldb::eTypeIsBound);
+          if (!is_generic || !is_bound)
+            break;
+
+          CompilerType self_unbound_type = self_type.GetUnboundType();
+
+          const size_t num_template_args = self_type.GetNumTemplateArguments();
+          if (log && num_template_args)
+            log->Printf("  [SUE::SC] Class generic arguments:");
+
+          for (size_t ai = 0, ae = num_template_args; ai != ae; ++ai) {
+            lldb::TemplateArgumentKind template_arg_kind;
+
+            CompilerType template_arg_type =
+                self_type.GetTemplateArgument(ai, template_arg_kind);
+
+            ConstString template_arg_name = template_arg_type.GetTypeName();
+
+            if (log)
+              log->Printf("    [SUE::SC] Argument name: %s",
+                          template_arg_name.AsCString());
+
+            CompilerType concrete_type =
+                exe_ctx.GetProcessRef()
+                    .GetSwiftLanguageRuntime()
+                    ->GetConcreteType(frame, template_arg_name);
+
+            const char *printable_name;
+            if (concrete_type.IsValid())
+              printable_name = concrete_type.GetTypeName().AsCString();
+            else
+              printable_name = template_arg_type.GetTypeName().AsCString();
+
+            if (log)
+              log->Printf("    [SUE::SC] Argument type: %s", printable_name);
+          }
+
+          if (log && self_unbound_type.GetNumTemplateArguments())
+            log->Printf("  [SUE::SC] Class unbound generic arguments:");
+
+          for (size_t ai = 0, ae = self_unbound_type.GetNumTemplateArguments();
+               ai != ae; ++ai) {
+            lldb::TemplateArgumentKind template_arg_kind;
+
+            CompilerType template_arg_type =
+                self_unbound_type.GetTemplateArgument(ai, template_arg_kind);
+
+            ConstString template_arg_name = template_arg_type.GetTypeName();
+
+            if (log)
+              log->Printf("    [SUE::SC] Argument name: %s",
+                          template_arg_name.AsCString());
+
+            CompilerType concrete_type =
+                exe_ctx.GetProcessRef()
+                    .GetSwiftLanguageRuntime()
+                    ->GetConcreteType(frame, template_arg_name);
+
+            if (log)
+              log->Printf("    [SUE::SC] Argument type: %s",
+                          concrete_type.GetTypeName().AsCString());
+
+            m_swift_generic_info.class_bindings.push_back(
+                {template_arg_name.AsCString(), concrete_type});
+          }
+        } while (0);
+      }
+    }
+
+    do {
+      ConstString function_name =
+          sym_ctx.GetFunctionName(Mangled::ePreferMangled);
+
+      if (function_name.IsEmpty())
+        break;
+
+      if (log)
+        log->Printf("  [SUE::SC] Function name: %s", function_name.AsCString());
+
+      Status get_type_error;
+      SwiftASTContext *ast_context = llvm::dyn_cast_or_null<SwiftASTContext>(
+          sym_ctx.module_sp->GetTypeSystemForLanguage(
+              lldb::eLanguageTypeSwift));
+      if (!ast_context || ast_context->HasFatalErrors())
+        break;
+
+      CompilerType function_type = ast_context->GetTypeFromMangledTypename(
+          function_name.AsCString(), get_type_error);
+
+      if (get_type_error.Fail() || !function_type.IsValid())
+        break;
+
+      if (log && function_type.GetNumTemplateArguments())
+        log->Printf("  [SUE::SC] Function generic arguments:");
+
+      for (size_t ai = 0, ae = function_type.GetNumTemplateArguments();
+           ai != ae; ++ai) {
+        lldb::TemplateArgumentKind template_arg_kind;
+
+        CompilerType template_arg_type =
+            function_type.GetTemplateArgument(ai, template_arg_kind);
+
+        ConstString template_arg_name = template_arg_type.GetTypeName();
+
+        if (log)
+          log->Printf("    [SUE::SC] Argument name: %s",
+                      template_arg_name.AsCString());
+
+        CompilerType concrete_type =
+            exe_ctx.GetProcessRef().GetSwiftLanguageRuntime()->GetConcreteType(
+                frame, template_arg_name);
+
+        lldbassert(concrete_type.IsValid());
+
+        if (!concrete_type.IsValid()) {
+          if (log)
+            log->Printf(
+                "  [SUE::SC] Concrete type of generic parameter is invalid");
+
+          continue;
+        }
+
+        if (log)
+          log->Printf("    [SUE::SC] Argument type: %s",
+                      concrete_type.GetTypeName().AsCString());
+
+        const char *name = template_arg_name.AsCString();
+
+        bool found = false;
+
+        for (const SwiftGenericInfo::Binding &binding :
+             m_swift_generic_info.class_bindings) {
+          if (binding.name == name) {
+            found = true;
+            break;
+          }
+        }
+
+        if (!found)
+          m_swift_generic_info.function_bindings.push_back(
+              {name, concrete_type});
+      }
+    } while (0);
+  }
+}
+
+bool SwiftUserExpression::Parse(DiagnosticManager &diagnostic_manager,
+                                ExecutionContext &exe_ctx,
+                                lldb_private::ExecutionPolicy execution_policy,
+                                bool keep_result_in_memory,
+                                bool generate_debug_info,
+                                uint32_t line_offset) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  Status err;
+
+  InstallContext(exe_ctx);
+
+  if (Target *target = exe_ctx.GetTargetPtr()) {
+    if (PersistentExpressionState *persistent_state =
+            target->GetPersistentExpressionStateForLanguage(
+                lldb::eLanguageTypeSwift)) {
+      m_result_delegate.RegisterPersistentState(persistent_state);
+      m_error_delegate.RegisterPersistentState(persistent_state);
+    } else {
+      diagnostic_manager.PutString(
+          eDiagnosticSeverityError,
+          "couldn't start parsing (no persistent data)");
+      return false;
+    }
+  } else {
+    diagnostic_manager.PutString(eDiagnosticSeverityError,
+                                 "couldn't start parsing (no target)");
+    return false;
+  }
+
+  ScanContext(exe_ctx, err);
+
+  if (!err.Success()) {
+    diagnostic_manager.Printf(eDiagnosticSeverityError, "warning: %s\n",
+                              err.AsCString());
+  }
+
+  StreamString m_transformed_stream;
+
+  ////////////////////////////////////
+  // Generate the expression
+  //
+
+  std::string prefix = m_expr_prefix;
+
+  std::unique_ptr<ExpressionSourceCode> source_code(
+      ExpressionSourceCode::CreateWrapped(prefix.c_str(), m_expr_text.c_str()));
+
+  const lldb::LanguageType lang_type = lldb::eLanguageTypeSwift;
+
+  m_options.SetLanguage(lang_type);
+  uint32_t first_body_line = 0;
+
+  if (!source_code->GetText(m_transformed_text, lang_type, m_language_flags,
+                            m_options, m_swift_generic_info, exe_ctx,
+                            first_body_line)) {
+    diagnostic_manager.PutString(eDiagnosticSeverityError,
+                                 "couldn't construct expression body");
+    return false;
+  }
+
+  if (log)
+    log->Printf("Parsing the following code:\n%s", m_transformed_text.c_str());
+
+  ////////////////////////////////////
+  // Set up the target and compiler
+  //
+
+  Target *target = exe_ctx.GetTargetPtr();
+
+  if (!target) {
+    diagnostic_manager.PutString(eDiagnosticSeverityError, "invalid target\n");
+    return false;
+  }
+
+  //////////////////////////
+  // Parse the expression
+  //
+
+  if (m_options.GetREPLEnabled())
+    m_materializer_ap.reset(new SwiftREPLMaterializer());
+  else
+    m_materializer_ap.reset(new Materializer());
+
+  class OnExit {
+  public:
+    typedef std::function<void(void)> Callback;
+
+    OnExit(Callback const &callback) : m_callback(callback) {}
+
+    ~OnExit() { m_callback(); }
+
+  private:
+    Callback m_callback;
+  };
+
+  ExecutionContextScope *exe_scope = NULL;
+
+  Process *process = exe_ctx.GetProcessPtr();
+
+  do {
+    exe_scope = exe_ctx.GetFramePtr();
+    if (exe_scope)
+      break;
+
+    exe_scope = process;
+    if (exe_scope)
+      break;
+
+    exe_scope = exe_ctx.GetTargetPtr();
+  } while (0);
+
+  std::unique_ptr<ExpressionParser> parser(
+      new SwiftExpressionParser(exe_scope, *this, m_options));
+
+  unsigned num_errors = parser->Parse(
+      diagnostic_manager, first_body_line,
+      first_body_line + source_code->GetNumBodyLines(), line_offset);
+
+  if (num_errors) {
+    // Calculate the fixed expression string at this point:
+    if (diagnostic_manager.HasFixIts()) {
+      if (parser->RewriteExpression(diagnostic_manager)) {
+        size_t fixed_start;
+        size_t fixed_end;
+        const std::string &fixed_expression =
+            diagnostic_manager.GetFixedExpression();
+        if (ExpressionSourceCode::GetOriginalBodyBounds(
+                fixed_expression, lang_type, fixed_start, fixed_end))
+          m_fixed_text =
+              fixed_expression.substr(fixed_start, fixed_end - fixed_start);
+      }
+    }
+    return false;
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////////
+  // Prepare the output of the parser for execution, evaluating it statically if
+  // possible
+  //
+
+  Status jit_error = parser->PrepareForExecution(
+      m_jit_start_addr, m_jit_end_addr, m_execution_unit_sp, exe_ctx,
+      m_can_interpret, execution_policy);
+
+  if (m_execution_unit_sp) {
+    if (m_options.GetREPLEnabled()) {
+      llvm::cast<SwiftREPLMaterializer>(m_materializer_ap.get())
+          ->RegisterExecutionUnit(m_execution_unit_sp.get());
+    }
+
+    bool register_execution_unit = false;
+
+    if (m_options.GetREPLEnabled()) {
+      if (!m_execution_unit_sp->GetJittedFunctions().empty() ||
+          !m_execution_unit_sp->GetJittedGlobalVariables().empty()) {
+        register_execution_unit = true;
+      }
+    } else {
+      if (m_execution_unit_sp->GetJittedFunctions().size() > 1 ||
+          m_execution_unit_sp->GetJittedGlobalVariables().size() > 1) {
+        register_execution_unit = true;
+      }
+    }
+
+    if (register_execution_unit) {
+      // We currently key off there being more than one external function in the
+      // execution
+      // unit to determine whether it needs to live in the process.
+
+      llvm::cast<SwiftPersistentExpressionState>(
+          exe_ctx.GetTargetPtr()->GetPersistentExpressionStateForLanguage(
+              lldb::eLanguageTypeSwift))
+          ->RegisterExecutionUnit(m_execution_unit_sp);
+    }
+  }
+
+  if (m_options.GetGenerateDebugInfo()) {
+    StreamString jit_module_name;
+    jit_module_name.Printf("%s%u", FunctionName(),
+                           m_options.GetExpressionNumber());
+    const char *limit_file = m_options.GetPoundLineFilePath();
+    FileSpec limit_file_spec;
+    uint32_t limit_start_line = 0;
+    uint32_t limit_end_line = 0;
+    if (limit_file) {
+      limit_file_spec.SetFile(limit_file, false);
+      limit_start_line = m_options.GetPoundLineLine();
+      limit_end_line = limit_start_line +
+                       std::count(m_expr_text.begin(), m_expr_text.end(), '\n');
+    }
+    m_execution_unit_sp->CreateJITModule(jit_module_name.GetString().data(),
+                                         limit_file ? &limit_file_spec : NULL,
+                                         limit_start_line, limit_end_line);
+  }
+
+  if (jit_error.Success()) {
+    if (process && m_jit_start_addr != LLDB_INVALID_ADDRESS)
+      m_jit_process_wp = lldb::ProcessWP(process->shared_from_this());
+    return true;
+  } else {
+    const char *error_cstr = jit_error.AsCString();
+    if (error_cstr && error_cstr[0])
+      diagnostic_manager.PutString(eDiagnosticSeverityError, error_cstr);
+    else
+      diagnostic_manager.PutString(eDiagnosticSeverityError,
+                                   "expression can't be interpreted or run\n");
+    return false;
+  }
+}
+
+bool SwiftUserExpression::AddArguments(ExecutionContext &exe_ctx,
+                                       std::vector<lldb::addr_t> &args,
+                                       lldb::addr_t struct_address,
+                                       DiagnosticManager &diagnostic_manager) {
+  lldb::addr_t object_ptr = LLDB_INVALID_ADDRESS;
+
+  if (m_language_flags & eLanguageFlagNeedsObjectPointer) {
+    lldb::StackFrameSP frame_sp = exe_ctx.GetFrameSP();
+    if (!frame_sp)
+      return true;
+
+    ConstString object_name("self");
+
+    Status object_ptr_error;
+
+    object_ptr = GetObjectPointer(frame_sp, object_name, object_ptr_error);
+
+    if (!object_ptr_error.Success()) {
+      diagnostic_manager.Printf(
+          eDiagnosticSeverityWarning,
+          "couldn't get required object pointer (substituting NULL): %s\n",
+          object_ptr_error.AsCString());
+      object_ptr = 0;
+    }
+
+    if (m_options.GetPlaygroundTransformEnabled() ||
+        m_options.GetREPLEnabled()) {
+      // When calling the playground function we are calling
+      // a main function which takes two arguments: argc and argv
+      // So we pass two zeroes as arguments
+      args.push_back(0); // argc
+      args.push_back(0); // argv
+    } else {
+      args.push_back(struct_address);
+      args.push_back(object_ptr);
+    }
+  } else {
+    args.push_back(struct_address);
+  }
+  return true;
+}
+
+lldb::ExpressionVariableSP SwiftUserExpression::GetResultAfterDematerialization(
+    ExecutionContextScope *exe_scope) {
+  lldb::ExpressionVariableSP in_result_sp = m_result_delegate.GetVariable();
+  lldb::ExpressionVariableSP in_error_sp = m_error_delegate.GetVariable();
+
+  lldb::ExpressionVariableSP result_sp;
+
+  if (in_error_sp) {
+    bool error_is_valid = false;
+
+    if (llvm::isa<SwiftASTContext>(
+            in_error_sp->GetCompilerType().GetTypeSystem())) {
+      lldb::ValueObjectSP val_sp = in_error_sp->GetValueObject();
+      if (val_sp) {
+        if (exe_scope) {
+          lldb::ProcessSP process_sp = exe_scope->CalculateProcess();
+          if (process_sp) {
+            SwiftLanguageRuntime *swift_runtime =
+                process_sp->GetSwiftLanguageRuntime();
+            if (swift_runtime)
+              error_is_valid = swift_runtime->IsValidErrorValue(*val_sp.get());
+          }
+        }
+      }
+    }
+
+    lldb::TargetSP target_sp = exe_scope->CalculateTarget();
+
+    if (target_sp) {
+      if (PersistentExpressionState *persistent_state =
+              target_sp->GetPersistentExpressionStateForLanguage(
+                  lldb::eLanguageTypeSwift)) {
+        if (error_is_valid) {
+          persistent_state->RemovePersistentVariable(in_result_sp);
+          result_sp = in_error_sp;
+        } else {
+          persistent_state->RemovePersistentVariable(in_error_sp);
+          result_sp = in_result_sp;
+        }
+      }
+    }
+  } else
+    result_sp = in_result_sp;
+
+  return result_sp;
+}
+
+SwiftUserExpression::ResultDelegate::ResultDelegate(
+    SwiftUserExpression &user_expression, bool is_error)
+    : m_user_expression(user_expression), m_is_error(is_error) {}
+
+ConstString SwiftUserExpression::ResultDelegate::GetName() {
+  return m_persistent_state->GetNextPersistentVariableName(m_is_error);
+}
+
+void SwiftUserExpression::ResultDelegate::DidDematerialize(
+    lldb::ExpressionVariableSP &variable) {
+  m_variable = variable;
+}
+
+void SwiftUserExpression::ResultDelegate::RegisterPersistentState(
+    PersistentExpressionState *persistent_state) {
+  m_persistent_state = persistent_state;
+}
+
+lldb::ExpressionVariableSP &SwiftUserExpression::ResultDelegate::GetVariable() {
+  return m_variable;
+}
+
+SwiftUserExpression::PersistentVariableDelegate::PersistentVariableDelegate(
+    SwiftUserExpression &user_expression)
+    : m_user_expression(user_expression) {}
+
+ConstString SwiftUserExpression::PersistentVariableDelegate::GetName() {
+  return ConstString();
+}
+
+void SwiftUserExpression::PersistentVariableDelegate::DidDematerialize(
+    lldb::ExpressionVariableSP &variable) {
+  if (SwiftExpressionVariable *swift_var =
+          llvm::dyn_cast<SwiftExpressionVariable>(variable.get())) {
+    swift_var->m_swift_flags &= ~SwiftExpressionVariable::EVSNeedsInit;
+  }
+}
diff --git a/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.h b/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.h
index e69de29bb..958ec2758 100644
--- a/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.h
+++ b/source/Plugins/ExpressionParser/Swift/SwiftUserExpression.h
@@ -0,0 +1,192 @@
+//===-- SwiftUserExpression.h -----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftUserExpression_h_
+#define liblldb_SwiftUserExpression_h_
+
+// C Includes
+// C++ Includes
+#include <map>
+#include <string>
+#include <vector>
+
+#include "lldb/Expression/LLVMUserExpression.h"
+#include "lldb/Expression/Materializer.h"
+
+// Other libraries and framework includes
+// Project includes
+
+namespace lldb_private {
+
+//----------------------------------------------------------------------
+/// @class SwiftUserExpression SwiftUserExpression.h
+/// "lldb/Expression/SwiftUserExpression.h"
+/// @brief Encapsulates a single expression for use with Clang
+///
+/// LLDB uses expressions for various purposes, notably to call functions
+/// and as a backend for the expr command.  SwiftUserExpression encapsulates
+/// the objects needed to parse and interpret or JIT an expression.  It
+/// uses the Clang parser to produce LLVM IR from the expression.
+//----------------------------------------------------------------------
+class SwiftUserExpression : public LLVMUserExpression {
+public:
+  enum { kDefaultTimeout = 500000u };
+
+  enum {
+    eLanguageFlagNeedsObjectPointer = 1 << 0,
+    eLanguageFlagInStaticMethod = 1 << 1,
+    eLanguageFlagIsClass = 1 << 2,
+    eLanguageFlagIsWeakSelf = 1 << 3
+  };
+
+  class SwiftUserExpressionHelper : public ExpressionTypeSystemHelper {
+  public:
+    SwiftUserExpressionHelper(Target &target)
+        : ExpressionTypeSystemHelper(eKindSwiftHelper), m_target(target) {}
+
+    ~SwiftUserExpressionHelper() {}
+
+  private:
+    Target &m_target;
+  };
+
+  //------------------------------------------------------------------
+  /// Constructor
+  ///
+  /// @param[in] expr
+  ///     The expression to parse.
+  ///
+  /// @param[in] expr_prefix
+  ///     If non-NULL, a C string containing translation-unit level
+  ///     definitions to be included when the expression is parsed.
+  ///
+  /// @param[in] language
+  ///     If not eLanguageTypeUnknown, a language to use when parsing
+  ///     the expression.  Currently restricted to those languages
+  ///     supported by Clang.
+  ///
+  /// @param[in] desired_type
+  ///     If not eResultTypeAny, the type to use for the expression
+  ///     result.
+  ///
+  /// @param[in] options
+  ///     Additional options for the expression.
+  //------------------------------------------------------------------
+  SwiftUserExpression(ExecutionContextScope &exe_scope, llvm::StringRef expr,
+                      llvm::StringRef prefix, lldb::LanguageType language,
+                      ResultType desired_type,
+                      const EvaluateExpressionOptions &options);
+
+  //------------------------------------------------------------------
+  /// Destructor
+  //------------------------------------------------------------------
+  ~SwiftUserExpression() override;
+
+  //------------------------------------------------------------------
+  /// Parse the expression
+  ///
+  /// @param[in] diagnostic_manager
+  ///     A diagnostic manager to report parse errors and warnings to.
+  ///
+  /// @param[in] exe_ctx
+  ///     The execution context to use when looking up entities that
+  ///     are needed for parsing (locations of functions, types of
+  ///     variables, persistent variables, etc.)
+  ///
+  /// @param[in] execution_policy
+  ///     Determines whether interpretation is possible or mandatory.
+  ///
+  /// @param[in] keep_result_in_memory
+  ///     True if the resulting persistent variable should reside in
+  ///     target memory, if applicable.
+  ///
+  /// @return
+  ///     True on success (no errors); false otherwise.
+  //------------------------------------------------------------------
+  bool Parse(DiagnosticManager &diagnostic_manager, ExecutionContext &exe_ctx,
+             lldb_private::ExecutionPolicy execution_policy,
+             bool keep_result_in_memory, bool generate_debug_info,
+             uint32_t line_offset = 0) override;
+
+  ExpressionTypeSystemHelper *GetTypeSystemHelper() override {
+    return &m_type_system_helper;
+  }
+
+  Materializer::PersistentVariableDelegate &GetResultDelegate() {
+    return m_result_delegate;
+  }
+
+  Materializer::PersistentVariableDelegate &GetErrorDelegate() {
+    return m_error_delegate;
+  }
+
+  Materializer::PersistentVariableDelegate &GetPersistentVariableDelegate() {
+    return m_persistent_variable_delegate;
+  }
+
+  lldb::ExpressionVariableSP
+  GetResultAfterDematerialization(ExecutionContextScope *exe_scope) override;
+
+  void WillStartExecuting() override;
+  void DidFinishExecuting() override;
+
+private:
+  //------------------------------------------------------------------
+  /// Populate m_in_cplusplus_method and m_in_objectivec_method based on the
+  /// environment.
+  //------------------------------------------------------------------
+
+  void ScanContext(ExecutionContext &exe_ctx,
+                   lldb_private::Status &err) override;
+
+  bool AddArguments(ExecutionContext &exe_ctx, std::vector<lldb::addr_t> &args,
+                    lldb::addr_t struct_address,
+                    DiagnosticManager &diagnostic_manager) override;
+
+  SwiftUserExpressionHelper m_type_system_helper;
+
+  class ResultDelegate : public Materializer::PersistentVariableDelegate {
+  public:
+    ResultDelegate(SwiftUserExpression &, bool is_error);
+    ConstString GetName() override;
+    void DidDematerialize(lldb::ExpressionVariableSP &variable) override;
+
+    void RegisterPersistentState(PersistentExpressionState *persistent_state);
+    lldb::ExpressionVariableSP &GetVariable();
+
+  private:
+    SwiftUserExpression &m_user_expression;
+    bool m_is_error;
+    PersistentExpressionState *m_persistent_state;
+    lldb::ExpressionVariableSP m_variable;
+  };
+
+  ResultDelegate m_result_delegate;
+  ResultDelegate m_error_delegate;
+
+  class PersistentVariableDelegate
+      : public Materializer::PersistentVariableDelegate {
+  public:
+    PersistentVariableDelegate(SwiftUserExpression &);
+    ConstString GetName() override;
+    void DidDematerialize(lldb::ExpressionVariableSP &variable) override;
+
+  private:
+    SwiftUserExpression &m_user_expression;
+  };
+
+  PersistentVariableDelegate m_persistent_variable_delegate;
+};
+
+} // namespace lldb_private
+
+#endif // liblldb_SwiftUserExpression_h_
diff --git a/source/Plugins/InstrumentationRuntime/CMakeLists.txt b/source/Plugins/InstrumentationRuntime/CMakeLists.txt
index 55e8752e7..9ed0403e9 100644
--- a/source/Plugins/InstrumentationRuntime/CMakeLists.txt
+++ b/source/Plugins/InstrumentationRuntime/CMakeLists.txt
@@ -2,3 +2,4 @@ add_subdirectory(ASan)
 add_subdirectory(MainThreadChecker)
 add_subdirectory(TSan)
 add_subdirectory(UBSan)
+add_subdirectory(SwiftRuntimeReporting)
diff --git a/source/Plugins/InstrumentationRuntime/MainThreadChecker/MainThreadCheckerRuntime.cpp b/source/Plugins/InstrumentationRuntime/MainThreadChecker/MainThreadCheckerRuntime.cpp
index eb238419a..0987d28ea 100644
--- a/source/Plugins/InstrumentationRuntime/MainThreadChecker/MainThreadCheckerRuntime.cpp
+++ b/source/Plugins/InstrumentationRuntime/MainThreadChecker/MainThreadCheckerRuntime.cpp
@@ -24,6 +24,9 @@
 #include "lldb/Target/Thread.h"
 #include "lldb/Utility/RegularExpression.h"
 #include "Plugins/Process/Utility/HistoryThread.h"
+#include "swift/AST/ASTContext.h"
+#include "swift/AST/NameLookup.h"
+#include "swift/ClangImporter/ClangImporter.h"
 
 using namespace lldb;
 using namespace lldb_private;
@@ -69,6 +72,84 @@ bool MainThreadCheckerRuntime::CheckIfRuntimeIsValid(
   return symbol != nullptr;
 }
 
+static std::string TranslateObjCNameToSwiftName(std::string className,
+                                                std::string selector,
+                                                StackFrameSP swiftFrame) {
+  if (className.empty() || selector.empty())
+    return "";
+  ModuleSP swiftModule = swiftFrame->GetFrameCodeAddress().GetModule();
+  if (!swiftModule)
+    return "";
+  SwiftASTContext *ctx = llvm::dyn_cast_or_null<SwiftASTContext>(
+      swiftModule->GetTypeSystemForLanguage(lldb::eLanguageTypeSwift));
+  if (!ctx)
+    return "";
+  swift::ClangImporter *imp = ctx->GetClangImporter();
+  if (!imp)
+    return "";
+
+  size_t numArguments = llvm::StringRef(selector).count(':');
+  llvm::SmallVector<llvm::StringRef, 4> parts;
+  llvm::StringRef(selector).split(parts, ":", /*MaxSplit*/ -1,
+      /*KeepEmpty*/ false);
+
+  llvm::SmallVector<swift::Identifier, 2> selectorIdentifiers;
+  for (size_t i = 0; i < parts.size(); i++) {
+    selectorIdentifiers.push_back(ctx->GetIdentifier(parts[i]));
+  }
+
+  class MyConsumer : public swift::VisibleDeclConsumer {
+  public:
+    swift::ObjCSelector selectorToLookup;
+    swift::DeclName result;
+
+    MyConsumer(swift::ObjCSelector selector) : selectorToLookup(selector) {}
+
+    virtual void foundDecl(swift::ValueDecl *VD,
+                           swift::DeclVisibilityKind Reason) {
+      if (result)
+        return; // Take the first result.
+      swift::ClassDecl *cls = llvm::dyn_cast<swift::ClassDecl>(VD);
+      if (!cls)
+        return;
+      auto funcs = cls->lookupDirect(selectorToLookup, true);
+      if (funcs.size() == 0)
+        return;
+
+      // If the decl is actually an accessor, use the property name instead.
+      swift::AbstractFunctionDecl *decl = funcs.front();
+      if (auto func = llvm::dyn_cast<swift::FuncDecl>(decl)) {
+        swift::DeclContext *funcCtx = func->getParent();
+        // We need to loadAllMembers(), otherwise 'isAccessor' returns false.
+        if (auto extension = llvm::dyn_cast<swift::ExtensionDecl>(funcCtx)) {
+          extension->loadAllMembers();
+        } else if (auto nominal =
+                       llvm::dyn_cast<swift::NominalTypeDecl>(funcCtx)) {
+          nominal->loadAllMembers();
+        }
+
+        if (func->isAccessor()) {
+          result = func->getAccessorStorageDecl()->getFullName();
+          return;
+        }
+      }
+
+      result = decl->getFullName();
+    }
+  };
+
+  MyConsumer consumer(swift::ObjCSelector(*ctx->GetASTContext(), numArguments,
+                                          selectorIdentifiers));
+  // FIXME(mracek): Switch to a new API that translates the Clang class name
+  // to Swift class name, once this API exists. Now we assume they are the same.
+  imp->lookupValue(ctx->GetIdentifier(className), consumer);
+
+  if (!consumer.result)
+    return "";
+  llvm::SmallString<32> scratchSpace;
+  return className + "." + consumer.result.getString(scratchSpace).str();
+}
+
 StructuredData::ObjectSP
 MainThreadCheckerRuntime::RetrieveReportData(ExecutionContextRef exe_ctx_ref) {
   ProcessSP process_sp = GetProcessSP();
@@ -133,7 +214,16 @@ MainThreadCheckerRuntime::RetrieveReportData(ExecutionContextRef exe_ctx_ref) {
     lldb::addr_t PC = addr.GetLoadAddress(&target);
     trace->AddItem(StructuredData::ObjectSP(new StructuredData::Integer(PC)));
   }
-
+  
+  if (responsible_frame) {
+    if (responsible_frame->GetLanguage() == eLanguageTypeSwift) {
+      std::string swiftApiName =
+          TranslateObjCNameToSwiftName(className, selector, responsible_frame);
+      if (swiftApiName != "")
+        apiName = swiftApiName;
+    }
+  }
+  
   auto *d = new StructuredData::Dictionary();
   auto dict_sp = StructuredData::ObjectSP(d);
   d->AddStringItem("instrumentation_class", "MainThreadChecker");
diff --git a/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/CMakeLists.txt b/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/CMakeLists.txt
index e69de29bb..5e948b3f8 100644
--- a/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/CMakeLists.txt
+++ b/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/CMakeLists.txt
@@ -0,0 +1,6 @@
+add_lldb_library(lldbPluginInstrumentationRuntimeSwiftRuntimeReporting PLUGIN
+                     SwiftRuntimeReporting.cpp
+
+                         LINK_LIBS lldbBreakpoint lldbCore lldbExpression
+                             lldbInterpreter lldbSymbol lldbTarget
+                                 LINK_COMPONENTS Support)
diff --git a/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.cpp b/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.cpp
index e69de29bb..0cc9a53a6 100644
--- a/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.cpp
+++ b/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.cpp
@@ -0,0 +1,473 @@
+//===-- SwiftRuntimeReporting.cpp -------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftRuntimeReporting.h"
+
+#include "Plugins/Process/Utility/HistoryThread.h"
+#include "lldb/Breakpoint/StoppointCallbackContext.h"
+#include "lldb/Core/Module.h"
+#include "lldb/Core/PluginManager.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/Symbol.h"
+#include "lldb/Symbol/SymbolContext.h"
+#include "lldb/Symbol/Variable.h"
+#include "lldb/Symbol/VariableList.h"
+#include "lldb/Target/InstrumentationRuntimeStopInfo.h"
+#include "lldb/Target/RegisterContext.h"
+#include "lldb/Target/SectionLoadList.h"
+#include "lldb/Target/StopInfo.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Target/Thread.h"
+#include "lldb/Utility/RegularExpression.h"
+#include "swift/AST/ASTContext.h"
+#include "swift/AST/NameLookup.h"
+#include "swift/ClangImporter/ClangImporter.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+SwiftRuntimeReporting::~SwiftRuntimeReporting() { Deactivate(); }
+
+lldb::InstrumentationRuntimeSP
+SwiftRuntimeReporting::CreateInstance(const lldb::ProcessSP &process_sp) {
+  return InstrumentationRuntimeSP(new SwiftRuntimeReporting(process_sp));
+}
+
+void SwiftRuntimeReporting::Initialize() {
+  PluginManager::RegisterPlugin(
+      GetPluginNameStatic(),
+      "SwiftRuntimeReporting instrumentation runtime plugin.", CreateInstance,
+      GetTypeStatic);
+}
+
+void SwiftRuntimeReporting::Terminate() {
+  PluginManager::UnregisterPlugin(CreateInstance);
+}
+
+lldb_private::ConstString SwiftRuntimeReporting::GetPluginNameStatic() {
+  return ConstString("SwiftRuntimeReporting");
+}
+
+lldb::InstrumentationRuntimeType SwiftRuntimeReporting::GetTypeStatic() {
+  return eInstrumentationRuntimeTypeSwiftRuntimeReporting;
+}
+
+const RegularExpression &SwiftRuntimeReporting::GetPatternForRuntimeLibrary() {
+  // TODO: Add support for Linux.
+  static RegularExpression regex(llvm::StringRef("libswiftCore.dylib"));
+  return regex;
+}
+
+bool SwiftRuntimeReporting::CheckIfRuntimeIsValid(
+    const lldb::ModuleSP module_sp) {
+  static ConstString test_sym("_swift_runtime_on_report");
+  const Symbol *symbol =
+      module_sp->FindFirstSymbolWithNameAndType(test_sym, lldb::eSymbolTypeAny);
+  return symbol != nullptr;
+}
+
+static StructuredData::ArraySP ReadThreads(ProcessSP process_sp, addr_t addr) {
+  StructuredData::ArraySP threads(new StructuredData::Array());
+
+  int ptr_size = process_sp->GetAddressByteSize();
+  Target &target = process_sp->GetTarget();
+
+  Status read_error;
+
+  uint64_t num_extra_threads =
+      process_sp->ReadUnsignedIntegerFromMemory(addr, ptr_size, 0, read_error);
+  if (num_extra_threads > 16)
+    num_extra_threads = 16;
+  addr_t threads_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+      addr + ptr_size, ptr_size, 0, read_error);
+  for (int i = 0; i < num_extra_threads; i++) {
+    StructuredData::ArraySP trace(new StructuredData::Array());
+    int thread_struct_stride = 3 * ptr_size + 8;
+    addr_t thread_ptr = threads_ptr + i * thread_struct_stride;
+    std::string thread_description = "";
+    addr_t description_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+        thread_ptr, ptr_size, 0, read_error);
+    if (description_ptr)
+      target.ReadCStringFromMemory(description_ptr, thread_description,
+                                   read_error);
+    // TODO
+    // uint64_t thread_id =
+    // process_sp->ReadUnsignedIntegerFromMemory(thread_ptr + ptr_size,
+    // ptr_size, 0, read_error);
+    uint64_t num_frames = process_sp->ReadUnsignedIntegerFromMemory(
+        thread_ptr + 8 + ptr_size, ptr_size, 0, read_error);
+    if (num_frames > 256)
+      num_frames = 256;
+    addr_t frames_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+        thread_ptr + 8 + 2 * ptr_size, ptr_size, 0, read_error);
+    for (int j = 0; j < num_frames; j++) {
+      addr_t frame = process_sp->ReadUnsignedIntegerFromMemory(
+          frames_ptr + j * ptr_size, ptr_size, 0, read_error);
+      trace->AddItem(
+          StructuredData::ObjectSP(new StructuredData::Integer(frame)));
+    }
+    StructuredData::DictionarySP thread(new StructuredData::Dictionary());
+    thread->AddItem("trace", StructuredData::ObjectSP(trace));
+    thread->AddIntegerItem("tid", 0 /* FIXME, TODO */);
+    thread->AddStringItem("description", thread_description);
+    threads->AddItem(StructuredData::ObjectSP(thread));
+  }
+
+  return threads;
+}
+
+static StructuredData::ArraySP ReadFixits(ProcessSP process_sp, addr_t addr) {
+  StructuredData::ArraySP fixits(new StructuredData::Array());
+
+  int ptr_size = process_sp->GetAddressByteSize();
+  Target &target = process_sp->GetTarget();
+
+  Status read_error;
+  uint64_t num_fixits =
+      process_sp->ReadUnsignedIntegerFromMemory(addr, ptr_size, 0, read_error);
+  if (num_fixits > 16)
+    num_fixits = 16;
+  addr_t fixits_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+      addr + ptr_size, ptr_size, 0, read_error);
+  for (int i = 0; i < num_fixits; i++) {
+    int fixit_struct_stride = 6 * ptr_size;
+    addr_t fixit_ptr = fixits_ptr + i * fixit_struct_stride;
+
+    std::string fixit_filename;
+    addr_t description_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+        fixit_ptr, ptr_size, 0, read_error);
+    if (description_ptr)
+      target.ReadCStringFromMemory(description_ptr, fixit_filename, read_error);
+
+    uint64_t start_line = process_sp->ReadUnsignedIntegerFromMemory(
+        fixit_ptr + 1 * ptr_size, ptr_size, 0, read_error);
+    uint64_t start_col = process_sp->ReadUnsignedIntegerFromMemory(
+        fixit_ptr + 2 * ptr_size, ptr_size, 0, read_error);
+    uint64_t end_line = process_sp->ReadUnsignedIntegerFromMemory(
+        fixit_ptr + 3 * ptr_size, ptr_size, 0, read_error);
+    uint64_t end_col = process_sp->ReadUnsignedIntegerFromMemory(
+        fixit_ptr + 4 * ptr_size, ptr_size, 0, read_error);
+
+    std::string fixit_replacement;
+    addr_t replacement_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+        fixit_ptr + 5 * ptr_size, ptr_size, 0, read_error);
+    if (replacement_ptr)
+      target.ReadCStringFromMemory(replacement_ptr, fixit_replacement,
+                                   read_error);
+
+    StructuredData::DictionarySP fixit(new StructuredData::Dictionary());
+    fixit->AddStringItem("filename", fixit_filename);
+    fixit->AddIntegerItem("start_line", start_line);
+    fixit->AddIntegerItem("start_col", start_col);
+    fixit->AddIntegerItem("end_line", end_line);
+    fixit->AddIntegerItem("end_col", end_col);
+    fixit->AddStringItem("replacement", fixit_replacement);
+    fixits->AddItem(fixit);
+  }
+
+  return fixits;
+}
+
+static StructuredData::ArraySP ReadNotes(ProcessSP process_sp, addr_t addr) {
+  StructuredData::ArraySP notes(new StructuredData::Array());
+
+  int ptr_size = process_sp->GetAddressByteSize();
+  Target &target = process_sp->GetTarget();
+
+  Status read_error;
+  uint64_t num_notes =
+      process_sp->ReadUnsignedIntegerFromMemory(addr, ptr_size, 0, read_error);
+  if (num_notes > 16)
+    num_notes = 16;
+  addr_t fixits_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+      addr + ptr_size, ptr_size, 0, read_error);
+  for (int i = 0; i < num_notes; i++) {
+    int note_struct_stride = 3 * ptr_size;
+    addr_t note_ptr = fixits_ptr + i * note_struct_stride;
+
+    std::string note_description;
+    addr_t description_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+        note_ptr, ptr_size, 0, read_error);
+    if (description_ptr)
+      target.ReadCStringFromMemory(description_ptr, note_description,
+                                   read_error);
+
+    auto fixits = ReadFixits(process_sp, note_ptr + ptr_size);
+
+    StructuredData::DictionarySP note(new StructuredData::Dictionary());
+    note->AddStringItem("description", note_description);
+    note->AddItem("fixits", fixits);
+    notes->AddItem(note);
+  }
+
+  return notes;
+}
+
+StructuredData::ObjectSP
+SwiftRuntimeReporting::RetrieveReportData(ExecutionContextRef exe_ctx_ref) {
+  ProcessSP process_sp = GetProcessSP();
+  if (!process_sp)
+    return StructuredData::ObjectSP();
+
+  ThreadSP thread_sp = exe_ctx_ref.GetThreadSP();
+  StackFrameSP frame_sp = thread_sp->GetSelectedFrame();
+  ModuleSP runtime_module_sp = GetRuntimeModuleSP();
+  Target &target = process_sp->GetTarget();
+
+  const lldb::ABISP &abi = process_sp->GetABI();
+  if (!abi)
+    return StructuredData::ObjectSP();
+
+  // Prepare the argument types: treat all of them as pointers
+  ClangASTContext *clang_ast_context = target.GetScratchClangASTContext();
+  ValueList args;
+  Value input_value;
+  input_value.SetCompilerType(
+      clang_ast_context->GetBasicType(eBasicTypeVoid).GetPointerType());
+  args.PushValue(input_value);
+  args.PushValue(input_value);
+  args.PushValue(input_value);
+
+  if (!abi->GetArgumentValues(*thread_sp, args))
+    return StructuredData::ObjectSP();
+
+  bool is_fatal = (args.GetValueAtIndex(0)->GetScalar().UInt() & 0xff) == 1;
+  addr_t message_ptr = args.GetValueAtIndex(1)->GetScalar().ULongLong();
+  addr_t details_ptr = args.GetValueAtIndex(2)->GetScalar().ULongLong();
+
+  std::string error_type = "";
+  std::string current_stack_description = "";
+  addr_t memory_address = 0;
+  uint64_t frames_to_skip = 0;
+
+  StructuredData::ArraySP extra_threads(new StructuredData::Array());
+  StructuredData::ArraySP fixits(new StructuredData::Array());
+  StructuredData::ArraySP notes(new StructuredData::Array());
+
+  Status read_error;
+  int ptr_size = process_sp->GetAddressByteSize();
+  uint64_t version = process_sp->ReadUnsignedIntegerFromMemory(
+      details_ptr, ptr_size, 0, read_error);
+  if (version == 1 || version == 2) {
+    addr_t error_type_ptr = process_sp->ReadUnsignedIntegerFromMemory(
+        details_ptr + ptr_size, ptr_size, 0, read_error);
+    if (error_type_ptr)
+      target.ReadCStringFromMemory(error_type_ptr, error_type, read_error);
+
+    addr_t current_stack_description_ptr =
+        process_sp->ReadUnsignedIntegerFromMemory(details_ptr + 2 * ptr_size,
+                                                  ptr_size, 0, read_error);
+    if (current_stack_description_ptr)
+      target.ReadCStringFromMemory(current_stack_description_ptr,
+                                   current_stack_description, read_error);
+
+    frames_to_skip = process_sp->ReadUnsignedIntegerFromMemory(
+        details_ptr + 3 * ptr_size, ptr_size, 0, read_error);
+
+    memory_address = process_sp->ReadUnsignedIntegerFromMemory(
+        details_ptr + 4 * ptr_size, ptr_size, 0, read_error);
+
+    extra_threads = ReadThreads(process_sp, details_ptr + 5 * ptr_size);
+
+    if (version == 2) {
+      fixits = ReadFixits(process_sp, details_ptr + 7 * ptr_size);
+      notes = ReadNotes(process_sp, details_ptr + 9 * ptr_size);
+    }
+  }
+
+  // Gather the PCs of the user frames in the backtrace.
+  StructuredData::ArraySP trace(new StructuredData::Array());
+  for (unsigned I = 0; I < thread_sp->GetStackFrameCount(); ++I) {
+    StackFrameSP frame = thread_sp->GetStackFrameAtIndex(I);
+    Address addr = frame->GetFrameCodeAddress();
+
+    if (I < frames_to_skip + 1)
+      continue;
+
+    // Decrement return address above the 0th frame to get correct symbol/source
+    // line.
+    if (I != 0 && trace->GetSize() == 0) {
+      addr.Slide(-1);
+    }
+
+    addr_t PC = addr.GetLoadAddress(&target);
+    trace->AddItem(StructuredData::ObjectSP(new StructuredData::Integer(PC)));
+  }
+
+  StructuredData::ArraySP threads(new StructuredData::Array());
+
+  StructuredData::DictionarySP thread(new StructuredData::Dictionary());
+  thread->AddItem("trace", trace);
+  thread->AddStringItem("description", current_stack_description);
+  thread->AddIntegerItem("tid", thread_sp->GetIndexID());
+  threads->AddItem(thread);
+  for (int i = 0; i < extra_threads->GetSize(); i++) {
+    threads->AddItem(extra_threads->GetItemAtIndex(i));
+  }
+
+  std::string message = "";
+  target.ReadCStringFromMemory(message_ptr, message, read_error);
+  if (read_error.Fail())
+    return StructuredData::ObjectSP();
+
+  // Trim the string.
+  size_t first = message.find_first_not_of(" \t\n");
+  size_t last = message.find_last_not_of(" \t\n");
+  message = message.substr(first, (last - first + 1));
+
+  StructuredData::DictionarySP d(new StructuredData::Dictionary());
+  d->AddStringItem("instrumentation_class", "SwiftRuntimeReporting");
+  d->AddStringItem("description", message);
+  d->AddStringItem("issue_type", error_type);
+  d->AddIntegerItem("memory_address", memory_address);
+  d->AddBooleanItem("is_fatal", is_fatal);
+  d->AddItem("threads", threads);
+  d->AddItem("fixits", fixits);
+  d->AddItem("notes", notes);
+  return d;
+}
+
+bool SwiftRuntimeReporting::NotifyBreakpointHit(
+    void *baton, StoppointCallbackContext *context, user_id_t break_id,
+    user_id_t break_loc_id) {
+  assert(baton && "null baton");
+  if (!baton)
+    return false; //< false => resume execution.
+
+  SwiftRuntimeReporting *const instance =
+      static_cast<SwiftRuntimeReporting *>(baton);
+
+  ProcessSP process_sp = instance->GetProcessSP();
+  ThreadSP thread_sp = context->exe_ctx_ref.GetThreadSP();
+  if (!process_sp || !thread_sp ||
+      process_sp != context->exe_ctx_ref.GetProcessSP())
+    return false;
+
+  if (process_sp->GetModIDRef().IsLastResumeForUserExpression())
+    return false;
+
+  StructuredData::ObjectSP report =
+      instance->RetrieveReportData(context->exe_ctx_ref);
+
+  if (report) {
+    std::string description = report->GetAsDictionary()
+                                  ->GetValueForKey("description")
+                                  ->GetAsString()
+                                  ->GetValue();
+    thread_sp->SetStopInfo(
+        InstrumentationRuntimeStopInfo::CreateStopReasonWithInstrumentationData(
+            *thread_sp, description, report));
+    return true;
+  }
+
+  return false;
+}
+
+void SwiftRuntimeReporting::Activate() {
+  if (IsActive())
+    return;
+
+  ProcessSP process_sp = GetProcessSP();
+  if (!process_sp)
+    return;
+
+  ModuleSP runtime_module_sp = GetRuntimeModuleSP();
+
+  ConstString symbol_name("_swift_runtime_on_report");
+  const Symbol *symbol = runtime_module_sp->FindFirstSymbolWithNameAndType(
+      symbol_name, eSymbolTypeCode);
+
+  if (symbol == nullptr)
+    return;
+
+  if (!symbol->ValueIsAddress() || !symbol->GetAddressRef().IsValid())
+    return;
+
+  Target &target = process_sp->GetTarget();
+  addr_t symbol_address = symbol->GetAddressRef().GetOpcodeLoadAddress(&target);
+
+  if (symbol_address == LLDB_INVALID_ADDRESS)
+    return;
+
+  Breakpoint *breakpoint =
+      process_sp->GetTarget()
+          .CreateBreakpoint(symbol_address, /*internal=*/true,
+                            /*hardware=*/false)
+          .get();
+  breakpoint->SetCallback(SwiftRuntimeReporting::NotifyBreakpointHit, this,
+                          true);
+  breakpoint->SetBreakpointKind("swift-language-runtime-report");
+  SetBreakpointID(breakpoint->GetID());
+
+  SetActive(true);
+}
+
+void SwiftRuntimeReporting::Deactivate() {
+  SetActive(false);
+
+  auto BID = GetBreakpointID();
+  if (BID == LLDB_INVALID_BREAK_ID)
+    return;
+
+  if (ProcessSP process_sp = GetProcessSP()) {
+    process_sp->GetTarget().RemoveBreakpointByID(BID);
+    SetBreakpointID(LLDB_INVALID_BREAK_ID);
+  }
+}
+
+lldb::ThreadCollectionSP
+SwiftRuntimeReporting::GetBacktracesFromExtendedStopInfo(
+    StructuredData::ObjectSP info) {
+  ThreadCollectionSP result;
+  result.reset(new ThreadCollection());
+
+  ProcessSP process_sp = GetProcessSP();
+
+  if (info->GetObjectForDotSeparatedPath("instrumentation_class")
+          ->GetStringValue() != "SwiftRuntimeReporting")
+    return result;
+
+  auto threads = info->GetObjectForDotSeparatedPath("threads")->GetAsArray();
+  threads->ForEach([process_sp,
+                    result](StructuredData::Object *thread) -> bool {
+    std::vector<lldb::addr_t> PCs;
+    auto trace = thread->GetObjectForDotSeparatedPath("trace")->GetAsArray();
+    trace->ForEach([&PCs](StructuredData::Object *PC) -> bool {
+      PCs.push_back(PC->GetAsInteger()->GetValue());
+      return true;
+    });
+
+    if (PCs.empty())
+      return true;
+
+    StructuredData::ObjectSP thread_id_obj =
+        thread->GetObjectForDotSeparatedPath("tid");
+    tid_t tid = thread_id_obj ? thread_id_obj->GetIntegerValue() : 0;
+
+    uint32_t stop_id = 0;
+    bool stop_id_is_valid = false;
+    HistoryThread *history_thread =
+        new HistoryThread(*process_sp, tid, PCs, stop_id, stop_id_is_valid);
+    ThreadSP new_thread_sp(history_thread);
+
+    StructuredData::ObjectSP description =
+        thread->GetObjectForDotSeparatedPath("description");
+    if (description)
+      history_thread->SetName(description->GetStringValue().data());
+
+    // Save this in the Process' ExtendedThreadList so a strong pointer
+    // retains the object
+    process_sp->GetExtendedThreadList().AddThread(new_thread_sp);
+    result->AddThread(new_thread_sp);
+
+    return true;
+  });
+
+  return result;
+}
diff --git a/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.h b/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.h
index e69de29bb..710a631b7 100644
--- a/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.h
+++ b/source/Plugins/InstrumentationRuntime/SwiftRuntimeReporting/SwiftRuntimeReporting.h
@@ -0,0 +1,68 @@
+//===-- SwiftRuntimeReporting.h ---------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftRuntimeReporting_h_
+#define liblldb_SwiftRuntimeReporting_h_
+
+#include "lldb/Target/ABI.h"
+#include "lldb/Target/InstrumentationRuntime.h"
+#include "lldb/Utility/StructuredData.h"
+#include "lldb/lldb-private.h"
+
+namespace lldb_private {
+
+class SwiftRuntimeReporting : public lldb_private::InstrumentationRuntime {
+public:
+  ~SwiftRuntimeReporting() override;
+
+  static lldb::InstrumentationRuntimeSP
+  CreateInstance(const lldb::ProcessSP &process_sp);
+
+  static void Initialize();
+
+  static void Terminate();
+
+  static lldb_private::ConstString GetPluginNameStatic();
+
+  static lldb::InstrumentationRuntimeType GetTypeStatic();
+
+  lldb_private::ConstString GetPluginName() override {
+    return GetPluginNameStatic();
+  }
+
+  virtual lldb::InstrumentationRuntimeType GetType() { return GetTypeStatic(); }
+
+  uint32_t GetPluginVersion() override { return 1; }
+
+  lldb::ThreadCollectionSP
+  GetBacktracesFromExtendedStopInfo(StructuredData::ObjectSP info) override;
+
+private:
+  SwiftRuntimeReporting(const lldb::ProcessSP &process_sp)
+      : lldb_private::InstrumentationRuntime(process_sp) {}
+
+  const RegularExpression &GetPatternForRuntimeLibrary() override;
+
+  bool CheckIfRuntimeIsValid(const lldb::ModuleSP module_sp) override;
+
+  void Activate() override;
+
+  void Deactivate();
+
+  static bool NotifyBreakpointHit(void *baton,
+                                  StoppointCallbackContext *context,
+                                  lldb::user_id_t break_id,
+                                  lldb::user_id_t break_loc_id);
+
+  StructuredData::ObjectSP RetrieveReportData(ExecutionContextRef exe_ctx_ref);
+};
+
+} // namespace lldb_private
+
+#endif // liblldb_SwiftRuntimeReporting_h_
diff --git a/source/Plugins/Language/CMakeLists.txt b/source/Plugins/Language/CMakeLists.txt
index 4b92a8ef8..b4ba88081 100644
--- a/source/Plugins/Language/CMakeLists.txt
+++ b/source/Plugins/Language/CMakeLists.txt
@@ -4,3 +4,4 @@ add_subdirectory(Java)
 add_subdirectory(ObjC)
 add_subdirectory(ObjCPlusPlus)
 add_subdirectory(OCaml)
+add_subdirectory(Swift)
diff --git a/source/Plugins/Language/CPlusPlus/CPlusPlusLanguage.cpp b/source/Plugins/Language/CPlusPlus/CPlusPlusLanguage.cpp
index 1ae9418e4..40527d729 100644
--- a/source/Plugins/Language/CPlusPlus/CPlusPlusLanguage.cpp
+++ b/source/Plugins/Language/CPlusPlus/CPlusPlusLanguage.cpp
@@ -916,9 +916,8 @@ CPlusPlusLanguage::GetHardcodedSynthetics() {
 
   llvm::call_once(g_initialize, []() -> void {
     g_formatters.push_back([](lldb_private::ValueObject &valobj,
-                              lldb::DynamicValueType,
-                              FormatManager &
-                                  fmt_mgr) -> SyntheticChildren::SharedPointer {
+                              lldb::DynamicValueType, FormatManager &fmt_mgr)
+                               -> SyntheticChildren::SharedPointer {
       static CXXSyntheticChildren::SharedPointer formatter_sp(
           new CXXSyntheticChildren(
               SyntheticChildren::Flags()
@@ -935,9 +934,8 @@ CPlusPlusLanguage::GetHardcodedSynthetics() {
       return nullptr;
     });
     g_formatters.push_back([](lldb_private::ValueObject &valobj,
-                              lldb::DynamicValueType,
-                              FormatManager &
-                                  fmt_mgr) -> SyntheticChildren::SharedPointer {
+                              lldb::DynamicValueType, FormatManager &fmt_mgr)
+                               -> SyntheticChildren::SharedPointer {
       static CXXSyntheticChildren::SharedPointer formatter_sp(
           new CXXSyntheticChildren(
               SyntheticChildren::Flags()
diff --git a/source/Plugins/Language/ObjC/CMakeLists.txt b/source/Plugins/Language/ObjC/CMakeLists.txt
index 7cc93c7b0..8aa2a6c02 100644
--- a/source/Plugins/Language/ObjC/CMakeLists.txt
+++ b/source/Plugins/Language/ObjC/CMakeLists.txt
@@ -21,4 +21,5 @@ add_lldb_library(lldbPluginObjCLanguage PLUGIN
     lldbTarget
     lldbUtility
     lldbPluginAppleObjCRuntime
+    lldbPluginSwiftLanguage
 )
diff --git a/source/Plugins/Language/ObjC/Cocoa.cpp b/source/Plugins/Language/ObjC/Cocoa.cpp
index 8f4997533..1a024e875 100644
--- a/source/Plugins/Language/ObjC/Cocoa.cpp
+++ b/source/Plugins/Language/ObjC/Cocoa.cpp
@@ -33,6 +33,8 @@
 
 #include "llvm/ADT/APInt.h"
 
+#include "llvm/ADT/APInt.h"
+
 #include "Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.h"
 
 #include "NSString.h"
@@ -41,6 +43,15 @@ using namespace lldb;
 using namespace lldb_private;
 using namespace lldb_private::formatters;
 
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+bool NSContiguousString_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                        const TypeSummaryOptions &options);
+}
+}
+}
+
 bool lldb_private::formatters::NSBundleSummaryProvider(
     ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
   ProcessSP process_sp = valobj.GetProcessSP();
diff --git a/source/Plugins/Language/ObjC/Cocoa.h b/source/Plugins/Language/ObjC/Cocoa.h
index 10ff3bce3..32f7252e7 100644
--- a/source/Plugins/Language/ObjC/Cocoa.h
+++ b/source/Plugins/Language/ObjC/Cocoa.h
@@ -19,6 +19,9 @@
 
 namespace lldb_private {
 namespace formatters {
+bool NSStringSummaryProvider(ValueObject &valobj, Stream &stream,
+                             const TypeSummaryOptions &options);
+
 bool NSIndexSetSummaryProvider(ValueObject &valobj, Stream &stream,
                                const TypeSummaryOptions &options);
 
diff --git a/source/Plugins/Language/ObjC/NSArray.cpp b/source/Plugins/Language/ObjC/NSArray.cpp
index 27cb9558c..689b33325 100644
--- a/source/Plugins/Language/ObjC/NSArray.cpp
+++ b/source/Plugins/Language/ObjC/NSArray.cpp
@@ -362,6 +362,18 @@ bool lldb_private::formatters::NSArraySummaryProvider(
                                                       ptr_size, 0, error);
     if (error.Fail())
       return false;
+  } else if (class_name == g_NSArrayMLegacy) {
+    Status error;
+    value = process_sp->ReadUnsignedIntegerFromMemory(valobj_addr + ptr_size,
+                                                      ptr_size, 0, error);
+    if (error.Fail())
+      return false;
+  } else if (class_name == g_NSArrayMImmutable) {
+    Status error;
+    value = process_sp->ReadUnsignedIntegerFromMemory(valobj_addr + ptr_size,
+                                                      ptr_size, 0, error);
+    if (error.Fail())
+      return false;
   } else if (class_name == g_NSArray0) {
     value = 0;
   } else if (class_name == g_NSArray1) {
@@ -917,7 +929,7 @@ lldb_private::formatters::NSArraySyntheticFrontEndCreator(
   CompilerType valobj_type(valobj_sp->GetCompilerType());
   Flags flags(valobj_type.GetTypeInfo());
 
-  if (flags.IsClear(eTypeIsPointer)) {
+  if (flags.IsClear(eTypeIsPointer) && flags.IsClear(eTypeIsSwift)) {
     Status error;
     valobj_sp = valobj_sp->AddressOf(error);
     if (error.Fail() || !valobj_sp)
diff --git a/source/Plugins/Language/ObjC/NSDictionary.cpp b/source/Plugins/Language/ObjC/NSDictionary.cpp
index 50febbe39..b7c4303e7 100644
--- a/source/Plugins/Language/ObjC/NSDictionary.cpp
+++ b/source/Plugins/Language/ObjC/NSDictionary.cpp
@@ -32,6 +32,13 @@
 #include "lldb/Utility/Status.h"
 #include "lldb/Utility/Stream.h"
 
+#include "clang/AST/DeclCXX.h"
+
+// FIXME: we should not need this
+#include "Plugins/Language/Swift/SwiftDictionary.h"
+#include "Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.h"
+#include <mutex>
+
 using namespace lldb;
 using namespace lldb_private;
 using namespace lldb_private::formatters;
@@ -369,7 +376,7 @@ lldb_private::formatters::NSDictionarySyntheticFrontEndCreator(
   CompilerType valobj_type(valobj_sp->GetCompilerType());
   Flags flags(valobj_type.GetTypeInfo());
 
-  if (flags.IsClear(eTypeIsPointer)) {
+  if (flags.IsClear(eTypeIsPointer) && flags.IsClear(eTypeIsSwift)) {
     Status error;
     valobj_sp = valobj_sp->AddressOf(error);
     if (error.Fail() || !valobj_sp)
diff --git a/source/Plugins/Language/ObjC/NSSet.cpp b/source/Plugins/Language/ObjC/NSSet.cpp
index 2f3398775..91ab586ff 100644
--- a/source/Plugins/Language/ObjC/NSSet.cpp
+++ b/source/Plugins/Language/ObjC/NSSet.cpp
@@ -288,7 +288,7 @@ lldb_private::formatters::NSSetSyntheticFrontEndCreator(
   CompilerType valobj_type(valobj_sp->GetCompilerType());
   Flags flags(valobj_type.GetTypeInfo());
 
-  if (flags.IsClear(eTypeIsPointer)) {
+  if (flags.IsClear(eTypeIsPointer) && flags.IsClear(eTypeIsSwift)) {
     Status error;
     valobj_sp = valobj_sp->AddressOf(error);
     if (error.Fail() || !valobj_sp)
diff --git a/source/Plugins/Language/ObjC/ObjCLanguage.cpp b/source/Plugins/Language/ObjC/ObjCLanguage.cpp
index ea2eec7b3..fafd15074 100644
--- a/source/Plugins/Language/ObjC/ObjCLanguage.cpp
+++ b/source/Plugins/Language/ObjC/ObjCLanguage.cpp
@@ -746,6 +746,11 @@ static void LoadObjCFormatters(TypeCategoryImplSP objc_category_sp) {
                 "NSNotification summary provider",
                 ConstString("NSConcreteNotification"), appkit_flags);
 
+  // AddStringSummary(objc_category_sp, "domain: ${var._domain} - code:
+  // ${var._code}", ConstString("NSError"), appkit_flags);
+  // AddStringSummary(objc_category_sp,"name:${var.name%S}
+  // reason:${var.reason%S}",ConstString("NSException"),appkit_flags);
+
   AddCXXSummary(
       objc_category_sp, lldb_private::formatters::NSNumberSummaryProvider,
       "NSNumber summary provider", ConstString("NSNumber"), appkit_flags);
@@ -884,8 +889,9 @@ ObjCLanguage::GetPossibleFormattersMatches(ValueObject &valobj,
 
   const bool check_cpp = false;
   const bool check_objc = true;
-  bool canBeObjCDynamic =
-      compiler_type.IsPossibleDynamicType(nullptr, check_cpp, check_objc);
+  const bool check_swift = false;
+  bool canBeObjCDynamic = compiler_type.IsPossibleDynamicType(
+      nullptr, check_cpp, check_objc, check_swift);
 
   if (canBeObjCDynamic) {
     do {
diff --git a/source/Plugins/Language/Swift/CMakeLists.txt b/source/Plugins/Language/Swift/CMakeLists.txt
index e69de29bb..b799cd87d 100644
--- a/source/Plugins/Language/Swift/CMakeLists.txt
+++ b/source/Plugins/Language/Swift/CMakeLists.txt
@@ -0,0 +1,29 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginSwiftLanguage PLUGIN
+  FoundationValueTypes.cpp
+  ObjCRuntimeSyntheticProvider.cpp
+  SwiftArray.cpp
+  SwiftBasicTypes.cpp
+  SwiftDictionary.cpp
+  SwiftFormatters.cpp
+  SwiftHashedContainer.cpp
+  SwiftLanguage.cpp
+  SwiftMetatype.cpp
+  SwiftOptionSet.cpp
+  SwiftOptional.cpp
+  SwiftSet.cpp
+
+  LINK_LIBS
+    lldbCore
+    lldbDataFormatters
+    lldbSymbol
+    lldbTarget
+    lldbUtility
+    lldbPluginObjCLanguage
+    swiftAST
+    swiftClangImporter
+    clangAST
+  LINK_COMPONENTS
+    Support
+)
diff --git a/source/Plugins/Language/Swift/FoundationValueTypes.cpp b/source/Plugins/Language/Swift/FoundationValueTypes.cpp
index e69de29bb..1fead8cd0 100644
--- a/source/Plugins/Language/Swift/FoundationValueTypes.cpp
+++ b/source/Plugins/Language/Swift/FoundationValueTypes.cpp
@@ -0,0 +1,444 @@
+//===-- FoundationValueTypes.cpp --------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "FoundationValueTypes.h"
+#include "ObjCRuntimeSyntheticProvider.h"
+
+#include "lldb/Core/ValueObject.h"
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Target/ObjCLanguageRuntime.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/DataExtractor.h"
+#include "lldb/Utility/Status.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+bool lldb_private::formatters::swift::Date_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__time("_time");
+
+  ValueObjectSP time_sp(valobj.GetChildAtNamePath({g__time}));
+
+  if (!time_sp)
+    return false;
+
+  DataExtractor data_extractor;
+  Status error;
+  if (!time_sp->GetData(data_extractor, error))
+    return false;
+
+  offset_t offset_ptr = 0;
+  double date_value = data_extractor.GetDouble(&offset_ptr);
+
+  if (date_value == -63114076800) {
+    stream.Printf("0001-12-30 00:00:00 +0000");
+    return true;
+  }
+  // this snippet of code assumes that time_t == seconds since Jan-1-1970
+  // this is generally true and POSIXly happy, but might break if a library
+  // vendor decides to get creative
+  time_t epoch = GetOSXEpoch();
+  epoch = epoch + (time_t)date_value;
+  tm *tm_date = gmtime(&epoch);
+  if (!tm_date)
+    return false;
+  std::string buffer(1024, 0);
+  if (strftime(&buffer[0], 1023, "%Z", tm_date) == 0)
+    return false;
+  stream.Printf("%04d-%02d-%02d %02d:%02d:%02d %s", tm_date->tm_year + 1900,
+                tm_date->tm_mon + 1, tm_date->tm_mday, tm_date->tm_hour,
+                tm_date->tm_min, tm_date->tm_sec, buffer.c_str());
+  return true;
+}
+
+bool lldb_private::formatters::swift::NotificationName_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__rawValue("_rawValue");
+
+  ValueObjectSP underlying_name_sp(valobj.GetChildAtNamePath({g__rawValue}));
+
+  if (!underlying_name_sp)
+    return false;
+
+  std::string summary;
+  if (!underlying_name_sp->GetSummaryAsCString(summary, options))
+    return false;
+
+  stream.PutCString(summary.c_str());
+  return true;
+}
+
+bool lldb_private::formatters::swift::URL_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__url("_url");
+
+  ValueObjectSP underlying_url_sp(valobj.GetChildAtNamePath({g__url}));
+
+  if (!underlying_url_sp)
+    return false;
+
+  std::string summary;
+  if (!underlying_url_sp->GetSummaryAsCString(summary, options))
+    return false;
+
+  stream.PutCString(summary.c_str());
+  return true;
+}
+
+bool lldb_private::formatters::swift::IndexPath_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__indexes("_indexes");
+  static ConstString g_empty("empty");
+  static ConstString g_single("single");
+  static ConstString g_pair("pair");
+  static ConstString g_array("array");
+
+  ValueObjectSP underlying_enum_sp(valobj.GetChildAtNamePath({g__indexes}));
+
+  if (!underlying_enum_sp)
+    return false;
+
+  underlying_enum_sp =
+      underlying_enum_sp->GetQualifiedRepresentationIfAvailable(
+          lldb::eDynamicDontRunTarget, true);
+  ConstString value(underlying_enum_sp->GetValueAsCString());
+  if (value.IsEmpty())
+    return false;
+
+  if (value == g_empty)
+    stream.PutCString("0 indices");
+  else if (value == g_single)
+    stream.PutCString("1 index");
+  else if (value == g_pair)
+    stream.PutCString("2 indices");
+  else if (value == g_array) {
+    if (underlying_enum_sp->GetNumChildren() != 1)
+      return false;
+
+    underlying_enum_sp = underlying_enum_sp->GetChildAtIndex(0, true)
+                             ->GetQualifiedRepresentationIfAvailable(
+                                 lldb::eDynamicDontRunTarget, true);
+    size_t num_children = underlying_enum_sp->GetNumChildren();
+    stream.Printf("%zu indices", num_children);
+  }
+  return true;
+}
+
+bool lldb_private::formatters::swift::Measurement_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_value("value");
+  static ConstString g_unit("unit");
+  static ConstString g__symbol("_symbol");
+
+  ValueObjectSP value_sp(valobj.GetChildAtNamePath({g_value}));
+  if (!value_sp)
+    return false;
+
+  ValueObjectSP unit_sp(valobj.GetChildAtNamePath({g_unit}));
+  if (!unit_sp)
+    return false;
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return false;
+
+  auto descriptor_sp(
+      process_sp->GetObjCLanguageRuntime()->GetClassDescriptor(*unit_sp));
+  if (!descriptor_sp)
+    return false;
+
+  if (descriptor_sp->GetNumIVars() == 0)
+    return false;
+
+  auto ivar = descriptor_sp->GetIVarAtIndex(0);
+  if (!ivar.m_type.IsValid())
+    return false;
+
+  ValueObjectSP symbol_sp(
+      unit_sp->GetSyntheticChildAtOffset(ivar.m_offset, ivar.m_type, true));
+  if (!symbol_sp)
+    return false;
+
+  symbol_sp = symbol_sp->GetQualifiedRepresentationIfAvailable(
+      lldb::eDynamicDontRunTarget, true);
+
+  DataExtractor data_extractor;
+  Status error;
+  if (!value_sp->GetData(data_extractor, error))
+    return false;
+
+  offset_t offset_ptr = 0;
+  double measurement_value = data_extractor.GetDouble(&offset_ptr);
+
+  std::string unit;
+  if (!symbol_sp->GetSummaryAsCString(unit, options))
+    return false;
+
+  if (unit.size() > 2 && unit[0] == '"') {
+    unit = unit.substr(1);
+    if (unit.back() == '"')
+      unit.pop_back();
+  }
+
+  stream.Printf("%g %s", measurement_value, unit.c_str());
+  return true;
+}
+
+bool lldb_private::formatters::swift::UUID_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_uuid("uuid");
+
+  ValueObjectSP uuid_sp(valobj.GetChildAtNamePath({g_uuid}));
+  if (!uuid_sp)
+    return false;
+
+  if (uuid_sp->GetNumChildren() < 16)
+    return false;
+
+  ValueObjectSP children[] = {
+      uuid_sp->GetChildAtIndex(0, true),  uuid_sp->GetChildAtIndex(1, true),
+      uuid_sp->GetChildAtIndex(2, true),  uuid_sp->GetChildAtIndex(3, true),
+      uuid_sp->GetChildAtIndex(4, true),  uuid_sp->GetChildAtIndex(5, true),
+      uuid_sp->GetChildAtIndex(6, true),  uuid_sp->GetChildAtIndex(7, true),
+      uuid_sp->GetChildAtIndex(8, true),  uuid_sp->GetChildAtIndex(9, true),
+      uuid_sp->GetChildAtIndex(10, true), uuid_sp->GetChildAtIndex(11, true),
+      uuid_sp->GetChildAtIndex(12, true), uuid_sp->GetChildAtIndex(13, true),
+      uuid_sp->GetChildAtIndex(14, true), uuid_sp->GetChildAtIndex(15, true)};
+
+  for (ValueObjectSP &child : children) {
+    if (!child)
+      return false;
+    child = child->GetQualifiedRepresentationIfAvailable(
+        lldb::eDynamicDontRunTarget, true);
+  }
+
+  const char *separator = "-";
+  stream.Printf("%2.2X%2.2X%2.2X%2.2X%s%2.2X%2.2X%s%2.2X%2.2X%s%2.2X%2.2X%s%2."
+                "2X%2.2X%2.2X%2.2X%2.2X%2.2X",
+                (uint8_t)children[0]->GetValueAsUnsigned(0),
+                (uint8_t)children[1]->GetValueAsUnsigned(0),
+                (uint8_t)children[2]->GetValueAsUnsigned(0),
+                (uint8_t)children[3]->GetValueAsUnsigned(0), separator,
+                (uint8_t)children[4]->GetValueAsUnsigned(0),
+                (uint8_t)children[5]->GetValueAsUnsigned(0), separator,
+                (uint8_t)children[6]->GetValueAsUnsigned(0),
+                (uint8_t)children[7]->GetValueAsUnsigned(0), separator,
+                (uint8_t)children[8]->GetValueAsUnsigned(0),
+                (uint8_t)children[9]->GetValueAsUnsigned(0), separator,
+                (uint8_t)children[10]->GetValueAsUnsigned(0),
+                (uint8_t)children[11]->GetValueAsUnsigned(0),
+                (uint8_t)children[12]->GetValueAsUnsigned(0),
+                (uint8_t)children[13]->GetValueAsUnsigned(0),
+                (uint8_t)children[14]->GetValueAsUnsigned(0),
+                (uint8_t)children[15]->GetValueAsUnsigned(0));
+
+  return true;
+}
+
+bool lldb_private::formatters::swift::Data_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__wrapped("_wrapped");
+  static ConstString g___wrapped("__wrapped");
+  static ConstString g_Immutable("Immutable");
+  static ConstString g_Mutable("Mutable");
+  static ConstString g__value("_value");
+
+  ValueObjectSP selected_case_sp =
+      valobj.GetChildAtNamePath({g__wrapped, g___wrapped});
+  if (!selected_case_sp)
+    return false;
+
+  ConstString selected_case(selected_case_sp->GetValueAsCString());
+  if (selected_case == g_Immutable) {
+    if (ValueObjectSP immutable_sp =
+            selected_case_sp->GetChildAtNamePath({g_Immutable, g__value})) {
+      std::string summary;
+      if (immutable_sp->GetSummaryAsCString(summary, options)) {
+        stream.Printf("%s", summary.c_str());
+        return true;
+      }
+    }
+  } else if (selected_case == g_Mutable) {
+    if (ValueObjectSP mutable_sp =
+            selected_case_sp->GetChildAtNamePath({g_Mutable, g__value})) {
+      ProcessSP process_sp(valobj.GetProcessSP());
+      if (!process_sp)
+        return false;
+      TargetSP target_sp(valobj.GetTargetSP());
+      if (!target_sp)
+        return false;
+      if (SwiftLanguageRuntime *swift_runtime =
+              valobj.GetProcessSP()->GetSwiftLanguageRuntime()) {
+        lldb::addr_t value =
+            mutable_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+        if (value != LLDB_INVALID_ADDRESS) {
+          value = swift_runtime->MaskMaybeBridgedPointer(value);
+          DataExtractor buffer(&value, process_sp->GetAddressByteSize(),
+                               process_sp->GetByteOrder(),
+                               process_sp->GetAddressByteSize());
+          if (ClangASTContext *clang_ast_ctx =
+                  target_sp->GetScratchClangASTContext()) {
+            if (CompilerType id_type =
+                    clang_ast_ctx->GetBasicType(lldb::eBasicTypeObjCID)) {
+              if (ValueObjectSP nsdata_sp =
+                      ValueObject::CreateValueObjectFromData(
+                          "nsdata", buffer, process_sp, id_type)) {
+                nsdata_sp = nsdata_sp->GetQualifiedRepresentationIfAvailable(
+                    lldb::eDynamicDontRunTarget, false);
+                std::string summary;
+                if (nsdata_sp->GetSummaryAsCString(summary, options)) {
+                  stream.Printf("%s", summary.c_str());
+                  return true;
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+class URLComponentsSyntheticChildrenFrontEnd
+    : public SyntheticChildrenFrontEnd {
+public:
+  URLComponentsSyntheticChildrenFrontEnd(lldb::ValueObjectSP valobj_sp)
+      : SyntheticChildrenFrontEnd(*valobj_sp), m_synth_up(nullptr)
+#define COMPONENT(Name, PrettyName, ID) , m_##Name(nullptr)
+#include "URLComponents.def"
+  {
+    SetValid(false);
+  }
+
+  ~URLComponentsSyntheticChildrenFrontEnd() override = default;
+
+  size_t CalculateNumChildren() override {
+    if (IsValid())
+      return 9;
+    return 0;
+  }
+
+  lldb::ValueObjectSP GetChildAtIndex(size_t idx) override {
+    if (IsValid()) {
+      switch (idx) {
+#define COMPONENT(Name, PrettyName, ID)                                        \
+  case ID:                                                                     \
+    return (m_##Name) ? (m_##Name)->GetSP() : nullptr;
+#include "URLComponents.def"
+      default:
+        break;
+      }
+    }
+
+    return nullptr;
+  }
+
+  bool Update() override {
+    static ConstString g__handle("_handle");
+    static ConstString g__pointer("_pointer");
+
+#define COMPONENT(Name, PrettyName, ID)                                        \
+  static ConstString g__##Name = ConstString("_" #Name);
+#include "URLComponents.def"
+
+    m_synth_up.reset();
+
+#define COMPONENT(Name, PrettyName, ID) m_##Name = nullptr;
+#include "URLComponents.def"
+
+    SetValid(false);
+
+    ValueObjectSP underlying_sp =
+        m_backend.GetChildAtNamePath({g__handle, g__pointer});
+    if (!underlying_sp)
+      return false;
+
+    ObjCLanguageRuntime *objc_runtime =
+        m_backend.GetProcessSP()->GetObjCLanguageRuntime();
+    if (!objc_runtime)
+      return false;
+
+    ObjCLanguageRuntime::ClassDescriptorSP class_descriptor_sp =
+        objc_runtime->GetClassDescriptor(*underlying_sp);
+    if (!class_descriptor_sp)
+      return false;
+
+    m_synth_up = ObjCRuntimeSyntheticProvider(SyntheticChildren::Flags(),
+                                              class_descriptor_sp)
+                     .GetFrontEnd(*underlying_sp);
+    if (!m_synth_up)
+      return false;
+    else
+      m_synth_up->Update();
+
+#define COMPONENT(Name, PrettyName, ID)                                        \
+  m_##Name =                                                                   \
+      m_synth_up                                                               \
+          ->GetChildAtIndex(m_synth_up->GetIndexOfChildWithName(g__##Name))    \
+          .get();                                                              \
+  if (m_##Name)                                                                \
+    m_##Name->SetName(GetNameFor##Name());
+#include "URLComponents.def"
+
+    SetValid(CheckValid());
+
+    return false;
+  }
+
+  bool MightHaveChildren() override { return true; }
+
+  size_t GetIndexOfChildWithName(const ConstString &name) override {
+#define COMPONENT(Name, PrettyName, ID)                                        \
+  if (name == GetNameFor##Name())                                              \
+    return ID;
+#include "URLComponents.def"
+    return UINT32_MAX;
+  }
+
+private:
+#define COMPONENT(Name, PrettyName, ID)                                        \
+  static ConstString GetNameFor##Name() {                                      \
+    static ConstString g_value(#PrettyName);                                   \
+    return g_value;                                                            \
+  }
+#include "URLComponents.def"
+
+  SyntheticChildrenFrontEnd::AutoPointer m_synth_up;
+#define COMPONENT(Name, PrettyName, ID) ValueObject *m_##Name;
+#include "URLComponents.def"
+
+  bool CheckValid() {
+#define COMPONENT(Name, PrettyName, ID)                                        \
+  if (m_##Name == nullptr)                                                     \
+    return false;
+#include "URLComponents.def"
+
+    return true;
+  }
+};
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::URLComponentsSyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return nullptr;
+
+  return new URLComponentsSyntheticChildrenFrontEnd(valobj_sp);
+}
diff --git a/source/Plugins/Language/Swift/FoundationValueTypes.h b/source/Plugins/Language/Swift/FoundationValueTypes.h
index e69de29bb..67d8b0966 100644
--- a/source/Plugins/Language/Swift/FoundationValueTypes.h
+++ b/source/Plugins/Language/Swift/FoundationValueTypes.h
@@ -0,0 +1,56 @@
+//===-- FoundationValueTypes.h ----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_FoundationValueTypes_h_
+#define liblldb_FoundationValueTypes_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "lldb/DataFormatters/FormatClasses.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+bool Date_SummaryProvider(ValueObject &valobj, Stream &stream,
+                          const TypeSummaryOptions &options);
+
+bool NotificationName_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                      const TypeSummaryOptions &options);
+
+bool URL_SummaryProvider(ValueObject &valobj, Stream &stream,
+                         const TypeSummaryOptions &options);
+
+bool IndexPath_SummaryProvider(ValueObject &valobj, Stream &stream,
+                               const TypeSummaryOptions &options);
+
+bool Measurement_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                 const TypeSummaryOptions &options);
+
+bool UUID_SummaryProvider(ValueObject &valobj, Stream &stream,
+                          const TypeSummaryOptions &options);
+
+bool Data_SummaryProvider(ValueObject &valobj, Stream &stream,
+                          const TypeSummaryOptions &options);
+
+SyntheticChildrenFrontEnd *
+URLComponentsSyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                      lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_FoundationValueTypes_h_
diff --git a/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.cpp b/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.cpp
index e69de29bb..fcbbeb1ce 100644
--- a/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.cpp
+++ b/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.cpp
@@ -0,0 +1,122 @@
+//===-- ObjCRuntimeSyntheticProvider.cpp ------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "ObjCRuntimeSyntheticProvider.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/DeclVendor.h"
+
+#include "lldb/lldb-public.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+std::string ObjCRuntimeSyntheticProvider::GetDescription() {
+  StreamString sstr;
+  sstr.Printf("%s%s%s Runtime-generated synthetic provider for %s {\n",
+              Cascades() ? "" : " (not cascading)",
+              SkipsPointers() ? " (skip pointers)" : "",
+              SkipsReferences() ? " (skip references)" : "",
+              m_descriptor_sp->GetClassName().AsCString("<unknown>"));
+
+  return sstr.GetString();
+}
+
+size_t ObjCRuntimeSyntheticProvider::FrontEnd::GetNumBases() {
+  return m_provider->m_descriptor_sp->GetSuperclass().get() ? 1 : 0;
+}
+
+size_t ObjCRuntimeSyntheticProvider::FrontEnd::CalculateNumChildren() {
+  size_t ivars = m_provider->GetNumIVars();
+  size_t bases = GetNumBases();
+  return bases + ivars;
+}
+
+static lldb::ValueObjectSP GetSuitableRootObject(ValueObjectSP valobj_sp) {
+  if (valobj_sp) {
+    if (!valobj_sp->GetParent())
+      return valobj_sp;
+    if (valobj_sp->IsBaseClass()) {
+      if (valobj_sp->GetParent()->IsBaseClass())
+        return GetSuitableRootObject(valobj_sp->GetParent()->GetSP());
+      return valobj_sp;
+    }
+  }
+  return valobj_sp;
+}
+
+ObjCRuntimeSyntheticProvider::FrontEnd::FrontEnd(
+    ObjCRuntimeSyntheticProvider *prv, ValueObject &backend)
+    : SyntheticChildrenFrontEnd(backend), m_provider(prv),
+      m_root_sp(::GetSuitableRootObject(backend.GetSP())) {}
+
+lldb::ValueObjectSP
+ObjCRuntimeSyntheticProvider::FrontEnd::GetChildAtIndex(size_t idx) {
+  lldb::ValueObjectSP child_sp(nullptr);
+  if (idx < CalculateNumChildren()) {
+    if (GetNumBases() == 1) {
+      if (idx == 0) {
+        do {
+          ProcessSP process_sp(m_backend.GetProcessSP());
+          if (!process_sp)
+            break;
+          ObjCLanguageRuntime *runtime = process_sp->GetObjCLanguageRuntime();
+          if (!runtime)
+            break;
+          DeclVendor *vendor = runtime->GetDeclVendor();
+          if (!vendor)
+            break;
+          std::vector<clang::NamedDecl *> decls;
+          auto descriptor_sp(m_provider->m_descriptor_sp);
+          if (!descriptor_sp)
+            break;
+          descriptor_sp = descriptor_sp->GetSuperclass();
+          if (!descriptor_sp)
+            break;
+          const bool append = false;
+          const uint32_t max = 1;
+          if (0 == vendor->FindDecls(descriptor_sp->GetClassName(), append, max,
+                                     decls))
+            break;
+          const uint32_t offset = 0;
+          const bool can_create = true;
+          if (decls.empty())
+            break;
+          CompilerType type = ClangASTContext::GetTypeForDecl(decls[0]);
+          if (!type.IsValid())
+            break;
+          child_sp = m_backend.GetSyntheticBase(offset, type, can_create);
+        } while (false);
+        return child_sp;
+      } else
+        --idx;
+    }
+    if (m_root_sp) {
+      const auto &ivar_info(m_provider->GetIVarAtIndex(idx));
+      const bool can_create = true;
+      child_sp = m_root_sp->GetSyntheticChildAtOffset(
+          ivar_info.m_offset, ivar_info.m_type, can_create);
+      if (child_sp)
+        child_sp->SetName(ivar_info.m_name);
+    }
+  }
+  return child_sp;
+}
+
+size_t ObjCRuntimeSyntheticProvider::FrontEnd::GetIndexOfChildWithName(
+    const ConstString &name) {
+  for (size_t idx = 0; idx < CalculateNumChildren(); idx++) {
+    const auto &ivar_info(m_provider->GetIVarAtIndex(idx));
+    if (name == ivar_info.m_name)
+      return idx + GetNumBases();
+  }
+  return UINT32_MAX;
+}
diff --git a/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.h b/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.h
index e69de29bb..7e8b777fc 100644
--- a/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.h
+++ b/source/Plugins/Language/Swift/ObjCRuntimeSyntheticProvider.h
@@ -0,0 +1,82 @@
+//===-- ObjCRuntimeSyntheticProvider.h --------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef lldb_ObjCRuntimeSyntheticProvider_h
+#define lldb_ObjCRuntimeSyntheticProvider_h
+
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/Target/ObjCLanguageRuntime.h"
+
+namespace lldb_private {
+class ObjCRuntimeSyntheticProvider : public SyntheticChildren {
+  ObjCLanguageRuntime::ClassDescriptorSP m_descriptor_sp;
+
+public:
+  ObjCRuntimeSyntheticProvider(
+      const SyntheticChildren::Flags &flags,
+      ObjCLanguageRuntime::ClassDescriptorSP descriptor_sp)
+      : SyntheticChildren(flags), m_descriptor_sp(descriptor_sp) {
+    // no point in making one with no descriptor!
+    assert(descriptor_sp.get());
+  }
+
+  bool IsScripted() { return false; }
+
+  size_t GetNumIVars() { return m_descriptor_sp->GetNumIVars(); }
+
+  ObjCLanguageRuntime::ClassDescriptor::iVarDescriptor
+  GetIVarAtIndex(size_t idx) {
+    return m_descriptor_sp->GetIVarAtIndex(idx);
+  }
+
+  std::string GetDescription();
+
+  class FrontEnd : public SyntheticChildrenFrontEnd {
+  private:
+    ObjCRuntimeSyntheticProvider *m_provider;
+
+  public:
+    FrontEnd(ObjCRuntimeSyntheticProvider *prv, ValueObject &backend);
+
+    virtual ~FrontEnd() {}
+
+    virtual size_t CalculateNumChildren();
+
+    virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx);
+
+    virtual bool Update() { return false; }
+
+    virtual bool MightHaveChildren() { return true; }
+
+    virtual size_t GetIndexOfChildWithName(const ConstString &name);
+
+    typedef std::shared_ptr<SyntheticChildrenFrontEnd> SharedPointer;
+
+  private:
+    size_t GetNumBases();
+
+    lldb::ValueObjectSP m_root_sp;
+
+    DISALLOW_COPY_AND_ASSIGN(FrontEnd);
+  };
+
+  virtual SyntheticChildrenFrontEnd::AutoPointer
+  GetFrontEnd(ValueObject &backend) {
+    return SyntheticChildrenFrontEnd::AutoPointer(new FrontEnd(this, backend));
+  }
+
+private:
+  DISALLOW_COPY_AND_ASSIGN(ObjCRuntimeSyntheticProvider);
+};
+} // namespace lldb_private
+
+#endif // lldb_ObjCRuntimeSyntheticProvider_h
diff --git a/source/Plugins/Language/Swift/SwiftArray.cpp b/source/Plugins/Language/Swift/SwiftArray.cpp
index e69de29bb..6e971ba22 100644
--- a/source/Plugins/Language/Swift/SwiftArray.cpp
+++ b/source/Plugins/Language/Swift/SwiftArray.cpp
@@ -0,0 +1,530 @@
+//===-- SwiftArray.cpp ------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftArray.h"
+
+#include "lldb/Core/ValueObjectConstResult.h"
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Target/Target.h"
+
+// FIXME: we should not need this
+#include "Plugins/Language/ObjC/Cocoa.h"
+
+#include "swift/AST/ASTContext.h"
+#include "llvm/ADT/StringRef.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+size_t SwiftArrayNativeBufferHandler::GetCount() { return m_size; }
+
+size_t SwiftArrayNativeBufferHandler::GetCapacity() { return m_capacity; }
+
+lldb_private::CompilerType SwiftArrayNativeBufferHandler::GetElementType() {
+  return m_elem_type;
+}
+
+ValueObjectSP SwiftArrayNativeBufferHandler::GetElementAtIndex(size_t idx) {
+  if (idx >= m_size)
+    return ValueObjectSP();
+
+  lldb::addr_t child_location = m_first_elem_ptr + idx * m_element_stride;
+
+  ProcessSP process_sp(m_exe_ctx_ref.GetProcessSP());
+  if (!process_sp)
+    return ValueObjectSP();
+
+  DataBufferSP buffer(new DataBufferHeap(m_element_size, 0));
+  Status error;
+  if (process_sp->ReadMemory(child_location, buffer->GetBytes(), m_element_size,
+                             error) != m_element_size ||
+      error.Fail())
+    return ValueObjectSP();
+  DataExtractor data(buffer, process_sp->GetByteOrder(),
+                     process_sp->GetAddressByteSize());
+  StreamString name;
+  name.Printf("[%zu]", idx);
+  return ValueObject::CreateValueObjectFromData(name.GetData(), data,
+                                                m_exe_ctx_ref, m_elem_type);
+}
+
+SwiftArrayNativeBufferHandler::SwiftArrayNativeBufferHandler(
+    ValueObject &valobj, lldb::addr_t native_ptr, CompilerType elem_type)
+    : m_metadata_ptr(LLDB_INVALID_ADDRESS),
+      m_reserved_word(LLDB_INVALID_ADDRESS), m_size(0), m_capacity(0),
+      m_first_elem_ptr(LLDB_INVALID_ADDRESS), m_elem_type(elem_type),
+      m_element_size(elem_type.GetByteSize(nullptr)),
+      m_element_stride(elem_type.GetByteStride()),
+      m_exe_ctx_ref(valobj.GetExecutionContextRef()) {
+  if (native_ptr == LLDB_INVALID_ADDRESS)
+    return;
+  if (native_ptr == 0) {
+    // 0 is a valid value for the pointer here - it just means empty
+    // never-written-to array
+    m_metadata_ptr = 0;
+    m_reserved_word = 0;
+    m_size = m_capacity = 0;
+    m_first_elem_ptr = 0;
+    return;
+  }
+  ProcessSP process_sp(m_exe_ctx_ref.GetProcessSP());
+  if (!process_sp)
+    return;
+  size_t ptr_size = process_sp->GetAddressByteSize();
+  Status error;
+  lldb::addr_t next_read = native_ptr;
+  m_metadata_ptr = process_sp->ReadPointerFromMemory(next_read, error);
+  if (error.Fail())
+    return;
+  next_read += ptr_size;
+  m_reserved_word =
+      process_sp->ReadUnsignedIntegerFromMemory(next_read, 8, 0, error);
+  if (error.Fail())
+    return;
+  next_read += 8;
+  m_size =
+      process_sp->ReadUnsignedIntegerFromMemory(next_read, ptr_size, 0, error);
+  if (error.Fail())
+    return;
+  next_read += ptr_size;
+  m_capacity =
+      process_sp->ReadUnsignedIntegerFromMemory(next_read, ptr_size, 0, error);
+  if (error.Fail())
+    return;
+  next_read += ptr_size;
+  m_first_elem_ptr = next_read;
+}
+
+bool SwiftArrayNativeBufferHandler::IsValid() {
+  return m_metadata_ptr != LLDB_INVALID_ADDRESS &&
+         m_first_elem_ptr != LLDB_INVALID_ADDRESS && m_capacity >= m_size &&
+         m_elem_type.IsValid();
+}
+
+size_t SwiftArrayBridgedBufferHandler::GetCount() {
+  return m_frontend->CalculateNumChildren();
+}
+
+size_t SwiftArrayBridgedBufferHandler::GetCapacity() { return GetCount(); }
+
+lldb_private::CompilerType SwiftArrayBridgedBufferHandler::GetElementType() {
+  return m_elem_type;
+}
+
+lldb::ValueObjectSP
+SwiftArrayBridgedBufferHandler::GetElementAtIndex(size_t idx) {
+  return m_frontend->GetChildAtIndex(idx);
+}
+
+SwiftArrayBridgedBufferHandler::SwiftArrayBridgedBufferHandler(
+    ProcessSP process_sp, lldb::addr_t native_ptr)
+    : SwiftArrayBufferHandler(), m_elem_type(), m_synth_array_sp(),
+      m_frontend(nullptr) {
+  m_elem_type =
+      process_sp->GetTarget().GetScratchClangASTContext()->GetBasicType(
+          lldb::eBasicTypeObjCID);
+  InferiorSizedWord isw(native_ptr, *process_sp);
+  m_synth_array_sp = ValueObjectConstResult::CreateValueObjectFromData(
+      "_", isw.GetAsData(process_sp->GetByteOrder()), *process_sp, m_elem_type);
+  if ((m_frontend = NSArraySyntheticFrontEndCreator(nullptr, m_synth_array_sp)))
+    m_frontend->Update();
+}
+
+bool SwiftArrayBridgedBufferHandler::IsValid() {
+  return m_synth_array_sp.get() != nullptr && m_frontend != nullptr;
+}
+
+size_t SwiftArraySliceBufferHandler::GetCount() { return m_size; }
+
+size_t SwiftArraySliceBufferHandler::GetCapacity() {
+  // Slices don't have a separate capacity - at least not in any obvious sense
+  return m_size;
+}
+
+lldb_private::CompilerType SwiftArraySliceBufferHandler::GetElementType() {
+  return m_elem_type;
+}
+
+lldb::ValueObjectSP
+SwiftArraySliceBufferHandler::GetElementAtIndex(size_t idx) {
+  if (idx >= m_size)
+    return ValueObjectSP();
+
+  const uint64_t effective_idx = idx + m_start_index;
+
+  lldb::addr_t child_location =
+      m_first_elem_ptr + effective_idx * m_element_stride;
+
+  ProcessSP process_sp(m_exe_ctx_ref.GetProcessSP());
+  if (!process_sp)
+    return ValueObjectSP();
+
+  DataBufferSP buffer(new DataBufferHeap(m_element_size, 0));
+  Status error;
+  if (process_sp->ReadMemory(child_location, buffer->GetBytes(), m_element_size,
+                             error) != m_element_size ||
+      error.Fail())
+    return ValueObjectSP();
+  DataExtractor data(buffer, process_sp->GetByteOrder(),
+                     process_sp->GetAddressByteSize());
+  StreamString name;
+  name.Printf("[%" PRIu64 "]", effective_idx);
+  return ValueObject::CreateValueObjectFromData(name.GetData(), data,
+                                                m_exe_ctx_ref, m_elem_type);
+}
+
+// this gets passed the "buffer" element?
+SwiftArraySliceBufferHandler::SwiftArraySliceBufferHandler(
+    ValueObject &valobj, CompilerType elem_type)
+    : m_size(0), m_first_elem_ptr(LLDB_INVALID_ADDRESS), m_elem_type(elem_type),
+      m_element_size(elem_type.GetByteSize(nullptr)),
+      m_element_stride(elem_type.GetByteStride()),
+      m_exe_ctx_ref(valobj.GetExecutionContextRef()), m_native_buffer(false),
+      m_start_index(0) {
+  static ConstString g_start("subscriptBaseAddress");
+  static ConstString g_value("_value");
+  static ConstString g__rawValue("_rawValue");
+  static ConstString g__countAndFlags("endIndexAndFlags");
+  static ConstString g__startIndex("startIndex");
+
+  ProcessSP process_sp(m_exe_ctx_ref.GetProcessSP());
+  if (!process_sp)
+    return;
+
+  ValueObjectSP value_sp(valobj.GetChildAtNamePath({g_start, g__rawValue}));
+  if (!value_sp)
+    return;
+
+  m_first_elem_ptr = value_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+
+  ValueObjectSP _countAndFlags_sp(
+      valobj.GetChildAtNamePath({g__countAndFlags, g_value}));
+
+  if (!_countAndFlags_sp)
+    return;
+
+  ValueObjectSP startIndex_sp(
+      valobj.GetChildAtNamePath({g__startIndex, g_value}));
+
+  if (startIndex_sp)
+    m_start_index = startIndex_sp->GetValueAsUnsigned(0);
+
+  InferiorSizedWord isw(_countAndFlags_sp->GetValueAsUnsigned(0), *process_sp);
+
+  m_size = (isw >> 1).GetValue() - m_start_index;
+
+  m_native_buffer = !((isw & 1).IsZero());
+}
+
+bool SwiftArraySliceBufferHandler::IsValid() {
+  return m_first_elem_ptr != LLDB_INVALID_ADDRESS && m_elem_type.IsValid();
+}
+
+size_t SwiftSyntheticFrontEndBufferHandler::GetCount() {
+  return m_frontend->CalculateNumChildren();
+}
+
+size_t SwiftSyntheticFrontEndBufferHandler::GetCapacity() {
+  return m_frontend->CalculateNumChildren();
+}
+
+lldb_private::CompilerType
+SwiftSyntheticFrontEndBufferHandler::GetElementType() {
+  // this doesn't make sense here - the synthetic children know best
+  return CompilerType();
+}
+
+lldb::ValueObjectSP
+SwiftSyntheticFrontEndBufferHandler::GetElementAtIndex(size_t idx) {
+  return m_frontend->GetChildAtIndex(idx);
+}
+
+// this receives a pointer to the NSArray
+SwiftSyntheticFrontEndBufferHandler::SwiftSyntheticFrontEndBufferHandler(
+    ValueObjectSP valobj_sp)
+    : m_valobj_sp(valobj_sp),
+      m_frontend(NSArraySyntheticFrontEndCreator(nullptr, valobj_sp)) {
+  // Cocoa NSArray frontends must be updated before use
+  if (m_frontend)
+    m_frontend->Update();
+}
+
+bool SwiftSyntheticFrontEndBufferHandler::IsValid() {
+  return m_frontend.get() != nullptr;
+}
+
+std::unique_ptr<SwiftArrayBufferHandler>
+SwiftArrayBufferHandler::CreateBufferHandler(ValueObject &valobj) {
+  llvm::StringRef valobj_typename(
+      valobj.GetCompilerType().GetTypeName().AsCString(""));
+
+  if (valobj_typename.startswith("Swift._NSSwiftArray")) {
+    CompilerType anyobject_type =
+        valobj.GetTargetSP()->GetScratchClangASTContext()->GetBasicType(
+            lldb::eBasicTypeObjCID);
+    auto handler = std::unique_ptr<SwiftArrayBufferHandler>(
+        new SwiftArrayNativeBufferHandler(valobj, valobj.GetPointerValue(),
+                                          anyobject_type));
+    if (handler && handler->IsValid())
+      return handler;
+    return nullptr;
+  }
+
+  // For now we have to keep the old mangled name since the Objc->Swift bindings
+  // that are in Foundation don't get the new mangling.
+  if (valobj_typename.startswith(SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs23_ContiguousArrayStorage")) ||
+      valobj_typename.startswith("_TtCs23_ContiguousArrayStorage") ||
+      valobj_typename.startswith("Swift._ContiguousArrayStorage")) {
+    CompilerType anyobject_type =
+        valobj.GetTargetSP()->GetScratchClangASTContext()->GetBasicType(
+            lldb::eBasicTypeObjCID);
+    auto handler = std::unique_ptr<SwiftArrayBufferHandler>(
+        new SwiftArrayNativeBufferHandler(
+            valobj, valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS),
+            anyobject_type));
+    if (handler && handler->IsValid())
+      return handler;
+    return nullptr;
+  }
+
+  if (valobj_typename.startswith(SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs21_SwiftDeferredNSArray")) ||
+      valobj_typename.startswith("_TtCs21_SwiftDeferredNSArray") ||
+      valobj_typename.startswith("_TtCs21_SwiftDeferredNSArray")) {
+    ProcessSP process_sp(valobj.GetProcessSP());
+    if (!process_sp)
+      return nullptr;
+    Status error;
+
+    lldb::addr_t buffer_ptr = valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS) +
+                              3 * process_sp->GetAddressByteSize();
+    buffer_ptr = process_sp->ReadPointerFromMemory(buffer_ptr, error);
+    if (error.Fail() || buffer_ptr == LLDB_INVALID_ADDRESS)
+      return nullptr;
+
+    lldb::addr_t argmetadata_ptr =
+        process_sp->ReadPointerFromMemory(buffer_ptr, error);
+    if (error.Fail() || argmetadata_ptr == LLDB_INVALID_ADDRESS)
+      return nullptr;
+
+    SwiftLanguageRuntime *swift_runtime = process_sp->GetSwiftLanguageRuntime();
+    if (!swift_runtime)
+      return nullptr;
+
+    CompilerType argument_type;
+
+    SwiftASTContext *swift_ast_ctx(llvm::dyn_cast_or_null<SwiftASTContext>(
+        valobj.GetCompilerType().GetTypeSystem()));
+    SwiftLanguageRuntime::MetadataPromiseSP promise_sp(
+        swift_runtime->GetMetadataPromise(argmetadata_ptr, swift_ast_ctx));
+    if (promise_sp) {
+      if (CompilerType type = promise_sp->FulfillTypePromise()) {
+        lldb::TemplateArgumentKind kind;
+        argument_type = type.GetTemplateArgument(0, kind);
+      }
+    }
+
+    if (!argument_type.IsValid())
+      return nullptr;
+
+    auto handler = std::unique_ptr<SwiftArrayBufferHandler>(
+        new SwiftArrayNativeBufferHandler(valobj, buffer_ptr, argument_type));
+    if (handler && handler->IsValid())
+      return handler;
+    return nullptr;
+  }
+
+  if (valobj_typename.startswith("Swift.NativeArray<")) {
+    // Swift.NativeArray
+    static ConstString g_buffer("_buffer");
+    static ConstString g_base("base");
+    static ConstString g_storage("storage");
+    static ConstString g_some("Some");
+
+    ValueObjectSP some_sp(valobj.GetNonSyntheticValue()->GetChildAtNamePath(
+        {g_buffer, g_base, g_storage, g_some}));
+
+    if (!some_sp)
+      return nullptr;
+
+    CompilerType elem_type(valobj.GetCompilerType().GetArrayElementType());
+
+    auto handler = std::unique_ptr<SwiftArrayBufferHandler>(
+        new SwiftArrayNativeBufferHandler(
+            *some_sp, some_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS),
+            elem_type));
+    if (handler && handler->IsValid())
+      return handler;
+    return nullptr;
+  } else if (valobj_typename.startswith("Swift.ArraySlice<")) {
+    // Swift.ArraySlice
+    static ConstString g_buffer("_buffer");
+
+    ValueObjectSP buffer_sp(
+        valobj.GetNonSyntheticValue()->GetChildAtNamePath({g_buffer}));
+    if (!buffer_sp)
+      return nullptr;
+
+    CompilerType elem_type(valobj.GetCompilerType().GetArrayElementType());
+
+    auto handler = std::unique_ptr<SwiftArrayBufferHandler>(
+        new SwiftArraySliceBufferHandler(*buffer_sp, elem_type));
+    if (handler && handler->IsValid())
+      return handler;
+    return nullptr;
+  } else {
+    // Swift.Array
+    static ConstString g_buffer("_buffer");
+    static ConstString g__storage("_storage");
+    static ConstString g_rawValue("rawValue");
+
+    static ConstString g___bufferPointer("__bufferPointer");
+    static ConstString g__nativeBuffer("_nativeBuffer");
+
+    ValueObjectSP buffer_sp(valobj.GetNonSyntheticValue()->GetChildAtNamePath(
+        {g_buffer, g__storage, g_rawValue}));
+
+    // For the old Array version which using ManagedBufferPointer.
+    // TODO: this can be removed eventually.
+    if (!buffer_sp)
+      buffer_sp = valobj.GetNonSyntheticValue()->GetChildAtNamePath(
+          {g_buffer, g___bufferPointer, g__nativeBuffer});
+
+    // For the new Array version which uses SIL tail-allocated arrays.
+    if (!buffer_sp)
+      buffer_sp = valobj.GetNonSyntheticValue()->GetChildAtNamePath(
+          {g_buffer, g__storage});
+
+    if (!buffer_sp)
+      return nullptr;
+
+    lldb::addr_t storage_location =
+        buffer_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+
+    if (storage_location != LLDB_INVALID_ADDRESS) {
+      ProcessSP process_sp(valobj.GetProcessSP());
+      if (!process_sp)
+        return nullptr;
+      SwiftLanguageRuntime *swift_runtime =
+          process_sp->GetSwiftLanguageRuntime();
+      if (!swift_runtime)
+        return nullptr;
+      lldb::addr_t masked_storage_location =
+          swift_runtime->MaskMaybeBridgedPointer(storage_location);
+
+      std::unique_ptr<SwiftArrayBufferHandler> handler;
+      if (masked_storage_location == storage_location) {
+        CompilerType elem_type(valobj.GetCompilerType().GetArrayElementType());
+        handler.reset(new SwiftArrayNativeBufferHandler(
+            valobj, storage_location, elem_type));
+      } else {
+        handler.reset(new SwiftArrayBridgedBufferHandler(
+            process_sp, masked_storage_location));
+      }
+
+      if (handler && handler->IsValid())
+        return handler;
+      return nullptr;
+    } else {
+      CompilerType elem_type(valobj.GetCompilerType().GetArrayElementType());
+      return std::unique_ptr<SwiftArrayBufferHandler>(
+          new SwiftArrayEmptyBufferHandler(elem_type));
+    }
+  }
+
+  return nullptr;
+}
+
+bool lldb_private::formatters::swift::Array_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  auto handler = SwiftArrayBufferHandler::CreateBufferHandler(valobj);
+
+  if (!handler)
+    return false;
+
+  auto count = handler->GetCount();
+
+  stream.Printf("%zu value%s", count, (count == 1 ? "" : "s"));
+
+  return true;
+};
+
+lldb_private::formatters::swift::ArraySyntheticFrontEnd::ArraySyntheticFrontEnd(
+    lldb::ValueObjectSP valobj_sp)
+    : SyntheticChildrenFrontEnd(*valobj_sp.get()), m_array_buffer() {
+  if (valobj_sp)
+    Update();
+}
+
+size_t lldb_private::formatters::swift::ArraySyntheticFrontEnd::
+    CalculateNumChildren() {
+  return m_array_buffer ? m_array_buffer->GetCount() : 0;
+}
+
+lldb::ValueObjectSP
+lldb_private::formatters::swift::ArraySyntheticFrontEnd::GetChildAtIndex(
+    size_t idx) {
+  if (!m_array_buffer)
+    return ValueObjectSP();
+
+  lldb::ValueObjectSP child_sp = m_array_buffer->GetElementAtIndex(idx);
+  if (child_sp)
+    child_sp->SetSyntheticChildrenGenerated(true);
+
+  return child_sp;
+}
+
+bool lldb_private::formatters::swift::ArraySyntheticFrontEnd::Update() {
+  m_array_buffer = SwiftArrayBufferHandler::CreateBufferHandler(m_backend);
+  return false;
+}
+
+bool lldb_private::formatters::swift::ArraySyntheticFrontEnd::IsValid() {
+  if (m_array_buffer)
+    return m_array_buffer->IsValid();
+  return false;
+}
+
+bool lldb_private::formatters::swift::ArraySyntheticFrontEnd::
+    MightHaveChildren() {
+  return true;
+}
+
+size_t lldb_private::formatters::swift::ArraySyntheticFrontEnd::
+    GetIndexOfChildWithName(const ConstString &name) {
+  if (!m_array_buffer)
+    return UINT32_MAX;
+  const char *item_name = name.GetCString();
+  uint32_t idx = ExtractIndexFromString(item_name);
+  if (idx < UINT32_MAX && idx >= CalculateNumChildren())
+    return UINT32_MAX;
+  return idx;
+}
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::ArraySyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return nullptr;
+
+  ArraySyntheticFrontEnd *front_end = new ArraySyntheticFrontEnd(valobj_sp);
+  if (front_end && front_end->IsValid())
+    return front_end;
+  return nullptr;
+}
diff --git a/source/Plugins/Language/Swift/SwiftArray.h b/source/Plugins/Language/Swift/SwiftArray.h
index e69de29bb..188cb2f9b 100644
--- a/source/Plugins/Language/Swift/SwiftArray.h
+++ b/source/Plugins/Language/Swift/SwiftArray.h
@@ -0,0 +1,219 @@
+//===-- SwiftArray.h --------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftArray_h_
+#define liblldb_SwiftArray_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "lldb/DataFormatters/FormatClasses.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+
+// Some part of the buffer handling logic needs to be shared between summary and
+// synthetic children
+// If I was only making synthetic children, this would be best modelled as
+// different FrontEnds
+class SwiftArrayBufferHandler {
+public:
+  virtual size_t GetCount() = 0;
+
+  virtual size_t GetCapacity() = 0;
+
+  virtual lldb_private::CompilerType GetElementType() = 0;
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t) = 0;
+
+  static std::unique_ptr<SwiftArrayBufferHandler>
+  CreateBufferHandler(ValueObject &valobj);
+
+  virtual bool IsValid() = 0;
+
+  virtual ~SwiftArrayBufferHandler() {}
+
+protected:
+  static bool DoesTypeEntailIndirectBuffer(const CompilerType &element_type);
+};
+
+class SwiftArrayEmptyBufferHandler : public SwiftArrayBufferHandler {
+public:
+  virtual size_t GetCount() { return 0; }
+
+  virtual size_t GetCapacity() { return 0; }
+
+  virtual lldb_private::CompilerType GetElementType() { return m_elem_type; }
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t) {
+    return lldb::ValueObjectSP();
+  }
+
+  virtual ~SwiftArrayEmptyBufferHandler() {}
+
+  virtual bool IsValid() { return true; }
+
+protected:
+  SwiftArrayEmptyBufferHandler(CompilerType elem_type)
+      : m_elem_type(elem_type) {}
+  friend class SwiftArrayBufferHandler;
+
+private:
+  lldb_private::CompilerType m_elem_type;
+};
+
+class SwiftArrayNativeBufferHandler : public SwiftArrayBufferHandler {
+public:
+  virtual size_t GetCount();
+
+  virtual size_t GetCapacity();
+
+  virtual lldb_private::CompilerType GetElementType();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  virtual bool IsValid();
+
+  virtual ~SwiftArrayNativeBufferHandler() {}
+
+protected:
+  SwiftArrayNativeBufferHandler(ValueObject &valobj, lldb::addr_t native_ptr,
+                                CompilerType elem_type);
+  friend class SwiftArrayBufferHandler;
+
+private:
+  lldb::addr_t m_metadata_ptr;
+  uint64_t m_reserved_word;
+  lldb::addr_t m_size;
+  lldb::addr_t m_capacity;
+  lldb::addr_t m_first_elem_ptr;
+  lldb_private::CompilerType m_elem_type;
+  size_t m_element_size;
+  size_t m_element_stride;
+  lldb_private::ExecutionContextRef m_exe_ctx_ref;
+};
+
+class SwiftArrayBridgedBufferHandler : public SwiftArrayBufferHandler {
+public:
+  virtual size_t GetCount();
+
+  virtual size_t GetCapacity();
+
+  virtual lldb_private::CompilerType GetElementType();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  virtual bool IsValid();
+
+  virtual ~SwiftArrayBridgedBufferHandler() {}
+
+protected:
+  SwiftArrayBridgedBufferHandler(lldb::ProcessSP, lldb::addr_t);
+  friend class SwiftArrayBufferHandler;
+
+private:
+  CompilerType m_elem_type;
+  lldb::ValueObjectSP m_synth_array_sp;
+  SyntheticChildrenFrontEnd *m_frontend;
+};
+
+class SwiftArraySliceBufferHandler : public SwiftArrayBufferHandler {
+public:
+  virtual size_t GetCount();
+
+  virtual size_t GetCapacity();
+
+  virtual lldb_private::CompilerType GetElementType();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  virtual bool IsValid();
+
+  virtual ~SwiftArraySliceBufferHandler() {}
+
+protected:
+  SwiftArraySliceBufferHandler(ValueObject &valobj, CompilerType elem_type);
+  friend class SwiftArrayBufferHandler;
+
+private:
+  lldb::addr_t m_size;
+  lldb::addr_t m_first_elem_ptr;
+  lldb_private::CompilerType m_elem_type;
+  size_t m_element_size;
+  size_t m_element_stride;
+  lldb_private::ExecutionContextRef m_exe_ctx_ref;
+  bool m_native_buffer;
+  uint64_t m_start_index;
+};
+
+class SwiftSyntheticFrontEndBufferHandler : public SwiftArrayBufferHandler {
+public:
+  virtual size_t GetCount();
+
+  virtual size_t GetCapacity();
+
+  virtual lldb_private::CompilerType GetElementType();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  virtual bool IsValid();
+
+  virtual ~SwiftSyntheticFrontEndBufferHandler() {}
+
+protected:
+  SwiftSyntheticFrontEndBufferHandler(lldb::ValueObjectSP valobj_sp);
+  friend class SwiftArrayBufferHandler;
+
+private:
+  lldb::ValueObjectSP m_valobj_sp; // reader beware: this entails you must only
+                                   // pass self-rooted valueobjects to this
+                                   // class
+  std::unique_ptr<SyntheticChildrenFrontEnd> m_frontend;
+};
+
+bool Array_SummaryProvider(ValueObject &valobj, Stream &stream,
+                           const TypeSummaryOptions &options);
+
+class ArraySyntheticFrontEnd : public SyntheticChildrenFrontEnd {
+public:
+  ArraySyntheticFrontEnd(lldb::ValueObjectSP valobj_sp);
+
+  virtual size_t CalculateNumChildren();
+
+  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx);
+
+  virtual bool Update();
+
+  virtual bool MightHaveChildren();
+
+  virtual size_t GetIndexOfChildWithName(const ConstString &name);
+
+  virtual ~ArraySyntheticFrontEnd() = default;
+
+  bool IsValid();
+
+private:
+  std::unique_ptr<SwiftArrayBufferHandler> m_array_buffer;
+};
+
+SyntheticChildrenFrontEnd *ArraySyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                                         lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftArray_h_
diff --git a/source/Plugins/Language/Swift/SwiftBasicTypes.cpp b/source/Plugins/Language/Swift/SwiftBasicTypes.cpp
index e69de29bb..1ebe7fda1 100644
--- a/source/Plugins/Language/Swift/SwiftBasicTypes.cpp
+++ b/source/Plugins/Language/Swift/SwiftBasicTypes.cpp
@@ -0,0 +1,33 @@
+//===-- SwiftBasicTypes.cpp -------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftBasicTypes.h"
+
+#include "lldb/Core/ValueObject.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+lldb::ValueObjectSP lldb_private::formatters::swift::
+    SwiftBasicTypeSyntheticFrontEnd::GetSyntheticValue() {
+  return m_backend.GetChildAtIndex(0, true);
+}
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (valobj_sp)
+    return new SwiftBasicTypeSyntheticFrontEnd(*valobj_sp);
+  return nullptr;
+}
diff --git a/source/Plugins/Language/Swift/SwiftBasicTypes.h b/source/Plugins/Language/Swift/SwiftBasicTypes.h
index e69de29bb..5a4134e42 100644
--- a/source/Plugins/Language/Swift/SwiftBasicTypes.h
+++ b/source/Plugins/Language/Swift/SwiftBasicTypes.h
@@ -0,0 +1,41 @@
+//===-- SwiftBasicTypes.h ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftBasicTypes_h_
+#define liblldb_SwiftBasicTypes_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "lldb/DataFormatters/TypeSynthetic.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+
+class SwiftBasicTypeSyntheticFrontEnd : public SyntheticValueProviderFrontEnd {
+public:
+  SwiftBasicTypeSyntheticFrontEnd(ValueObject &backend)
+      : SyntheticValueProviderFrontEnd(backend) {}
+
+  ~SwiftBasicTypeSyntheticFrontEnd() {}
+
+  virtual lldb::ValueObjectSP GetSyntheticValue();
+};
+
+SyntheticChildrenFrontEnd *
+SwiftBasicTypeSyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                       lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftDictionary_h_
diff --git a/source/Plugins/Language/Swift/SwiftDictionary.cpp b/source/Plugins/Language/Swift/SwiftDictionary.cpp
index e69de29bb..8e42acec2 100644
--- a/source/Plugins/Language/Swift/SwiftDictionary.cpp
+++ b/source/Plugins/Language/Swift/SwiftDictionary.cpp
@@ -0,0 +1,138 @@
+//===-- SwiftDictionary.cpp -------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftDictionary.h"
+
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+
+#include "swift/AST/ASTContext.h"
+#include "llvm/ADT/StringRef.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+class SwiftDictionaryNativeBufferHandler
+    : public SwiftHashedContainerNativeBufferHandler {
+public:
+  SwiftHashedContainerBufferHandler::Kind GetKind() {
+    return Kind::eDictionary;
+  }
+
+  static ConstString GetMangledStorageTypeName();
+
+  static ConstString GetDemangledStorageTypeName();
+
+  SwiftDictionaryNativeBufferHandler(ValueObjectSP nativeStorage_sp,
+                                     CompilerType key_type,
+                                     CompilerType value_type)
+      : SwiftHashedContainerNativeBufferHandler(nativeStorage_sp, key_type,
+                                                value_type) {}
+  friend class SwiftHashedContainerBufferHandler;
+
+private:
+};
+
+class SwiftDictionarySyntheticFrontEndBufferHandler
+    : public SwiftHashedContainerSyntheticFrontEndBufferHandler {
+public:
+  SwiftHashedContainerBufferHandler::Kind GetKind() {
+    return Kind::eDictionary;
+  }
+
+  virtual ~SwiftDictionarySyntheticFrontEndBufferHandler() {}
+
+  SwiftDictionarySyntheticFrontEndBufferHandler(lldb::ValueObjectSP valobj_sp)
+      : SwiftHashedContainerSyntheticFrontEndBufferHandler(valobj_sp) {}
+  friend class SwiftHashedContainerBufferHandler;
+
+private:
+};
+
+class DictionarySyntheticFrontEnd : public HashedContainerSyntheticFrontEnd {
+public:
+  DictionarySyntheticFrontEnd(lldb::ValueObjectSP valobj_sp)
+      : HashedContainerSyntheticFrontEnd(valobj_sp) {}
+
+  virtual bool Update();
+
+  virtual ~DictionarySyntheticFrontEnd() = default;
+};
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::DictionarySyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return NULL;
+  return (new DictionarySyntheticFrontEnd(valobj_sp));
+}
+
+bool lldb_private::formatters::swift::DictionarySyntheticFrontEnd::Update() {
+  m_buffer = SwiftHashedContainerBufferHandler::CreateBufferHandler(
+      m_backend,
+      [](ValueObjectSP a, CompilerType b,
+         CompilerType c) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftDictionaryNativeBufferHandler(a, b, c);
+      },
+      [](ValueObjectSP a) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftDictionarySyntheticFrontEndBufferHandler(a);
+      },
+      SwiftDictionaryNativeBufferHandler::GetMangledStorageTypeName(),
+      SwiftDictionaryNativeBufferHandler::GetDemangledStorageTypeName());
+  return false;
+}
+
+bool lldb_private::formatters::swift::Dictionary_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  auto handler = SwiftHashedContainerBufferHandler::CreateBufferHandler(
+      valobj,
+      [](ValueObjectSP a, CompilerType b,
+         CompilerType c) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftDictionaryNativeBufferHandler(a, b, c);
+      },
+      [](ValueObjectSP a) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftDictionarySyntheticFrontEndBufferHandler(a);
+      },
+      SwiftDictionaryNativeBufferHandler::GetMangledStorageTypeName(),
+      SwiftDictionaryNativeBufferHandler::GetDemangledStorageTypeName());
+
+  if (!handler)
+    return false;
+
+  auto count = handler->GetCount();
+
+  stream.Printf("%zu key/value pair%s", count, (count == 1 ? "" : "s"));
+
+  return true;
+};
+
+ConstString SwiftDictionaryNativeBufferHandler::GetMangledStorageTypeName() {
+  static ConstString g_name(SwiftLanguageRuntime::GetCurrentMangledName(
+      "_TtCs29_NativeDictionaryStorageOwner"));
+  return g_name;
+}
+
+ConstString SwiftDictionaryNativeBufferHandler::GetDemangledStorageTypeName() {
+  static ConstString g_name("Swift._NativeDictionaryStorageOwner");
+  return g_name;
+}
diff --git a/source/Plugins/Language/Swift/SwiftDictionary.h b/source/Plugins/Language/Swift/SwiftDictionary.h
index e69de29bb..6401f0b41 100644
--- a/source/Plugins/Language/Swift/SwiftDictionary.h
+++ b/source/Plugins/Language/Swift/SwiftDictionary.h
@@ -0,0 +1,38 @@
+//===-- SwiftDictionary.h ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftDictionary_h_
+#define liblldb_SwiftDictionary_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "SwiftHashedContainer.h"
+#include "lldb/DataFormatters/FormatClasses.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+bool Dictionary_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                const TypeSummaryOptions &options);
+
+SyntheticChildrenFrontEnd *
+DictionarySyntheticFrontEndCreator(CXXSyntheticChildren *, lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftDictionary_h_
diff --git a/source/Plugins/Language/Swift/SwiftFormatters.cpp b/source/Plugins/Language/Swift/SwiftFormatters.cpp
index e69de29bb..6eb4a3208 100644
--- a/source/Plugins/Language/Swift/SwiftFormatters.cpp
+++ b/source/Plugins/Language/Swift/SwiftFormatters.cpp
@@ -0,0 +1,792 @@
+//===-- SwiftFormatters.cpp -------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftFormatters.h"
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/DataFormatters/StringPrinter.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Utility/DataBufferHeap.h"
+#include "lldb/Utility/Status.h"
+
+// FIXME: we should not need this
+#include "Plugins/Language/CPlusPlus/CxxStringTypes.h"
+#include "Plugins/Language/ObjC/Cocoa.h"
+#include "Plugins/Language/ObjC/NSString.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+bool lldb_private::formatters::swift::Character_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_Small("Small");
+  static ConstString g_Large("Large");
+
+  static ConstString g__representation("_representation");
+
+  static ConstString g__storage("_storage");
+  static ConstString g_storage("storage");
+  static ConstString g_Some("Some");
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return false;
+
+  ValueObjectSP representation_sp =
+      valobj.GetChildMemberWithName(g__representation, true);
+
+  if (!representation_sp)
+    return false;
+
+  ConstString value(representation_sp->GetValueAsCString());
+
+  if (value == g_Large) {
+    ValueObjectSP largeBuffer_sp(representation_sp->GetChildAtNamePath(
+        {g_Large, g__storage, g_storage, g_Some}));
+    if (!largeBuffer_sp)
+      return false;
+
+    lldb::addr_t buffer_ptr =
+        largeBuffer_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+    if (LLDB_INVALID_ADDRESS == buffer_ptr || 0 == buffer_ptr)
+      return false;
+
+    buffer_ptr += 2 * process_sp->GetAddressByteSize();
+    Status error;
+    buffer_ptr = process_sp->ReadPointerFromMemory(buffer_ptr, error);
+    if (LLDB_INVALID_ADDRESS == buffer_ptr || 0 == buffer_ptr)
+      return false;
+
+    StringPrinter::ReadStringAndDumpToStreamOptions options;
+    options.SetLocation(buffer_ptr)
+        .SetEscapeNonPrintables(true)
+        .SetNeedsZeroTermination(true)
+        .SetPrefixToken(0)
+        .SetProcessSP(valobj.GetProcessSP())
+        .SetQuote('"')
+        .SetStream(&stream)
+        .SetLanguage(lldb::eLanguageTypeSwift);
+
+    return StringPrinter::ReadStringAndDumpToStream<
+        StringPrinter::StringElementType::UTF16>(options);
+  } else if (value == g_Small) {
+    const uint64_t invalidRepr = 0xFFFFFFFFFFFFFFFF;
+
+    ValueObjectSP smallBuffer_sp(
+        representation_sp->GetChildAtNamePath({g_Small}));
+    if (!smallBuffer_sp)
+      return false;
+
+    uint64_t buffer_data = smallBuffer_sp->GetValueAsUnsigned(invalidRepr);
+    if (invalidRepr == buffer_data)
+      return false;
+
+    uint8_t bytes[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+    uint64_t mask = 0x00000000000000FF;
+    uint8_t shift = 0;
+    uint8_t pos = 0;
+    for (; pos < 7; pos++, mask <<= 8, shift += 8) {
+      auto val = (uint8_t)((mask & buffer_data) >> shift);
+      if (0xFF == val)
+        break;
+      bytes[pos] = val;
+    }
+
+    DataExtractor data(bytes, 7, process_sp->GetByteOrder(),
+                       process_sp->GetAddressByteSize());
+
+    StringPrinter::ReadBufferAndDumpToStreamOptions options;
+    options.SetData(data)
+        .SetEscapeNonPrintables(true)
+        .SetPrefixToken(0)
+        .SetQuote('"')
+        .SetStream(&stream)
+        .SetSourceSize(pos)
+        .SetLanguage(lldb::eLanguageTypeSwift);
+
+    return StringPrinter::ReadBufferAndDumpToStream<
+        StringPrinter::StringElementType::UTF8>(options);
+  }
+  return false;
+}
+
+bool lldb_private::formatters::swift::UnicodeScalar_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_value("_value");
+  ValueObjectSP value_sp(valobj.GetChildMemberWithName(g_value, true));
+  if (!value_sp)
+    return false;
+  return Char32SummaryProvider(*value_sp.get(), stream, options);
+}
+
+bool lldb_private::formatters::swift::StringCore_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return StringCore_SummaryProvider(
+      valobj, stream, options,
+      StringPrinter::ReadStringAndDumpToStreamOptions());
+}
+
+bool lldb_private::formatters::swift::StringCore_SummaryProvider(
+    ValueObject &valobj, Stream &stream,
+    const TypeSummaryOptions &summary_options,
+    StringPrinter::ReadStringAndDumpToStreamOptions read_options) {
+  static ConstString g_some("some");
+  static ConstString g__baseAddress("_baseAddress");
+  static ConstString g__countAndFlags("_countAndFlags");
+  static ConstString g_value("_value");
+  static ConstString g__rawValue("_rawValue");
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return false;
+  ValueObjectSP baseAddress_sp(
+      valobj.GetChildAtNamePath({g__baseAddress, g_some, g__rawValue}));
+  ValueObjectSP _countAndFlags_sp(
+      valobj.GetChildAtNamePath({g__countAndFlags, g_value}));
+
+  if (!_countAndFlags_sp)
+    return false;
+
+  lldb::addr_t baseAddress =
+      baseAddress_sp ? baseAddress_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS)
+                     : 0;
+  InferiorSizedWord _countAndFlags = InferiorSizedWord(
+      _countAndFlags_sp->GetValueAsUnsigned(0), *process_sp.get());
+
+  if (baseAddress == LLDB_INVALID_ADDRESS)
+    return false;
+
+  bool hasCocoaBuffer = (_countAndFlags << 1).IsNegative();
+
+  if (baseAddress == 0) {
+    if (hasCocoaBuffer) {
+      static ConstString g__owner("_owner");
+      static ConstString g_Some("some");
+      static ConstString g_instance_type("instance_type");
+
+      ValueObjectSP dyn_inst_type0(
+          valobj.GetChildAtNamePath({g__owner, g_Some, g_instance_type}));
+      if (!dyn_inst_type0)
+        return false;
+      lldb::addr_t dyn_inst_type0_ptr =
+          dyn_inst_type0->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+      if (dyn_inst_type0_ptr == 0 || dyn_inst_type0_ptr == LLDB_INVALID_ADDRESS)
+        return false;
+
+      InferiorSizedWord dataAddress_isw =
+          InferiorSizedWord(dyn_inst_type0_ptr, *process_sp.get());
+
+      DataExtractor id_ptr =
+          dataAddress_isw.GetAsData(process_sp->GetByteOrder());
+      CompilerType id_type =
+          process_sp->GetTarget().GetScratchClangASTContext()->GetBasicType(
+              lldb::eBasicTypeObjCID);
+
+      if (!id_type)
+        return false;
+
+      ValueObjectSP nsstringhere_sp = ValueObject::CreateValueObjectFromData(
+          "nsstringhere", id_ptr, valobj.GetExecutionContextRef(), id_type);
+      if (nsstringhere_sp)
+        return NSStringSummaryProvider(*nsstringhere_sp.get(), stream,
+                                       summary_options);
+      return false;
+    } else {
+      stream.Printf("\"\"");
+      return true;
+    }
+  }
+
+  const InferiorSizedWord _countMask =
+      InferiorSizedWord::GetMaximum(*process_sp.get()) >> 2;
+
+  uint64_t count = (_countAndFlags & _countMask).GetValue();
+
+  bool isASCII =
+      ((_countAndFlags >> (_countMask.GetBitSize() - 1)).SignExtend() << 8)
+          .IsZero();
+
+  if (count == 0) {
+    stream.Printf("\"\"");
+    return true;
+  }
+
+  read_options.SetLocation(baseAddress);
+  read_options.SetProcessSP(process_sp);
+  read_options.SetStream(&stream);
+  read_options.SetSourceSize(count);
+  read_options.SetNeedsZeroTermination(false);
+  read_options.SetIgnoreMaxLength(summary_options.GetCapping() ==
+                                  lldb::eTypeSummaryUncapped);
+  read_options.SetBinaryZeroIsTerminator(false);
+  read_options.SetLanguage(summary_options.GetLanguage());
+  if (summary_options.GetLanguage() == lldb::eLanguageTypeObjC)
+    read_options.SetPrefixToken("@");
+
+  if (isASCII)
+    return StringPrinter::ReadStringAndDumpToStream<
+        StringPrinter::StringElementType::UTF8>(read_options);
+  else
+    return StringPrinter::ReadStringAndDumpToStream<
+        StringPrinter::StringElementType::UTF16>(read_options);
+}
+
+bool lldb_private::formatters::swift::String_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return String_SummaryProvider(
+      valobj, stream, options,
+      StringPrinter::ReadStringAndDumpToStreamOptions());
+}
+
+bool lldb_private::formatters::swift::String_SummaryProvider(
+    ValueObject &valobj, Stream &stream,
+    const TypeSummaryOptions &summary_options,
+    StringPrinter::ReadStringAndDumpToStreamOptions read_options) {
+  static ConstString g_core("_core");
+  ValueObjectSP core_sp = valobj.GetChildMemberWithName(g_core, true);
+  if (core_sp)
+    return StringCore_SummaryProvider(*core_sp, stream, summary_options,
+                                      read_options);
+  return false;
+}
+
+bool lldb_private::formatters::swift::StaticString_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return StaticString_SummaryProvider(
+      valobj, stream, options,
+      StringPrinter::ReadStringAndDumpToStreamOptions());
+}
+
+bool lldb_private::formatters::swift::StaticString_SummaryProvider(
+    ValueObject &valobj, Stream &stream,
+    const TypeSummaryOptions &summary_options,
+    StringPrinter::ReadStringAndDumpToStreamOptions read_options) {
+  static ConstString g__startPtrOrData("_startPtrOrData");
+  static ConstString g__byteSize("_utf8CodeUnitCount");
+  static ConstString g__flags("_flags");
+
+  ValueObjectSP flags_sp(valobj.GetChildMemberWithName(g__flags, true));
+  if (!flags_sp)
+    return false;
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return false;
+
+  // 0 == pointer representation
+  InferiorSizedWord flags(flags_sp->GetValueAsUnsigned(0), *process_sp);
+  if (0 != (flags & 0x1).GetValue())
+    return false;
+
+  ValueObjectSP startptr_sp(
+      valobj.GetChildMemberWithName(g__startPtrOrData, true));
+  ValueObjectSP bytesize_sp(valobj.GetChildMemberWithName(g__byteSize, true));
+  if (!startptr_sp || !bytesize_sp)
+    return false;
+
+  lldb::addr_t start_ptr =
+      startptr_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  uint64_t size = bytesize_sp->GetValueAsUnsigned(0);
+
+  if (start_ptr == LLDB_INVALID_ADDRESS || start_ptr == 0)
+    return false;
+
+  if (size == 0) {
+    stream.Printf("\"\"");
+    return true;
+  }
+
+  read_options.SetProcessSP(process_sp);
+  read_options.SetLocation(start_ptr);
+  read_options.SetSourceSize(size);
+  read_options.SetBinaryZeroIsTerminator(false);
+  read_options.SetNeedsZeroTermination(false);
+  read_options.SetStream(&stream);
+  read_options.SetIgnoreMaxLength(summary_options.GetCapping() ==
+                                  lldb::eTypeSummaryUncapped);
+  read_options.SetLanguage(lldb::eLanguageTypeSwift);
+
+  return StringPrinter::ReadStringAndDumpToStream<
+      StringPrinter::StringElementType::UTF8>(read_options);
+}
+
+bool lldb_private::formatters::swift::NSContiguousString_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_StringCoreType(
+      SwiftLanguageRuntime::GetCurrentMangledName("_TtVs11_StringCore"));
+  lldb::addr_t core_location = valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  if (core_location == LLDB_INVALID_ADDRESS)
+    return false;
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return false;
+  size_t ptr_size = process_sp->GetAddressByteSize();
+  core_location += 2 * ptr_size;
+
+  Status error;
+
+  InferiorSizedWord isw_1(
+      process_sp->ReadPointerFromMemory(core_location, error), *process_sp);
+  InferiorSizedWord isw_2(
+      process_sp->ReadPointerFromMemory(core_location + ptr_size, error),
+      *process_sp);
+  InferiorSizedWord isw_3(process_sp->ReadPointerFromMemory(
+                              core_location + ptr_size + ptr_size, error),
+                          *process_sp);
+
+  DataBufferSP buffer_sp(new DataBufferHeap(3 * ptr_size, 0));
+  uint8_t *buffer = buffer_sp->GetBytes();
+
+  buffer = isw_1.CopyToBuffer(buffer);
+  buffer = isw_2.CopyToBuffer(buffer);
+  buffer = isw_3.CopyToBuffer(buffer);
+
+  DataExtractor data(buffer_sp, process_sp->GetByteOrder(), ptr_size);
+
+  SwiftASTContext *lldb_swift_ast =
+      process_sp->GetTarget().GetScratchSwiftASTContext(error);
+  if (!lldb_swift_ast)
+    return false;
+  CompilerType string_core_type = lldb_swift_ast->GetTypeFromMangledTypename(
+      g_StringCoreType.GetCString(), error);
+  if (string_core_type.IsValid() == false)
+    return false;
+
+  ValueObjectSP string_core_sp = ValueObject::CreateValueObjectFromData(
+      "stringcore", data, valobj.GetExecutionContextRef(), string_core_type);
+  if (string_core_sp)
+    return StringCore_SummaryProvider(*string_core_sp, stream, options);
+  return false;
+}
+
+bool lldb_private::formatters::swift::Bool_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_value("_value");
+  ValueObjectSP value_child(valobj.GetChildMemberWithName(g_value, true));
+  if (!value_child)
+    return false;
+
+  // Swift Bools are stored in a byte, but only the LSB of the byte is
+  // significant.  The swift::irgen::FixedTypeInfo structure represents
+  // this information by providing a mask of the "extra bits" for the type.
+  // But at present CompilerType has no way to represent that information.
+  // So for now we hard code it.
+  uint64_t value = value_child->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  const uint64_t mask = 1 << 0;
+  value &= mask;
+
+  switch (value) {
+  case 0:
+    stream.Printf("false");
+    return true;
+  case 1:
+    stream.Printf("true");
+    return true;
+  case LLDB_INVALID_ADDRESS:
+    return false;
+  default:
+    stream.Printf("<invalid> (0x%" PRIx8 ")", (uint8_t)value);
+    return true;
+  }
+}
+
+bool lldb_private::formatters::swift::DarwinBoolean_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__value("_value");
+  ValueObjectSP value_child(valobj.GetChildMemberWithName(g__value, true));
+  if (!value_child)
+    return false;
+  auto value = value_child->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  switch (value) {
+  case 0:
+    stream.Printf("false");
+    return true;
+  default:
+    stream.Printf("true");
+    return true;
+  }
+}
+
+static bool RangeFamily_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                        const TypeSummaryOptions &options,
+                                        bool isHalfOpen) {
+  static ConstString g_lowerBound("lowerBound");
+  static ConstString g_upperBound("upperBound");
+
+  ValueObjectSP lowerBound_sp(
+      valobj.GetChildMemberWithName(g_lowerBound, true));
+  ValueObjectSP upperBound_sp(
+      valobj.GetChildMemberWithName(g_upperBound, true));
+
+  if (!lowerBound_sp || !upperBound_sp)
+    return false;
+
+  lowerBound_sp = lowerBound_sp->GetQualifiedRepresentationIfAvailable(
+      lldb::eDynamicDontRunTarget, true);
+  upperBound_sp = upperBound_sp->GetQualifiedRepresentationIfAvailable(
+      lldb::eDynamicDontRunTarget, true);
+
+  auto start_summary = lowerBound_sp->GetValueAsCString();
+  auto end_summary = upperBound_sp->GetValueAsCString();
+
+  // the Range should not have a summary unless both start and end indices have
+  // one - or it will look awkward
+  if (!start_summary || !start_summary[0] || !end_summary || !end_summary[0])
+    return false;
+
+  stream.Printf("%s%s%s", start_summary, isHalfOpen ? "..<" : "...",
+                end_summary);
+
+  return true;
+}
+
+bool lldb_private::formatters::swift::Range_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return RangeFamily_SummaryProvider(valobj, stream, options, true);
+}
+
+bool lldb_private::formatters::swift::CountableRange_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return RangeFamily_SummaryProvider(valobj, stream, options, true);
+}
+
+bool lldb_private::formatters::swift::ClosedRange_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return RangeFamily_SummaryProvider(valobj, stream, options, false);
+}
+
+bool lldb_private::formatters::swift::CountableClosedRange_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  return RangeFamily_SummaryProvider(valobj, stream, options, false);
+}
+
+bool lldb_private::formatters::swift::StridedRangeGenerator_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g__bounds("_bounds");
+  static ConstString g__stride("_stride");
+
+  ValueObjectSP bounds_sp(valobj.GetChildMemberWithName(g__bounds, true));
+  ValueObjectSP stride_sp(valobj.GetChildMemberWithName(g__stride, true));
+
+  if (!bounds_sp || !stride_sp)
+    return false;
+
+  auto bounds_summary = bounds_sp->GetSummaryAsCString();
+  auto stride_summary = stride_sp->GetValueAsCString();
+
+  if (!bounds_summary || !bounds_summary[0] || !stride_summary ||
+      !stride_summary[0])
+    return false;
+
+  stream.Printf("(%s).by(%s)", bounds_summary, stride_summary);
+
+  return true;
+}
+
+bool lldb_private::formatters::swift::BuiltinObjC_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  stream.Printf("0x%" PRIx64 " ", valobj.GetValueAsUnsigned(0));
+  stream.Printf("%s", valobj.GetObjectDescription());
+  return true;
+}
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+class EnumSyntheticFrontEnd : public SyntheticChildrenFrontEnd {
+public:
+  EnumSyntheticFrontEnd(lldb::ValueObjectSP valobj_sp);
+
+  virtual size_t CalculateNumChildren();
+
+  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx);
+
+  virtual bool Update();
+
+  virtual bool MightHaveChildren();
+
+  virtual size_t GetIndexOfChildWithName(const ConstString &name);
+
+  virtual ~EnumSyntheticFrontEnd() = default;
+
+private:
+  ExecutionContextRef m_exe_ctx_ref;
+  ConstString m_element_name;
+  size_t m_child_index;
+};
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+lldb_private::formatters::swift::EnumSyntheticFrontEnd::EnumSyntheticFrontEnd(
+    lldb::ValueObjectSP valobj_sp)
+    : SyntheticChildrenFrontEnd(*valobj_sp.get()), m_exe_ctx_ref(),
+      m_element_name(nullptr), m_child_index(UINT32_MAX) {
+  if (valobj_sp)
+    Update();
+}
+
+size_t
+lldb_private::formatters::swift::EnumSyntheticFrontEnd::CalculateNumChildren() {
+  return m_child_index != UINT32_MAX ? 1 : 0;
+}
+
+lldb::ValueObjectSP
+lldb_private::formatters::swift::EnumSyntheticFrontEnd::GetChildAtIndex(
+    size_t idx) {
+  if (idx)
+    return ValueObjectSP();
+  if (m_child_index == UINT32_MAX)
+    return ValueObjectSP();
+  return m_backend.GetChildAtIndex(m_child_index, true);
+}
+
+bool lldb_private::formatters::swift::EnumSyntheticFrontEnd::Update() {
+  m_element_name.Clear();
+  m_child_index = UINT32_MAX;
+  m_exe_ctx_ref = m_backend.GetExecutionContextRef();
+  m_element_name.SetCString(m_backend.GetValueAsCString());
+  m_child_index = m_backend.GetIndexOfChildWithName(m_element_name);
+  return false;
+}
+
+bool lldb_private::formatters::swift::EnumSyntheticFrontEnd::
+    MightHaveChildren() {
+  return m_child_index != UINT32_MAX;
+}
+
+size_t
+lldb_private::formatters::swift::EnumSyntheticFrontEnd::GetIndexOfChildWithName(
+    const ConstString &name) {
+  if (name == m_element_name)
+    return 0;
+  return UINT32_MAX;
+}
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::EnumSyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return NULL;
+  return (new EnumSyntheticFrontEnd(valobj_sp));
+}
+
+bool lldb_private::formatters::swift::ObjC_Selector_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  static ConstString g_ptr("ptr");
+  static ConstString g__rawValue("_rawValue");
+
+  ValueObjectSP ptr_sp(valobj.GetChildAtNamePath({g_ptr, g__rawValue}));
+  if (!ptr_sp)
+    return false;
+
+  auto ptr_value = ptr_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+
+  if (0 == ptr_value || LLDB_INVALID_ADDRESS == ptr_value)
+    return false;
+
+  StringPrinter::ReadStringAndDumpToStreamOptions read_options;
+  read_options.SetLocation(ptr_value)
+      .SetProcessSP(valobj.GetProcessSP())
+      .SetStream(&stream)
+      .SetQuote('"')
+      .SetNeedsZeroTermination(true)
+      .SetLanguage(lldb::eLanguageTypeSwift);
+
+  return StringPrinter::ReadStringAndDumpToStream<
+      StringPrinter::StringElementType::ASCII>(read_options);
+}
+
+template <int Key> struct TypePreservingNSNumber;
+
+template <> struct TypePreservingNSNumber<0> {
+  typedef int64_t SixtyFourValueType;
+  typedef int32_t ThirtyTwoValueType;
+
+  static constexpr const char *FormatString = "Int(%" PRId64 ")";
+};
+
+template <> struct TypePreservingNSNumber<1> {
+  typedef int64_t ValueType;
+  static constexpr const char *FormatString = "Int64(%" PRId64 ")";
+};
+
+template <> struct TypePreservingNSNumber<2> {
+  typedef int32_t ValueType;
+  static constexpr const char *FormatString = "Int32(%" PRId32 ")";
+};
+
+template <> struct TypePreservingNSNumber<3> {
+  typedef int16_t ValueType;
+  static constexpr const char *FormatString = "Int16(%" PRId16 ")";
+};
+
+template <> struct TypePreservingNSNumber<4> {
+  typedef int8_t ValueType;
+  static constexpr const char *FormatString = "Int8(%" PRId8 ")";
+};
+
+template <> struct TypePreservingNSNumber<5> {
+  typedef uint64_t SixtyFourValueType;
+  typedef uint32_t ThirtyTwoValueType;
+
+  static constexpr const char *FormatString = "UInt(%" PRIu64 ")";
+};
+
+template <> struct TypePreservingNSNumber<6> {
+  typedef uint64_t ValueType;
+  static constexpr const char *FormatString = "UInt64(%" PRIu64 ")";
+};
+
+template <> struct TypePreservingNSNumber<7> {
+  typedef uint32_t ValueType;
+  static constexpr const char *FormatString = "UInt32(%" PRIu32 ")";
+};
+
+template <> struct TypePreservingNSNumber<8> {
+  typedef uint16_t ValueType;
+  static constexpr const char *FormatString = "UInt16(%" PRIu16 ")";
+};
+
+template <> struct TypePreservingNSNumber<9> {
+  typedef uint8_t ValueType;
+  static constexpr const char *FormatString = "UInt8(%" PRIu8 ")";
+};
+
+template <> struct TypePreservingNSNumber<10> {
+  typedef float ValueType;
+  static constexpr const char *FormatString = "Float(%f)";
+};
+
+template <> struct TypePreservingNSNumber<11> {
+  typedef double ValueType;
+  static constexpr const char *FormatString = "Double(%f)";
+};
+
+template <> struct TypePreservingNSNumber<12> {
+  typedef double SixtyFourValueType;
+  typedef float ThirtyTwoValueType;
+
+  static constexpr const char *FormatString = "CGFloat(%f)";
+};
+
+template <> struct TypePreservingNSNumber<13> {
+  typedef bool ValueType;
+  static constexpr const char *FormatString = "Bool(%d)";
+};
+
+template <int Key,
+          typename Value = typename TypePreservingNSNumber<Key>::ValueType>
+bool PrintTypePreservingNSNumber(DataBufferSP buffer_sp, Stream &stream) {
+  Value value;
+  memcpy(&value, buffer_sp->GetBytes(), sizeof(value));
+  stream.Printf(TypePreservingNSNumber<Key>::FormatString, value);
+  return true;
+}
+
+template <>
+bool PrintTypePreservingNSNumber<13, void>(DataBufferSP buffer_sp,
+                                           Stream &stream) {
+  typename TypePreservingNSNumber<13>::ValueType value;
+  memcpy(&value, buffer_sp->GetBytes(), sizeof(value));
+  stream.PutCString(value ? "true" : "false");
+  return true;
+}
+
+template <int Key,
+          typename SixtyFour =
+              typename TypePreservingNSNumber<Key>::SixtyFourValueType,
+          typename ThirtyTwo =
+              typename TypePreservingNSNumber<Key>::ThirtyTwoValueType>
+bool PrintTypePreservingNSNumber(DataBufferSP buffer_sp, ProcessSP process_sp,
+                                 Stream &stream) {
+  switch (process_sp->GetAddressByteSize()) {
+  case 4: {
+    ThirtyTwo value;
+    memcpy(&value, buffer_sp->GetBytes(), sizeof(value));
+    stream.Printf(TypePreservingNSNumber<Key>::FormatString, (SixtyFour)value);
+    return true;
+  }
+  case 8: {
+    SixtyFour value;
+    memcpy(&value, buffer_sp->GetBytes(), sizeof(value));
+    stream.Printf(TypePreservingNSNumber<Key>::FormatString, value);
+    return true;
+  }
+  }
+
+  llvm_unreachable("unknown address byte size");
+}
+
+bool lldb_private::formatters::swift::TypePreservingNSNumber_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  lldb::addr_t ptr_value(valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS));
+  if (ptr_value == LLDB_INVALID_ADDRESS)
+    return false;
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return false;
+
+  uint32_t ptr_size = process_sp->GetAddressByteSize();
+  const uint32_t size_of_tag = 1;
+  const uint32_t size_of_payload = 8;
+
+  lldb::addr_t addr_of_payload = ptr_value + ptr_size;
+  lldb::addr_t addr_of_tag = addr_of_payload + size_of_payload;
+
+  Status read_error;
+  uint64_t tag = process_sp->ReadUnsignedIntegerFromMemory(
+      addr_of_tag, size_of_tag, 0, read_error);
+  if (read_error.Fail())
+    return false;
+
+  DataBufferSP buffer_sp(new DataBufferHeap(size_of_payload, 0));
+  process_sp->ReadMemoryFromInferior(addr_of_payload, buffer_sp->GetBytes(),
+                                     size_of_payload, read_error);
+  if (read_error.Fail())
+    return false;
+
+#define PROCESS_DEPENDENT_TAG(Key)                                             \
+  case Key:                                                                    \
+    return PrintTypePreservingNSNumber<Key>(buffer_sp, process_sp, stream);
+#define PROCESS_INDEPENDENT_TAG(Key)                                           \
+  case Key:                                                                    \
+    return PrintTypePreservingNSNumber<Key>(buffer_sp, stream);
+
+  switch (tag) {
+    PROCESS_DEPENDENT_TAG(0);
+    PROCESS_INDEPENDENT_TAG(1);
+    PROCESS_INDEPENDENT_TAG(2);
+    PROCESS_INDEPENDENT_TAG(3);
+    PROCESS_INDEPENDENT_TAG(4);
+    PROCESS_DEPENDENT_TAG(5);
+    PROCESS_INDEPENDENT_TAG(6);
+    PROCESS_INDEPENDENT_TAG(7);
+    PROCESS_INDEPENDENT_TAG(8);
+    PROCESS_INDEPENDENT_TAG(9);
+    PROCESS_INDEPENDENT_TAG(10);
+    PROCESS_INDEPENDENT_TAG(11);
+    PROCESS_DEPENDENT_TAG(12);
+    PROCESS_INDEPENDENT_TAG(13);
+  default:
+    break;
+  }
+
+#undef PROCESS_DEPENDENT_TAG
+#undef PROCESS_INDEPENDENT_TAG
+
+  return false;
+}
diff --git a/source/Plugins/Language/Swift/SwiftFormatters.h b/source/Plugins/Language/Swift/SwiftFormatters.h
index e69de29bb..202fc0a28 100644
--- a/source/Plugins/Language/Swift/SwiftFormatters.h
+++ b/source/Plugins/Language/Swift/SwiftFormatters.h
@@ -0,0 +1,104 @@
+//===-- SwiftFormatters.h ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftFormatters_h_
+#define liblldb_SwiftFormatters_h_
+
+#include "lldb/lldb-forward.h"
+#include <stdint.h>
+
+#include "lldb/DataFormatters/FormatClasses.h"
+#include "lldb/DataFormatters/StringPrinter.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+
+#include "FoundationValueTypes.h"
+#include "SwiftArray.h"
+#include "SwiftBasicTypes.h"
+#include "SwiftDictionary.h"
+#include "SwiftMetatype.h"
+#include "SwiftOptionSet.h"
+#include "SwiftOptional.h"
+#include "SwiftSet.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+bool Character_SummaryProvider(ValueObject &valobj, Stream &stream,
+                               const TypeSummaryOptions &options);
+
+bool UnicodeScalar_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                   const TypeSummaryOptions &options);
+
+bool StringCore_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                const TypeSummaryOptions &options);
+
+bool StringCore_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &,
+    StringPrinter::ReadStringAndDumpToStreamOptions);
+
+bool String_SummaryProvider(ValueObject &valobj, Stream &stream,
+                            const TypeSummaryOptions &options);
+
+bool String_SummaryProvider(ValueObject &valobj, Stream &stream,
+                            const TypeSummaryOptions &,
+                            StringPrinter::ReadStringAndDumpToStreamOptions);
+
+bool StaticString_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                  const TypeSummaryOptions &options);
+
+bool StaticString_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &,
+    StringPrinter::ReadStringAndDumpToStreamOptions);
+
+bool NSContiguousString_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                        const TypeSummaryOptions &options);
+
+bool Bool_SummaryProvider(ValueObject &valobj, Stream &stream,
+                          const TypeSummaryOptions &options);
+
+bool DarwinBoolean_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                   const TypeSummaryOptions &options);
+
+bool Range_SummaryProvider(ValueObject &valobj, Stream &stream,
+                           const TypeSummaryOptions &options);
+
+bool CountableRange_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                    const TypeSummaryOptions &options);
+
+bool ClosedRange_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                 const TypeSummaryOptions &options);
+
+bool CountableClosedRange_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                          const TypeSummaryOptions &options);
+
+bool StridedRangeGenerator_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                           const TypeSummaryOptions &options);
+
+// TODO: this is a transient workaround for the fact that
+// ObjC types are totally opaque in Swift for LLDB
+bool BuiltinObjC_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                 const TypeSummaryOptions &options);
+
+bool ObjC_Selector_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                   const TypeSummaryOptions &options);
+
+bool TypePreservingNSNumber_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                            const TypeSummaryOptions &options);
+
+SyntheticChildrenFrontEnd *EnumSyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                                        lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftFormatters_h_
diff --git a/source/Plugins/Language/Swift/SwiftHashedContainer.cpp b/source/Plugins/Language/Swift/SwiftHashedContainer.cpp
index e69de29bb..4e1179566 100644
--- a/source/Plugins/Language/Swift/SwiftHashedContainer.cpp
+++ b/source/Plugins/Language/Swift/SwiftHashedContainer.cpp
@@ -0,0 +1,525 @@
+//===-- SwiftHashedContainer.cpp --------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftHashedContainer.h"
+
+#include "lldb/Core/ValueObjectConstResult.h"
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Target/ObjCLanguageRuntime.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Utility/DataBufferHeap.h"
+
+#include "Plugins/Language/ObjC/NSDictionary.h"
+
+#include "swift/AST/ASTContext.h"
+#include "llvm/ADT/StringRef.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+//#define DICTIONARY_IS_BROKEN_AGAIN 1
+
+size_t SwiftHashedContainerSyntheticFrontEndBufferHandler::GetCount() {
+  return m_frontend->CalculateNumChildren();
+}
+
+lldb_private::CompilerType
+SwiftHashedContainerSyntheticFrontEndBufferHandler::GetElementType() {
+  // this doesn't make sense here - the synthetic children know best
+  return CompilerType();
+}
+
+lldb::ValueObjectSP
+SwiftHashedContainerSyntheticFrontEndBufferHandler::GetElementAtIndex(
+    size_t idx) {
+  return m_frontend->GetChildAtIndex(idx);
+}
+
+SwiftHashedContainerSyntheticFrontEndBufferHandler::
+    SwiftHashedContainerSyntheticFrontEndBufferHandler(
+        lldb::ValueObjectSP valobj_sp)
+    : m_valobj_sp(valobj_sp),
+      m_frontend(NSDictionarySyntheticFrontEndCreator(nullptr, valobj_sp)) {
+  // Cocoa frontends must be updated before use
+  if (m_frontend)
+    m_frontend->Update();
+}
+
+bool SwiftHashedContainerSyntheticFrontEndBufferHandler::IsValid() {
+  return m_frontend.get() != nullptr;
+}
+
+size_t SwiftHashedContainerNativeBufferHandler::GetCount() { return m_count; }
+
+lldb_private::CompilerType
+SwiftHashedContainerNativeBufferHandler::GetElementType() {
+  return m_element_type;
+}
+
+lldb::ValueObjectSP
+SwiftHashedContainerNativeBufferHandler::GetElementAtIndex(size_t idx) {
+  lldb::ValueObjectSP null_valobj_sp;
+  if (idx >= m_count)
+    return null_valobj_sp;
+  if (!IsValid())
+    return null_valobj_sp;
+  int64_t found_idx = -1;
+  for (Cell cell_idx = 0; cell_idx < m_capacity; cell_idx++) {
+    const bool used = ReadBitmaskAtIndex(cell_idx);
+    if (!used)
+      continue;
+    if (++found_idx == idx) {
+#ifdef DICTIONARY_IS_BROKEN_AGAIN
+      printf("found idx = %zu at cell_idx = %" PRIu64 "\n", idx, cell_idx);
+#endif
+
+      // you found it!!!
+      DataBufferSP full_buffer_sp(
+          new DataBufferHeap(m_key_stride + m_value_stride, 0));
+      uint8_t *key_buffer_ptr = full_buffer_sp->GetBytes();
+      uint8_t *value_buffer_ptr =
+          m_value_stride ? (key_buffer_ptr + m_key_stride) : nullptr;
+      if (GetDataForKeyAtCell(cell_idx, key_buffer_ptr) &&
+          (value_buffer_ptr == nullptr ||
+           GetDataForValueAtCell(cell_idx, value_buffer_ptr))) {
+        DataExtractor full_data;
+        full_data.SetData(full_buffer_sp);
+        StreamString name;
+        name.Printf("[%zu]", idx);
+        return ValueObjectConstResult::Create(
+            m_process, m_element_type, ConstString(name.GetData()), full_data);
+      }
+    }
+  }
+  return null_valobj_sp;
+}
+
+bool SwiftHashedContainerNativeBufferHandler::ReadBitmaskAtIndex(Index i) {
+  if (i >= m_capacity)
+    return false;
+  const size_t word = i / (8 * m_ptr_size);
+  const size_t offset = i % (8 * m_ptr_size);
+  Status error;
+  const lldb::addr_t effective_ptr = m_bitmask_ptr + (word * m_ptr_size);
+#ifdef DICTIONARY_IS_BROKEN_AGAIN
+  printf("for idx = %" PRIu64
+         ", reading at word = %zu offset = %zu, effective_ptr = 0x%" PRIx64
+         "\n",
+         i, word, offset, effective_ptr);
+#endif
+
+  uint64_t data = 0;
+
+  auto cached = m_bitmask_cache.find(effective_ptr);
+  if (cached != m_bitmask_cache.end()) {
+    data = cached->second;
+  } else {
+    data = m_process->ReadUnsignedIntegerFromMemory(effective_ptr, m_ptr_size,
+                                                    0, error);
+    if (error.Fail())
+      return false;
+    m_bitmask_cache[effective_ptr] = data;
+  }
+
+  const uint64_t mask = static_cast<uint64_t>(1UL << offset);
+  const uint64_t value = (data & mask);
+#ifdef DICTIONARY_IS_BROKEN_AGAIN
+  printf("data = 0x%" PRIx64 ", mask = 0x%" PRIx64 ", value = 0x%" PRIx64 "\n",
+         data, mask, value);
+#endif
+  return (0 != value);
+}
+
+lldb::addr_t
+SwiftHashedContainerNativeBufferHandler::GetLocationOfKeyAtCell(Cell i) {
+  return m_keys_ptr + (i * m_key_stride);
+}
+
+lldb::addr_t
+SwiftHashedContainerNativeBufferHandler::GetLocationOfValueAtCell(Cell i) {
+  return m_value_stride ? m_values_ptr + (i * m_value_stride)
+                        : LLDB_INVALID_ADDRESS;
+}
+
+// these are sharp tools that assume that the Cell contains valid data and the
+// destination buffer
+// has enough room to store the data to - use with caution
+bool SwiftHashedContainerNativeBufferHandler::GetDataForKeyAtCell(
+    Cell i, void *data_ptr) {
+  if (!data_ptr)
+    return false;
+
+  lldb::addr_t addr = GetLocationOfKeyAtCell(i);
+  Status error;
+  m_process->ReadMemory(addr, data_ptr, m_key_stride, error);
+  if (error.Fail())
+    return false;
+
+  return true;
+}
+
+bool SwiftHashedContainerNativeBufferHandler::GetDataForValueAtCell(
+    Cell i, void *data_ptr) {
+  if (!data_ptr || !m_value_stride)
+    return false;
+
+  lldb::addr_t addr = GetLocationOfValueAtCell(i);
+  Status error;
+  m_process->ReadMemory(addr, data_ptr, m_value_stride, error);
+  if (error.Fail())
+    return false;
+
+  return true;
+}
+
+SwiftHashedContainerNativeBufferHandler::
+    SwiftHashedContainerNativeBufferHandler(
+        lldb::ValueObjectSP nativeStorage_sp, CompilerType key_type,
+        CompilerType value_type)
+    : m_nativeStorage(nativeStorage_sp.get()), m_process(nullptr),
+      m_ptr_size(0), m_count(0), m_capacity(0),
+      m_bitmask_ptr(LLDB_INVALID_ADDRESS), m_keys_ptr(LLDB_INVALID_ADDRESS),
+      m_values_ptr(LLDB_INVALID_ADDRESS), m_element_type(),
+      m_key_stride(key_type.GetByteStride()), m_value_stride(0),
+      m_bitmask_cache() {
+  static ConstString g_initializedEntries("initializedEntries");
+  static ConstString g_values("values");
+  static ConstString g__rawValue("_rawValue");
+  static ConstString g_keys("keys");
+  static ConstString g_buffer("buffer");
+
+  static ConstString g_key("key");
+  static ConstString g_value("value");
+  static ConstString g__value("_value");
+
+  static ConstString g_capacity("capacity");
+  static ConstString g_count("count");
+
+  if (!m_nativeStorage)
+    return;
+  if (!key_type)
+    return;
+
+  if (value_type) {
+    m_value_stride = value_type.GetByteStride();
+    if (SwiftASTContext *swift_ast =
+            llvm::dyn_cast_or_null<SwiftASTContext>(key_type.GetTypeSystem())) {
+      std::vector<SwiftASTContext::TupleElement> tuple_elements{
+          {g_key, key_type}, {g_value, value_type}};
+      m_element_type = swift_ast->CreateTupleType(tuple_elements);
+    }
+  } else
+    m_element_type = key_type;
+
+  if (!m_element_type)
+    return;
+
+  m_process = m_nativeStorage->GetProcessSP().get();
+  if (!m_process)
+    return;
+
+  m_ptr_size = m_process->GetAddressByteSize();
+
+  auto buffer_sp = m_nativeStorage->GetChildAtNamePath({g_buffer});
+  if (buffer_sp) {
+    auto buffer_ptr = buffer_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+    if (buffer_ptr == 0 || buffer_ptr == LLDB_INVALID_ADDRESS)
+      return;
+
+    Status error;
+    m_capacity =
+        m_process->ReadPointerFromMemory(buffer_ptr + 2 * m_ptr_size, error);
+    if (error.Fail())
+      return;
+    m_count =
+        m_process->ReadPointerFromMemory(buffer_ptr + 3 * m_ptr_size, error);
+    if (error.Fail())
+      return;
+  } else {
+    m_capacity = m_nativeStorage->GetChildAtNamePath({g_capacity, g__value})
+                     ->GetValueAsUnsigned(0);
+    m_count = m_nativeStorage->GetChildAtNamePath({g_count, g__value})
+                  ->GetValueAsUnsigned(0);
+  }
+
+  m_nativeStorage = nativeStorage_sp.get();
+  m_bitmask_ptr =
+      m_nativeStorage
+          ->GetChildAtNamePath({g_initializedEntries, g_values, g__rawValue})
+          ->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+
+  if (ValueObjectSP value_child_sp =
+          m_nativeStorage->GetChildAtNamePath({g_values, g__rawValue})) {
+    // it is fine not to pass a value_type, but if the value child exists, then
+    // you have to pass one
+    if (!value_type)
+      return;
+    m_values_ptr = value_child_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  }
+  m_keys_ptr = m_nativeStorage->GetChildAtNamePath({g_keys, g__rawValue})
+                   ->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+}
+
+bool SwiftHashedContainerNativeBufferHandler::IsValid() {
+  return (m_nativeStorage != nullptr) && (m_process != nullptr) &&
+         m_element_type.IsValid() && m_bitmask_ptr != LLDB_INVALID_ADDRESS &&
+         m_keys_ptr != LLDB_INVALID_ADDRESS &&
+         /*m_values_ptr != LLDB_INVALID_ADDRESS && you can't check values
+            because some containers have only keys*/
+         m_capacity >= m_count;
+}
+
+std::unique_ptr<SwiftHashedContainerBufferHandler>
+SwiftHashedContainerBufferHandler::CreateBufferHandlerForNativeStorageOwner(
+    ValueObject &valobj, lldb::addr_t storage_ptr, bool fail_on_no_children,
+    NativeCreatorFunction Native) {
+
+  CompilerType valobj_type(valobj.GetCompilerType());
+  lldb::TemplateArgumentKind kind;
+  CompilerType key_type = valobj_type.GetTemplateArgument(0, kind);
+  CompilerType value_type = valobj_type.GetTemplateArgument(1, kind);
+
+  static ConstString g_Native("native");
+  static ConstString g_nativeStorage("nativeStorage");
+  static ConstString g_buffer("buffer");
+
+  Status error;
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return nullptr;
+
+  ValueObjectSP native_sp(valobj.GetChildAtNamePath({g_nativeStorage}));
+  ValueObjectSP native_buffer_sp(
+      valobj.GetChildAtNamePath({g_nativeStorage, g_buffer}));
+  if (!native_sp || !native_buffer_sp) {
+    if (fail_on_no_children)
+      return nullptr;
+    else {
+      lldb::addr_t native_storage_ptr =
+          storage_ptr + (3 * process_sp->GetAddressByteSize());
+      native_storage_ptr =
+          process_sp->ReadPointerFromMemory(native_storage_ptr, error);
+      // (AnyObject,AnyObject)?
+      SwiftASTContext *swift_ast_ctx =
+          process_sp->GetTarget().GetScratchSwiftASTContext(error);
+      if (swift_ast_ctx) {
+        CompilerType element_type(swift_ast_ctx->GetTypeFromMangledTypename(
+            SwiftLanguageRuntime::GetCurrentMangledName(
+                "_TtGSqTPs9AnyObject_PS____")
+                .c_str(),
+            error));
+        auto handler = std::unique_ptr<SwiftHashedContainerBufferHandler>(
+            Native(native_sp, key_type, value_type));
+        if (handler && handler->IsValid())
+          return handler;
+      }
+      return nullptr;
+    }
+  }
+
+  CompilerType child_type(native_sp->GetCompilerType());
+  CompilerType element_type(child_type.GetTemplateArgument(1, kind));
+  if (element_type.IsValid() == false ||
+      kind != lldb::eTemplateArgumentKindType)
+    return nullptr;
+  lldb::addr_t native_storage_ptr = process_sp->ReadPointerFromMemory(
+      storage_ptr + 2 * process_sp->GetAddressByteSize(), error);
+  if (error.Fail() || native_storage_ptr == LLDB_INVALID_ADDRESS)
+    return nullptr;
+  auto handler = std::unique_ptr<SwiftHashedContainerBufferHandler>(
+      Native(native_sp, key_type, value_type));
+  if (handler && handler->IsValid())
+    return handler;
+
+  return nullptr;
+}
+
+std::unique_ptr<SwiftHashedContainerBufferHandler>
+SwiftHashedContainerBufferHandler::CreateBufferHandler(
+    ValueObject &valobj, NativeCreatorFunction Native,
+    SyntheticCreatorFunction Synthetic, ConstString mangled,
+    ConstString demangled) {
+  static ConstString g__variantStorage("_variantStorage");
+  static ConstString g__variantBuffer("_variantBuffer");
+  static ConstString g_Native("native");
+  static ConstString g_Cocoa("cocoa");
+  static ConstString g_nativeStorage("nativeStorage");
+  static ConstString g_nativeBuffer("nativeBuffer");
+  static ConstString g_buffer("buffer");
+  static ConstString g_storage("storage");
+  static ConstString g__storage("_storage");
+  static ConstString g_Some("some");
+
+  Status error;
+
+  ProcessSP process_sp(valobj.GetProcessSP());
+  if (!process_sp)
+    return nullptr;
+
+  ConstString type_name_cs(valobj.GetTypeName());
+  if (type_name_cs) {
+    llvm::StringRef type_name_strref(type_name_cs.GetStringRef());
+
+    if (type_name_strref.startswith(mangled.GetCString()) ||
+        type_name_strref.startswith(demangled.GetCString())) {
+      return CreateBufferHandlerForNativeStorageOwner(
+          valobj, valobj.GetPointerValue(), false, Native);
+    }
+  }
+
+  ValueObjectSP valobj_sp =
+      valobj.GetSP()->GetQualifiedRepresentationIfAvailable(
+          lldb::eDynamicCanRunTarget, false);
+
+  ValueObjectSP _variantStorageSP(
+      valobj_sp->GetChildMemberWithName(g__variantStorage, true));
+
+  if (!_variantStorageSP)
+    _variantStorageSP =
+        valobj_sp->GetChildMemberWithName(g__variantBuffer, true);
+
+  if (!_variantStorageSP) {
+    static ConstString g__SwiftDeferredNSDictionary(
+        "Swift._SwiftDeferredNSDictionary");
+    if (type_name_cs.GetStringRef().startswith(
+            g__SwiftDeferredNSDictionary.GetStringRef())) {
+      ValueObjectSP storage_sp(
+          valobj_sp->GetChildAtNamePath({g_nativeBuffer, g__storage}));
+      if (storage_sp) {
+        CompilerType child_type(valobj_sp->GetCompilerType());
+        lldb::TemplateArgumentKind kind;
+        CompilerType key_type(child_type.GetTemplateArgument(0, kind));
+        CompilerType value_type(child_type.GetTemplateArgument(1, kind));
+
+        auto handler = std::unique_ptr<SwiftHashedContainerBufferHandler>(
+            Native(storage_sp, key_type, value_type));
+        if (handler && handler->IsValid())
+          return handler;
+      }
+    }
+    return nullptr;
+  }
+
+  ConstString storage_kind(_variantStorageSP->GetValueAsCString());
+
+  if (!storage_kind)
+    return nullptr;
+
+  if (g_Cocoa == storage_kind) {
+    ValueObjectSP child_sp(
+        _variantStorageSP->GetChildMemberWithName(g_Native, true));
+    if (!child_sp)
+      return nullptr;
+    // it's an NSDictionary in disguise
+    uint64_t cocoa_storage_ptr =
+        child_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+    if (cocoa_storage_ptr == LLDB_INVALID_ADDRESS || error.Fail())
+      return nullptr;
+    cocoa_storage_ptr &= 0x00FFFFFFFFFFFFFF; // for some reason I need to zero
+                                             // out the MSB; figure out why
+                                             // later
+    CompilerType id =
+        process_sp->GetTarget().GetScratchClangASTContext()->GetBasicType(
+            lldb::eBasicTypeObjCID);
+    InferiorSizedWord isw(cocoa_storage_ptr, *process_sp);
+    ValueObjectSP cocoarr_sp = ValueObject::CreateValueObjectFromData(
+        "cocoarr", isw.GetAsData(process_sp->GetByteOrder()),
+        valobj.GetExecutionContextRef(), id);
+    if (!cocoarr_sp)
+      return nullptr;
+    auto objc_runtime = process_sp->GetObjCLanguageRuntime();
+    auto descriptor_sp = objc_runtime->GetClassDescriptor(*cocoarr_sp);
+    if (!descriptor_sp)
+      return nullptr;
+    ConstString classname(descriptor_sp->GetClassName());
+    if (classname &&
+        classname.GetStringRef().startswith(mangled.GetCString())) {
+      return CreateBufferHandlerForNativeStorageOwner(
+          *_variantStorageSP, cocoa_storage_ptr, true, Native);
+    } else {
+      auto handler = std::unique_ptr<SwiftHashedContainerBufferHandler>(
+          Synthetic(cocoarr_sp));
+      if (handler && handler->IsValid())
+        return handler;
+      return nullptr;
+    }
+  }
+  if (g_Native == storage_kind) {
+    ValueObjectSP native_sp(_variantStorageSP->GetChildAtNamePath({g_Native}));
+    ValueObjectSP nativeStorage_sp(
+        _variantStorageSP->GetChildAtNamePath({g_Native, g_nativeStorage}));
+    if (!native_sp)
+      return nullptr;
+    if (!nativeStorage_sp)
+      nativeStorage_sp =
+          _variantStorageSP->GetChildAtNamePath({g_Native, g__storage});
+    if (!nativeStorage_sp)
+      return nullptr;
+
+    CompilerType child_type(valobj.GetCompilerType());
+    lldb::TemplateArgumentKind kind;
+    CompilerType key_type(child_type.GetTemplateArgument(0, kind));
+    CompilerType value_type(child_type.GetTemplateArgument(1, kind));
+
+    auto handler = std::unique_ptr<SwiftHashedContainerBufferHandler>(
+        Native(nativeStorage_sp, key_type, value_type));
+    if (handler && handler->IsValid())
+      return handler;
+    return nullptr;
+  }
+
+  return nullptr;
+}
+
+lldb_private::formatters::swift::HashedContainerSyntheticFrontEnd::
+    HashedContainerSyntheticFrontEnd(lldb::ValueObjectSP valobj_sp)
+    : SyntheticChildrenFrontEnd(*valobj_sp.get()), m_buffer() {}
+
+size_t lldb_private::formatters::swift::HashedContainerSyntheticFrontEnd::
+    CalculateNumChildren() {
+  return m_buffer ? m_buffer->GetCount() : 0;
+}
+
+lldb::ValueObjectSP lldb_private::formatters::swift::
+    HashedContainerSyntheticFrontEnd::GetChildAtIndex(size_t idx) {
+  if (!m_buffer)
+    return ValueObjectSP();
+
+  lldb::ValueObjectSP child_sp = m_buffer->GetElementAtIndex(idx);
+
+  if (child_sp)
+    child_sp->SetSyntheticChildrenGenerated(true);
+
+  return child_sp;
+}
+
+bool lldb_private::formatters::swift::HashedContainerSyntheticFrontEnd::
+    MightHaveChildren() {
+  return true;
+}
+
+size_t lldb_private::formatters::swift::HashedContainerSyntheticFrontEnd::
+    GetIndexOfChildWithName(const ConstString &name) {
+  if (!m_buffer)
+    return UINT32_MAX;
+  const char *item_name = name.GetCString();
+  uint32_t idx = ExtractIndexFromString(item_name);
+  if (idx < UINT32_MAX && idx >= CalculateNumChildren())
+    return UINT32_MAX;
+  return idx;
+}
diff --git a/source/Plugins/Language/Swift/SwiftHashedContainer.h b/source/Plugins/Language/Swift/SwiftHashedContainer.h
index e69de29bb..436dc3173 100644
--- a/source/Plugins/Language/Swift/SwiftHashedContainer.h
+++ b/source/Plugins/Language/Swift/SwiftHashedContainer.h
@@ -0,0 +1,191 @@
+//===-- SwiftHashedContainer.h ----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftHashedContainer_h_
+#define liblldb_SwiftHashedContainer_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "lldb/DataFormatters/FormatClasses.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+
+#include <functional>
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+
+// Some part of the buffer handling logic needs to be shared between summary and
+// synthetic children
+// If I was only making synthetic children, this would be best modelled as
+// different FrontEnds
+class SwiftHashedContainerBufferHandler {
+public:
+  enum class Kind { eDictionary, eSet };
+
+  virtual Kind GetKind() = 0;
+
+  virtual size_t GetCount() = 0;
+
+  virtual lldb_private::CompilerType GetElementType() = 0;
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t) = 0;
+
+  typedef std::function<SwiftHashedContainerBufferHandler *(
+      lldb::ValueObjectSP, CompilerType, CompilerType)>
+      NativeCreatorFunction;
+
+  typedef std::function<SwiftHashedContainerBufferHandler *(
+      lldb::ValueObjectSP)>
+      SyntheticCreatorFunction;
+
+  static std::unique_ptr<SwiftHashedContainerBufferHandler>
+  CreateBufferHandler(ValueObject &valobj, NativeCreatorFunction Native,
+                      SyntheticCreatorFunction Synthetic, ConstString mangled,
+                      ConstString demangled);
+
+  virtual ~SwiftHashedContainerBufferHandler() {}
+
+protected:
+  virtual bool IsValid() = 0;
+
+  static std::unique_ptr<SwiftHashedContainerBufferHandler>
+  CreateBufferHandlerForNativeStorageOwner(ValueObject &valobj,
+                                           lldb::addr_t storage_ptr,
+                                           bool fail_on_no_children,
+                                           NativeCreatorFunction Native);
+};
+
+class SwiftHashedContainerEmptyBufferHandler
+    : public SwiftHashedContainerBufferHandler {
+public:
+  virtual size_t GetCount() { return 0; }
+
+  virtual lldb_private::CompilerType GetElementType() { return m_elem_type; }
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t) {
+    return lldb::ValueObjectSP();
+  }
+
+  virtual ~SwiftHashedContainerEmptyBufferHandler() {}
+
+protected:
+  SwiftHashedContainerEmptyBufferHandler(CompilerType elem_type)
+      : m_elem_type(elem_type) {}
+  friend class SwiftHashedContainerBufferHandler;
+
+  virtual bool IsValid() { return true; }
+
+private:
+  lldb_private::CompilerType m_elem_type;
+};
+
+class SwiftHashedContainerNativeBufferHandler
+    : public SwiftHashedContainerBufferHandler {
+public:
+  virtual size_t GetCount();
+
+  virtual lldb_private::CompilerType GetElementType();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  virtual ~SwiftHashedContainerNativeBufferHandler() {}
+
+protected:
+  typedef uint64_t Index;
+  typedef uint64_t Cell;
+
+  SwiftHashedContainerNativeBufferHandler(lldb::ValueObjectSP nativeStorage_sp,
+                                          CompilerType key_type,
+                                          CompilerType value_type);
+  friend class SwiftHashedContainerBufferHandler;
+
+  virtual bool IsValid();
+
+  bool ReadBitmaskAtIndex(Index);
+
+  lldb::addr_t GetLocationOfKeyAtCell(Cell);
+
+  lldb::addr_t GetLocationOfValueAtCell(Cell);
+
+  bool GetDataForKeyAtCell(Cell, void *);
+
+  bool GetDataForValueAtCell(Cell, void *);
+
+private:
+  ValueObject *m_nativeStorage;
+  Process *m_process;
+  uint32_t m_ptr_size;
+  uint64_t m_count;
+  uint64_t m_capacity;
+  lldb::addr_t m_bitmask_ptr;
+  lldb::addr_t m_keys_ptr;
+  lldb::addr_t m_values_ptr;
+  CompilerType m_element_type;
+  uint64_t m_key_stride;
+  uint64_t m_value_stride;
+  std::map<lldb::addr_t, uint64_t> m_bitmask_cache;
+};
+
+class SwiftHashedContainerSyntheticFrontEndBufferHandler
+    : public SwiftHashedContainerBufferHandler {
+public:
+  virtual size_t GetCount();
+
+  virtual lldb_private::CompilerType GetElementType();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  virtual ~SwiftHashedContainerSyntheticFrontEndBufferHandler() {}
+
+protected:
+  SwiftHashedContainerSyntheticFrontEndBufferHandler(
+      lldb::ValueObjectSP valobj_sp);
+  friend class SwiftHashedContainerBufferHandler;
+
+  virtual bool IsValid();
+
+private:
+  lldb::ValueObjectSP m_valobj_sp; // reader beware: this entails you must only
+                                   // pass self-rooted valueobjects to this
+                                   // class
+  std::unique_ptr<SyntheticChildrenFrontEnd> m_frontend;
+};
+
+class HashedContainerSyntheticFrontEnd : public SyntheticChildrenFrontEnd {
+public:
+  HashedContainerSyntheticFrontEnd(lldb::ValueObjectSP valobj_sp);
+
+  virtual size_t CalculateNumChildren();
+
+  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx);
+
+  virtual bool Update() = 0;
+
+  virtual bool MightHaveChildren();
+
+  virtual size_t GetIndexOfChildWithName(const ConstString &name);
+
+  virtual ~HashedContainerSyntheticFrontEnd() = default;
+
+protected:
+  std::unique_ptr<SwiftHashedContainerBufferHandler> m_buffer;
+};
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftHashedContainer_h_
diff --git a/source/Plugins/Language/Swift/SwiftLanguage.cpp b/source/Plugins/Language/Swift/SwiftLanguage.cpp
index e69de29bb..d7bfca6b3 100644
--- a/source/Plugins/Language/Swift/SwiftLanguage.cpp
+++ b/source/Plugins/Language/Swift/SwiftLanguage.cpp
@@ -0,0 +1,1851 @@
+//===-- SwiftLanguage.cpp ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftLanguage.h"
+
+#include "lldb/Core/PluginManager.h"
+#include "lldb/Core/ValueObject.h"
+#include "lldb/Core/ValueObjectVariable.h"
+#include "lldb/Utility/ConstString.h"
+
+#include "lldb/DataFormatters/DataVisualization.h"
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/DataFormatters/StringPrinter.h"
+
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/CompileUnit.h"
+#include "lldb/Symbol/Function.h"
+#include "lldb/Symbol/Variable.h"
+#include "lldb/Symbol/VariableList.h"
+
+#include "lldb/Target/SwiftLanguageRuntime.h"
+
+#include "ObjCRuntimeSyntheticProvider.h"
+#include "SwiftFormatters.h"
+
+#include <functional>
+#include <mutex>
+
+#include "swift/AST/Module.h"
+#include "swift/AST/Type.h"
+#include "swift/AST/Types.h"
+#include "swift/Demangling/ManglingMacros.h"
+#include "llvm/Support/ConvertUTF.h"
+
+#include "Plugins/Language/ObjC/Cocoa.h"
+#include "Plugins/Language/ObjC/NSDictionary.h"
+#include "Plugins/Language/ObjC/NSSet.h"
+#include "Plugins/Language/ObjC/NSString.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+#ifndef LLDB_DISABLE_PYTHON
+using lldb_private::formatters::AddCXXSummary;
+using lldb_private::formatters::AddCXXSynthetic;
+#endif
+using lldb_private::formatters::AddFormat;
+using lldb_private::formatters::AddStringSummary;
+using lldb_private::formatters::AddSummary;
+
+void SwiftLanguage::Initialize() {
+  static ConstString g_NSDictionaryClass1(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCSs29_NativeDictionaryStorageOwner"));
+  static ConstString g_NSDictionaryClass2(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs29_NativeDictionaryStorageOwner"));
+  static ConstString g_NSDictionaryClass3Old(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtGCs29_NativeDictionaryStorageOwner"));
+  static ConstString g_NSDictionaryClass3(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          MANGLING_PREFIX_STR "s29_NativeDictionaryStorageOwner"));
+  static ConstString g_NSDictionaryClass4Old(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtGCs26_SwiftDeferredNSDictionary"));
+  static ConstString g_NSDictionaryClass4(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          MANGLING_PREFIX_STR "s26_SwiftDeferredNSDictionary"));
+
+  static ConstString g_NSSetClass1(SwiftLanguageRuntime::GetCurrentMangledName(
+      "_TtCSs22_NativeSetStorageOwner"));
+  static ConstString g_NSSetClass2(SwiftLanguageRuntime::GetCurrentMangledName(
+      "_TtCs22_NativeSetStorageOwner"));
+  static ConstString g_NSStringClass1(
+      SwiftLanguageRuntime::GetCurrentMangledName("_NSContiguousString"));
+  static ConstString g_NSStringClass2(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCSs19_NSContiguousString"));
+  static ConstString g_NSStringClass3Old("_TtCs19_NSContiguousString");
+  static ConstString g_NSStringClass3(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs19_NSContiguousString"));
+  static ConstString g_NSArrayClass1Old("_TtCs21_SwiftDeferredNSArray");
+  static ConstString g_NSArrayClass1(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs21_SwiftDeferredNSArray"));
+
+  PluginManager::RegisterPlugin(GetPluginNameStatic(), "Swift Language",
+                                CreateInstance);
+
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSummaries()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetFullMatch(g_NSDictionaryClass1),
+                  lldb_private::formatters::swift::Dictionary_SummaryProvider});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSummaries()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetFullMatch(g_NSDictionaryClass2),
+                  lldb_private::formatters::swift::Dictionary_SummaryProvider});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSummaries()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass3Old),
+                  lldb_private::formatters::swift::Dictionary_SummaryProvider});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSummaries()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass3),
+                  lldb_private::formatters::swift::Dictionary_SummaryProvider});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSummaries()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass4Old),
+                  lldb_private::formatters::swift::Dictionary_SummaryProvider});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSummaries()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass4),
+                  lldb_private::formatters::swift::Dictionary_SummaryProvider});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSynthetics()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetFullMatch(g_NSDictionaryClass1),
+                  lldb_private::formatters::swift::
+                      DictionarySyntheticFrontEndCreator});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSynthetics()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetFullMatch(g_NSDictionaryClass2),
+                  lldb_private::formatters::swift::
+                      DictionarySyntheticFrontEndCreator});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSynthetics()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass3Old),
+                  lldb_private::formatters::swift::
+                      DictionarySyntheticFrontEndCreator});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSynthetics()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass3),
+                  lldb_private::formatters::swift::
+                      DictionarySyntheticFrontEndCreator});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSynthetics()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass4Old),
+                  lldb_private::formatters::swift::
+                      DictionarySyntheticFrontEndCreator});
+  lldb_private::formatters::NSDictionary_Additionals::GetAdditionalSynthetics()
+      .push_back({lldb_private::formatters::NSDictionary_Additionals::
+                      AdditionalFormatterMatching()
+                          .GetPrefixMatch(g_NSDictionaryClass4),
+                  lldb_private::formatters::swift::
+                      DictionarySyntheticFrontEndCreator});
+
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSummaries().emplace(
+      g_NSSetClass1, lldb_private::formatters::swift::Set_SummaryProvider);
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSynthetics()
+      .emplace(g_NSSetClass1,
+               lldb_private::formatters::swift::SetSyntheticFrontEndCreator);
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSummaries().emplace(
+      g_NSSetClass2, lldb_private::formatters::swift::Set_SummaryProvider);
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSynthetics()
+      .emplace(g_NSSetClass2,
+               lldb_private::formatters::swift::SetSyntheticFrontEndCreator);
+
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .emplace(
+          g_NSStringClass1,
+          lldb_private::formatters::swift::NSContiguousString_SummaryProvider);
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .emplace(
+          g_NSStringClass2,
+          lldb_private::formatters::swift::NSContiguousString_SummaryProvider);
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .emplace(
+          g_NSStringClass3,
+          lldb_private::formatters::swift::NSContiguousString_SummaryProvider);
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .emplace(
+          g_NSStringClass3Old,
+          lldb_private::formatters::swift::NSContiguousString_SummaryProvider);
+
+  lldb_private::formatters::NSArray_Additionals::GetAdditionalSummaries()
+      .emplace(g_NSArrayClass1,
+               lldb_private::formatters::swift::Array_SummaryProvider);
+  lldb_private::formatters::NSArray_Additionals::GetAdditionalSummaries()
+      .emplace(g_NSArrayClass1Old,
+               lldb_private::formatters::swift::Array_SummaryProvider);
+  lldb_private::formatters::NSArray_Additionals::GetAdditionalSynthetics()
+      .emplace(g_NSArrayClass1,
+               lldb_private::formatters::swift::ArraySyntheticFrontEndCreator);
+}
+
+void SwiftLanguage::Terminate() {
+  // FIXME: Duplicating this list from Initialize seems error-prone.
+  static ConstString g_NSDictionaryClass1(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCSs29_NativeDictionaryStorageOwner"));
+  static ConstString g_NSDictionaryClass2(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs29_NativeDictionaryStorageOwner"));
+  static ConstString g_NSSetClass1(SwiftLanguageRuntime::GetCurrentMangledName(
+      "_TtCSs22_NativeSetStorageOwner"));
+  static ConstString g_NSSetClass2(SwiftLanguageRuntime::GetCurrentMangledName(
+      "_TtCs22_NativeSetStorageOwner"));
+  static ConstString g_NSStringClass1(
+      SwiftLanguageRuntime::GetCurrentMangledName("_NSContiguousString"));
+  static ConstString g_NSStringClass2(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCSs19_NSContiguousString"));
+  static ConstString g_NSStringClass3Old("_TtCs19_NSContiguousString");
+  static ConstString g_NSStringClass3(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs19_NSContiguousString"));
+  static ConstString g_NSArrayClass1Old("_TtCs21_SwiftDeferredNSArray");
+  static ConstString g_NSArrayClass1(
+      SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs21_SwiftDeferredNSArray"));
+
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSummaries().erase(
+      g_NSSetClass1);
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSynthetics().erase(
+      g_NSSetClass1);
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSummaries().erase(
+      g_NSSetClass2);
+  lldb_private::formatters::NSSet_Additionals::GetAdditionalSynthetics().erase(
+      g_NSSetClass2);
+
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .erase(g_NSStringClass1);
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .erase(g_NSStringClass2);
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .erase(g_NSStringClass3);
+  lldb_private::formatters::NSString_Additionals::GetAdditionalSummaries()
+      .erase(g_NSStringClass3Old);
+
+  lldb_private::formatters::NSArray_Additionals::GetAdditionalSummaries().erase(
+      g_NSArrayClass1);
+  lldb_private::formatters::NSArray_Additionals::GetAdditionalSummaries().erase(
+      g_NSArrayClass1Old);
+  lldb_private::formatters::NSArray_Additionals::GetAdditionalSynthetics()
+      .erase(g_NSArrayClass1);
+
+  PluginManager::UnregisterPlugin(CreateInstance);
+}
+
+lldb_private::ConstString SwiftLanguage::GetPluginNameStatic() {
+  static ConstString g_name("swift");
+  return g_name;
+}
+
+bool SwiftLanguage::IsTopLevelFunction(Function &function) {
+  static ConstString g_main("main");
+
+  if (CompileUnit *comp_unit = function.GetCompileUnit()) {
+    if (comp_unit->GetLanguage() == lldb::eLanguageTypeSwift) {
+      if (function.GetMangled().GetMangledName() == g_main)
+        return true;
+    }
+  }
+
+  return false;
+}
+
+static void LoadSwiftFormatters(lldb::TypeCategoryImplSP swift_category_sp) {
+  if (!swift_category_sp)
+    return;
+
+  TypeSummaryImpl::Flags summary_flags;
+  summary_flags.SetCascades(true)
+      .SetSkipPointers(true)
+      .SetSkipReferences(true)
+      .SetDontShowChildren(true)
+      .SetDontShowValue(true)
+      .SetShowMembersOneLiner(false)
+      .SetHideItemNames(false);
+
+  TypeFormatImpl::Flags format_flags;
+  format_flags.SetCascades(true).SetSkipPointers(true).SetSkipReferences(true);
+
+  SyntheticChildren::Flags basic_synth_flags;
+  basic_synth_flags.SetCascades(true).SetSkipPointers(true).SetSkipReferences(
+      true);
+
+#ifndef LLDB_DISABLE_PYTHON
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::ObjC_Selector_SummaryProvider,
+                "ObjectiveC.Selector", ConstString("ObjectiveC.Selector"),
+                summary_flags);
+
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Int64", ConstString("Swift.Int64"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Int32", ConstString("Swift.Int32"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Int16", ConstString("Swift.Int16"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Int8", ConstString("Swift.Int8"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Int", ConstString("Swift.Int"), basic_synth_flags);
+
+  AddFormat(swift_category_sp, lldb::eFormatDecimal, ConstString("Swift.Int64"),
+            format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatDecimal, ConstString("Swift.Int32"),
+            format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatDecimal, ConstString("Swift.Int16"),
+            format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatDecimal, ConstString("Swift.Int8"),
+            format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatDecimal, ConstString("Swift.Int"),
+            format_flags, false);
+
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UInt64", ConstString("Swift.UInt64"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UInt32", ConstString("Swift.UInt32"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UInt16", ConstString("Swift.UInt16"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UInt8", ConstString("Swift.UInt8"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UInt", ConstString("Swift.UInt"), basic_synth_flags);
+
+  AddFormat(swift_category_sp, lldb::eFormatUnsigned,
+            ConstString("Swift.UInt64"), format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatUnsigned,
+            ConstString("Swift.UInt32"), format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatUnsigned,
+            ConstString("Swift.UInt16"), format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatUnsigned,
+            ConstString("Swift.UInt8"), format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatUnsigned, ConstString("Swift.UInt"),
+            format_flags, false);
+
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Float32", ConstString("Swift.Float32"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Float64", ConstString("Swift.Float64"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Float80", ConstString("Swift.Float80"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Float", ConstString("Swift.Float"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.Double", ConstString("Swift.Double"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.CDouble", ConstString("Swift.CDouble"), basic_synth_flags);
+
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Darwin.size_t", ConstString("Darwin.size_t"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.OpaquePointer", ConstString("Swift.OpaquePointer"),
+      basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UWord", ConstString("Swift.UWord"), basic_synth_flags);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UnsafePointer", ConstString("^Swift.UnsafePointer<.+>$"),
+      basic_synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftBasicTypeSyntheticFrontEndCreator,
+      "Swift.UnsafeMutablePointer",
+      ConstString("^Swift.UnsafeMutablePointer<.+>$"), basic_synth_flags, true);
+
+  AddFormat(swift_category_sp, lldb::eFormatPointer,
+            ConstString("Swift.OpaquePointer"), format_flags, false);
+  AddFormat(swift_category_sp, lldb::eFormatPointer,
+            ConstString("^Swift.UnsafePointer<.+>$"), format_flags, true);
+  AddFormat(swift_category_sp, lldb::eFormatPointer,
+            ConstString("^Swift.UnsafeMutablePointer<.+>$"), format_flags,
+            true);
+  AddFormat(swift_category_sp, lldb::eFormatUnsigned,
+            ConstString("Swift.UWord"), format_flags, false);
+
+  SyntheticChildren::Flags synth_flags;
+  synth_flags.SetCascades(true).SetSkipPointers(false).SetSkipReferences(false);
+
+  // Arrays and Dictionaries want their children shown.. that's the whole point
+  summary_flags.SetDontShowChildren(false);
+  summary_flags.SetSkipPointers(false); // the ContiguousArrayStorage ugliness
+                                        // will come back to us as pointers
+  synth_flags.SetSkipPointers(false);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Array_SummaryProvider,
+                "Swift.Array summary provider",
+                ConstString("^Swift.Array<.+>$"), summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Array_SummaryProvider,
+                "Swift.Array summary provider",
+                ConstString("Swift._NSSwiftArray"), summary_flags, false);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Array_SummaryProvider,
+                "Swift.Array summary provider",
+                ConstString("^Swift.NativeArray<.+>$"), summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Array_SummaryProvider,
+                "Swift.ArraySlice summary provider",
+                ConstString("^Swift.ArraySlice<.+>$"), summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Array_SummaryProvider,
+                "Swift.Array summary provider",
+                ConstString("^_TtCs23_ContiguousArrayStorage[A-Fa-f0-9]+$"),
+                summary_flags, true);
+  AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::swift::Array_SummaryProvider,
+      "Swift.Array summary provider",
+      ConstString("^Swift._ContiguousArrayStorage"), summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::NSArraySummaryProvider,
+                "Swift.Array summary provider",
+                ConstString(SwiftLanguageRuntime::GetCurrentMangledName(
+                    "_TtCs21_SwiftDeferredNSArray")),
+                summary_flags, false);
+  AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::NSArraySummaryProvider,
+      "Swift.Array summary provider",
+      ConstString("_TtCs21_SwiftDeferredNSArray"), summary_flags, false);
+
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Dictionary_SummaryProvider,
+                "Swift.Dictionary summary provider",
+                ConstString("^Swift.Dictionary<.+,.+>$"), summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::NSDictionarySummaryProvider<false>,
+                "Swift.Dictionary synthetic children",
+                ConstString("^Swift._SwiftDeferredNSDictionary<.+>$"),
+                summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::NSDictionarySummaryProvider<false>,
+                "Swift.Dictionary synthetic children",
+                ConstString("^_TtGCs29_NativeDictionaryStorageOwner.*_$"),
+                summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::NSDictionarySummaryProvider<false>,
+                "Swift.Dictionary synthetic children",
+                ConstString("^_TtGCs29_NativeDictionaryStorageOwner.*_$"),
+                summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::NSDictionarySummaryProvider<false>,
+                "Swift.Dictionary synthetic children",
+                ConstString("^Swift._NativeDictionaryStorageOwner.*$"),
+                summary_flags, true);
+
+  summary_flags.SetDontShowChildren(true);
+  summary_flags.SetSkipPointers(true);
+
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::ArraySyntheticFrontEndCreator,
+      "Swift.Array synthetic children", ConstString("^Swift.Array<.+>$"),
+      synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::ArraySyntheticFrontEndCreator,
+      "Swift.Array synthetic children", ConstString("Swift._NSSwiftArray"),
+      synth_flags, false);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::ArraySyntheticFrontEndCreator,
+      "Swift.Array synthetic children", ConstString("^Swift.NativeArray<.+>$"),
+      synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::ArraySyntheticFrontEndCreator,
+      "Swift.Array synthetic children", ConstString("^Swift.ArraySlice<.+>$"),
+      synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::ArraySyntheticFrontEndCreator,
+      "Swift.Array synthetic children",
+      ConstString("^_TtCs23_ContiguousArrayStorage[A-Fa-f0-9]+$"), synth_flags,
+      true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::ArraySyntheticFrontEndCreator,
+      "Swift.Array synthetic children",
+      ConstString("^Swift._ContiguousArrayStorage"), synth_flags, true);
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::NSArraySyntheticFrontEndCreator,
+                  "Swift.Array synthetic children",
+                  ConstString(SwiftLanguageRuntime::GetCurrentMangledName(
+                      "_TtCs21_SwiftDeferredNSArray")),
+                  synth_flags, false);
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::NSArraySyntheticFrontEndCreator,
+                  "Swift.Array synthetic children",
+                  ConstString("_TtCs21_SwiftDeferredNSArray"), synth_flags,
+                  false);
+
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::DictionarySyntheticFrontEndCreator,
+      "Swift.Dictionary synthetic children",
+      ConstString("^Swift.Dictionary<.+,.+>$"), synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::NSDictionarySyntheticFrontEndCreator,
+      "Swift.Dictionary synthetic children",
+      ConstString("^_TtCs29_NativeDictionaryStorageOwner[A-Fa-f0-9]+$"),
+      synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::NSDictionarySyntheticFrontEndCreator,
+      "Swift.Dictionary synthetic children",
+      ConstString("^Swift._SwiftDeferredNSDictionary<.+>$"), synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::NSDictionarySyntheticFrontEndCreator,
+      "Swift.Dictionary synthetic children",
+      ConstString("^_TtGCs29_NativeDictionaryStorageOwner.*_$"), synth_flags,
+      true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::NSDictionarySyntheticFrontEndCreator,
+      "Swift.Dictionary synthetic children",
+      ConstString("^Swift._NativeDictionaryStorageOwner.*$"), synth_flags,
+      true);
+
+  // FIXME: _Set and Set seem to be coexisting on different trains - support
+  // both for a while
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::swift::SetSyntheticFrontEndCreator,
+                  "Swift.Set synthetic children",
+                  ConstString("^Swift.Set<.+>$"), synth_flags, true);
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::swift::SetSyntheticFrontEndCreator,
+                  "Swift.Set synthetic children",
+                  ConstString("^Swift._Set<.+>$"), synth_flags, true);
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::NSSetSyntheticFrontEndCreator,
+                  "Swift.Set synthetic children",
+                  ConstString("^_TtCs22_NativeSetStorageOwner[A-Fa-f0-9]+$"),
+                  synth_flags, true);
+
+  synth_flags.SetSkipPointers(true);
+
+  AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::swift::Bool_SummaryProvider,
+      "Swift.Bool summary provider", ConstString("Swift.Bool"), summary_flags);
+  AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::TypePreservingNSNumber_SummaryProvider,
+      "_SwiftTypePreservingNSNumber summary provider",
+      ConstString("_SwiftTypePreservingNSNumber"), summary_flags);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::DarwinBoolean_SummaryProvider,
+                "DarwinBoolean summary provider", ConstString("DarwinBoolean"),
+                summary_flags);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::UnicodeScalar_SummaryProvider,
+                "Swift.UnicodeScalar summary provider",
+                ConstString("Swift.UnicodeScalar"), summary_flags);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::UnicodeScalar_SummaryProvider,
+                "Swift.Unicode.Scalar summary provider",
+                ConstString("Swift.Unicode.Scalar"), summary_flags);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Character_SummaryProvider,
+                "Swift.Character summary provider",
+                ConstString("Swift.Character"), summary_flags);
+  bool (*string_summary_provider)(ValueObject &, Stream &,
+                                  const TypeSummaryOptions &) =
+      lldb_private::formatters::swift::String_SummaryProvider;
+  AddCXXSummary(swift_category_sp, string_summary_provider,
+                "Swift.String summary provider", ConstString("Swift.String"),
+                summary_flags);
+  bool (*staticstring_summary_provider)(ValueObject &, Stream &,
+                                        const TypeSummaryOptions &) =
+      lldb_private::formatters::swift::StaticString_SummaryProvider;
+  AddCXXSummary(swift_category_sp, staticstring_summary_provider,
+                "Swift.StaticString summary provider",
+                ConstString("Swift.StaticString"), summary_flags);
+  summary_flags.SetSkipPointers(false);
+  // this is an ObjC dynamic type - as such it comes in pointer form
+  // NSContiguousString* - do not skip pointers here
+  AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::NSContiguousString_SummaryProvider,
+      "NSContiguousString summary provider", ConstString("_NSContiguousString"),
+      summary_flags);
+  AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::NSContiguousString_SummaryProvider,
+      "NSContiguousString summary provider",
+      ConstString(SwiftLanguageRuntime::GetCurrentMangledName(
+          "_TtCs19_NSContiguousString")),
+      summary_flags);
+  summary_flags.SetSkipPointers(true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::BuiltinObjC_SummaryProvider,
+                "ObjC object pointer summary provider",
+                ConstString("Builtin.ObjCPointer"), summary_flags);
+
+  TypeSummaryImpl::Flags optional_summary_flags;
+  optional_summary_flags.SetCascades(true)
+      .SetDontShowChildren(false) // this one will actually be calculated at
+                                  // runtime, what you pass here doesn't matter
+      .SetDontShowValue(true)
+      .SetHideItemNames(false)
+      .SetShowMembersOneLiner(false)
+      .SetSkipPointers(true)
+      .SetSkipReferences(false);
+
+  SyntheticChildren::Flags optional_synth_flags;
+  optional_synth_flags.SetCascades(true)
+      .SetSkipPointers(true)
+      .SetSkipReferences(false);
+
+  TypeSummaryImplSP swift_optional_summary_sp(
+      new lldb_private::formatters::swift::SwiftOptionalSummaryProvider(
+          optional_summary_flags));
+  TypeSummaryImplSP swift_unchecked_optional_summary_sp(
+      new lldb_private::formatters::swift::SwiftOptionalSummaryProvider(
+          optional_summary_flags));
+
+  // do not move the relative order of these - @unchecked needs to come first or
+  // else pain will ensue
+  AddSummary(swift_category_sp, swift_unchecked_optional_summary_sp,
+             ConstString("^Swift.ImplicitlyUnwrappedOptional<.+>$"), true);
+  AddSummary(swift_category_sp, swift_optional_summary_sp,
+             ConstString("^Swift.Optional<.+>$"), true);
+
+  AddSummary(swift_category_sp, swift_unchecked_optional_summary_sp,
+             ConstString("AnyObject!"), false);
+  AddSummary(swift_category_sp, swift_optional_summary_sp,
+             ConstString("AnyObject?"), false);
+
+  AddSummary(swift_category_sp, swift_unchecked_optional_summary_sp,
+             ConstString("()!"), false);
+  AddSummary(swift_category_sp, swift_optional_summary_sp, ConstString("()?"),
+             false);
+
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::swift::
+                      SwiftUncheckedOptionalSyntheticFrontEndCreator,
+                  "Swift.Optional synthetic children",
+                  ConstString("^Swift.ImplicitlyUnwrappedOptional<.+>$"),
+                  optional_synth_flags, true);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEndCreator,
+      "Swift.Optional synthetic children", ConstString("^Swift.Optional<.+>$"),
+      optional_synth_flags, true);
+
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::swift::
+                      SwiftUncheckedOptionalSyntheticFrontEndCreator,
+                  "Swift.Optional synthetic children",
+                  ConstString("AnyObject!"), optional_synth_flags, false);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEndCreator,
+      "Swift.Optional synthetic children", ConstString("AnyObject?"),
+      optional_synth_flags, false);
+
+  AddCXXSynthetic(swift_category_sp,
+                  lldb_private::formatters::swift::
+                      SwiftUncheckedOptionalSyntheticFrontEndCreator,
+                  "Swift.Optional synthetic children", ConstString("()!"),
+                  optional_synth_flags, false);
+  AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEndCreator,
+      "Swift.Optional synthetic children", ConstString("()?"),
+      optional_synth_flags, false);
+
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::Range_SummaryProvider,
+                "Swift.Range summary provider", ConstString("Swift.Range<.+>$"),
+                summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::CountableRange_SummaryProvider,
+                "Swift.CountableRange summary provider",
+                ConstString("Swift.CountableRange<.+>$"), summary_flags, true);
+  AddCXXSummary(swift_category_sp,
+                lldb_private::formatters::swift::ClosedRange_SummaryProvider,
+                "Swift.ClosedRange summary provider",
+                ConstString("Swift.ClosedRange<.+>$"), summary_flags, true);
+  AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::CountableClosedRange_SummaryProvider,
+      "Swift.CountableClosedRange summary provider",
+      ConstString("Swift.CountableClosedRange<.+>$"), summary_flags, true);
+
+  AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::StridedRangeGenerator_SummaryProvider,
+      "Swift.StridedRangeGenerator summary provider",
+      ConstString("Swift.StridedRangeGenerator<.+>$"), summary_flags, true);
+
+  TypeSummaryImpl::Flags nil_summary_flags;
+  nil_summary_flags.SetCascades(true)
+      .SetDontShowChildren(true)
+      .SetDontShowValue(true)
+      .SetHideItemNames(false)
+      .SetShowMembersOneLiner(false)
+      .SetSkipPointers(true)
+      .SetSkipReferences(false);
+
+  AddStringSummary(swift_category_sp, "nil", ConstString("Swift._Nil"),
+                   nil_summary_flags);
+
+  AddStringSummary(swift_category_sp, "${var.native}",
+                   ConstString("CoreGraphics.CGFloat"), summary_flags);
+#endif // LLDB_DISABLE_PYTHON
+}
+
+static void
+LoadFoundationValueTypesFormatters(lldb::TypeCategoryImplSP swift_category_sp) {
+  if (!swift_category_sp)
+    return;
+
+  TypeSummaryImpl::Flags summary_flags;
+  summary_flags.SetCascades(true)
+      .SetDontShowChildren(false)
+      .SetSkipPointers(true)
+      .SetSkipReferences(false)
+      .SetHideItemNames(false)
+      .SetShowMembersOneLiner(false);
+
+#ifndef LLDB_DISABLE_PYTHON
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::swift::Date_SummaryProvider,
+      "Foundation.Date summary provider", ConstString("Foundation.Date"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::NotificationName_SummaryProvider,
+      "Notification.Name summary provider",
+      ConstString("Foundation.Notification.Type.Name"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::NotificationName_SummaryProvider,
+      "Notification.Name summary provider",
+      ConstString("Foundation.Notification.Name"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::swift::URL_SummaryProvider,
+      "URL summary provider", ConstString("Foundation.URL"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::IndexPath_SummaryProvider,
+      "IndexPath summary provider", ConstString("Foundation.IndexPath"),
+      summary_flags);
+
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp,
+      lldb_private::formatters::swift::Measurement_SummaryProvider,
+      "Measurement summary provider",
+      ConstString("Foundation.Measurement<Foundation.Unit>"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::swift::UUID_SummaryProvider,
+      "UUID summary provider", ConstString("Foundation.UUID"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+
+  lldb_private::formatters::AddCXXSummary(
+      swift_category_sp, lldb_private::formatters::swift::Data_SummaryProvider,
+      "Data summary provider", ConstString("Foundation.Data"),
+      TypeSummaryImpl::Flags(summary_flags).SetDontShowChildren(true));
+
+  lldb_private::formatters::AddCXXSynthetic(
+      swift_category_sp,
+      lldb_private::formatters::swift::URLComponentsSyntheticFrontEndCreator,
+      "URLComponents synthetic children",
+      ConstString("Foundation.URLComponents"),
+      SyntheticChildren::Flags()
+          .SetSkipPointers(true)
+          .SetCascades(true)
+          .SetSkipReferences(false)
+          .SetNonCacheable(false));
+#endif
+}
+
+lldb::TypeCategoryImplSP SwiftLanguage::GetFormatters() {
+  static llvm::once_flag g_initialize;
+  static TypeCategoryImplSP g_category;
+
+  std::call_once(g_initialize, [this]() -> void {
+    DataVisualization::Categories::GetCategory(GetPluginName(), g_category);
+    if (g_category) {
+      LoadSwiftFormatters(g_category);
+      LoadFoundationValueTypesFormatters(g_category);
+    }
+  });
+  return g_category;
+}
+
+HardcodedFormatters::HardcodedSummaryFinder
+SwiftLanguage::GetHardcodedSummaries() {
+  static llvm::once_flag g_initialize;
+  static HardcodedFormatters::HardcodedSummaryFinder g_formatters;
+
+  std::call_once(g_initialize, []() -> void {
+    g_formatters.push_back([](lldb_private::ValueObject &valobj,
+                              lldb::DynamicValueType,
+                              FormatManager &) -> lldb::TypeSummaryImplSP {
+      static lldb::TypeSummaryImplSP swift_metatype_summary_sp(nullptr);
+      static ConstString g_RawPointerType("Builtin.RawPointer");
+      CompilerType type(valobj.GetCompilerType());
+      Flags type_flags(type.GetTypeInfo());
+      if (type_flags.AllSet(eTypeIsMetatype | eTypeIsSwift)) {
+        if (!swift_metatype_summary_sp.get()) {
+          TypeSummaryImpl::Flags flags;
+          flags.SetCascades(true)
+              .SetDontShowChildren(true)
+              .SetDontShowValue(true)
+              .SetHideItemNames(false)
+              .SetShowMembersOneLiner(false)
+              .SetSkipPointers(false)
+              .SetSkipReferences(false);
+          swift_metatype_summary_sp.reset(new CXXFunctionSummaryFormat(
+              flags,
+              lldb_private::formatters::swift::SwiftMetatype_SummaryProvider,
+              "Swift Metatype Summary"));
+        }
+        return swift_metatype_summary_sp;
+      }
+      if (valobj.GetName().GetLength() > 12 &&
+          valobj.GetName().GetStringRef().startswith("$swift.type.") &&
+          type.GetTypeName() == g_RawPointerType) {
+        if (!swift_metatype_summary_sp.get()) {
+          TypeSummaryImpl::Flags flags;
+          flags.SetCascades(true)
+              .SetDontShowChildren(true)
+              .SetDontShowValue(true)
+              .SetHideItemNames(false)
+              .SetShowMembersOneLiner(false)
+              .SetSkipPointers(false)
+              .SetSkipReferences(false);
+          swift_metatype_summary_sp.reset(new CXXFunctionSummaryFormat(
+              flags,
+              lldb_private::formatters::swift::SwiftMetatype_SummaryProvider,
+              "Swift Metatype Summary"));
+        }
+        return swift_metatype_summary_sp;
+      }
+      return nullptr;
+    });
+    g_formatters.push_back([](lldb_private::ValueObject &valobj,
+                              lldb::DynamicValueType, FormatManager &)
+                               -> TypeSummaryImpl::SharedPointer {
+      CompilerType clang_type(valobj.GetCompilerType());
+      if (lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+              WouldEvenConsiderFormatting(clang_type)) {
+        TypeSummaryImpl::SharedPointer formatter_sp(
+            new lldb_private::formatters::swift::SwiftOptionSetSummaryProvider(
+                clang_type));
+        return formatter_sp;
+      }
+      return nullptr;
+    });
+  });
+
+  return g_formatters;
+}
+
+HardcodedFormatters::HardcodedSyntheticFinder
+SwiftLanguage::GetHardcodedSynthetics() {
+  static llvm::once_flag g_initialize;
+  static ConstString g_runtime_synths_category_name("runtime-synthetics");
+  static HardcodedFormatters::HardcodedSyntheticFinder g_formatters;
+
+  std::call_once(g_initialize, []() -> void {
+    g_formatters.push_back([](lldb_private::ValueObject &valobj,
+                              lldb::DynamicValueType,
+                              FormatManager &) -> lldb::SyntheticChildrenSP {
+      static lldb::SyntheticChildrenSP swift_enum_synth(nullptr);
+      CompilerType type(valobj.GetCompilerType());
+      Flags type_flags(type.GetTypeInfo());
+      if (type_flags.AllSet(eTypeIsSwift | eTypeIsEnumeration)) {
+        if (!swift_enum_synth)
+          swift_enum_synth = lldb::SyntheticChildrenSP(new CXXSyntheticChildren(
+              SyntheticChildren::Flags()
+                  .SetCascades(true)
+                  .SetSkipPointers(true)
+                  .SetSkipReferences(true),
+              "swift Enum synthetic children provider",
+              lldb_private::formatters::swift::EnumSyntheticFrontEndCreator));
+        return swift_enum_synth;
+      }
+      return nullptr;
+    });
+    g_formatters.push_back(
+        [](lldb_private::ValueObject &valobj, lldb::DynamicValueType dyn_type,
+           FormatManager &format_manager) -> lldb::SyntheticChildrenSP {
+          struct IsEligible {
+            static bool Check(ValueObject &valobj, const CompilerType &type) {
+              bool is_imported = false;
+
+              if (type.IsValid()) {
+                SwiftASTContext *swift_ast_ctx =
+                    llvm::dyn_cast_or_null<SwiftASTContext>(
+                        type.GetTypeSystem());
+                if (swift_ast_ctx &&
+                    swift_ast_ctx->IsImportedType(type, nullptr))
+                  is_imported = true;
+              }
+
+              if (is_imported && type.GetNumFields() == 0)
+                return true;
+              if (valobj.IsBaseClass() && type.IsRuntimeGeneratedType()) {
+                auto parent(valobj.GetParent());
+                if (!parent)
+                  return false;
+                return IsEligible::Check(*parent, parent->GetCompilerType());
+              }
+              return false;
+            }
+          };
+
+          if (dyn_type == lldb::eNoDynamicValues)
+            return nullptr;
+          CompilerType type(valobj.GetCompilerType());
+          const bool can_create = false;
+          auto category_sp(format_manager.GetCategory(
+              g_runtime_synths_category_name, can_create));
+          if (!category_sp || category_sp->IsEnabled() == false)
+            return nullptr;
+          if (IsEligible::Check(valobj, type)) {
+            ProcessSP process_sp(valobj.GetProcessSP());
+            if (!process_sp)
+              return nullptr;
+            ObjCLanguageRuntime *objc_runtime =
+                process_sp->GetObjCLanguageRuntime();
+            ObjCLanguageRuntime::ClassDescriptorSP valobj_descriptor_sp =
+                objc_runtime->GetClassDescriptor(valobj);
+            if (valobj_descriptor_sp) {
+              return SyntheticChildrenSP(
+                  new ObjCRuntimeSyntheticProvider(SyntheticChildren::Flags()
+                                                       .SetCascades(true)
+                                                       .SetSkipPointers(true)
+                                                       .SetSkipReferences(true)
+                                                       .SetNonCacheable(true),
+                                                   valobj_descriptor_sp));
+            }
+          }
+          return nullptr;
+        });
+    g_formatters.push_back(
+        [](lldb_private::ValueObject &valobj, lldb::DynamicValueType dyn_type,
+           FormatManager &format_manager) -> lldb::SyntheticChildrenSP {
+          struct IsEligible {
+            static bool Check(const CompilerType &type) {
+              if ((ClangASTContext::IsObjCObjectPointerType(type) ||
+                   ClangASTContext::IsObjCObjectOrInterfaceType(type)) &&
+                  SwiftLanguageRuntime::IsSwiftClassName(
+                      type.GetTypeName().GetCString()))
+                return true;
+
+              return false;
+            }
+          };
+
+          if (dyn_type == lldb::eNoDynamicValues)
+            return nullptr;
+          CompilerType type(valobj.GetCompilerType());
+          if (IsEligible::Check(type)) {
+            ProcessSP process_sp(valobj.GetProcessSP());
+            if (!process_sp)
+              return nullptr;
+            SwiftLanguageRuntime *swift_runtime =
+                process_sp->GetSwiftLanguageRuntime();
+            return swift_runtime->GetBridgedSyntheticChildProvider(valobj);
+          }
+          return nullptr;
+        });
+  });
+
+  return g_formatters;
+}
+
+std::vector<ConstString> SwiftLanguage::GetPossibleFormattersMatches(
+    ValueObject &valobj, lldb::DynamicValueType use_dynamic) {
+  std::vector<ConstString> result;
+
+  if (use_dynamic == lldb::eNoDynamicValues)
+    return result;
+
+  CompilerType compiler_type(valobj.GetCompilerType());
+
+  const bool check_cpp = false;
+  const bool check_objc = false;
+  const bool check_swift = true;
+  bool canBeSwiftDynamic = compiler_type.IsPossibleDynamicType(
+      nullptr, check_cpp, check_objc, check_swift);
+
+  if (canBeSwiftDynamic) {
+    do {
+      lldb::ProcessSP process_sp = valobj.GetProcessSP();
+      if (!process_sp)
+        break;
+      SwiftLanguageRuntime *runtime = process_sp->GetSwiftLanguageRuntime();
+      if (runtime == nullptr)
+        break;
+      TypeAndOrName type_and_or_name;
+      Address address;
+      Value::ValueType value_type;
+      if (!runtime->GetDynamicTypeAndAddress(
+              valobj, use_dynamic, type_and_or_name, address, value_type))
+        break;
+      if (ConstString name = type_and_or_name.GetName())
+        result.push_back(name);
+    } while (false);
+  }
+
+#if 0
+    if (llvm::isa<SwiftASTContext>(compiler_type.GetTypeSystem()))
+        result.push_back(compiler_type.GetMangledTypeName());
+#endif
+
+  return result;
+}
+
+static char32_t ConvertUTF8ToCodePoint(unsigned char c0, unsigned char c1) {
+  return (c0 - 192) * 64 + (c1 - 128);
+}
+static char32_t ConvertUTF8ToCodePoint(unsigned char c0, unsigned char c1,
+                                       unsigned char c2) {
+  return (c0 - 224) * 4096 + (c1 - 128) * 64 + (c2 - 128);
+}
+static char32_t ConvertUTF8ToCodePoint(unsigned char c0, unsigned char c1,
+                                       unsigned char c2, unsigned char c3) {
+  return (c0 - 240) * 262144 + (c2 - 128) * 4096 + (c2 - 128) * 64 + (c3 - 128);
+}
+
+lldb_private::formatters::StringPrinter::EscapingHelper
+SwiftLanguage::GetStringPrinterEscapingHelper(
+    lldb_private::formatters::StringPrinter::GetPrintableElementType
+        elem_type) {
+  switch (elem_type) {
+  case lldb_private::formatters::StringPrinter::GetPrintableElementType::UTF8:
+    return
+        [this](uint8_t *buffer, uint8_t *buffer_end, uint8_t *&next)
+            -> lldb_private::formatters::StringPrinter::
+                StringPrinterBufferPointer<> {
+                  lldb_private::formatters::StringPrinter::
+                      StringPrinterBufferPointer<>
+                          retval{nullptr};
+
+                  auto isprint32 = [](char32_t codepoint) -> bool {
+                    if (codepoint <= 0x1F || codepoint == 0x7F) // C0
+                    {
+                      return false;
+                    }
+                    if (codepoint >= 0x80 && codepoint <= 0x9F) // C1
+                    {
+                      return false;
+                    }
+                    if (codepoint == 0x2028 ||
+                        codepoint == 0x2029) // line/paragraph separators
+                    {
+                      return false;
+                    }
+                    if (codepoint == 0x200E || codepoint == 0x200F ||
+                        (codepoint >= 0x202A &&
+                         codepoint <= 0x202E)) // bidirectional text control
+                    {
+                      return false;
+                    }
+                    if (codepoint >= 0xFFF9 &&
+                        codepoint <=
+                            0xFFFF) // interlinears and generally specials
+                    {
+                      return false;
+                    }
+                    return true;
+                  };
+
+                  unsigned utf8_encoded_len = llvm::getNumBytesForUTF8(*buffer);
+
+                  if (1 + buffer_end - buffer < utf8_encoded_len) {
+                    // I don't have enough bytes - print whatever I have left
+                    retval = {buffer,
+                              static_cast<size_t>(1 + buffer_end - buffer)};
+                    next = buffer_end + 1;
+                    return retval;
+                  }
+
+                  char32_t codepoint = 0;
+                  switch (utf8_encoded_len) {
+                  case 1:
+                    return GetStringPrinterEscapingHelper(
+                        lldb_private::formatters::StringPrinter::
+                            GetPrintableElementType::ASCII)(buffer, buffer_end,
+                                                            next);
+                  case 2:
+                    codepoint = ConvertUTF8ToCodePoint(
+                        (unsigned char)*buffer, (unsigned char)*(buffer + 1));
+                    break;
+                  case 3:
+                    codepoint = ConvertUTF8ToCodePoint(
+                        (unsigned char)*buffer, (unsigned char)*(buffer + 1),
+                        (unsigned char)*(buffer + 2));
+                    break;
+                  case 4:
+                    codepoint = ConvertUTF8ToCodePoint(
+                        (unsigned char)*buffer, (unsigned char)*(buffer + 1),
+                        (unsigned char)*(buffer + 2),
+                        (unsigned char)*(buffer + 3));
+                    break;
+                  default:
+                    // this is probably some bogus non-character thing
+                    // just print it as-is and hope to sync up again soon
+                    retval = {buffer, 1};
+                    next = buffer + 1;
+                    return retval;
+                  }
+
+                  if (codepoint) {
+                    switch (codepoint) {
+                    case 0:
+                      retval = {"\\0", 2};
+                      break;
+                    case '\a':
+                      retval = {"\\a", 2};
+                      break;
+                    case '\n':
+                      retval = {"\\n", 2};
+                      break;
+                    case '\r':
+                      retval = {"\\r", 2};
+                      break;
+                    case '\t':
+                      retval = {"\\t", 2};
+                      break;
+                    case '"':
+                      retval = {"\\\"", 2};
+                      break;
+                    case '\'':
+                      retval = {"\\'", 2};
+                      break;
+                    case '\\':
+                      retval = {"\\\\", 2};
+                      break;
+                    default:
+                      if (isprint32(codepoint))
+                        retval = {buffer, utf8_encoded_len};
+                      else {
+                        uint8_t *data = new uint8_t[13];
+                        unsigned long data_len =
+                            sprintf((char *)data, "\\u{%x}", *buffer);
+                        retval = {data, data_len,
+                                  [](const uint8_t *c) { delete[] c; }};
+                        break;
+                      }
+                    }
+
+                    next = buffer + utf8_encoded_len;
+                    return retval;
+                  }
+
+                  // this should not happen - but just in case.. try to resync
+                  // at some point
+                  retval = {buffer, 1};
+                  next = buffer + 1;
+                  return retval;
+                };
+  case lldb_private::formatters::StringPrinter::GetPrintableElementType::ASCII:
+    return [](uint8_t *buffer, uint8_t *buffer_end, uint8_t *&next)
+               -> lldb_private::formatters::StringPrinter::
+                   StringPrinterBufferPointer<> {
+                     lldb_private::formatters::StringPrinter::
+                         StringPrinterBufferPointer<>
+                             retval = {nullptr};
+
+                     switch (*buffer) {
+                     case 0:
+                       retval = {"\\0", 2};
+                       break;
+                     case '\a':
+                       retval = {"\\a", 2};
+                       break;
+                     case '\n':
+                       retval = {"\\n", 2};
+                       break;
+                     case '\r':
+                       retval = {"\\r", 2};
+                       break;
+                     case '\t':
+                       retval = {"\\t", 2};
+                       break;
+                     case '"':
+                       retval = {"\\\"", 2};
+                       break;
+                     case '\'':
+                       retval = {"\\'", 2};
+                       break;
+                     case '\\':
+                       retval = {"\\\\", 2};
+                       break;
+                     default:
+                       if (isprint(*buffer))
+                         retval = {buffer, 1};
+                       else {
+                         uint8_t *data = new uint8_t[7];
+                         unsigned long data_len =
+                             sprintf((char *)data, "\\u{%x}", *buffer);
+                         retval = {data, data_len,
+                                   [](const uint8_t *c) { delete[] c; }};
+                         break;
+                       }
+                     }
+
+                     next = buffer + 1;
+                     return retval;
+                   };
+  }
+
+  llvm_unreachable("Unhandled StringPrinter in switch.");
+}
+
+static void SplitDottedName(llvm::StringRef name,
+                            std::vector<llvm::StringRef> &parts,
+                            char sep = '.') {
+  if (name.empty())
+    return;
+  auto pair = name.split(sep);
+  if (false == pair.first.empty())
+    parts.push_back(pair.first);
+  if (false == pair.second.empty())
+    SplitDottedName(pair.second, parts, sep);
+}
+
+std::unique_ptr<Language::TypeScavenger> SwiftLanguage::GetTypeScavenger() {
+  class SwiftTypeScavenger : public Language::TypeScavenger {
+  private:
+    typedef SwiftASTContext::TypeOrDecl TypeOrDecl;
+    typedef SwiftASTContext::TypesOrDecls TypesOrDecls;
+
+    class SwiftScavengerResult : public Language::TypeScavenger::Result {
+    public:
+      typedef SwiftASTContext::TypeOrDecl TypeOrDecl;
+
+      SwiftScavengerResult(TypeOrDecl type)
+          : Language::TypeScavenger::Result(), m_result(type) {}
+
+      bool IsValid() override { return m_result.operator bool(); }
+
+      bool DumpToStream(Stream &stream, bool print_help_if_available) override {
+        if (IsValid()) {
+          auto as_type = m_result.GetAs<CompilerType>();
+          auto as_decl = m_result.GetAs<swift::Decl *>();
+
+          if (as_type.hasValue() && as_type.getValue()) {
+            TypeSystem *type_system = as_type->GetTypeSystem();
+            if (SwiftASTContext *swift_ast_ctx =
+                    llvm::dyn_cast_or_null<SwiftASTContext>(type_system))
+              swift_ast_ctx->DumpTypeDescription(as_type->GetOpaqueQualType(),
+                                                 &stream,
+                                                 print_help_if_available, true);
+            else
+              as_type->DumpTypeDescription(
+                  &stream); // we should always have a swift type here..
+          } else if (as_decl.hasValue() && as_decl.getValue()) {
+            std::string buffer;
+            llvm::raw_string_ostream str_stream(buffer);
+            swift::Decl *decl = as_decl.getValue();
+            decl->print(str_stream,
+                        SwiftASTContext::GetUserVisibleTypePrintingOptions(
+                            print_help_if_available));
+            str_stream.flush();
+            stream.Printf("%s", buffer.c_str());
+          }
+
+          stream.EOL();
+          return true;
+        }
+        return false;
+      }
+
+      virtual ~SwiftScavengerResult() = default;
+
+    private:
+      TypeOrDecl m_result;
+    };
+
+  protected:
+    SwiftTypeScavenger() = default;
+
+    virtual ~SwiftTypeScavenger() = default;
+
+    typedef std::function<size_t(const char *, ExecutionContextScope *,
+                                 TypesOrDecls &)>
+        Hoarder;
+    typedef std::vector<Hoarder> Hoarders;
+
+    static Hoarders &GetHoarders() {
+      static Hoarders g_hoarders;
+      static llvm::once_flag g_init;
+      std::call_once(g_init, []() -> void {
+        g_hoarders.push_back([](const char *input,
+                                ExecutionContextScope *exe_scope,
+                                TypesOrDecls &results) -> size_t {
+          size_t before = results.size();
+
+          if (exe_scope) {
+            Target *target = exe_scope->CalculateTarget().get();
+            if (target) {
+              const bool create_on_demand = false;
+              Status error;
+              SwiftASTContext *ast_ctx(
+                  target->GetScratchSwiftASTContext(error, create_on_demand));
+              if (ast_ctx) {
+                const bool is_mangled = true;
+                Mangled mangled(ConstString(input), is_mangled);
+                if (mangled.GuessLanguage() == eLanguageTypeSwift) {
+                  Status error;
+                  auto candidate =
+                      ast_ctx->GetTypeFromMangledTypename(input, error);
+                  if (candidate.IsValid() && error.Success())
+                    results.insert(candidate);
+                }
+              }
+            }
+          }
+
+          return (results.size() - before);
+        });
+        g_hoarders.push_back([](const char *input,
+                                ExecutionContextScope *exe_scope,
+                                TypesOrDecls &results) -> size_t {
+          size_t before = results.size();
+
+          if (exe_scope) {
+            Target *target = exe_scope->CalculateTarget().get();
+            StackFrame *frame = exe_scope->CalculateStackFrame().get();
+            if (target && frame) {
+              lldb::ValueObjectSP result_sp;
+              EvaluateExpressionOptions options;
+              options.SetLanguage(eLanguageTypeSwift);
+              options.SetGenerateDebugInfo(false);
+              StreamString stream;
+              stream.Printf("typealias __lldb__typelookup_typealias = %s; "
+                            "__lldb__typelookup_typealias.self",
+                            input);
+              if (target->EvaluateExpression(stream.GetData(), frame, result_sp,
+                                             options) == eExpressionCompleted) {
+                if (result_sp && result_sp->GetCompilerType().IsValid()) {
+                  CompilerType result_type(result_sp->GetCompilerType());
+                  if (Flags(result_type.GetTypeInfo())
+                          .AllSet(eTypeIsSwift | eTypeIsMetatype))
+                    result_type = result_type.GetInstanceType();
+                  results.insert(TypeOrDecl(result_type));
+                }
+              }
+            }
+          }
+
+          return (results.size() - before);
+        });
+        g_hoarders.push_back([](const char *input,
+                                ExecutionContextScope *exe_scope,
+                                TypesOrDecls &results) -> size_t {
+          size_t before = results.size();
+
+          if (exe_scope) {
+            Target *target = exe_scope->CalculateTarget().get();
+            const bool create_on_demand = false;
+            Status error;
+            SwiftASTContext *ast_ctx(
+                target->GetScratchSwiftASTContext(error, create_on_demand));
+            if (ast_ctx) {
+              auto iter = ast_ctx->GetModuleCache().begin(),
+                   end = ast_ctx->GetModuleCache().end();
+
+              std::vector<llvm::StringRef> name_parts;
+              SplitDottedName(input, name_parts);
+
+              std::function<void(swift::ModuleDecl *)> lookup_func =
+                  [ast_ctx, input, name_parts,
+                   &results](swift::ModuleDecl *module) -> void {
+
+                swift::ModuleDecl::AccessPathTy access_path;
+
+                module->forAllVisibleModules(
+                    access_path, true,
+                    [ast_ctx, input, name_parts, &results](
+                        swift::ModuleDecl::ImportedModule imported_module)
+                        -> bool {
+                      auto module = imported_module.second;
+                      TypesOrDecls local_results;
+                      ast_ctx->FindTypesOrDecls(input, module, local_results,
+                                                false);
+                      llvm::Optional<TypeOrDecl> candidate;
+                      if (local_results.empty() && name_parts.size() > 1) {
+                        size_t idx_of_deeper = 1;
+                        // if you're looking for Swift.Int in module Swift, try
+                        // looking for Int
+                        if (name_parts.front() == module->getName().str()) {
+                          candidate = ast_ctx->FindTypeOrDecl(
+                              name_parts[1].str().c_str(), module);
+                          idx_of_deeper = 2;
+                        }
+                        // this is probably the top-level name of a nested type
+                        // String.UTF8View
+                        else {
+                          candidate = ast_ctx->FindTypeOrDecl(
+                              name_parts[0].str().c_str(), module);
+                        }
+                        if (candidate.hasValue()) {
+                          TypesOrDecls candidates{candidate.getValue()};
+                          for (; idx_of_deeper < name_parts.size();
+                               idx_of_deeper++) {
+                            TypesOrDecls new_candidates;
+                            for (auto candidate : candidates) {
+                              ast_ctx->FindContainedTypeOrDecl(
+                                  name_parts[idx_of_deeper], candidate,
+                                  new_candidates);
+                            }
+                            candidates = new_candidates;
+                          }
+                          for (auto candidate : candidates) {
+                            if (candidate)
+                              results.insert(candidate);
+                          }
+                        }
+                      } else if (local_results.size() > 0) {
+                        for (const auto &result : local_results)
+                          results.insert(result);
+                      } else if (local_results.empty() && module &&
+                                 name_parts.size() == 1 &&
+                                 name_parts.front() == module->getName().str())
+                        results.insert(
+                            CompilerType(ast_ctx->GetASTContext(),
+                                         swift::ModuleType::get(module)));
+                      return true;
+                    });
+
+              };
+
+              for (; iter != end; iter++)
+                lookup_func(iter->second);
+            }
+          }
+
+          return (results.size() - before);
+        });
+      });
+
+      return g_hoarders;
+    }
+
+    bool Find_Impl(ExecutionContextScope *exe_scope, const char *key,
+                   ResultSet &result_set) override {
+      Hoarders &hoarders(GetHoarders());
+      TypesOrDecls types_or_decls;
+
+      for (auto &hoarder : hoarders) {
+        hoarder(key, exe_scope, types_or_decls);
+        if (types_or_decls.size())
+          break;
+      }
+
+      bool any_found = false;
+
+      for (TypeOrDecl type_or_decl : types_or_decls) {
+        any_found = true;
+        std::unique_ptr<Language::TypeScavenger::Result> result(
+            new SwiftScavengerResult(type_or_decl));
+        result_set.insert(std::move(result));
+      }
+
+      return any_found;
+    }
+
+    friend class SwiftLanguage;
+  };
+
+  return std::unique_ptr<TypeScavenger>(new SwiftTypeScavenger());
+}
+
+const char *SwiftLanguage::GetLanguageSpecificTypeLookupHelp() {
+  return "\nFor Swift, in addition to a simple type name (such as String, Int, "
+         "NSObject, ..), one can also provide:\n"
+         "- a mangled type name (e.g. _TtSi)\n"
+         "- the name of a function, even if multiple overloads of it exist\n"
+         "- the name of an operator\n"
+         "- the name of a module available in the current target, which will "
+         "print all types and declarations available in that module";
+}
+
+bool SwiftLanguage::GetFormatterPrefixSuffix(ValueObject &valobj,
+                                             ConstString type_hint,
+                                             std::string &prefix,
+                                             std::string &suffix) {
+  static ConstString g_NSNumberChar("NSNumber:char");
+  static ConstString g_NSNumberShort("NSNumber:short");
+  static ConstString g_NSNumberInt("NSNumber:int");
+  static ConstString g_NSNumberLong("NSNumber:long");
+  static ConstString g_NSNumberInt128("NSNumber:int128_t");
+  static ConstString g_NSNumberFloat("NSNumber:float");
+  static ConstString g_NSNumberDouble("NSNumber:double");
+
+  if (type_hint.IsEmpty())
+    return false;
+
+  prefix.clear();
+  suffix.clear();
+
+  if (type_hint == g_NSNumberChar) {
+    prefix = "UInt8(";
+    suffix = ")";
+    return true;
+  }
+  if (type_hint == g_NSNumberShort) {
+    prefix = "Int16(";
+    suffix = ")";
+    return true;
+  }
+  if (type_hint == g_NSNumberInt) {
+    prefix = "Int32(";
+    suffix = ")";
+    return true;
+  }
+  if (type_hint == g_NSNumberLong) {
+    prefix = "Int64(";
+    suffix = ")";
+    return true;
+  }
+  if (type_hint == g_NSNumberInt128) {
+    prefix = "Int128(";
+    suffix = ")";
+    return true;
+  }
+  if (type_hint == g_NSNumberFloat) {
+    prefix = "Float(";
+    suffix = ")";
+    return true;
+  }
+  if (type_hint == g_NSNumberDouble) {
+    prefix = "Double(";
+    suffix = ")";
+    return true;
+  }
+
+  return false;
+}
+
+DumpValueObjectOptions::DeclPrintingHelper
+SwiftLanguage::GetDeclPrintingHelper() {
+  return [](ConstString type_name, ConstString var_name,
+            const DumpValueObjectOptions &options, Stream &stream) -> bool {
+    std::string type_name_str(type_name ? type_name.GetCString() : "");
+    if (type_name) {
+      for (auto iter = type_name_str.find(" *"); iter != std::string::npos;
+           iter = type_name_str.find(" *")) {
+        type_name_str.erase(iter, 2);
+      }
+      if (!type_name_str.empty()) {
+        if (type_name_str.front() != '(' || type_name_str.back() != ')') {
+          type_name_str = "(" + type_name_str + ")";
+        }
+      }
+    }
+
+    if (!type_name_str.empty())
+      stream.Printf("%s ", type_name_str.c_str());
+    if (var_name)
+      stream.Printf("%s =", var_name.GetCString());
+    else if (!options.m_hide_name)
+      stream.Printf(" =");
+
+    return true;
+  };
+}
+
+LazyBool SwiftLanguage::IsLogicalTrue(ValueObject &valobj, Status &error) {
+  static ConstString g_SwiftBool("Swift.Bool");
+  static ConstString g_value("_value");
+
+  Scalar scalar_value;
+
+  CompilerType valobj_type(valobj.GetCompilerType());
+  Flags type_flags(valobj_type.GetTypeInfo());
+  if (llvm::isa<SwiftASTContext>(valobj_type.GetTypeSystem())) {
+    if (type_flags.AllSet(eTypeIsStructUnion) &&
+        valobj_type.GetTypeName() == g_SwiftBool) {
+      ValueObjectSP your_value_sp(valobj.GetChildMemberWithName(g_value, true));
+      if (!your_value_sp) {
+        error.SetErrorString("unexpected data layout");
+        return eLazyBoolNo;
+      } else {
+        if (!your_value_sp->ResolveValue(scalar_value)) {
+          error.SetErrorString("unexpected data layout");
+          return eLazyBoolNo;
+        } else {
+          error.Clear();
+          if (scalar_value.ULongLong(1) == 0)
+            return eLazyBoolNo;
+          else
+            return eLazyBoolYes;
+        }
+      }
+    }
+  }
+
+  error.SetErrorString("not a Swift boolean type");
+  return eLazyBoolNo;
+}
+
+bool SwiftLanguage::IsUninitializedReference(ValueObject &valobj) {
+  const uint32_t mask = eTypeIsSwift | eTypeIsClass;
+  bool isSwiftClass =
+      (((valobj.GetCompilerType().GetTypeInfo(nullptr)) & mask) == mask);
+  if (!isSwiftClass)
+    return false;
+  bool canReadValue = true;
+  bool isZero = valobj.GetValueAsUnsigned(0, &canReadValue) == 0;
+  return canReadValue && isZero;
+}
+
+bool SwiftLanguage::GetFunctionDisplayName(
+    const SymbolContext *sc, const ExecutionContext *exe_ctx,
+    FunctionNameRepresentation representation, Stream &s) {
+  switch (representation) {
+  case Language::FunctionNameRepresentation::eName:
+    break; // no need to customize this
+  case Language::FunctionNameRepresentation::eNameWithNoArgs: {
+    if (sc->function) {
+      if (sc->function->GetLanguage() == eLanguageTypeSwift) {
+        if (ConstString cs = sc->function->GetDisplayName()) {
+          s.Printf("%s", cs.AsCString());
+          return true;
+        }
+      }
+    }
+  }
+  case Language::FunctionNameRepresentation::eNameWithArgs: {
+    if (sc->function) {
+      if (sc->function->GetLanguage() == eLanguageTypeSwift) {
+        if (const char *cstr = sc->function->GetDisplayName().AsCString()) {
+          ExecutionContextScope *exe_scope =
+              exe_ctx ? exe_ctx->GetBestExecutionContextScope() : NULL;
+
+          const InlineFunctionInfo *inline_info = NULL;
+          VariableListSP variable_list_sp;
+          bool get_function_vars = true;
+          if (sc->block) {
+            Block *inline_block = sc->block->GetContainingInlinedBlock();
+
+            if (inline_block) {
+              get_function_vars = false;
+              inline_info = sc->block->GetInlinedFunctionInfo();
+              if (inline_info)
+                variable_list_sp = inline_block->GetBlockVariableList(true);
+            }
+          }
+
+          if (get_function_vars) {
+            variable_list_sp =
+                sc->function->GetBlock(true).GetBlockVariableList(true);
+          }
+
+          if (inline_info) {
+            s.PutCString(cstr);
+            s.PutCString(" [inlined] ");
+            cstr =
+                inline_info->GetName(sc->function->GetLanguage()).GetCString();
+          }
+
+          VariableList args;
+          if (variable_list_sp)
+            variable_list_sp->AppendVariablesWithScope(
+                eValueTypeVariableArgument, args);
+          if (args.GetSize() > 0) {
+            const char *open_paren = strchr(cstr, '(');
+            const char *close_paren = nullptr;
+            const char *generic = strchr(cstr, '<');
+            // if before the arguments list begins there is a template sign
+            // then scan to the end of the generic args before you try to find
+            // the arguments list
+            if (generic && open_paren && generic < open_paren) {
+              int generic_depth = 1;
+              ++generic;
+              for (; *generic && generic_depth > 0; generic++) {
+                if (*generic == '<')
+                  generic_depth++;
+                if (*generic == '>')
+                  generic_depth--;
+              }
+              if (*generic)
+                open_paren = strchr(generic, '(');
+              else
+                open_paren = nullptr;
+            }
+            if (open_paren) {
+              close_paren = strchr(open_paren, ')');
+            }
+
+            if (open_paren)
+              s.Write(cstr, open_paren - cstr + 1);
+            else {
+              s.PutCString(cstr);
+              s.PutChar('(');
+            }
+            const size_t num_args = args.GetSize();
+            for (size_t arg_idx = 0; arg_idx < num_args; ++arg_idx) {
+              std::string buffer;
+
+              VariableSP var_sp(args.GetVariableAtIndex(arg_idx));
+              ValueObjectSP var_value_sp(
+                  ValueObjectVariable::Create(exe_scope, var_sp));
+              StreamString ss;
+              const char *var_representation = nullptr;
+              const char *var_name = var_value_sp->GetName().GetCString();
+              if (var_value_sp->GetCompilerType().IsValid()) {
+                if (var_value_sp && exe_scope->CalculateTarget())
+                  var_value_sp =
+                      var_value_sp->GetQualifiedRepresentationIfAvailable(
+                          exe_scope->CalculateTarget()
+                              ->TargetProperties::GetPreferDynamicValue(),
+                          exe_scope->CalculateTarget()
+                              ->TargetProperties::GetEnableSyntheticValue());
+                if (var_value_sp->GetCompilerType().IsAggregateType() &&
+                    DataVisualization::ShouldPrintAsOneLiner(
+                        *var_value_sp.get())) {
+                  static StringSummaryFormat format(
+                      TypeSummaryImpl::Flags()
+                          .SetHideItemNames(false)
+                          .SetShowMembersOneLiner(true),
+                      "");
+                  format.FormatObject(var_value_sp.get(), buffer,
+                                      TypeSummaryOptions());
+                  var_representation = buffer.c_str();
+                } else
+                  var_value_sp->DumpPrintableRepresentation(
+                      ss,
+                      ValueObject::ValueObjectRepresentationStyle::
+                          eValueObjectRepresentationStyleSummary,
+                      eFormatDefault,
+                      ValueObject::PrintableRepresentationSpecialCases::eAllow,
+                      false);
+              }
+              if (ss.GetData() && ss.GetSize())
+                var_representation = ss.GetData();
+              if (arg_idx > 0)
+                s.PutCString(", ");
+              if (var_value_sp->GetError().Success()) {
+                if (var_representation)
+                  s.Printf("%s=%s", var_name, var_representation);
+                else
+                  s.Printf("%s=%s at %s", var_name,
+                           var_value_sp->GetTypeName().GetCString(),
+                           var_value_sp->GetLocationAsCString());
+              } else
+                s.Printf("%s=<unavailable>", var_name);
+            }
+
+            if (close_paren)
+              s.PutCString(close_paren);
+            else
+              s.PutChar(')');
+
+          } else {
+            s.PutCString(cstr);
+          }
+          return true;
+        }
+      }
+    }
+  }
+  }
+
+  return false;
+}
+
+void SwiftLanguage::GetExceptionResolverDescription(bool catch_on,
+                                                    bool throw_on, Stream &s) {
+  s.Printf("Swift Error breakpoint");
+}
+
+//------------------------------------------------------------------
+// PluginInterface protocol
+//------------------------------------------------------------------
+lldb_private::ConstString SwiftLanguage::GetPluginName() {
+  return GetPluginNameStatic();
+}
+
+uint32_t SwiftLanguage::GetPluginVersion() { return 1; }
+
+//------------------------------------------------------------------
+// Static Functions
+//------------------------------------------------------------------
+Language *SwiftLanguage::CreateInstance(lldb::LanguageType language) {
+  switch (language) {
+  case lldb::eLanguageTypeSwift:
+    return new SwiftLanguage();
+  default:
+    return nullptr;
+  }
+}
diff --git a/source/Plugins/Language/Swift/SwiftLanguage.h b/source/Plugins/Language/Swift/SwiftLanguage.h
index e69de29bb..15b6a6385 100644
--- a/source/Plugins/Language/Swift/SwiftLanguage.h
+++ b/source/Plugins/Language/Swift/SwiftLanguage.h
@@ -0,0 +1,96 @@
+//===-- SwiftLanguage.h -----------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftLanguage_h_
+#define liblldb_SwiftLanguage_h_
+
+// C Includes
+// C++ Includes
+// Other libraries and framework includes
+// Project includes
+#include "lldb/Target/Language.h"
+#include "lldb/lldb-private.h"
+
+namespace lldb_private {
+
+class SwiftLanguage : public Language {
+public:
+  virtual ~SwiftLanguage() = default;
+
+  SwiftLanguage() = default;
+
+  lldb::LanguageType GetLanguageType() const override {
+    return lldb::eLanguageTypeSwift;
+  }
+
+  bool IsTopLevelFunction(Function &function) override;
+
+  virtual lldb::TypeCategoryImplSP GetFormatters() override;
+
+  HardcodedFormatters::HardcodedSummaryFinder GetHardcodedSummaries() override;
+
+  HardcodedFormatters::HardcodedSyntheticFinder
+  GetHardcodedSynthetics() override;
+
+  std::vector<ConstString>
+  GetPossibleFormattersMatches(ValueObject &valobj,
+                               lldb::DynamicValueType use_dynamic) override;
+
+  virtual lldb_private::formatters::StringPrinter::EscapingHelper
+      GetStringPrinterEscapingHelper(
+          lldb_private::formatters::StringPrinter::GetPrintableElementType)
+          override;
+
+  std::unique_ptr<TypeScavenger> GetTypeScavenger() override;
+
+  const char *GetLanguageSpecificTypeLookupHelp() override;
+
+  bool GetFormatterPrefixSuffix(ValueObject &valobj, ConstString type_hint,
+                                std::string &prefix,
+                                std::string &suffix) override;
+
+  DumpValueObjectOptions::DeclPrintingHelper GetDeclPrintingHelper() override;
+
+  LazyBool IsLogicalTrue(ValueObject &valobj, Status &error) override;
+
+  bool IsUninitializedReference(ValueObject &valobj) override;
+
+  bool GetFunctionDisplayName(const SymbolContext *sc,
+                              const ExecutionContext *exe_ctx,
+                              FunctionNameRepresentation representation,
+                              Stream &s) override;
+
+  void GetExceptionResolverDescription(bool catch_on, bool throw_on,
+                                       Stream &s) override;
+
+  //------------------------------------------------------------------
+  // Static Functions
+  //------------------------------------------------------------------
+  static void Initialize();
+
+  static void Terminate();
+
+  static lldb_private::Language *CreateInstance(lldb::LanguageType language);
+
+  static lldb_private::ConstString GetPluginNameStatic();
+
+  //------------------------------------------------------------------
+  // PluginInterface protocol
+  //------------------------------------------------------------------
+  virtual ConstString GetPluginName() override;
+
+  virtual uint32_t GetPluginVersion() override;
+};
+
+} // namespace lldb_private
+
+#endif // liblldb_SwiftLanguage_h_
diff --git a/source/Plugins/Language/Swift/SwiftMetatype.cpp b/source/Plugins/Language/Swift/SwiftMetatype.cpp
index e69de29bb..9432f67f7 100644
--- a/source/Plugins/Language/Swift/SwiftMetatype.cpp
+++ b/source/Plugins/Language/Swift/SwiftMetatype.cpp
@@ -0,0 +1,51 @@
+//===-- SwiftMetatype.cpp ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftMetatype.h"
+#include "lldb/Core/Mangled.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+
+#include "swift/AST/Type.h"
+#include "swift/AST/Types.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+bool lldb_private::formatters::swift::SwiftMetatype_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  lldb::addr_t metadata_ptr = valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  if (metadata_ptr == LLDB_INVALID_ADDRESS || metadata_ptr == 0) {
+    CompilerType compiler_metatype_type(valobj.GetCompilerType());
+    CompilerType instancetype(compiler_metatype_type.GetInstanceType());
+    const char *ptr = instancetype.GetDisplayTypeName().AsCString(nullptr);
+    if (ptr && *ptr) {
+      stream.Printf("%s", ptr);
+      return true;
+    }
+  } else {
+    auto swift_runtime = valobj.GetProcessSP()->GetSwiftLanguageRuntime();
+    if (!swift_runtime)
+      return false;
+    SwiftLanguageRuntime::MetadataPromiseSP metadata_promise_sp =
+        swift_runtime->GetMetadataPromise(metadata_ptr);
+    if (CompilerType resolved_type =
+            metadata_promise_sp->FulfillTypePromise()) {
+      stream.Printf("%s", resolved_type.GetDisplayTypeName().AsCString());
+      return true;
+    }
+  }
+  return false;
+}
diff --git a/source/Plugins/Language/Swift/SwiftMetatype.h b/source/Plugins/Language/Swift/SwiftMetatype.h
index e69de29bb..a288ff5ef 100644
--- a/source/Plugins/Language/Swift/SwiftMetatype.h
+++ b/source/Plugins/Language/Swift/SwiftMetatype.h
@@ -0,0 +1,28 @@
+//===-- SwiftMetatype.h -----------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftMetatype_h_
+#define liblldb_SwiftMetatype_h_
+
+#include "lldb/lldb-forward.h"
+#include "lldb/lldb-private.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+bool SwiftMetatype_SummaryProvider(ValueObject &valobj, Stream &stream,
+                                   const TypeSummaryOptions &options);
+}
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftMetatype_h_
diff --git a/source/Plugins/Language/Swift/SwiftOptionSet.cpp b/source/Plugins/Language/Swift/SwiftOptionSet.cpp
index e69de29bb..9bea1d30c 100644
--- a/source/Plugins/Language/Swift/SwiftOptionSet.cpp
+++ b/source/Plugins/Language/Swift/SwiftOptionSet.cpp
@@ -0,0 +1,221 @@
+//===-- SwiftOptionSet.cpp --------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftOptionSet.h"
+
+#include "lldb/Core/ValueObject.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Utility/StreamString.h"
+
+#include "swift/AST/Decl.h"
+#include "swift/ClangImporter/ClangImporter.h"
+#include "clang/AST/Decl.h"
+#include "llvm/ADT/StringRef.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+bool lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+    WouldEvenConsiderFormatting(CompilerType clang_type) {
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(clang_type.GetTypeSystem());
+  if (!swift_ast_ctx)
+    return false;
+
+  return clang_type.IsValid() &&
+         swift_ast_ctx->IsTrivialOptionSetType(clang_type) &&
+         swift_ast_ctx->IsImportedType(clang_type, nullptr);
+}
+
+lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+    SwiftOptionSetSummaryProvider(CompilerType clang_type)
+    : TypeSummaryImpl(TypeSummaryImpl::Kind::eInternal,
+                      TypeSummaryImpl::Flags()),
+      m_type(clang_type), m_cases() {}
+
+static ConstString GetDisplayCaseName(::swift::ClangImporter *clang_importer,
+                                      clang::EnumConstantDecl *case_decl) {
+  if (clang_importer) {
+    ::swift::Identifier imported_identifier =
+        clang_importer->getEnumConstantName(case_decl);
+    if (false == imported_identifier.empty())
+      return ConstString(imported_identifier.str());
+  }
+  return ConstString(case_decl->getName());
+}
+
+static clang::EnumDecl *GetAsEnumDecl(const CompilerType &compiler_type) {
+  if (compiler_type.IsValid() &&
+      llvm::dyn_cast_or_null<ClangASTContext>(compiler_type.GetTypeSystem())) {
+    opaque_compiler_type_t clang_type = compiler_type.GetOpaqueQualType();
+    clang::QualType qual_type = clang::QualType::getFromOpaquePtr(clang_type);
+    const clang::Type::TypeClass type_class = qual_type->getTypeClass();
+    switch (type_class) {
+    case clang::Type::TypeClass::Enum: {
+      if (const clang::EnumType *enum_type =
+              qual_type->getAs<clang::EnumType>())
+        return enum_type->getDecl();
+    }
+    default:
+      break;
+    }
+  }
+
+  return nullptr;
+}
+
+void lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+    FillCasesIfNeeded() {
+  if (m_cases.hasValue())
+    return;
+
+  m_cases = CasesVector();
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(m_type.GetTypeSystem());
+
+  if (swift_ast_ctx && swift_ast_ctx->IsTrivialOptionSetType(m_type)) {
+    CompilerType original_type;
+    if (swift_ast_ctx->IsImportedType(m_type, &original_type)) {
+      clang::EnumDecl *enum_decl = GetAsEnumDecl(original_type);
+      if (enum_decl) {
+        ::swift::ClangImporter *clang_importer =
+            swift_ast_ctx->GetClangImporter();
+        auto iter = enum_decl->enumerator_begin(),
+             end = enum_decl->enumerator_end();
+        for (; iter != end; ++iter) {
+          clang::EnumConstantDecl *case_decl = *iter;
+          if (case_decl) {
+            llvm::APInt case_init_val(case_decl->getInitVal());
+            // extend all cases to 64 bits so that equality check is fast
+            // but if they are larger than 64, I am going to get out of that
+            // case
+            // and then pick it up again as unmatched data at the end
+            if (case_init_val.getBitWidth() < 64)
+              case_init_val = case_init_val.zext(64);
+            if (case_init_val.getBitWidth() > 64)
+              continue;
+            ConstString case_name(
+                GetDisplayCaseName(clang_importer, case_decl));
+            m_cases->push_back({case_init_val, case_name});
+          }
+        }
+      }
+    }
+  }
+}
+
+std::string lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+    GetDescription() {
+  StreamString sstr;
+  sstr.Printf("`%s `%s%s%s%s%s%s%s", "Swift OptionSet summary provider",
+              Cascades() ? "" : " (not cascading)", " (may show children)",
+              !DoesPrintValue(nullptr) ? " (hide value)" : "",
+              IsOneLiner() ? " (one-line printout)" : "",
+              SkipsPointers() ? " (skip pointers)" : "",
+              SkipsReferences() ? " (skip references)" : "",
+              HideNames(nullptr) ? " (hide member names)" : "");
+  return sstr.GetString();
+}
+
+static bool ReadValueIfAny(ValueObject &valobj, llvm::APInt &value) {
+  ValueObjectSP most_qualified_sp(valobj.GetQualifiedRepresentationIfAvailable(
+      lldb::eDynamicDontRunTarget, true));
+
+  bool success;
+  value = llvm::APInt(64, most_qualified_sp->GetValueAsUnsigned(0, &success));
+  return success;
+}
+
+static ValueObjectSP GetRawValue(ValueObject *valobj) {
+  if (!valobj)
+    return nullptr;
+
+  static ConstString g_rawValue("rawValue");
+
+  auto rawValue_sp = valobj->GetChildMemberWithName(g_rawValue, true);
+
+  return rawValue_sp;
+}
+
+bool lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+    FormatObject(ValueObject *valobj, std::string &dest,
+                 const TypeSummaryOptions &options) {
+  auto rawValue_sp = GetRawValue(valobj);
+  if (!rawValue_sp)
+    return false;
+
+  llvm::APInt value;
+  if (ReadValueIfAny(*rawValue_sp, value)) {
+    FillCasesIfNeeded();
+
+    StreamString ss;
+    bool first_match = true;
+    bool any_match = false;
+
+    llvm::APInt matched_value(llvm::APInt::getNullValue(64));
+
+    auto iter = m_cases->begin(), end = m_cases->end();
+    for (; iter != end; ++iter) {
+      llvm::APInt case_value = iter->first;
+      if ((case_value & value) == case_value) {
+        // hey a case matched!!
+        any_match = true;
+        if (first_match) {
+          ss.Printf("[.%s", iter->second.AsCString());
+          first_match = false;
+        } else {
+          ss.Printf(", .%s", iter->second.AsCString());
+        }
+
+        matched_value |= case_value;
+
+        // if we matched everything, get out
+        if (matched_value == value)
+          break;
+      }
+    }
+
+    if (any_match) {
+      // if we found a full match, then close the list
+      if (matched_value == value)
+        ss.PutChar(']');
+      else {
+        // print the unaccounted-for bits separately
+        llvm::APInt residual = (value & ~matched_value);
+        ss.Printf(", 0x%s]", residual.toString(16, false).c_str());
+      }
+    }
+
+    // if we printed anything, use it
+    const char *data = ss.GetData();
+    if (data && data[0]) {
+      dest.assign(data);
+      return true;
+    }
+  }
+  return false;
+}
+
+bool lldb_private::formatters::swift::SwiftOptionSetSummaryProvider::
+    DoesPrintChildren(ValueObject *valobj) const {
+  auto rawValue_sp = GetRawValue(valobj);
+  if (!rawValue_sp)
+    return false;
+
+  llvm::APInt value;
+  // only show children if you couldn't read the value of rawValue
+  return (false == ReadValueIfAny(*rawValue_sp, value));
+}
diff --git a/source/Plugins/Language/Swift/SwiftOptionSet.h b/source/Plugins/Language/Swift/SwiftOptionSet.h
index e69de29bb..245f75c9d 100644
--- a/source/Plugins/Language/Swift/SwiftOptionSet.h
+++ b/source/Plugins/Language/Swift/SwiftOptionSet.h
@@ -0,0 +1,64 @@
+//===-- SwiftOptionSet.h ----------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftOptionSet_h_
+#define liblldb_SwiftOptionSet_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Utility/ConstString.h"
+
+#include "llvm/ADT/APInt.h"
+#include "llvm/ADT/Optional.h"
+
+#include <vector>
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+struct SwiftOptionSetSummaryProvider : public TypeSummaryImpl {
+  static bool WouldEvenConsiderFormatting(CompilerType);
+
+  SwiftOptionSetSummaryProvider(CompilerType);
+
+  virtual ~SwiftOptionSetSummaryProvider() = default;
+
+  virtual bool FormatObject(ValueObject *valobj, std::string &dest,
+                            const TypeSummaryOptions &options);
+
+  virtual std::string GetDescription();
+
+  virtual bool IsScripted() { return false; }
+
+  virtual bool DoesPrintChildren(ValueObject *valobj) const;
+
+private:
+  DISALLOW_COPY_AND_ASSIGN(SwiftOptionSetSummaryProvider);
+
+  void FillCasesIfNeeded();
+
+  CompilerType m_type;
+
+  typedef std::vector<std::pair<llvm::APInt, lldb_private::ConstString>>
+      CasesVector;
+
+  llvm::Optional<CasesVector> m_cases;
+};
+
+bool SwiftOptionSet_SummaryProvider(ValueObject &valobj, Stream &stream);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftOptionSet_h_
diff --git a/source/Plugins/Language/Swift/SwiftOptional.cpp b/source/Plugins/Language/Swift/SwiftOptional.cpp
index e69de29bb..f0bf12472 100644
--- a/source/Plugins/Language/Swift/SwiftOptional.cpp
+++ b/source/Plugins/Language/Swift/SwiftOptional.cpp
@@ -0,0 +1,274 @@
+//===-- SwiftOptional.cpp ---------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftOptional.h"
+#include "lldb/DataFormatters/DataVisualization.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/ValueObjectPrinter.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Utility/DataBufferHeap.h"
+#include "lldb/Utility/DataExtractor.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+std::string lldb_private::formatters::swift::SwiftOptionalSummaryProvider::
+    GetDescription() {
+  StreamString sstr;
+  sstr.Printf("`%s `%s%s%s%s%s%s%s", "Swift.Optional summary provider",
+              Cascades() ? "" : " (not cascading)", " (may show children)",
+              !DoesPrintValue(nullptr) ? " (hide value)" : "",
+              IsOneLiner() ? " (one-line printout)" : "",
+              SkipsPointers() ? " (skip pointers)" : "",
+              SkipsReferences() ? " (skip references)" : "",
+              HideNames(nullptr) ? " (hide member names)" : "");
+  return sstr.GetString();
+}
+
+// if this ValueObject is an Optional<T> with the Some(T) case selected,
+// retrieve the value of the Some case..
+static PointerOrSP
+ExtractSomeIfAny(ValueObject *optional,
+                 lldb::DynamicValueType dynamic_value = lldb::eNoDynamicValues,
+                 bool synthetic_value = false) {
+  if (!optional)
+    return nullptr;
+
+  static ConstString g_Some("some");
+  static ConstString g_None("none");
+
+  ValueObjectSP non_synth_valobj = optional->GetNonSyntheticValue();
+  if (!non_synth_valobj)
+    return nullptr;
+
+  ConstString value(non_synth_valobj->GetValueAsCString());
+
+  if (!value || value == g_None)
+    return nullptr;
+
+  PointerOrSP value_sp(
+      non_synth_valobj->GetChildMemberWithName(g_Some, true).get());
+  if (!value_sp)
+    return nullptr;
+
+  SwiftASTContext::NonTriviallyManagedReferenceStrategy strategy;
+  if (SwiftASTContext::IsNonTriviallyManagedReferenceType(
+          non_synth_valobj->GetCompilerType(), strategy) &&
+      strategy ==
+          SwiftASTContext::NonTriviallyManagedReferenceStrategy::eWeak) {
+    if (auto process_sp = optional->GetProcessSP()) {
+      if (auto swift_runtime = process_sp->GetSwiftLanguageRuntime()) {
+        lldb::addr_t original_ptr =
+            value_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+        lldb::addr_t tweaked_ptr =
+            swift_runtime->MaybeMaskNonTrivialReferencePointer(original_ptr,
+                                                               strategy);
+        if (original_ptr != tweaked_ptr) {
+          CompilerType value_type(value_sp->GetCompilerType());
+          DataBufferSP buffer_sp(
+              new DataBufferHeap(&tweaked_ptr, sizeof(tweaked_ptr)));
+          DataExtractor extractor(buffer_sp, process_sp->GetByteOrder(),
+                                  process_sp->GetAddressByteSize());
+          ExecutionContext exe_ctx(process_sp);
+          value_sp = PointerOrSP(ValueObject::CreateValueObjectFromData(
+              value_sp->GetName().AsCString(), extractor, exe_ctx, value_type));
+          if (!value_sp)
+            return nullptr;
+          else
+            value_sp->SetSyntheticChildrenGenerated(true);
+        }
+      }
+    }
+  }
+
+  if (dynamic_value != lldb::eNoDynamicValues) {
+    ValueObjectSP dyn_value_sp = value_sp->GetDynamicValue(dynamic_value);
+    if (dyn_value_sp)
+      value_sp = dyn_value_sp;
+  }
+
+  if (synthetic_value && value_sp->HasSyntheticValue())
+    value_sp = value_sp->GetSyntheticValue();
+
+  return value_sp;
+}
+
+static bool
+SwiftOptional_SummaryProvider_Impl(ValueObject &valobj, Stream &stream,
+                                   const TypeSummaryOptions &options) {
+  PointerOrSP some =
+      ExtractSomeIfAny(&valobj, valobj.GetDynamicValueType(), true);
+  if (!some) {
+    stream.Printf("nil");
+    return true;
+  }
+
+  const char *value_summary = some->GetSummaryAsCString();
+
+  if (value_summary)
+    stream.Printf("%s", value_summary);
+  else if (lldb_private::DataVisualization::ShouldPrintAsOneLiner(*some)) {
+    TypeSummaryImpl::Flags oneliner_flags;
+    oneliner_flags.SetHideItemNames(false)
+        .SetCascades(true)
+        .SetDontShowChildren(false)
+        .SetDontShowValue(false)
+        .SetShowMembersOneLiner(true)
+        .SetSkipPointers(false)
+        .SetSkipReferences(false);
+    StringSummaryFormat oneliner(oneliner_flags, "");
+    std::string buffer;
+    oneliner.FormatObject(some, buffer, options);
+    stream.Printf("%s", buffer.c_str());
+  }
+
+  return true;
+}
+
+bool lldb_private::formatters::swift::SwiftOptionalSummaryProvider::
+    FormatObject(ValueObject *target_valobj_sp, std::string &dest,
+                 const TypeSummaryOptions &options) {
+  if (!target_valobj_sp)
+    return false;
+
+  StreamString stream;
+
+  bool is_ok =
+      SwiftOptional_SummaryProvider_Impl(*target_valobj_sp, stream, options);
+  dest.assign(stream.GetString());
+
+  return is_ok;
+}
+
+bool lldb_private::formatters::swift::SwiftOptionalSummaryProvider::
+    DoesPrintChildren(ValueObject *target_valobj) const {
+  if (!target_valobj)
+    return false;
+
+  PointerOrSP some = ExtractSomeIfAny(
+      target_valobj, target_valobj->GetDynamicValueType(), true);
+
+  if (!some)
+    return true;
+
+  lldb_private::Flags some_flags(some->GetCompilerType().GetTypeInfo());
+
+  if (some_flags.AllSet(eTypeIsSwift)) {
+    if (some_flags.AnySet(eTypeInstanceIsPointer | eTypeIsProtocol))
+      return true;
+  }
+
+  lldb::TypeSummaryImplSP summary_sp = some->GetSummaryFormat();
+
+  if (!summary_sp) {
+    if (lldb_private::DataVisualization::ShouldPrintAsOneLiner(*some))
+      return false;
+    else
+      return (some->GetNumChildren() > 0);
+  } else
+    return (some->GetNumChildren() > 0) &&
+           (summary_sp->DoesPrintChildren(some));
+}
+
+bool lldb_private::formatters::swift::SwiftOptionalSummaryProvider::
+    DoesPrintValue(ValueObject *valobj) const {
+  return false;
+}
+
+lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEnd::
+    SwiftOptionalSyntheticFrontEnd(lldb::ValueObjectSP valobj_sp)
+    : SyntheticChildrenFrontEnd(*valobj_sp.get()), m_is_none(false),
+      m_children(false), m_some(nullptr) {}
+
+bool lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEnd::IsEmpty()
+    const {
+  return (m_is_none == true || m_children == false || m_some == nullptr);
+}
+
+size_t lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEnd::
+    CalculateNumChildren() {
+  if (IsEmpty())
+    return 0;
+  return m_some->GetNumChildren();
+}
+
+lldb::ValueObjectSP lldb_private::formatters::swift::
+    SwiftOptionalSyntheticFrontEnd::GetChildAtIndex(size_t idx) {
+  if (IsEmpty())
+    return nullptr;
+  auto child = m_some->GetChildAtIndex(idx, true);
+  if (m_some->IsSyntheticChildrenGenerated())
+    child->SetSyntheticChildrenGenerated(true);
+  return child;
+}
+
+bool lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEnd::Update() {
+  m_some = nullptr;
+  m_is_none = true;
+  m_children = false;
+
+  m_some = ExtractSomeIfAny(&m_backend, m_backend.GetDynamicValueType(), true);
+
+  if (!m_some) {
+    m_is_none = true;
+    m_children = false;
+    return false;
+  }
+
+  m_is_none = false;
+
+  m_children = (m_some->GetNumChildren() > 0);
+
+  return false;
+}
+
+bool lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEnd::
+    MightHaveChildren() {
+  return IsEmpty() ? false : true;
+}
+
+size_t lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEnd::
+    GetIndexOfChildWithName(const ConstString &name) {
+  static ConstString g_Some("some");
+
+  if (IsEmpty())
+    return UINT32_MAX;
+
+  return m_some->GetIndexOfChildWithName(name);
+}
+
+lldb::ValueObjectSP lldb_private::formatters::swift::
+    SwiftOptionalSyntheticFrontEnd::GetSyntheticValue() {
+  if (m_some && m_some->CanProvideValue())
+    return m_some->GetSP();
+  return nullptr;
+}
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::SwiftOptionalSyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return nullptr;
+  return (new SwiftOptionalSyntheticFrontEnd(valobj_sp));
+}
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::SwiftUncheckedOptionalSyntheticFrontEndCreator(
+    CXXSyntheticChildren *cxx_synth, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return nullptr;
+  return SwiftOptionalSyntheticFrontEndCreator(cxx_synth, valobj_sp);
+}
diff --git a/source/Plugins/Language/Swift/SwiftOptional.h b/source/Plugins/Language/Swift/SwiftOptional.h
index e69de29bb..9accb3fe5 100644
--- a/source/Plugins/Language/Swift/SwiftOptional.h
+++ b/source/Plugins/Language/Swift/SwiftOptional.h
@@ -0,0 +1,123 @@
+//===-- SwiftOptional.h -----------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftOptional_h_
+#define liblldb_SwiftOptional_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+
+#include <cstddef>
+
+namespace lldb_private {
+namespace formatters {
+// ExtractSomeIfAny() can return EITHER a child member or some other long-lived
+// ValueObject
+// OR an entirely consed-up ValueObject
+// The lifetime of these two is radically different, and there is no trivial way
+// to do the right
+// thing for both cases - except have a class that can wrap either and is safe
+// to store and pass around
+class PointerOrSP {
+public:
+  PointerOrSP(std::nullptr_t) : m_raw_ptr(nullptr), m_shared_ptr(nullptr) {}
+
+  PointerOrSP(ValueObject *valobj) : m_raw_ptr(valobj), m_shared_ptr(nullptr) {}
+
+  PointerOrSP(lldb::ValueObjectSP valobj_sp)
+      : m_raw_ptr(nullptr), m_shared_ptr(valobj_sp) {}
+
+  ValueObject *operator->() {
+    if (m_shared_ptr)
+      return m_shared_ptr.get();
+    return m_raw_ptr;
+  }
+
+  ValueObject &operator*() { return *(this->operator->()); }
+
+  operator ValueObject *() { return this->operator->(); }
+
+  explicit operator bool() const {
+    return (m_shared_ptr.get() != nullptr) || (m_raw_ptr != nullptr);
+  }
+
+  bool operator==(std::nullptr_t) const { return !(this->operator bool()); }
+
+protected:
+  ValueObject *m_raw_ptr;
+  lldb::ValueObjectSP m_shared_ptr;
+};
+
+namespace swift {
+struct SwiftOptionalSummaryProvider : public TypeSummaryImpl {
+  SwiftOptionalSummaryProvider(const TypeSummaryImpl::Flags &flags)
+      : TypeSummaryImpl(TypeSummaryImpl::Kind::eInternal,
+                        TypeSummaryImpl::Flags()) {}
+
+  virtual ~SwiftOptionalSummaryProvider() {}
+
+  virtual bool FormatObject(ValueObject *valobj, std::string &dest,
+                            const TypeSummaryOptions &options);
+
+  virtual std::string GetDescription();
+
+  virtual bool IsScripted() { return false; }
+
+  virtual bool DoesPrintChildren(ValueObject *valobj) const;
+
+  virtual bool DoesPrintValue(ValueObject *valobj) const;
+
+private:
+  DISALLOW_COPY_AND_ASSIGN(SwiftOptionalSummaryProvider);
+};
+
+bool SwiftOptional_SummaryProvider(ValueObject &valobj, Stream &stream);
+
+class SwiftOptionalSyntheticFrontEnd : public SyntheticChildrenFrontEnd {
+public:
+  SwiftOptionalSyntheticFrontEnd(lldb::ValueObjectSP valobj_sp);
+
+  virtual size_t CalculateNumChildren();
+
+  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx);
+
+  virtual bool Update();
+
+  virtual bool MightHaveChildren();
+
+  virtual size_t GetIndexOfChildWithName(const ConstString &name);
+
+  virtual lldb::ValueObjectSP GetSyntheticValue();
+
+  virtual ~SwiftOptionalSyntheticFrontEnd() = default;
+
+private:
+  bool m_is_none;
+  bool m_children;
+  PointerOrSP m_some;
+
+  bool IsEmpty() const;
+};
+
+SyntheticChildrenFrontEnd *
+SwiftOptionalSyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                      lldb::ValueObjectSP);
+SyntheticChildrenFrontEnd *
+SwiftUncheckedOptionalSyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                               lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftOptional_h_
diff --git a/source/Plugins/Language/Swift/SwiftSet.cpp b/source/Plugins/Language/Swift/SwiftSet.cpp
index e69de29bb..94e713bc8 100644
--- a/source/Plugins/Language/Swift/SwiftSet.cpp
+++ b/source/Plugins/Language/Swift/SwiftSet.cpp
@@ -0,0 +1,147 @@
+//===-- SwiftSet.cpp --------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "SwiftSet.h"
+
+#include "lldb/DataFormatters/FormattersHelpers.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+
+#include "swift/AST/ASTContext.h"
+#include "llvm/ADT/StringRef.h"
+
+using namespace lldb;
+using namespace lldb_private;
+using namespace lldb_private::formatters;
+using namespace lldb_private::formatters::swift;
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+class SwiftSetNativeBufferHandler
+    : public SwiftHashedContainerNativeBufferHandler {
+public:
+  SwiftHashedContainerBufferHandler::Kind GetKind() { return Kind::eSet; }
+
+  static ConstString GetMangledStorageTypeName();
+
+  static ConstString GetDemangledStorageTypeName();
+
+  virtual lldb::ValueObjectSP GetElementAtIndex(size_t);
+
+  SwiftSetNativeBufferHandler(ValueObjectSP nativeStorage_sp,
+                              CompilerType key_type)
+      : SwiftHashedContainerNativeBufferHandler(nativeStorage_sp, key_type,
+                                                CompilerType()) {}
+  friend class SwiftHashedContainerBufferHandler;
+
+private:
+};
+
+class SwiftSetSyntheticFrontEndBufferHandler
+    : public SwiftHashedContainerSyntheticFrontEndBufferHandler {
+public:
+  SwiftHashedContainerBufferHandler::Kind GetKind() { return Kind::eSet; }
+
+  virtual ~SwiftSetSyntheticFrontEndBufferHandler() {}
+
+  SwiftSetSyntheticFrontEndBufferHandler(lldb::ValueObjectSP valobj_sp)
+      : SwiftHashedContainerSyntheticFrontEndBufferHandler(valobj_sp) {}
+  friend class SwiftHashedContainerBufferHandler;
+
+private:
+};
+
+class SetSyntheticFrontEnd : public HashedContainerSyntheticFrontEnd {
+public:
+  SetSyntheticFrontEnd(lldb::ValueObjectSP valobj_sp)
+      : HashedContainerSyntheticFrontEnd(valobj_sp) {}
+
+  virtual bool Update();
+
+  virtual ~SetSyntheticFrontEnd() = default;
+};
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+SyntheticChildrenFrontEnd *
+lldb_private::formatters::swift::SetSyntheticFrontEndCreator(
+    CXXSyntheticChildren *, lldb::ValueObjectSP valobj_sp) {
+  if (!valobj_sp)
+    return NULL;
+  return (new SetSyntheticFrontEnd(valobj_sp));
+}
+
+bool lldb_private::formatters::swift::SetSyntheticFrontEnd::Update() {
+  m_buffer = SwiftHashedContainerBufferHandler::CreateBufferHandler(
+      m_backend,
+      [](ValueObjectSP a, CompilerType b,
+         CompilerType c) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftSetNativeBufferHandler(a, b);
+      },
+      [](ValueObjectSP a) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftSetSyntheticFrontEndBufferHandler(a);
+      },
+      SwiftSetNativeBufferHandler::GetMangledStorageTypeName(),
+      SwiftSetNativeBufferHandler::GetDemangledStorageTypeName());
+  return false;
+}
+
+bool lldb_private::formatters::swift::Set_SummaryProvider(
+    ValueObject &valobj, Stream &stream, const TypeSummaryOptions &options) {
+  auto handler = SwiftHashedContainerBufferHandler::CreateBufferHandler(
+      valobj,
+      [](ValueObjectSP a, CompilerType b,
+         CompilerType c) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftSetNativeBufferHandler(a, b);
+      },
+      [](ValueObjectSP a) -> SwiftHashedContainerBufferHandler * {
+        return new SwiftSetSyntheticFrontEndBufferHandler(a);
+      },
+      SwiftSetNativeBufferHandler::GetMangledStorageTypeName(),
+      SwiftSetNativeBufferHandler::GetDemangledStorageTypeName());
+
+  if (!handler)
+    return false;
+
+  auto count = handler->GetCount();
+
+  stream.Printf("%zu value%s", count, (count == 1 ? "" : "s"));
+
+  return true;
+};
+
+lldb::ValueObjectSP SwiftSetNativeBufferHandler::GetElementAtIndex(size_t idx) {
+  ValueObjectSP parent_element(
+      this->SwiftHashedContainerNativeBufferHandler::GetElementAtIndex(idx));
+  if (!parent_element)
+    return parent_element;
+  static ConstString g_key("key");
+  ValueObjectSP key_child(parent_element->GetChildMemberWithName(g_key, true));
+  return key_child ? (key_child->SetName(parent_element->GetName()), key_child)
+                   : parent_element;
+}
+
+ConstString SwiftSetNativeBufferHandler::GetMangledStorageTypeName() {
+  static ConstString g_name(SwiftLanguageRuntime::GetCurrentMangledName(
+      "_TtCs22_NativeSetStorageOwner"));
+  return g_name;
+}
+
+ConstString SwiftSetNativeBufferHandler::GetDemangledStorageTypeName() {
+  static ConstString g_name(
+      "Swift._NativeSetStorageOwner with unmangled suffix");
+  return g_name;
+}
diff --git a/source/Plugins/Language/Swift/SwiftSet.h b/source/Plugins/Language/Swift/SwiftSet.h
index e69de29bb..76364b594 100644
--- a/source/Plugins/Language/Swift/SwiftSet.h
+++ b/source/Plugins/Language/Swift/SwiftSet.h
@@ -0,0 +1,38 @@
+//===-- SwiftSet.h ----------------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_SwiftSet_h_
+#define liblldb_SwiftSet_h_
+
+#include "lldb/lldb-forward.h"
+
+#include "SwiftHashedContainer.h"
+#include "lldb/DataFormatters/FormatClasses.h"
+#include "lldb/DataFormatters/TypeSummary.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/Symbol/CompilerType.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/ConstString.h"
+
+namespace lldb_private {
+namespace formatters {
+namespace swift {
+bool Set_SummaryProvider(ValueObject &valobj, Stream &stream,
+                         const TypeSummaryOptions &options);
+
+SyntheticChildrenFrontEnd *SetSyntheticFrontEndCreator(CXXSyntheticChildren *,
+                                                       lldb::ValueObjectSP);
+} // namespace swift
+} // namespace formatters
+} // namespace lldb_private
+
+#endif // liblldb_SwiftSet_h_
diff --git a/source/Plugins/Language/Swift/URLComponents.def b/source/Plugins/Language/Swift/URLComponents.def
index e69de29bb..0e6dfd967 100644
--- a/source/Plugins/Language/Swift/URLComponents.def
+++ b/source/Plugins/Language/Swift/URLComponents.def
@@ -0,0 +1,15 @@
+#ifndef COMPONENT
+#define COMPONENT(Name, PrettyName, Index)
+#endif
+
+COMPONENT(urlString, urlString, 0)
+COMPONENT(schemeComponent, scheme, 1)
+COMPONENT(userComponent, user, 2)
+COMPONENT(passwordComponent, password, 3)
+COMPONENT(hostComponent, host, 4)
+COMPONENT(portComponent, port, 5)
+COMPONENT(pathComponent, path, 6)
+COMPONENT(queryComponent, query, 7)
+COMPONENT(fragmentComponent, fragment, 8)
+
+#undef COMPONENT
diff --git a/source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/ItaniumABILanguageRuntime.cpp b/source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/ItaniumABILanguageRuntime.cpp
index e5a459dfe..b11995436 100644
--- a/source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/ItaniumABILanguageRuntime.cpp
+++ b/source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/ItaniumABILanguageRuntime.cpp
@@ -44,8 +44,9 @@ static const char *vtable_demangled_prefix = "vtable for ";
 bool ItaniumABILanguageRuntime::CouldHaveDynamicValue(ValueObject &in_value) {
   const bool check_cxx = true;
   const bool check_objc = false;
-  return in_value.GetCompilerType().IsPossibleDynamicType(NULL, check_cxx,
-                                                          check_objc);
+  const bool check_swift = false;
+  return in_value.GetCompilerType().IsPossibleDynamicType(
+      NULL, check_cxx, check_objc, check_swift);
 }
 
 TypeAndOrName ItaniumABILanguageRuntime::GetTypeInfoFromVTableAddress(
diff --git a/source/Plugins/LanguageRuntime/Java/JavaLanguageRuntime.cpp b/source/Plugins/LanguageRuntime/Java/JavaLanguageRuntime.cpp
index 36c30a99f..c8b0086b4 100644
--- a/source/Plugins/LanguageRuntime/Java/JavaLanguageRuntime.cpp
+++ b/source/Plugins/LanguageRuntime/Java/JavaLanguageRuntime.cpp
@@ -105,7 +105,7 @@ bool JavaLanguageRuntime::GetDynamicTypeAndAddress(
 
   ConstString linkage_name;
   CompilerType in_type = in_value.GetCompilerType();
-  if (in_type.IsPossibleDynamicType(nullptr, false, false))
+  if (in_type.IsPossibleDynamicType(nullptr, false, false, false))
     linkage_name = GetDynamicTypeId(&exe_ctx, target, in_value);
   else
     linkage_name = JavaASTContext::GetLinkageName(in_type);
diff --git a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.cpp b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.cpp
index eacc98a07..1a863907a 100644
--- a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.cpp
+++ b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.cpp
@@ -235,10 +235,17 @@ Address *AppleObjCRuntime::GetPrintForDebuggerAddr() {
 }
 
 bool AppleObjCRuntime::CouldHaveDynamicValue(ValueObject &in_value) {
+  return CouldHaveDynamicValue(in_value,
+                               /* allow_swift = */ false);
+}
+
+bool AppleObjCRuntime::CouldHaveDynamicValue(ValueObject &in_value,
+                                             bool allow_swift) {
   return in_value.GetCompilerType().IsPossibleDynamicType(
       NULL,
       false, // do not check C++
-      true); // check ObjC
+      true,  // check ObjC
+      allow_swift);
 }
 
 bool AppleObjCRuntime::GetDynamicTypeAndAddress(
@@ -279,6 +286,17 @@ AppleObjCRuntime::FixUpDynamicType(const TypeAndOrName &type_and_or_name,
   return ret;
 }
 
+bool AppleObjCRuntime::GetDynamicTypeAndAddress(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address,
+    Value::ValueType &value_type, bool allow_swift) {
+  if (!allow_swift)
+    return GetDynamicTypeAndAddress(in_value, use_dynamic, class_type_or_name,
+                                    address, value_type);
+  else
+    return false;
+}
+
 bool AppleObjCRuntime::AppleIsModuleObjCLibrary(const ModuleSP &module_sp) {
   if (module_sp) {
     const FileSpec &module_file_spec = module_sp->GetFileSpec();
diff --git a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.h b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.h
index 57d98fbd7..7e06b149a 100644
--- a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.h
+++ b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.h
@@ -53,12 +53,21 @@ public:
 
   bool CouldHaveDynamicValue(ValueObject &in_value) override;
 
+  virtual bool CouldHaveDynamicValue(ValueObject &in_value, bool allow_swift);
+
   bool GetDynamicTypeAndAddress(ValueObject &in_value,
                                 lldb::DynamicValueType use_dynamic,
                                 TypeAndOrName &class_type_or_name,
                                 Address &address,
                                 Value::ValueType &value_type) override;
 
+  virtual bool GetDynamicTypeAndAddress(ValueObject &in_value,
+                                        lldb::DynamicValueType use_dynamic,
+                                        TypeAndOrName &class_type_or_name,
+                                        Address &address,
+                                        Value::ValueType &value_type,
+                                        bool allow_swift);
+
   TypeAndOrName FixUpDynamicType(const TypeAndOrName &type_and_or_name,
                                  ValueObject &static_value) override;
 
@@ -96,6 +105,8 @@ public:
   virtual void GetValuesForGlobalCFBooleans(lldb::addr_t &cf_true,
                                             lldb::addr_t &cf_false);
 
+  virtual bool IsTaggedPointer (lldb::addr_t addr) { return false; }
+
 protected:
   // Call CreateInstance instead.
   AppleObjCRuntime(Process *process);
diff --git a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.cpp b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.cpp
index 2a7735959..22384f4e3 100644
--- a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.cpp
+++ b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.cpp
@@ -62,6 +62,11 @@
 #include "AppleObjCTrampolineHandler.h"
 #include "AppleObjCTypeEncodingParser.h"
 
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DeclObjC.h"
+
+#include <vector>
+
 using namespace lldb;
 using namespace lldb_private;
 
@@ -394,9 +399,9 @@ AppleObjCRuntimeV2::AppleObjCRuntimeV2(Process *process,
 }
 
 bool AppleObjCRuntimeV2::GetDynamicTypeAndAddress(
-    ValueObject &in_value, DynamicValueType use_dynamic,
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
     TypeAndOrName &class_type_or_name, Address &address,
-    Value::ValueType &value_type) {
+    Value::ValueType &value_type, bool allow_swift) {
   // We should never get here with a null process...
   assert(m_process != NULL);
 
@@ -416,7 +421,7 @@ bool AppleObjCRuntimeV2::GetDynamicTypeAndAddress(
   value_type = Value::ValueType::eValueTypeScalar;
 
   // Make sure we can have a dynamic value before starting...
-  if (CouldHaveDynamicValue(in_value)) {
+  if (CouldHaveDynamicValue(in_value, allow_swift)) {
     // First job, pull out the address at 0 offset from the object  That will be
     // the ISA pointer.
     ClassDescriptorSP objc_class_sp(GetNonKVOClassDescriptor(in_value));
@@ -450,6 +455,15 @@ bool AppleObjCRuntimeV2::GetDynamicTypeAndAddress(
   return class_type_or_name.IsEmpty() == false;
 }
 
+bool AppleObjCRuntimeV2::GetDynamicTypeAndAddress(
+    ValueObject &in_value, DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address,
+    Value::ValueType &value_type) {
+  return GetDynamicTypeAndAddress(in_value, use_dynamic, class_type_or_name,
+                                  address, value_type,
+                                  /* allow_swift = */ false);
+}
+
 //------------------------------------------------------------------
 // Static Functions
 //------------------------------------------------------------------
diff --git a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.h b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.h
index 718073090..94e0d58b9 100644
--- a/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.h
+++ b/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntimeV2.h
@@ -58,6 +58,12 @@ public:
                                 Address &address,
                                 Value::ValueType &value_type) override;
 
+  bool GetDynamicTypeAndAddress(ValueObject &in_value,
+                                lldb::DynamicValueType use_dynamic,
+                                TypeAndOrName &class_type_or_name,
+                                Address &address, Value::ValueType &value_type,
+                                bool allow_swift) override;
+
   UtilityFunction *CreateObjectChecker(const char *) override;
 
   //------------------------------------------------------------------
@@ -88,6 +94,8 @@ public:
 
   EncodingToTypeSP GetEncodingToType() override;
 
+  bool IsTaggedPointer(lldb::addr_t ptr) override;
+
   TaggedPointerVendor *GetTaggedPointerVendor() override {
     return m_tagged_pointer_vendor_ap.get();
   }
@@ -279,8 +287,6 @@ private:
 
   ObjCISA GetPointerISA(ObjCISA isa);
 
-  bool IsTaggedPointer(lldb::addr_t ptr);
-
   lldb::addr_t GetISAHashTablePointer();
 
   bool UpdateISAToDescriptorMapFromMemory(RemoteNXMapTable &hash_table);
@@ -305,6 +311,7 @@ private:
   bool GetCFBooleanValuesIfNeeded();
 
   friend class ClassDescriptorV2;
+  friend class SwiftLanguageRuntime;
 
   std::unique_ptr<UtilityFunction> m_get_class_info_code;
   lldb::addr_t m_get_class_info_args;
diff --git a/source/Plugins/ObjectFile/ELF/ObjectFileELF.cpp b/source/Plugins/ObjectFile/ELF/ObjectFileELF.cpp
index 3b33cf160..a3d65f109 100644
--- a/source/Plugins/ObjectFile/ELF/ObjectFileELF.cpp
+++ b/source/Plugins/ObjectFile/ELF/ObjectFileELF.cpp
@@ -22,6 +22,7 @@
 #include "lldb/Symbol/DWARFCallFrameInfo.h"
 #include "lldb/Symbol/SymbolContext.h"
 #include "lldb/Target/SectionLoadList.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/DataBufferLLVM.h"
 #include "lldb/Utility/Log.h"
@@ -1857,6 +1858,7 @@ void ObjectFileELF::CreateSections(SectionList &unified_section_list) {
       static ConstString g_sect_name_dwarf_debug_str_offsets_dwo(
           ".debug_str_offsets.dwo");
       static ConstString g_sect_name_eh_frame(".eh_frame");
+      static ConstString g_sect_name_swift_ast(".swift_ast");
       static ConstString g_sect_name_arm_exidx(".ARM.exidx");
       static ConstString g_sect_name_arm_extab(".ARM.extab");
       static ConstString g_sect_name_go_symtab(".gosymtab");
@@ -1942,6 +1944,8 @@ void ObjectFileELF::CreateSections(SectionList &unified_section_list) {
         sect_type = eSectionTypeDWARFDebugStrOffsets;
       else if (name == g_sect_name_eh_frame)
         sect_type = eSectionTypeEHFrame;
+      else if (name == g_sect_name_swift_ast)
+        sect_type = eSectionTypeSwiftModules;
       else if (name == g_sect_name_arm_exidx)
         sect_type = eSectionTypeARMexidx;
       else if (name == g_sect_name_arm_extab)
@@ -2364,7 +2368,8 @@ unsigned ObjectFileELF::ParseSymbols(Symtab *symtab, user_id_t start_id,
 
     bool is_global = symbol.getBinding() == STB_GLOBAL;
     uint32_t flags = symbol.st_other << 8 | symbol.st_info | additional_flags;
-    bool is_mangled = (symbol_name[0] == '_' && symbol_name[1] == 'Z');
+    bool is_mangled =
+        (symbol_name && symbol_name[0] == '_' && symbol_name[1] == 'Z');
 
     llvm::StringRef symbol_ref(symbol_name);
 
@@ -2373,6 +2378,12 @@ unsigned ObjectFileELF::ParseSymbols(Symtab *symtab, user_id_t start_id,
     size_t version_pos = symbol_ref.find('@');
     bool has_suffix = version_pos != llvm::StringRef::npos;
     llvm::StringRef symbol_bare = symbol_ref.substr(0, version_pos);
+
+    Mangled guess_the_language(ConstString(symbol_bare), true);
+    if (guess_the_language.GuessLanguage() != lldb::eLanguageTypeUnknown) {
+      is_mangled = true;
+    }
+
     Mangled mangled(ConstString(symbol_bare), is_mangled);
 
     // Now append the suffix back to mangled and unmangled names. Only do it if
@@ -2392,6 +2403,9 @@ unsigned ObjectFileELF::ParseSymbols(Symtab *symtab, user_id_t start_id,
         mangled.SetDemangledName(ConstString((demangled_name + suffix).str()));
     }
 
+    if (SwiftLanguageRuntime::IsMetadataSymbol(symbol_name))
+      symbol_type = eSymbolTypeMetadata;
+
     // In ELF all symbol should have a valid size but it is not true for some
     // function symbols
     // coming from hand written assembly. As none of the function symbol should
diff --git a/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp b/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp
index 9bc171e45..1805b6346 100644
--- a/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp
+++ b/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp
@@ -35,6 +35,7 @@
 #include "lldb/Target/Platform.h"
 #include "lldb/Target/Process.h"
 #include "lldb/Target/SectionLoadList.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/Thread.h"
 #include "lldb/Target/ThreadList.h"
@@ -1213,8 +1214,10 @@ AddressClass ObjectFileMachO::GetAddressClass(lldb::addr_t file_addr) {
           case eSectionTypeDWARFDebugStrOffsets:
           case eSectionTypeDWARFAppleNames:
           case eSectionTypeDWARFAppleTypes:
+          case eSectionTypeDWARFAppleExternalTypes:
           case eSectionTypeDWARFAppleNamespaces:
           case eSectionTypeDWARFAppleObjC:
+          case eSectionTypeSwiftModules:
             return eAddressClassDebug;
 
           case eSectionTypeEHFrame:
@@ -1298,8 +1301,14 @@ AddressClass ObjectFileMachO::GetAddressClass(lldb::addr_t file_addr) {
         return eAddressClassRuntime;
       case eSymbolTypeObjCIVar:
         return eAddressClassRuntime;
+      case eSymbolTypeIVarOffset:
+        return eAddressClassRuntime;
+      case eSymbolTypeMetadata:
+        return eAddressClassRuntime;
       case eSymbolTypeReExported:
         return eAddressClassRuntime;
+      case eSymbolTypeASTFile:
+        return eAddressClassDebug;
       }
     }
   }
@@ -1726,6 +1735,8 @@ void ObjectFileMachO::CreateSections(SectionList &unified_section_list) {
                       "__apple_names");
                   static ConstString g_sect_name_dwarf_apple_types(
                       "__apple_types");
+                  static ConstString g_sect_name_dwarf_apple_exttypes(
+                      "__apple_exttypes");
                   static ConstString g_sect_name_dwarf_apple_namespaces(
                       "__apple_namespac");
                   static ConstString g_sect_name_dwarf_apple_objc(
@@ -1735,6 +1746,8 @@ void ObjectFileMachO::CreateSections(SectionList &unified_section_list) {
                       "__unwind_info");
                   static ConstString g_sect_name_text("__text");
                   static ConstString g_sect_name_data("__data");
+                  static ConstString g_sect_name_swift_ast_old("__ast");
+                  static ConstString g_sect_name_swift_ast("__swift_ast");
                   static ConstString g_sect_name_go_symtab("__gosymtab");
 
                   if (section_name == g_sect_name_dwarf_debug_abbrev)
@@ -1763,6 +1776,8 @@ void ObjectFileMachO::CreateSections(SectionList &unified_section_list) {
                     sect_type = eSectionTypeDWARFAppleNames;
                   else if (section_name == g_sect_name_dwarf_apple_types)
                     sect_type = eSectionTypeDWARFAppleTypes;
+                  else if (section_name == g_sect_name_dwarf_apple_exttypes)
+                    sect_type = eSectionTypeDWARFAppleExternalTypes;
                   else if (section_name == g_sect_name_dwarf_apple_namespaces)
                     sect_type = eSectionTypeDWARFAppleNamespaces;
                   else if (section_name == g_sect_name_dwarf_apple_objc)
@@ -1777,6 +1792,9 @@ void ObjectFileMachO::CreateSections(SectionList &unified_section_list) {
                     sect_type = eSectionTypeCompactUnwind;
                   else if (section_name == g_sect_name_cfstring)
                     sect_type = eSectionTypeDataObjCCFStrings;
+                  else if (section_name == g_sect_name_swift_ast ||
+                           section_name == g_sect_name_swift_ast_old)
+                    sect_type = eSectionTypeSwiftModules;
                   else if (section_name == g_sect_name_go_symtab)
                     sect_type = eSectionTypeGoSymtab;
                   else if (section_name == g_sect_name_objc_data ||
@@ -2026,8 +2044,44 @@ struct TrieEntryWithOffset {
   }
 };
 
+static LazyBool CalculateNameIsSwift(std::vector<llvm::StringRef> &nameSlices) {
+  // Currently a symbol is defined to possibly be in the Trie only if
+  // it is a swift symbol. Swift mangled names start with "__T" so we
+  // need to see if the nameSlices start with "__T", but of course
+  // this could be broken up into at most 3 entries.
+
+  llvm::StringRef swift_prefix("__T");
+
+  for (const auto &name : nameSlices) {
+    const size_t name_len = name.size();
+    const size_t swift_prefix_len =
+        swift_prefix.size(); // This length changes as we trim it down so we
+                             // must always fetch it
+    if (swift_prefix_len > name_len) {
+      // The remaining swift prefix is longer than the current
+      // name slice, so if the prefix starts with the name, then
+      // trim characters off the swift prefix and keep looking,
+      // else we are done if the swift prefix doesn't start with
+      // the name
+      if (swift_prefix.startswith(name))
+        swift_prefix = swift_prefix.substr(name_len);
+      else
+        return eLazyBoolNo;
+    } else {
+      // The current name slice is greater than or equal to
+      // the remaining prefix, so just test if it starts with
+      // the prefix and we are done
+      if (name.startswith(swift_prefix))
+        return eLazyBoolYes;
+      else
+        return eLazyBoolNo;
+    }
+  }
+  return eLazyBoolCalculate;
+}
+
 static bool ParseTrieEntries(DataExtractor &data, lldb::offset_t offset,
-                             const bool is_arm,
+                             const bool is_arm, const LazyBool symbol_is_swift,
                              std::vector<llvm::StringRef> &nameSlices,
                              std::set<lldb::addr_t> &resolver_addresses,
                              std::vector<TrieEntryWithOffset> &output) {
@@ -2056,8 +2110,9 @@ static bool ParseTrieEntries(DataExtractor &data, lldb::offset_t offset,
         e.entry.other = 0;
     }
     // Only add symbols that are reexport symbols with a valid import name
-    if (EXPORT_SYMBOL_FLAGS_REEXPORT & e.entry.flags && import_name &&
-        import_name[0]) {
+    if ((EXPORT_SYMBOL_FLAGS_REEXPORT & e.entry.flags && import_name &&
+         import_name[0]) ||
+        symbol_is_swift == eLazyBoolYes) {
       std::string name;
       if (!nameSlices.empty()) {
         for (auto name_slice : nameSlices)
@@ -2082,9 +2137,16 @@ static bool ParseTrieEntries(DataExtractor &data, lldb::offset_t offset,
       nameSlices.push_back(llvm::StringRef(cstr));
     else
       return false; // Corrupt data
+
+    const LazyBool child_symbol_is_swift =
+        (symbol_is_swift == eLazyBoolCalculate)
+            ? CalculateNameIsSwift(nameSlices)
+            : symbol_is_swift;
+
     lldb::offset_t childNodeOffset = data.GetULEB128(&children_offset);
     if (childNodeOffset) {
-      if (!ParseTrieEntries(data, childNodeOffset, is_arm, nameSlices,
+      if (!ParseTrieEntries(data, childNodeOffset, is_arm,
+                            child_symbol_is_swift, nameSlices,
                             resolver_addresses, output)) {
         return false;
       }
@@ -2120,6 +2182,82 @@ UUID ObjectFileMachO::GetSharedCacheUUID(FileSpec dyld_shared_cache,
   return dsc_uuid;
 }
 
+static SymbolType GetSymbolType(
+    const char *&symbol_name, const char *&symbol_name_non_abi_mangled,
+    bool &demangled_is_synthesized, const SectionSP &text_section_sp,
+    const SectionSP &data_section_sp, const SectionSP &data_dirty_section_sp,
+    const SectionSP &data_const_section_sp, const SectionSP &objc_section_sp,
+    const SectionSP &symbol_section) {
+  SymbolType type = eSymbolTypeInvalid;
+
+  const char *symbol_sect_name = symbol_section->GetName().AsCString();
+  if (symbol_section->IsDescendant(text_section_sp.get())) {
+    if (symbol_section->IsClear(S_ATTR_PURE_INSTRUCTIONS |
+                                S_ATTR_SELF_MODIFYING_CODE |
+                                S_ATTR_SOME_INSTRUCTIONS))
+      type = eSymbolTypeData;
+    else
+      type = eSymbolTypeCode;
+  } else if (symbol_section->IsDescendant(data_section_sp.get()) ||
+             symbol_section->IsDescendant(data_dirty_section_sp.get()) ||
+             symbol_section->IsDescendant(data_const_section_sp.get())) {
+    if (symbol_sect_name &&
+        ::strstr(symbol_sect_name, "__objc") == symbol_sect_name) {
+      type = eSymbolTypeRuntime;
+
+      if (symbol_name) {
+        llvm::StringRef symbol_name_ref(symbol_name);
+        if (symbol_name_ref.startswith("_OBJC_")) {
+          static const llvm::StringRef g_objc_v2_prefix_class("_OBJC_CLASS_$_");
+          static const llvm::StringRef g_objc_v2_prefix_metaclass(
+              "_OBJC_METACLASS_$_");
+          static const llvm::StringRef g_objc_v2_prefix_ivar("_OBJC_IVAR_$_");
+          if (symbol_name_ref.startswith(g_objc_v2_prefix_class)) {
+            symbol_name_non_abi_mangled = symbol_name + 1;
+            symbol_name = symbol_name + g_objc_v2_prefix_class.size();
+            type = eSymbolTypeObjCClass;
+            demangled_is_synthesized = true;
+          } else if (symbol_name_ref.startswith(g_objc_v2_prefix_metaclass)) {
+            symbol_name_non_abi_mangled = symbol_name + 1;
+            symbol_name = symbol_name + g_objc_v2_prefix_metaclass.size();
+            type = eSymbolTypeObjCMetaClass;
+            demangled_is_synthesized = true;
+          } else if (symbol_name_ref.startswith(g_objc_v2_prefix_ivar)) {
+            symbol_name_non_abi_mangled = symbol_name + 1;
+            symbol_name = symbol_name + g_objc_v2_prefix_ivar.size();
+            type = eSymbolTypeObjCIVar;
+            demangled_is_synthesized = true;
+          }
+        } else if (symbol_name_ref.startswith("__TM")) {
+          type = eSymbolTypeMetadata;
+        }
+      }
+    } else if (symbol_sect_name &&
+               ::strstr(symbol_sect_name, "__gcc_except_tab") ==
+                   symbol_sect_name) {
+      type = eSymbolTypeException;
+    } else {
+      type = eSymbolTypeData;
+    }
+  } else if (symbol_sect_name &&
+             ::strstr(symbol_sect_name, "__IMPORT") == symbol_sect_name) {
+    type = eSymbolTypeTrampoline;
+  } else if (symbol_section->IsDescendant(objc_section_sp.get())) {
+    type = eSymbolTypeRuntime;
+    if (symbol_name && symbol_name[0] == '.') {
+      llvm::StringRef symbol_name_ref(symbol_name);
+      static const llvm::StringRef g_objc_v1_prefix_class(".objc_class_name_");
+      if (symbol_name_ref.startswith(g_objc_v1_prefix_class)) {
+        symbol_name_non_abi_mangled = symbol_name;
+        symbol_name = symbol_name + g_objc_v1_prefix_class.size();
+        type = eSymbolTypeObjCClass;
+        demangled_is_synthesized = true;
+      }
+    }
+  }
+  return type;
+}
+
 size_t ObjectFileMachO::ParseSymtab() {
   static Timer::Category func_cat(LLVM_PRETTY_FUNCTION);
   Timer scoped_timer(func_cat, "ObjectFileMachO::ParseSymtab () module = %s",
@@ -2579,11 +2717,13 @@ size_t ObjectFileMachO::ParseSymtab() {
 
     std::vector<TrieEntryWithOffset> trie_entries;
     std::set<lldb::addr_t> resolver_addresses;
+    std::set<lldb::addr_t> symbol_file_addresses;
 
     if (dyld_trie_data.GetByteSize() > 0) {
       std::vector<llvm::StringRef> nameSlices;
-      ParseTrieEntries(dyld_trie_data, 0, is_arm, nameSlices,
-                       resolver_addresses, trie_entries);
+      ParseTrieEntries(dyld_trie_data, 0, is_arm,
+                       eLazyBoolNo, // eLazyBoolCalculate,
+                       nameSlices, resolver_addresses, trie_entries);
 
       ConstString text_segment_name("__TEXT");
       SectionSP text_segment_sp =
@@ -3481,6 +3621,9 @@ size_t ObjectFileMachO::ParseSymtab() {
                                         type = eSymbolTypeObjCIVar;
                                         demangled_is_synthesized = true;
                                       }
+                                    } else if (symbol_name_ref.startswith(
+                                                   "__TM")) {
+                                      type = eSymbolTypeMetadata;
                                     }
                                   }
                                 } else if (symbol_sect_name &&
@@ -3552,6 +3695,13 @@ size_t ObjectFileMachO::ParseSymtab() {
                           }
                         }
                         if (symbol_section) {
+                          // Keep track of the symbols we added by address in
+                          // case we have other sources
+                          // for symbols where we only want to add a symbol if
+                          // it isn't already in the
+                          // symbol table.
+                          symbol_file_addresses.insert(nlist.n_value);
+
                           const addr_t section_file_addr =
                               symbol_section->GetFileAddress();
                           if (symbol_byte_size == 0 &&
@@ -3742,6 +3892,14 @@ size_t ObjectFileMachO::ParseSymtab() {
                                       nlist.n_type << 16 | nlist.n_desc);
                                   sym[sym_idx].Clear();
                                   continue;
+                                } else {
+                                  if (SwiftLanguageRuntime::IsSwiftSymbol(symbol_name) {
+                                    if (SwiftLanguageRuntime::IsIvarOffset(symbol_name) {
+                                      type = eSymbolTypeIVarOffset;
+                                    } else if (SwiftLanguageRuntime::IsMetadataSymbol(symbol_name) {
+                                      type = eSymbolTypeMetadata;
+                                    }
+                                  }
                                 }
                               }
                             }
@@ -3885,6 +4043,12 @@ size_t ObjectFileMachO::ParseSymtab() {
             // correctly.  To do this right, we should coalesce all the GSYM &
             // global symbols that have the
             // same address.
+            if (symbol_name && symbol_name[0] == '_' && symbol_name[1] == '_'
+                && SwiftLanguageRuntime::IsMetadataSymbol(symbol_name+1)) {
+              add_nlist = false;
+              break;
+            }
+
             is_gsym = true;
             sym[sym_idx].SetExternal(true);
 
@@ -4250,6 +4414,11 @@ size_t ObjectFileMachO::ParseSymtab() {
             type = eSymbolTypeAdditional;
             break;
 
+          case N_AST:
+            // A path to a compiler AST file
+            type = eSymbolTypeASTFile;
+            break;
+
           default:
             break;
           }
@@ -4423,6 +4592,8 @@ size_t ObjectFileMachO::ParseSymtab() {
                           type = eSymbolTypeObjCIVar;
                           demangled_is_synthesized = true;
                         }
+                      } else if (symbol_name_ref.startswith("__TM")) {
+                        type = eSymbolTypeMetadata;
                       }
                     }
                   } else if (symbol_sect_name &&
@@ -4491,6 +4662,13 @@ size_t ObjectFileMachO::ParseSymtab() {
           }
 
           if (symbol_section) {
+            // Keep track of the symbols we added by address in case we have
+            // other sources
+            // for symbols where we only want to add a symbol if it isn't
+            // already in the
+            // symbol table.
+            symbol_file_addresses.insert(nlist.n_value);
+
             const addr_t section_file_addr = symbol_section->GetFileAddress();
             if (symbol_byte_size == 0 && function_starts_count > 0) {
               addr_t symbol_lookup_file_addr = nlist.n_value;
@@ -4644,8 +4822,24 @@ size_t ObjectFileMachO::ParseSymtab() {
                     // symbol table
                     sym[GSYM_sym_idx].SetFlags(nlist.n_type << 16 |
                                                nlist.n_desc);
+                    if (SwiftLanguageRuntime::IsSwiftMangledName(gsym_name)) {
+                      if (SwiftLanguageRuntime::IsIvarOffsetSymbol(gsym_name)) {
+                        sym[GSYM_sym_idx].SetType(eSymbolTypeIVarOffset);
+                      } else if (SwiftLanguageRuntime::IsMetadataSymbol(gsym_name)) {
+                        sym[GSYM_sym_idx].SetType(eSymbolTypeMetadata);
+                      }
+                    }
+
                     sym[sym_idx].Clear();
                     continue;
+                  } else {
+                    if (SwiftLanguageRuntime::IsSwiftMangledName(symbol_name)) {
+                      if (SwiftLanguageRuntime::IsIvarOffsetSymbol(symbol_name)) {
+                        type = eSymbolTypeIVarOffset;
+                      } else if (SwiftLanguageRuntime::IsMetadataSymbol(symbol_name)) {
+                        type = eSymbolTypeMetadata;
+                      }
+                    }
                   }
                 }
               }
@@ -4686,6 +4880,58 @@ size_t ObjectFileMachO::ParseSymtab() {
 
     uint32_t synthetic_sym_id = symtab_load_command.nsyms;
 
+    // Check the trie for any symbols that are in the trie only and make symbols
+    // for those
+    if (!trie_entries.empty()) {
+      for (const auto &e : trie_entries) {
+        // Don't handle the re-exported symbols here, just the symbols that were
+        // in the trie only
+        if (e.entry.name && !e.entry.import_name &&
+            symbol_file_addresses.find(e.entry.address) ==
+                symbol_file_addresses.end()) {
+          SectionSP symbol_section =
+              section_list->FindSectionContainingFileAddress(e.entry.address);
+          if (symbol_section) {
+            const addr_t section_file_addr = symbol_section->GetFileAddress();
+
+            // Keep track of the symbols we added by address in case we have
+            // other sources
+            // for symbols where we only want to add a symbol if it isn't
+            // already in the
+            // symbol table.
+            symbol_file_addresses.insert(e.entry.address);
+
+            if (e.entry.address >= section_file_addr) {
+              const uint64_t symbol_value = e.entry.address - section_file_addr;
+
+              const char *symbol_name = e.entry.name.GetCString();
+              const char *symbol_name_non_abi_mangled = nullptr;
+              bool demangled_is_synthesized = false;
+              SymbolType type = GetSymbolType(
+                  symbol_name, symbol_name_non_abi_mangled,
+                  demangled_is_synthesized, text_section_sp, data_section_sp,
+                  data_dirty_section_sp, data_const_section_sp, objc_section_sp,
+                  symbol_section);
+
+              // Make a synthetic symbol to describe re-exported symbol.
+              if (sym_idx >= num_syms)
+                sym = symtab->Resize(++num_syms);
+              sym[sym_idx].SetID(synthetic_sym_id++);
+              sym[sym_idx].GetMangled() = Mangled(e.entry.name, true);
+              sym[sym_idx].SetType(type);
+              sym[sym_idx].SetIsSynthetic(true);
+              sym[sym_idx].GetAddressRef().SetSection(symbol_section);
+              sym[sym_idx].GetAddressRef().SetOffset(symbol_value);
+              if (demangled_is_synthesized)
+                sym[sym_idx].SetDemangledNameIsSynthesized(true);
+
+              ++sym_idx;
+            }
+          }
+        }
+      }
+    }
+
     if (function_starts_count > 0) {
       uint32_t num_synthetic_function_symbols = 0;
       for (i = 0; i < function_starts_count; ++i) {
diff --git a/source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp b/source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp
index 5607a71ad..7a5c472d1 100644
--- a/source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp
+++ b/source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp
@@ -696,6 +696,7 @@ void ObjectFilePECOFF::CreateSections(SectionList &unified_section_list) {
         static ConstString g_sect_name_dwarf_debug_ranges(".debug_ranges");
         static ConstString g_sect_name_dwarf_debug_str(".debug_str");
         static ConstString g_sect_name_eh_frame(".eh_frame");
+        static ConstString g_sect_name_swift_ast(".swift_ast");
         static ConstString g_sect_name_go_symtab(".gosymtab");
         SectionType section_type = eSectionTypeOther;
         if (m_sect_headers[idx].flags & llvm::COFF::IMAGE_SCN_CNT_CODE &&
@@ -745,6 +746,8 @@ void ObjectFilePECOFF::CreateSections(SectionList &unified_section_list) {
           section_type = eSectionTypeDWARFDebugStr;
         else if (const_sect_name == g_sect_name_eh_frame)
           section_type = eSectionTypeEHFrame;
+        else if (const_sect_name == g_sect_name_swift_ast)
+          section_type = eSectionTypeSwiftModules;
         else if (const_sect_name == g_sect_name_go_symtab)
           section_type = eSectionTypeGoSymtab;
         else if (m_sect_headers[idx].flags & llvm::COFF::IMAGE_SCN_CNT_CODE) {
diff --git a/source/Plugins/OperatingSystem/Go/OperatingSystemGo.cpp b/source/Plugins/OperatingSystem/Go/OperatingSystemGo.cpp
index 75bc518f7..ef16ea9fa 100644
--- a/source/Plugins/OperatingSystem/Go/OperatingSystemGo.cpp
+++ b/source/Plugins/OperatingSystem/Go/OperatingSystemGo.cpp
@@ -47,7 +47,7 @@ using namespace lldb_private;
 namespace {
 
 static PropertyDefinition g_properties[] = {
-    {"enable", OptionValue::eTypeBoolean, true, true, nullptr, nullptr,
+    {"enable", OptionValue::eTypeBoolean, true, false, nullptr, nullptr,
      "Specify whether goroutines should be treated as threads."},
     {NULL, OptionValue::eTypeInvalid, false, 0, NULL, NULL, NULL}};
 
@@ -451,8 +451,14 @@ OperatingSystemGo::Goroutine
 OperatingSystemGo::CreateGoroutineAtIndex(uint64_t idx, Status &err) {
   err.Clear();
   Goroutine result = {};
-  ValueObjectSP g =
-      m_allg_sp->GetSyntheticArrayMember(idx, true)->Dereference(err);
+  ValueObjectSP child_sp = m_allg_sp->GetSyntheticArrayMember(idx, true);
+  if (!child_sp) {
+    err.SetErrorToGenericError();
+    err.SetErrorString("unable to find goroutines in array");
+    return result;
+  }
+
+  ValueObjectSP g = child_sp->Dereference(err);
   if (err.Fail()) {
     return result;
   }
diff --git a/source/Plugins/Platform/MacOSX/PlatformDarwin.cpp b/source/Plugins/Platform/MacOSX/PlatformDarwin.cpp
index f87852ed7..99976b1c3 100644
--- a/source/Plugins/Platform/MacOSX/PlatformDarwin.cpp
+++ b/source/Plugins/Platform/MacOSX/PlatformDarwin.cpp
@@ -1741,6 +1741,60 @@ lldb_private::FileSpec PlatformDarwin::LocateExecutable(const char *basename) {
   return FileSpec();
 }
 
+bool PlatformDarwin::IsUnitTestExecutable(lldb_private::Module &module) {
+  static ConstString s_xctest("xctest");
+  static ConstString s_XCTRunner("XCTRunner");
+  ConstString executable_name = module.GetFileSpec().GetFilename();
+  return (executable_name == s_xctest || executable_name == s_XCTRunner);
+}
+
+lldb::ModuleSP
+PlatformDarwin::GetUnitTestModule(lldb_private::ModuleList &modules) {
+  ConstString test_bundle_executable;
+
+  for (size_t mi = 0, num_images = modules.GetSize(); mi != num_images; ++mi) {
+    ModuleSP module_sp = modules.GetModuleAtIndex(mi);
+
+    std::string module_path = module_sp->GetFileSpec().GetPath();
+
+    const char deep_substr[] = ".xctest/Contents/";
+    size_t pos = module_path.rfind(deep_substr);
+    if (pos == std::string::npos) {
+      const char flat_substr[] = ".xctest/";
+      pos = module_path.rfind(flat_substr);
+
+      if (pos == std::string::npos) {
+        continue;
+      } else {
+        module_path.erase(pos + strlen(flat_substr));
+      }
+    } else {
+      module_path.erase(pos + strlen(deep_substr));
+    }
+
+    if (!test_bundle_executable) {
+      module_path.append("Info.plist");
+
+      ApplePropertyList info_plist(module_path.c_str());
+
+      std::string cf_bundle_executable;
+      if (info_plist.GetValueAsString("CFBundleExecutable",
+                                      cf_bundle_executable)) {
+        test_bundle_executable = ConstString(cf_bundle_executable);
+      } else {
+        return ModuleSP();
+      }
+    }
+
+    if (test_bundle_executable &&
+        module_sp->GetFileSpec().GetFilename() == test_bundle_executable) {
+      return module_sp;
+    }
+  }
+
+  return ModuleSP();
+}
+
 lldb_private::Status
 PlatformDarwin::LaunchProcess(lldb_private::ProcessLaunchInfo &launch_info) {
   // Starting in Fall 2016 OSes, NSLog messages only get mirrored to stderr
diff --git a/source/Plugins/Platform/MacOSX/PlatformDarwin.h b/source/Plugins/Platform/MacOSX/PlatformDarwin.h
index c04318e98..4ffbee6e5 100644
--- a/source/Plugins/Platform/MacOSX/PlatformDarwin.h
+++ b/source/Plugins/Platform/MacOSX/PlatformDarwin.h
@@ -79,6 +79,9 @@ public:
 
   lldb_private::FileSpec LocateExecutable(const char *basename) override;
 
+  static bool IsUnitTestExecutable(lldb_private::Module &module);
+  static lldb::ModuleSP GetUnitTestModule(lldb_private::ModuleList &modules);
+
   lldb_private::Status
   LaunchProcess(lldb_private::ProcessLaunchInfo &launch_info) override;
 
diff --git a/source/Plugins/Process/gdb-remote/CMakeLists.txt b/source/Plugins/Process/gdb-remote/CMakeLists.txt
index 5e51feef1..41bca34a1 100644
--- a/source/Plugins/Process/gdb-remote/CMakeLists.txt
+++ b/source/Plugins/Process/gdb-remote/CMakeLists.txt
@@ -1,5 +1,7 @@
 if (CMAKE_SYSTEM_NAME MATCHES "Darwin")
   include_directories(${LIBXML2_INCLUDE_DIR})
+elseif (CMAKE_SYSTEM_NAME MATCHES "Linux")
+  list(APPEND LLDB_PLUGINS lldbPluginProcessLinux)
 endif()
 
 set(LLDB_PLUGINS
diff --git a/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationClient.cpp b/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationClient.cpp
index e6fd386b9..66de7a32f 100644
--- a/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationClient.cpp
+++ b/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationClient.cpp
@@ -3712,8 +3712,11 @@ void GDBRemoteCommunicationClient::ServeSymbolLookups(
                       case eSymbolTypeCompiler:
                       case eSymbolTypeInstrumentation:
                       case eSymbolTypeTrampoline:
+                      case eSymbolTypeASTFile:
+                      case eSymbolTypeMetadata:
                         break;
 
+                      case eSymbolTypeIVarOffset:
                       case eSymbolTypeCode:
                       case eSymbolTypeResolver:
                       case eSymbolTypeData:
diff --git a/source/Plugins/SymbolFile/DWARF/CMakeLists.txt b/source/Plugins/SymbolFile/DWARF/CMakeLists.txt
index fb468440f..05ddc639a 100644
--- a/source/Plugins/SymbolFile/DWARF/CMakeLists.txt
+++ b/source/Plugins/SymbolFile/DWARF/CMakeLists.txt
@@ -2,6 +2,7 @@ add_lldb_library(lldbPluginSymbolFileDWARF PLUGIN
   DIERef.cpp
   DWARFAbbreviationDeclaration.cpp
   DWARFASTParserClang.cpp
+  DWARFASTParserSwift.cpp
   DWARFASTParserGo.cpp
   DWARFASTParserJava.cpp
   DWARFASTParserOCaml.cpp
diff --git a/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.cpp b/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.cpp
index e69de29bb..0556cc2d5 100644
--- a/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.cpp
+++ b/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.cpp
@@ -0,0 +1,273 @@
+//===-- DWARFASTParserSwift.cpp ---------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "DWARFASTParserSwift.h"
+
+#include "DWARFCompileUnit.h"
+#include "DWARFDIE.h"
+#include "DWARFDebugInfo.h"
+#include "DWARFDefines.h"
+#include "SymbolFileDWARF.h"
+
+#include "swift/AST/ASTContext.h"
+
+#include "lldb/Core/Module.h"
+#include "lldb/Symbol/CompileUnit.h"
+#include "lldb/Symbol/Function.h"
+#include "lldb/Symbol/ObjectFile.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Symbol/Type.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Utility/Log.h"
+#include "lldb/Utility/Status.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+DWARFASTParserSwift::DWARFASTParserSwift(SwiftASTContext &ast) : m_ast(ast) {}
+
+DWARFASTParserSwift::~DWARFASTParserSwift() {}
+
+lldb::TypeSP DWARFASTParserSwift::ParseTypeFromDWARF(const SymbolContext &sc,
+                                                     const DWARFDIE &die,
+                                                     Log *log,
+                                                     bool *type_is_new_ptr) {
+  lldb::TypeSP type_sp;
+  CompilerType compiler_type;
+  Status error;
+
+  Declaration decl;
+  ConstString mangled_name;
+  ConstString name;
+
+  DWARFAttributes attributes;
+  const size_t num_attributes = die.GetAttributes(attributes);
+  DWARFFormValue type_attr;
+
+  if (num_attributes > 0) {
+    uint32_t i;
+    for (i = 0; i < num_attributes; ++i) {
+      const dw_attr_t attr = attributes.AttributeAtIndex(i);
+      DWARFFormValue form_value;
+      if (attributes.ExtractFormValueAtIndex(i, form_value)) {
+        switch (attr) {
+        case DW_AT_decl_file:
+          decl.SetFile(sc.comp_unit->GetSupportFiles().GetFileSpecAtIndex(
+              form_value.Unsigned()));
+          break;
+        case DW_AT_decl_line:
+          decl.SetLine(form_value.Unsigned());
+          break;
+        case DW_AT_decl_column:
+          decl.SetColumn(form_value.Unsigned());
+          break;
+        case DW_AT_name:
+          name.SetCString(form_value.AsCString());
+          break;
+        case DW_AT_linkage_name:
+        case DW_AT_MIPS_linkage_name:
+          mangled_name.SetCString(form_value.AsCString());
+          break;
+        default:
+          break;
+        }
+      }
+    }
+  }
+
+  if (!mangled_name && name) {
+    if (SwiftLanguageRuntime::IsSwiftMangledName(name.GetCString()))
+      mangled_name = name;
+    else {
+      const char *type_name_cstr = name.GetCString();
+      // TODO: remove this once all mangled names are always included for all
+      // types in DWARF
+      swift::ModuleDecl *swift_module = m_ast.GetModule(decl.GetFile(), error);
+      if (swift_module)
+        compiler_type = m_ast.FindType(type_name_cstr, swift_module);
+
+      if (!compiler_type) {
+        // Anything from the swift module might be in a DW_TAG_typedef with a
+        // name of "Int"
+        // so we shuld also check the swift module if we fail to find our type
+        // until we get
+        // <rdar://problem/15290346> fixed.
+        compiler_type =
+            m_ast.FindFirstType(type_name_cstr, ConstString("Swift"));
+      }
+    }
+  }
+
+  if (mangled_name) {
+    // see if we parsed this type already
+    type_sp = m_ast.GetCachedType(mangled_name);
+    if (type_sp)
+      return type_sp;
+
+    // otherwise figure it out yourself
+    compiler_type =
+        m_ast.GetTypeFromMangledTypename(mangled_name.GetCString(), error);
+  }
+
+  if (!compiler_type && name) {
+    if (name.GetStringRef().startswith("$swift.") ||
+        name.GetStringRef().startswith(
+            SwiftLanguageRuntime::GetCurrentMangledName("_TtBp")
+                .c_str())) { // This is the RawPointerType, need to figure out
+                             // its name from the AST.
+      swift::ASTContext *swift_ast_ctx = m_ast.GetASTContext();
+      if (swift_ast_ctx)
+        compiler_type =
+            CompilerType(swift_ast_ctx, swift_ast_ctx->TheRawPointerType);
+      else {
+        if (log) {
+          const char *file_name = "<unknown>";
+          SymbolFile *sym_file = m_ast.GetSymbolFile();
+          if (sym_file) {
+            ObjectFile *obj_file = sym_file->GetObjectFile();
+            if (obj_file) {
+              ModuleSP module_sp = obj_file->GetModule();
+              if (module_sp)
+                file_name = module_sp->GetFileSpec().GetFilename().AsCString();
+            }
+          }
+          log->Printf("Got null AST context while looking up %s in %s.",
+                      name.AsCString(), file_name);
+        }
+        return TypeSP();
+      }
+    }
+  }
+
+  switch (die.Tag()) {
+  case DW_TAG_inlined_subroutine:
+  case DW_TAG_subprogram:
+  case DW_TAG_subroutine_type:
+    if (!compiler_type || !compiler_type.IsFunctionType()) {
+      // Make sure we at least have some function type. The mangling for the
+      // "top_level_code"
+      // is currently returning the emptyTupleType (originally "_TtT_") which is
+      // not a function type...
+      compiler_type = m_ast.GetVoidFunctionType();
+    }
+    break;
+  default:
+    break;
+  }
+
+  if (compiler_type) {
+    type_sp = TypeSP(new Type(
+        die.GetID(), die.GetDWARF(), compiler_type.GetTypeName(),
+        compiler_type.GetByteSize(nullptr), NULL, LLDB_INVALID_UID,
+        Type::eEncodingIsUID, &decl, compiler_type, Type::eResolveStateFull));
+  }
+
+  // cache this type
+  if (type_sp && mangled_name &&
+      SwiftLanguageRuntime::IsSwiftMangledName(mangled_name.GetCString()))
+    m_ast.SetCachedType(mangled_name, type_sp);
+
+  return type_sp;
+}
+
+Function *DWARFASTParserSwift::ParseFunctionFromDWARF(const SymbolContext &sc,
+                                                      const DWARFDIE &die) {
+  DWARFRangeList func_ranges;
+  const char *name = NULL;
+  const char *mangled = NULL;
+  int decl_file = 0;
+  int decl_line = 0;
+  int decl_column = 0;
+  int call_file = 0;
+  int call_line = 0;
+  int call_column = 0;
+  DWARFExpression frame_base(die.GetCU());
+
+  if (die.Tag() != DW_TAG_subprogram)
+    return NULL;
+
+  if (die.GetDIENamesAndRanges(name, mangled, func_ranges, decl_file, decl_line,
+                               decl_column, call_file, call_line, call_column,
+                               &frame_base)) {
+    // Union of all ranges in the function DIE (if the function is
+    // discontiguous)
+    SymbolFileDWARF *dwarf = die.GetDWARF();
+    AddressRange func_range;
+    lldb::addr_t lowest_func_addr = func_ranges.GetMinRangeBase(0);
+    lldb::addr_t highest_func_addr = func_ranges.GetMaxRangeEnd(0);
+    if (lowest_func_addr != LLDB_INVALID_ADDRESS &&
+        lowest_func_addr <= highest_func_addr) {
+      ModuleSP module_sp(dwarf->GetObjectFile()->GetModule());
+      func_range.GetBaseAddress().ResolveAddressUsingFileSections(
+          lowest_func_addr, module_sp->GetSectionList());
+      if (func_range.GetBaseAddress().IsValid())
+        func_range.SetByteSize(highest_func_addr - lowest_func_addr);
+    }
+
+    if (func_range.GetBaseAddress().IsValid()) {
+      Mangled func_name;
+      if (mangled)
+        func_name.SetValue(ConstString(mangled), true);
+      else
+        func_name.SetValue(ConstString(name), false);
+
+      // See if this function can throw.  We can't get that from the
+      // mangled name (even though the information is often there)
+      // because Swift reserves the right to omit it from the name
+      // if it doesn't need it.  So instead we look for the
+      // DW_TAG_thrown_error:
+
+      bool can_throw = false;
+
+      DWARFDebugInfoEntry *child(die.GetFirstChild().GetDIE());
+      while (child) {
+        if (child->Tag() == DW_TAG_thrown_type) {
+          can_throw = true;
+          break;
+        }
+        child = child->GetSibling();
+      }
+
+      FunctionSP func_sp;
+      std::unique_ptr<Declaration> decl_ap;
+      if (decl_file != 0 || decl_line != 0 || decl_column != 0)
+        decl_ap.reset(new Declaration(
+            sc.comp_unit->GetSupportFiles().GetFileSpecAtIndex(decl_file),
+            decl_line, decl_column));
+
+      if (dwarf->FixupAddress(func_range.GetBaseAddress())) {
+        const user_id_t func_user_id = die.GetID();
+        func_sp.reset(new Function(sc.comp_unit, func_user_id, func_user_id,
+                                   func_name, nullptr, func_range,
+                                   can_throw)); // first address range
+
+        if (func_sp.get() != NULL) {
+          if (frame_base.IsValid())
+            func_sp->GetFrameBaseExpression() = frame_base;
+          sc.comp_unit->AddFunction(func_sp);
+          return func_sp.get();
+        }
+      }
+    }
+  }
+  return NULL;
+}
+
+lldb_private::CompilerDeclContext
+DWARFASTParserSwift::GetDeclContextForUIDFromDWARF(const DWARFDIE &die) {
+  return CompilerDeclContext();
+}
+
+lldb_private::CompilerDeclContext
+DWARFASTParserSwift::GetDeclContextContainingUIDFromDWARF(const DWARFDIE &die) {
+  return CompilerDeclContext();
+}
diff --git a/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.h b/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.h
index e69de29bb..5b27ffe2a 100644
--- a/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.h
+++ b/source/Plugins/SymbolFile/DWARF/DWARFASTParserSwift.h
@@ -0,0 +1,62 @@
+//===-- DWARFASTParserSwift.h -----------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef SymbolFileDWARF_DWARFASTParserSwift_h_
+#define SymbolFileDWARF_DWARFASTParserSwift_h_
+
+#include "DWARFASTParser.h"
+#include "DWARFDIE.h"
+
+class DWARFDebugInfoEntry;
+class DWARFDIECollection;
+
+class DWARFASTParserSwift : public DWARFASTParser {
+public:
+  DWARFASTParserSwift(lldb_private::SwiftASTContext &ast);
+
+  virtual ~DWARFASTParserSwift();
+
+  lldb::TypeSP ParseTypeFromDWARF(const lldb_private::SymbolContext &sc,
+                                  const DWARFDIE &die, lldb_private::Log *log,
+                                  bool *type_is_new_ptr) override;
+
+  lldb_private::Function *
+  ParseFunctionFromDWARF(const lldb_private::SymbolContext &sc,
+                         const DWARFDIE &die) override;
+
+  bool
+  CompleteTypeFromDWARF(const DWARFDIE &die, lldb_private::Type *type,
+                        lldb_private::CompilerType &compiler_type) override {
+    return false;
+  }
+
+  lldb_private::CompilerDecl
+  GetDeclForUIDFromDWARF(const DWARFDIE &die) override {
+    return lldb_private::CompilerDecl();
+  }
+
+  lldb_private::CompilerDeclContext
+  GetDeclContextForUIDFromDWARF(const DWARFDIE &die) override;
+
+  lldb_private::CompilerDeclContext
+  GetDeclContextContainingUIDFromDWARF(const DWARFDIE &die) override;
+
+  std::vector<DWARFDIE> GetDIEForDeclContext(
+      lldb_private::CompilerDeclContext decl_context) override {
+    return {};
+  }
+
+protected:
+  lldb_private::SwiftASTContext &m_ast;
+};
+
+#endif // SymbolFileDWARF_DWARFASTParserSwift_h_
diff --git a/source/Plugins/SymbolFile/DWARF/DWARFCompileUnit.cpp b/source/Plugins/SymbolFile/DWARF/DWARFCompileUnit.cpp
index 79b2acc4b..127555866 100644
--- a/source/Plugins/SymbolFile/DWARF/DWARFCompileUnit.cpp
+++ b/source/Plugins/SymbolFile/DWARF/DWARFCompileUnit.cpp
@@ -804,30 +804,52 @@ void DWARFCompileUnit::IndexPrivate(
     case DW_TAG_subprogram:
       if (has_address) {
         if (name) {
-          ObjCLanguage::MethodName objc_method(name, true);
-          if (objc_method.IsValid(true)) {
-            ConstString objc_class_name_with_category(
-                objc_method.GetClassNameWithCategory());
-            ConstString objc_selector_name(objc_method.GetSelector());
-            ConstString objc_fullname_no_category_name(
-                objc_method.GetFullNameWithoutCategory(true));
-            ConstString objc_class_name_no_category(objc_method.GetClassName());
-            func_fullnames.Insert(ConstString(name),
-                                  DIERef(cu_offset, die.GetOffset()));
-            if (objc_class_name_with_category)
-              objc_class_selectors.Insert(objc_class_name_with_category,
-                                          DIERef(cu_offset, die.GetOffset()));
-            if (objc_class_name_no_category &&
-                objc_class_name_no_category != objc_class_name_with_category)
-              objc_class_selectors.Insert(objc_class_name_no_category,
-                                          DIERef(cu_offset, die.GetOffset()));
-            if (objc_selector_name)
-              func_selectors.Insert(objc_selector_name,
+          bool has_valid_objc_method = false;
+
+          if (Language::LanguageIsObjC(cu_language)) {
+            ObjCLanguage::MethodName objc_method(name, true);
+            if (objc_method.IsValid(true)) {
+              ConstString objc_class_name_with_category(
+                  objc_method.GetClassNameWithCategory());
+              ConstString objc_selector_name(objc_method.GetSelector());
+              ConstString objc_fullname_no_category_name(
+                  objc_method.GetFullNameWithoutCategory(true));
+              ConstString objc_class_name_no_category(
+                  objc_method.GetClassName());
+              func_fullnames.Insert(ConstString(name),
                                     DIERef(cu_offset, die.GetOffset()));
-            if (objc_fullname_no_category_name)
-              func_fullnames.Insert(objc_fullname_no_category_name,
+              if (objc_class_name_with_category)
+                objc_class_selectors.Insert(objc_class_name_with_category,
+                                            DIERef(cu_offset, die.GetOffset()));
+              if (objc_class_name_no_category &&
+                  objc_class_name_no_category != objc_class_name_with_category)
+                objc_class_selectors.Insert(objc_class_name_no_category,
+                                            DIERef(cu_offset, die.GetOffset()));
+              if (objc_selector_name)
+                func_selectors.Insert(objc_selector_name,
+                                      DIERef(cu_offset, die.GetOffset()));
+              if (objc_fullname_no_category_name)
+                func_fullnames.Insert(objc_fullname_no_category_name,
+                                      DIERef(cu_offset, die.GetOffset()));
+              has_valid_objc_method = true;
+            }
+          } else if (cu_language == eLanguageTypeGo) {
+            // If the name is of the form {something}.{basename}, we're going
+            // to inject an accelerator for basename into the mapping table.
+            // This will allow us to handle user-specified symbol names
+            // in Go versions where the DW_AT_name of the subprogram is
+            // set to {package}.{funcname}, without colliding with how
+            // Swift handles this.
+            llvm::StringRef name_string_ref(name);
+            const size_t dot_pos = name_string_ref.find_last_of('.');
+            if ((dot_pos != llvm::StringRef::npos) &&
+                (name_string_ref.size() > dot_pos + 1)) {
+              llvm::StringRef base_name = name_string_ref.substr(dot_pos + 1);
+              func_basenames.Insert(ConstString(base_name.str()),
                                     DIERef(cu_offset, die.GetOffset()));
+            }
           }
+
           // If we have a mangled name, then the DW_AT_name attribute
           // is usually the method name without the class or any parameters
           const DWARFDebugInfoEntry *parent = die.GetParent();
@@ -855,7 +877,7 @@ void DWARFCompileUnit::IndexPrivate(
             func_basenames.Insert(ConstString(name),
                                   DIERef(cu_offset, die.GetOffset()));
 
-          if (!is_method && !mangled_cstr && !objc_method.IsValid(true))
+          if (!is_method && !mangled_cstr && !has_valid_objc_method)
             func_fullnames.Insert(ConstString(name),
                                   DIERef(cu_offset, die.GetOffset()));
         }
@@ -917,8 +939,24 @@ void DWARFCompileUnit::IndexPrivate(
     case DW_TAG_typedef:
     case DW_TAG_union_type:
     case DW_TAG_unspecified_type:
-      if (name && !is_declaration)
+      if (name && !is_declaration) {
+        if (cu_language == eLanguageTypeGo) {
+          // For Go, check if the type name appears to have the full
+          // package scope in it.  If so, reduce to the basename and
+          // add a type lookup for the basename.
+          llvm::StringRef name_string_ref(name);
+          const size_t dot_pos = name_string_ref.find_last_of('.');
+          if ((dot_pos != llvm::StringRef::npos) &&
+              (name_string_ref.size() > dot_pos + 1)) {
+            llvm::StringRef base_name = name_string_ref.substr(dot_pos + 1);
+            types.Insert(ConstString(base_name),
+                         DIERef(cu_offset, die.GetOffset()));
+          }
+        }
+
+        // Add a type mapping for the name just as it appeared.
         types.Insert(ConstString(name), DIERef(cu_offset, die.GetOffset()));
+      }
       if (mangled_cstr && !is_declaration)
         types.Insert(ConstString(mangled_cstr),
                      DIERef(cu_offset, die.GetOffset()));
@@ -1052,6 +1090,12 @@ uint32_t DWARFCompileUnit::GetProducerVersionUpdate() {
   return m_producer_version_update;
 }
 
+// Remove this once GOOGLE_RenderScript is available in our LLVM.
+#if !defined(DW_LANG_GOOGLE_RenderScript)
+// HANDLE_DW_LANG(0x8e57, GOOGLE_RenderScript)
+#define DW_LANG_GOOGLE_RenderScript 0x8e57
+#endif
+
 LanguageType DWARFCompileUnit::LanguageTypeFromDWARF(uint64_t val) {
   // Note: user languages between lo_user and hi_user
   // must be handled explicitly here.
diff --git a/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.cpp b/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.cpp
index 8d87c201e..1b0a57912 100644
--- a/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.cpp
+++ b/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.cpp
@@ -960,6 +960,15 @@ uint64_t DWARFDebugInfoEntry::GetAttributeValueAsUnsigned(
   return fail_value;
 }
 
+lldb::LanguageType DWARFDebugInfoEntry::GetLanguageAttributeValue(
+    SymbolFileDWARF *dwarf2Data, const DWARFCompileUnit *cu) const {
+  const uint64_t language = GetAttributeValueAsUnsigned(
+      dwarf2Data, cu, DW_AT_language, lldb::eLanguageTypeUnknown);
+  if (language == llvm::dwarf::DW_LANG_Swift)
+    return lldb::eLanguageTypeSwift;
+  return (lldb::LanguageType)language;
+}
+
 //----------------------------------------------------------------------
 // GetAttributeValueAsSigned
 //
diff --git a/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h b/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h
index 15abac77a..1bd9201d9 100644
--- a/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h
+++ b/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h
@@ -115,6 +115,10 @@ public:
       const dw_attr_t attr, uint64_t fail_value,
       bool check_specification_or_abstract_origin = false) const;
 
+  lldb::LanguageType
+  GetLanguageAttributeValue(SymbolFileDWARF *dwarf2Data,
+                            const DWARFCompileUnit *cu) const;
+
   uint64_t GetAttributeValueAsReference(
       SymbolFileDWARF *dwarf2Data, const DWARFCompileUnit *cu,
       const dw_attr_t attr, uint64_t fail_value,
diff --git a/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h b/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h
index 8d6af3d65..0aa9422fc 100644
--- a/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h
+++ b/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h
@@ -77,6 +77,8 @@ public:
   bool IsValid() const { return m_form != 0; }
   bool SkipValue(const lldb_private::DWARFDataExtractor &debug_info_data,
                  lldb::offset_t *offset_ptr) const;
+  explicit operator bool() const { return m_cu != NULL && m_form != 0; };
+  void Clear();
   static bool SkipValue(const dw_form_t form,
                         const lldb_private::DWARFDataExtractor &debug_info_data,
                         lldb::offset_t *offset_ptr, const DWARFCompileUnit *cu);
@@ -85,7 +87,6 @@ public:
   static FixedFormSizes GetFixedFormSizesForAddressSize(uint8_t addr_size,
                                                         bool is_dwarf64);
   static int Compare(const DWARFFormValue &a, const DWARFFormValue &b);
-  void Clear();
 
 protected:
   const DWARFCompileUnit *m_cu; // Compile unit for this form
diff --git a/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.cpp b/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.cpp
index cb1e5c185..61cba77e8 100644
--- a/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.cpp
+++ b/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.cpp
@@ -122,17 +122,20 @@ const char *DWARFMappedHash::GetAtomTypeName(uint16_t atom) {
     return "type-flags";
   case eAtomTypeQualNameHash:
     return "qualified-name-hash";
+  case eAtomTypeString:
+    return "strp";
   }
   return "<invalid>";
 }
 
 DWARFMappedHash::DIEInfo::DIEInfo()
     : cu_offset(DW_INVALID_OFFSET), offset(DW_INVALID_OFFSET), tag(0),
-      type_flags(0), qualified_name_hash(0) {}
+      type_flags(0), qualified_name_hash(0), strp(UINT64_MAX) {}
 
 DWARFMappedHash::DIEInfo::DIEInfo(dw_offset_t c, dw_offset_t o, dw_tag_t t,
-                                  uint32_t f, uint32_t h)
-    : cu_offset(c), offset(o), tag(t), type_flags(f), qualified_name_hash(h) {}
+                                  uint32_t f, uint32_t h, uint64_t s)
+    : cu_offset(c), offset(o), tag(t), type_flags(f), qualified_name_hash(h),
+      strp(s) {}
 
 DWARFMappedHash::Prologue::Prologue(dw_offset_t _die_base_offset)
     : die_base_offset(_die_base_offset), atoms(), atom_mask(0),
diff --git a/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.h b/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.h
index 959517529..0d195ec3f 100644
--- a/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.h
+++ b/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.h
@@ -34,15 +34,16 @@ public:
                              // contains the item in question
     eAtomTypeTag = 3u, // DW_TAG_xxx value, should be encoded as DW_FORM_data1
                        // (if no tags exceed 255) or DW_FORM_data2
-    eAtomTypeNameFlags = 4u,   // Flags from enum NameFlags
-    eAtomTypeTypeFlags = 5u,   // Flags from enum TypeFlags,
-    eAtomTypeQualNameHash = 6u // A 32 bit hash of the full qualified name
-                               // (since all hash entries are basename only)
+    eAtomTypeNameFlags = 4u,    // Flags from enum NameFlags
+    eAtomTypeTypeFlags = 5u,    // Flags from enum TypeFlags,
+    eAtomTypeQualNameHash = 6u, // A 32 bit hash of the full qualified name
+                                // (since all hash entries are basename only)
     // For example a type like "std::vector<int>::iterator" would have a name of
     // "iterator"
     // and a 32 bit hash for "std::vector<int>::iterator" to allow us to not
     // have to pull
     // in debug info for a type when we know the fully qualified name.
+    eAtomTypeString = 7u // A 64 bit string offset into the .debug_str table
   };
 
   // Bit definitions for the eAtomTypeTypeFlags flags
@@ -58,9 +59,11 @@ public:
     dw_tag_t tag;
     uint32_t type_flags;          // Any flags for this DIEInfo
     uint32_t qualified_name_hash; // A 32 bit hash of the fully qualified name
+    uint64_t strp;                // 64 bit string table offset
 
     DIEInfo();
-    DIEInfo(dw_offset_t c, dw_offset_t o, dw_tag_t t, uint32_t f, uint32_t h);
+    DIEInfo(dw_offset_t c, dw_offset_t o, dw_tag_t t, uint32_t f, uint32_t h,
+            uint64_t s = UINT64_MAX);
   };
 
   struct Atom {
diff --git a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp
index ef18c2b5d..6ac8aa5a9 100644
--- a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp
+++ b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp
@@ -14,6 +14,7 @@
 #include "llvm/Support/Threading.h"
 
 #include "lldb/Core/ArchSpec.h"
+#include "lldb/Core/Mangled.h"
 #include "lldb/Core/Module.h"
 #include "lldb/Core/ModuleList.h"
 #include "lldb/Core/ModuleSpec.h"
@@ -36,6 +37,7 @@
 
 #include "lldb/Symbol/Block.h"
 #include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/ClangASTImporter.h"
 #include "lldb/Symbol/ClangUtil.h"
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/CompilerDecl.h"
@@ -207,6 +209,11 @@ static const char *resolveCompDir(const char *path_from_dwarf) {
   return nullptr;
 }
 
+static inline bool IsSwiftLanguage(LanguageType language) {
+  return language == eLanguageTypePLI || language == eLanguageTypeSwift ||
+         ((uint32_t)language == (uint32_t)llvm::dwarf::DW_LANG_Swift);
+}
+
 void SymbolFileDWARF::Initialize() {
   LogChannelDWARF::Initialize();
   PluginManager::RegisterPlugin(GetPluginNameStatic(),
@@ -393,13 +400,15 @@ SymbolFileDWARF::SymbolFileDWARF(ObjectFile *objfile)
       m_data_debug_aranges(), m_data_debug_frame(), m_data_debug_info(),
       m_data_debug_line(), m_data_debug_macro(), m_data_debug_loc(),
       m_data_debug_ranges(), m_data_debug_str(), m_data_apple_names(),
-      m_data_apple_types(), m_data_apple_namespaces(), m_abbr(), m_info(),
-      m_line(), m_apple_names_ap(), m_apple_types_ap(), m_apple_namespaces_ap(),
-      m_apple_objc_ap(), m_function_basename_index(),
-      m_function_fullname_index(), m_function_method_index(),
-      m_function_selector_index(), m_objc_class_selectors_index(),
-      m_global_index(), m_type_index(), m_namespace_index(), m_indexed(false),
-      m_using_apple_tables(false), m_fetched_external_modules(false),
+      m_data_apple_types(), m_data_apple_exttypes(), m_data_apple_namespaces(),
+      m_abbr(), m_info(), m_line(), m_apple_names_ap(), m_apple_types_ap(),
+      m_apple_exttypes_ap(), m_apple_namespaces_ap(), m_apple_objc_ap(),
+      m_function_basename_index(), m_function_fullname_index(),
+      m_function_method_index(), m_function_selector_index(),
+      m_objc_class_selectors_index(), m_global_index(), m_type_index(),
+      m_namespace_index(), m_indexed(false), m_using_apple_tables(false),
+      m_initialized_swift_modules(false), m_reported_missing_sdk(false),
+      m_fetched_external_modules(false),
       m_supports_DW_AT_APPLE_objc_complete_type(eLazyBoolCalculate), m_ranges(),
       m_unique_ast_type_map() {}
 
@@ -462,6 +471,15 @@ void SymbolFileDWARF::InitializeObject() {
     else
       m_apple_types_ap.reset();
   }
+  get_apple_exttypes_data();
+  if (m_data_apple_exttypes.m_data.GetByteSize() > 0) {
+    m_apple_exttypes_ap.reset(new DWARFMappedHash::MemoryTable(
+        m_data_apple_exttypes.m_data, get_debug_str_data(), ".apple_exttypes"));
+    if (m_apple_exttypes_ap->IsValid())
+      m_using_apple_tables = true;
+    else
+      m_apple_exttypes_ap.reset();
+  }
 
   get_apple_namespaces_data();
   if (m_data_apple_namespaces.m_data.GetByteSize() > 0) {
@@ -639,6 +657,11 @@ const DWARFDataExtractor &SymbolFileDWARF::get_apple_types_data() {
   return GetCachedSectionData(eSectionTypeDWARFAppleTypes, m_data_apple_types);
 }
 
+const DWARFDataExtractor &SymbolFileDWARF::get_apple_exttypes_data() {
+  return GetCachedSectionData(eSectionTypeDWARFAppleExternalTypes,
+                              m_data_apple_exttypes);
+}
+
 const DWARFDataExtractor &SymbolFileDWARF::get_apple_namespaces_data() {
   return GetCachedSectionData(eSectionTypeDWARFAppleNamespaces,
                               m_data_apple_namespaces);
@@ -910,6 +933,73 @@ bool SymbolFileDWARF::ParseImportedModules(
   assert(sc.comp_unit);
   DWARFCompileUnit *dwarf_cu = GetDWARFCompileUnit(sc.comp_unit);
   if (dwarf_cu) {
+    if (ClangModulesDeclVendor::LanguageSupportsClangModules(
+            sc.comp_unit->GetLanguage())) {
+      const DWARFDIE cu_die = dwarf_cu->GetCompileUnitDIEOnly();
+      bool found_one = false;
+
+      if (cu_die) {
+        for (DWARFDIE child_die = cu_die.GetFirstChild(); child_die.IsValid();
+             child_die = child_die.GetSibling()) {
+          if (child_die.Tag() == DW_TAG_module) {
+            const char *modulename = child_die.GetName();
+
+            if (modulename) {
+              found_one = true;
+              imported_modules.push_back(ConstString(modulename));
+            }
+          }
+        }
+
+        return found_one;
+      }
+    } else if (IsSwiftLanguage(sc.comp_unit->GetLanguage())) {
+      const DWARFDIE cu_die = dwarf_cu->GetCompileUnitDIEOnly();
+      bool found_one = false;
+
+      if (cu_die) {
+        for (DWARFDIE child_die = cu_die.GetFirstChild(); child_die.IsValid();
+             child_die = child_die.GetSibling()) {
+          if (child_die.Tag() == DW_TAG_imported_module) {
+            dw_offset_t die_offset = child_die.GetAttributeValueAsReference(
+                DW_AT_import, DW_INVALID_OFFSET);
+
+            if (die_offset != DW_INVALID_OFFSET) {
+              const DWARFDIE import_die = dwarf_cu->GetDIE(die_offset);
+
+              if (import_die) {
+                const char *modulename = import_die.GetName();
+
+                if (modulename) {
+                  found_one = true;
+                  // Now we have to see if this imported_module tag is embedded
+                  // in a DW_TAG_MODULE,
+                  // that is how sub-module importation is expressed:
+                  std::string module_string(modulename);
+
+                  for (DWARFDIE parent_die = import_die.GetParent();
+                       parent_die.IsValid() &&
+                       parent_die.Tag() == DW_TAG_module;
+                       parent_die = parent_die.GetParent()) {
+                    const char *parent_name = parent_die.GetName();
+                    if (parent_name) {
+                      module_string.insert(0, ".");
+                      module_string.insert(0, parent_name);
+                    }
+                  }
+
+                  imported_modules.push_back(
+                      ConstString(module_string.c_str()));
+                }
+              }
+            }
+          }
+        }
+
+        return found_one;
+      }
+    }
+  } else {
     if (ClangModulesDeclVendor::LanguageSupportsClangModules(
             sc.comp_unit->GetLanguage())) {
       UpdateExternalModuleListIfNeeded();
@@ -1809,6 +1897,10 @@ uint32_t SymbolFileDWARF::ResolveSymbolContext(const FileSpec &file_spec,
                                                SymbolContextList &sc_list) {
   const uint32_t prev_size = sc_list.GetSize();
   if (resolve_scope & eSymbolContextCompUnit) {
+    // See if the SymbolFile requires that we always check for inline entries
+    if (check_inlines == false)
+      check_inlines = ForceInlineSourceFileCheck();
+
     DWARFDebugInfo *debug_info = DebugInfo();
     if (debug_info) {
       uint32_t cu_idx;
@@ -1921,6 +2013,32 @@ uint32_t SymbolFileDWARF::ResolveSymbolContext(const FileSpec &file_spec,
   return sc_list.GetSize() - prev_size;
 }
 
+lldb::TypeSP
+SymbolFileDWARF::ResolveTypeFromAttribute(const DWARFFormValue &type_attr) {
+  if (type_attr) {
+    const dw_form_t form = type_attr.Form();
+
+    switch (form) {
+    case DW_FORM_ref_sig8: {
+      // TODO: Find type in .debug_types and return an appropriate
+      // lldb_private::Type *
+    } break;
+
+    case DW_FORM_ref1:
+    case DW_FORM_ref2:
+    case DW_FORM_ref4:
+    case DW_FORM_ref8:
+    case DW_FORM_ref_udata:
+    case DW_FORM_ref_addr: {
+      Type *ref_type = ResolveTypeUID(type_attr.Reference());
+      if (ref_type)
+        return ref_type->shared_from_this();
+    } break;
+    }
+  }
+  return lldb::TypeSP();
+}
+
 void SymbolFileDWARF::PreloadSymbols() {
   std::lock_guard<std::recursive_mutex> guard(
       GetObjectFile()->GetModule()->GetMutex());
@@ -2080,6 +2198,13 @@ bool SymbolFileDWARF::DeclContextMatchesThisSymbolFile(
   return false;
 }
 
+ClangASTImporter &SymbolFileDWARF::GetClangASTImporter() {
+  if (!m_clang_ast_importer_ap) {
+    m_clang_ast_importer_ap.reset(new ClangASTImporter);
+  }
+  return *m_clang_ast_importer_ap;
+}
+
 uint32_t SymbolFileDWARF::FindGlobalVariables(
     const ConstString &name, const CompilerDeclContext *parent_decl_ctx,
     bool append, uint32_t max_matches, VariableList &variables) {
@@ -3510,6 +3635,135 @@ TypeSP SymbolFileDWARF::ParseType(const SymbolContext &sc, const DWARFDIE &die,
   return type_sp;
 }
 
+bool SymbolFileDWARF::GetCompileOption(const char *option, std::string &value,
+                                       CompileUnit *cu) {
+  value.clear();
+
+  DWARFDebugInfo *debug_info = DebugInfo();
+
+  if (debug_info) {
+    const uint32_t num_compile_units = GetNumCompileUnits();
+
+    if (cu) {
+      DWARFCompileUnit *dwarf_cu = GetDWARFCompileUnit(cu);
+
+      if (dwarf_cu) {
+        const DWARFDIE die = dwarf_cu->GetCompileUnitDIEOnly();
+        if (die) {
+          const char *flags =
+              die.GetAttributeValueAsString(DW_AT_APPLE_flags, NULL);
+
+          if (flags) {
+            if (strstr(flags, option)) {
+              Args compiler_args(flags);
+
+              return compiler_args.GetOptionValueAsString(option, value);
+            }
+          }
+        }
+      }
+    } else {
+      for (uint32_t cu_idx = 0; cu_idx < num_compile_units; ++cu_idx) {
+        DWARFCompileUnit *dwarf_cu = debug_info->GetCompileUnitAtIndex(cu_idx);
+
+        if (dwarf_cu) {
+          const DWARFDIE die = dwarf_cu->GetCompileUnitDIEOnly();
+          if (die) {
+            const char *flags =
+                die.GetAttributeValueAsString(DW_AT_APPLE_flags, NULL);
+
+            if (flags) {
+              if (strstr(flags, option)) {
+                Args compiler_args(flags);
+
+                return compiler_args.GetOptionValueAsString(option, value);
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+int SymbolFileDWARF::GetCompileOptions(const char *option,
+                                       std::vector<std::string> &values,
+                                       CompileUnit *cu) {
+  DWARFDebugInfo *debug_info = DebugInfo();
+
+  if (debug_info) {
+    if (cu) {
+      DWARFCompileUnit *dwarf_cu = GetDWARFCompileUnit(cu);
+
+      if (dwarf_cu) {
+        const DWARFDIE die = dwarf_cu->GetCompileUnitDIEOnly();
+        if (die) {
+          const char *flags =
+              die.GetAttributeValueAsString(DW_AT_APPLE_flags, NULL);
+
+          if (flags) {
+            if (strstr(flags, option)) {
+              Args compiler_args(flags);
+
+              return compiler_args.GetOptionValuesAsStrings(option, values);
+            }
+          }
+        }
+      }
+    } else {
+      const uint32_t num_compile_units = GetNumCompileUnits();
+
+      for (uint32_t cu_idx = 0; cu_idx < num_compile_units; ++cu_idx) {
+        DWARFCompileUnit *dwarf_cu = debug_info->GetCompileUnitAtIndex(cu_idx);
+
+        if (dwarf_cu) {
+          const DWARFDIE die = dwarf_cu->GetCompileUnitDIEOnly();
+          if (die) {
+            const char *flags =
+                die.GetAttributeValueAsString(DW_AT_APPLE_flags, NULL);
+
+            if (flags) {
+              if (strstr(flags, option)) {
+                Args compiler_args(flags);
+
+                return compiler_args.GetOptionValuesAsStrings(option, values);
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return 0;
+}
+
+void SymbolFileDWARF::GetLoadedModules(lldb::LanguageType language,
+                                       lldb_private::FileSpecList &modules) {
+  ModuleSP module_sp(m_obj_file->GetModule());
+
+  if (IsSwiftLanguage(language)) {
+    const uint32_t num_cus = module_sp->GetNumCompileUnits();
+    for (uint32_t i = 0; i < num_cus; ++i) {
+      CompileUnit *cu = module_sp->GetCompileUnitAtIndex(i).get();
+      if (cu) {
+        const FileSpecList &files = cu->GetSupportFiles();
+        const size_t num_files = files.GetSize();
+        static ConstString g_swift_module_extension("swiftmodule");
+        for (uint32_t pass = 0; pass < 2; ++pass) {
+          for (size_t file_idx = 0; file_idx < num_files; ++file_idx) {
+            const FileSpec &file = files.GetFileSpecAtIndex(file_idx);
+            if (file.GetFileNameExtension() == g_swift_module_extension)
+              modules.AppendIfUnique(file);
+          }
+        }
+      }
+    }
+  }
+}
+
 size_t SymbolFileDWARF::ParseTypes(const SymbolContext &sc,
                                    const DWARFDIE &orig_die,
                                    bool parse_siblings, bool parse_children) {
@@ -3870,6 +4124,10 @@ VariableSP SymbolFileDWARF::ParseVariableDIE(const SymbolContext &sc,
         }
       }
 
+      if (tag == DW_TAG_variable && mangled &&
+          IsSwiftLanguage(sc.comp_unit->GetLanguage()))
+        mangled = NULL;
+
       const DWARFDIE parent_context_die = GetDeclContextDIEContainingDIE(die);
       const dw_tag_t parent_tag = die.GetParent().Tag();
       bool is_static_member =
@@ -4007,7 +4265,15 @@ VariableSP SymbolFileDWARF::ParseVariableDIE(const SymbolContext &sc,
             }
           }
         } else {
-          if (location_is_const_value_data)
+          // The heuristic for inferring static variables works for Clang's
+          // behavior on C-like languages, which generally does not emit
+          // AT_const_value for locals.
+          //
+          // However, the Swift compiler can and does emit AT_const_value for
+          // locals, and function-level statics don't exist, so we flip the
+          // heuristic here.
+          if (location_is_const_value_data &&
+              !IsSwiftLanguage(sc.comp_unit->GetLanguage()))
             scope = eValueTypeVariableStatic;
           else {
             scope = eValueTypeVariableLocal;
@@ -4048,8 +4314,14 @@ VariableSP SymbolFileDWARF::ParseVariableDIE(const SymbolContext &sc,
       }
 
       if (symbol_context_scope) {
-        SymbolFileTypeSP type_sp(
-            new SymbolFileType(*this, DIERef(type_die_form).GetUID(this)));
+        SymbolFileTypeSP type_sp;
+        if (type_die_form.Form() == DW_FORM_strp) {
+          type_sp.reset(new SymbolFileType(
+              *this, ResolveTypeFromAttribute(type_die_form)));
+        } else {
+          type_sp.reset(
+              new SymbolFileType(*this, DIERef(type_die_form).GetUID(this)));
+        }
 
         if (const_value.Form() && type_sp && type_sp->GetType())
           location.CopyOpcodeData(const_value.Unsigned(),
diff --git a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.h b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.h
index 9b1eb1d76..b86ac11d0 100644
--- a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.h
+++ b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.h
@@ -74,6 +74,7 @@ public:
   friend class DWARFCompileUnit;
   friend class DWARFDIE;
   friend class DWARFASTParserClang;
+  friend class DWARFASTParserSwift;
   friend class DWARFASTParserGo;
   friend class DWARFASTParserJava;
   friend class DWARFASTParserOCaml;
@@ -226,6 +227,15 @@ public:
       const lldb_private::ConstString &name,
       const lldb_private::CompilerDeclContext *parent_decl_ctx) override;
 
+  bool GetCompileOption(const char *option, std::string &value,
+                        lldb_private::CompileUnit *cu = nullptr) override;
+
+  int GetCompileOptions(const char *option, std::vector<std::string> &value,
+                        lldb_private::CompileUnit *cu = nullptr) override;
+
+  void GetLoadedModules(lldb::LanguageType language,
+                        lldb_private::FileSpecList &modules) override;
+
   void PreloadSymbols() override;
 
   //------------------------------------------------------------------
@@ -248,6 +258,7 @@ public:
   const lldb_private::DWARFDataExtractor &get_debug_str_offsets_data();
   const lldb_private::DWARFDataExtractor &get_apple_names_data();
   const lldb_private::DWARFDataExtractor &get_apple_types_data();
+  const lldb_private::DWARFDataExtractor &get_apple_exttypes_data();
   const lldb_private::DWARFDataExtractor &get_apple_namespaces_data();
   const lldb_private::DWARFDataExtractor &get_apple_objc_data();
 
@@ -452,6 +463,15 @@ protected:
 
   void UpdateExternalModuleListIfNeeded();
 
+  lldb_private::ClangASTImporter &GetClangASTImporter();
+
+  lldb_private::SwiftASTContext *
+  GetSwiftASTContextForCU(lldb_private::Status *error, DWARFCompileUnit &cu);
+
+  lldb::user_id_t GetTypeUIDFromTypeAttribute(const DWARFFormValue &type_attr);
+
+  lldb::TypeSP ResolveTypeFromAttribute(const DWARFFormValue &type_attr);
+
   virtual DIEToTypePtr &GetDIEToType() { return m_die_to_type; }
 
   virtual DIEToVariableSP &GetDIEToVariable() { return m_die_to_variable_sp; }
@@ -481,6 +501,7 @@ protected:
   DWARFDataSegment m_data_debug_str_offsets;
   DWARFDataSegment m_data_apple_names;
   DWARFDataSegment m_data_apple_types;
+  DWARFDataSegment m_data_apple_exttypes;
   DWARFDataSegment m_data_apple_namespaces;
   DWARFDataSegment m_data_apple_objc;
 
@@ -492,9 +513,11 @@ protected:
   std::unique_ptr<DWARFDebugLine> m_line;
   std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_names_ap;
   std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_types_ap;
+  std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_exttypes_ap;
   std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_namespaces_ap;
   std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_objc_ap;
   std::unique_ptr<GlobalVariableMap> m_global_aranges_ap;
+  std::unique_ptr<lldb_private::ClangASTImporter> m_clang_ast_importer_ap;
 
   typedef std::unordered_map<lldb::offset_t, lldb_private::DebugMacrosSP>
       DebugMacrosMap;
@@ -511,7 +534,8 @@ protected:
   NameToDIE m_global_index;               // Global and static variables
   NameToDIE m_type_index;                 // All type DIE offsets
   NameToDIE m_namespace_index;            // All type DIE offsets
-  bool m_indexed : 1, m_using_apple_tables : 1, m_fetched_external_modules : 1;
+  bool m_indexed : 1, m_using_apple_tables : 1, m_initialized_swift_modules : 1,
+      m_reported_missing_sdk : 1, m_fetched_external_modules : 1;
   lldb_private::LazyBool m_supports_DW_AT_APPLE_objc_complete_type;
 
   typedef std::shared_ptr<std::set<DIERef>> DIERefSetSP;
diff --git a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.cpp b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.cpp
index eabff86a5..425e9a727 100644
--- a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.cpp
+++ b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.cpp
@@ -21,6 +21,7 @@
 #include "lldb/Core/RangeMap.h"
 #include "lldb/Core/Section.h"
 #include "lldb/Host/FileSystem.h"
+#include "lldb/Utility/DataBufferLLVM.h"
 #include "lldb/Utility/RegularExpression.h"
 #include "lldb/Utility/Timer.h"
 
@@ -255,7 +256,8 @@ SymbolFile *SymbolFileDWARFDebugMap::CreateInstance(ObjectFile *obj_file) {
 SymbolFileDWARFDebugMap::SymbolFileDWARFDebugMap(ObjectFile *ofile)
     : SymbolFile(ofile), m_flags(), m_compile_unit_infos(), m_func_indexes(),
       m_glob_indexes(),
-      m_supports_DW_AT_APPLE_objc_complete_type(eLazyBoolCalculate) {}
+      m_supports_DW_AT_APPLE_objc_complete_type(eLazyBoolCalculate),
+      m_initialized_swift_modules(false) {}
 
 SymbolFileDWARFDebugMap::~SymbolFileDWARFDebugMap() {}
 
@@ -1441,3 +1443,66 @@ SymbolFileDWARFDebugMap::AddOSOARanges(SymbolFileDWARF *dwarf2Data,
   }
   return num_line_entries_added;
 }
+
+std::vector<DataBufferSP>
+SymbolFileDWARFDebugMap::GetASTData(lldb::LanguageType language) {
+  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_MAP));
+
+  std::vector<DataBufferSP> ast_datas;
+  if (language != eLanguageTypeSwift) {
+    if (log)
+      log->Printf("SymbolFileDWARFDebugMap::%s() - ignoring because not Swift",
+                  __FUNCTION__);
+    return ast_datas;
+  }
+
+  Symtab *symtab = m_obj_file->GetSymtab();
+  if (!symtab) {
+    if (log)
+      log->Printf("SymbolFileDWARFDebugMap::%s() - ignoring because the obj "
+                  "file has no symbol table",
+                  __FUNCTION__);
+    return ast_datas;
+  }
+
+  uint32_t next_idx = 0;
+  bool done = false;
+  do {
+    Symbol *symbol =
+        symtab->FindSymbolWithType(eSymbolTypeASTFile, Symtab::eDebugAny,
+                                   Symtab::eVisibilityAny, next_idx);
+    if (symbol == nullptr) {
+      // We didn't find any more symbols of type eSymbolTypeASTFile.  We are
+      // done looping for them.
+      done = true;
+    } else {
+      // Try to load the specified file.
+      FileSpec file_spec(symbol->GetName().GetCString(), false);
+      if (file_spec.Exists()) {
+        // We found the source data for the AST data blob.
+        // Read it in and add it to our return vector.
+        ast_datas.push_back(DataBufferLLVM::CreateFromPath(file_spec.GetPath()));
+        if (log)
+          log->Printf("SymbolFileDWARFDebugMap::%s() - found and loaded AST "
+                      "data from file %s",
+                      __FUNCTION__, file_spec.GetPath().c_str());
+      } else {
+        if (log)
+          log->Printf("SymbolFileDWARFDebugMap::%s() - found reference to AST "
+                      "file %s, but could not find the file, ignoring",
+                      __FUNCTION__, file_spec.GetPath().c_str());
+      }
+
+      // Regardless of whether we could find the specified file, start the next
+      // symbol search at the index past the one we just found.
+      ++next_idx;
+    }
+  } while (!done);
+
+  // Return the vector of AST data blobs
+  if (log)
+    log->Printf("SymbolFileDWARFDebugMap::%s() - returning %d AST data blobs",
+                __FUNCTION__, (int)ast_datas.size());
+
+  return ast_datas;
+}
diff --git a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.h b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.h
index dcca4268b..43957cece 100644
--- a/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.h
+++ b/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.h
@@ -23,6 +23,7 @@
 class SymbolFileDWARF;
 class DWARFDebugAranges;
 class DWARFDeclContext;
+class DebugMapModule;
 
 class SymbolFileDWARFDebugMap : public lldb_private::SymbolFile {
 public:
@@ -123,6 +124,9 @@ public:
                   uint32_t type_mask,
                   lldb_private::TypeList &type_list) override;
 
+  std::vector<lldb::DataBufferSP>
+  GetASTData(lldb::LanguageType language) override;
+
   //------------------------------------------------------------------
   // PluginInterface protocol
   //------------------------------------------------------------------
@@ -136,6 +140,7 @@ protected:
   friend class DebugMapModule;
   friend struct DIERef;
   friend class DWARFASTParserClang;
+  friend class DWARFASTParserSwift;
   friend class DWARFCompileUnit;
   friend class SymbolFileDWARF;
   struct OSOInfo {
@@ -303,6 +308,7 @@ protected:
   std::map<lldb_private::ConstString, OSOInfoSP> m_oso_map;
   UniqueDWARFASTTypeMap m_unique_ast_type_map;
   lldb_private::LazyBool m_supports_DW_AT_APPLE_objc_complete_type;
+  bool m_initialized_swift_modules;
   DebugMap m_debug_map;
 
   //------------------------------------------------------------------
diff --git a/source/Symbol/CMakeLists.txt b/source/Symbol/CMakeLists.txt
index 69a2b5a16..b21c6cb0e 100644
--- a/source/Symbol/CMakeLists.txt
+++ b/source/Symbol/CMakeLists.txt
@@ -22,6 +22,8 @@ add_lldb_library(lldbSymbol
   LineTable.cpp
   ObjectFile.cpp
   OCamlASTContext.cpp
+  SwiftASTContext.cpp
+  SwiftMangledNameVisitor.cpp
   Symbol.cpp
   SymbolContext.cpp
   SymbolFile.cpp
@@ -38,6 +40,16 @@ add_lldb_library(lldbSymbol
   VerifyDecl.cpp
 
   LINK_LIBS
+    swiftAST
+    swiftASTSectionImporter
+    swiftBasic
+    swiftClangImporter
+    swiftDriver
+    swiftFrontend
+    swiftIDE
+    swiftIRGen
+    swiftSIL
+    swiftSerialization
     clangAST
     clangBasic
     clangFrontend
@@ -48,6 +60,7 @@ add_lldb_library(lldbSymbol
     lldbUtility
     lldbPluginExpressionParserClang
     lldbPluginExpressionParserGo
+    lldbPluginExpressionParserSwift
     lldbPluginSymbolFileDWARF
     lldbPluginSymbolFilePDB
     lldbPluginObjectContainerBSDArchive
diff --git a/source/Symbol/ClangASTContext.cpp b/source/Symbol/ClangASTContext.cpp
index c8738e6e5..70081d437 100644
--- a/source/Symbol/ClangASTContext.cpp
+++ b/source/Symbol/ClangASTContext.cpp
@@ -49,6 +49,7 @@
 #include "clang/AST/VTableBuilder.h"
 #include "clang/Basic/Builtins.h"
 #include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/DiagnosticOptions.h"
 #include "clang/Basic/FileManager.h"
 #include "clang/Basic/FileSystemOptions.h"
 #include "clang/Basic/SourceManager.h"
@@ -543,6 +544,14 @@ ClangASTContext::ClangASTContext(const char *target_triple)
     SetTargetTriple(target_triple);
 }
 
+ClangASTContext::ClangASTContext(clang::ASTContext *ast_ctx)
+    : TypeSystem(TypeSystem::eKindClang), m_target_triple(), m_ast_ap(ast_ctx),
+      m_language_options_ap(), m_source_manager_ap(), m_diagnostics_engine_ap(),
+      m_target_options_rp(), m_target_info_ap(), m_identifier_table_ap(),
+      m_selector_table_ap(), m_builtins_ap(), m_callback_tag_decl(nullptr),
+      m_callback_objc_decl(nullptr), m_callback_baton(nullptr),
+      m_pointer_byte_size(0), m_ast_owned(false) {}
+
 //----------------------------------------------------------------------
 // Destructor
 //----------------------------------------------------------------------
@@ -558,9 +567,10 @@ ConstString ClangASTContext::GetPluginName() {
 
 uint32_t ClangASTContext::GetPluginVersion() { return 1; }
 
-lldb::TypeSystemSP ClangASTContext::CreateInstance(lldb::LanguageType language,
-                                                   lldb_private::Module *module,
-                                                   Target *target) {
+lldb::TypeSystemSP
+ClangASTContext::CreateInstance(lldb::LanguageType language,
+                                lldb_private::Module *module, Target *target,
+                                const char *compiler_options) {
   if (ClangASTContextSupportsLanguage(language)) {
     ArchSpec arch;
     if (module)
@@ -758,6 +768,8 @@ ASTContext *ClangASTContext::getASTContext() {
 
 ClangASTContext *ClangASTContext::GetASTContext(clang::ASTContext *ast) {
   ClangASTContext *clang_ast = GetASTMap().Lookup(ast);
+  if (!clang_ast)
+    clang_ast = new ClangASTContext(ast);
   return clang_ast;
 }
 
@@ -1285,6 +1297,30 @@ ClangASTContext::GetTranslationUnitDecl(clang::ASTContext *ast) {
   return ast->getTranslationUnitDecl();
 }
 
+CompilerType ClangASTContext::CopyType(const CompilerType &src) {
+  clang::ASTContext *dst_clang_ast = getASTContext();
+  if (dst_clang_ast) {
+    FileSystemOptions file_system_options;
+    ClangASTContext *src_ast =
+        llvm::dyn_cast_or_null<ClangASTContext>(src.GetTypeSystem());
+    if (src_ast) {
+      clang::ASTContext *src_clang_ast = src_ast->getASTContext();
+      if (src_clang_ast) {
+        if (src_clang_ast == dst_clang_ast)
+          return src; // We already are in the right AST, no need to copy
+        else {
+          FileManager file_manager(file_system_options);
+          ASTImporter importer(*dst_clang_ast, file_manager, *src_clang_ast,
+                               file_manager, false);
+          QualType dst_qual_type(importer.Import(ClangUtil::GetQualType(src)));
+          return CompilerType(this, dst_qual_type.getAsOpaquePtr());
+        }
+      }
+    }
+  }
+  return CompilerType();
+}
+
 clang::Decl *ClangASTContext::CopyDecl(ASTContext *dst_ast, ASTContext *src_ast,
                                        clang::Decl *source_decl) {
   FileSystemOptions file_system_options;
@@ -3571,7 +3607,7 @@ bool ClangASTContext::IsDefined(lldb::opaque_compiler_type_t type) {
 }
 
 bool ClangASTContext::IsObjCClassType(const CompilerType &type) {
-  if (type) {
+  if (type && ClangUtil::IsClangType(type)) {
     clang::QualType qual_type(ClangUtil::GetCanonicalQualType(type));
 
     const clang::ObjCObjectPointerType *obj_pointer_type =
@@ -3584,7 +3620,7 @@ bool ClangASTContext::IsObjCClassType(const CompilerType &type) {
 }
 
 bool ClangASTContext::IsObjCObjectOrInterfaceType(const CompilerType &type) {
-  if (ClangUtil::IsClangType(type))
+  if (type && ClangUtil::IsClangType(type))
     return ClangUtil::GetCanonicalQualType(type)->isObjCObjectOrInterfaceType();
   return false;
 }
@@ -3634,7 +3670,7 @@ bool ClangASTContext::IsPolymorphicClass(lldb::opaque_compiler_type_t type) {
 bool ClangASTContext::IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                                             CompilerType *dynamic_pointee_type,
                                             bool check_cplusplus,
-                                            bool check_objc) {
+                                            bool check_objc, bool check_swift) {
   clang::QualType pointee_qual_type;
   if (type) {
     clang::QualType qual_type(GetCanonicalQualType(type));
@@ -3690,26 +3726,26 @@ bool ClangASTContext::IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                                        ->getUnderlyingType()
                                        .getAsOpaquePtr(),
                                    dynamic_pointee_type, check_cplusplus,
-                                   check_objc);
+                                   check_objc, check_swift);
 
     case clang::Type::Auto:
       return IsPossibleDynamicType(llvm::cast<clang::AutoType>(qual_type)
                                        ->getDeducedType()
                                        .getAsOpaquePtr(),
                                    dynamic_pointee_type, check_cplusplus,
-                                   check_objc);
+                                   check_objc, check_swift);
 
     case clang::Type::Elaborated:
       return IsPossibleDynamicType(llvm::cast<clang::ElaboratedType>(qual_type)
                                        ->getNamedType()
                                        .getAsOpaquePtr(),
                                    dynamic_pointee_type, check_cplusplus,
-                                   check_objc);
+                                   check_objc, check_swift);
 
     case clang::Type::Paren:
       return IsPossibleDynamicType(
           llvm::cast<clang::ParenType>(qual_type)->desugar().getAsOpaquePtr(),
-          dynamic_pointee_type, check_cplusplus, check_objc);
+          dynamic_pointee_type, check_cplusplus, check_objc, check_swift);
     default:
       break;
     }
@@ -3850,7 +3886,7 @@ bool ClangASTContext::IsBeingDefined(lldb::opaque_compiler_type_t type) {
 
 bool ClangASTContext::IsObjCObjectPointerType(const CompilerType &type,
                                               CompilerType *class_type_ptr) {
-  if (!type)
+  if (!type || !ClangUtil::IsClangType(type))
     return false;
 
   clang::QualType qual_type(ClangUtil::GetCanonicalQualType(type));
@@ -4417,6 +4453,12 @@ ClangASTContext::GetCanonicalType(lldb::opaque_compiler_type_t type) {
   return CompilerType();
 }
 
+CompilerType ClangASTContext::GetInstanceType(void *type) {
+  if (type)
+    return CompilerType(getASTContext(), GetQualType(type));
+  return CompilerType();
+}
+
 static clang::QualType GetFullyUnqualifiedType_Impl(clang::ASTContext *ast,
                                                     clang::QualType qual_type) {
   if (qual_type->isPointerType())
@@ -4703,6 +4745,28 @@ ClangASTContext::GetMemberFunctionAtIndex(lldb::opaque_compiler_type_t type,
     return TypeMemberFunctionImpl(clang_type, clang_decl, name, kind);
 }
 
+CompilerType ClangASTContext::GetLValueReferenceType(const CompilerType &type) {
+  if (ClangUtil::IsClangType(type)) {
+    ClangASTContext *ast =
+        llvm::dyn_cast<ClangASTContext>(type.GetTypeSystem());
+    return CompilerType(ast->getASTContext(),
+                        ast->getASTContext()->getLValueReferenceType(
+                            ClangUtil::GetQualType(type)));
+  }
+  return CompilerType();
+}
+
+CompilerType ClangASTContext::GetRValueReferenceType(const CompilerType &type) {
+  if (ClangUtil::IsClangType(type)) {
+    ClangASTContext *ast =
+        llvm::dyn_cast<ClangASTContext>(type.GetTypeSystem());
+    return CompilerType(ast->getASTContext(),
+                        ast->getASTContext()->getRValueReferenceType(
+                            ClangUtil::GetQualType(type)));
+  }
+  return CompilerType();
+}
+
 CompilerType
 ClangASTContext::GetNonReferenceType(lldb::opaque_compiler_type_t type) {
   if (type)
@@ -4873,6 +4937,20 @@ ClangASTContext::GetTypedefedType(lldb::opaque_compiler_type_t type) {
   return CompilerType();
 }
 
+CompilerType
+ClangASTContext::GetUnboundType(lldb::opaque_compiler_type_t type) {
+  return CompilerType(getASTContext(), GetQualType(type));
+}
+
+CompilerType ClangASTContext::RemoveFastQualifiers(const CompilerType &type) {
+  if (ClangUtil::IsClangType(type)) {
+    clang::QualType qual_type(ClangUtil::GetQualType(type));
+    qual_type.getQualifiers().removeFastQualifiers();
+    return CompilerType(type.GetTypeSystem(), qual_type.getAsOpaquePtr());
+  }
+  return type;
+}
+
 //----------------------------------------------------------------------
 // Create related types using the current type's AST
 //----------------------------------------------------------------------
@@ -4945,6 +5023,10 @@ uint64_t ClangASTContext::GetBitSize(lldb::opaque_compiler_type_t type,
   return 0;
 }
 
+uint64_t ClangASTContext::GetByteStride(lldb::opaque_compiler_type_t type) {
+  return GetByteSize(type, nullptr);
+}
+
 size_t ClangASTContext::GetTypeBitAlign(lldb::opaque_compiler_type_t type) {
   if (GetCompleteType(type))
     return getASTContext()->getTypeAlign(GetQualType(type));
@@ -6903,9 +6985,10 @@ CompilerType ClangASTContext::GetChildCompilerTypeAtIndex(
   return CompilerType();
 }
 
-static uint32_t GetIndexForRecordBase(const clang::RecordDecl *record_decl,
-                                      const clang::CXXBaseSpecifier *base_spec,
-                                      bool omit_empty_base_classes) {
+uint32_t
+ClangASTContext::GetIndexForRecordBase(const clang::RecordDecl *record_decl,
+                                       const clang::CXXBaseSpecifier *base_spec,
+                                       bool omit_empty_base_classes) {
   uint32_t child_idx = 0;
 
   const clang::CXXRecordDecl *cxx_record_decl =
@@ -7050,10 +7133,10 @@ size_t ClangASTContext::GetIndexOfChildMemberWithName(
 
           clang::CXXBasePaths paths;
           if (cxx_record_decl->lookupInBases(
-                  [decl_name](const clang::CXXBaseSpecifier *specifier,
-                              clang::CXXBasePath &path) {
+                  [&decl_name](const CXXBaseSpecifier *base_specifier,
+                               CXXBasePath &base_path) {
                     return clang::CXXRecordDecl::FindOrdinaryMember(
-                        specifier, path, decl_name);
+                        base_specifier, base_path, decl_name);
                   },
                   paths)) {
             clang::CXXBasePaths::const_paths_iterator path,
@@ -9230,7 +9313,8 @@ bool ClangASTContext::DumpTypeValue(
     lldb::opaque_compiler_type_t type, Stream *s, lldb::Format format,
     const DataExtractor &data, lldb::offset_t byte_offset, size_t byte_size,
     uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-    ExecutionContextScope *exe_scope) {
+    ExecutionContextScope *exe_scope,
+    bool is_base_class) {
   if (!type)
     return false;
   if (IsAggregateType(type)) {
@@ -9262,7 +9346,7 @@ bool ClangASTContext::DumpTypeValue(
                              // treat as a bitfield
           bitfield_bit_offset, // Offset in bits of a bitfield value if
                                // bitfield_bit_size != 0
-          exe_scope);
+          exe_scope, is_base_class);
     } break;
 
     case clang::Type::Enum:
@@ -9646,7 +9730,7 @@ DWARFASTParser *ClangASTContext::GetDWARFParser() {
 
 PDBASTParser *ClangASTContext::GetPDBParser() {
   if (!m_pdb_ast_parser_ap)
-    m_pdb_ast_parser_ap.reset(new PDBASTParser(*this));
+      m_pdb_ast_parser_ap.reset(new PDBASTParser(*this));
   return m_pdb_ast_parser_ap.get();
 }
 
diff --git a/source/Symbol/CompilerType.cpp b/source/Symbol/CompilerType.cpp
index e3880af27..f32fd44be 100644
--- a/source/Symbol/CompilerType.cpp
+++ b/source/Symbol/CompilerType.cpp
@@ -14,6 +14,7 @@
 #include "lldb/Core/StreamFile.h"
 #include "lldb/Symbol/ClangASTContext.h"
 #include "lldb/Symbol/ClangExternalASTSourceCommon.h"
+#include "lldb/Symbol/SwiftASTContext.h"
 #include "lldb/Symbol/Type.h"
 #include "lldb/Target/ExecutionContext.h"
 #include "lldb/Target/Process.h"
@@ -26,6 +27,8 @@
 #include <iterator>
 #include <mutex>
 
+#include "swift/AST/Type.h"
+
 using namespace lldb;
 using namespace lldb_private;
 
@@ -42,6 +45,11 @@ CompilerType::CompilerType(clang::ASTContext *ast, clang::QualType qual_type)
 #endif
 }
 
+CompilerType::CompilerType(swift::ASTContext *ast_context,
+                           swift::Type qual_type)
+    : m_type(qual_type.getPointer()),
+      m_type_system(SwiftASTContext::GetSwiftASTContext(ast_context)) {}
+
 CompilerType::~CompilerType() {}
 
 //----------------------------------------------------------------------
@@ -226,11 +234,11 @@ bool CompilerType::IsPolymorphicClass() const {
 }
 
 bool CompilerType::IsPossibleDynamicType(CompilerType *dynamic_pointee_type,
-                                         bool check_cplusplus,
-                                         bool check_objc) const {
+                                         bool check_cplusplus, bool check_objc,
+                                         bool check_swift) const {
   if (IsValid())
-    return m_type_system->IsPossibleDynamicType(m_type, dynamic_pointee_type,
-                                                check_cplusplus, check_objc);
+    return m_type_system->IsPossibleDynamicType(
+        m_type, dynamic_pointee_type, check_cplusplus, check_objc, check_swift);
   return false;
 }
 
@@ -312,7 +320,26 @@ ConstString CompilerType::GetTypeName() const {
   return ConstString("<invalid>");
 }
 
-ConstString CompilerType::GetDisplayTypeName() const { return GetTypeName(); }
+ConstString CompilerType::GetDisplayTypeName() const {
+  if (IsValid()) {
+    return m_type_system->GetDisplayTypeName(m_type);
+  }
+  return ConstString();
+}
+
+ConstString CompilerType::GetTypeSymbolName() const {
+  if (IsValid()) {
+    return m_type_system->GetTypeSymbolName(m_type);
+  }
+  return ConstString();
+}
+
+ConstString CompilerType::GetMangledTypeName() const {
+  if (IsValid()) {
+    return m_type_system->GetMangledTypeName(m_type);
+  }
+  return ConstString();
+}
 
 uint32_t CompilerType::GetTypeInfo(
     CompilerType *pointee_or_element_compiler_type) const {
@@ -378,6 +405,12 @@ CompilerType CompilerType::GetCanonicalType() const {
   return CompilerType();
 }
 
+CompilerType CompilerType::GetInstanceType() const {
+  if (IsValid())
+    return m_type_system->GetInstanceType(m_type);
+  return CompilerType();
+}
+
 CompilerType CompilerType::GetFullyUnqualifiedType() const {
   if (IsValid())
     return m_type_system->GetFullyUnqualifiedType(m_type);
@@ -490,6 +523,20 @@ CompilerType CompilerType::GetTypedefedType() const {
     return CompilerType();
 }
 
+CompilerType CompilerType::GetUnboundType() const {
+  if (IsValid())
+    return m_type_system->GetUnboundType(m_type);
+  return CompilerType();
+}
+
+// CompilerType
+// CompilerType::RemoveFastQualifiers () const
+//{
+//    if (IsValid())
+//        return m_type_system->RemoveFastQualifiers(m_type);
+//    return CompilerType();
+//}
+
 //----------------------------------------------------------------------
 // Create related types using the current type's AST
 //----------------------------------------------------------------------
@@ -515,6 +562,14 @@ uint64_t CompilerType::GetByteSize(ExecutionContextScope *exe_scope) const {
   return (GetBitSize(exe_scope) + 7) / 8;
 }
 
+uint64_t CompilerType::GetByteStride() const {
+  if (IsValid())
+    return m_type_system->GetByteStride(m_type);
+  return 0;
+}
+
+uint64_t CompilerType::GetAlignedBitSize() const { return 0; }
+
 size_t CompilerType::GetTypeBitAlign() const {
   if (IsValid())
     return m_type_system->GetTypeBitAlign(m_type);
@@ -762,12 +817,13 @@ bool CompilerType::DumpTypeValue(Stream *s, lldb::Format format,
                                  lldb::offset_t byte_offset, size_t byte_size,
                                  uint32_t bitfield_bit_size,
                                  uint32_t bitfield_bit_offset,
-                                 ExecutionContextScope *exe_scope) {
+                                 ExecutionContextScope *exe_scope,
+                                 bool is_base_class) {
   if (!IsValid())
     return false;
-  return m_type_system->DumpTypeValue(m_type, s, format, data, byte_offset,
-                                      byte_size, bitfield_bit_size,
-                                      bitfield_bit_offset, exe_scope);
+  return m_type_system->DumpTypeValue(
+      m_type, s, format, data, byte_offset, byte_size, bitfield_bit_size,
+      bitfield_bit_offset, exe_scope, is_base_class);
 }
 
 void CompilerType::DumpSummary(ExecutionContext *exe_ctx, Stream *s,
@@ -797,7 +853,7 @@ bool CompilerType::GetValueAsScalar(const lldb_private::DataExtractor &data,
   if (!IsValid())
     return false;
 
-  if (IsAggregateType()) {
+  if (0 == (GetTypeInfo() & eTypeHasValue)) {
     return false; // Aggregate types don't have scalar values
   } else {
     uint64_t count = 0;
diff --git a/source/Symbol/Function.cpp b/source/Symbol/Function.cpp
index 9464cef0b..98d9f8c6f 100644
--- a/source/Symbol/Function.cpp
+++ b/source/Symbol/Function.cpp
@@ -112,7 +112,7 @@ ConstString InlineFunctionInfo::GetName(LanguageType language) const {
 ConstString InlineFunctionInfo::GetDisplayName(LanguageType language) const {
   if (m_mangled)
     return m_mangled.GetDisplayDemangledName(language);
-  return m_name;
+  return GetName(language);
 }
 
 Declaration &InlineFunctionInfo::GetCallSite() { return m_call_decl; }
@@ -134,22 +134,29 @@ size_t InlineFunctionInfo::MemorySize() const {
 //----------------------------------------------------------------------
 Function::Function(CompileUnit *comp_unit, lldb::user_id_t func_uid,
                    lldb::user_id_t type_uid, const Mangled &mangled, Type *type,
-                   const AddressRange &range)
+                   const AddressRange &range, bool canThrow)
     : UserID(func_uid), m_comp_unit(comp_unit), m_type_uid(type_uid),
       m_type(type), m_mangled(mangled), m_block(func_uid), m_range(range),
       m_frame_base(nullptr), m_flags(), m_prologue_byte_size(0) {
   m_block.SetParentScope(this);
+  if (canThrow)
+    m_flags.Set(flagsFunctionCanThrow);
+
   assert(comp_unit != nullptr);
 }
 
 Function::Function(CompileUnit *comp_unit, lldb::user_id_t func_uid,
                    lldb::user_id_t type_uid, const char *mangled, Type *type,
-                   const AddressRange &range)
+                   const AddressRange &range, bool canThrow)
     : UserID(func_uid), m_comp_unit(comp_unit), m_type_uid(type_uid),
       m_type(type), m_mangled(ConstString(mangled), true), m_block(func_uid),
       m_range(range), m_frame_base(nullptr), m_flags(),
       m_prologue_byte_size(0) {
   m_block.SetParentScope(this);
+
+  if (canThrow)
+    m_flags.Set(flagsFunctionCanThrow);
+
   assert(comp_unit != nullptr);
 }
 
@@ -350,6 +357,8 @@ bool Function::IsTopLevelFunction() {
 }
 
 ConstString Function::GetDisplayName() const {
+  if (!m_mangled)
+    return GetName();
   return m_mangled.GetDisplayDemangledName(GetLanguage());
 }
 
diff --git a/source/Symbol/GoASTContext.cpp b/source/Symbol/GoASTContext.cpp
index 6761a605e..33e3ab278 100644
--- a/source/Symbol/GoASTContext.cpp
+++ b/source/Symbol/GoASTContext.cpp
@@ -229,8 +229,8 @@ ConstString GoASTContext::GetPluginName() {
 uint32_t GoASTContext::GetPluginVersion() { return 1; }
 
 lldb::TypeSystemSP GoASTContext::CreateInstance(lldb::LanguageType language,
-                                                Module *module,
-                                                Target *target) {
+                                                Module *module, Target *target,
+                                                const char *compiler_options) {
   if (language == eLanguageTypeGo) {
     ArchSpec arch;
     std::shared_ptr<GoASTContext> go_ast_sp;
@@ -434,7 +434,7 @@ bool GoASTContext::IsPolymorphicClass(lldb::opaque_compiler_type_t type) {
 bool GoASTContext::IsPossibleDynamicType(
     lldb::opaque_compiler_type_t type,
     CompilerType *target_type, // Can pass NULL
-    bool check_cplusplus, bool check_objc) {
+    bool check_cplusplus, bool check_objc, bool check_swift) {
   if (target_type)
     target_type->Clear();
   if (type)
@@ -1185,7 +1185,8 @@ bool GoASTContext::DumpTypeValue(lldb::opaque_compiler_type_t type, Stream *s,
                                  lldb::offset_t byte_offset, size_t byte_size,
                                  uint32_t bitfield_bit_size,
                                  uint32_t bitfield_bit_offset,
-                                 ExecutionContextScope *exe_scope) {
+                                 ExecutionContextScope *exe_scope,
+                                 bool is_base_class) {
   if (!type)
     return false;
   if (IsAggregateType(type)) {
@@ -1208,7 +1209,7 @@ bool GoASTContext::DumpTypeValue(lldb::opaque_compiler_type_t type, Stream *s,
                              // treat as a bitfield
           bitfield_bit_offset, // Offset in bits of a bitfield value if
                                // bitfield_bit_size != 0
-          exe_scope);
+          exe_scope, is_base_class);
     }
 
     uint32_t item_count = 1;
diff --git a/source/Symbol/JavaASTContext.cpp b/source/Symbol/JavaASTContext.cpp
index ae4e9d513..fba0d9e14 100644
--- a/source/Symbol/JavaASTContext.cpp
+++ b/source/Symbol/JavaASTContext.cpp
@@ -347,7 +347,8 @@ uint32_t JavaASTContext::GetPluginVersion() { return 1; }
 
 lldb::TypeSystemSP JavaASTContext::CreateInstance(lldb::LanguageType language,
                                                   Module *module,
-                                                  Target *target) {
+                                                  Target *target,
+                                                  const char *extra_options) {
   if (language == eLanguageTypeJava) {
     if (module)
       return std::make_shared<JavaASTContext>(module->GetArchitecture());
@@ -518,7 +519,7 @@ bool JavaASTContext::IsIntegerType(lldb::opaque_compiler_type_t type,
 bool JavaASTContext::IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                                            CompilerType *target_type,
                                            bool check_cplusplus,
-                                           bool check_objc) {
+                                           bool check_objc, bool check_swift) {
   return llvm::isa<JavaReferenceType>(static_cast<JavaType *>(type));
 }
 
@@ -729,6 +730,11 @@ JavaASTContext::GetCanonicalType(lldb::opaque_compiler_type_t type) {
   return CompilerType(this, type);
 }
 
+CompilerType
+JavaASTContext::GetInstanceType(lldb::opaque_compiler_type_t type) {
+  return CompilerType(this, type);
+}
+
 CompilerType
 JavaASTContext::GetFullyUnqualifiedType(lldb::opaque_compiler_type_t type) {
   return CompilerType(this, type);
@@ -747,6 +753,10 @@ JavaASTContext::GetTypedefedType(lldb::opaque_compiler_type_t type) {
   return CompilerType();
 }
 
+CompilerType JavaASTContext::GetUnboundType(lldb::opaque_compiler_type_t type) {
+  return CompilerType();
+}
+
 CompilerType JavaASTContext::GetBasicTypeFromAST(lldb::BasicType basic_type) {
   return CompilerType();
 }
@@ -820,6 +830,10 @@ uint64_t JavaASTContext::GetBitSize(lldb::opaque_compiler_type_t type,
   return 0;
 }
 
+uint64_t JavaASTContext::GetByteStride(void *type) {
+  return (GetBitSize(type, nullptr) + 7) / 8;
+}
+
 lldb::Encoding JavaASTContext::GetEncoding(lldb::opaque_compiler_type_t type,
                                            uint64_t &count) {
   count = 1;
@@ -1002,7 +1016,8 @@ bool JavaASTContext::DumpTypeValue(
     lldb::opaque_compiler_type_t type, Stream *s, lldb::Format format,
     const DataExtractor &data, lldb::offset_t data_offset,
     size_t data_byte_size, uint32_t bitfield_bit_size,
-    uint32_t bitfield_bit_offset, ExecutionContextScope *exe_scope) {
+    uint32_t bitfield_bit_offset, ExecutionContextScope *exe_scope,
+    bool is_base_class) {
   if (IsScalarType(type)) {
     return DumpDataExtractor(data, s, data_offset, format, data_byte_size,
                              1, // count
diff --git a/source/Symbol/OCamlASTContext.cpp b/source/Symbol/OCamlASTContext.cpp
index 1456ebfa9..1300e49ea 100644
--- a/source/Symbol/OCamlASTContext.cpp
+++ b/source/Symbol/OCamlASTContext.cpp
@@ -113,9 +113,9 @@ ConstString OCamlASTContext::GetPluginName() {
 
 uint32_t OCamlASTContext::GetPluginVersion() { return 1; }
 
-lldb::TypeSystemSP OCamlASTContext::CreateInstance(lldb::LanguageType language,
-                                                   Module *module,
-                                                   Target *target) {
+lldb::TypeSystemSP
+OCamlASTContext::CreateInstance(lldb::LanguageType language, Module *module,
+                                Target *target, const char *compiler_options) {
   Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_LANGUAGE));
 
   if (language == lldb::eLanguageTypeOCaml) {
@@ -292,7 +292,7 @@ bool OCamlASTContext::IsPolymorphicClass(lldb::opaque_compiler_type_t type) {
 bool OCamlASTContext::IsPossibleDynamicType(lldb::opaque_compiler_type_t type,
                                             CompilerType *target_type,
                                             bool check_cplusplus,
-                                            bool check_objc) {
+                                            bool check_objc, bool check_swift) {
   return false;
 }
 
@@ -408,6 +408,11 @@ OCamlASTContext::GetCanonicalType(lldb::opaque_compiler_type_t type) {
   return CompilerType(this, type);
 }
 
+CompilerType
+OCamlASTContext::GetInstanceType(lldb::opaque_compiler_type_t type) {
+  return CompilerType(this, type);
+}
+
 CompilerType
 OCamlASTContext::GetFullyUnqualifiedType(lldb::opaque_compiler_type_t type) {
   return CompilerType(this, type);
@@ -459,6 +464,15 @@ OCamlASTContext::GetTypedefedType(lldb::opaque_compiler_type_t type) {
   return CompilerType();
 }
 
+CompilerType
+OCamlASTContext::GetUnboundType(lldb::opaque_compiler_type_t type) {
+  return CompilerType();
+}
+
+CompilerType GetUnboundType(lldb::opaque_compiler_type_t type) {
+  return CompilerType();
+}
+
 CompilerType OCamlASTContext::GetBasicTypeFromAST(lldb::BasicType basic_type) {
   return CompilerType();
 }
@@ -481,6 +495,16 @@ uint64_t OCamlASTContext::GetBitSize(lldb::opaque_compiler_type_t type,
   return 0;
 }
 
+uint64_t OCamlASTContext::GetByteStride(lldb::opaque_compiler_type_t type) {
+  if (OCamlPrimitiveType *ptype =
+          llvm::dyn_cast<OCamlPrimitiveType>(static_cast<OCamlType *>(type))) {
+    // This is very likely insufficient as it doesn't take any kind of
+    // post-structure packing into account.
+    return ptype->GetByteSize();
+  }
+  return 0;
+}
+
 lldb::Encoding OCamlASTContext::GetEncoding(lldb::opaque_compiler_type_t type,
                                             uint64_t &count) {
   count = 1;
@@ -615,7 +639,7 @@ bool OCamlASTContext::DumpTypeValue(
     lldb::opaque_compiler_type_t type, Stream *s, lldb::Format format,
     const DataExtractor &data, lldb::offset_t byte_offset, size_t byte_size,
     uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
-    ExecutionContextScope *exe_scope) {
+    ExecutionContextScope *exe_scope, bool is_base_class) {
   if (!type) {
     s->Printf("no type value\n");
     return false;
diff --git a/source/Symbol/ObjectFile.cpp b/source/Symbol/ObjectFile.cpp
index fd4180862..6946b298f 100644
--- a/source/Symbol/ObjectFile.cpp
+++ b/source/Symbol/ObjectFile.cpp
@@ -18,6 +18,7 @@
 #include "lldb/Target/Process.h"
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/SectionLoadList.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/DataBuffer.h"
 #include "lldb/Utility/DataBufferHeap.h"
@@ -361,8 +362,10 @@ AddressClass ObjectFile::GetAddressClass(addr_t file_addr) {
           case eSectionTypeDWARFDebugStrOffsets:
           case eSectionTypeDWARFAppleNames:
           case eSectionTypeDWARFAppleTypes:
+          case eSectionTypeDWARFAppleExternalTypes:
           case eSectionTypeDWARFAppleNamespaces:
           case eSectionTypeDWARFAppleObjC:
+          case eSectionTypeSwiftModules:
             return eAddressClassDebug;
           case eSectionTypeEHFrame:
           case eSectionTypeARMexidx:
@@ -444,8 +447,14 @@ AddressClass ObjectFile::GetAddressClass(addr_t file_addr) {
         return eAddressClassRuntime;
       case eSymbolTypeObjCIVar:
         return eAddressClassRuntime;
+      case eSymbolTypeIVarOffset:
+        return eAddressClassRuntime;
+      case eSymbolTypeMetadata:
+        return eAddressClassRuntime;
       case eSymbolTypeReExported:
         return eAddressClassRuntime;
+      case eSymbolTypeASTFile:
+        return eAddressClassDebug;
       }
     }
   }
@@ -633,7 +642,14 @@ lldb::SymbolType
 ObjectFile::GetSymbolTypeFromName(llvm::StringRef name,
                                   lldb::SymbolType symbol_type_hint) {
   if (!name.empty()) {
-    if (name.startswith("_OBJC_")) {
+    std::string name_str = name.str();
+    if (SwiftLanguageRuntime::IsSwiftMangledName(name_str.c_str())) {
+      // Swift
+      if (SwiftLanguageRuntime::IsMetadataSymbol(name_str.c_str()))
+        return lldb::eSymbolTypeMetadata;
+      if (SwiftLanguageRuntime::IsIvarOffsetSymbol(name_str.c_str()))
+        return lldb::eSymbolTypeIVarOffset;
+    } else if (name.startswith("_OBJC_")) {
       // ObjC
       if (name.startswith("_OBJC_CLASS_$_"))
         return lldb::eSymbolTypeObjCClass;
diff --git a/source/Symbol/SwiftASTContext.cpp b/source/Symbol/SwiftASTContext.cpp
index e69de29bb..be4017118 100644
--- a/source/Symbol/SwiftASTContext.cpp
+++ b/source/Symbol/SwiftASTContext.cpp
@@ -0,0 +1,8239 @@
+//===-- SwiftASTContext.cpp -------------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "lldb/Symbol/SwiftASTContext.h"
+
+// C++ Includes
+#include <mutex> // llvm::once
+#include <queue>
+#include <set>
+#include <sstream>
+
+#include "swift/AST/ASTContext.h"
+#include "swift/AST/ASTMangler.h"
+#include "swift/AST/DebuggerClient.h"
+#include "swift/AST/Decl.h"
+#include "swift/AST/DiagnosticEngine.h"
+#include "swift/AST/ExistentialLayout.h"
+#include "swift/AST/GenericSignature.h"
+#include "swift/AST/IRGenOptions.h"
+#include "swift/AST/NameLookup.h"
+#include "swift/AST/SearchPathOptions.h"
+#include "swift/AST/Type.h"
+#include "swift/AST/Types.h"
+#include "swift/ASTSectionImporter/ASTSectionImporter.h"
+#include "swift/Basic/Dwarf.h"
+#include "swift/Basic/LangOptions.h"
+#include "swift/Basic/Platform.h"
+#include "swift/Basic/SourceManager.h"
+#include "swift/ClangImporter/ClangImporter.h"
+#include "swift/ClangImporter/ClangImporterOptions.h"
+#include "swift/Demangling/Demangle.h"
+#include "swift/Driver/Util.h"
+#include "swift/Frontend/Frontend.h"
+#include "swift/Frontend/PrintingDiagnosticConsumer.h"
+#include "swift/IDE/Utils.h"
+#include "swift/IRGen/Linking.h"
+#include "swift/SIL/SILModule.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/TargetOptions.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/Process.h"
+#include "llvm/Support/TargetRegistry.h"
+#include "llvm/Support/TargetSelect.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetOptions.h"
+#include "llvm/Target/TargetSubtargetInfo.h"
+
+#include "swift/IRGen/FixedTypeInfo.h"
+#include "swift/IRGen/GenEnum.h"
+#include "swift/IRGen/GenHeap.h"
+#include "swift/IRGen/IRGenMangler.h"
+#include "swift/IRGen/IRGenModule.h"
+#include "swift/IRGen/TypeInfo.h"
+
+#include "swift/Serialization/SerializedModuleLoader.h"
+#include "swift/Strings.h"
+
+#include "Plugins/ExpressionParser/Swift/SwiftDiagnostic.h"
+#include "Plugins/ExpressionParser/Swift/SwiftUserExpression.h"
+#include "lldb/Core/ArchSpec.h"
+#include "lldb/Core/Debugger.h"
+#include "lldb/Core/DumpDataExtractor.h"
+#include "lldb/Core/Module.h"
+#include "lldb/Core/ModuleSpec.h"
+#include "lldb/Core/PluginManager.h"
+#include "lldb/Core/Section.h"
+#include "lldb/Core/StreamFile.h"
+#include "lldb/Core/ThreadSafeDenseMap.h"
+#include "lldb/Expression/DiagnosticManager.h"
+#include "lldb/Host/Host.h"
+#include "lldb/Host/HostInfo.h"
+#include "lldb/Host/StringConvert.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/CompileUnit.h"
+#include "lldb/Symbol/ObjectFile.h"
+#include "lldb/Symbol/SymbolFile.h"
+#include "lldb/Symbol/SymbolVendor.h"
+#include "lldb/Target/Platform.h"
+#include "lldb/Target/Process.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Utility/CleanUp.h"
+#include "lldb/Utility/FileSpec.h"
+#include "lldb/Utility/LLDBAssert.h"
+#include "lldb/Utility/Log.h"
+#include "lldb/Utility/Status.h"
+
+#include "Plugins/Platform/MacOSX/PlatformDarwin.h"
+#include "Plugins/SymbolFile/DWARF/DWARFASTParserSwift.h"
+
+#ifdef LLDB_CONFIGURATION_DEBUG
+#define VALID_OR_RETURN(value)                                                 \
+  do {                                                                         \
+    lldbassert(!HasFatalErrors());                                             \
+    if (HasFatalErrors()) {                                                    \
+      return (value);                                                          \
+    }                                                                          \
+  } while (0)
+#define VALID_OR_RETURN_VOID()                                                 \
+  do {                                                                         \
+    lldbassert(!HasFatalErrors());                                             \
+    if (HasFatalErrors()) {                                                    \
+      return;                                                                  \
+    }                                                                          \
+  } while (0)
+#else
+#define VALID_OR_RETURN(value)                                                 \
+  do {                                                                         \
+    if (HasFatalErrors()) {                                                    \
+      return (value);                                                          \
+    }                                                                          \
+  } while (0)
+#define VALID_OR_RETURN_VOID()                                                 \
+  do {                                                                         \
+    if (HasFatalErrors()) {                                                    \
+      return;                                                                  \
+    }                                                                          \
+  } while (0)
+#endif
+
+using namespace lldb;
+using namespace lldb_private;
+
+typedef lldb_private::ThreadSafeDenseMap<swift::ASTContext *, SwiftASTContext *>
+    ThreadSafeSwiftASTMap;
+
+static ThreadSafeSwiftASTMap &GetASTMap() {
+  // The global destructor list will tear down all of the modules when the LLDB
+  // shared library is being unloaded and this needs to live beyond all of those
+  // and not be destructed before they have all gone away. So we will leak this
+  // list intentionally so we can avoid global destructor problems.
+  static ThreadSafeSwiftASTMap *g_map_ptr = NULL;
+  static llvm::once_flag g_once_flag;
+  std::call_once(g_once_flag, []() {
+    g_map_ptr = new ThreadSafeSwiftASTMap(); // NOTE: Intentional leak
+  });
+  return *g_map_ptr;
+}
+
+static inline swift::Type GetSwiftType(void *opaque_ptr) {
+  return swift::Type((swift::TypeBase *)opaque_ptr);
+}
+
+static inline swift::CanType GetCanonicalSwiftType(void *opaque_ptr) {
+  return ((swift::TypeBase *)opaque_ptr)->getCanonicalType();
+}
+
+static inline swift::Type GetSwiftType(CompilerType type) {
+  return swift::Type((swift::TypeBase *)type.GetOpaqueQualType());
+}
+
+static inline swift::CanType GetCanonicalSwiftType(CompilerType type) {
+  return ((swift::TypeBase *)type.GetOpaqueQualType())->getCanonicalType();
+}
+
+enum class MemberType : uint32_t { Invalid, BaseClass, Field };
+
+static const char *MemberTypeToCString(MemberType member_type) {
+  switch (member_type) {
+  case MemberType::Invalid:
+    return "invalid";
+  case MemberType::BaseClass:
+    return "base class";
+  case MemberType::Field:
+    return "field";
+  }
+  return "???";
+}
+
+struct MemberInfo {
+  CompilerType clang_type;
+  lldb_private::ConstString name;
+  uint64_t byte_size;
+  uint32_t byte_offset;
+  MemberType member_type;
+  bool is_fragile;
+
+  MemberInfo(MemberType member_type)
+      : clang_type(), name(), byte_size(0), byte_offset(0),
+        member_type(member_type), is_fragile(false) {}
+
+  void Dump(uint32_t idx) {
+    printf("[%i] %12s +%u (%s) %s <%" PRIu64 "> %s\n", idx,
+           MemberTypeToCString(member_type), byte_offset,
+           clang_type.GetTypeName().AsCString("<no type name>"),
+           name.AsCString("<NULL>"), byte_size, is_fragile ? "[fragile]" : "");
+  }
+};
+
+struct CachedMemberInfo {
+  std::vector<MemberInfo> member_infos;
+};
+
+struct EnumElementInfo {
+  CompilerType clang_type;
+  lldb_private::ConstString name;
+  uint64_t byte_size;
+  uint32_t value;       // The value for this enumeration element
+  uint32_t extra_value; // If not UINT32_MAX, then this value is an extra value
+  // that appears at offset 0 to tell one or more empty
+  // enums apart. This value will only be filled in if there
+  // are one ore more enum elements that have a non-zero byte size
+
+  EnumElementInfo()
+      : clang_type(), name(), byte_size(0), extra_value(UINT32_MAX) {}
+
+  void Dump(Stream &strm) const {
+    strm.Printf("<%2" PRIu64 "> %4u", byte_size, value);
+    if (extra_value != UINT32_MAX)
+      strm.Printf("%4u: ", extra_value);
+    else
+      strm.Printf("    : ");
+    strm.Printf("case %s", name.GetCString());
+    if (clang_type)
+      strm.Printf("%s", clang_type.GetTypeName().AsCString("<no type name>"));
+    strm.EOL();
+  }
+};
+
+class SwiftEnumDescriptor;
+
+typedef std::shared_ptr<CachedMemberInfo> CachedMemberInfoSP;
+typedef std::shared_ptr<SwiftEnumDescriptor> SwiftEnumDescriptorSP;
+typedef llvm::DenseMap<lldb::opaque_compiler_type_t, CachedMemberInfoSP>
+    MemberInfoCache;
+typedef llvm::DenseMap<lldb::opaque_compiler_type_t, SwiftEnumDescriptorSP>
+    EnumInfoCache;
+typedef std::shared_ptr<MemberInfoCache> MemberInfoCacheSP;
+typedef std::shared_ptr<EnumInfoCache> EnumInfoCacheSP;
+typedef llvm::DenseMap<const swift::ASTContext *, MemberInfoCacheSP>
+    ASTMemberInfoCacheMap;
+typedef llvm::DenseMap<const swift::ASTContext *, EnumInfoCacheSP>
+    ASTEnumInfoCacheMap;
+
+static MemberInfoCache *GetMemberInfoCache(const swift::ASTContext *a) {
+  static ASTMemberInfoCacheMap g_cache;
+  static std::mutex g_mutex;
+  std::lock_guard<std::mutex> locker(g_mutex);
+  ASTMemberInfoCacheMap::iterator pos = g_cache.find(a);
+  if (pos == g_cache.end()) {
+    g_cache.insert(std::make_pair(
+        a, std::shared_ptr<MemberInfoCache>(new MemberInfoCache())));
+    return g_cache.find(a)->second.get();
+  }
+  return pos->second.get();
+}
+
+static EnumInfoCache *GetEnumInfoCache(const swift::ASTContext *a) {
+  static ASTEnumInfoCacheMap g_cache;
+  static std::mutex g_mutex;
+  std::lock_guard<std::mutex> locker(g_mutex);
+  ASTEnumInfoCacheMap::iterator pos = g_cache.find(a);
+  if (pos == g_cache.end()) {
+    g_cache.insert(
+        std::make_pair(a, std::shared_ptr<EnumInfoCache>(new EnumInfoCache())));
+    return g_cache.find(a)->second.get();
+  }
+  return pos->second.get();
+}
+
+namespace {
+bool IsDirectory(const FileSpec &spec) {
+  return llvm::sys::fs::is_directory(spec.GetPath());
+}
+bool IsRegularFile(const FileSpec &spec) {
+  return llvm::sys::fs::is_regular_file(spec.GetPath());
+}
+} // namespace
+
+llvm::LLVMContext &SwiftASTContext::GetGlobalLLVMContext() {
+  // TODO check with Sean.  Do we really want this to be static across
+  // an LLDB managing multiple Swift processes?
+  static llvm::LLVMContext s_global_context;
+  return s_global_context;
+}
+
+CachedMemberInfo *SwiftASTContext::GetCachedMemberInfo(void *type) {
+  VALID_OR_RETURN(nullptr);
+
+  if (type) {
+    // printf("CompilerType::GetCachedMemberInfo () for %s...",
+    // GetTypeName().c_str());
+    bool is_class = false;
+    bool is_protocol = false;
+    MemberInfoCache *member_info_cache = GetMemberInfoCache(GetASTContext());
+    MemberInfoCache::const_iterator pos = member_info_cache->find(type);
+    if (pos != member_info_cache->end()) {
+      // printf("cached: %p\n", pos->second.get());
+      return pos->second.get();
+    }
+
+    CachedMemberInfoSP member_infos_sp(new CachedMemberInfo());
+    // printf("creating in %p\n", member_infos_sp.get());
+
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    std::vector<const swift::irgen::TypeInfo *> field_type_infos;
+    swift::irgen::LayoutStrategy layout_strategy =
+        swift::irgen::LayoutStrategy::Optimal;
+
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::Error:
+    case swift::TypeKind::BuiltinInteger:
+    case swift::TypeKind::BuiltinFloat:
+    case swift::TypeKind::BuiltinRawPointer:
+    case swift::TypeKind::BuiltinBridgeObject:
+    case swift::TypeKind::BuiltinNativeObject:
+    case swift::TypeKind::BuiltinUnsafeValueBuffer:
+    case swift::TypeKind::BuiltinUnknownObject:
+    case swift::TypeKind::BuiltinVector:
+    case swift::TypeKind::UnownedStorage:
+    case swift::TypeKind::WeakStorage:
+    case swift::TypeKind::UnmanagedStorage:
+    case swift::TypeKind::GenericTypeParam:
+    case swift::TypeKind::DependentMember:
+    case swift::TypeKind::Metatype:
+    case swift::TypeKind::Module:
+    case swift::TypeKind::Function:
+    case swift::TypeKind::GenericFunction:
+    case swift::TypeKind::LValue:
+    case swift::TypeKind::UnboundGeneric:
+    case swift::TypeKind::Enum:
+    case swift::TypeKind::BoundGenericEnum:
+    case swift::TypeKind::ExistentialMetatype:
+    case swift::TypeKind::DynamicSelf:
+    case swift::TypeKind::SILBox:
+    case swift::TypeKind::SILFunction:
+    case swift::TypeKind::SILBlockStorage:
+    case swift::TypeKind::InOut:
+    case swift::TypeKind::Unresolved:
+      assert(false &&
+             "Caller must only call this function with valid type_kind");
+      break;
+
+    case swift::TypeKind::Tuple: {
+      layout_strategy = swift::irgen::LayoutStrategy::Universal;
+
+      swift::TupleType *tuple_type = swift_can_type->castTo<swift::TupleType>();
+      for (auto tuple_field : tuple_type->getElements()) {
+        MemberInfo member_info(MemberType::Field);
+        member_info.clang_type =
+            CompilerType(GetASTContext(), tuple_field.getType().getPointer());
+        member_info.byte_size = member_info.clang_type.GetByteSize(nullptr);
+
+        const char *tuple_name = tuple_field.getName().get();
+        if (tuple_name) {
+          member_info.name.SetCString(tuple_name);
+        } else {
+          StreamString tuple_name_strm;
+          tuple_name_strm.Printf(
+              "%u", (uint32_t)member_infos_sp->member_infos.size());
+          member_info.name.SetCString(tuple_name_strm.GetString().data());
+        }
+
+        field_type_infos.push_back(
+            GetSwiftTypeInfo(member_info.clang_type.GetOpaqueQualType()));
+        assert(field_type_infos.back() != nullptr);
+        member_infos_sp->member_infos.push_back(member_info);
+      }
+    } break;
+
+    case swift::TypeKind::Protocol:
+    case swift::TypeKind::ProtocolComposition: {
+      ProtocolInfo protocol_info;
+      if (!GetProtocolTypeInfo(
+              CompilerType(GetASTContext(), GetSwiftType(type)), protocol_info))
+        break;
+      is_protocol = true;
+      uint32_t num_children = protocol_info.m_num_storage_words;
+
+      for (uint32_t idx = 0; idx < num_children; idx++) {
+        MemberInfo member_info(MemberType::Field);
+        member_info.clang_type = CompilerType(
+            GetASTContext(), GetASTContext()->TheRawPointerType.getPointer());
+        member_info.byte_size = member_info.clang_type.GetByteSize(nullptr);
+        member_info.byte_offset = idx * member_info.byte_size;
+        member_info.is_fragile = false;
+        StreamString child_name_stream;
+
+        // Opaque existentials have m_num_payload_words != 0.
+        if (idx < protocol_info.m_num_payload_words)
+          child_name_stream.Printf("payload_data_%u", idx);
+        else {
+          // After the payload, the first word is either the instance itself
+          // (for class or error existentials) or a metadata pointer
+          // (for opaque existentials).
+          //
+          // Class and opaque existentials have zero or more witness tables.
+          // Error existentials always store their witness table inline.
+          int l_idx = idx - protocol_info.m_num_payload_words;
+          if (l_idx == 0)
+            child_name_stream.Printf("instance_type");
+          else
+            child_name_stream.Printf("protocol_witness_%u", l_idx - 1);
+        }
+        member_info.name = ConstString(child_name_stream.GetData());
+        member_infos_sp->member_infos.push_back(member_info);
+      }
+    } break;
+
+    case swift::TypeKind::Struct:
+    case swift::TypeKind::Class:
+    case swift::TypeKind::BoundGenericStruct:
+    case swift::TypeKind::BoundGenericClass: {
+      auto t_decl = swift_can_type.getAnyNominal();
+      auto class_decl = swift::dyn_cast<swift::ClassDecl>(t_decl);
+      if (class_decl) {
+        is_class = true;
+        swift::Type superclass_type(swift_can_type->getSuperclass());
+        if (superclass_type) {
+          MemberInfo member_info(MemberType::BaseClass);
+          member_info.clang_type =
+              CompilerType(GetASTContext(), superclass_type.getPointer());
+          member_info.byte_size = member_info.clang_type.GetByteSize(nullptr);
+          // Showing somemodule.sometype<A> is confusing to the user because
+          // it will show the *unboud* archetype name even though the type
+          // is actually properly bound (or it should!) and since one cannot
+          // overload a class on the number of generic arguments,
+          // somemodule.sometype is just as unique.
+          member_info.name.SetCString(
+              member_info.clang_type.GetUnboundType().GetTypeName().AsCString(
+                  "<no type name>"));
+          field_type_infos.push_back(
+              GetSwiftTypeInfo(member_info.clang_type.GetOpaqueQualType()));
+          assert(field_type_infos.back() != nullptr);
+          member_infos_sp->member_infos.push_back(member_info);
+        }
+      }
+
+      for (auto decl : t_decl->getMembers()) {
+        // Find ivars that aren't properties
+        if (swift::isa<swift::VarDecl>(decl)) {
+          swift::VarDecl *var_decl = swift::cast<swift::VarDecl>(decl);
+          if (var_decl->hasStorage() && !var_decl->isStatic()) {
+            MemberInfo member_info(MemberType::Field);
+            swift::Type member_type = swift_can_type->getTypeOfMember(
+                t_decl->getModuleContext(), var_decl, nullptr);
+            member_info.clang_type =
+                CompilerType(GetASTContext(), member_type.getPointer());
+            member_info.byte_size = member_info.clang_type.GetByteSize(nullptr);
+            member_info.is_fragile =
+                is_class; // Class fields are all fragile...
+            const char *child_name_cstr = var_decl->getName().get();
+            if (child_name_cstr)
+              member_info.name.SetCString(child_name_cstr);
+            field_type_infos.push_back(
+                GetSwiftTypeInfo(member_info.clang_type.GetOpaqueQualType()));
+            assert(field_type_infos.back() != nullptr);
+            member_infos_sp->member_infos.push_back(member_info);
+          }
+        }
+      }
+    } break;
+
+    case swift::TypeKind::TypeVariable:
+    case swift::TypeKind::Archetype:
+      break;
+
+    case swift::TypeKind::Optional:
+    case swift::TypeKind::ImplicitlyUnwrappedOptional:
+    case swift::TypeKind::NameAlias:
+    case swift::TypeKind::Paren:
+    case swift::TypeKind::Dictionary:
+    case swift::TypeKind::ArraySlice:
+      assert(false && "Not a canonical type");
+      break;
+    }
+    if (!member_infos_sp->member_infos.empty()) {
+      if (is_class) {
+        // If we have a class, then all offsets are fragile so we don't need to
+        // do layout since we will need to lookup the ivar offset symbol, or
+        // munge the runtime data to find the offsets.
+      } else if (!is_protocol) {
+        // Only do struct layout if we don't have a union since the only thing
+        // we need layout for currently is for the byte offset and the byte
+        // offset of everything in a union is zero.
+        // As for protocols, their fields are artificially generated from what a
+        // protocol_container contains in the Swift runtime itself, and it's
+        // just pointers, so no need to get fancy.
+        swift::irgen::StructLayout layout(
+            GetIRGenModule(), swift_can_type,
+            swift::irgen::LayoutKind::NonHeapObject, layout_strategy,
+            field_type_infos);
+
+        const size_t num_elements = layout.getElements().size();
+        assert(num_elements == member_infos_sp->member_infos.size());
+        for (int ii = 0; ii < num_elements; ++ii) {
+          auto element = layout.getElements()[ii];
+          // check or crash
+          if (element.getKind() == swift::irgen::ElementLayout::Kind::Fixed)
+            member_infos_sp->member_infos[ii].byte_offset =
+                element.getByteOffset().getValue();
+          else
+            member_infos_sp->member_infos[ii].byte_offset =
+                0; // TODO: dynamic layout
+                   // member_infos_sp->member_infos[ii].Dump(ii);
+        }
+      }
+      member_info_cache->insert(std::make_pair(type, member_infos_sp));
+      return member_infos_sp.get();
+    }
+  }
+  return nullptr;
+}
+
+class SwiftEnumDescriptor {
+public:
+  enum class Kind {
+    Empty,      // no cases in this enum
+    CStyle,     // no cases have payloads
+    AllPayload, // all cases have payloads
+    Mixed       // some cases have payloads
+  };
+
+  struct ElementInfo {
+    lldb_private::ConstString name;
+    CompilerType payload_type;
+    bool has_payload : 1;
+    bool is_indirect : 1;
+  };
+
+  Kind GetKind() const { return m_kind; }
+
+  ConstString GetTypeName() { return m_type_name; }
+
+  virtual ElementInfo *
+  GetElementFromData(const lldb_private::DataExtractor &data) = 0;
+
+  virtual size_t GetNumElements() {
+    return GetNumElementsWithPayload() + GetNumCStyleElements();
+  }
+
+  virtual size_t GetNumElementsWithPayload() = 0;
+
+  virtual size_t GetNumCStyleElements() = 0;
+
+  virtual ElementInfo *GetElementWithPayloadAtIndex(size_t idx) = 0;
+
+  virtual ElementInfo *GetElementWithNoPayloadAtIndex(size_t idx) = 0;
+
+  virtual ~SwiftEnumDescriptor() = default;
+
+  static SwiftEnumDescriptor *CreateDescriptor(swift::ASTContext *ast,
+                                               swift::CanType swift_can_type,
+                                               swift::EnumDecl *enum_decl);
+
+protected:
+  SwiftEnumDescriptor(swift::ASTContext *ast, swift::CanType swift_can_type,
+                      swift::EnumDecl *enum_decl, SwiftEnumDescriptor::Kind k)
+      : m_kind(k), m_type_name() {
+    if (swift_can_type.getPointer()) {
+      if (auto nominal = swift_can_type->getAnyNominal()) {
+        swift::Identifier name(nominal->getName());
+        if (name.get())
+          m_type_name.SetCString(name.get());
+      }
+    }
+  }
+
+private:
+  Kind m_kind;
+  ConstString m_type_name;
+};
+
+class SwiftEmptyEnumDescriptor : public SwiftEnumDescriptor {
+public:
+  SwiftEmptyEnumDescriptor(swift::ASTContext *ast,
+                           swift::CanType swift_can_type,
+                           swift::EnumDecl *enum_decl)
+      : SwiftEnumDescriptor(ast, swift_can_type, enum_decl,
+                            SwiftEnumDescriptor::Kind::Empty) {}
+
+  virtual ElementInfo *
+  GetElementFromData(const lldb_private::DataExtractor &data) {
+    return nullptr;
+  }
+
+  virtual size_t GetNumElementsWithPayload() { return 0; }
+
+  virtual size_t GetNumCStyleElements() { return 0; }
+
+  virtual ElementInfo *GetElementWithPayloadAtIndex(size_t idx) {
+    return nullptr;
+  }
+
+  virtual ElementInfo *GetElementWithNoPayloadAtIndex(size_t idx) {
+    return nullptr;
+  }
+
+  static bool classof(const SwiftEnumDescriptor *S) {
+    return S->GetKind() == SwiftEnumDescriptor::Kind::Empty;
+  }
+
+  virtual ~SwiftEmptyEnumDescriptor() = default;
+};
+
+namespace std {
+template <> struct less<swift::ClusteredBitVector> {
+  bool operator()(const swift::ClusteredBitVector &lhs,
+                  const swift::ClusteredBitVector &rhs) const {
+    int iL = lhs.size() - 1;
+    int iR = rhs.size() - 1;
+    for (; iL >= 0 && iR >= 0; --iL, --iR) {
+      bool bL = lhs[iL];
+      bool bR = rhs[iR];
+      if (bL and not bR)
+        return false;
+      if (bR and not bL)
+        return true;
+    }
+    return false;
+  }
+};
+} // namespace std
+
+static std::string Dump(const swift::ClusteredBitVector &bit_vector) {
+  std::string buffer;
+  llvm::raw_string_ostream ostream(buffer);
+  for (size_t i = 0; i < bit_vector.size(); i++) {
+    if (bit_vector[i])
+      ostream << '1';
+    else
+      ostream << '0';
+    if ((i % 4) == 3)
+      ostream << ' ';
+  }
+  ostream.flush();
+  return buffer;
+}
+
+class SwiftCStyleEnumDescriptor : public SwiftEnumDescriptor {
+public:
+  SwiftCStyleEnumDescriptor(swift::ASTContext *ast,
+                            swift::CanType swift_can_type,
+                            swift::EnumDecl *enum_decl)
+      : SwiftEnumDescriptor(ast, swift_can_type, enum_decl,
+                            SwiftEnumDescriptor::Kind::CStyle),
+        m_nopayload_elems_bitmask(), m_elements(), m_element_indexes() {
+    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+    if (log)
+      log->Printf("doing C-style enum layout for %s",
+                  GetTypeName().AsCString());
+
+    SwiftASTContext *swift_ast_ctx = SwiftASTContext::GetSwiftASTContext(ast);
+    swift::irgen::IRGenModule &irgen_module = swift_ast_ctx->GetIRGenModule();
+    const swift::irgen::EnumImplStrategy &enum_impl_strategy =
+        swift::irgen::getEnumImplStrategy(irgen_module, swift_can_type);
+    llvm::ArrayRef<swift::irgen::EnumImplStrategy::Element>
+        elements_with_no_payload =
+            enum_impl_strategy.getElementsWithNoPayload();
+    const bool has_payload = false;
+    const bool is_indirect = false;
+    uint64_t case_counter = 0;
+    m_nopayload_elems_bitmask =
+        enum_impl_strategy.getBitMaskForNoPayloadElements();
+
+    if (log)
+      log->Printf("m_nopayload_elems_bitmask = %s",
+                  Dump(m_nopayload_elems_bitmask).c_str());
+
+    for (auto enum_case : elements_with_no_payload) {
+      ConstString case_name(enum_case.decl->getName().str().data());
+      swift::ClusteredBitVector case_value =
+          enum_impl_strategy.getBitPatternForNoPayloadElement(enum_case.decl);
+
+      if (log)
+        log->Printf("case_name = %s, unmasked value = %s",
+                    case_name.AsCString(), Dump(case_value).c_str());
+
+      case_value &= m_nopayload_elems_bitmask;
+
+      if (log)
+        log->Printf("case_name = %s, masked value = %s", case_name.AsCString(),
+                    Dump(case_value).c_str());
+
+      std::unique_ptr<ElementInfo> elem_info(
+          new ElementInfo{case_name, CompilerType(), has_payload, is_indirect});
+      m_element_indexes.emplace(case_counter, elem_info.get());
+      case_counter++;
+      m_elements.emplace(case_value, std::move(elem_info));
+    }
+  }
+
+  virtual ElementInfo *
+  GetElementFromData(const lldb_private::DataExtractor &data) {
+    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+    if (log)
+      log->Printf(
+          "C-style enum - inspecting data to find enum case for type %s",
+          GetTypeName().AsCString());
+
+    swift::ClusteredBitVector current_payload;
+    lldb::offset_t offset = 0;
+    for (size_t idx = 0; idx < data.GetByteSize(); idx++) {
+      uint64_t byte = data.GetU8(&offset);
+      current_payload.add(8, byte);
+    }
+
+    if (log) {
+      log->Printf("m_nopayload_elems_bitmask        = %s",
+                  Dump(m_nopayload_elems_bitmask).c_str());
+      log->Printf("current_payload                  = %s",
+                  Dump(current_payload).c_str());
+    }
+
+    if (current_payload.size() != m_nopayload_elems_bitmask.size()) {
+      if (log)
+        log->Printf("sizes don't match; getting out with an error");
+      return nullptr;
+    }
+
+    current_payload &= m_nopayload_elems_bitmask;
+
+    if (log)
+      log->Printf("masked current_payload           = %s",
+                  Dump(current_payload).c_str());
+
+    auto iter = m_elements.find(current_payload), end = m_elements.end();
+    if (iter == end) {
+      if (log)
+        log->Printf("bitmask search failed");
+      return nullptr;
+    }
+    if (log)
+      log->Printf("bitmask search success - found case %s",
+                  iter->second.get()->name.AsCString());
+    return iter->second.get();
+  }
+
+  virtual size_t GetNumElementsWithPayload() { return 0; }
+
+  virtual size_t GetNumCStyleElements() { return m_elements.size(); }
+
+  virtual ElementInfo *GetElementWithPayloadAtIndex(size_t idx) {
+    return nullptr;
+  }
+
+  virtual ElementInfo *GetElementWithNoPayloadAtIndex(size_t idx) {
+    if (idx >= m_element_indexes.size())
+      return nullptr;
+    return m_element_indexes[idx];
+  }
+
+  static bool classof(const SwiftEnumDescriptor *S) {
+    return S->GetKind() == SwiftEnumDescriptor::Kind::CStyle;
+  }
+
+  virtual ~SwiftCStyleEnumDescriptor() = default;
+
+private:
+  swift::ClusteredBitVector m_nopayload_elems_bitmask;
+  std::map<swift::ClusteredBitVector, std::unique_ptr<ElementInfo>> m_elements;
+  std::map<uint64_t, ElementInfo *> m_element_indexes;
+};
+
+static CompilerType
+GetFunctionArgumentTuple(const CompilerType &compiler_type) {
+  if (compiler_type.IsValid() &&
+      llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem())) {
+    swift::CanType swift_can_type(
+        GetCanonicalSwiftType(compiler_type.GetOpaqueQualType()));
+    auto func = swift::dyn_cast_or_null<swift::AnyFunctionType>(swift_can_type);
+    if (func) {
+      auto input = func.getInput();
+      // See comment in swift::AnyFunctionType for rationale here:
+      // A function can take either a tuple or a parentype, but if a parentype
+      // (i.e. (Foo)), then it will be reduced down to just Foo, so if the input
+      // is not a tuple, that must mean there is only 1 input.
+      auto tuple = swift::dyn_cast<swift::TupleType>(input);
+      if (tuple)
+        return CompilerType(compiler_type.GetTypeSystem(), tuple);
+      else
+        return CompilerType(compiler_type.GetTypeSystem(), input.getPointer());
+    }
+  }
+  return CompilerType();
+}
+
+class SwiftAllPayloadEnumDescriptor : public SwiftEnumDescriptor {
+public:
+  SwiftAllPayloadEnumDescriptor(swift::ASTContext *ast,
+                                swift::CanType swift_can_type,
+                                swift::EnumDecl *enum_decl)
+      : SwiftEnumDescriptor(ast, swift_can_type, enum_decl,
+                            SwiftEnumDescriptor::Kind::AllPayload),
+        m_tag_bits(), m_elements() {
+    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+    if (log)
+      log->Printf("doing ADT-style enum layout for %s",
+                  GetTypeName().AsCString());
+
+    SwiftASTContext *swift_ast_ctx = SwiftASTContext::GetSwiftASTContext(ast);
+    swift::irgen::IRGenModule &irgen_module = swift_ast_ctx->GetIRGenModule();
+    const swift::irgen::EnumImplStrategy &enum_impl_strategy =
+        swift::irgen::getEnumImplStrategy(irgen_module, swift_can_type);
+    llvm::ArrayRef<swift::irgen::EnumImplStrategy::Element>
+        elements_with_payload = enum_impl_strategy.getElementsWithPayload();
+    m_tag_bits = enum_impl_strategy.getTagBitsForPayloads();
+
+    if (log)
+      log->Printf("tag_bits = %s", Dump(m_tag_bits).c_str());
+
+    auto module_ctx = enum_decl->getModuleContext();
+    const bool has_payload = true;
+    for (auto enum_case : elements_with_payload) {
+      ConstString case_name(enum_case.decl->getName().str().data());
+
+      swift::EnumElementDecl *case_decl = enum_case.decl;
+      assert(case_decl);
+      CompilerType case_type(
+          ast, swift_can_type->getTypeOfMember(module_ctx, case_decl, nullptr)
+                   .getPointer());
+      case_type = GetFunctionArgumentTuple(case_type.GetFunctionReturnType());
+
+      const bool is_indirect =
+          case_decl->isIndirect() || case_decl->getParentEnum()->isIndirect();
+
+      if (log)
+        log->Printf("case_name = %s, type = %s, is_indirect = %s",
+                    case_name.AsCString(), case_type.GetTypeName().AsCString(),
+                    is_indirect ? "yes" : "no");
+
+      std::unique_ptr<ElementInfo> elem_info(
+          new ElementInfo{case_name, case_type, has_payload, is_indirect});
+      m_elements.push_back(std::move(elem_info));
+    }
+  }
+
+  virtual ElementInfo *
+  GetElementFromData(const lldb_private::DataExtractor &data) {
+    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+    if (log)
+      log->Printf(
+          "ADT-style enum - inspecting data to find enum case for type %s",
+          GetTypeName().AsCString());
+
+    if (m_elements.size() == 0) // no elements, just fail
+    {
+      if (log)
+        log->Printf("enum with no cases. getting out");
+      return nullptr;
+    }
+    if (m_elements.size() == 1) // one element, so it's gotta be it
+    {
+      if (log)
+        log->Printf("enum with one case. getting out easy with %s",
+                    m_elements.front().get()->name.AsCString());
+
+      return m_elements.front().get();
+    }
+
+    swift::ClusteredBitVector current_payload;
+    lldb::offset_t offset = 0;
+    for (size_t idx = 0; idx < data.GetByteSize(); idx++) {
+      uint64_t byte = data.GetU8(&offset);
+      current_payload.add(8, byte);
+    }
+    if (log) {
+      log->Printf("tag_bits        = %s", Dump(m_tag_bits).c_str());
+      log->Printf("current_payload = %s", Dump(current_payload).c_str());
+    }
+
+    if (current_payload.size() != m_tag_bits.size()) {
+      if (log)
+        log->Printf("sizes don't match; getting out with an error");
+      return nullptr;
+    }
+
+    size_t discriminator = 0;
+    size_t power_of_2 = 1;
+    auto enumerator = m_tag_bits.enumerateSetBits();
+    for (llvm::Optional<size_t> next = enumerator.findNext(); next.hasValue();
+         next = enumerator.findNext()) {
+      discriminator =
+          discriminator + (current_payload[next.getValue()] ? power_of_2 : 0);
+      power_of_2 <<= 1;
+    }
+
+    if (discriminator >= m_elements.size()) // discriminator too large, get out
+    {
+      if (log)
+        log->Printf("discriminator value of %" PRIu64 " too large, getting out",
+                    (uint64_t)discriminator);
+      return nullptr;
+    } else {
+      auto ptr = m_elements[discriminator].get();
+      if (log) {
+        if (!ptr)
+          log->Printf("discriminator value of %" PRIu64
+                      " acceptable, but null case matched - that's bad",
+                      (uint64_t)discriminator);
+        else
+          log->Printf("discriminator value of %" PRIu64
+                      " acceptable, case %s matched",
+                      (uint64_t)discriminator, ptr->name.AsCString());
+      }
+      return ptr;
+    }
+  }
+
+  virtual size_t GetNumElementsWithPayload() { return m_elements.size(); }
+
+  virtual size_t GetNumCStyleElements() { return 0; }
+
+  virtual ElementInfo *GetElementWithPayloadAtIndex(size_t idx) {
+    if (idx >= m_elements.size())
+      return nullptr;
+    return m_elements[idx].get();
+  }
+
+  virtual ElementInfo *GetElementWithNoPayloadAtIndex(size_t idx) {
+    return nullptr;
+  }
+
+  static bool classof(const SwiftEnumDescriptor *S) {
+    return S->GetKind() == SwiftEnumDescriptor::Kind::AllPayload;
+  }
+
+  virtual ~SwiftAllPayloadEnumDescriptor() = default;
+
+private:
+  swift::ClusteredBitVector m_tag_bits;
+  std::vector<std::unique_ptr<ElementInfo>> m_elements;
+};
+
+class SwiftMixedEnumDescriptor : public SwiftEnumDescriptor {
+public:
+  SwiftMixedEnumDescriptor(swift::ASTContext *ast,
+                           swift::CanType swift_can_type,
+                           swift::EnumDecl *enum_decl)
+      : SwiftEnumDescriptor(ast, swift_can_type, enum_decl,
+                            SwiftEnumDescriptor::Kind::Mixed),
+        m_non_payload_cases(ast, swift_can_type, enum_decl),
+        m_payload_cases(ast, swift_can_type, enum_decl) {}
+
+  virtual ElementInfo *
+  GetElementFromData(const lldb_private::DataExtractor &data) {
+    ElementInfo *elem_info = m_non_payload_cases.GetElementFromData(data);
+    return elem_info ? elem_info : m_payload_cases.GetElementFromData(data);
+  }
+
+  static bool classof(const SwiftEnumDescriptor *S) {
+    return S->GetKind() == SwiftEnumDescriptor::Kind::Mixed;
+  }
+
+  virtual size_t GetNumElementsWithPayload() {
+    return m_payload_cases.GetNumElementsWithPayload();
+  }
+
+  virtual size_t GetNumCStyleElements() {
+    return m_non_payload_cases.GetNumCStyleElements();
+  }
+
+  virtual ElementInfo *GetElementWithPayloadAtIndex(size_t idx) {
+    return m_payload_cases.GetElementWithPayloadAtIndex(idx);
+  }
+
+  virtual ElementInfo *GetElementWithNoPayloadAtIndex(size_t idx) {
+    return m_non_payload_cases.GetElementWithNoPayloadAtIndex(idx);
+  }
+
+  virtual ~SwiftMixedEnumDescriptor() = default;
+
+private:
+  SwiftCStyleEnumDescriptor m_non_payload_cases;
+  SwiftAllPayloadEnumDescriptor m_payload_cases;
+};
+
+SwiftEnumDescriptor *
+SwiftEnumDescriptor::CreateDescriptor(swift::ASTContext *ast,
+                                      swift::CanType swift_can_type,
+                                      swift::EnumDecl *enum_decl) {
+  assert(ast);
+  assert(enum_decl);
+  assert(swift_can_type.getPointer());
+  SwiftASTContext *swift_ast_ctx = SwiftASTContext::GetSwiftASTContext(ast);
+  assert(swift_ast_ctx);
+  if (enum_decl == ast->getImplicitlyUnwrappedOptionalDecl()) {
+    swift::EnumDecl *optional_decl = ast->getOptionalDecl();
+    swift::CanType bound_optional_can_type =
+        swift::BoundGenericType::get(
+            optional_decl, swift::Type(),
+            swift::cast<swift::BoundGenericType>(swift_can_type)
+                ->getGenericArgs())
+            ->getCanonicalType();
+    return CreateDescriptor(ast, bound_optional_can_type, optional_decl);
+  }
+  swift::irgen::IRGenModule &irgen_module = swift_ast_ctx->GetIRGenModule();
+  const swift::irgen::EnumImplStrategy &enum_impl_strategy =
+      swift::irgen::getEnumImplStrategy(irgen_module, swift_can_type);
+  llvm::ArrayRef<swift::irgen::EnumImplStrategy::Element>
+      elements_with_payload = enum_impl_strategy.getElementsWithPayload();
+  llvm::ArrayRef<swift::irgen::EnumImplStrategy::Element>
+      elements_with_no_payload = enum_impl_strategy.getElementsWithNoPayload();
+  if (elements_with_no_payload.size() == 0) {
+    // nothing with no payload.. empty or all payloads?
+    if (elements_with_payload.size() == 0)
+      return new SwiftEmptyEnumDescriptor(ast, swift_can_type, enum_decl);
+    else
+      return new SwiftAllPayloadEnumDescriptor(ast, swift_can_type, enum_decl);
+  } else {
+    // something with no payload.. mixed or C-style?
+    if (elements_with_payload.size() == 0)
+      return new SwiftCStyleEnumDescriptor(ast, swift_can_type, enum_decl);
+    else
+      return new SwiftMixedEnumDescriptor(ast, swift_can_type, enum_decl);
+  }
+}
+
+static SwiftEnumDescriptor *
+GetEnumInfoFromEnumDecl(swift::ASTContext *ast, swift::CanType swift_can_type,
+                        swift::EnumDecl *enum_decl) {
+  return SwiftEnumDescriptor::CreateDescriptor(ast, swift_can_type, enum_decl);
+}
+
+SwiftEnumDescriptor *SwiftASTContext::GetCachedEnumInfo(void *type) {
+  VALID_OR_RETURN(nullptr);
+
+  if (type) {
+    EnumInfoCache *enum_info_cache = GetEnumInfoCache(GetASTContext());
+    EnumInfoCache::const_iterator pos = enum_info_cache->find(type);
+    if (pos != enum_info_cache->end())
+      return pos->second.get();
+
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    if (!SwiftASTContext::IsFullyRealized(
+            CompilerType(GetASTContext(), swift_can_type)))
+      return nullptr;
+
+    SwiftEnumDescriptorSP enum_info_sp;
+
+    if (auto *enum_type = swift_can_type->getAs<swift::EnumType>()) {
+      enum_info_sp.reset(GetEnumInfoFromEnumDecl(
+          GetASTContext(), swift_can_type, enum_type->getDecl()));
+    } else if (auto *bound_enum_type =
+                   swift_can_type->getAs<swift::BoundGenericEnumType>()) {
+      enum_info_sp.reset(GetEnumInfoFromEnumDecl(
+          GetASTContext(), swift_can_type, bound_enum_type->getDecl()));
+    }
+
+    if (enum_info_sp.get())
+      enum_info_cache->insert(std::make_pair(type, enum_info_sp));
+    return enum_info_sp.get();
+  }
+  return nullptr;
+}
+
+namespace {
+static inline bool
+SwiftASTContextSupportsLanguage(lldb::LanguageType language) {
+  return language == eLanguageTypeSwift;
+}
+
+static bool IsDeviceSupport(const char *path) {
+  // The old-style check, which we preserve for safety.
+  if (path && strstr(path, "iOS DeviceSupport"))
+    return true;
+
+  // The new-style check, which should cover more devices.
+  if (path)
+    if (const char *Developer_Xcode = strstr(path, "Developer"))
+      if (const char *DeviceSupport = strstr(Developer_Xcode, "DeviceSupport"))
+        if (strstr(DeviceSupport, "Symbols"))
+          return true;
+
+  return false;
+}
+} // namespace
+
+SwiftASTContext::SwiftASTContext(const char *triple, Target *target)
+    : TypeSystem(TypeSystem::eKindSwift), m_source_manager_ap(),
+      m_diagnostic_engine_ap(), m_ast_context_ap(), m_ir_gen_module_ap(),
+      m_compiler_invocation_ap(new swift::CompilerInvocation()),
+      m_dwarf_ast_parser_ap(), m_scratch_module(NULL), m_sil_module_ap(),
+      m_serialized_module_loader(NULL), m_clang_importer(NULL),
+      m_swift_module_cache(), m_mangled_name_to_type_map(),
+      m_type_to_mangled_name_map(), m_pointer_byte_size(0),
+      m_pointer_bit_align(0), m_void_function_type(), m_target_wp(),
+      m_process(NULL), m_platform_sdk_path(), m_resource_dir(),
+      m_ast_file_data_map(), m_initialized_language_options(false),
+      m_initialized_search_path_options(false),
+      m_initialized_clang_importer_options(false),
+      m_reported_fatal_error(false), m_fatal_errors(), m_negative_type_cache(),
+      m_extra_type_info_cache(), m_swift_type_map() {
+  // Set the module-cache path if it has been specified:
+  if (target) {
+    FileSpec &module_cache = target->GetModuleCachePath();
+    if (module_cache && module_cache.Exists()) {
+
+      std::string module_cache_path = module_cache.GetPath();
+      llvm::StringRef module_cache_ref(module_cache_path);
+      m_compiler_invocation_ap->setClangModuleCachePath(module_cache_ref);
+    }
+    m_target_wp = target->shared_from_this();
+  }
+
+  if (triple)
+    SetTriple(triple);
+  swift::IRGenOptions &ir_gen_opts =
+      m_compiler_invocation_ap->getIRGenOptions();
+  ir_gen_opts.OutputKind = swift::IRGenOutputKind::Module;
+  ir_gen_opts.UseJIT = true;
+  ir_gen_opts.DWARFVersion = swift::DWARFVersion;
+}
+
+SwiftASTContext::SwiftASTContext(const SwiftASTContext &rhs)
+    : TypeSystem(rhs.getKind()), m_source_manager_ap(),
+      m_diagnostic_engine_ap(), m_ast_context_ap(), m_ir_gen_module_ap(),
+      m_compiler_invocation_ap(new swift::CompilerInvocation()),
+      m_dwarf_ast_parser_ap(), m_scratch_module(NULL), m_sil_module_ap(),
+      m_serialized_module_loader(NULL), m_clang_importer(NULL),
+      m_swift_module_cache(), m_mangled_name_to_type_map(),
+      m_type_to_mangled_name_map(), m_pointer_byte_size(0),
+      m_pointer_bit_align(0), m_void_function_type(), m_target_wp(),
+      m_process(NULL), m_platform_sdk_path(), m_resource_dir(),
+      m_ast_file_data_map(), m_initialized_language_options(false),
+      m_initialized_search_path_options(false),
+      m_initialized_clang_importer_options(false),
+      m_reported_fatal_error(false), m_fatal_errors(), m_negative_type_cache(),
+      m_extra_type_info_cache(), m_swift_type_map() {
+  if (rhs.m_compiler_invocation_ap) {
+    std::string rhs_triple = rhs.GetTriple();
+    if (!rhs_triple.empty()) {
+      SetTriple(rhs_triple.c_str());
+    }
+    llvm::StringRef module_cache_path =
+        rhs.m_compiler_invocation_ap->getClangModuleCachePath();
+    if (!module_cache_path.empty())
+      m_compiler_invocation_ap->setClangModuleCachePath(module_cache_path);
+  }
+
+  swift::IRGenOptions &ir_gen_opts =
+      m_compiler_invocation_ap->getIRGenOptions();
+  ir_gen_opts.OutputKind = swift::IRGenOutputKind::Module;
+  ir_gen_opts.UseJIT = true;
+
+  TargetSP target_sp = rhs.m_target_wp.lock();
+  if (target_sp)
+    m_target_wp = target_sp;
+
+  m_platform_sdk_path = rhs.m_platform_sdk_path;
+  m_resource_dir = rhs.m_resource_dir;
+
+  swift::ASTContext *lhs_ast = GetASTContext();
+  swift::ASTContext *rhs_ast =
+      const_cast<SwiftASTContext &>(rhs).GetASTContext();
+
+  if (lhs_ast && rhs_ast) {
+    lhs_ast->SearchPathOpts = rhs_ast->SearchPathOpts;
+  }
+  GetClangImporter();
+}
+
+SwiftASTContext::~SwiftASTContext() {
+  if (m_ast_context_ap.get()) {
+    GetASTMap().Erase(m_ast_context_ap.get());
+  }
+}
+
+ConstString SwiftASTContext::GetPluginNameStatic() {
+  return ConstString("swift");
+}
+
+ConstString SwiftASTContext::GetPluginName() {
+  return ClangASTContext::GetPluginNameStatic();
+}
+
+uint32_t SwiftASTContext::GetPluginVersion() { return 1; }
+
+static std::string &GetDefaultResourceDir() {
+  static std::string s_resource_dir;
+  return s_resource_dir;
+}
+
+lldb::TypeSystemSP SwiftASTContext::CreateInstance(lldb::LanguageType language,
+                                                   Module *module,
+                                                   Target *target,
+                                                   const char *extra_options) {
+  if (SwiftASTContextSupportsLanguage(language)) {
+    ArchSpec arch;
+    if (module) {
+      arch = module->GetArchitecture();
+
+      ObjectFile *objfile = module->GetObjectFile();
+      ArchSpec object_arch;
+
+      if (!objfile || !objfile->GetArchitecture(object_arch))
+        return TypeSystemSP();
+
+      lldb::CompUnitSP main_compile_unit_sp = module->GetCompileUnitAtIndex(0);
+
+      Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+      if (main_compile_unit_sp && !main_compile_unit_sp->Exists()) {
+        if (log) {
+          StreamString ss;
+          module->GetDescription(&ss);
+
+          log->Printf("Corresponding source not found for %s, loading module "
+                      "%s is unlikely to succeed",
+                      main_compile_unit_sp->GetCString(), ss.GetData());
+        }
+      }
+
+      std::shared_ptr<SwiftASTContext> swift_ast_sp(new SwiftASTContext());
+
+      swift_ast_sp->GetLanguageOptions().DebuggerSupport = true;
+      swift_ast_sp->GetLanguageOptions().EnableAccessControl = false;
+
+      if (!arch.IsValid())
+        return TypeSystemSP();
+
+      llvm::Triple triple = arch.GetTriple();
+
+      if (triple.getOS() == llvm::Triple::UnknownOS) {
+      // cl_kernels are the only binaries that don't have an LC_MIN_VERSION_xxx
+      // load command. This avoids a Swift assertion.
+
+#if defined(__APPLE__)
+        switch (triple.getArch()) {
+        default:
+          triple.setOS(llvm::Triple::MacOSX);
+          break;
+        case llvm::Triple::arm:
+        case llvm::Triple::armeb:
+        case llvm::Triple::aarch64:
+        case llvm::Triple::aarch64_be:
+          triple.setOS(llvm::Triple::IOS);
+          break;
+        }
+
+#else
+        // Not an elegant hack on OS X, not an elegant hack elsewhere.
+        // But we shouldn't be claiming things are Mac binaries when they are
+        // not.
+        triple.setOS(HostInfo::GetArchitecture().GetTriple().getOS());
+#endif
+      }
+
+      swift_ast_sp->SetTriple(triple.getTriple().c_str(), module);
+
+      bool set_triple = false;
+
+      SymbolVendor *sym_vendor = module->GetSymbolVendor();
+
+      std::string resource_dir;
+      std::string target_triple;
+
+      if (sym_vendor) {
+        // Use the new loadFromSerializedAST if possible:
+
+        auto ast_file_datas = sym_vendor->GetASTData(eLanguageTypeSwift);
+
+        bool got_serialized_options = false;
+        DataBufferSP ast_file_data_sp;
+        if (!ast_file_datas.empty() &&
+            ((ast_file_data_sp = ast_file_datas.front()) != nullptr)) {
+          if (log)
+            log->Printf("Found %d AST file data entries for library: %s.",
+                        (int)ast_file_datas.size(),
+                        module->GetSpecificationDescription().c_str());
+
+          // Retrieve the first serialized AST data blob and initialize
+          // the compiler invocation with it.
+          llvm::StringRef section_data_ref(
+              (const char *)ast_file_data_sp->GetBytes(),
+              ast_file_data_sp->GetByteSize());
+          auto result =
+              swift_ast_sp->GetCompilerInvocation().loadFromSerializedAST(
+                  section_data_ref);
+
+          switch (result) {
+          case swift::serialization::Status::Valid:
+            got_serialized_options = true;
+            break;
+
+          case swift::serialization::Status::FormatTooOld:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file format is too old to be used by the "
+                "version of the swift compiler in LLDB");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::FormatTooNew:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file format is too new to be used by this "
+                "version of the swift compiler in LLDB");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::MissingDependency:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file depends on another module that can't be "
+                "loaded");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::MissingShadowedModule:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file is an overlay for a clang module, which "
+                "can't be found");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::FailedToLoadBridgingHeader:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file depends on a bridging header that can't "
+                "be loaded");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::Malformed:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file is malformed");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::MalformedDocumentation:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module documentation file is malformed in some way");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::NameMismatch:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file's name does not match the module it is "
+                "being loaded into");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::TargetIncompatible:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file was built for a different target "
+                "platform");
+            return swift_ast_sp;
+
+          case swift::serialization::Status::TargetTooNew:
+            swift_ast_sp->m_fatal_errors.SetErrorString(
+                "the swift module file was built for a target newer than the "
+                "current target");
+            return swift_ast_sp;
+          }
+        }
+
+        // TODO: make sure we only get options for Swift files.
+        // We really should be passing down a language enumeration into
+        // sym_vendor->GetCompileOption() so we don't get compiler options
+        // for a C/C++ file...
+
+        if (got_serialized_options) {
+          // Some of the bits in the compiler options we keep separately, so we
+          // need to populate them from the serialized options:
+          llvm::StringRef serialized_triple =
+              swift_ast_sp->GetCompilerInvocation().getTargetTriple();
+          if (serialized_triple.empty()) {
+            if (log)
+              log->Printf("\tSerialized triple for %s was empty.",
+                          module->GetSpecificationDescription().c_str());
+          } else {
+            if (log)
+              log->Printf("\tFound serialized triple for %s: %s.",
+                          module->GetSpecificationDescription().c_str(),
+                          serialized_triple.data());
+            swift_ast_sp->SetTriple(serialized_triple.data(), module);
+            set_triple = true;
+          }
+
+          llvm::StringRef serialized_sdk_path =
+              swift_ast_sp->GetCompilerInvocation().getSDKPath();
+          if (serialized_sdk_path.empty()) {
+            if (log)
+              log->Printf("\tNo serialized SDK path.");
+          } else {
+            if (log)
+              log->Printf("\tGot serialized SDK path %s.",
+                          serialized_sdk_path.data());
+            FileSpec sdk_spec(serialized_sdk_path.data(), false);
+            if (sdk_spec.Exists()) {
+              swift_ast_sp->SetPlatformSDKPath(serialized_sdk_path.data());
+            }
+          }
+        }
+
+        if (!got_serialized_options || !swift_ast_sp->GetPlatformSDKPath()) {
+          std::string platform_sdk_path;
+          if (sym_vendor->GetCompileOption("-sdk", platform_sdk_path)) {
+            FileSpec sdk_spec(platform_sdk_path.c_str(), false);
+            if (sdk_spec.Exists()) {
+              swift_ast_sp->SetPlatformSDKPath(platform_sdk_path.c_str());
+            }
+
+            if (sym_vendor->GetCompileOption("-target", target_triple)) {
+              llvm::StringRef parsed_triple(target_triple);
+
+              swift_ast_sp->SetTriple(target_triple.c_str(), module);
+              set_triple = true;
+            }
+          }
+        }
+
+        if (sym_vendor->GetCompileOption("-resource-dir", resource_dir)) {
+          swift_ast_sp->SetResourceDir(resource_dir.c_str());
+        } else if (!GetDefaultResourceDir().empty()) {
+          // Use the first resource dir we found when setting up a target.
+          swift_ast_sp->SetResourceDir(GetDefaultResourceDir().c_str());
+        } else {
+          if (log)
+            log->Printf(
+                "No resource dir available for module's SwiftASTContext.");
+        }
+
+        if (!got_serialized_options) {
+
+          std::vector<std::string> framework_search_paths;
+
+          if (sym_vendor->GetCompileOptions("-F", framework_search_paths)) {
+            for (std::string &search_path : framework_search_paths) {
+              swift_ast_sp->AddFrameworkSearchPath(search_path.c_str());
+            }
+          }
+
+          std::vector<std::string> include_paths;
+
+          if (sym_vendor->GetCompileOptions("-I", include_paths)) {
+            for (std::string &search_path : include_paths) {
+              const FileSpec path_spec(search_path.c_str(), false);
+
+              if (path_spec.Exists()) {
+                static const ConstString s_hmap_extension("hmap");
+
+                if (IsDirectory(path_spec)) {
+                  swift_ast_sp->AddModuleSearchPath(search_path.c_str());
+                } else if (IsRegularFile(path_spec) &&
+                           path_spec.GetFileNameExtension() ==
+                               s_hmap_extension) {
+                  std::string argument("-I");
+                  argument.append(search_path);
+                  swift_ast_sp->AddClangArgument(argument.c_str());
+                }
+              }
+            }
+          }
+
+          std::vector<std::string> cc_options;
+
+          if (sym_vendor->GetCompileOptions("-Xcc", cc_options)) {
+            for (int i = 0; i < cc_options.size(); ++i) {
+              if (!cc_options[i].compare("-iquote") &&
+                  i + 1 < cc_options.size()) {
+                swift_ast_sp->AddClangArgumentPair("-iquote",
+                                                   cc_options[i + 1].c_str());
+              }
+            }
+          }
+        }
+
+        FileSpecList loaded_modules;
+
+        sym_vendor->GetLoadedModules(lldb::eLanguageTypeSwift, loaded_modules);
+
+        for (size_t mi = 0, me = loaded_modules.GetSize(); mi != me; ++mi) {
+          const FileSpec &loaded_module = loaded_modules.GetFileSpecAtIndex(mi);
+
+          if (loaded_module.Exists())
+            swift_ast_sp->AddModuleSearchPath(
+                loaded_module.GetDirectory().GetCString());
+        }
+      }
+
+      if (!set_triple) {
+        llvm::Triple llvm_triple(swift_ast_sp->GetTriple());
+
+        // LLVM wants this to be set to iOS or MacOSX; if we're working on
+        // a bare-boards type image, change the triple for LLVM's benefit.
+        if (llvm_triple.getVendor() == llvm::Triple::Apple &&
+            llvm_triple.getOS() == llvm::Triple::UnknownOS) {
+          if (llvm_triple.getArch() == llvm::Triple::arm ||
+              llvm_triple.getArch() == llvm::Triple::thumb) {
+            llvm_triple.setOS(llvm::Triple::IOS);
+          } else {
+            llvm_triple.setOS(llvm::Triple::MacOSX);
+          }
+          swift_ast_sp->SetTriple(llvm_triple.str().c_str(), module);
+        }
+      }
+
+      if (!swift_ast_sp->GetClangImporter()) {
+        if (log) {
+          log->Printf(
+              "((Module*)%p) [%s]->GetSwiftASTContext() returning NULL "
+              "- couldn't create a ClangImporter",
+              module,
+              module->GetFileSpec().GetFilename().AsCString("<anonymous>"));
+        }
+
+        return TypeSystemSP();
+      }
+
+      std::vector<std::string> module_names;
+      swift_ast_sp->RegisterSectionModules(*module, module_names);
+      swift_ast_sp->ValidateSectionModules(*module, module_names);
+
+      if (log) {
+        log->Printf(
+            "((Module*)%p) [%s]->GetSwiftASTContext() = %p", module,
+            module->GetFileSpec().GetFilename().AsCString("<anonymous>"),
+            swift_ast_sp.get());
+        swift_ast_sp->DumpConfiguration(log);
+      }
+      return swift_ast_sp;
+    } else if (target) {
+      arch = target->GetArchitecture();
+
+      // Make an AST but don't set the triple yet. We need to try and detect
+      // if we have a iOS simulator...
+      std::shared_ptr<SwiftASTContextForExpressions> swift_ast_sp(
+          new SwiftASTContextForExpressions(*target));
+
+      if (!arch.IsValid())
+        return TypeSystemSP();
+
+      bool handled_sdk_path = false;
+      bool handled_resource_dir = false;
+      const size_t num_images = target->GetImages().GetSize();
+      // Set the SDK path and resource dir prior to doing search paths.
+      // Otherwise when we create search path options we put in the wrong SDK
+      // path.
+
+      FileSpec &target_sdk_spec = target->GetSDKPath();
+      if (target_sdk_spec && target_sdk_spec.Exists()) {
+        std::string platform_sdk_path(target_sdk_spec.GetPath());
+        swift_ast_sp->SetPlatformSDKPath(std::move(platform_sdk_path));
+        handled_sdk_path = true;
+      }
+
+      Status module_error;
+      for (size_t mi = 0; mi != num_images; ++mi) {
+        ModuleSP module_sp = target->GetImages().GetModuleAtIndex(mi);
+
+        SwiftASTContext *module_swift_ast =
+            llvm::dyn_cast_or_null<SwiftASTContext>(
+                module_sp->GetTypeSystemForLanguage(lldb::eLanguageTypeSwift));
+
+        if (!module_swift_ast || module_swift_ast->HasFatalErrors() ||
+            !module_swift_ast->GetClangImporter()) {
+          // Make sure we warn about this module load failure, the one that
+          // comes from loading types often gets swallowed up and not seen,
+          // this is the only reliable point where we can show this.
+          // But only do it once per UUID so we don't overwhelm the user with
+          // warnings...
+          std::unordered_set<std::string> m_swift_warnings_issued;
+
+          UUID module_uuid(module_sp->GetUUID());
+          std::pair<std::unordered_set<std::string>::iterator, bool> result(
+              m_swift_warnings_issued.insert(module_uuid.GetAsString()));
+          if (result.second) {
+            StreamString ss;
+            module_sp->GetDescription(&ss, eDescriptionLevelBrief);
+            target->GetDebugger().GetErrorFile()->Printf(
+                "warning: Swift error in module %s" /*": \n    %s\n"*/
+                ".\nDebug info from this module will be unavailable in the "
+                "debugger.\n\n",
+                ss.GetData());
+          }
+
+          continue;
+        }
+
+        if (!handled_sdk_path) {
+          const char *platform_sdk_path =
+              module_swift_ast->GetPlatformSDKPath();
+
+          if (platform_sdk_path) {
+            handled_sdk_path = true;
+            swift_ast_sp->SetPlatformSDKPath(platform_sdk_path);
+          }
+        }
+
+        if (!handled_resource_dir) {
+          const char *resource_dir = module_swift_ast->GetResourceDir();
+          if (resource_dir) {
+            handled_resource_dir = true;
+            swift_ast_sp->SetResourceDir(resource_dir);
+            if (GetDefaultResourceDir().empty()) {
+              // Tuck this away as a reasonable default resource dir
+              // for contexts that don't have one. The Swift parser
+              // will assert without one.
+              GetDefaultResourceDir() = resource_dir;
+            }
+          }
+        }
+
+        if (handled_sdk_path && handled_resource_dir)
+          break;
+      }
+
+      // First, prime the compiler with the options from the main executable:
+      bool read_options_from_ast = false;
+      ModuleSP exe_module_sp(target->GetExecutableModule());
+
+#ifdef __APPLE__
+      // If we're debugging a testsuite, then treat the main test bundle as the
+      // executable.
+      if (exe_module_sp &&
+          PlatformDarwin::IsUnitTestExecutable(*exe_module_sp)) {
+        ModuleSP unit_test_module =
+            PlatformDarwin::GetUnitTestModule(target->GetImages());
+
+        if (unit_test_module) {
+          exe_module_sp = unit_test_module;
+        }
+      }
+#endif
+
+      if (exe_module_sp) {
+        SymbolVendor *sym_vendor = exe_module_sp->GetSymbolVendor();
+        if (sym_vendor) {
+          // Retrieve the Swift ASTs from the symbol vendor.
+          auto ast_datas = sym_vendor->GetASTData(eLanguageTypeSwift);
+          if (!ast_datas.empty()) {
+            // We only initialize the compiler invocation with the first
+            // AST since it initializes some data that must remain static,
+            // like the SDK path and the triple for the produced output.
+            auto ast_data_sp = ast_datas.front();
+            llvm::StringRef section_data_ref(
+                (const char *)ast_data_sp->GetBytes(),
+                ast_data_sp->GetByteSize());
+            swift::serialization::Status result =
+                swift_ast_sp->GetCompilerInvocation().loadFromSerializedAST(
+                    section_data_ref);
+            if (result == swift::serialization::Status::Valid) {
+              read_options_from_ast = true;
+            } else {
+              Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+              if (log)
+                log->Printf("Attempt to load compiler options from Serialized "
+                            "AST failed: %d (%zu AST data blobs total).",
+                            result, ast_datas.size());
+            }
+          }
+        }
+      }
+
+      // Now if the user fully specified the triple, let that override the one
+      // we got from executable's options:
+
+      if (target->GetArchitecture().IsFullySpecifiedTriple()) {
+        swift_ast_sp->SetTriple(
+            target->GetArchitecture().GetTriple().str().c_str());
+      } else {
+        // Always run using the Host OS triple...
+        bool set_triple = false;
+        PlatformSP platform_sp(target->GetPlatform());
+        uint32_t major, minor, update;
+        if (platform_sp &&
+            platform_sp->GetOSVersion(major, minor, update,
+                                      target->GetProcessSP().get())) {
+          StreamString full_triple_name;
+          full_triple_name.PutCString(
+              target->GetArchitecture().GetTriple().str());
+          if (major != UINT32_MAX) {
+            full_triple_name.Printf("%u", major);
+            if (minor != UINT32_MAX) {
+              full_triple_name.Printf(".%u", minor);
+              if (update != UINT32_MAX)
+                full_triple_name.Printf(".%u", update);
+            }
+          }
+          swift_ast_sp->SetTriple(full_triple_name.GetString().data());
+          set_triple = true;
+        }
+
+        if (!set_triple) {
+          ModuleSP exe_module_sp(target->GetExecutableModule());
+          if (exe_module_sp) {
+            Status exe_error;
+            SwiftASTContext *exe_swift_ctx =
+                llvm::dyn_cast_or_null<SwiftASTContext>(
+                    exe_module_sp->GetTypeSystemForLanguage(
+                        lldb::eLanguageTypeSwift));
+            if (exe_swift_ctx) {
+              swift_ast_sp->SetTriple(
+                  exe_swift_ctx->GetLanguageOptions().Target.str().c_str());
+            }
+          }
+        }
+      }
+
+      const bool use_all_compiler_flags =
+          !read_options_from_ast || target->GetUseAllCompilerFlags();
+
+      std::function<void(ModuleSP &&)> process_one_module =
+          [target, &swift_ast_sp,
+           use_all_compiler_flags](ModuleSP &&module_sp) {
+            const FileSpec &module_file = module_sp->GetFileSpec();
+
+            std::string module_path = module_file.GetPath();
+
+            // Add the containing framework to the framework search path.  Don't
+            // do that if this is the executable module, since it might be
+            // buried in some framework that we don't care about.
+            if (use_all_compiler_flags &&
+                target->GetExecutableModulePointer() != module_sp.get()) {
+              size_t framework_offset = module_path.rfind(".framework/");
+
+              if (framework_offset != std::string::npos) {
+                // Sometimes the version of the framework that got loaded has
+                // been stripped and in that case, adding it to the framework
+                // search path will just short-cut a clang search that might
+                // otherwise find the needed headers. So don't add these paths.
+                std::string framework_path =
+                    module_path.substr(0, framework_offset);
+                framework_path.append(".framework");
+                FileSpec path_spec(framework_path, true);
+                FileSpec headers_spec =
+                    path_spec.CopyByAppendingPathComponent("Headers");
+                bool add_it = false;
+                if (headers_spec.Exists())
+                  add_it = true;
+                if (!add_it) {
+                  FileSpec module_spec =
+                      path_spec.CopyByAppendingPathComponent("Modules");
+                  if (module_spec.Exists())
+                    add_it = true;
+                }
+
+                if (!add_it) {
+                  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+                  if (log)
+                    log->Printf("process_one_module rejecting framework path"
+                                " \"%s\" as it has no Headers "
+                                "or Modules subdirectories.",
+                                framework_path.c_str());
+                }
+
+                if (add_it) {
+                  while (framework_offset &&
+                         (module_path[framework_offset] != '/'))
+                    framework_offset--;
+
+                  if (module_path[framework_offset] == '/') {
+                    // framework_offset now points to the '/';
+
+                    std::string parent_path =
+                        module_path.substr(0, framework_offset);
+
+                    if (strncmp(parent_path.c_str(), "/System/Library",
+                                strlen("/System/Library")) &&
+                        !IsDeviceSupport(parent_path.c_str())) {
+                      swift_ast_sp->AddFrameworkSearchPath(parent_path.c_str());
+                    }
+                  }
+                }
+              }
+            }
+
+            SymbolVendor *sym_vendor = module_sp->GetSymbolVendor();
+
+            if (sym_vendor) {
+              std::vector<std::string> module_names;
+
+              SymbolFile *sym_file = sym_vendor->GetSymbolFile();
+              if (sym_file) {
+                Status sym_file_error;
+                SwiftASTContext *ast_context =
+                    llvm::dyn_cast_or_null<SwiftASTContext>(
+                        sym_file->GetTypeSystemForLanguage(
+                            lldb::eLanguageTypeSwift));
+                if (ast_context) {
+                  if (use_all_compiler_flags ||
+                      target->GetExecutableModulePointer() == module_sp.get()) {
+                    for (size_t msi = 0,
+                                mse = ast_context->GetNumModuleSearchPaths();
+                         msi < mse; ++msi) {
+                      const char *search_path =
+                          ast_context->GetModuleSearchPathAtIndex(msi);
+                      swift_ast_sp->AddModuleSearchPath(search_path);
+                    }
+
+                    for (size_t fsi = 0,
+                                fse = ast_context->GetNumFrameworkSearchPaths();
+                         fsi < fse; ++fsi) {
+                      const char *search_path =
+                          ast_context->GetFrameworkSearchPathAtIndex(fsi);
+                      swift_ast_sp->AddFrameworkSearchPath(search_path);
+                    }
+
+                    for (size_t osi = 0,
+                                ose = ast_context->GetNumClangArguments();
+                         osi < ose; ++osi) {
+                      const char *clang_argument =
+                          ast_context->GetClangArgumentAtIndex(osi);
+                      swift_ast_sp->AddClangArgument(clang_argument, true);
+                    }
+                  }
+
+                  swift_ast_sp->RegisterSectionModules(*module_sp,
+                                                       module_names);
+                }
+              }
+            }
+          };
+
+      for (size_t mi = 0; mi != num_images; ++mi) {
+        process_one_module(target->GetImages().GetModuleAtIndex(mi));
+      }
+
+      FileSpecList &framework_search_paths =
+          target->GetSwiftFrameworkSearchPaths();
+      FileSpecList &module_search_paths = target->GetSwiftModuleSearchPaths();
+
+      for (size_t fi = 0, fe = framework_search_paths.GetSize(); fi != fe;
+           ++fi) {
+        swift_ast_sp->AddFrameworkSearchPath(
+            framework_search_paths.GetFileSpecAtIndex(fi).GetPath().c_str());
+      }
+
+      for (size_t mi = 0, me = module_search_paths.GetSize(); mi != me; ++mi) {
+        swift_ast_sp->AddModuleSearchPath(
+            module_search_paths.GetFileSpecAtIndex(mi).GetPath().c_str());
+      }
+
+      // Now fold any extra options we were passed. This has to be done BEFORE
+      // the ClangImporter is made by calling GetClangImporter or these options
+      // will be ignored.
+
+      if (extra_options) {
+        swift::CompilerInvocation &compiler_invocation =
+            swift_ast_sp->GetCompilerInvocation();
+        Args extra_args(extra_options);
+        llvm::ArrayRef<const char *> extra_args_ref(
+            extra_args.GetArgumentVector(), extra_args.GetArgumentCount());
+        compiler_invocation.parseArgs(extra_args_ref,
+                                      swift_ast_sp->GetDiagnosticEngine());
+      }
+
+      Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+      // This needs to happen once all the import paths are set, or otherwise no
+      // modules will be found.
+      if (!swift_ast_sp->GetClangImporter()) {
+        if (log) {
+          log->Printf("((Target*)%p)->GetSwiftASTContext() returning NULL - "
+                      "couldn't create a ClangImporter",
+                      target);
+        }
+
+        return TypeSystemSP();
+      }
+
+      if (log) {
+        log->Printf("((Target*)%p)->GetSwiftASTContext() = %p", target,
+                    swift_ast_sp.get());
+        swift_ast_sp->DumpConfiguration(log);
+      }
+
+      if (swift_ast_sp->HasFatalErrors()) {
+        swift_ast_sp->m_error.SetErrorStringWithFormat(
+            "Error creating target Swift AST context: %s",
+            swift_ast_sp->GetFatalErrors().AsCString());
+        return lldb::TypeSystemSP();
+      }
+
+      {
+        const bool can_create = true;
+        if (!swift_ast_sp->m_ast_context_ap->getStdlibModule(can_create)) {
+          // We need to be able to load the standard library!
+          return lldb::TypeSystemSP();
+        }
+      }
+
+      return swift_ast_sp;
+    }
+  }
+  return lldb::TypeSystemSP();
+}
+
+void SwiftASTContext::EnumerateSupportedLanguages(
+    std::set<lldb::LanguageType> &languages_for_types,
+    std::set<lldb::LanguageType> &languages_for_expressions) {
+  static std::vector<lldb::LanguageType> s_supported_languages_for_types(
+      {lldb::eLanguageTypeSwift});
+
+  static std::vector<lldb::LanguageType> s_supported_languages_for_expressions(
+      {lldb::eLanguageTypeSwift});
+
+  languages_for_types.insert(s_supported_languages_for_types.begin(),
+                             s_supported_languages_for_types.end());
+  languages_for_expressions.insert(
+      s_supported_languages_for_expressions.begin(),
+      s_supported_languages_for_expressions.end());
+}
+
+void SwiftASTContext::Initialize() {
+  PluginManager::RegisterPlugin(GetPluginNameStatic(),
+                                "swift AST context plug-in", CreateInstance,
+                                EnumerateSupportedLanguages);
+}
+
+void SwiftASTContext::Terminate() {
+  PluginManager::UnregisterPlugin(CreateInstance);
+}
+
+bool SwiftASTContext::SupportsLanguage(lldb::LanguageType language) {
+  return SwiftASTContextSupportsLanguage(language);
+}
+
+Status SwiftASTContext::IsCompatible() { return GetFatalErrors(); }
+
+Status SwiftASTContext::GetFatalErrors() {
+  Status error;
+  if (HasFatalErrors()) {
+    error = m_fatal_errors;
+    if (error.Success())
+      error.SetErrorString("unknown fatal error in swift AST context");
+  }
+  return error;
+}
+
+swift::IRGenOptions &SwiftASTContext::GetIRGenOptions() {
+  return m_compiler_invocation_ap->getIRGenOptions();
+}
+
+std::string SwiftASTContext::GetTriple() const {
+  return m_compiler_invocation_ap->getTargetTriple();
+}
+
+// Conditions a triple string to be safe for use with Swift.
+// Right now this just strips the Haswell marker off the CPU name.
+// TODO make Swift more robust
+static std::string GetSwiftFriendlyTriple(const std::string &triple) {
+  static std::string s_x86_64h("x86_64h");
+  static std::string::size_type s_x86_64h_size = s_x86_64h.size();
+
+  if (0 == triple.compare(0, s_x86_64h_size, s_x86_64h)) {
+    std::string fixed_triple("x86_64");
+    fixed_triple.append(
+        triple.substr(s_x86_64h_size, triple.size() - s_x86_64h_size));
+    return fixed_triple;
+  }
+  return triple;
+}
+
+bool SwiftASTContext::SetTriple(const char *triple_cstr, Module *module) {
+  if (triple_cstr && triple_cstr[0]) {
+    Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+    // We can change our triple up until we create the swift::irgen::IRGenModule
+    if (m_ir_gen_module_ap.get() == NULL) {
+      std::string raw_triple(triple_cstr);
+      std::string triple = GetSwiftFriendlyTriple(raw_triple);
+
+      llvm::Triple llvm_triple(triple);
+      const unsigned unspecified = 0;
+      // If the OS version is unspecified, do fancy things
+      if (llvm_triple.getOSMajorVersion() == unspecified) {
+        // If a triple is "<arch>-apple-darwin" change it to be
+        // "<arch>-apple-macosx" otherwise the major and minor OS version we
+        // append below would be wrong.
+        if (llvm_triple.getVendor() == llvm::Triple::VendorType::Apple &&
+            llvm_triple.getOS() == llvm::Triple::OSType::Darwin) {
+          llvm_triple.setOS(llvm::Triple::OSType::MacOSX);
+          triple = llvm_triple.str();
+        }
+
+        // Append the min OS to the triple if we have a target
+        ModuleSP module_sp;
+        if (module == NULL) {
+          TargetSP target_sp(m_target_wp.lock());
+          if (target_sp) {
+            module_sp = target_sp->GetExecutableModule();
+            if (module_sp)
+              module = module_sp.get();
+          }
+        }
+
+        if (module) {
+          ObjectFile *objfile = module->GetObjectFile();
+          uint32_t versions[3];
+          if (objfile) {
+            uint32_t num_versions = objfile->GetMinimumOSVersion(versions, 3);
+            StreamString strm;
+            if (num_versions) {
+              for (uint32_t v = 0; v < 3; ++v) {
+                if (v < num_versions) {
+                  if (versions[v] == UINT32_MAX)
+                    versions[v] = 0;
+                } else
+                  versions[v] = 0;
+              }
+              strm.Printf("%s%u.%u.%u", llvm_triple.getOSName().str().c_str(),
+                          versions[0], versions[1], versions[2]);
+              llvm_triple.setOSName(strm.GetString());
+              triple = llvm_triple.str();
+            }
+          }
+        }
+      }
+      if (log)
+        log->Printf("%p: SwiftASTContext::SetTriple('%s') setting to '%s'%s",
+                    this, triple_cstr, triple.c_str(),
+                    m_target_wp.lock() ? " (target)" : "");
+      m_compiler_invocation_ap->setTargetTriple(triple);
+      return true;
+    } else {
+      if (log)
+        log->Printf("%p: SwiftASTContext::SetTriple('%s') ignoring triple "
+                    "since the IRGenModule has already been created",
+                    this, triple_cstr);
+    }
+  }
+  return false;
+}
+
+static std::string GetXcodeContentsPath() {
+  const char substr[] = ".app/Contents/";
+
+  // First, try based on the current shlib's location
+
+  {
+    FileSpec fspec;
+
+    if (HostInfo::GetLLDBPath(ePathTypeLLDBShlibDir, fspec)) {
+      std::string path_to_shlib = fspec.GetPath();
+      size_t pos = path_to_shlib.rfind(substr);
+      if (pos != std::string::npos) {
+        path_to_shlib.erase(pos + strlen(substr));
+        return path_to_shlib;
+      }
+    }
+  }
+
+  // Fall back to using xcrun
+
+  {
+    int status = 0;
+    int signo = 0;
+    std::string output;
+    const char *command = "xcrun -sdk macosx --show-sdk-path";
+    lldb_private::Status error = Host::RunShellCommand(
+        command, // shell command to run
+        NULL,    // current working directory
+        &status, // Put the exit status of the process in here
+        &signo,  // Put the signal that caused the process to exit in here
+        &output, // Get the output from the command and place it in this string
+        3);      // Timeout in seconds to wait for shell program to finish
+    if (status == 0 && !output.empty()) {
+      size_t first_non_newline = output.find_last_not_of("\r\n");
+      if (first_non_newline != std::string::npos) {
+        output.erase(first_non_newline + 1);
+      }
+
+      size_t pos = output.rfind(substr);
+      if (pos != std::string::npos) {
+        output.erase(pos + strlen(substr));
+        return output;
+      }
+    }
+  }
+
+  return std::string();
+}
+
+static std::string GetCurrentToolchainPath() {
+  const char substr[] = ".xctoolchain/";
+
+  {
+    FileSpec fspec;
+
+    if (HostInfo::GetLLDBPath(ePathTypeLLDBShlibDir, fspec)) {
+      std::string path_to_shlib = fspec.GetPath();
+      size_t pos = path_to_shlib.rfind(substr);
+      if (pos != std::string::npos) {
+        path_to_shlib.erase(pos + strlen(substr));
+        return path_to_shlib;
+      }
+    }
+  }
+
+  return std::string();
+}
+
+static std::string GetCurrentCLToolsPath() {
+  const char substr[] = "/CommandLineTools/";
+
+  {
+    FileSpec fspec;
+
+    if (HostInfo::GetLLDBPath(ePathTypeLLDBShlibDir, fspec)) {
+      std::string path_to_shlib = fspec.GetPath();
+      size_t pos = path_to_shlib.rfind(substr);
+      if (pos != std::string::npos) {
+        path_to_shlib.erase(pos + strlen(substr));
+        return path_to_shlib;
+      }
+    }
+  }
+
+  return std::string();
+}
+
+namespace {
+
+enum class SDKType {
+  MacOSX = 0,
+  iPhoneSimulator,
+  iPhoneOS,
+  AppleTVSimulator,
+  AppleTVOS,
+  WatchSimulator,
+  watchOS,
+  numSDKTypes,
+  unknown = -1
+};
+
+const char *const sdk_strings[] = {
+    "macosx",    "iphonesimulator", "iphoneos", "appletvsimulator",
+    "appletvos", "watchsimulator",  "watchos",
+};
+
+struct SDKEnumeratorInfo {
+  FileSpec found_path;
+  SDKType sdk_type;
+  uint32_t least_major;
+  uint32_t least_minor;
+};
+
+static bool SDKSupportsSwift(const FileSpec &sdk_path, SDKType desired_type) {
+  ConstString last_path_component = sdk_path.GetLastPathComponent();
+
+  if (last_path_component) {
+    const llvm::StringRef sdk_name_raw = last_path_component.GetStringRef();
+    std::string sdk_name_lower = sdk_name_raw.lower();
+    const llvm::StringRef sdk_name(sdk_name_lower);
+
+    llvm::StringRef version_part;
+
+    SDKType sdk_type = SDKType::unknown;
+
+    if (desired_type == SDKType::unknown) {
+      for (int i = (int)SDKType::MacOSX; i < (int)SDKType::numSDKTypes; ++i) {
+        if (sdk_name.startswith(sdk_strings[i])) {
+          version_part = sdk_name.drop_front(strlen(sdk_strings[i]));
+          sdk_type = (SDKType)i;
+          break;
+        }
+      }
+
+      // For non-Darwin SDKs assume Swift is supported
+      if (sdk_type == SDKType::unknown)
+        return true;
+    } else {
+      if (sdk_name.startswith(sdk_strings[(int)desired_type])) {
+        version_part =
+            sdk_name.drop_front(strlen(sdk_strings[(int)desired_type]));
+        sdk_type = desired_type;
+      } else {
+        return false;
+      }
+    }
+
+    const size_t major_dot_offset = version_part.find('.');
+    if (major_dot_offset == llvm::StringRef::npos)
+      return false;
+
+    const llvm::StringRef major_version =
+        version_part.slice(0, major_dot_offset);
+    const llvm::StringRef minor_part =
+        version_part.drop_front(major_dot_offset + 1);
+
+    const size_t minor_dot_offset = minor_part.find('.');
+    if (minor_dot_offset == llvm::StringRef::npos)
+      return false;
+
+    const llvm::StringRef minor_version = minor_part.slice(0, minor_dot_offset);
+
+    unsigned int major = 0;
+    unsigned int minor = 0;
+
+    if (major_version.getAsInteger(10, major))
+      return false;
+
+    if (minor_version.getAsInteger(10, minor))
+      return false;
+
+    switch (sdk_type) {
+    case SDKType::MacOSX:
+      if (major > 10 || (major == 10 && minor >= 10))
+        return true;
+      break;
+    case SDKType::iPhoneOS:
+    case SDKType::iPhoneSimulator:
+      if (major >= 8)
+        return true;
+      break;
+    case SDKType::AppleTVSimulator:
+    case SDKType::AppleTVOS:
+      if (major >= 9)
+        return true;
+      break;
+    case SDKType::WatchSimulator:
+    case SDKType::watchOS:
+      if (major >= 2)
+        return true;
+      break;
+    default:
+      return false;
+    }
+  }
+
+  return false;
+}
+
+FileSpec::EnumerateDirectoryResult
+DirectoryEnumerator(void *baton, llvm::sys::fs::file_type file_type,
+                    const FileSpec &spec) {
+  SDKEnumeratorInfo *enumerator_info = static_cast<SDKEnumeratorInfo *>(baton);
+
+  if (SDKSupportsSwift(spec, enumerator_info->sdk_type)) {
+    enumerator_info->found_path = spec;
+    return FileSpec::EnumerateDirectoryResult::eEnumerateDirectoryResultNext;
+  }
+
+  return FileSpec::EnumerateDirectoryResult::eEnumerateDirectoryResultNext;
+};
+
+static ConstString EnumerateSDKsForVersion(FileSpec sdks_spec, SDKType sdk_type,
+                                           uint32_t least_major,
+                                           uint32_t least_minor) {
+  if (!IsDirectory(sdks_spec))
+    return ConstString();
+
+  const bool find_directories = true;
+  const bool find_files = false;
+  const bool find_other = true; // include symlinks
+
+  SDKEnumeratorInfo enumerator_info;
+
+  enumerator_info.sdk_type = sdk_type;
+  enumerator_info.least_major = least_major;
+  enumerator_info.least_minor = least_minor;
+
+  FileSpec::EnumerateDirectory(sdks_spec.GetPath().c_str(), find_directories,
+                               find_files, find_other, DirectoryEnumerator,
+                               &enumerator_info);
+
+  if (IsDirectory(enumerator_info.found_path))
+    return ConstString(enumerator_info.found_path.GetPath());
+  else
+    return ConstString();
+}
+
+static ConstString GetSDKDirectory(SDKType sdk_type, uint32_t least_major,
+                                   uint32_t least_minor) {
+  if (sdk_type != SDKType::MacOSX) {
+    // Look inside Xcode for the required installed iOS SDK version
+
+    std::string sdks_path = GetXcodeContentsPath();
+    sdks_path.append("Developer/Platforms");
+
+    if (sdk_type == SDKType::iPhoneSimulator) {
+      sdks_path.append("/iPhoneSimulator.platform/");
+    } else if (sdk_type == SDKType::AppleTVSimulator) {
+      sdks_path.append("/AppleTVSimulator.platform/");
+    } else if (sdk_type == SDKType::AppleTVOS) {
+      sdks_path.append("/AppleTVOS.platform/");
+    } else if (sdk_type == SDKType::WatchSimulator) {
+      sdks_path.append("/WatchSimulator.platform/");
+    } else if (sdk_type == SDKType::watchOS) {
+      // For now, we need to be prepared to handle either capitalization of this
+      // path.
+
+      std::string WatchOS_candidate_path = sdks_path + "/WatchOS.platform/";
+      if (IsDirectory(FileSpec(WatchOS_candidate_path.c_str(), false))) {
+        sdks_path = WatchOS_candidate_path;
+      } else {
+        std::string watchOS_candidate_path = sdks_path + "/watchOS.platform/";
+        if (IsDirectory(FileSpec(watchOS_candidate_path.c_str(), false))) {
+          sdks_path = watchOS_candidate_path;
+        } else {
+          return ConstString();
+        }
+      }
+    } else {
+      sdks_path.append("/iPhoneOS.platform/");
+    }
+
+    sdks_path.append("Developer/SDKs/");
+
+    FileSpec sdks_spec(sdks_path.c_str(), false);
+
+    return EnumerateSDKsForVersion(sdks_spec, sdk_type, least_major,
+                                   least_major);
+  }
+
+  // The SDK type is Mac OS X
+
+  uint32_t major = 0;
+  uint32_t minor = 0;
+  uint32_t update = 0;
+
+  if (!HostInfo::GetOSVersion(major, minor, update))
+    return ConstString();
+
+  // If there are minimum requirements that exceed the current OS, apply those
+
+  if (least_major > major) {
+    major = least_major;
+    minor = least_minor;
+  } else if (least_major == major) {
+    if (least_minor > minor)
+      minor = least_minor;
+  }
+
+  typedef std::map<uint64_t, ConstString> SDKDirectoryCache;
+  static std::mutex g_mutex;
+  static SDKDirectoryCache g_sdk_cache;
+  std::lock_guard<std::mutex> locker(g_mutex);
+  const uint64_t major_minor = (uint64_t)major << 32 | (uint64_t)minor;
+  SDKDirectoryCache::iterator pos = g_sdk_cache.find(major_minor);
+  if (pos != g_sdk_cache.end())
+    return pos->second;
+
+  FileSpec fspec;
+  std::string xcode_contents_path;
+
+  if (xcode_contents_path.empty())
+    xcode_contents_path = GetXcodeContentsPath();
+
+  if (!xcode_contents_path.empty()) {
+    StreamString sdk_path;
+    sdk_path.Printf(
+        "%sDeveloper/Platforms/MacOSX.platform/Developer/SDKs/MacOSX%u.%u.sdk",
+        xcode_contents_path.c_str(), major, minor);
+    fspec.SetFile(sdk_path.GetString(), false);
+    if (fspec.Exists()) {
+      ConstString path(sdk_path.GetString());
+      // Cache results
+      g_sdk_cache[major_minor] = path;
+      return path;
+    } else if ((least_major != major) || (least_minor != minor)) {
+      // Try the required SDK
+      sdk_path.Clear();
+      sdk_path.Printf("%sDeveloper/Platforms/MacOSX.platform/Developer/SDKs/"
+                      "MacOSX%u.%u.sdk",
+                      xcode_contents_path.c_str(), least_major, least_minor);
+      fspec.SetFile(sdk_path.GetString(), false);
+      if (fspec.Exists()) {
+        ConstString path(sdk_path.GetString());
+        // Cache results
+        g_sdk_cache[major_minor] = path;
+        return path;
+      } else {
+        // Okay, we're going to do an exhaustive search for *any* SDK that has
+        // an adequate version.
+
+        std::string sdks_path = GetXcodeContentsPath();
+        sdks_path.append("Developer/Platforms/MacOSX.platform/Developer/SDKs");
+
+        FileSpec sdks_spec(sdks_path.c_str(), false);
+
+        ConstString sdk_path = EnumerateSDKsForVersion(
+            sdks_spec, sdk_type, least_major, least_major);
+
+        if (sdk_path) {
+          g_sdk_cache[major_minor] = sdk_path;
+          return sdk_path;
+        }
+      }
+    }
+  }
+
+  // Cache results
+  g_sdk_cache[major_minor] = ConstString();
+  return ConstString();
+}
+
+static ConstString GetResourceDir() {
+  static ConstString g_cached_resource_dir;
+  static llvm::once_flag g_once_flag;
+  std::call_once(g_once_flag, []() {
+    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+    // First, check if there's something in our bundle
+    {
+      FileSpec swift_dir_spec;
+      if (HostInfo::GetLLDBPath(ePathTypeSwiftDir, swift_dir_spec)) {
+        if (log)
+          log->Printf("%s: trying ePathTypeSwiftDir: %s", __FUNCTION__,
+                      swift_dir_spec.GetCString());
+
+        if (IsDirectory(swift_dir_spec)) {
+          g_cached_resource_dir = ConstString(swift_dir_spec.GetPath());
+          if (log)
+            log->Printf("%s: found Swift resource dir via "
+                        "ePathTypeSwiftDir': %s",
+                        __FUNCTION__, g_cached_resource_dir.AsCString());
+          return;
+        }
+      }
+    }
+
+    // Nothing in our bundle. Are we in a toolchain that has its own Swift
+    // compiler resource dir?
+
+    {
+      std::string xcode_toolchain_path = GetCurrentToolchainPath();
+      if (log)
+        log->Printf("%s: trying toolchain path: %s", __FUNCTION__,
+                    xcode_toolchain_path.c_str());
+
+      if (!xcode_toolchain_path.empty()) {
+        xcode_toolchain_path.append("usr/lib/swift");
+        if (log)
+          log->Printf("%s: trying toolchain-based lib path: %s", __FUNCTION__,
+                      xcode_toolchain_path.c_str());
+
+        if (IsDirectory(FileSpec(xcode_toolchain_path, false))) {
+          g_cached_resource_dir = ConstString(xcode_toolchain_path);
+          if (log)
+            log->Printf("%s: found Swift resource dir via "
+                        "toolchain path + 'usr/lib/swift': %s",
+                        __FUNCTION__, g_cached_resource_dir.AsCString());
+          return;
+        }
+      }
+    }
+
+    // We're not in a toolchain that has one. Use the Xcode default toolchain.
+
+    {
+      std::string xcode_contents_path = GetXcodeContentsPath();
+      if (log)
+        log->Printf("%s: trying Xcode path: %s", __FUNCTION__,
+                    xcode_contents_path.c_str());
+
+      if (!xcode_contents_path.empty()) {
+        xcode_contents_path.append("Developer/Toolchains/"
+                                   "XcodeDefault.xctoolchain"
+                                   "/usr/lib/swift");
+        if (log)
+          log->Printf("%s: trying Xcode-based lib path: %s", __FUNCTION__,
+                      xcode_contents_path.c_str());
+
+        if (IsDirectory(FileSpec(xcode_contents_path, false))) {
+          g_cached_resource_dir = ConstString(xcode_contents_path);
+          if (log)
+            log->Printf("%s: found Swift resource dir via "
+                        "Xcode contents path + default toolchain "
+                        "relative dir: %s",
+                        __FUNCTION__, g_cached_resource_dir.AsCString());
+          return;
+        }
+      }
+    }
+
+    // We're not in Xcode. We might be in the command-line tools.
+
+    {
+      std::string cl_tools_path = GetCurrentCLToolsPath();
+      if (log)
+        log->Printf("%s: trying command-line tools path: %s", __FUNCTION__,
+                    cl_tools_path.c_str());
+
+      if (!cl_tools_path.empty()) {
+        cl_tools_path.append("usr/lib/swift");
+        if (log)
+          log->Printf("%s: trying command-line tools-based lib "
+                      "path: %s",
+                      __FUNCTION__, cl_tools_path.c_str());
+
+        if (IsDirectory(FileSpec(cl_tools_path, false))) {
+          g_cached_resource_dir = ConstString(cl_tools_path);
+          if (log)
+            log->Printf("%s: found Swift resource dir via "
+                        "command-line tools path + "
+                        "usr/lib/swift: %s",
+                        __FUNCTION__, g_cached_resource_dir.AsCString());
+          return;
+        }
+      }
+    }
+
+    // We might be in the build-dir configuration for a build-script-driven
+    // LLDB build, which has the Swift build dir as a sibling directory
+    // to the lldb build dir.  This looks much different than the install-
+    // dir layout that the previous checks would try.
+    {
+      FileSpec faux_swift_dir_spec;
+      if (HostInfo::GetLLDBPath(ePathTypeSwiftDir, faux_swift_dir_spec)) {
+// We can't use a C++11 stdlib regex feature here because it
+// doesn't work on Ubuntu 14.04 x86_64.  Once we don't care
+// about supporting that anymore, let's pull the code below
+// back in since it is a simpler implementation using
+// std::regex.
+#if 0
+                // Let's try to regex this.
+                // We're looking for /some/path/lldb-{os}-{arch}, and want to
+                // build the following:
+                //    /some/path/swift-{os}-{arch}/lib/swift/{os}/{arch}
+                // In a match, these are the following assignments for
+                // backrefs:
+                //   $1 - first part of path before swift build dir
+                //   $2 - the host OS path separator character
+                //   $3 - all the stuff that should come after changing
+                //        lldb to swift for the lib dir.
+                auto match_regex =
+                    std::regex("^(.+([/\\\\]))lldb-(.+)$");
+                const std::string replace_format = "$1swift-$3";
+                const std::string faux_swift_dir =
+                    faux_swift_dir_spec.GetCString();
+                const std::string build_tree_resource_dir =
+                    std::regex_replace(faux_swift_dir, match_regex,
+                                       replace_format);
+#else
+                std::string build_tree_resource_dir;
+                const std::string faux_swift_dir =
+                    faux_swift_dir_spec.GetCString();
+
+                // Find something that matches lldb- (particularly,
+                // the last one).
+                const std::string lldb_dash("lldb-");
+                auto lldb_pos = faux_swift_dir.rfind(lldb_dash);
+                if ((lldb_pos != std::string::npos) &&
+                    (lldb_pos > 0) &&
+                    ((faux_swift_dir[lldb_pos - 1] == '\\') ||
+                     (faux_swift_dir[lldb_pos - 1] == '/')))
+                {
+                    // We found something that matches ^.+[/\\]lldb-.+$
+                    std::ostringstream stream;
+                    // Take everything before lldb- (the path leading up to
+                    // the lldb dir).
+                    stream << faux_swift_dir.substr(0, lldb_pos);
+
+                    // replace lldb- with swift-.
+                    stream << "swift-";
+
+                    // and now tack on the same components from after
+                    // the lldb- part.
+                    stream << faux_swift_dir.substr(lldb_pos +
+                                                    lldb_dash.length());
+                    const std::string build_tree_resource_dir = stream.str();
+                    if (log)
+                        log->Printf("%s: trying ePathTypeSwiftDir regex-based "
+                                    "build dir: %s",
+                                    __FUNCTION__,
+                                    build_tree_resource_dir.c_str());
+                    FileSpec swift_resource_dir_spec(
+                        build_tree_resource_dir.c_str(), false);
+                    if (IsDirectory(swift_resource_dir_spec))
+                    {
+                        g_cached_resource_dir =
+                            ConstString(swift_resource_dir_spec.GetPath());
+                        if (log)
+                            log->Printf("%s: found Swift resource dir via "
+                                        "ePathTypeSwiftDir + inferred "
+                                        "build-tree dir: %s", __FUNCTION__,
+                                        g_cached_resource_dir.AsCString());
+                        return;
+                    }
+                }
+#endif
+      }
+    }
+
+    // We failed to find a reasonable Swift resource dir.
+    if (log)
+      log->Printf("%s: failed to find a Swift resource dir", __FUNCTION__);
+  });
+
+  return g_cached_resource_dir;
+}
+
+} // anonymous namespace
+
+swift::CompilerInvocation &SwiftASTContext::GetCompilerInvocation() {
+  return *m_compiler_invocation_ap;
+}
+
+swift::SourceManager &SwiftASTContext::GetSourceManager() {
+  if (m_source_manager_ap.get() == NULL)
+    m_source_manager_ap.reset(new swift::SourceManager());
+  return *m_source_manager_ap;
+}
+
+swift::LangOptions &SwiftASTContext::GetLanguageOptions() {
+  return GetCompilerInvocation().getLangOptions();
+}
+
+swift::DiagnosticEngine &SwiftASTContext::GetDiagnosticEngine() {
+  if (m_diagnostic_engine_ap.get() == NULL)
+    m_diagnostic_engine_ap.reset(
+        new swift::DiagnosticEngine(GetSourceManager()));
+  return *m_diagnostic_engine_ap;
+}
+
+// This code comes from CompilerInvocation.cpp (setRuntimeResourcePath)
+
+static void ConfigureResourceDirs(swift::CompilerInvocation &invocation,
+                                  FileSpec resource_dir, llvm::Triple triple) {
+  // Make sure the triple is right:
+  invocation.setTargetTriple(triple.str());
+  invocation.setRuntimeResourcePath(resource_dir.GetPath().c_str());
+}
+
+swift::SILOptions &SwiftASTContext::GetSILOptions() {
+  return GetCompilerInvocation().getSILOptions();
+}
+
+bool SwiftASTContext::TargetHasNoSDK() {
+  llvm::Triple triple(GetTriple());
+
+  switch (triple.getOS()) {
+  case llvm::Triple::OSType::MacOSX:
+  case llvm::Triple::OSType::Darwin:
+  case llvm::Triple::OSType::IOS:
+    return false;
+  default:
+    return true;
+  }
+}
+
+swift::ClangImporterOptions &SwiftASTContext::GetClangImporterOptions() {
+  swift::ClangImporterOptions &clang_importer_options =
+      GetCompilerInvocation().getClangImporterOptions();
+  if (!m_initialized_clang_importer_options) {
+    m_initialized_clang_importer_options = true;
+    FileSpec clang_dir_spec;
+    if (HostInfo::GetLLDBPath(ePathTypeClangDir, clang_dir_spec))
+      clang_importer_options.OverrideResourceDir =
+          std::move(clang_dir_spec.GetPath());
+  }
+  return clang_importer_options;
+}
+
+swift::SearchPathOptions &SwiftASTContext::GetSearchPathOptions() {
+  swift::SearchPathOptions &search_path_opts =
+      GetCompilerInvocation().getSearchPathOptions();
+
+  if (!m_initialized_search_path_options) {
+    m_initialized_search_path_options = true;
+
+    bool set_sdk = false;
+    bool set_resource_dir = false;
+
+    if (!search_path_opts.SDKPath.empty()) {
+      FileSpec provided_sdk_path(search_path_opts.SDKPath, false);
+      if (provided_sdk_path.Exists()) {
+        // We don't check whether the SDK supports swift because we figure if
+        // someone is passing this to us on the command line (e.g., for the
+        // REPL), they probably know what they're doing.
+
+        set_sdk = true;
+      }
+    } else if (!m_platform_sdk_path.empty()) {
+      FileSpec platform_sdk(m_platform_sdk_path.c_str(), false);
+
+      if (platform_sdk.Exists() &&
+          SDKSupportsSwift(platform_sdk, SDKType::unknown)) {
+        search_path_opts.SDKPath = m_platform_sdk_path.c_str();
+        set_sdk = true;
+      }
+    }
+
+    llvm::Triple triple(GetTriple());
+
+    if (!m_resource_dir.empty()) {
+      FileSpec resource_dir(m_resource_dir.c_str(), false);
+
+      if (resource_dir.Exists()) {
+        ConfigureResourceDirs(GetCompilerInvocation(), resource_dir, triple);
+        set_resource_dir = true;
+      }
+    }
+
+    if (!set_sdk) {
+      if (triple.getOS() == llvm::Triple::OSType::MacOSX ||
+          triple.getOS() == llvm::Triple::OSType::Darwin) {
+        search_path_opts.SDKPath = GetSDKDirectory(SDKType::MacOSX, 10, 10)
+                                       .AsCString(""); // we need the 10.10 SDK
+      } else if (triple.getOS() == llvm::Triple::OSType::IOS) {
+        if (triple.getArchName().startswith("arm")) {
+          search_path_opts.SDKPath =
+              GetSDKDirectory(SDKType::iPhoneOS, 8, 0).AsCString("");
+        } else {
+          search_path_opts.SDKPath =
+              GetSDKDirectory(SDKType::iPhoneSimulator, 8, 0).AsCString("");
+        }
+      }
+      // explicitly leave the SDKPath blank on other platforms
+    }
+
+    if (!set_resource_dir) {
+      FileSpec resource_dir(::GetResourceDir().AsCString(""), false);
+      if (resource_dir.Exists())
+        ConfigureResourceDirs(GetCompilerInvocation(), resource_dir, triple);
+    }
+  }
+
+  return search_path_opts;
+}
+
+namespace lldb_private {
+
+class ANSIColorStringStream : public llvm::raw_string_ostream {
+public:
+  ANSIColorStringStream(bool colorize)
+      : llvm::raw_string_ostream(m_buffer), m_colorize(colorize) {}
+  /// Changes the foreground color of text that will be output from this point
+  /// forward.
+  /// @param Color ANSI color to use, the special SAVEDCOLOR can be used to
+  /// change only the bold attribute, and keep colors untouched
+  /// @param Bold bold/brighter text, default false
+  /// @param BG if true change the background, default: change foreground
+  /// @returns itself so it can be used within << invocations
+  virtual raw_ostream &changeColor(enum Colors colors, bool bold = false,
+                                   bool bg = false) {
+    if (llvm::sys::Process::ColorNeedsFlush())
+      flush();
+    const char *colorcode;
+    if (colors == SAVEDCOLOR)
+      colorcode = llvm::sys::Process::OutputBold(bg);
+    else
+      colorcode = llvm::sys::Process::OutputColor(colors, bold, bg);
+    if (colorcode) {
+      size_t len = strlen(colorcode);
+      write(colorcode, len);
+    }
+    return *this;
+  }
+
+  /// Resets the colors to terminal defaults. Call this when you are done
+  /// outputting colored text, or before program exit.
+  virtual raw_ostream &resetColor() {
+    if (llvm::sys::Process::ColorNeedsFlush())
+      flush();
+    const char *colorcode = llvm::sys::Process::ResetColor();
+    if (colorcode) {
+      size_t len = strlen(colorcode);
+      write(colorcode, len);
+    }
+    return *this;
+  }
+
+  /// Reverses the forground and background colors.
+  virtual raw_ostream &reverseColor() {
+    if (llvm::sys::Process::ColorNeedsFlush())
+      flush();
+    const char *colorcode = llvm::sys::Process::OutputReverse();
+    if (colorcode) {
+      size_t len = strlen(colorcode);
+      write(colorcode, len);
+    }
+    return *this;
+  }
+
+  /// This function determines if this stream is connected to a "tty" or
+  /// "console" window. That is, the output would be displayed to the user
+  /// rather than being put on a pipe or stored in a file.
+  virtual bool is_displayed() const { return m_colorize; }
+
+  /// This function determines if this stream is displayed and supports colors.
+  virtual bool has_colors() const { return m_colorize; }
+
+protected:
+  std::string m_buffer;
+  bool m_colorize;
+};
+
+class StoringDiagnosticConsumer : public swift::DiagnosticConsumer {
+public:
+  StoringDiagnosticConsumer(SwiftASTContext &ast_context)
+      : m_ast_context(ast_context), m_diagnostics(), m_num_errors(0),
+        m_colorize(false) {
+    m_ast_context.GetDiagnosticEngine().resetHadAnyError();
+    m_ast_context.GetDiagnosticEngine().addConsumer(*this);
+  }
+
+  ~StoringDiagnosticConsumer() {
+    m_ast_context.GetDiagnosticEngine().takeConsumers();
+  }
+
+  virtual void
+  handleDiagnostic(swift::SourceManager &source_mgr,
+                   swift::SourceLoc source_loc, swift::DiagnosticKind kind,
+                   llvm::StringRef formatString,
+                   llvm::ArrayRef<swift::DiagnosticArgument> formatArgs,
+                   const swift::DiagnosticInfo &info) {
+    llvm::StringRef bufferName = "<anonymous>";
+    unsigned bufferID = 0;
+    std::pair<unsigned, unsigned> line_col = {0, 0};
+
+    llvm::SmallString<256> text;
+    {
+      llvm::raw_svector_ostream out(text);
+      swift::DiagnosticEngine::formatDiagnosticText(out, formatString,
+                                                    formatArgs);
+    }
+
+    if (source_loc.isValid()) {
+      bufferID = source_mgr.findBufferContainingLoc(source_loc);
+      bufferName = source_mgr.getBufferIdentifierForLoc(source_loc);
+      line_col = source_mgr.getLineAndColumn(source_loc);
+    }
+
+    if (line_col.first != 0) {
+      ANSIColorStringStream os(m_colorize);
+
+      // Determine what kind of diagnostic we're emitting, and whether we want
+      // to use its fixits:
+      bool use_fixits = false;
+      llvm::SourceMgr::DiagKind source_mgr_kind;
+      switch (kind) {
+      default:
+      case swift::DiagnosticKind::Error:
+        source_mgr_kind = llvm::SourceMgr::DK_Error;
+        use_fixits = true;
+        break;
+      case swift::DiagnosticKind::Warning:
+        source_mgr_kind = llvm::SourceMgr::DK_Warning;
+        break;
+
+      case swift::DiagnosticKind::Note:
+        source_mgr_kind = llvm::SourceMgr::DK_Note;
+        break;
+      }
+
+      // Translate ranges.
+      llvm::SmallVector<llvm::SMRange, 2> ranges;
+      for (auto R : info.Ranges)
+        ranges.push_back(getRawRange(source_mgr, R));
+
+      // Translate fix-its.
+      llvm::SmallVector<llvm::SMFixIt, 2> fix_its;
+      for (swift::DiagnosticInfo::FixIt F : info.FixIts)
+        fix_its.push_back(getRawFixIt(source_mgr, F));
+
+      // Display the diagnostic.
+
+      auto message = source_mgr.GetMessage(source_loc, source_mgr_kind, text,
+                                           ranges, fix_its);
+      source_mgr.getLLVMSourceMgr().PrintMessage(os, message);
+
+      // Use the llvm::raw_string_ostream::str() accessor as it will flush
+      // the stream into our "message" and return us a reference to "message".
+      std::string &message_ref = os.str();
+
+      if (message_ref.empty())
+        m_diagnostics.push_back(RawDiagnostic(
+            text.str(), kind, bufferName, bufferID, line_col.first,
+            line_col.second,
+            use_fixits ? info.FixIts
+                       : llvm::ArrayRef<swift::Diagnostic::FixIt>()));
+      else
+        m_diagnostics.push_back(RawDiagnostic(
+            message_ref, kind, bufferName, bufferID, line_col.first,
+            line_col.second,
+            use_fixits ? info.FixIts
+                       : llvm::ArrayRef<swift::Diagnostic::FixIt>()));
+    } else {
+      m_diagnostics.push_back(RawDiagnostic(
+          text.str(), kind, bufferName, bufferID, line_col.first,
+          line_col.second, llvm::ArrayRef<swift::Diagnostic::FixIt>()));
+    }
+
+    if (kind == swift::DiagnosticKind::Error)
+      m_num_errors++;
+  }
+
+  void Clear() {
+    m_ast_context.GetDiagnosticEngine().resetHadAnyError();
+    m_diagnostics.clear();
+    m_num_errors = 0;
+  }
+
+  unsigned NumErrors() {
+    if (m_num_errors)
+      return m_num_errors;
+    else if (m_ast_context.GetASTContext()->hadError())
+      return 1;
+    else
+      return 0;
+  }
+
+  static DiagnosticSeverity SeverityForKind(swift::DiagnosticKind kind) {
+    switch (kind) {
+    case swift::DiagnosticKind::Error:
+      return eDiagnosticSeverityError;
+    case swift::DiagnosticKind::Warning:
+      return eDiagnosticSeverityWarning;
+    case swift::DiagnosticKind::Note:
+      return eDiagnosticSeverityRemark;
+    }
+
+    llvm_unreachable("Unhandled DiagnosticKind in switch.");
+  }
+
+  void PrintDiagnostics(DiagnosticManager &diagnostic_manager,
+                        uint32_t bufferID = UINT32_MAX, uint32_t first_line = 0,
+                        uint32_t last_line = UINT32_MAX,
+                        uint32_t line_offset = 0) {
+    bool added_one_diagnostic = false;
+    for (const RawDiagnostic &diagnostic : m_diagnostics) {
+      // We often make expressions and wrap them in some code.
+      // When we see errors we want the line numbers to be correct so
+      // we correct them below. LLVM stores in SourceLoc objects as character
+      // offsets so there is no way to get LLVM to move its error line numbers
+      // around by adjusting the source location, we must do it manually. We
+      // also want to use the same error formatting as LLVM and Clang, so we
+      // must muck with the string.
+
+      const DiagnosticSeverity severity = SeverityForKind(diagnostic.kind);
+      const DiagnosticOrigin origin = eDiagnosticOriginSwift;
+
+      if (first_line > 0 && bufferID != UINT32_MAX &&
+          diagnostic.bufferID == bufferID && !diagnostic.bufferName.empty()) {
+        // Make sure the error line is in range
+        if (diagnostic.line >= first_line && diagnostic.line <= last_line) {
+          // Need to remap the error/warning to a different line
+          StreamString match;
+          match.Printf("%s:%u:", diagnostic.bufferName.str().c_str(),
+                       diagnostic.line);
+          const size_t match_len = match.GetString().size();
+          size_t match_pos = diagnostic.description.find(match.GetString());
+          if (match_pos != std::string::npos) {
+            // We have some <file>:<line>:" instances that need to be updated
+            StreamString fixed_description;
+            size_t start_pos = 0;
+            do {
+              if (match_pos > start_pos)
+                fixed_description.Printf(
+                    "%s", diagnostic.description.substr(start_pos, match_pos)
+                              .c_str());
+              fixed_description.Printf(
+                  "%s:%u:", diagnostic.bufferName.str().c_str(),
+                  diagnostic.line - first_line + line_offset + 1);
+              start_pos = match_pos + match_len;
+              match_pos =
+                  diagnostic.description.find(match.GetString(), start_pos);
+            } while (match_pos != std::string::npos);
+
+            // Append any last remainging text
+            if (start_pos < diagnostic.description.size())
+              fixed_description.Printf(
+                  "%s", diagnostic.description
+                            .substr(start_pos,
+                                    diagnostic.description.size() - start_pos)
+                            .c_str());
+
+            SwiftDiagnostic *new_diagnostic =
+                new SwiftDiagnostic(fixed_description.GetString().data(),
+                                    severity, origin, bufferID);
+            for (auto fixit : diagnostic.fixits)
+              new_diagnostic->AddFixIt(fixit);
+
+            diagnostic_manager.AddDiagnostic(new_diagnostic);
+            added_one_diagnostic = true;
+
+            continue;
+          }
+        }
+      }
+    }
+
+    // In general, we don't want to see diagnostics from outside of the source
+    // text range of the actual user expression. But if we didn't find any
+    // diagnostics in the text range, it's probably because the source range was
+    // not specified correctly, and we don't want to lose legit errors because
+    // of that. So in that case we'll add them all here:
+
+    if (!added_one_diagnostic) {
+      // This will report diagnostic errors from outside the expression's source
+      // range. Those are not interesting to users, so we only emit them in
+      // debug builds.
+      for (const RawDiagnostic &diagnostic : m_diagnostics) {
+        const DiagnosticSeverity severity = SeverityForKind(diagnostic.kind);
+        const DiagnosticOrigin origin = eDiagnosticOriginSwift;
+        diagnostic_manager.AddDiagnostic(diagnostic.description.c_str(),
+                                         severity, origin);
+      }
+    }
+  }
+
+  bool GetColorize() const { return m_colorize; }
+
+  bool SetColorize(bool b) {
+    const bool old = m_colorize;
+    m_colorize = b;
+    return old;
+  }
+
+private:
+  // We don't currently use lldb_private::Diagostic or any of the lldb
+  // DiagnosticManager machinery to store diagnostics as they occur. Instead,
+  // we store them in raw form using this struct, then transcode them to
+  // SwiftDiagnostics in PrintDiagnostic.
+  struct RawDiagnostic {
+    RawDiagnostic(std::string in_desc, swift::DiagnosticKind in_kind,
+                  llvm::StringRef in_bufferName, unsigned in_bufferID,
+                  uint32_t in_line, uint32_t in_column,
+                  llvm::ArrayRef<swift::Diagnostic::FixIt> in_fixits)
+        : description(in_desc), kind(in_kind), bufferName(in_bufferName),
+          bufferID(in_bufferID), line(in_line), column(in_column) {
+      for (auto fixit : in_fixits) {
+        fixits.push_back(fixit);
+      }
+    }
+    std::string description;
+    swift::DiagnosticKind kind;
+    const llvm::StringRef bufferName;
+    unsigned bufferID;
+    uint32_t line;
+    uint32_t column;
+    std::vector<swift::DiagnosticInfo::FixIt> fixits;
+  };
+  typedef std::vector<RawDiagnostic> RawDiagnosticBuffer;
+
+  SwiftASTContext &m_ast_context;
+  RawDiagnosticBuffer m_diagnostics;
+  unsigned m_num_errors = 0;
+  bool m_colorize;
+};
+} // namespace lldb_private
+
+swift::ASTContext *SwiftASTContext::GetASTContext() {
+  if (m_ast_context_ap.get() == NULL) {
+    m_ast_context_ap.reset(
+        new swift::ASTContext(GetLanguageOptions(), GetSearchPathOptions(),
+                              GetSourceManager(), GetDiagnosticEngine()));
+    m_diagnostic_consumer_ap.reset(new StoringDiagnosticConsumer(*this));
+
+    if (getenv("LLDB_SWIFT_DUMP_DIAGS")) {
+      // NOTE: leaking a swift::PrintingDiagnosticConsumer() here, but this only
+      // gets enabled when the above environment variable is set.
+      GetDiagnosticEngine().addConsumer(
+          *new swift::PrintingDiagnosticConsumer());
+    }
+    // Install the serialized module loader
+
+    std::unique_ptr<swift::ModuleLoader> serialized_module_loader_ap(
+        swift::SerializedModuleLoader::create(*m_ast_context_ap));
+
+    if (serialized_module_loader_ap) {
+      m_serialized_module_loader =
+          (swift::SerializedModuleLoader *)serialized_module_loader_ap.get();
+      m_ast_context_ap->addModuleLoader(std::move(serialized_module_loader_ap));
+    }
+
+    GetASTMap().Insert(m_ast_context_ap.get(), this);
+
+    // Store common useful manglings for quick lookup - this also ensures that
+    // types that didn't come out of the visitor (e.g. fallback ObjCPointers)
+    // still exist in our tables for later mangled name retrieval
+    // (the expression parser needs to do this).
+    CacheDemangledType(
+        ConstString(
+            SwiftLanguageRuntime::GetCurrentMangledName("_TtBO").c_str())
+            .GetCString(),
+        m_ast_context_ap->TheUnknownObjectType.getPointer());
+    CacheDemangledType(
+        ConstString(
+            SwiftLanguageRuntime::GetCurrentMangledName("_TtBp").c_str())
+            .GetCString(),
+        m_ast_context_ap->TheRawPointerType.getPointer());
+    CacheDemangledType(
+        ConstString(
+            SwiftLanguageRuntime::GetCurrentMangledName("_TtBb").c_str())
+            .GetCString(),
+        m_ast_context_ap->TheBridgeObjectType.getPointer());
+    CacheDemangledType(
+        ConstString(
+            SwiftLanguageRuntime::GetCurrentMangledName("_TtBo").c_str())
+            .GetCString(),
+        m_ast_context_ap->TheNativeObjectType.getPointer());
+    CacheDemangledType(
+        ConstString(
+            SwiftLanguageRuntime::GetCurrentMangledName("_TtT_").c_str())
+            .GetCString(),
+        m_ast_context_ap->TheEmptyTupleType.getPointer());
+  }
+
+  VALID_OR_RETURN(nullptr);
+
+  return m_ast_context_ap.get();
+}
+
+swift::SerializedModuleLoader *SwiftASTContext::GetSerializeModuleLoader() {
+  VALID_OR_RETURN(nullptr);
+
+  GetASTContext();
+  return m_serialized_module_loader;
+}
+
+swift::ClangImporter *SwiftASTContext::GetClangImporter() {
+  VALID_OR_RETURN(nullptr);
+
+  if (m_clang_importer == NULL) {
+    swift::ASTContext *ast_ctx = GetASTContext();
+
+    if (!ast_ctx) {
+      return nullptr;
+    }
+
+    // Install the Clang module loader
+    TargetSP target_sp(m_target_wp.lock());
+    if (true /*target_sp*/) {
+      // PlatformSP platform_sp = target_sp->GetPlatform();
+      if (true /*platform_sp*/) {
+        if (!ast_ctx->SearchPathOpts.SDKPath.empty() || TargetHasNoSDK()) {
+          swift::ClangImporterOptions &clang_importer_options =
+              GetClangImporterOptions();
+          if (!clang_importer_options.OverrideResourceDir.empty()) {
+            std::unique_ptr<swift::ModuleLoader> clang_importer_ap(
+                swift::ClangImporter::create(*m_ast_context_ap,
+                                             clang_importer_options));
+
+            if (clang_importer_ap) {
+              const bool isClang = true;
+              m_clang_importer =
+                  (swift::ClangImporter *)clang_importer_ap.get();
+              m_ast_context_ap->addModuleLoader(std::move(clang_importer_ap),
+                                                isClang);
+            }
+          }
+        }
+      }
+    }
+  }
+  return m_clang_importer;
+}
+
+bool SwiftASTContext::AddModuleSearchPath(const char *path) {
+  VALID_OR_RETURN(false);
+
+  if (path && path[0]) {
+    swift::ASTContext *ast = GetASTContext();
+    std::string path_str(path);
+    bool add_search_path = true;
+    for (auto path : ast->SearchPathOpts.ImportSearchPaths) {
+      if (path == path_str) {
+        add_search_path = false;
+        break;
+      }
+    }
+
+    if (add_search_path) {
+      ast->SearchPathOpts.ImportSearchPaths.push_back(path);
+      return true;
+    }
+  }
+  return false;
+}
+
+bool SwiftASTContext::AddFrameworkSearchPath(const char *path) {
+  VALID_OR_RETURN(false);
+
+  if (path && path[0]) {
+    swift::ASTContext *ast = GetASTContext();
+    std::string path_str(path);
+    bool add_search_path = true;
+    for (const auto &swift_path : ast->SearchPathOpts.FrameworkSearchPaths) {
+      if (swift_path.Path == path_str) {
+        add_search_path = false;
+        break;
+      }
+    }
+
+    if (add_search_path) {
+      ast->SearchPathOpts.FrameworkSearchPaths.push_back(
+          {path, /*isSystem=*/false});
+      return true;
+    }
+  }
+  return false;
+}
+
+bool SwiftASTContext::AddClangArgument(const char *clang_arg, bool force) {
+  if (clang_arg && clang_arg[0]) {
+    swift::ClangImporterOptions &importer_options = GetClangImporterOptions();
+
+    bool add_hmap = true;
+
+    if (!force) {
+      for (std::string &arg : importer_options.ExtraArgs) {
+        if (!arg.compare(clang_arg)) {
+          add_hmap = false;
+          break;
+        }
+      }
+    }
+
+    if (add_hmap) {
+      importer_options.ExtraArgs.push_back(clang_arg);
+      return true;
+    }
+  }
+  return false;
+}
+
+bool SwiftASTContext::AddClangArgumentPair(const char *clang_arg_1,
+                                           const char *clang_arg_2) {
+  if (clang_arg_1 && clang_arg_2 && clang_arg_1[0] && clang_arg_2[0]) {
+    swift::ClangImporterOptions &importer_options = GetClangImporterOptions();
+
+    bool add_hmap = true;
+
+    for (ssize_t ai = 0, ae = importer_options.ExtraArgs.size() -
+                              1; // -1 because we look at the next one too
+         ai < ae; ++ai) {
+      if (!importer_options.ExtraArgs[ai].compare(clang_arg_1) &&
+          !importer_options.ExtraArgs[ai + 1].compare(clang_arg_2)) {
+        add_hmap = false;
+        break;
+      }
+    }
+
+    if (add_hmap) {
+      importer_options.ExtraArgs.push_back(clang_arg_1);
+      importer_options.ExtraArgs.push_back(clang_arg_2);
+      return true;
+    }
+  }
+  return false;
+}
+
+size_t SwiftASTContext::GetNumModuleSearchPaths() const {
+  VALID_OR_RETURN(0);
+
+  if (m_ast_context_ap.get())
+    return m_ast_context_ap->SearchPathOpts.ImportSearchPaths.size();
+  return 0;
+}
+
+const char *SwiftASTContext::GetModuleSearchPathAtIndex(size_t idx) const {
+  VALID_OR_RETURN(nullptr);
+
+  if (m_ast_context_ap.get()) {
+    if (idx < m_ast_context_ap->SearchPathOpts.ImportSearchPaths.size())
+      return m_ast_context_ap->SearchPathOpts.ImportSearchPaths[idx].c_str();
+  }
+  return NULL;
+}
+
+size_t SwiftASTContext::GetNumFrameworkSearchPaths() const {
+  VALID_OR_RETURN(0);
+
+  if (m_ast_context_ap.get())
+    return m_ast_context_ap->SearchPathOpts.FrameworkSearchPaths.size();
+  return 0;
+}
+
+const char *SwiftASTContext::GetFrameworkSearchPathAtIndex(size_t idx) const {
+  VALID_OR_RETURN(nullptr);
+
+  if (m_ast_context_ap.get()) {
+    if (idx < m_ast_context_ap->SearchPathOpts.FrameworkSearchPaths.size())
+      return m_ast_context_ap->SearchPathOpts.FrameworkSearchPaths[idx]
+          .Path.c_str();
+  }
+  return NULL;
+}
+
+size_t SwiftASTContext::GetNumClangArguments() {
+  swift::ClangImporterOptions &importer_options = GetClangImporterOptions();
+
+  return importer_options.ExtraArgs.size();
+}
+
+const char *SwiftASTContext::GetClangArgumentAtIndex(size_t idx) {
+  swift::ClangImporterOptions &importer_options = GetClangImporterOptions();
+
+  if (idx < importer_options.ExtraArgs.size())
+    return importer_options.ExtraArgs[idx].c_str();
+
+  return NULL;
+}
+
+swift::ModuleDecl *
+SwiftASTContext::GetCachedModule(const ConstString &module_name) {
+  VALID_OR_RETURN(nullptr);
+
+  SwiftModuleMap::const_iterator iter =
+      m_swift_module_cache.find(module_name.GetCString());
+
+  if (iter != m_swift_module_cache.end())
+    return iter->second;
+  return NULL;
+}
+
+swift::ModuleDecl *
+SwiftASTContext::CreateModule(const ConstString &module_basename,
+                              Status &error) {
+  VALID_OR_RETURN(nullptr);
+
+  if (module_basename) {
+    swift::ModuleDecl *module = GetCachedModule(module_basename);
+    if (module) {
+      error.SetErrorStringWithFormat("module already exists for '%s'",
+                                     module_basename.GetCString());
+      return NULL;
+    }
+
+    swift::ASTContext *ast = GetASTContext();
+    if (ast) {
+      swift::Identifier module_id(
+          ast->getIdentifier(module_basename.GetCString()));
+      module = swift::ModuleDecl::create(module_id, *ast);
+      if (module) {
+        m_swift_module_cache[module_basename.GetCString()] = module;
+        return module;
+      } else {
+        error.SetErrorStringWithFormat("invalid swift AST (NULL)");
+      }
+    } else {
+      error.SetErrorStringWithFormat("invalid swift AST (NULL)");
+    }
+  } else {
+    error.SetErrorStringWithFormat("invalid module name (empty)");
+  }
+  return NULL;
+}
+
+void SwiftASTContext::CacheModule(swift::ModuleDecl *module) {
+  VALID_OR_RETURN_VOID();
+
+  if (!module)
+    return;
+  auto ID = module->getName().get();
+  if (nullptr == ID || 0 == ID[0])
+    return;
+  if (m_swift_module_cache.find(ID) != m_swift_module_cache.end())
+    return;
+  m_swift_module_cache.insert({ID, module});
+}
+
+swift::ModuleDecl *
+SwiftASTContext::GetModule(const ConstString &module_basename, Status &error) {
+  VALID_OR_RETURN(nullptr);
+
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+  if (log)
+    log->Printf("((SwiftASTContext*)%p)->GetModule('%s')", this,
+                module_basename.AsCString("<no name>"));
+
+  if (module_basename) {
+    swift::ModuleDecl *module = GetCachedModule(module_basename);
+    if (module)
+      return module;
+    if (swift::ASTContext *ast = GetASTContext()) {
+      typedef std::pair<swift::Identifier, swift::SourceLoc> ModuleNameSpec;
+      llvm::StringRef module_basename_sref(module_basename.GetCString());
+      ModuleNameSpec name_pair(ast->getIdentifier(module_basename_sref),
+                               swift::SourceLoc());
+
+      if (HasFatalErrors()) {
+        error.SetErrorStringWithFormat("failed to get module '%s' from AST "
+                                       "context:\nAST context is in a fatal "
+                                       "error state",
+                                       module_basename.GetCString());
+        printf("error in SwiftASTContext::GetModule(%s): AST context is in a "
+               "fatal error stat",
+               module_basename.GetCString());
+        return nullptr;
+      }
+
+      ClearDiagnostics();
+
+      module = ast->getModuleByName(module_basename_sref);
+
+      if (HasErrors()) {
+        DiagnosticManager diagnostic_manager;
+        PrintDiagnostics(diagnostic_manager);
+        error.SetErrorStringWithFormat(
+            "failed to get module '%s' from AST context:\n%s",
+            module_basename.GetCString(),
+            diagnostic_manager.GetString().data());
+#ifdef LLDB_CONFIGURATION_DEBUG
+        printf("error in SwiftASTContext::GetModule(%s): '%s'",
+               module_basename.GetCString(),
+               diagnostic_manager.GetString().data());
+#endif
+        if (log)
+          log->Printf("((SwiftASTContext*)%p)->GetModule('%s') -- error: %s",
+                      this, module_basename.GetCString(),
+                      diagnostic_manager.GetString().data());
+      } else if (module) {
+        if (log)
+          log->Printf("((SwiftASTContext*)%p)->GetModule('%s') -- found %s",
+                      this, module_basename.GetCString(),
+                      module->getName().str().str().c_str());
+
+        m_swift_module_cache[module_basename.GetCString()] = module;
+        return module;
+      } else {
+        if (log)
+          log->Printf(
+              "((SwiftASTContext*)%p)->GetModule('%s') -- failed with no error",
+              this, module_basename.GetCString());
+
+        error.SetErrorStringWithFormat(
+            "failed to get module '%s' from AST context",
+            module_basename.GetCString());
+      }
+    } else {
+      if (log)
+        log->Printf(
+            "((SwiftASTContext*)%p)->GetModule('%s') -- invalid ASTContext",
+            this, module_basename.GetCString());
+
+      error.SetErrorString("invalid swift::ASTContext");
+    }
+  } else {
+    if (log)
+      log->Printf(
+          "((SwiftASTContext*)%p)->GetModule('%s') -- empty module name", this,
+          module_basename.GetCString());
+
+    error.SetErrorString("invalid module name (empty)");
+  }
+  return NULL;
+}
+
+swift::ModuleDecl *SwiftASTContext::GetModule(const FileSpec &module_spec,
+                                              Status &error) {
+  VALID_OR_RETURN(nullptr);
+
+  ConstString module_basename(module_spec.GetFileNameStrippingExtension());
+
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+  if (log)
+    log->Printf("((SwiftASTContext*)%p)->GetModule((FileSpec)'%s')", this,
+                module_spec.GetPath().c_str());
+
+  if (module_basename) {
+    SwiftModuleMap::const_iterator iter =
+        m_swift_module_cache.find(module_basename.GetCString());
+
+    if (iter != m_swift_module_cache.end())
+      return iter->second;
+
+    if (module_spec.Exists()) {
+      swift::ASTContext *ast = GetASTContext();
+      if (!GetClangImporter()) {
+        if (log)
+          log->Printf("((SwiftASTContext*)%p)->GetModule((FileSpec)'%s') -- no "
+                      "ClangImporter so giving up",
+                      this, module_spec.GetPath().c_str());
+        error.SetErrorStringWithFormat("couldn't get a ClangImporter");
+        return nullptr;
+      }
+
+      std::string module_directory(module_spec.GetDirectory().GetCString());
+      bool add_search_path = true;
+      for (auto path : ast->SearchPathOpts.ImportSearchPaths) {
+        if (path == module_directory) {
+          add_search_path = false;
+          break;
+        }
+      }
+      // Add the search path if needed so we can find the module by basename
+      if (add_search_path)
+        ast->SearchPathOpts.ImportSearchPaths.push_back(
+            std::move(module_directory));
+
+      typedef std::pair<swift::Identifier, swift::SourceLoc> ModuleNameSpec;
+      llvm::StringRef module_basename_sref(module_basename.GetCString());
+      ModuleNameSpec name_pair(ast->getIdentifier(module_basename_sref),
+                               swift::SourceLoc());
+      swift::ModuleDecl *module =
+          ast->getModule(llvm::ArrayRef<ModuleNameSpec>(name_pair));
+      if (module) {
+        if (log)
+          log->Printf(
+              "((SwiftASTContext*)%p)->GetModule((FileSpec)'%s') -- found %s",
+              this, module_spec.GetPath().c_str(),
+              module->getName().str().str().c_str());
+
+        m_swift_module_cache[module_basename.GetCString()] = module;
+        return module;
+      } else {
+        if (log)
+          log->Printf("((SwiftASTContext*)%p)->GetModule((FileSpec)'%s') -- "
+                      "couldn't get from AST context",
+                      this, module_spec.GetPath().c_str());
+
+        error.SetErrorStringWithFormat(
+            "failed to get module '%s' from AST context",
+            module_basename.GetCString());
+      }
+    } else {
+      if (log)
+        log->Printf("((SwiftASTContext*)%p)->GetModule((FileSpec)'%s') -- "
+                    "doesn't exist",
+                    this, module_spec.GetPath().c_str());
+
+      error.SetErrorStringWithFormat("module '%s' doesn't exist",
+                                     module_spec.GetPath().c_str());
+    }
+  } else {
+    if (log)
+      log->Printf(
+          "((SwiftASTContext*)%p)->GetModule((FileSpec)'%s') -- no basename",
+          this, module_spec.GetPath().c_str());
+
+    error.SetErrorStringWithFormat("no module basename in '%s'",
+                                   module_spec.GetPath().c_str());
+  }
+  return NULL;
+}
+
+swift::ModuleDecl *
+SwiftASTContext::FindAndLoadModule(const ConstString &module_basename,
+                                   Process &process, Status &error) {
+  VALID_OR_RETURN(nullptr);
+
+  swift::ModuleDecl *swift_module = GetModule(module_basename, error);
+  if (!swift_module)
+    return nullptr;
+  LoadModule(swift_module, process, error);
+  return swift_module;
+}
+
+swift::ModuleDecl *
+SwiftASTContext::FindAndLoadModule(const FileSpec &module_spec,
+                                   Process &process, Status &error) {
+  VALID_OR_RETURN(nullptr);
+
+  swift::ModuleDecl *swift_module = GetModule(module_spec, error);
+  if (!swift_module)
+    return nullptr;
+  LoadModule(swift_module, process, error);
+  return swift_module;
+}
+
+bool SwiftASTContext::LoadOneImage(Process &process, FileSpec &link_lib_spec,
+                                   Status &error) {
+  VALID_OR_RETURN(false);
+
+  error.Clear();
+
+  PlatformSP platform_sp = process.GetTarget().GetPlatform();
+  if (platform_sp)
+    return platform_sp->LoadImage(&process, FileSpec(), link_lib_spec, error) !=
+           LLDB_INVALID_IMAGE_TOKEN;
+  else
+    return false;
+}
+
+static void
+GetLibrarySearchPaths(std::vector<std::string> &paths,
+                      const swift::SearchPathOptions &search_path_opts) {
+  paths.clear();
+  paths.resize(search_path_opts.LibrarySearchPaths.size() + 1);
+  std::copy(search_path_opts.LibrarySearchPaths.begin(),
+            search_path_opts.LibrarySearchPaths.end(), paths.begin());
+  paths.push_back(search_path_opts.RuntimeLibraryPath);
+}
+
+void SwiftASTContext::LoadModule(swift::ModuleDecl *swift_module,
+                                 Process &process, Status &error) {
+  VALID_OR_RETURN_VOID();
+
+  Status current_error;
+  auto addLinkLibrary = [&](swift::LinkLibrary link_lib) {
+    Status load_image_error;
+    StreamString all_dlopen_errors;
+    const char *library_name = link_lib.getName().data();
+
+    if (library_name == NULL || library_name[0] == '\0') {
+      error.SetErrorString("Empty library name passed to addLinkLibrary");
+      return;
+    }
+
+    SwiftLanguageRuntime *runtime = process.GetSwiftLanguageRuntime();
+
+    if (runtime && runtime->IsInLibraryNegativeCache(library_name))
+      return;
+
+    swift::LibraryKind library_kind = link_lib.getKind();
+
+    Log *log(GetLogIfAnyCategoriesSet(LIBLLDB_LOG_TYPES));
+    if (log)
+      log->Printf("\nLoading link library \"%s\" of kind: %d.", library_name,
+                  library_kind);
+
+    switch (library_kind) {
+    case swift::LibraryKind::Framework: {
+
+      // First make sure the library isn't already loaded. Since this is a
+      // framework, we make sure the file name and the framework name are the
+      // same, and that we are contained in FileName.framework with no other
+      // intervening frameworks.  We can get more restrictive if this gives
+      // false positives.
+
+      ConstString library_cstr(library_name);
+
+      std::string framework_name(library_name);
+      framework_name.append(".framework");
+
+      // Lookup the module by file basename and make sure that basename has
+      // "<basename>.framework" in the path.
+
+      ModuleSpec module_spec;
+      module_spec.GetFileSpec().GetFilename() = library_cstr;
+      lldb_private::ModuleList matching_module_list;
+      bool module_already_loaded = false;
+      if (process.GetTarget().GetImages().FindModules(module_spec,
+                                                      matching_module_list)) {
+        matching_module_list.ForEach(
+            [&module_already_loaded, &module_spec,
+             &framework_name](const ModuleSP &module_sp) -> bool {
+              module_already_loaded = module_spec.GetFileSpec().GetPath().find(
+                                          framework_name) != std::string::npos;
+              return module_already_loaded ==
+                     false; // Keep iterating if we didn't find the right module
+            });
+      }
+      // If we already have this library loaded, don't try and load it again.
+      if (module_already_loaded) {
+        if (log)
+          log->Printf("Skipping load of %s as it is already loaded.",
+                      framework_name.c_str());
+        return;
+      }
+
+      for (auto module : process.GetTarget().GetImages().Modules()) {
+        FileSpec module_file = module->GetFileSpec();
+        if (module_file.GetFilename() == library_cstr) {
+          std::string module_path = module_file.GetPath();
+
+          size_t framework_offset = module_path.rfind(framework_name);
+
+          if (framework_offset != std::string::npos) {
+            // The Framework is already loaded, so we don't need to try to load
+            // it again.
+            if (log)
+              log->Printf("Skipping load of %s as it is already loaded.",
+                          framework_name.c_str());
+            return;
+          }
+        }
+      }
+
+      std::string framework_path("@rpath/");
+      framework_path.append(library_name);
+      framework_path.append(".framework/");
+      framework_path.append(library_name);
+      FileSpec framework_spec(framework_path.c_str(), false);
+
+      if (LoadOneImage(process, framework_spec, load_image_error)) {
+        if (log)
+          log->Printf("Found framework at: %s.", framework_path.c_str());
+
+        return;
+      } else
+        all_dlopen_errors.Printf("Looking for \"%s\", error: %s\n",
+                                 framework_path.c_str(),
+                                 load_image_error.AsCString());
+
+      // And then in the various framework search paths.
+      std::unordered_set<std::string> seen_paths;
+      for (const auto &framework_search_dir :
+           swift_module->getASTContext().SearchPathOpts.FrameworkSearchPaths) {
+        // The framework search dir as it comes from the AST context often has
+        // duplicate entries, don't try to load along the same path twice.
+
+        std::pair<std::unordered_set<std::string>::iterator, bool>
+            insert_result = seen_paths.insert(framework_search_dir.Path);
+        if (!insert_result.second)
+          continue;
+
+        framework_path = framework_search_dir.Path;
+        framework_path.append("/");
+        framework_path.append(library_name);
+        framework_path.append(".framework/");
+        framework_path.append(library_name);
+        framework_spec.SetFile(framework_path.c_str(), false);
+
+        if (LoadOneImage(process, framework_spec, load_image_error)) {
+          if (log)
+            log->Printf("Found framework at: %s.", framework_path.c_str());
+
+          return;
+        } else
+          all_dlopen_errors.Printf("Looking for \"%s\"\n,    error: %s\n",
+                                   framework_path.c_str(),
+                                   load_image_error.AsCString());
+      }
+
+      // Maybe we were told to add a link library that exists in the system.  I
+      // tried just specifying Foo.framework/Foo and letting the system search
+      // figure that out, but if DYLD_FRAMEWORK_FALLBACK_PATH is set
+      // (e.g. in Xcode's test scheme) then these aren't found. So for now I
+      // dial them in explicitly:
+
+      std::string system_path("/System/Library/Frameworks/");
+      system_path.append(library_name);
+      system_path.append(".framework/");
+      system_path.append(library_name);
+      framework_spec.SetFile(system_path.c_str(), true);
+      if (LoadOneImage(process, framework_spec, load_image_error))
+        return;
+      else
+        all_dlopen_errors.Printf("Looking for \"%s\"\n,    error: %s\n",
+                                 framework_path.c_str(),
+                                 load_image_error.AsCString());
+    } break;
+    case swift::LibraryKind::Library: {
+      std::vector<std::string> search_paths;
+
+      GetLibrarySearchPaths(search_paths,
+                            swift_module->getASTContext().SearchPathOpts);
+
+      if (LoadLibraryUsingPaths(process, library_name, search_paths, true,
+                                all_dlopen_errors))
+        return;
+    } break;
+    }
+
+    // If we get here, we aren't going to find this image, so add it to a
+    // negative cache:
+    if (runtime)
+      runtime->AddToLibraryNegativeCache(library_name);
+
+    current_error.SetErrorStringWithFormat(
+        "Failed to load linked library %s of module %s - errors:\n%s\n",
+        library_name, swift_module->getName().str().str().c_str(),
+        all_dlopen_errors.GetData());
+  };
+
+  swift_module->forAllVisibleModules(
+      {},
+      true, // includePrivateTopLevel
+      [&](swift::ModuleDecl::ImportedModule import) {
+        import.second->collectLinkLibraries(addLinkLibrary);
+      });
+  error = current_error;
+}
+
+bool SwiftASTContext::LoadLibraryUsingPaths(
+    Process &process, llvm::StringRef library_name,
+    std::vector<std::string> &search_paths, bool check_rpath,
+    StreamString &all_dlopen_errors) {
+  VALID_OR_RETURN(false);
+
+  Log *log(GetLogIfAnyCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  SwiftLanguageRuntime *runtime = process.GetSwiftLanguageRuntime();
+  if (!runtime) {
+    all_dlopen_errors.PutCString(
+        "Can't load Swift libraries without a language runtime.");
+    return false;
+  }
+
+  if (ConstString::Equals(runtime->GetStandardLibraryBaseName(),
+                          ConstString(library_name))) {
+    // Never dlopen the standard library. Some binaries statically link to the
+    // Swift standard library and dlopening it here will cause ObjC runtime
+    // conflicts.
+    // If you want to run Swift expressions you have to arrange to load the
+    // Swift standard library by hand before doing so.
+    if (log)
+      log->Printf("Skipping swift standard library \"%s\" - we don't hand load "
+                  "that one.",
+                  runtime->GetStandardLibraryBaseName().AsCString());
+    return true;
+  }
+
+  PlatformSP platform_sp(process.GetTarget().GetPlatform());
+
+  std::string library_fullname;
+
+  if (platform_sp) {
+    library_fullname =
+        platform_sp->GetFullNameForDylib(ConstString(library_name)).AsCString();
+  } else // This is the old way, and we shouldn't use it except on Mac OS
+  {
+#ifdef __APPLE__
+    library_fullname = "lib";
+    library_fullname.append(library_name);
+    library_fullname.append(".dylib");
+#else
+    return false;
+#endif
+  }
+
+  ModuleSpec module_spec;
+  module_spec.GetFileSpec().GetFilename().SetCString(library_fullname.c_str());
+  lldb_private::ModuleList matching_module_list;
+
+  if (process.GetTarget().GetImages().FindModules(module_spec,
+                                                  matching_module_list) > 0) {
+    if (log)
+      log->Printf("Skipping module %s as it is already loaded.",
+                  library_fullname.c_str());
+    return true;
+  }
+
+  FileSpec library_spec;
+  std::string library_path;
+  std::unordered_set<std::string> seen_paths;
+  Status load_image_error;
+
+  for (const std::string &library_search_dir : search_paths) {
+    // The library search dir as it comes from the AST context often has
+    // duplicate entries, don't try to load along the same path twice.
+
+    std::pair<std::unordered_set<std::string>::iterator, bool> insert_result =
+        seen_paths.insert(library_search_dir);
+    if (!insert_result.second)
+      continue;
+
+    library_path = library_search_dir;
+    library_path.append("/");
+    library_path.append(library_fullname);
+    library_spec.SetFile(library_path.c_str(), false);
+    if (LoadOneImage(process, library_spec, load_image_error)) {
+      if (log)
+        log->Printf("Found library at: %s.", library_path.c_str());
+      return true;
+    } else
+      all_dlopen_errors.Printf("Looking for \"%s\"\n,    error: %s\n",
+                               library_path.c_str(),
+                               load_image_error.AsCString());
+  }
+
+  if (check_rpath) {
+    // Let our RPATH help us out when finding the right library
+    library_path = "@rpath/";
+    library_path += library_fullname;
+
+    FileSpec link_lib_spec(library_path.c_str(), false);
+
+    if (LoadOneImage(process, link_lib_spec, load_image_error)) {
+      if (log)
+        log->Printf("Found library at: %s.", library_path.c_str());
+      return true;
+    } else
+      all_dlopen_errors.Printf("Looking for \"%s\", error: %s\n",
+                               library_path.c_str(),
+                               load_image_error.AsCString());
+  }
+  return false;
+}
+
+void SwiftASTContext::LoadExtraDylibs(Process &process, Status &error) {
+  VALID_OR_RETURN_VOID();
+
+  error.Clear();
+  swift::IRGenOptions &irgen_options = GetIRGenOptions();
+  for (const swift::LinkLibrary &link_lib : irgen_options.LinkLibraries) {
+    // We don't have to do frameworks here, they actually record their link
+    // libraries properly.
+    if (link_lib.getKind() == swift::LibraryKind::Library) {
+      const char *library_name = link_lib.getName().data();
+      StreamString errors;
+
+      std::vector<std::string> search_paths;
+
+      GetLibrarySearchPaths(search_paths,
+                            m_compiler_invocation_ap->getSearchPathOptions());
+
+      bool success = LoadLibraryUsingPaths(process, library_name, search_paths,
+                                           false, errors);
+      if (!success) {
+        error.SetErrorString(errors.GetData());
+      }
+    }
+  }
+}
+
+bool SwiftASTContext::RegisterSectionModules(
+    Module &module, std::vector<std::string> &module_names) {
+  VALID_OR_RETURN(false);
+
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  swift::SerializedModuleLoader *sml = GetSerializeModuleLoader();
+  if (sml) {
+    SectionList *section_list = module.GetSectionList();
+    if (section_list) {
+      SectionSP section_sp(
+          section_list->FindSectionByType(eSectionTypeSwiftModules, true));
+      if (section_sp) {
+        DataExtractor section_data;
+
+        if (section_sp->GetSectionData(section_data)) {
+          llvm::StringRef section_data_ref(
+              (const char *)section_data.GetDataStart(),
+              section_data.GetByteSize());
+          llvm::SmallVector<std::string, 4> llvm_modules;
+          if (swift::parseASTSection(sml, section_data_ref, llvm_modules)) {
+            for (auto module_name : llvm_modules)
+              module_names.push_back(module_name);
+            return true;
+          }
+        }
+      } else {
+        if (m_ast_file_data_map.find(&module) != m_ast_file_data_map.end())
+          return true;
+
+        SymbolVendor *sym_vendor = module.GetSymbolVendor();
+        if (sym_vendor) {
+          // Grab all the AST blobs from the symbol vendor.
+          auto ast_file_datas = sym_vendor->GetASTData(eLanguageTypeSwift);
+          if (log)
+            log->Printf("SwiftASTContext::%s() retrieved %zu AST Data blobs "
+                        "from the symbol vendor.",
+                        __FUNCTION__, ast_file_datas.size());
+
+          // Add each of the AST blobs to the vector of AST blobs for the
+          // module.
+          auto &ast_vector = GetASTVectorForModule(&module);
+          ast_vector.insert(ast_vector.end(), ast_file_datas.begin(),
+                            ast_file_datas.end());
+
+          // Retrieve the module names from the AST blobs retrieved from the
+          // symbol vendor.
+          size_t parse_fail_count = 0;
+          size_t ast_number = 0;
+          for (auto ast_file_data_sp : ast_file_datas) {
+            // Parse the AST section info from the AST blob.
+            ++ast_number;
+            llvm::StringRef section_data_ref(
+                (const char *)ast_file_data_sp->GetBytes(),
+                ast_file_data_sp->GetByteSize());
+            llvm::SmallVector<std::string, 4> llvm_modules;
+            if (swift::parseASTSection(sml, section_data_ref, llvm_modules)) {
+              // Collect the LLVM module names referenced by the AST.
+              for (auto module_name : llvm_modules)
+                module_names.push_back(module_name);
+              if (log)
+                log->Printf("SwiftASTContext::%s() - parsed %zu llvm modules "
+                            "from Swift AST section %zu of %zu.",
+                            __FUNCTION__, llvm_modules.size(), ast_number,
+                            ast_file_datas.size());
+            } else {
+              // Keep track of the fact that we failed to parse the AST
+              // section info.
+              if (log)
+                log->Printf("SwiftASTContext::%s() - failed to parse AST "
+                            "section %zu of %zu.",
+                            __FUNCTION__, ast_number, ast_file_datas.size());
+              ++parse_fail_count;
+            }
+          }
+          if (!ast_file_datas.empty() && (parse_fail_count == 0)) {
+            // We found AST data entries and we successfully parsed all of
+            // them.
+            return true;
+          }
+        }
+      }
+    }
+  }
+  return false;
+}
+
+void SwiftASTContext::ValidateSectionModules(
+    Module &module, const std::vector<std::string> &module_names) {
+  VALID_OR_RETURN_VOID();
+
+  Status error;
+
+  for (const std::string &module_name : module_names)
+    if (!GetModule(ConstString(module_name.c_str()), error))
+      module.ReportWarning("unable to load swift module '%s' (%s)",
+                           module_name.c_str(), error.AsCString());
+}
+
+swift::Identifier SwiftASTContext::GetIdentifier(const char *name) {
+  VALID_OR_RETURN(swift::Identifier());
+
+  return GetASTContext()->getIdentifier(llvm::StringRef(name));
+}
+
+swift::Identifier SwiftASTContext::GetIdentifier(const llvm::StringRef &name) {
+  VALID_OR_RETURN(swift::Identifier());
+
+  return GetASTContext()->getIdentifier(name);
+}
+
+ConstString SwiftASTContext::GetMangledTypeName(swift::TypeBase *type_base) {
+  VALID_OR_RETURN(ConstString());
+
+  auto iter = m_type_to_mangled_name_map.find(type_base),
+       end = m_type_to_mangled_name_map.end();
+  if (iter != end)
+    return ConstString(iter->second);
+
+  swift::Type swift_type(type_base);
+
+  bool has_archetypes = swift_type->hasArchetype();
+
+  if (!has_archetypes) {
+    swift::Mangle::ASTMangler mangler(true);
+    std::string s = mangler.mangleTypeForDebugger(swift_type, nullptr, nullptr);
+
+    if (!s.empty()) {
+      ConstString mangled_cs(s.c_str());
+      CacheDemangledType(mangled_cs.AsCString(), type_base);
+      return mangled_cs;
+    }
+  }
+
+  return ConstString();
+}
+
+void SwiftASTContext::CacheDemangledType(const char *name,
+                                         swift::TypeBase *found_type) {
+  VALID_OR_RETURN_VOID();
+
+  m_type_to_mangled_name_map.insert(std::make_pair(found_type, name));
+  m_mangled_name_to_type_map.insert(std::make_pair(name, found_type));
+}
+
+void SwiftASTContext::CacheDemangledTypeFailure(const char *name) {
+  VALID_OR_RETURN_VOID();
+
+  m_negative_type_cache.Insert(name);
+}
+
+CompilerType
+SwiftASTContext::GetTypeFromMangledTypename(const char *mangled_typename,
+                                            Status &error) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (mangled_typename &&
+      SwiftLanguageRuntime::IsSwiftMangledName(mangled_typename)) {
+    Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+    if (log)
+      log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s')",
+                  this, mangled_typename);
+
+    swift::ASTContext *ast_ctx = GetASTContext();
+    if (!ast_ctx) {
+      if (log)
+        log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s') "
+                    "-- null Swift AST Context",
+                    this, mangled_typename);
+      error.SetErrorString("null Swift AST Context");
+      return CompilerType();
+    }
+
+    error.Clear();
+
+    // If we were to crash doing this, remember what type caused it
+    llvm::PrettyStackTraceFormat PST("error finding type for %s",
+                                     mangled_typename);
+    ConstString mangled_name(mangled_typename);
+    swift::TypeBase *found_type =
+        m_mangled_name_to_type_map.lookup(mangled_name.GetCString());
+    if (found_type) {
+      if (log)
+        log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s') "
+                    "-- found in the positive cache",
+                    this, mangled_typename);
+      return CompilerType(ast_ctx, found_type);
+    }
+
+    if (m_negative_type_cache.Lookup(mangled_name.GetCString())) {
+      if (log)
+        log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s') "
+                    "-- found in the negative cache",
+                    this, mangled_typename);
+      return CompilerType();
+    }
+
+    if (log)
+      log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s') -- "
+                  "not cached, searching",
+                  this, mangled_typename);
+
+    std::string swift_error;
+    found_type = swift::ide::getTypeFromMangledSymbolname(
+                     *ast_ctx, mangled_typename, swift_error)
+                     .getPointer();
+
+    if (found_type) {
+      CacheDemangledType(mangled_name.GetCString(), found_type);
+      CompilerType result_type(ast_ctx, found_type);
+      if (log)
+        log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s') "
+                    "-- found %s",
+                    this, mangled_typename,
+                    result_type.GetTypeName().GetCString());
+      return result_type;
+    } else {
+      if (log)
+        log->Printf("((SwiftASTContext*)%p)->GetTypeFromMangledTypename('%s') "
+                    "-- error: %s",
+                    this, mangled_typename, swift_error.c_str());
+
+      error.SetErrorStringWithFormat("type for typename '%s' was not found",
+                                     mangled_typename);
+      CacheDemangledTypeFailure(mangled_name.GetCString());
+      return CompilerType();
+    }
+  }
+  error.SetErrorStringWithFormat("typename '%s' is not a valid Swift mangled "
+                                 "typename, it should begin with _T",
+                                 mangled_typename);
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetVoidFunctionType() {
+  VALID_OR_RETURN(CompilerType());
+
+  if (!m_void_function_type) {
+    swift::ASTContext *ast = GetASTContext();
+    swift::Type empty_tuple_type(swift::TupleType::getEmpty(*ast));
+    m_void_function_type = CompilerType(
+        ast, swift::FunctionType::get(empty_tuple_type, empty_tuple_type));
+  }
+  return m_void_function_type;
+}
+
+static CompilerType ValueDeclToType(swift::ValueDecl *decl,
+                                    swift::ASTContext *ast) {
+  if (decl) {
+    switch (decl->getKind()) {
+    case swift::DeclKind::TypeAlias: {
+      swift::TypeAliasDecl *alias_decl =
+          swift::cast<swift::TypeAliasDecl>(decl);
+      if (alias_decl->hasInterfaceType()) {
+        swift::Type swift_type = alias_decl->getDeclaredInterfaceType();
+        return CompilerType(ast, swift_type.getPointer());
+      }
+      break;
+    }
+
+    case swift::DeclKind::Enum:
+    case swift::DeclKind::Struct:
+    case swift::DeclKind::Protocol:
+    case swift::DeclKind::Class: {
+      swift::NominalTypeDecl *nominal_decl =
+          swift::cast<swift::NominalTypeDecl>(decl);
+      if (nominal_decl->hasInterfaceType()) {
+        swift::Type swift_type = nominal_decl->getDeclaredType();
+        return CompilerType(ast, swift_type.getPointer());
+      }
+    } break;
+
+    default:
+      break;
+    }
+  }
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::FindQualifiedType(const char *qualified_name) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (qualified_name && qualified_name[0]) {
+    const char *dot_pos = strchr(qualified_name, '.');
+    if (dot_pos) {
+      ConstString module_name(qualified_name, dot_pos - qualified_name);
+      swift::ModuleDecl *swift_module = GetCachedModule(module_name);
+      if (swift_module) {
+        swift::ModuleDecl::AccessPathTy access_path;
+        llvm::SmallVector<swift::ValueDecl *, 4> decls;
+        const char *module_type_name = dot_pos + 1;
+        swift_module->lookupValue(access_path, GetIdentifier(module_type_name),
+                                  swift::NLKind::UnqualifiedLookup, decls);
+        for (auto decl : decls) {
+          CompilerType type = ValueDeclToType(decl, GetASTContext());
+          if (type)
+            return type;
+        }
+      }
+    }
+  }
+  return CompilerType();
+}
+
+static CompilerType DeclToType(swift::Decl *decl, swift::ASTContext *ast) {
+  if (swift::ValueDecl *value_decl =
+          swift::dyn_cast_or_null<swift::ValueDecl>(decl))
+    return ValueDeclToType(value_decl, ast);
+  return CompilerType();
+}
+
+static SwiftASTContext::TypeOrDecl DeclToTypeOrDecl(swift::ASTContext *ast,
+                                                    swift::Decl *decl) {
+  if (decl) {
+    switch (decl->getKind()) {
+    case swift::DeclKind::Import:
+    case swift::DeclKind::Extension:
+    case swift::DeclKind::PatternBinding:
+    case swift::DeclKind::TopLevelCode:
+    case swift::DeclKind::GenericTypeParam:
+    case swift::DeclKind::AssociatedType:
+    case swift::DeclKind::EnumElement:
+    case swift::DeclKind::EnumCase:
+    case swift::DeclKind::IfConfig:
+    case swift::DeclKind::Param:
+    case swift::DeclKind::Module:
+    case swift::DeclKind::MissingMember:
+      break;
+
+    case swift::DeclKind::InfixOperator:
+    case swift::DeclKind::PrefixOperator:
+    case swift::DeclKind::PostfixOperator:
+    case swift::DeclKind::PrecedenceGroup:
+      return decl;
+
+    case swift::DeclKind::TypeAlias: {
+      swift::TypeAliasDecl *alias_decl =
+          swift::cast<swift::TypeAliasDecl>(decl);
+      if (alias_decl->hasInterfaceType()) {
+        swift::Type swift_type = alias_decl->getDeclaredInterfaceType();
+        return CompilerType(ast, swift_type.getPointer());
+      }
+    } break;
+    case swift::DeclKind::Enum:
+    case swift::DeclKind::Struct:
+    case swift::DeclKind::Class:
+    case swift::DeclKind::Protocol: {
+      swift::NominalTypeDecl *nominal_decl =
+          swift::cast<swift::NominalTypeDecl>(decl);
+      if (nominal_decl->hasInterfaceType()) {
+        swift::Type swift_type = nominal_decl->getDeclaredType();
+        return CompilerType(ast, swift_type.getPointer());
+      }
+    } break;
+
+    case swift::DeclKind::Func:
+    case swift::DeclKind::Var:
+      return decl;
+
+    case swift::DeclKind::Subscript:
+    case swift::DeclKind::Constructor:
+    case swift::DeclKind::Destructor:
+      break;
+    }
+  }
+  return CompilerType();
+}
+
+size_t SwiftASTContext::FindContainedType(llvm::StringRef name,
+                                          CompilerType container_type,
+                                          std::set<CompilerType> &results,
+                                          bool append) {
+  VALID_OR_RETURN(0);
+
+  if (!append)
+    results.clear();
+
+  size_t size_before = results.size();
+
+  TypesOrDecls types_or_decl_results;
+  FindContainedTypeOrDecl(name, container_type, types_or_decl_results);
+
+  for (const auto &result : types_or_decl_results) {
+    CompilerType type = result.Apply<CompilerType>(
+        [](CompilerType type) -> CompilerType { return type; },
+        [this](swift::Decl *decl) -> CompilerType {
+          return DeclToType(decl, GetASTContext());
+        });
+    results.emplace(type);
+  }
+
+  return results.size() - size_before;
+}
+
+size_t
+SwiftASTContext::FindContainedTypeOrDecl(llvm::StringRef name,
+                                         TypeOrDecl container_type_or_decl,
+                                         TypesOrDecls &results, bool append) {
+  VALID_OR_RETURN(0);
+
+  if (!append)
+    results.clear();
+  size_t size_before = results.size();
+
+  CompilerType container_type = container_type_or_decl.Apply<CompilerType>(
+      [](CompilerType type) -> CompilerType { return type; },
+      [this](swift::Decl *decl) -> CompilerType {
+        return DeclToType(decl, GetASTContext());
+      });
+
+  if (false == name.empty() &&
+      llvm::dyn_cast_or_null<SwiftASTContext>(container_type.GetTypeSystem())) {
+    swift::Type swift_type(GetSwiftType(container_type));
+    if (!swift_type)
+      return 0;
+    swift::CanType swift_can_type(swift_type->getCanonicalType());
+    swift::NominalType *nominal_type =
+        swift_can_type->getAs<swift::NominalType>();
+    if (!nominal_type)
+      return 0;
+    swift::NominalTypeDecl *nominal_decl = nominal_type->getDecl();
+    llvm::ArrayRef<swift::ValueDecl *> decls = nominal_decl->lookupDirect(
+        swift::DeclName(m_ast_context_ap->getIdentifier(name)));
+    for (auto decl : decls)
+      results.emplace(DeclToTypeOrDecl(GetASTContext(), decl));
+  }
+  return results.size() - size_before;
+}
+
+CompilerType SwiftASTContext::FindType(const char *name,
+                                       swift::ModuleDecl *swift_module) {
+  VALID_OR_RETURN(CompilerType());
+
+  std::set<CompilerType> search_results;
+
+  FindTypes(name, swift_module, search_results, false);
+
+  if (search_results.empty())
+    return CompilerType();
+  else
+    return *search_results.begin();
+}
+
+llvm::Optional<SwiftASTContext::TypeOrDecl>
+SwiftASTContext::FindTypeOrDecl(const char *name,
+                                swift::ModuleDecl *swift_module) {
+  VALID_OR_RETURN(llvm::Optional<SwiftASTContext::TypeOrDecl>());
+
+  TypesOrDecls search_results;
+
+  FindTypesOrDecls(name, swift_module, search_results, false);
+
+  if (search_results.empty())
+    return llvm::Optional<SwiftASTContext::TypeOrDecl>();
+  else
+    return *search_results.begin();
+}
+
+size_t SwiftASTContext::FindTypes(const char *name,
+                                  swift::ModuleDecl *swift_module,
+                                  std::set<CompilerType> &results,
+                                  bool append) {
+  VALID_OR_RETURN(0);
+
+  if (!append)
+    results.clear();
+
+  size_t before = results.size();
+
+  TypesOrDecls types_or_decls_results;
+  FindTypesOrDecls(name, swift_module, types_or_decls_results);
+
+  for (const auto &result : types_or_decls_results) {
+    CompilerType type = result.Apply<CompilerType>(
+        [](CompilerType type) -> CompilerType { return type; },
+        [this](swift::Decl *decl) -> CompilerType {
+          if (swift::ValueDecl *value_decl =
+                  swift::dyn_cast_or_null<swift::ValueDecl>(decl)) {
+            if (value_decl->hasInterfaceType()) {
+              swift::Type swift_type = value_decl->getInterfaceType();
+              swift::MetatypeType *meta_type =
+                  swift_type->getAs<swift::MetatypeType>();
+              swift::ASTContext *ast = GetASTContext();
+              if (meta_type)
+                return CompilerType(ast,
+                                    meta_type->getInstanceType().getPointer());
+              else
+                return CompilerType(ast, swift_type.getPointer());
+            }
+          }
+          return CompilerType();
+        });
+    results.emplace(type);
+  }
+
+  return results.size() - before;
+}
+
+size_t SwiftASTContext::FindTypesOrDecls(const char *name,
+                                         swift::ModuleDecl *swift_module,
+                                         TypesOrDecls &results, bool append) {
+  VALID_OR_RETURN(0);
+
+  if (!append)
+    results.clear();
+
+  size_t before = results.size();
+
+  if (name && name[0] && swift_module) {
+    swift::ModuleDecl::AccessPathTy access_path;
+    llvm::SmallVector<swift::ValueDecl *, 4> value_decls;
+    swift::Identifier identifier(GetIdentifier(name));
+    if (strchr(name, '.'))
+      swift_module->lookupValue(access_path, identifier,
+                                swift::NLKind::QualifiedLookup, value_decls);
+    else
+      swift_module->lookupValue(access_path, identifier,
+                                swift::NLKind::UnqualifiedLookup, value_decls);
+    if (identifier.isOperator()) {
+      swift::OperatorDecl *op_decl =
+          swift_module->lookupPrefixOperator(identifier);
+      if (op_decl)
+        results.emplace(DeclToTypeOrDecl(GetASTContext(), op_decl));
+      if ((op_decl = swift_module->lookupInfixOperator(identifier)))
+        results.emplace(DeclToTypeOrDecl(GetASTContext(), op_decl));
+      if ((op_decl = swift_module->lookupPostfixOperator(identifier)))
+        results.emplace(DeclToTypeOrDecl(GetASTContext(), op_decl));
+    }
+    if (swift::PrecedenceGroupDecl *pg_decl =
+            swift_module->lookupPrecedenceGroup(identifier))
+      results.emplace(DeclToTypeOrDecl(GetASTContext(), pg_decl));
+
+    for (auto decl : value_decls)
+      results.emplace(DeclToTypeOrDecl(GetASTContext(), decl));
+  }
+
+  return results.size() - before;
+}
+
+size_t SwiftASTContext::FindType(const char *name,
+                                 std::set<CompilerType> &results, bool append) {
+  VALID_OR_RETURN(0);
+
+  if (!append)
+    results.clear();
+  auto iter = m_swift_module_cache.begin(), end = m_swift_module_cache.end();
+
+  size_t count = 0;
+
+  std::function<void(swift::ModuleDecl *)> lookup_func =
+      [this, name, &results, &count](swift::ModuleDecl *module) -> void {
+    CompilerType candidate(this->FindType(name, module));
+    if (candidate) {
+      ++count;
+      results.insert(candidate);
+    }
+  };
+
+  for (; iter != end; iter++)
+    lookup_func(iter->second);
+
+  if (m_scratch_module)
+    lookup_func(m_scratch_module);
+
+  return count;
+}
+
+CompilerType SwiftASTContext::FindFirstType(const char *name,
+                                            const ConstString &module_name) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (name && name[0]) {
+    if (module_name) {
+      return FindType(name, GetCachedModule(module_name));
+    } else {
+      std::set<CompilerType> types;
+      FindType(name, types);
+      if (!types.empty())
+        return *types.begin();
+    }
+  }
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::ImportType(CompilerType &type, Status &error) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (m_ast_context_ap.get() == NULL)
+    return CompilerType();
+
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem());
+
+  if (swift_ast_ctx == nullptr) {
+    error.SetErrorString("Can't import clang type into a Swift ASTContext.");
+    return CompilerType();
+  } else if (swift_ast_ctx == this) {
+    // This is the same AST context, so the type is already imported...
+    return type;
+  }
+
+  // For now we're going to do this all using mangled names.  If we find that is
+  // too slow, we can use the TypeBase * in the CompilerType to match this to
+  // the version of the type we got from the mangled name in the original
+  // swift::ASTContext.
+
+  ConstString mangled_name(type.GetMangledTypeName());
+  if (mangled_name) {
+    swift::TypeBase *our_type_base =
+        m_mangled_name_to_type_map.lookup(mangled_name.GetCString());
+    if (our_type_base)
+      return CompilerType(m_ast_context_ap.get(), our_type_base);
+    else {
+      Status error;
+
+      CompilerType our_type(
+          GetTypeFromMangledTypename(mangled_name.GetCString(), error));
+      if (error.Success())
+        return our_type;
+    }
+  }
+  return CompilerType();
+}
+
+swift::IRGenDebugInfoKind SwiftASTContext::GetGenerateDebugInfo() {
+  return GetIRGenOptions().DebugInfoKind;
+}
+
+swift::PrintOptions SwiftASTContext::GetUserVisibleTypePrintingOptions(
+    bool print_help_if_available) {
+  swift::PrintOptions print_options;
+  print_options.SynthesizeSugarOnTypes = true;
+  print_options.VarInitializers = true;
+  print_options.TypeDefinitions = true;
+  print_options.PrintGetSetOnRWProperties = true;
+  print_options.SkipImplicit = false;
+  print_options.PreferTypeRepr = true;
+  print_options.FunctionDefinitions = true;
+  print_options.FullyQualifiedTypesIfAmbiguous = true;
+  print_options.FullyQualifiedTypes = true;
+  print_options.ExplodePatternBindingDecls = false;
+  print_options.PrintDocumentationComments =
+      print_options.PrintRegularClangComments = print_help_if_available;
+  return print_options;
+}
+
+void SwiftASTContext::SetGenerateDebugInfo(swift::IRGenDebugInfoKind b) {
+  GetIRGenOptions().DebugInfoKind = b;
+}
+
+llvm::TargetOptions *SwiftASTContext::getTargetOptions() {
+  if (m_target_options_ap.get() == NULL) {
+    m_target_options_ap.reset(new llvm::TargetOptions());
+  }
+  return m_target_options_ap.get();
+}
+
+swift::ModuleDecl *SwiftASTContext::GetScratchModule() {
+  VALID_OR_RETURN(nullptr);
+
+  if (m_scratch_module == nullptr)
+    m_scratch_module = swift::ModuleDecl::create(
+        GetASTContext()->getIdentifier("__lldb_scratch_module"),
+        *GetASTContext());
+  return m_scratch_module;
+}
+
+swift::SILModule *SwiftASTContext::GetSILModule() {
+  VALID_OR_RETURN(nullptr);
+
+  if (m_sil_module_ap.get() == NULL)
+    m_sil_module_ap = swift::SILModule::createEmptyModule(GetScratchModule(),
+                                                          GetSILOptions());
+  return m_sil_module_ap.get();
+}
+
+swift::irgen::IRGenerator &
+SwiftASTContext::GetIRGenerator(swift::IRGenOptions &opts,
+                                swift::SILModule &module) {
+  if (m_ir_generator_ap.get() == nullptr) {
+    m_ir_generator_ap.reset(new swift::irgen::IRGenerator(opts, module));
+  }
+
+  return *m_ir_generator_ap.get();
+}
+
+swift::irgen::IRGenModule &SwiftASTContext::GetIRGenModule() {
+  VALID_OR_RETURN(*m_ir_gen_module_ap);
+
+  if (m_ir_gen_module_ap.get() == NULL) {
+    // Make sure we have a good ClangImporter.
+    GetClangImporter();
+
+    swift::IRGenOptions &ir_gen_opts = GetIRGenOptions();
+
+    std::string error_str;
+    std::string triple = GetTriple();
+    const llvm::Target *llvm_target =
+        llvm::TargetRegistry::lookupTarget(triple, error_str);
+
+    llvm::CodeGenOpt::Level optimization_level = llvm::CodeGenOpt::Level::None;
+
+    // Create a target machine.
+    llvm::TargetMachine *target_machine = llvm_target->createTargetMachine(
+        triple,
+        "generic", // cpu
+        "",        // features
+        *getTargetOptions(),
+        llvm::Reloc::Static, // TODO verify with Sean, Default went away
+        llvm::CodeModel::Default, optimization_level);
+    if (target_machine) {
+      // Set the module's string representation.
+      const llvm::DataLayout data_layout = target_machine->createDataLayout();
+
+      llvm::Triple llvm_triple(triple);
+      swift::SILModule *sil_module = GetSILModule();
+      if (sil_module != nullptr) {
+        swift::irgen::IRGenerator &ir_generator =
+            GetIRGenerator(ir_gen_opts, *sil_module);
+        m_ir_gen_module_ap.reset(new swift::irgen::IRGenModule(
+            ir_generator, ir_generator.createTargetMachine(), nullptr,
+            GetGlobalLLVMContext(), ir_gen_opts.ModuleName,
+            ir_gen_opts.getSingleOutputFilename()));
+        llvm::Module *llvm_module = m_ir_gen_module_ap->getModule();
+        llvm_module->setDataLayout(data_layout.getStringRepresentation());
+        llvm_module->setTargetTriple(triple);
+      }
+    }
+  }
+  return *m_ir_gen_module_ap;
+}
+
+CompilerType
+SwiftASTContext::CreateTupleType(const std::vector<CompilerType> &elements) {
+  VALID_OR_RETURN(CompilerType());
+
+  Status error;
+  if (elements.size() == 0)
+    return CompilerType(GetASTContext(), GetASTContext()->TheEmptyTupleType);
+  else {
+    std::vector<swift::TupleTypeElt> tuple_elems;
+    for (const CompilerType &type : elements) {
+      if (auto swift_type = GetSwiftType(type))
+        tuple_elems.push_back(swift::TupleTypeElt(swift_type));
+      else
+        return CompilerType();
+    }
+    llvm::ArrayRef<swift::TupleTypeElt> fields(tuple_elems);
+    return CompilerType(
+        GetASTContext(),
+        swift::TupleType::get(fields, *GetASTContext()).getPointer());
+  }
+}
+
+CompilerType
+SwiftASTContext::CreateTupleType(const std::vector<TupleElement> &elements) {
+  VALID_OR_RETURN(CompilerType());
+
+  Status error;
+  if (elements.size() == 0)
+    return CompilerType(GetASTContext(), GetASTContext()->TheEmptyTupleType);
+  else {
+    std::vector<swift::TupleTypeElt> tuple_elems;
+    for (const TupleElement &element : elements) {
+      if (auto swift_type = GetSwiftType(element.element_type)) {
+        if (element.element_name.IsEmpty())
+          tuple_elems.push_back(swift::TupleTypeElt(swift_type));
+        else
+          tuple_elems.push_back(swift::TupleTypeElt(
+              swift_type, m_ast_context_ap->getIdentifier(
+                              element.element_name.GetCString())));
+      } else
+        return CompilerType();
+    }
+    llvm::ArrayRef<swift::TupleTypeElt> fields(tuple_elems);
+    return CompilerType(
+        GetASTContext(),
+        swift::TupleType::get(fields, *GetASTContext()).getPointer());
+  }
+}
+
+CompilerType SwiftASTContext::CreateFunctionType(CompilerType arg_type,
+                                                 CompilerType ret_type,
+                                                 bool throws) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (!llvm::dyn_cast_or_null<SwiftASTContext>(arg_type.GetTypeSystem()) ||
+      !llvm::dyn_cast_or_null<SwiftASTContext>(ret_type.GetTypeSystem()))
+    return CompilerType();
+  swift::FunctionType::ExtInfo ext_info;
+  if (throws)
+    ext_info = ext_info.withThrows();
+  return CompilerType(GetASTContext(), swift::FunctionType::get(
+                                           GetSwiftType(arg_type),
+                                           GetSwiftType(ret_type), ext_info));
+}
+
+CompilerType SwiftASTContext::GetErrorType() {
+  VALID_OR_RETURN(CompilerType());
+
+  swift::ASTContext *swift_ctx = GetASTContext();
+  if (swift_ctx) {
+    // Getting the error type requires the Stdlib module be loaded, but doesn't
+    // cause it to be loaded.
+    // Do that here:
+    swift_ctx->getStdlibModule(true);
+    swift::NominalTypeDecl *error_type_decl = GetASTContext()->getErrorDecl();
+    if (error_type_decl) {
+      auto error_type = error_type_decl->getDeclaredType().getPointer();
+      return CompilerType(GetASTContext(), error_type);
+    }
+  }
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetNSErrorType(Status &error) {
+  VALID_OR_RETURN(CompilerType());
+
+  return GetTypeFromMangledTypename(
+      SwiftLanguageRuntime::GetCurrentMangledName("_TtC10Foundation7NSError")
+          .c_str(),
+      error);
+}
+
+CompilerType SwiftASTContext::CreateMetatypeType(CompilerType instance_type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (llvm::dyn_cast_or_null<SwiftASTContext>(instance_type.GetTypeSystem()))
+    return CompilerType(GetASTContext(),
+                        swift::MetatypeType::get(GetSwiftType(instance_type),
+                                                 *GetASTContext()));
+  return CompilerType();
+}
+
+SwiftASTContext *SwiftASTContext::GetSwiftASTContext(swift::ASTContext *ast) {
+  SwiftASTContext *swift_ast = GetASTMap().Lookup(ast);
+  return swift_ast;
+}
+
+uint32_t SwiftASTContext::GetPointerByteSize() {
+  VALID_OR_RETURN(0);
+
+  if (m_pointer_byte_size == 0) {
+    swift::ASTContext *ast = GetASTContext();
+    m_pointer_byte_size = CompilerType(ast, ast->TheRawPointerType.getPointer())
+                              .GetByteSize(nullptr);
+  }
+  return m_pointer_byte_size;
+}
+
+uint32_t SwiftASTContext::GetPointerBitAlignment() {
+  VALID_OR_RETURN(0);
+
+  if (m_pointer_bit_align == 0) {
+    swift::ASTContext *ast = GetASTContext();
+    m_pointer_bit_align = CompilerType(ast, ast->TheRawPointerType.getPointer())
+                              .GetAlignedBitSize();
+  }
+  return m_pointer_bit_align;
+}
+
+bool SwiftASTContext::HasErrors() {
+  if (m_diagnostic_consumer_ap.get())
+    return (
+        static_cast<StoringDiagnosticConsumer *>(m_diagnostic_consumer_ap.get())
+            ->NumErrors() != 0);
+  else
+    return false;
+}
+
+bool SwiftASTContext::HasFatalErrors(swift::ASTContext *ast_context) {
+  return (ast_context && ast_context->Diags.hasFatalErrorOccurred());
+}
+
+void SwiftASTContext::ClearDiagnostics() {
+  assert(!HasFatalErrors() && "Never clear a fatal diagnostic!");
+  if (m_diagnostic_consumer_ap.get())
+    static_cast<StoringDiagnosticConsumer *>(m_diagnostic_consumer_ap.get())
+        ->Clear();
+}
+
+bool SwiftASTContext::SetColorizeDiagnostics(bool b) {
+  if (m_diagnostic_consumer_ap.get())
+    return static_cast<StoringDiagnosticConsumer *>(
+               m_diagnostic_consumer_ap.get())
+        ->SetColorize(b);
+  return false;
+}
+
+void SwiftASTContext::PrintDiagnostics(DiagnosticManager &diagnostic_manager,
+                                       uint32_t bufferID, uint32_t first_line,
+                                       uint32_t last_line,
+                                       uint32_t line_offset) {
+  // If this is a fatal error, copy the error into the AST context's fatal error
+  // field, and then put it to the stream, otherwise just dump the diagnostics
+  // to the stream.
+
+  // N.B. you cannot use VALID_OR_RETURN_VOID here since that exits if you have
+  // fatal errors, which are what we are trying to print here.
+  if (!m_ast_context_ap.get()) {
+    SymbolFile *sym_file = GetSymbolFile();
+    if (sym_file) {
+      ConstString name =
+          sym_file->GetObjectFile()->GetModule()->GetObjectName();
+      m_fatal_errors.SetErrorStringWithFormat("Null context for %s.",
+                                              name.AsCString());
+    } else {
+      m_fatal_errors.SetErrorString("Unknown fatal error occurred.");
+    }
+    return;
+  }
+
+  if (m_ast_context_ap->Diags.hasFatalErrorOccurred() &&
+      !m_reported_fatal_error) {
+    DiagnosticManager fatal_diagnostics;
+
+    if (m_diagnostic_consumer_ap.get())
+      static_cast<StoringDiagnosticConsumer *>(m_diagnostic_consumer_ap.get())
+          ->PrintDiagnostics(fatal_diagnostics, bufferID, first_line, last_line,
+                             line_offset);
+    if (fatal_diagnostics.Diagnostics().size())
+      m_fatal_errors.SetErrorString(fatal_diagnostics.GetString().data());
+    else
+      m_fatal_errors.SetErrorString("Unknown fatal error occurred.");
+
+    m_reported_fatal_error = true;
+
+    for (const DiagnosticList::value_type &fatal_diagnostic :
+         fatal_diagnostics.Diagnostics()) {
+      // FIXME: need to add a CopyDiagnostic operation for copying diagnostics
+      // from one manager to another.
+      diagnostic_manager.AddDiagnostic(
+          fatal_diagnostic->GetMessage(), fatal_diagnostic->GetSeverity(),
+          fatal_diagnostic->getKind(), fatal_diagnostic->GetCompilerID());
+    }
+  } else {
+    if (m_diagnostic_consumer_ap.get())
+      static_cast<StoringDiagnosticConsumer *>(m_diagnostic_consumer_ap.get())
+          ->PrintDiagnostics(diagnostic_manager, bufferID, first_line,
+                             last_line, line_offset);
+  }
+}
+
+void SwiftASTContext::ModulesDidLoad(ModuleList &module_list) {
+  ClearModuleDependentCaches();
+}
+
+void SwiftASTContext::ClearModuleDependentCaches() {
+  m_negative_type_cache.Clear();
+  m_extra_type_info_cache.Clear();
+}
+
+void SwiftASTContext::DumpConfiguration(Log *log) {
+  VALID_OR_RETURN_VOID();
+
+  if (!log)
+    return;
+
+  log->Printf("(SwiftASTContext*)%p:", this);
+
+  if (!m_ast_context_ap)
+    log->Printf("  (no AST context)");
+
+  log->Printf("  Architecture                 : %s",
+              m_ast_context_ap->LangOpts.Target.getTriple().c_str());
+
+  log->Printf("  SDK path                     : %s",
+              m_ast_context_ap->SearchPathOpts.SDKPath.c_str());
+  log->Printf("  Runtime resource path        : %s",
+              m_ast_context_ap->SearchPathOpts.RuntimeResourcePath.c_str());
+  log->Printf("  Runtime library path         : %s",
+              m_ast_context_ap->SearchPathOpts.RuntimeLibraryPath.c_str());
+  log->Printf(
+      "  Runtime library import path  : %s",
+      m_ast_context_ap->SearchPathOpts.RuntimeLibraryImportPath.c_str());
+
+  log->Printf("  Framework search paths       : (%llu items)",
+              (unsigned long long)
+                  m_ast_context_ap->SearchPathOpts.FrameworkSearchPaths.size());
+  for (const auto &framework_search_path :
+       m_ast_context_ap->SearchPathOpts.FrameworkSearchPaths) {
+    log->Printf("    %s", framework_search_path.Path.c_str());
+  }
+
+  log->Printf("  Import search paths          : (%llu items)",
+              (unsigned long long)
+                  m_ast_context_ap->SearchPathOpts.ImportSearchPaths.size());
+  for (std::string &import_search_path :
+       m_ast_context_ap->SearchPathOpts.ImportSearchPaths) {
+    log->Printf("    %s", import_search_path.c_str());
+  }
+
+  swift::ClangImporterOptions &clang_importer_options =
+      GetClangImporterOptions();
+
+  log->Printf("  Extra clang arguments        : (%llu items)",
+              (unsigned long long)clang_importer_options.ExtraArgs.size());
+  for (std::string &extra_arg : clang_importer_options.ExtraArgs) {
+    log->Printf("    %s", extra_arg.c_str());
+  }
+}
+
+bool SwiftASTContext::HasTarget() const {
+  lldb::TargetWP empty_wp;
+
+  // If either call to "std::weak_ptr::owner_before(...) value returns true,
+  // this indicates that m_section_wp once contained (possibly still does) a
+  // reference to a valid shared pointer. This helps us know if we had a valid
+  // reference to a target which is now invalid because the target was deleted.
+  return empty_wp.owner_before(m_target_wp) ||
+         m_target_wp.owner_before(empty_wp);
+}
+
+bool SwiftASTContext::CheckProcessChanged() {
+  if (HasTarget()) {
+    TargetSP target_sp(m_target_wp.lock());
+    if (target_sp) {
+      Process *process = target_sp->GetProcessSP().get();
+      if (m_process == NULL) {
+        if (process)
+          m_process = process;
+      } else {
+        if (m_process != process)
+          return true;
+      }
+    }
+  }
+  return false;
+}
+
+void SwiftASTContext::AddDebuggerClient(
+    swift::DebuggerClient *debugger_client) {
+  m_debugger_clients.push_back(
+      std::unique_ptr<swift::DebuggerClient>(debugger_client));
+}
+
+SwiftASTContext::ExtraTypeInformation::ExtraTypeInformation()
+    : m_flags(false, false) {}
+
+SwiftASTContext::ExtraTypeInformation::ExtraTypeInformation(
+    swift::CanType swift_can_type)
+    : m_flags(false, false) {
+  static ConstString g_rawValue("rawValue");
+
+  swift::ASTContext &ast_ctx = swift_can_type->getASTContext();
+  SwiftASTContext *swift_ast = SwiftASTContext::GetSwiftASTContext(&ast_ctx);
+  if (swift_ast) {
+    swift::ProtocolDecl *option_set =
+        ast_ctx.getProtocol(swift::KnownProtocolKind::OptionSet);
+    if (option_set) {
+      if (auto nominal_decl =
+              swift_can_type.getNominalOrBoundGenericNominal()) {
+        for (swift::ProtocolDecl *protocol_decl :
+             nominal_decl->getAllProtocols()) {
+          if (protocol_decl == option_set) {
+            for (swift::VarDecl *stored_property :
+                 nominal_decl->getStoredProperties()) {
+              swift::Identifier name = stored_property->getName();
+              if (name.str() == g_rawValue.GetStringRef()) {
+                m_flags.m_is_trivial_option_set = true;
+                break;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  if (auto metatype_type =
+          swift::dyn_cast_or_null<swift::MetatypeType>(swift_can_type)) {
+    if (!metatype_type->hasRepresentation() ||
+        (swift::MetatypeRepresentation::Thin ==
+         metatype_type->getRepresentation()))
+      m_flags.m_is_zero_size = true;
+  } else if (auto enum_decl = swift_can_type->getEnumOrBoundGenericEnum()) {
+    size_t num_nopayload = 0, num_payload = 0;
+    for (auto the_case : enum_decl->getAllElements()) {
+      if (the_case->getArgumentInterfaceType()) {
+        num_payload = 1;
+        break;
+      } else {
+        if (++num_nopayload > 1)
+          break;
+      }
+    }
+    if (num_nopayload == 1 && num_payload == 0)
+      m_flags.m_is_zero_size = true;
+  } else if (auto struct_decl =
+                 swift_can_type->getStructOrBoundGenericStruct()) {
+    bool has_storage = false;
+    auto members = struct_decl->getMembers();
+    for (const auto &member : members) {
+      if (swift::VarDecl *var_decl = swift::dyn_cast<swift::VarDecl>(member)) {
+        if (!var_decl->isStatic() && var_decl->hasStorage()) {
+          has_storage = true;
+          break;
+        }
+      }
+    }
+    m_flags.m_is_zero_size = !has_storage;
+  } else if (auto tuple_type =
+                 swift::dyn_cast_or_null<swift::TupleType>(swift_can_type)) {
+    m_flags.m_is_zero_size = (tuple_type->getNumElements() == 0);
+  }
+}
+
+SwiftASTContext::ExtraTypeInformation
+SwiftASTContext::GetExtraTypeInformation(void *type) {
+  if (!type)
+    return ExtraTypeInformation();
+
+  swift::CanType swift_can_type;
+  void *swift_can_type_ptr = nullptr;
+  if (auto swift_type = GetSwiftType(type)) {
+    swift_can_type = swift_type->getCanonicalType();
+    swift_can_type_ptr = swift_can_type.getPointer();
+  }
+  if (!swift_can_type_ptr)
+    return ExtraTypeInformation();
+
+  ExtraTypeInformation eti;
+  if (!m_extra_type_info_cache.Lookup(swift_can_type_ptr, eti)) {
+    ExtraTypeInformation extra_info(swift_can_type);
+    m_extra_type_info_cache.Insert(swift_can_type_ptr, extra_info);
+    return extra_info;
+  } else {
+    return eti;
+  }
+}
+
+bool SwiftASTContext::DeclContextIsStructUnionOrClass(void *opaque_decl_ctx) {
+  return false;
+}
+
+ConstString SwiftASTContext::DeclContextGetName(void *opaque_decl_ctx) {
+  return ConstString();
+}
+
+ConstString
+SwiftASTContext::DeclContextGetScopeQualifiedName(void *opaque_decl_ctx) {
+  return ConstString();
+}
+
+bool SwiftASTContext::DeclContextIsClassMethod(
+    void *opaque_decl_ctx, lldb::LanguageType *language_ptr,
+    bool *is_instance_method_ptr, ConstString *language_object_name_ptr) {
+  return false;
+}
+
+///////////
+////////////////////
+///////////
+
+bool SwiftASTContext::IsArrayType(void *type, CompilerType *element_type_ptr,
+                                  uint64_t *size, bool *is_incomplete) {
+  VALID_OR_RETURN(false);
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+  swift::BoundGenericStructType *struct_type =
+      swift_can_type->getAs<swift::BoundGenericStructType>();
+  if (struct_type) {
+    swift::StructDecl *struct_decl = struct_type->getDecl();
+    if (strcmp(struct_decl->getName().get(), "Array") != 0)
+      return false;
+    if (!struct_decl->getModuleContext()->isStdlibModule())
+      return false;
+    const llvm::ArrayRef<swift::Type> &args = struct_type->getGenericArgs();
+    if (args.size() != 1)
+      return false;
+    if (is_incomplete)
+      *is_incomplete = true;
+    if (size)
+      *size = 0;
+    if (element_type_ptr)
+      *element_type_ptr = CompilerType(GetASTContext(), args[0].getPointer());
+    return true;
+  }
+
+  return false;
+}
+
+bool SwiftASTContext::IsAggregateType(void *type) {
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    auto referent_type = swift_can_type->getReferenceStorageReferent();
+    return (referent_type->is<swift::TupleType>() ||
+            referent_type->is<swift::BuiltinVectorType>() ||
+            referent_type->getAnyNominal());
+  }
+
+  return false;
+}
+
+bool SwiftASTContext::IsVectorType(void *type, CompilerType *element_type,
+                                   uint64_t *size) {
+  return false;
+}
+
+bool SwiftASTContext::IsRuntimeGeneratedType(void *type) { return false; }
+
+bool SwiftASTContext::IsCharType(void *type) { return false; }
+
+bool SwiftASTContext::IsCompleteType(void *type) { return true; }
+
+bool SwiftASTContext::IsConst(void *type) { return false; }
+
+bool SwiftASTContext::IsCStringType(void *type, uint32_t &length) {
+  return false;
+}
+
+bool SwiftASTContext::IsFunctionType(void *type, bool *is_variadic_ptr) {
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::Function:
+    case swift::TypeKind::GenericFunction:
+      return true;
+    case swift::TypeKind::SILFunction:
+      return false; // TODO: is this correct?
+    default:
+      return false;
+    }
+  }
+  return false;
+}
+
+// Used to detect "Homogeneous Floating-point Aggregates"
+uint32_t SwiftASTContext::IsHomogeneousAggregate(void *type,
+                                                 CompilerType *base_type_ptr) {
+  return 0;
+}
+
+size_t SwiftASTContext::GetNumberOfFunctionArguments(void *type) {
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    auto func = swift::dyn_cast_or_null<swift::AnyFunctionType>(swift_can_type);
+    if (func) {
+      auto input = func.getInput();
+      // See comment in swift::AnyFunctionType for rationale here:
+      // A function can take either a tuple or a parentype, but if a parentype
+      // (i.e. (Foo)), then it will be reduced down to just Foo, so if the input
+      // is not a tuple, that must mean there is only 1 input.
+      auto tuple = swift::dyn_cast<swift::TupleType>(input);
+      if (tuple)
+        return tuple->getNumElements();
+      else
+        return 1;
+    }
+  }
+  return 0;
+}
+
+CompilerType SwiftASTContext::GetFunctionArgumentAtIndex(void *type,
+                                                         const size_t index) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    auto func = swift::dyn_cast<swift::AnyFunctionType>(swift_can_type);
+    if (func) {
+      auto input = func.getInput();
+      // See comment in swift::AnyFunctionType for rationale here:
+      // A function can take either a tuple or a parentype, but if a parentype
+      // (i.e. (Foo)), then it will be reduced down to just Foo, so if the input
+      // is not a tuple, that must mean there is only 1 input.
+      auto tuple = swift::dyn_cast<swift::TupleType>(input);
+      if (tuple) {
+        if (index < tuple->getNumElements())
+          return CompilerType(GetASTContext(), tuple->getElementType(index));
+      } else
+        return CompilerType(GetASTContext(), input);
+    }
+  }
+  return CompilerType();
+}
+
+bool SwiftASTContext::IsFunctionPointerType(void *type) {
+  return IsFunctionType(type, nullptr); // FIXME: think about this
+}
+
+bool SwiftASTContext::IsBlockPointerType(
+    void *type, CompilerType *function_pointer_type_ptr) {
+  return false;
+}
+
+bool SwiftASTContext::IsIntegerType(void *type, bool &is_signed) {
+  return (GetTypeInfo(type, nullptr) & eTypeIsInteger);
+}
+
+bool SwiftASTContext::IsPointerType(void *type, CompilerType *pointee_type) {
+  VALID_OR_RETURN(false);
+
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    auto referent_type = swift_can_type->getReferenceStorageReferent();
+    return (referent_type->is<swift::BuiltinRawPointerType>() ||
+            referent_type->is<swift::BuiltinNativeObjectType>() ||
+            referent_type->is<swift::BuiltinUnsafeValueBufferType>() ||
+            referent_type->is<swift::BuiltinUnknownObjectType>() ||
+            referent_type->is<swift::BuiltinBridgeObjectType>());
+  }
+
+  if (pointee_type)
+    pointee_type->Clear();
+  return false;
+}
+
+bool SwiftASTContext::IsPointerOrReferenceType(void *type,
+                                               CompilerType *pointee_type) {
+  return IsPointerType(type, pointee_type) ||
+         IsReferenceType(type, pointee_type, nullptr);
+}
+
+bool SwiftASTContext::ShouldTreatScalarValueAsAddress(
+    lldb::opaque_compiler_type_t type) {
+  return Flags(GetTypeInfo(type, nullptr))
+      .AnySet(eTypeInstanceIsPointer | eTypeIsReference);
+}
+
+bool SwiftASTContext::IsReferenceType(void *type, CompilerType *pointee_type,
+                                      bool *is_rvalue) {
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::InOut:
+    case swift::TypeKind::LValue:
+      if (pointee_type)
+        *pointee_type = GetNonReferenceType(type);
+      return true;
+    default:
+      break;
+    }
+  }
+  if (pointee_type)
+    pointee_type->Clear();
+  return false;
+}
+
+bool SwiftASTContext::IsInoutType(const CompilerType &compiler_type,
+                                  CompilerType *original_type) {
+  if (compiler_type.IsValid()) {
+    if (auto ast = llvm::dyn_cast_or_null<SwiftASTContext>(
+            compiler_type.GetTypeSystem())) {
+      swift::CanType swift_can_type(GetCanonicalSwiftType(compiler_type));
+      swift::LValueType *lvalue = swift_can_type->getAs<swift::LValueType>();
+      if (lvalue) {
+        if (original_type)
+          *original_type =
+              CompilerType(ast, lvalue->getObjectType().getPointer());
+        return true;
+      }
+      swift::InOutType *inout = swift_can_type->getAs<swift::InOutType>();
+      if (inout) {
+        if (original_type)
+          *original_type =
+              CompilerType(ast, inout->getObjectType().getPointer());
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+bool SwiftASTContext::IsFloatingPointType(void *type, uint32_t &count,
+                                          bool &is_complex) {
+  if (type) {
+    if (GetTypeInfo(type, nullptr) & eTypeIsFloat) {
+      count = 1;
+      is_complex = false;
+      return true;
+    }
+  }
+  count = 0;
+  is_complex = false;
+  return false;
+}
+
+bool SwiftASTContext::IsDefined(void *type) {
+  if (!type)
+    return false;
+
+  return true;
+}
+
+bool SwiftASTContext::IsPolymorphicClass(void *type) { return false; }
+
+bool SwiftASTContext::IsPossibleDynamicType(void *type,
+                                            CompilerType *dynamic_pointee_type,
+                                            bool check_cplusplus,
+                                            bool check_objc, bool check_swift) {
+  VALID_OR_RETURN(false);
+
+  if (type && check_swift) {
+    // FIXME: use the dynamic_pointee_type
+    Flags type_flags(GetTypeInfo(type, nullptr));
+
+    if (type_flags.AnySet(eTypeIsArchetype | eTypeIsClass | eTypeIsProtocol))
+      return true;
+
+    if (type_flags.AnySet(eTypeIsStructUnion | eTypeIsEnumeration |
+                          eTypeIsTuple)) {
+      CompilerType compiler_type(GetASTContext(), GetCanonicalSwiftType(type));
+      return !SwiftASTContext::IsFullyRealized(compiler_type);
+    }
+
+    auto can_type = GetCanonicalSwiftType(type).getPointer();
+    if (can_type == GetASTContext()->TheRawPointerType.getPointer())
+      return true;
+    if (can_type == GetASTContext()->TheUnknownObjectType.getPointer())
+      return true;
+    if (can_type == GetASTContext()->TheNativeObjectType.getPointer())
+      return true;
+    if (can_type == GetASTContext()->TheBridgeObjectType.getPointer())
+      return true;
+  }
+
+  if (dynamic_pointee_type)
+    dynamic_pointee_type->Clear();
+  return false;
+}
+
+bool SwiftASTContext::IsScalarType(void *type) {
+  if (!type)
+    return false;
+
+  return (GetTypeInfo(type, nullptr) & eTypeIsScalar) != 0;
+}
+
+bool SwiftASTContext::IsTypedefType(void *type) {
+  if (!type)
+    return false;
+  swift::Type swift_type(GetSwiftType(type));
+  return swift::isa<swift::NameAliasType>(swift_type.getPointer());
+}
+
+bool SwiftASTContext::IsVoidType(void *type) {
+  VALID_OR_RETURN(false);
+
+  if (!type)
+    return false;
+  return type == GetASTContext()->TheEmptyTupleType.getPointer();
+}
+
+bool SwiftASTContext::IsArchetypeType(const CompilerType &compiler_type) {
+  if (!compiler_type.IsValid())
+    return false;
+
+  if (llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem())) {
+    swift::Type swift_type(GetSwiftType(compiler_type));
+    return swift_type->is<swift::ArchetypeType>();
+  }
+  return false;
+}
+
+bool SwiftASTContext::IsSelfArchetypeType(const CompilerType &compiler_type) {
+  if (!compiler_type.IsValid())
+    return false;
+
+  if (llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem())) {
+    if (swift::isa<swift::ArchetypeType>(
+            (swift::TypeBase *)compiler_type.GetOpaqueQualType())) {
+      // Hack: Just assume if we have an archetype as the type of 'self',
+      // it's going to be a protocol 'Self' type.
+      return true;
+    }
+  }
+  return false;
+}
+
+bool SwiftASTContext::IsPossibleZeroSizeType(
+    const CompilerType &compiler_type) {
+  if (!compiler_type.IsValid())
+    return false;
+
+  if (auto ast = llvm::dyn_cast_or_null<SwiftASTContext>(
+          compiler_type.GetTypeSystem()))
+    return ast
+        ->GetExtraTypeInformation(
+            GetCanonicalSwiftType(compiler_type).getPointer())
+        .m_flags.m_is_zero_size;
+  return false;
+}
+
+bool SwiftASTContext::IsErrorType(const CompilerType &compiler_type) {
+  if (compiler_type.IsValid() &&
+      llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem())) {
+    ProtocolInfo protocol_info;
+
+    if (GetProtocolTypeInfo(compiler_type, protocol_info))
+      return protocol_info.m_is_errortype;
+    return false;
+  }
+  return false;
+}
+
+CompilerType
+SwiftASTContext::GetReferentType(const CompilerType &compiler_type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (compiler_type.IsValid() &&
+      llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem())) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(compiler_type));
+    auto ref_type = swift_can_type->getReferenceStorageReferent();
+    return CompilerType(GetASTContext(), ref_type);
+  }
+
+  return CompilerType();
+}
+
+bool SwiftASTContext::IsTrivialOptionSetType(
+    const CompilerType &compiler_type) {
+  if (compiler_type.IsValid() &&
+      llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem()))
+    return GetExtraTypeInformation(compiler_type.GetOpaqueQualType())
+        .m_flags.m_is_trivial_option_set;
+  return false;
+}
+
+bool SwiftASTContext::IsFullyRealized(const CompilerType &compiler_type) {
+  if (!compiler_type.IsValid())
+    return false;
+
+  if (auto ast = llvm::dyn_cast_or_null<SwiftASTContext>(
+          compiler_type.GetTypeSystem())) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(compiler_type));
+    if (swift::isa<swift::MetatypeType>(swift_can_type))
+      return true;
+    return !swift_can_type->hasArchetype();
+  }
+
+  return false;
+}
+
+bool SwiftASTContext::GetProtocolTypeInfo(const CompilerType &type,
+                                          ProtocolInfo &protocol_info) {
+  if (auto ast =
+          llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    if (!swift_can_type.isExistentialType())
+      return false;
+
+    swift::ExistentialLayout layout = swift_can_type.getExistentialLayout();
+    protocol_info.m_is_class_only = layout.requiresClass();
+    protocol_info.m_num_protocols = layout.getProtocols().size();
+    protocol_info.m_is_objc = layout.isObjC();
+    protocol_info.m_is_anyobject = layout.isAnyObject();
+    protocol_info.m_is_errortype = layout.isErrorExistential();
+
+    unsigned num_witness_tables = 0;
+    for (auto protoTy : layout.getProtocols()) {
+      if (!protoTy->getDecl()->isObjC() && !protoTy->isAnyObject())
+        num_witness_tables++;
+    }
+
+    if (layout.isErrorExistential()) {
+      // Error existential -- instance pointer only
+      protocol_info.m_num_payload_words = 0;
+      protocol_info.m_num_storage_words = 1;
+    } else if (layout.requiresClass()) {
+      // Class-constrained existential -- instance pointer plus witness tables
+      protocol_info.m_num_payload_words = 0;
+      protocol_info.m_num_storage_words = 1 + num_witness_tables;
+    } else {
+      // Opaque existential -- three words of inline storage, metadata and
+      // witness tables
+      protocol_info.m_num_payload_words = 3;
+      protocol_info.m_num_storage_words = 3 + 1 + num_witness_tables;
+    }
+
+    return true;
+  }
+
+  return false;
+}
+
+bool SwiftASTContext::IsOptionalChain(CompilerType type,
+                                      CompilerType &payload_type,
+                                      uint32_t &depth) {
+  auto is_optional = [](const CompilerType &type) -> bool {
+    if (auto ast =
+            llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+      if (auto swift_ast = ast->GetASTContext()) {
+        swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+        if (swift_can_type.getAnyOptionalObjectType())
+          return true;
+        return false;
+      }
+    }
+    return false;
+  };
+
+  depth = 0;
+
+  while (is_optional(type)) {
+    ++depth;
+    lldb::TemplateArgumentKind kind;
+    type = type.GetTemplateArgument(0, kind);
+  }
+
+  if (depth > 0) {
+    payload_type = type;
+    return true;
+  } else
+    return false;
+}
+
+SwiftASTContext::TypeAllocationStrategy
+SwiftASTContext::GetAllocationStrategy(const CompilerType &type) {
+  if (auto ast =
+          llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+    const swift::irgen::TypeInfo *type_info =
+        ast->GetSwiftTypeInfo(type.GetOpaqueQualType());
+    if (!type_info)
+      return TypeAllocationStrategy::eUnknown;
+    switch (type_info->getFixedPacking(ast->GetIRGenModule())) {
+    case swift::irgen::FixedPacking::OffsetZero:
+      return TypeAllocationStrategy::eInline;
+    case swift::irgen::FixedPacking::Allocate:
+      return TypeAllocationStrategy::ePointer;
+    case swift::irgen::FixedPacking::Dynamic:
+      return TypeAllocationStrategy::eDynamic;
+    default:
+      break;
+    }
+  }
+
+  return TypeAllocationStrategy::eUnknown;
+}
+
+bool SwiftASTContext::IsBeingDefined(void *type) { return false; }
+
+bool SwiftASTContext::IsObjCObjectPointerType(const CompilerType &type,
+                                              CompilerType *class_type_ptr) {
+  if (!type)
+    return false;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  if (type_kind == swift::TypeKind::BuiltinNativeObject ||
+      type_kind == swift::TypeKind::BuiltinUnknownObject)
+    return true;
+
+  if (class_type_ptr)
+    class_type_ptr->Clear();
+  return false;
+}
+
+//----------------------------------------------------------------------
+// Type Completion
+//----------------------------------------------------------------------
+
+bool SwiftASTContext::GetCompleteType(void *type) { return true; }
+
+ConstString SwiftASTContext::GetTypeName(void *type) {
+  std::string type_name;
+  if (type) {
+    swift::Type swift_type(GetSwiftType(type));
+
+    swift::Type normalized_type =
+        swift_type.transform([](swift::Type type) -> swift::Type {
+          if (swift::SyntaxSugarType *syntax_sugar_type =
+                  swift::dyn_cast<swift::SyntaxSugarType>(type.getPointer())) {
+            return syntax_sugar_type->getSinglyDesugaredType();
+          }
+          if (swift::DictionaryType *dictionary_type =
+                  swift::dyn_cast<swift::DictionaryType>(type.getPointer())) {
+            return dictionary_type->getSinglyDesugaredType();
+          }
+          return type;
+        });
+
+    swift::PrintOptions print_options;
+    print_options.FullyQualifiedTypes = true;
+    print_options.SynthesizeSugarOnTypes = false;
+    type_name = normalized_type.getString(print_options);
+  }
+  return ConstString(type_name);
+}
+
+ConstString SwiftASTContext::GetDisplayTypeName(void *type) {
+  std::string type_name(GetTypeName(type).AsCString(""));
+
+  if (type) {
+    swift::Type swift_type(GetSwiftType(type));
+
+    swift::PrintOptions print_options;
+    print_options.FullyQualifiedTypes = false;
+    print_options.SynthesizeSugarOnTypes = true;
+    print_options.FullyQualifiedTypesIfAmbiguous = true;
+    type_name = swift_type.getString(print_options);
+  }
+
+  return ConstString(type_name);
+}
+
+ConstString SwiftASTContext::GetTypeSymbolName(void *type) {
+  swift::Type swift_type(GetSwiftType(type));
+  return GetTypeName(swift_type->getWithoutParens().getPointer());
+}
+
+ConstString SwiftASTContext::GetMangledTypeName(void *type) {
+  return GetMangledTypeName(GetSwiftType(type).getPointer());
+}
+
+uint32_t
+SwiftASTContext::GetTypeInfo(void *type,
+                             CompilerType *pointee_or_element_clang_type) {
+  VALID_OR_RETURN(0);
+
+  if (!type)
+    return 0;
+
+  if (pointee_or_element_clang_type)
+    pointee_or_element_clang_type->Clear();
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  uint32_t swift_flags = eTypeIsSwift;
+  switch (type_kind) {
+  case swift::TypeKind::DependentMember:
+  case swift::TypeKind::Error:
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::Module:
+  case swift::TypeKind::TypeVariable:
+    break;
+  case swift::TypeKind::UnboundGeneric:
+    swift_flags |= eTypeIsGeneric;
+    break;
+
+  case swift::TypeKind::GenericFunction:
+    swift_flags |= eTypeIsGeneric;
+  case swift::TypeKind::Function:
+    swift_flags |=
+        eTypeIsBuiltIn | eTypeHasValue | eTypeIsScalar | eTypeInstanceIsPointer;
+    break;
+  case swift::TypeKind::BuiltinInteger:
+    swift_flags |=
+        eTypeIsBuiltIn | eTypeHasValue | eTypeIsScalar | eTypeIsInteger;
+    break;
+  case swift::TypeKind::BuiltinFloat:
+    swift_flags |=
+        eTypeIsBuiltIn | eTypeHasValue | eTypeIsScalar | eTypeIsFloat;
+    break;
+  case swift::TypeKind::BuiltinRawPointer:
+    swift_flags |= eTypeIsBuiltIn | eTypeHasChildren | eTypeIsPointer |
+                   eTypeIsScalar | eTypeHasValue;
+    break;
+  case swift::TypeKind::BuiltinNativeObject:
+    swift_flags |= eTypeIsBuiltIn | eTypeHasChildren | eTypeIsPointer |
+                   eTypeIsScalar | eTypeHasValue;
+    break;
+  case swift::TypeKind::BuiltinUnknownObject:
+    swift_flags |= eTypeIsBuiltIn | eTypeHasChildren | eTypeIsPointer |
+                   eTypeIsScalar | eTypeHasValue | eTypeIsObjC;
+    break;
+  case swift::TypeKind::BuiltinBridgeObject:
+    swift_flags |= eTypeIsBuiltIn | eTypeHasChildren | eTypeIsPointer |
+                   eTypeIsScalar | eTypeHasValue | eTypeIsObjC;
+    break;
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+    swift_flags |=
+        eTypeIsBuiltIn | eTypeIsPointer | eTypeIsScalar | eTypeHasValue;
+    break;
+  case swift::TypeKind::BuiltinVector:
+    // TODO: OR in eTypeIsFloat or eTypeIsInteger as needed
+    return eTypeIsBuiltIn | eTypeHasChildren | eTypeIsVector;
+    break;
+
+  case swift::TypeKind::Tuple:
+    swift_flags |= eTypeHasChildren | eTypeIsTuple;
+    break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    swift_flags |= CompilerType(GetASTContext(),
+                                swift_can_type->getReferenceStorageReferent())
+                       .GetTypeInfo(pointee_or_element_clang_type);
+    break;
+  case swift::TypeKind::BoundGenericEnum:
+    swift_flags |= eTypeIsGeneric | eTypeIsBound;
+  case swift::TypeKind::Enum: {
+    SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+    if (cached_enum_info) {
+      if (cached_enum_info->GetNumElementsWithPayload() == 0)
+        swift_flags |= eTypeHasValue | eTypeIsEnumeration;
+      else
+        swift_flags |= eTypeHasValue | eTypeIsEnumeration | eTypeHasChildren;
+    } else
+      swift_flags |= eTypeIsEnumeration;
+  } break;
+
+  case swift::TypeKind::BoundGenericStruct:
+    swift_flags |= eTypeIsGeneric | eTypeIsBound;
+  case swift::TypeKind::Struct:
+    swift_flags |= eTypeHasChildren | eTypeIsStructUnion;
+    break;
+
+  case swift::TypeKind::BoundGenericClass:
+    swift_flags |= eTypeIsGeneric | eTypeIsBound;
+  case swift::TypeKind::Class:
+    swift_flags |= eTypeHasChildren | eTypeIsClass | eTypeHasValue |
+                   eTypeInstanceIsPointer;
+    break;
+
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::ProtocolComposition:
+    swift_flags |= eTypeHasChildren | eTypeIsStructUnion | eTypeIsProtocol;
+    break;
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype:
+    swift_flags |= eTypeIsMetatype | eTypeHasValue;
+    break;
+
+  case swift::TypeKind::Archetype:
+    swift_flags |=
+        eTypeHasValue | eTypeIsScalar | eTypeIsPointer | eTypeIsArchetype;
+    break;
+
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::LValue:
+    if (pointee_or_element_clang_type)
+      *pointee_or_element_clang_type = GetNonReferenceType(type);
+    swift_flags |= eTypeHasChildren | eTypeIsReference | eTypeHasValue;
+    break;
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+  return swift_flags;
+}
+
+lldb::LanguageType SwiftASTContext::GetMinimumLanguage(void *type) {
+  if (!type)
+    return lldb::eLanguageTypeC;
+
+  return lldb::eLanguageTypeSwift;
+}
+
+lldb::TypeClass SwiftASTContext::GetTypeClass(void *type) {
+  VALID_OR_RETURN(lldb::eTypeClassInvalid);
+
+  if (!type)
+    return lldb::eTypeClassInvalid;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::BuiltinInteger:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinFloat:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinRawPointer:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinNativeObject:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinUnknownObject:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinBridgeObject:
+    return lldb::eTypeClassBuiltin;
+  case swift::TypeKind::BuiltinVector:
+    return lldb::eTypeClassVector;
+  case swift::TypeKind::Tuple:
+    return lldb::eTypeClassArray;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetTypeClass();
+  case swift::TypeKind::GenericTypeParam:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::DependentMember:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::Enum:
+    return lldb::eTypeClassUnion;
+  case swift::TypeKind::Struct:
+    return lldb::eTypeClassStruct;
+  case swift::TypeKind::Class:
+    return lldb::eTypeClassClass;
+  case swift::TypeKind::Protocol:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::Metatype:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::Module:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::Archetype:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::Function:
+    return lldb::eTypeClassFunction;
+  case swift::TypeKind::GenericFunction:
+    return lldb::eTypeClassFunction;
+  case swift::TypeKind::ProtocolComposition:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::LValue:
+    return lldb::eTypeClassReference;
+  case swift::TypeKind::UnboundGeneric:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::BoundGenericClass:
+    return lldb::eTypeClassClass;
+  case swift::TypeKind::BoundGenericEnum:
+    return lldb::eTypeClassUnion;
+  case swift::TypeKind::BoundGenericStruct:
+    return lldb::eTypeClassStruct;
+  case swift::TypeKind::TypeVariable:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::ExistentialMetatype:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::DynamicSelf:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::SILBox:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::SILFunction:
+    return lldb::eTypeClassFunction;
+  case swift::TypeKind::SILBlockStorage:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::InOut:
+    return lldb::eTypeClassOther;
+  case swift::TypeKind::Unresolved:
+    return lldb::eTypeClassOther;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+
+  return lldb::eTypeClassOther;
+}
+
+unsigned SwiftASTContext::GetTypeQualifiers(void *type) { return 0; }
+
+//----------------------------------------------------------------------
+// Creating related types
+//----------------------------------------------------------------------
+
+CompilerType SwiftASTContext::GetArrayElementType(void *type,
+                                                  uint64_t *stride) {
+  VALID_OR_RETURN(CompilerType());
+
+  CompilerType element_type;
+  if (type) {
+    swift::CanType swift_type(GetCanonicalSwiftType(type));
+    // There are a couple of structs that mean "Array" in Swift:
+    // Array<T>
+    // NativeArray<T>
+    // Slice<T>
+    // Treat them as arrays for convenience sake.
+    swift::BoundGenericStructType *boundGenericStructType(
+        swift_type->getAs<swift::BoundGenericStructType>());
+    if (boundGenericStructType) {
+      auto args = boundGenericStructType->getGenericArgs();
+      swift::StructDecl *decl = boundGenericStructType->getDecl();
+      if (args.size() == 1 && decl->getModuleContext()->isStdlibModule()) {
+        const char *declname = decl->getName().get();
+        if (0 == strcmp(declname, "NativeArray") ||
+            0 == strcmp(declname, "Array") ||
+            0 == strcmp(declname, "ArraySlice"))
+          element_type = CompilerType(GetASTContext(), args[0].getPointer());
+      }
+    }
+  }
+  return element_type;
+}
+
+CompilerType SwiftASTContext::GetCanonicalType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type)
+    return CompilerType(GetASTContext(),
+                        GetCanonicalSwiftType(type).getPointer());
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetInstanceType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (!type)
+    return CompilerType();
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+  switch (swift_can_type->getKind()) {
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype: {
+    auto metatype_type =
+        swift::dyn_cast<swift::AnyMetatypeType>(swift_can_type);
+    if (metatype_type)
+      return CompilerType(GetASTContext(),
+                          metatype_type.getInstanceType().getPointer());
+    return CompilerType();
+  }
+  default:
+    break;
+  }
+
+  return CompilerType(GetASTContext(), GetSwiftType(type));
+}
+
+CompilerType SwiftASTContext::GetFullyUnqualifiedType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  return CompilerType(GetASTContext(), GetSwiftType(type));
+}
+
+int SwiftASTContext::GetFunctionArgumentCount(void *type) {
+  return GetNumberOfFunctionArguments(type);
+}
+
+CompilerType SwiftASTContext::GetFunctionArgumentTypeAtIndex(void *type,
+                                                             size_t idx) {
+  return GetFunctionArgumentAtIndex(type, idx);
+}
+
+CompilerType SwiftASTContext::GetFunctionReturnType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    auto func =
+        swift::dyn_cast<swift::AnyFunctionType>(GetCanonicalSwiftType(type));
+    if (func)
+      return CompilerType(GetASTContext(), func.getResult().getPointer());
+  }
+  return CompilerType();
+}
+
+size_t SwiftASTContext::GetNumMemberFunctions(void *type) {
+  size_t num_functions = 0;
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    auto nominal_decl = swift_can_type.getAnyNominal();
+    if (nominal_decl) {
+      auto iter = nominal_decl->getMembers().begin();
+      auto end = nominal_decl->getMembers().end();
+      for (; iter != end; iter++) {
+        switch (iter->getKind()) {
+        case swift::DeclKind::Constructor:
+        case swift::DeclKind::Destructor:
+        case swift::DeclKind::Func:
+          num_functions += 1;
+          break;
+        default:
+          break;
+        }
+      }
+    }
+  }
+  return num_functions;
+}
+
+TypeMemberFunctionImpl SwiftASTContext::GetMemberFunctionAtIndex(void *type,
+                                                                 size_t idx) {
+  VALID_OR_RETURN(TypeMemberFunctionImpl());
+
+  std::string name("");
+  CompilerType result_type;
+  MemberFunctionKind kind(MemberFunctionKind::eMemberFunctionKindUnknown);
+  swift::AbstractFunctionDecl *the_decl_we_care_about = nullptr;
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    auto nominal_decl = swift_can_type.getAnyNominal();
+    if (nominal_decl) {
+      auto iter = nominal_decl->getMembers().begin();
+      auto end = nominal_decl->getMembers().end();
+      for (; iter != end; iter++) {
+        auto decl_kind = iter->getKind();
+        switch (decl_kind) {
+        case swift::DeclKind::Constructor:
+        case swift::DeclKind::Destructor:
+        case swift::DeclKind::Func: {
+          if (idx == 0) {
+            swift::AbstractFunctionDecl *abstract_func_decl =
+                llvm::dyn_cast_or_null<swift::AbstractFunctionDecl>(*iter);
+            if (abstract_func_decl) {
+              switch (decl_kind) {
+              case swift::DeclKind::Constructor:
+                name.clear();
+                kind = lldb::eMemberFunctionKindConstructor;
+                the_decl_we_care_about = abstract_func_decl;
+                break;
+              case swift::DeclKind::Destructor:
+                name.clear();
+                kind = lldb::eMemberFunctionKindDestructor;
+                the_decl_we_care_about = abstract_func_decl;
+                break;
+              case swift::DeclKind::Func:
+              default: // I know that this can only be one of three kinds
+                       // since I am here..
+              {
+                swift::FuncDecl *func_decl =
+                    llvm::dyn_cast<swift::FuncDecl>(*iter);
+                if (func_decl) {
+                  if (func_decl->getName().empty())
+                    name.clear();
+                  else
+                    name.assign(func_decl->getName().get());
+                  if (func_decl->isStatic())
+                    kind = lldb::eMemberFunctionKindStaticMethod;
+                  else
+                    kind = lldb::eMemberFunctionKindInstanceMethod;
+                  the_decl_we_care_about = func_decl;
+                }
+              }
+              }
+              result_type = CompilerType(
+                  GetASTContext(),
+                  abstract_func_decl->getInterfaceType().getPointer());
+            }
+          } else
+            --idx;
+        } break;
+        default:
+          break;
+        }
+      }
+    }
+  }
+
+  if (type && the_decl_we_care_about && (kind != eMemberFunctionKindUnknown))
+    return TypeMemberFunctionImpl(
+        result_type, CompilerDecl(this, the_decl_we_care_about), name, kind);
+
+  return TypeMemberFunctionImpl();
+}
+
+CompilerType SwiftASTContext::GetLValueReferenceType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type)
+    return CompilerType(GetASTContext(),
+                        swift::LValueType::get(GetSwiftType(type)));
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetRValueReferenceType(void *type) {
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetNonReferenceType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    swift::LValueType *lvalue = swift_can_type->getAs<swift::LValueType>();
+    if (lvalue)
+      return CompilerType(GetASTContext(),
+                          lvalue->getObjectType().getPointer());
+    swift::InOutType *inout = swift_can_type->getAs<swift::InOutType>();
+    if (inout)
+      return CompilerType(GetASTContext(), inout->getObjectType().getPointer());
+  }
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetPointeeType(void *type) {
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetPointerType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::Type swift_type(::GetSwiftType(type));
+    const swift::TypeKind type_kind = swift_type->getKind();
+    if (type_kind == swift::TypeKind::BuiltinRawPointer)
+      return CompilerType(GetASTContext(), swift_type);
+    else if (type_kind == swift::TypeKind::Struct)
+      return CompilerType(GetASTContext(), swift::InOutType::get(swift_type));
+  }
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetTypedefedType(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::Type swift_type(::GetSwiftType(type));
+    swift::NameAliasType *name_alias_type =
+        swift::dyn_cast<swift::NameAliasType>(swift_type.getPointer());
+    if (name_alias_type) {
+      return CompilerType(GetASTContext(),
+                          name_alias_type->getSinglyDesugaredType());
+    }
+  }
+
+  return CompilerType();
+}
+
+CompilerType
+SwiftASTContext::GetUnboundType(lldb::opaque_compiler_type_t type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    swift::BoundGenericType *bound_generic_type =
+        swift_can_type->getAs<swift::BoundGenericType>();
+    if (bound_generic_type) {
+      swift::NominalTypeDecl *nominal_type_decl = bound_generic_type->getDecl();
+      if (nominal_type_decl)
+        return CompilerType(GetASTContext(),
+                            nominal_type_decl->getDeclaredType());
+    }
+  }
+
+  return CompilerType(GetASTContext(), GetSwiftType(type));
+}
+
+//----------------------------------------------------------------------
+// Create related types using the current type's AST
+//----------------------------------------------------------------------
+
+CompilerType SwiftASTContext::GetBasicTypeFromAST(lldb::BasicType basic_type) {
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetIntTypeFromBitSize(size_t bit_size,
+                                                    bool is_signed) {
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetFloatTypeFromBitSize(size_t bit_size) {
+  return CompilerType();
+}
+
+//----------------------------------------------------------------------
+// Exploring the type
+//----------------------------------------------------------------------
+
+const swift::irgen::TypeInfo *
+SwiftASTContext::GetSwiftTypeInfo(swift::Type container_type,
+                                  swift::VarDecl *item_decl) {
+  VALID_OR_RETURN(nullptr);
+
+  if (container_type && item_decl) {
+    auto &irgen_module = GetIRGenModule();
+    swift::CanType container_can_type(
+        GetCanonicalSwiftType(container_type.getPointer()));
+    swift::SILType lowered_container_type =
+        irgen_module.getLoweredType(container_can_type);
+    swift::SILType lowered_field_type =
+        lowered_container_type.getFieldType(item_decl, *GetSILModule());
+    return &irgen_module.getTypeInfo(lowered_field_type);
+  }
+
+  return nullptr;
+}
+
+const swift::irgen::TypeInfo *SwiftASTContext::GetSwiftTypeInfo(void *type) {
+  VALID_OR_RETURN(nullptr);
+
+  if (type) {
+    auto &irgen_module = GetIRGenModule();
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    swift::SILType swift_sil_type = irgen_module.getLoweredType(swift_can_type);
+    return &irgen_module.getTypeInfo(swift_sil_type);
+  }
+  return nullptr;
+}
+
+const swift::irgen::FixedTypeInfo *
+SwiftASTContext::GetSwiftFixedTypeInfo(void *type) {
+  VALID_OR_RETURN(nullptr);
+
+  const swift::irgen::TypeInfo *type_info = GetSwiftTypeInfo(type);
+  if (type_info) {
+    if (type_info->isFixedSize())
+      return swift::cast<const swift::irgen::FixedTypeInfo>(type_info);
+  }
+  return nullptr;
+}
+
+uint64_t SwiftASTContext::GetBitSize(lldb::opaque_compiler_type_t type,
+                                     ExecutionContextScope *exe_scope) {
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::Archetype:
+    case swift::TypeKind::LValue:
+    case swift::TypeKind::UnboundGeneric:
+    case swift::TypeKind::GenericFunction:
+    case swift::TypeKind::Function:
+      return GetPointerByteSize() * 8;
+    default:
+      break;
+    }
+    const swift::irgen::FixedTypeInfo *fixed_type_info =
+        GetSwiftFixedTypeInfo(type);
+    if (fixed_type_info)
+      return fixed_type_info->getFixedSize().getValue() * 8;
+  }
+  return 0;
+}
+
+uint64_t SwiftASTContext::GetByteStride(lldb::opaque_compiler_type_t type) {
+  if (type) {
+    const swift::irgen::FixedTypeInfo *fixed_type_info =
+        GetSwiftFixedTypeInfo(type);
+    if (fixed_type_info)
+      return fixed_type_info->getFixedStride().getValue();
+  }
+  return 0;
+}
+
+size_t SwiftASTContext::GetTypeBitAlign(void *type) {
+  if (type) {
+    const swift::irgen::FixedTypeInfo *fixed_type_info =
+        GetSwiftFixedTypeInfo(type);
+    if (fixed_type_info)
+      return fixed_type_info->getFixedAlignment().getValue();
+  }
+  return 0;
+}
+
+lldb::Encoding SwiftASTContext::GetEncoding(void *type, uint64_t &count) {
+  VALID_OR_RETURN(lldb::eEncodingInvalid);
+
+  if (!type)
+    return lldb::eEncodingInvalid;
+
+  count = 1;
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+    break;
+  case swift::TypeKind::BuiltinInteger:
+    return lldb::eEncodingSint; // TODO: detect if an integer is unsigned
+  case swift::TypeKind::BuiltinFloat:
+    return lldb::eEncodingIEEE754; // TODO: detect if an integer is unsigned
+
+  case swift::TypeKind::Archetype:
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::Class: // Classes are pointers in swift...
+  case swift::TypeKind::BoundGenericClass:
+    return lldb::eEncodingUint;
+
+  case swift::TypeKind::BuiltinVector:
+    break;
+  case swift::TypeKind::Tuple:
+    break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetEncoding(count);
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    break;
+
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype:
+    return lldb::eEncodingUint;
+
+  case swift::TypeKind::GenericFunction:
+  case swift::TypeKind::Function:
+    return lldb::eEncodingUint;
+
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum:
+    break;
+
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::Module:
+  case swift::TypeKind::ProtocolComposition:
+    break;
+  case swift::TypeKind::LValue:
+    return lldb::eEncodingUint;
+  case swift::TypeKind::UnboundGeneric:
+  case swift::TypeKind::BoundGenericStruct:
+  case swift::TypeKind::TypeVariable:
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+  count = 0;
+  return lldb::eEncodingInvalid;
+}
+
+lldb::Format SwiftASTContext::GetFormat(void *type) {
+  VALID_OR_RETURN(lldb::eFormatInvalid);
+
+  if (!type)
+    return lldb::eFormatDefault;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+    break;
+  case swift::TypeKind::BuiltinInteger:
+    return eFormatDecimal; // TODO: detect if an integer is unsigned
+  case swift::TypeKind::BuiltinFloat:
+    return eFormatFloat; // TODO: detect if an integer is unsigned
+
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::Archetype:
+    return eFormatAddressInfo;
+
+  // Classes are always pointers in swift...
+  case swift::TypeKind::Class:
+  case swift::TypeKind::BoundGenericClass:
+    return eFormatHex;
+
+  case swift::TypeKind::BuiltinVector:
+    break;
+  case swift::TypeKind::Tuple:
+    break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetFormat();
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    break;
+
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum:
+    return eFormatUnsigned;
+
+  case swift::TypeKind::GenericFunction:
+  case swift::TypeKind::Function:
+    return lldb::eFormatAddressInfo;
+
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::Metatype:
+  case swift::TypeKind::Module:
+  case swift::TypeKind::ProtocolComposition:
+    break;
+  case swift::TypeKind::LValue:
+    return lldb::eFormatHex;
+  case swift::TypeKind::UnboundGeneric:
+  case swift::TypeKind::BoundGenericStruct:
+  case swift::TypeKind::TypeVariable:
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+  // We don't know hot to display this type...
+  return lldb::eFormatBytes;
+}
+
+uint32_t SwiftASTContext::GetNumChildren(void *type,
+                                         bool omit_empty_base_classes) {
+  VALID_OR_RETURN(0);
+
+  if (!type)
+    return 0;
+
+  uint32_t num_children = 0;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+  case swift::TypeKind::BuiltinInteger:
+  case swift::TypeKind::BuiltinFloat:
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::BuiltinVector:
+  case swift::TypeKind::Module:
+  case swift::TypeKind::Function:
+  case swift::TypeKind::GenericFunction:
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::InOut:
+    break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetNumChildren(omit_empty_base_classes);
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    break;
+
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum: {
+    SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+    if (cached_enum_info)
+      return cached_enum_info->GetNumElementsWithPayload();
+  } break;
+
+  case swift::TypeKind::Tuple:
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Class:
+  case swift::TypeKind::BoundGenericClass:
+  case swift::TypeKind::BoundGenericStruct:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::ProtocolComposition:
+  case swift::TypeKind::Archetype: {
+    CachedMemberInfo *cached_member_info = GetCachedMemberInfo(type);
+    if (cached_member_info)
+      return cached_member_info->member_infos.size();
+  } break;
+
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype:
+    return 0;
+
+  case swift::TypeKind::LValue: {
+    swift::LValueType *lvalue_type =
+        swift_can_type->castTo<swift::LValueType>();
+    swift::TypeBase *deref_type = lvalue_type->getObjectType().getPointer();
+
+    uint32_t num_pointee_children =
+        CompilerType(GetASTContext(), deref_type)
+            .GetNumChildren(omit_empty_base_classes);
+    // If this type points to a simple type (or to a class), then it has 1 child
+    if (num_pointee_children == 0 || deref_type->getClassOrBoundGenericClass())
+      num_children = 1;
+    else
+      num_children = num_pointee_children;
+  } break;
+
+  case swift::TypeKind::UnboundGeneric:
+    break;
+  case swift::TypeKind::TypeVariable:
+    break;
+
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+
+  return num_children;
+}
+
+lldb::BasicType SwiftASTContext::GetBasicTypeEnumeration(void *type) {
+  return eBasicTypeInvalid;
+}
+
+#pragma mark Aggregate Types
+
+uint32_t SwiftASTContext::GetNumDirectBaseClasses(void *opaque_type) {
+  if (!opaque_type)
+    return 0;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(opaque_type));
+  swift::ClassDecl *class_decl = swift_can_type->getClassOrBoundGenericClass();
+  if (class_decl) {
+    if (class_decl->hasSuperclass())
+      return 1;
+  }
+
+  return 0;
+}
+
+uint32_t SwiftASTContext::GetNumVirtualBaseClasses(void *opaque_type) {
+  return 0;
+}
+
+uint32_t SwiftASTContext::GetNumFields(void *type) {
+  VALID_OR_RETURN(0);
+
+  if (!type)
+    return 0;
+
+  uint32_t count = 0;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+  case swift::TypeKind::BuiltinInteger:
+  case swift::TypeKind::BuiltinFloat:
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::BuiltinVector:
+    break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetNumFields();
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    break;
+
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum: {
+    SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+    if (cached_enum_info)
+      return cached_enum_info->GetNumElementsWithPayload();
+  } break;
+
+  case swift::TypeKind::Tuple:
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Class:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::ProtocolComposition:
+  case swift::TypeKind::BoundGenericClass:
+  case swift::TypeKind::BoundGenericStruct: {
+    CachedMemberInfo *cached_member_info = GetCachedMemberInfo(type);
+    if (cached_member_info) {
+      const size_t num_members = cached_member_info->member_infos.size();
+      if (num_members > 0 &&
+          cached_member_info->member_infos.front().member_type ==
+              MemberType::BaseClass)
+        return num_members - 1;
+      else
+        return num_members;
+    }
+  } break;
+
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype:
+    return 0;
+
+  case swift::TypeKind::Module:
+  case swift::TypeKind::Archetype:
+  case swift::TypeKind::Function:
+  case swift::TypeKind::GenericFunction:
+  case swift::TypeKind::LValue:
+  case swift::TypeKind::UnboundGeneric:
+  case swift::TypeKind::TypeVariable:
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+
+  return count;
+}
+
+CompilerType
+SwiftASTContext::GetDirectBaseClassAtIndex(void *opaque_type, size_t idx,
+                                           uint32_t *bit_offset_ptr) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (opaque_type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(opaque_type));
+    swift::ClassDecl *class_decl =
+        swift_can_type->getClassOrBoundGenericClass();
+    if (class_decl) {
+      swift::Type base_class_type = class_decl->getSuperclass();
+      if (base_class_type)
+        return CompilerType(GetASTContext(), base_class_type.getPointer());
+    }
+  }
+  return CompilerType();
+}
+
+CompilerType
+SwiftASTContext::GetVirtualBaseClassAtIndex(void *opaque_type, size_t idx,
+                                            uint32_t *bit_offset_ptr) {
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetFieldAtIndex(void *type, size_t idx,
+                                              std::string &name,
+                                              uint64_t *bit_offset_ptr,
+                                              uint32_t *bitfield_bit_size_ptr,
+                                              bool *is_bitfield_ptr) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (!type)
+    return CompilerType();
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+  case swift::TypeKind::BuiltinInteger:
+  case swift::TypeKind::BuiltinFloat:
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::BuiltinVector:
+    break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetFieldAtIndex(idx, name, bit_offset_ptr, bitfield_bit_size_ptr,
+                         is_bitfield_ptr);
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    break;
+
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum: {
+    SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+    if (cached_enum_info &&
+        idx < cached_enum_info->GetNumElementsWithPayload()) {
+      const SwiftEnumDescriptor::ElementInfo *enum_element_info =
+          cached_enum_info->GetElementWithPayloadAtIndex(idx);
+      name.assign(enum_element_info->name.GetCString());
+      if (bit_offset_ptr)
+        *bit_offset_ptr = 0;
+      if (bitfield_bit_size_ptr)
+        *bitfield_bit_size_ptr = 0;
+      if (is_bitfield_ptr)
+        *is_bitfield_ptr = false;
+      return enum_element_info->payload_type;
+    }
+  } break;
+
+  case swift::TypeKind::Tuple:
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Class:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::ProtocolComposition:
+  case swift::TypeKind::BoundGenericClass:
+  case swift::TypeKind::BoundGenericStruct: {
+    CachedMemberInfo *cached_member_info = GetCachedMemberInfo(type);
+    if (cached_member_info) {
+      const size_t num_members = cached_member_info->member_infos.size();
+      uint32_t actual_idx = idx;
+      if (num_members > 0 &&
+          cached_member_info->member_infos.front().member_type ==
+              MemberType::BaseClass)
+        ++actual_idx; // Skip base class since we are looking for fields only
+      if (actual_idx < num_members) {
+        if (cached_member_info->member_infos[actual_idx].name)
+          name = cached_member_info->member_infos[actual_idx].name.GetCString();
+        if (bit_offset_ptr)
+          *bit_offset_ptr =
+              cached_member_info->member_infos[actual_idx].byte_offset * 8;
+        if (bitfield_bit_size_ptr)
+          *bitfield_bit_size_ptr = 0;
+        if (is_bitfield_ptr)
+          *is_bitfield_ptr = false;
+        return cached_member_info->member_infos[actual_idx].clang_type;
+      }
+    }
+  } break;
+
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype:
+    break;
+
+  case swift::TypeKind::Module:
+  case swift::TypeKind::Archetype:
+  case swift::TypeKind::Function:
+  case swift::TypeKind::GenericFunction:
+  case swift::TypeKind::LValue:
+  case swift::TypeKind::UnboundGeneric:
+  case swift::TypeKind::TypeVariable:
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+
+  return CompilerType();
+}
+
+// If a pointer to a pointee type (the clang_type arg) says that it has no
+// children, then we either need to trust it, or override it and return a
+// different result. For example, an "int *" has one child that is an integer,
+// but a function pointer doesn't have any children. Likewise if a Record type
+// claims it has no children, then there really is nothing to show.
+uint32_t SwiftASTContext::GetNumPointeeChildren(void *type) {
+  if (!type)
+    return 0;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+    return 0;
+  case swift::TypeKind::BuiltinInteger:
+    return 1;
+  case swift::TypeKind::BuiltinFloat:
+    return 1;
+  case swift::TypeKind::BuiltinRawPointer:
+    return 1;
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+    return 1;
+  case swift::TypeKind::BuiltinNativeObject:
+    return 1;
+  case swift::TypeKind::BuiltinUnknownObject:
+    return 1;
+  case swift::TypeKind::BuiltinBridgeObject:
+    return 1;
+  case swift::TypeKind::BuiltinVector:
+    return 0;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return GetNumPointeeChildren(
+        swift::cast<swift::ReferenceStorageType>(swift_can_type).getPointer());
+  case swift::TypeKind::Tuple:
+    return 0;
+  case swift::TypeKind::GenericTypeParam:
+    return 0;
+  case swift::TypeKind::DependentMember:
+    return 0;
+  case swift::TypeKind::Enum:
+    return 0;
+  case swift::TypeKind::Struct:
+    return 0;
+  case swift::TypeKind::Class:
+    return 0;
+  case swift::TypeKind::Protocol:
+    return 0;
+  case swift::TypeKind::Metatype:
+    return 0;
+  case swift::TypeKind::Module:
+    return 0;
+  case swift::TypeKind::Archetype:
+    return 0;
+  case swift::TypeKind::Function:
+    return 0;
+  case swift::TypeKind::GenericFunction:
+    return 0;
+  case swift::TypeKind::ProtocolComposition:
+    return 0;
+  case swift::TypeKind::LValue:
+    return 1;
+  case swift::TypeKind::UnboundGeneric:
+    return 0;
+  case swift::TypeKind::BoundGenericClass:
+    return 0;
+  case swift::TypeKind::BoundGenericEnum:
+    return 0;
+  case swift::TypeKind::BoundGenericStruct:
+    return 0;
+  case swift::TypeKind::TypeVariable:
+    return 0;
+  case swift::TypeKind::ExistentialMetatype:
+    return 0;
+  case swift::TypeKind::DynamicSelf:
+    return 0;
+  case swift::TypeKind::SILBox:
+    return 0;
+  case swift::TypeKind::SILFunction:
+    return 0;
+  case swift::TypeKind::SILBlockStorage:
+    return 0;
+  case swift::TypeKind::InOut:
+    return 0;
+  case swift::TypeKind::Unresolved:
+    return 0;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+
+  return 0;
+}
+
+static int64_t GetInstanceVariableOffset_Symbol(ExecutionContext *exe_ctx,
+                                                const CompilerType &type,
+                                                const char *ivar_name,
+                                                const CompilerType &ivar_type) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  ConstString class_name(type.GetTypeSymbolName());
+  Target *target = exe_ctx->GetTargetPtr();
+
+  if (log)
+    log->Printf("[GetInstanceVariableOffset_Symbol] ivar_name = %s, type = %s "
+                "class_name = %s",
+                ivar_name, type.GetTypeName().AsCString(),
+                class_name.AsCString());
+
+  if (target && class_name && ivar_type.IsValid() && ivar_name) {
+    swift::NominalTypeDecl *nominal_decl =
+        GetSwiftType(type)->getNominalOrBoundGenericNominal();
+
+    if (nominal_decl) {
+      swift::ValueDecl *the_value_decl = nullptr;
+      SwiftASTContext *swift_ast_ctx =
+          llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem());
+
+      auto decls = nominal_decl->lookupDirect(swift::DeclName(
+          swift_ast_ctx->GetASTContext()->getIdentifier(ivar_name)));
+      for (auto &decl : decls) {
+        swift::VarDecl *var_decl = llvm::dyn_cast_or_null<swift::VarDecl>(decl);
+        if (var_decl && var_decl->hasStorage()) {
+          the_value_decl = var_decl;
+          break;
+        }
+      }
+
+      if (the_value_decl) {
+        swift::irgen::IRGenMangler mangler;
+        std::string buffer =
+            mangler.mangleFieldOffsetFull(the_value_decl, false);
+
+        StreamString symbol_name;
+        symbol_name.Printf("%s", buffer.c_str());
+        ConstString ivar_const_str(symbol_name.GetString());
+
+        lldb::addr_t ivar_offset_ptr =
+            target->FindLoadAddrForNameInSymbolsAndPersistentVariables(
+                ivar_const_str, eSymbolTypeIVarOffset);
+
+        if (log)
+          log->Printf("[GetInstanceVariableOffset_Symbol] symbol_name = %s "
+                      "ivar_offset_ptr = 0x%" PRIx64,
+                      ivar_const_str.AsCString(), ivar_offset_ptr);
+
+        if (ivar_offset_ptr != LLDB_INVALID_ADDRESS) {
+          Status error;
+          return target->ReadUnsignedIntegerFromMemory(
+              ivar_offset_ptr,
+              false,                     // prefer_file_cache
+              type.GetPointerByteSize(), // byte size of integer to read
+              LLDB_INVALID_IVAR_OFFSET, error);
+        }
+      } else if (log)
+        log->Printf("[GetInstanceVariableOffset_Symbol] no the_value_decl");
+    } else if (log)
+      log->Printf("[GetInstanceVariableOffset_Symbol] no nominal_decl");
+  }
+  return LLDB_INVALID_IVAR_OFFSET;
+}
+
+static int64_t GetInstanceVariableOffset_Metadata(
+    ValueObject *valobj, ExecutionContext *exe_ctx, const CompilerType &type,
+    ConstString ivar_name, const CompilerType &ivar_type) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+  if (log)
+    log->Printf(
+        "[GetInstanceVariableOffset_Metadata] ivar_name = %s, type = %s",
+        ivar_name.AsCString(), type.GetTypeName().AsCString());
+
+  Process *process = exe_ctx->GetProcessPtr();
+  if (process) {
+    SwiftLanguageRuntime *runtime = process->GetSwiftLanguageRuntime();
+    if (runtime) {
+      if (auto resolver_sp = runtime->GetMemberVariableOffsetResolver(type)) {
+        Status error;
+        if (auto result = resolver_sp->ResolveOffset(valobj, ivar_name, &error))
+          return result.getValue();
+        else if (log)
+          log->Printf(
+              "[GetInstanceVariableOffset_Metadata] resolver failure: %s",
+              error.AsCString());
+      } else if (log)
+        log->Printf("[GetInstanceVariableOffset_Metadata] no offset resolver");
+    } else if (log)
+      log->Printf("[GetInstanceVariableOffset_Metadata] no runtime");
+  } else if (log)
+    log->Printf("[GetInstanceVariableOffset_Metadata] no process");
+  return LLDB_INVALID_IVAR_OFFSET;
+}
+
+static int64_t GetInstanceVariableOffset(ValueObject *valobj,
+                                         ExecutionContext *exe_ctx,
+                                         const CompilerType &class_type,
+                                         const char *ivar_name,
+                                         const CompilerType &ivar_type) {
+  int64_t offset = LLDB_INVALID_IVAR_OFFSET;
+
+  if (ivar_name && ivar_name[0]) {
+    if (exe_ctx) {
+      Target *target = exe_ctx->GetTargetPtr();
+      if (target) {
+        // Given a type there are three cases:
+        //   non generic type - field offset symbols are emitted
+        //   generic type:
+        //     iVar offsets depend on the type arguments - no field offsets
+        //     emitted
+        //     iVar offsets do not depend on the type arguments - field offsets
+        //     emitted for the *unbound* type
+
+        bool is_generic = (class_type.GetTypeInfo() & eTypeIsGeneric);
+
+        bool try_symbol = false;
+        bool try_metadata = true;
+
+        if (!is_generic)
+          try_symbol = true;
+
+        if (try_symbol) {
+          offset = GetInstanceVariableOffset_Symbol(exe_ctx, class_type,
+                                                    ivar_name, ivar_type);
+          if (offset != LLDB_INVALID_IVAR_OFFSET)
+            return offset;
+        }
+
+        if (try_metadata) {
+          offset = GetInstanceVariableOffset_Symbol(exe_ctx, class_type,
+                                                    ivar_name, ivar_type);
+          if (offset == LLDB_INVALID_IVAR_OFFSET)
+            offset = GetInstanceVariableOffset_Metadata(
+                valobj, exe_ctx, class_type, ConstString(ivar_name), ivar_type);
+        }
+      }
+    }
+  }
+  return offset;
+}
+
+bool SwiftASTContext::IsNonTriviallyManagedReferenceType(
+    const CompilerType &type, NonTriviallyManagedReferenceStrategy &strategy,
+    CompilerType *underlying_type) {
+  if (auto ast =
+          llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    default:
+      break;
+    case swift::TypeKind::UnmanagedStorage: {
+      strategy = NonTriviallyManagedReferenceStrategy::eUnmanaged;
+      if (underlying_type)
+        *underlying_type = CompilerType(
+            ast, swift_can_type->getReferenceStorageReferent().getPointer());
+    }
+      return true;
+    case swift::TypeKind::UnownedStorage: {
+      strategy = NonTriviallyManagedReferenceStrategy::eUnowned;
+      if (underlying_type)
+        *underlying_type = CompilerType(
+            ast, swift_can_type->getReferenceStorageReferent().getPointer());
+    }
+      return true;
+    case swift::TypeKind::WeakStorage: {
+      strategy = NonTriviallyManagedReferenceStrategy::eWeak;
+      if (underlying_type)
+        *underlying_type = CompilerType(
+            ast, swift_can_type->getReferenceStorageReferent().getPointer());
+    }
+      return true;
+    }
+  }
+  return false;
+}
+
+CompilerType SwiftASTContext::GetChildCompilerTypeAtIndex(
+    void *type, ExecutionContext *exe_ctx, size_t idx,
+    bool transparent_pointers, bool omit_empty_base_classes,
+    bool ignore_array_bounds, std::string &child_name,
+    uint32_t &child_byte_size, int32_t &child_byte_offset,
+    uint32_t &child_bitfield_bit_size, uint32_t &child_bitfield_bit_offset,
+    bool &child_is_base_class, bool &child_is_deref_of_parent,
+    ValueObject *valobj, uint64_t &language_flags) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (!type)
+    return CompilerType();
+
+  language_flags = 0;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+  case swift::TypeKind::BuiltinInteger:
+  case swift::TypeKind::BuiltinFloat:
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::BuiltinVector:
+
+  //            case swift::TypeKind::Tuple:
+  //                {
+  //                    swift::TupleType *tuple_type =
+  //                    swift_can_type->getAs<swift::TupleType>();
+  //                    if (tuple_type && idx < tuple_type->getNumElements())
+  //                    {
+  //                        child_byte_offset = 0; // TODO: figure out how to
+  //                        get byte offset of tuple field...
+  //                        child_bitfield_bit_size = 0;
+  //                        child_bitfield_bit_offset = 0;
+  //                        child_is_base_class = false;
+  //                        child_is_deref_of_parent = false;
+  //
+  //                        uint32_t tuple_idx = 0;
+  //                        for (auto tuple_field : tuple_type->getFields())
+  //                        {
+  //                            CompilerType tuple_field_type(m_swift_ast,
+  //                            tuple_field.getType().getPointer());
+  //                            auto tuple_field_byte_size =
+  //                            tuple_field_type.GetByteSize();
+  //
+  //                            if (tuple_idx == idx)
+  //                            {
+  //                                child_byte_size = tuple_field_byte_size;
+  //                                const char *tuple_name =
+  //                                tuple_field.getName().get();
+  //                                if (tuple_name)
+  //                                {
+  //                                    child_name = tuple_name;
+  //                                }
+  //                                else
+  //                                {
+  //                                    StreamString tuple_name_strm;
+  //                                    tuple_name_strm.Printf("%u",
+  //                                    (uint32_t)idx);
+  //                                    child_name =
+  //                                    std::move(tuple_name_strm.GetString());
+  //                                }
+  //                                return tuple_field_type;
+  //                            }
+  //                            else
+  //                            {
+  //                                const uint64_t tuple_field_bit_size =
+  //                                tuple_field_byte_size * 8;
+  //                                const uint64_t tuple_aligned_bit_size =
+  //                                tuple_field_type.GetAlignedBitSize();
+  //                                child_byte_offset +=
+  //                                llvm::RoundUpToAlignment(tuple_field_bit_size,
+  //                                tuple_aligned_bit_size) / 8;
+  //                                ++tuple_idx;
+  //                            }
+  //                        }
+  //                    }
+  //                }
+  //                break;
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .GetChildCompilerTypeAtIndex(
+            exe_ctx, idx, transparent_pointers, omit_empty_base_classes,
+            ignore_array_bounds, child_name, child_byte_size, child_byte_offset,
+            child_bitfield_bit_size, child_bitfield_bit_offset,
+            child_is_base_class, child_is_deref_of_parent, valobj,
+            language_flags);
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    break;
+
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum: {
+    SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+    if (cached_enum_info &&
+        idx < cached_enum_info->GetNumElementsWithPayload()) {
+      const SwiftEnumDescriptor::ElementInfo *element_info =
+          cached_enum_info->GetElementWithPayloadAtIndex(idx);
+      child_name.assign(element_info->name.GetCString());
+      child_byte_size = element_info->payload_type.GetByteSize(
+          exe_ctx ? exe_ctx->GetBestExecutionContextScope() : NULL);
+      child_byte_offset = 0;
+      child_bitfield_bit_size = 0;
+      child_bitfield_bit_offset = 0;
+      child_is_base_class = false;
+      child_is_deref_of_parent = false;
+      if (element_info->is_indirect) {
+        language_flags |= LanguageFlags::eIsIndirectEnumCase;
+        return CompilerType(GetASTContext(),
+                            GetASTContext()->TheRawPointerType.getPointer());
+      } else
+        return element_info->payload_type;
+    }
+  } break;
+
+  case swift::TypeKind::Tuple:
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Class:
+  case swift::TypeKind::BoundGenericClass:
+  case swift::TypeKind::BoundGenericStruct:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::ProtocolComposition: {
+    CachedMemberInfo *cached_member_info = GetCachedMemberInfo(type);
+    if (cached_member_info) {
+      const size_t num_members = cached_member_info->member_infos.size();
+      if (idx < num_members) {
+        if (cached_member_info->member_infos[idx].name)
+          child_name = cached_member_info->member_infos[idx].name.GetCString();
+        else
+          child_name.clear();
+        child_byte_size = cached_member_info->member_infos[idx].byte_size;
+        // Check for fragile ivar offsets and look them up and cache them.
+        if (cached_member_info->member_infos[idx].is_fragile &&
+            cached_member_info->member_infos[idx].byte_offset == 0) {
+          CompilerType compiler_type(GetASTContext(), GetSwiftType(type));
+          const int64_t fragile_ivar_offset = GetInstanceVariableOffset(
+              valobj, exe_ctx, compiler_type, child_name.c_str(),
+              cached_member_info->member_infos[idx].clang_type);
+          if (fragile_ivar_offset != LLDB_INVALID_IVAR_OFFSET)
+            cached_member_info->member_infos[idx].byte_offset =
+                fragile_ivar_offset;
+        }
+        child_byte_offset = cached_member_info->member_infos[idx].byte_offset;
+        child_bitfield_bit_size = 0;
+        child_bitfield_bit_offset = 0;
+        if ((child_is_base_class =
+                 cached_member_info->member_infos[idx].member_type ==
+                 MemberType::BaseClass)) {
+          language_flags |= LanguageFlags::eIgnoreInstancePointerness;
+        }
+        child_is_deref_of_parent = false;
+        return cached_member_info->member_infos[idx].clang_type;
+      }
+    }
+  } break;
+
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype:
+    break;
+
+  case swift::TypeKind::Module:
+  case swift::TypeKind::Archetype:
+  case swift::TypeKind::Function:
+  case swift::TypeKind::GenericFunction:
+    break;
+
+  case swift::TypeKind::LValue:
+    if (idx < GetNumChildren(type, omit_empty_base_classes)) {
+      CompilerType pointee_clang_type(GetNonReferenceType(type));
+      Flags pointee_clang_type_flags(pointee_clang_type.GetTypeInfo());
+      const char *parent_name = valobj ? valobj->GetName().GetCString() : NULL;
+      if (parent_name) {
+        child_name.assign(1, '&');
+        child_name += parent_name;
+      }
+
+      // We have a pointer to a simple type
+      if (idx == 0) {
+        child_byte_size = pointee_clang_type.GetByteSize(
+            exe_ctx ? exe_ctx->GetBestExecutionContextScope() : NULL);
+        child_byte_offset = 0;
+        return pointee_clang_type;
+      }
+    }
+    break;
+  case swift::TypeKind::UnboundGeneric:
+    break;
+  case swift::TypeKind::TypeVariable:
+    break;
+
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+  return CompilerType();
+}
+
+// Look for a child member (doesn't include base classes, but it does include
+// their members) in the type hierarchy. Returns an index path into "clang_type"
+// on how to reach the appropriate member.
+//
+//    class A
+//    {
+//    public:
+//        int m_a;
+//        int m_b;
+//    };
+//
+//    class B
+//    {
+//    };
+//
+//    class C :
+//        public B,
+//        public A
+//    {
+//    };
+//
+// If we have a clang type that describes "class C", and we wanted to look for
+// "m_b" in it:
+//
+// With omit_empty_base_classes == false we would get an integer array back
+// with:
+// { 1,  1 }
+// The first index 1 is the child index for "class A" within class C.
+// The second index 1 is the child index for "m_b" within class A.
+//
+// With omit_empty_base_classes == true we would get an integer array back with:
+// { 0,  1 }
+// The first index 0 is the child index for "class A" within class C (since
+// class B doesn't have any members it doesn't count).
+// The second index 1 is the child index for "m_b" within class A.
+
+size_t SwiftASTContext::GetIndexOfChildMemberWithName(
+    void *type, const char *name, bool omit_empty_base_classes,
+    std::vector<uint32_t> &child_indexes) {
+  VALID_OR_RETURN(0);
+
+  if (type && name && name[0]) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::Error:
+    case swift::TypeKind::BuiltinInteger:
+    case swift::TypeKind::BuiltinFloat:
+    case swift::TypeKind::BuiltinRawPointer:
+    case swift::TypeKind::BuiltinNativeObject:
+    case swift::TypeKind::BuiltinUnknownObject:
+    case swift::TypeKind::BuiltinUnsafeValueBuffer:
+    case swift::TypeKind::BuiltinBridgeObject:
+    case swift::TypeKind::BuiltinVector:
+      break;
+
+    case swift::TypeKind::UnmanagedStorage:
+    case swift::TypeKind::UnownedStorage:
+    case swift::TypeKind::WeakStorage:
+      return CompilerType(GetASTContext(),
+                          swift_can_type->getReferenceStorageReferent())
+          .GetIndexOfChildMemberWithName(name, omit_empty_base_classes,
+                                         child_indexes);
+    case swift::TypeKind::GenericTypeParam:
+    case swift::TypeKind::DependentMember:
+      break;
+
+    case swift::TypeKind::Enum:
+    case swift::TypeKind::BoundGenericEnum: {
+      SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+      if (cached_enum_info) {
+        ConstString const_name(name);
+        const size_t num_sized_elements =
+            cached_enum_info->GetNumElementsWithPayload();
+        for (size_t i = 0; i < num_sized_elements; ++i) {
+          if (cached_enum_info->GetElementWithPayloadAtIndex(i)->name ==
+              const_name) {
+            child_indexes.push_back(i);
+            return child_indexes.size();
+          }
+        }
+      }
+    } break;
+
+    case swift::TypeKind::Tuple: {
+      // For tuples only always look for the member by number first as a tuple
+      // element can be named, yet still be accessed by the number...
+      swift::TupleType *tuple_type = swift_can_type->castTo<swift::TupleType>();
+      uint32_t tuple_idx = StringConvert::ToUInt32(name, UINT32_MAX);
+      if (tuple_idx != UINT32_MAX) {
+        if (tuple_idx < tuple_type->getNumElements()) {
+          child_indexes.push_back(tuple_idx);
+          return child_indexes.size();
+        } else
+          return 0;
+      }
+    }
+    // Fall through to class/union/struct case...
+    case swift::TypeKind::Struct:
+    case swift::TypeKind::Class:
+    case swift::TypeKind::Protocol:
+    case swift::TypeKind::ProtocolComposition:
+    case swift::TypeKind::BoundGenericClass:
+    case swift::TypeKind::BoundGenericStruct: {
+      CachedMemberInfo *cached_member_info = GetCachedMemberInfo(type);
+      if (cached_member_info) {
+        ConstString const_name(name);
+        const size_t num_members = cached_member_info->member_infos.size();
+        if (num_members > 0) {
+          for (size_t i = 0; i < num_members; ++i) {
+            const MemberInfo &member_info = cached_member_info->member_infos[i];
+            if (member_info.name &&
+                member_info.member_type != MemberType::BaseClass) {
+              if (const_name == member_info.name) {
+                child_indexes.push_back(i);
+                return child_indexes.size();
+              }
+            }
+          }
+          // Check the base class if we have one...
+          if (cached_member_info->member_infos[0].member_type ==
+              MemberType::BaseClass) {
+            // Push index zero for the base class
+            child_indexes.push_back(0);
+
+            if (cached_member_info->member_infos[0]
+                    .clang_type.GetIndexOfChildMemberWithName(
+                        name, omit_empty_base_classes, child_indexes)) {
+              // We did find an ivar in a superclass so just
+              // return the results!
+              return child_indexes.size();
+            }
+            // We didn't find an ivar matching "name" in our
+            // superclass, pop the superclass zero index that
+            // we pushed on above.
+            child_indexes.pop_back();
+          }
+        }
+      }
+    } break;
+
+    case swift::TypeKind::ExistentialMetatype:
+    case swift::TypeKind::Metatype:
+      break;
+
+    case swift::TypeKind::Module:
+    case swift::TypeKind::Archetype:
+    case swift::TypeKind::Function:
+    case swift::TypeKind::GenericFunction:
+      break;
+    case swift::TypeKind::InOut:
+    case swift::TypeKind::LValue: {
+      CompilerType pointee_clang_type(GetNonReferenceType(type));
+
+      if (pointee_clang_type.IsAggregateType()) {
+        return pointee_clang_type.GetIndexOfChildMemberWithName(
+            name, omit_empty_base_classes, child_indexes);
+      }
+    } break;
+    case swift::TypeKind::UnboundGeneric:
+      break;
+    case swift::TypeKind::TypeVariable:
+      break;
+
+    case swift::TypeKind::DynamicSelf:
+    case swift::TypeKind::SILBox:
+    case swift::TypeKind::SILFunction:
+    case swift::TypeKind::SILBlockStorage:
+    case swift::TypeKind::Unresolved:
+      break;
+
+    case swift::TypeKind::Optional:
+    case swift::TypeKind::ImplicitlyUnwrappedOptional:
+    case swift::TypeKind::NameAlias:
+    case swift::TypeKind::Paren:
+    case swift::TypeKind::Dictionary:
+    case swift::TypeKind::ArraySlice:
+      assert(false && "Not a canonical type");
+      break;
+    }
+  }
+  return 0;
+}
+
+// Get the index of the child of "clang_type" whose name matches. This function
+// doesn't descend into the children, but only looks one level deep and name
+// matches can include base class names.
+
+uint32_t
+SwiftASTContext::GetIndexOfChildWithName(void *type, const char *name,
+                                         bool omit_empty_base_classes) {
+  VALID_OR_RETURN(UINT32_MAX);
+
+  if (type && name && name[0]) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::Error:
+    case swift::TypeKind::BuiltinInteger:
+    case swift::TypeKind::BuiltinFloat:
+    case swift::TypeKind::BuiltinRawPointer:
+    case swift::TypeKind::BuiltinNativeObject:
+    case swift::TypeKind::BuiltinUnsafeValueBuffer:
+    case swift::TypeKind::BuiltinUnknownObject:
+    case swift::TypeKind::BuiltinBridgeObject:
+    case swift::TypeKind::BuiltinVector:
+      break;
+    case swift::TypeKind::UnmanagedStorage:
+    case swift::TypeKind::UnownedStorage:
+    case swift::TypeKind::WeakStorage:
+      return CompilerType(GetASTContext(),
+                          swift_can_type->getReferenceStorageReferent())
+          .GetIndexOfChildWithName(name, omit_empty_base_classes);
+    case swift::TypeKind::GenericTypeParam:
+    case swift::TypeKind::DependentMember:
+      break;
+
+    case swift::TypeKind::Enum:
+    case swift::TypeKind::BoundGenericEnum: {
+      SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+      if (cached_enum_info) {
+        ConstString const_name(name);
+        const size_t num_sized_elements =
+            cached_enum_info->GetNumElementsWithPayload();
+        for (size_t i = 0; i < num_sized_elements; ++i) {
+          if (cached_enum_info->GetElementWithPayloadAtIndex(i)->name ==
+              const_name)
+            return i;
+        }
+      }
+    } break;
+
+    case swift::TypeKind::Tuple: {
+      swift::TupleType *tuple_type = swift_can_type->castTo<swift::TupleType>();
+      uint32_t tuple_idx = StringConvert::ToUInt32(name, UINT32_MAX);
+      if (tuple_idx != UINT32_MAX) {
+        if (tuple_idx < tuple_type->getNumElements())
+          return tuple_idx;
+      }
+    }
+    // Fall through to struct/union/class case...
+    case swift::TypeKind::Struct:
+    case swift::TypeKind::Class:
+    case swift::TypeKind::Protocol:
+    case swift::TypeKind::ProtocolComposition:
+    case swift::TypeKind::BoundGenericClass:
+    case swift::TypeKind::BoundGenericStruct: {
+      CachedMemberInfo *cached_member_info = GetCachedMemberInfo(type);
+      if (cached_member_info) {
+        ConstString const_name(name);
+        const size_t num_members = cached_member_info->member_infos.size();
+        if (num_members > 0) {
+          for (size_t i = 0; i < num_members; ++i) {
+            const MemberInfo &member_info = cached_member_info->member_infos[i];
+            if (member_info.name &&
+                member_info.member_type != MemberType::BaseClass) {
+              if (const_name == member_info.name)
+                return i;
+            }
+          }
+          // Check the base class name if we have one...
+          if (cached_member_info->member_infos[0].member_type ==
+                  MemberType::BaseClass &&
+              cached_member_info->member_infos[0].name == const_name) {
+            return 0;
+          }
+        }
+      }
+    }
+
+    break;
+
+    case swift::TypeKind::ExistentialMetatype:
+    case swift::TypeKind::Metatype:
+      break;
+
+    case swift::TypeKind::Module:
+    case swift::TypeKind::Archetype:
+    case swift::TypeKind::Function:
+    case swift::TypeKind::GenericFunction:
+      break;
+    case swift::TypeKind::InOut:
+    case swift::TypeKind::LValue: {
+      CompilerType pointee_type(GetNonReferenceType(type));
+
+      if (pointee_type.IsAggregateType()) {
+        return pointee_type.GetIndexOfChildWithName(name,
+                                                    omit_empty_base_classes);
+      }
+    } break;
+    case swift::TypeKind::UnboundGeneric:
+      break;
+    case swift::TypeKind::TypeVariable:
+      break;
+
+    case swift::TypeKind::DynamicSelf:
+    case swift::TypeKind::SILBox:
+    case swift::TypeKind::SILFunction:
+    case swift::TypeKind::SILBlockStorage:
+    case swift::TypeKind::Unresolved:
+      break;
+
+    case swift::TypeKind::Optional:
+    case swift::TypeKind::ImplicitlyUnwrappedOptional:
+    case swift::TypeKind::NameAlias:
+    case swift::TypeKind::Paren:
+    case swift::TypeKind::Dictionary:
+    case swift::TypeKind::ArraySlice:
+      assert(false && "Not a canonical type");
+      break;
+    }
+  }
+  return UINT32_MAX;
+}
+
+size_t SwiftASTContext::GetNumTemplateArguments(void *type) {
+  if (!type)
+    return 0;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::UnboundGeneric: {
+    swift::UnboundGenericType *unbound_generic_type =
+        swift_can_type->castTo<swift::UnboundGenericType>();
+    auto *nominal_type_decl = unbound_generic_type->getDecl();
+    swift::GenericParamList *generic_param_list =
+        nominal_type_decl->getGenericParams();
+    return generic_param_list->getParams().size();
+  } break;
+  case swift::TypeKind::BoundGenericClass:
+  case swift::TypeKind::BoundGenericStruct:
+  case swift::TypeKind::BoundGenericEnum: {
+    swift::BoundGenericType *bound_generic_type =
+        swift_can_type->castTo<swift::BoundGenericType>();
+    return bound_generic_type->getGenericArgs().size();
+  }
+  default:
+    break;
+  }
+
+  return 0;
+}
+
+bool SwiftASTContext::GetSelectedEnumCase(const CompilerType &type,
+                                          const DataExtractor &data,
+                                          ConstString *name, bool *has_payload,
+                                          CompilerType *payload,
+                                          bool *is_indirect) {
+  if (auto ast =
+          llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    default:
+      break;
+    case swift::TypeKind::Enum:
+    case swift::TypeKind::BoundGenericEnum: {
+      SwiftEnumDescriptor *cached_enum_info =
+          ast->GetCachedEnumInfo(swift_can_type.getPointer());
+      if (cached_enum_info) {
+        auto enum_elem_info = cached_enum_info->GetElementFromData(data);
+        if (enum_elem_info) {
+          if (name)
+            *name = enum_elem_info->name;
+          if (has_payload)
+            *has_payload = enum_elem_info->has_payload;
+          if (payload)
+            *payload = enum_elem_info->payload_type;
+          if (is_indirect)
+            *is_indirect = enum_elem_info->is_indirect;
+          return true;
+        }
+      }
+    } break;
+    }
+  }
+
+  return false;
+}
+
+CompilerType
+SwiftASTContext::GetTemplateArgument(void *type, size_t arg_idx,
+                                     lldb::TemplateArgumentKind &kind) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    if (auto *unbound_generic_type =
+            swift_can_type->getAs<swift::UnboundGenericType>()) {
+      auto *nominal_type_decl = unbound_generic_type->getDecl();
+      swift::GenericSignature *generic_sig =
+          nominal_type_decl->getGenericSignature();
+      auto depTy = generic_sig->getGenericParams()[arg_idx];
+      return CompilerType(GetASTContext(),
+                          nominal_type_decl->mapTypeIntoContext(depTy)
+                              ->castTo<swift::ArchetypeType>());
+    }
+    if (auto *bound_generic_type =
+            swift_can_type->getAs<swift::BoundGenericType>()) {
+      if (arg_idx < bound_generic_type->getGenericArgs().size()) {
+        kind = eTemplateArgumentKindType;
+        return CompilerType(
+            GetASTContext(),
+            bound_generic_type->getGenericArgs()[arg_idx].getPointer());
+      }
+    }
+  }
+
+  kind = eTemplateArgumentKindNull;
+  return CompilerType();
+}
+
+CompilerType SwiftASTContext::GetTypeForFormatters(void *type) {
+  VALID_OR_RETURN(CompilerType());
+
+  if (type) {
+    swift::Type swift_type(GetSwiftType(type));
+    return CompilerType(GetASTContext(), swift_type);
+  }
+  return CompilerType();
+}
+
+LazyBool SwiftASTContext::ShouldPrintAsOneLiner(void *type,
+                                                ValueObject *valobj) {
+  if (type) {
+    CompilerType can_compiler_type(GetCanonicalType(type));
+    if (IsImportedType(can_compiler_type, nullptr))
+      return eLazyBoolNo;
+  }
+  if (valobj) {
+    if (valobj->IsBaseClass())
+      return eLazyBoolNo;
+    if ((valobj->GetLanguageFlags() & LanguageFlags::eIsIndirectEnumCase) ==
+        LanguageFlags::eIsIndirectEnumCase)
+      return eLazyBoolNo;
+  }
+
+  return eLazyBoolCalculate;
+}
+
+bool SwiftASTContext::IsMeaninglessWithoutDynamicResolution(void *type) {
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+    const swift::TypeKind type_kind = swift_can_type->getKind();
+    switch (type_kind) {
+    case swift::TypeKind::Archetype:
+      return true;
+    default:
+      return false;
+    }
+  }
+
+  return false;
+}
+
+//----------------------------------------------------------------------
+// Dumping types
+//----------------------------------------------------------------------
+#define DEPTH_INCREMENT 2
+
+void SwiftASTContext::DumpValue(
+    void *type, ExecutionContext *exe_ctx, Stream *s, lldb::Format format,
+    const lldb_private::DataExtractor &data, lldb::offset_t data_byte_offset,
+    size_t data_byte_size, uint32_t bitfield_bit_size,
+    uint32_t bitfield_bit_offset, bool show_types, bool show_summary,
+    bool verbose, uint32_t depth) {}
+
+bool SwiftASTContext::DumpTypeValue(
+    void *type, Stream *s, lldb::Format format,
+    const lldb_private::DataExtractor &data, lldb::offset_t byte_offset,
+    size_t byte_size, uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,
+    ExecutionContextScope *exe_scope, bool is_base_class) {
+  VALID_OR_RETURN(false);
+
+  if (!type)
+    return false;
+
+  swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+
+  const swift::TypeKind type_kind = swift_can_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Error:
+    break;
+
+  case swift::TypeKind::Class:
+  case swift::TypeKind::BoundGenericClass:
+    // If we have a class that is in a variable then it is a pointer,
+    // else if it is a base class, it has no value.
+    if (is_base_class)
+      break;
+  // Fall through to case below
+  case swift::TypeKind::BuiltinInteger:
+  case swift::TypeKind::BuiltinFloat:
+  case swift::TypeKind::BuiltinRawPointer:
+  case swift::TypeKind::BuiltinNativeObject:
+  case swift::TypeKind::BuiltinUnsafeValueBuffer:
+  case swift::TypeKind::BuiltinUnknownObject:
+  case swift::TypeKind::BuiltinBridgeObject:
+  case swift::TypeKind::Archetype:
+  case swift::TypeKind::Function:
+  case swift::TypeKind::GenericFunction:
+  case swift::TypeKind::LValue: {
+    uint32_t item_count = 1;
+    // A few formats, we might need to modify our size and count for depending
+    // on how we are trying to display the value...
+    switch (format) {
+    default:
+    case eFormatBoolean:
+    case eFormatBinary:
+    case eFormatComplex:
+    case eFormatCString: // NULL terminated C strings
+    case eFormatDecimal:
+    case eFormatEnum:
+    case eFormatHex:
+    case eFormatHexUppercase:
+    case eFormatFloat:
+    case eFormatOctal:
+    case eFormatOSType:
+    case eFormatUnsigned:
+    case eFormatPointer:
+    case eFormatVectorOfChar:
+    case eFormatVectorOfSInt8:
+    case eFormatVectorOfUInt8:
+    case eFormatVectorOfSInt16:
+    case eFormatVectorOfUInt16:
+    case eFormatVectorOfSInt32:
+    case eFormatVectorOfUInt32:
+    case eFormatVectorOfSInt64:
+    case eFormatVectorOfUInt64:
+    case eFormatVectorOfFloat32:
+    case eFormatVectorOfFloat64:
+    case eFormatVectorOfUInt128:
+      break;
+
+    case eFormatAddressInfo:
+      if (byte_size == 0) {
+        byte_size = exe_scope->CalculateTarget()
+                        ->GetArchitecture()
+                        .GetAddressByteSize();
+        item_count = 1;
+      }
+      break;
+
+    case eFormatChar:
+    case eFormatCharPrintable:
+    case eFormatCharArray:
+    case eFormatBytes:
+    case eFormatBytesWithASCII:
+      item_count = byte_size;
+      byte_size = 1;
+      break;
+
+    case eFormatUnicode16:
+      item_count = byte_size / 2;
+      byte_size = 2;
+      break;
+
+    case eFormatUnicode32:
+      item_count = byte_size / 4;
+      byte_size = 4;
+      break;
+    }
+    return DumpDataExtractor(data, s, byte_offset, format, byte_size,
+                             item_count, UINT32_MAX, LLDB_INVALID_ADDRESS,
+                             bitfield_bit_size, bitfield_bit_offset, exe_scope);
+  } break;
+  case swift::TypeKind::BuiltinVector:
+    break;
+
+  case swift::TypeKind::Tuple:
+    break;
+
+  case swift::TypeKind::UnmanagedStorage:
+  case swift::TypeKind::UnownedStorage:
+  case swift::TypeKind::WeakStorage:
+    return CompilerType(GetASTContext(),
+                        swift_can_type->getReferenceStorageReferent())
+        .DumpTypeValue(s, format, data, byte_offset, byte_size,
+                       bitfield_bit_size, bitfield_bit_offset, exe_scope,
+                       is_base_class);
+  case swift::TypeKind::Enum:
+  case swift::TypeKind::BoundGenericEnum: {
+    SwiftEnumDescriptor *cached_enum_info = GetCachedEnumInfo(type);
+    if (cached_enum_info) {
+      auto enum_elem_info = cached_enum_info->GetElementFromData(data);
+      if (enum_elem_info)
+        s->Printf("%s", enum_elem_info->name.GetCString());
+      else {
+        lldb::offset_t ptr = 0;
+        if (data.GetByteSize())
+          s->Printf("<invalid> (0x%" PRIx8 ")", data.GetU8(&ptr));
+        else
+          s->Printf("<empty>");
+      }
+      return true;
+    } else
+      s->Printf("<unknown type>");
+  } break;
+
+  case swift::TypeKind::Struct:
+  case swift::TypeKind::Protocol:
+  case swift::TypeKind::GenericTypeParam:
+  case swift::TypeKind::DependentMember:
+    return false;
+
+  case swift::TypeKind::ExistentialMetatype:
+  case swift::TypeKind::Metatype: {
+    return DumpDataExtractor(data, s, byte_offset, eFormatPointer, byte_size, 1,
+                             UINT32_MAX, LLDB_INVALID_ADDRESS,
+                             bitfield_bit_size, bitfield_bit_offset, exe_scope);
+  } break;
+
+  case swift::TypeKind::Module:
+  case swift::TypeKind::ProtocolComposition:
+  case swift::TypeKind::UnboundGeneric:
+  case swift::TypeKind::BoundGenericStruct:
+  case swift::TypeKind::TypeVariable:
+  case swift::TypeKind::DynamicSelf:
+  case swift::TypeKind::SILBox:
+  case swift::TypeKind::SILFunction:
+  case swift::TypeKind::SILBlockStorage:
+  case swift::TypeKind::InOut:
+  case swift::TypeKind::Unresolved:
+    break;
+
+  case swift::TypeKind::Optional:
+  case swift::TypeKind::ImplicitlyUnwrappedOptional:
+  case swift::TypeKind::NameAlias:
+  case swift::TypeKind::Paren:
+  case swift::TypeKind::Dictionary:
+  case swift::TypeKind::ArraySlice:
+    assert(false && "Not a canonical type");
+    break;
+  }
+
+  return 0;
+}
+
+bool SwiftASTContext::IsImportedType(const CompilerType &type,
+                                     CompilerType *original_type) {
+  bool success = false;
+
+  if (llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+    do {
+      swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+      swift::NominalType *nominal_type =
+          swift_can_type->getAs<swift::NominalType>();
+      if (!nominal_type)
+        break;
+      swift::NominalTypeDecl *nominal_type_decl = nominal_type->getDecl();
+      if (nominal_type_decl && nominal_type_decl->hasClangNode()) {
+        const clang::Decl *clang_decl = nominal_type_decl->getClangDecl();
+        if (!clang_decl)
+          break;
+        success = true;
+        if (!original_type)
+          break;
+
+        if (const clang::ObjCInterfaceDecl *objc_interface_decl =
+                llvm::dyn_cast<clang::ObjCInterfaceDecl>(
+                    clang_decl)) // ObjCInterfaceDecl is not a TypeDecl
+        {
+          *original_type =
+              CompilerType(&objc_interface_decl->getASTContext(),
+                           clang::QualType::getFromOpaquePtr(
+                               objc_interface_decl->getTypeForDecl()));
+        } else if (const clang::TypeDecl *type_decl =
+                       llvm::dyn_cast<clang::TypeDecl>(clang_decl)) {
+          *original_type = CompilerType(
+              &type_decl->getASTContext(),
+              clang::QualType::getFromOpaquePtr(type_decl->getTypeForDecl()));
+        } else // TODO: any more cases that we care about?
+        {
+          *original_type = CompilerType();
+        }
+      }
+    } while (0);
+  }
+
+  return success;
+}
+
+bool SwiftASTContext::IsImportedObjectiveCType(const CompilerType &type,
+                                               CompilerType *original_type) {
+  bool success = false;
+
+  if (llvm::dyn_cast_or_null<SwiftASTContext>(type.GetTypeSystem())) {
+    CompilerType local_original_type;
+
+    if (IsImportedType(type, &local_original_type)) {
+      if (local_original_type.IsValid()) {
+        ClangASTContext *clang_ast = llvm::dyn_cast_or_null<ClangASTContext>(
+            local_original_type.GetTypeSystem());
+        if (clang_ast &&
+            clang_ast->IsObjCObjectOrInterfaceType(local_original_type)) {
+          if (original_type)
+            *original_type = local_original_type;
+          success = true;
+        }
+      }
+    }
+  }
+
+  return success;
+}
+
+void SwiftASTContext::DumpSummary(void *type, ExecutionContext *exe_ctx,
+                                  Stream *s,
+                                  const lldb_private::DataExtractor &data,
+                                  lldb::offset_t data_byte_offset,
+                                  size_t data_byte_size) {}
+
+size_t SwiftASTContext::ConvertStringToFloatValue(void *type, const char *s,
+                                                  uint8_t *dst,
+                                                  size_t dst_size) {
+  return 0;
+}
+
+void SwiftASTContext::DumpTypeDescription(void *type) {
+  StreamFile s(stdout, false);
+  DumpTypeDescription(type, &s);
+}
+
+void SwiftASTContext::DumpTypeDescription(void *type, Stream *s) {
+  DumpTypeDescription(type, s, false, true);
+}
+
+void SwiftASTContext::DumpTypeDescription(void *type,
+                                          bool print_help_if_available,
+                                          bool print_extensions_if_available) {
+  StreamFile s(stdout, false);
+  DumpTypeDescription(type, &s, print_help_if_available,
+                      print_extensions_if_available);
+}
+
+static void PrintSwiftNominalType(swift::NominalTypeDecl *nominal_type_decl,
+                                  Stream *s, bool print_help_if_available,
+                                  bool print_extensions_if_available) {
+  if (nominal_type_decl && s) {
+    std::string buffer;
+    llvm::raw_string_ostream ostream(buffer);
+    const swift::PrintOptions &print_options(
+        SwiftASTContext::GetUserVisibleTypePrintingOptions(
+            print_help_if_available));
+    nominal_type_decl->print(ostream, print_options);
+    ostream.flush();
+    if (buffer.empty() == false)
+      s->Printf("%s\n", buffer.c_str());
+    if (print_extensions_if_available) {
+      for (auto ext : nominal_type_decl->getExtensions()) {
+        if (ext) {
+          buffer.clear();
+          llvm::raw_string_ostream ext_ostream(buffer);
+          ext->print(ext_ostream, print_options);
+          ext_ostream.flush();
+          if (buffer.empty() == false)
+            s->Printf("%s\n", buffer.c_str());
+        }
+      }
+    }
+  }
+}
+
+void SwiftASTContext::DumpTypeDescription(void *type, Stream *s,
+                                          bool print_help_if_available,
+                                          bool print_extensions_if_available) {
+  llvm::SmallVector<char, 1024> buf;
+  llvm::raw_svector_ostream llvm_ostrm(buf);
+
+  if (type) {
+    swift::CanType swift_can_type(GetCanonicalSwiftType(type));
+    switch (swift_can_type->getKind()) {
+    case swift::TypeKind::Module: {
+      swift::ModuleType *module_type =
+          swift_can_type->castTo<swift::ModuleType>();
+      swift::ModuleDecl *module = module_type->getModule();
+      llvm::SmallVector<swift::Decl *, 10> decls;
+      module->getDisplayDecls(decls);
+      for (swift::Decl *decl : decls) {
+        swift::DeclKind kind = decl->getKind();
+        if (kind >= swift::DeclKind::First_TypeDecl &&
+            kind <= swift::DeclKind::Last_TypeDecl) {
+          swift::TypeDecl *type_decl =
+              llvm::dyn_cast_or_null<swift::TypeDecl>(decl);
+          if (type_decl) {
+            CompilerType clang_type(
+                &module->getASTContext(),
+                type_decl->getDeclaredInterfaceType().getPointer());
+            if (clang_type) {
+              Flags clang_type_flags(clang_type.GetTypeInfo());
+              DumpTypeDescription(clang_type.GetOpaqueQualType(), s,
+                                  print_help_if_available,
+                                  print_extensions_if_available);
+            }
+          }
+        } else if (kind == swift::DeclKind::Func ||
+                   kind == swift::DeclKind::Var) {
+          std::string buffer;
+          llvm::raw_string_ostream stream(buffer);
+          decl->print(stream,
+                      SwiftASTContext::GetUserVisibleTypePrintingOptions(
+                          print_help_if_available));
+          stream.flush();
+          s->Printf("%s\n", buffer.c_str());
+        } else if (kind == swift::DeclKind::Import) {
+          swift::ImportDecl *import_decl =
+              llvm::dyn_cast_or_null<swift::ImportDecl>(decl);
+          if (import_decl) {
+            switch (import_decl->getImportKind()) {
+            case swift::ImportKind::Module: {
+              swift::ModuleDecl *imported_module = import_decl->getModule();
+              if (imported_module) {
+                s->Printf("import %s\n", imported_module->getName().get());
+              }
+            } break;
+            default: {
+              for (swift::Decl *imported_decl : import_decl->getDecls()) {
+                // all of the non-module things you can import should be a
+                // ValueDecl
+                if (swift::ValueDecl *imported_value_decl =
+                        llvm::dyn_cast_or_null<swift::ValueDecl>(
+                            imported_decl)) {
+                  if (swift::TypeBase *decl_type =
+                          imported_value_decl->getInterfaceType()
+                              .getPointer()) {
+                    DumpTypeDescription(decl_type, s, print_help_if_available,
+                                        print_extensions_if_available);
+                  }
+                }
+              }
+            } break;
+            }
+          }
+        }
+      }
+      break;
+    }
+    case swift::TypeKind::Metatype: {
+      s->PutCString("metatype ");
+      swift::MetatypeType *metatype_type =
+          swift_can_type->castTo<swift::MetatypeType>();
+      DumpTypeDescription(metatype_type->getInstanceType().getPointer(),
+                          print_help_if_available,
+                          print_extensions_if_available);
+    } break;
+    case swift::TypeKind::UnboundGeneric: {
+      swift::UnboundGenericType *unbound_generic_type =
+          swift_can_type->castTo<swift::UnboundGenericType>();
+      auto nominal_type_decl = llvm::dyn_cast<swift::NominalTypeDecl>(
+          unbound_generic_type->getDecl());
+      if (nominal_type_decl) {
+        PrintSwiftNominalType(nominal_type_decl, s, print_help_if_available,
+                              print_extensions_if_available);
+      }
+    } break;
+    case swift::TypeKind::GenericFunction:
+    case swift::TypeKind::Function: {
+      swift::AnyFunctionType *any_function_type =
+          swift_can_type->castTo<swift::AnyFunctionType>();
+      std::string buffer;
+      llvm::raw_string_ostream ostream(buffer);
+      const swift::PrintOptions &print_options(
+          SwiftASTContext::GetUserVisibleTypePrintingOptions(
+              print_help_if_available));
+
+      any_function_type->print(ostream, print_options);
+      ostream.flush();
+      if (buffer.empty() == false)
+        s->Printf("%s\n", buffer.c_str());
+    } break;
+    case swift::TypeKind::Tuple: {
+      swift::TupleType *tuple_type = swift_can_type->castTo<swift::TupleType>();
+      std::string buffer;
+      llvm::raw_string_ostream ostream(buffer);
+      const swift::PrintOptions &print_options(
+          SwiftASTContext::GetUserVisibleTypePrintingOptions(
+              print_help_if_available));
+
+      tuple_type->print(ostream, print_options);
+      ostream.flush();
+      if (buffer.empty() == false)
+        s->Printf("%s\n", buffer.c_str());
+    } break;
+    case swift::TypeKind::BoundGenericClass:
+    case swift::TypeKind::BoundGenericEnum:
+    case swift::TypeKind::BoundGenericStruct: {
+      swift::BoundGenericType *bound_generic_type =
+          swift_can_type->castTo<swift::BoundGenericType>();
+      swift::NominalTypeDecl *nominal_type_decl = bound_generic_type->getDecl();
+      PrintSwiftNominalType(nominal_type_decl, s, print_help_if_available,
+                            print_extensions_if_available);
+    } break;
+    case swift::TypeKind::BuiltinInteger: {
+      swift::BuiltinIntegerType *builtin_integer_type =
+          swift_can_type->castTo<swift::BuiltinIntegerType>();
+      s->Printf("builtin integer type of width %u bits\n",
+                builtin_integer_type->getWidth().getGreatestWidth());
+      break;
+    }
+    case swift::TypeKind::BuiltinFloat: {
+      swift::BuiltinFloatType *builtin_float_type =
+          swift_can_type->castTo<swift::BuiltinFloatType>();
+      s->Printf("builtin floating-point type of width %u bits\n",
+                builtin_float_type->getBitWidth());
+      break;
+    }
+    case swift::TypeKind::ProtocolComposition: {
+      swift::ProtocolCompositionType *protocol_composition_type =
+          swift_can_type->castTo<swift::ProtocolCompositionType>();
+      std::string buffer;
+      llvm::raw_string_ostream ostream(buffer);
+      const swift::PrintOptions &print_options(
+          SwiftASTContext::GetUserVisibleTypePrintingOptions(
+              print_help_if_available));
+
+      protocol_composition_type->print(ostream, print_options);
+      ostream.flush();
+      if (buffer.empty() == false)
+        s->Printf("%s\n", buffer.c_str());
+      break;
+    }
+    default: {
+      swift::NominalType *nominal_type =
+          llvm::dyn_cast_or_null<swift::NominalType>(
+              swift_can_type.getPointer());
+      if (nominal_type) {
+        swift::NominalTypeDecl *nominal_type_decl = nominal_type->getDecl();
+        PrintSwiftNominalType(nominal_type_decl, s, print_help_if_available,
+                              print_extensions_if_available);
+      }
+    } break;
+    }
+
+    if (buf.size() > 0) {
+      s->Write(buf.data(), buf.size());
+    }
+  }
+}
+
+TypeSP SwiftASTContext::GetCachedType(const ConstString &mangled) {
+  TypeSP type_sp;
+  if (m_swift_type_map.Lookup(mangled.GetCString(), type_sp))
+    return type_sp;
+  else
+    return TypeSP();
+}
+
+void SwiftASTContext::SetCachedType(const ConstString &mangled,
+                                    const TypeSP &type_sp) {
+  m_swift_type_map.Insert(mangled.GetCString(), type_sp);
+}
+
+DWARFASTParser *SwiftASTContext::GetDWARFParser() {
+  if (!m_dwarf_ast_parser_ap)
+    m_dwarf_ast_parser_ap.reset(new DWARFASTParserSwift(*this));
+  return m_dwarf_ast_parser_ap.get();
+}
+
+std::vector<lldb::DataBufferSP> &
+SwiftASTContext::GetASTVectorForModule(const Module *module) {
+  return m_ast_file_data_map[const_cast<Module *>(module)];
+}
+
+SwiftASTContextForExpressions::SwiftASTContextForExpressions(Target &target)
+    : SwiftASTContext(target.GetArchitecture().GetTriple().getTriple().c_str(),
+                      &target),
+      m_persistent_state_up(new SwiftPersistentExpressionState) {}
+
+UserExpression *SwiftASTContextForExpressions::GetUserExpression(
+    llvm::StringRef expr, llvm::StringRef prefix, lldb::LanguageType language,
+    Expression::ResultType desired_type,
+    const EvaluateExpressionOptions &options) {
+  TargetSP target_sp = m_target_wp.lock();
+  if (!target_sp)
+    return nullptr;
+
+  return new SwiftUserExpression(*target_sp.get(), expr, prefix, language,
+                                 desired_type, options);
+}
+
+PersistentExpressionState *
+SwiftASTContextForExpressions::GetPersistentExpressionState() {
+  return m_persistent_state_up.get();
+}
diff --git a/source/Symbol/SwiftMangledNameVisitor.cpp b/source/Symbol/SwiftMangledNameVisitor.cpp
index e69de29bb..10eb99cdc 100644
--- a/source/Symbol/SwiftMangledNameVisitor.cpp
+++ b/source/Symbol/SwiftMangledNameVisitor.cpp
@@ -0,0 +1,48 @@
+//===-- SwiftMangledNameVisitor.cpp -----------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "lldb/Symbol/SwiftMangledNameVisitor.h"
+
+using namespace lldb_private;
+
+void SwiftMangledNameVisitor::accept(swift::Demangle::NodePointer pointer) {
+#define NODE(e)                                                                \
+  case swift::Demangle::Node::Kind::e: {                                       \
+    accept##e(pointer);                                                        \
+    break;                                                                     \
+  }
+  const swift::Demangle::Node::Kind node_kind = pointer->getKind();
+  switch (node_kind) {
+#include "swift/Demangling/DemangleNodes.def"
+  }
+}
+
+#define NODE(e)                                                                \
+  void SwiftMangledNameVisitor::visit##e(                                      \
+      swift::Demangle::NodePointer pointer) {}                                 \
+  void SwiftMangledNameVisitor::accept##e(                                     \
+      swift::Demangle::NodePointer cur_node) {                                 \
+    swift::Demangle::Node::iterator end = cur_node->end();                     \
+    for (swift::Demangle::Node::iterator pos = cur_node->begin(); pos != end;  \
+         ++pos) {                                                              \
+      accept(*pos);                                                            \
+    };                                                                         \
+    visit##e(cur_node);                                                        \
+  }
+#include "swift/Demangling/DemangleNodes.def"
+
+void SwiftMangledNameVisitor::visit(const char *mangled_name) {
+  if (mangled_name && mangled_name[0]) {
+    swift::Demangle::Context demangle_ctx;
+    accept(demangle_ctx.demangleSymbolAsNode(llvm::StringRef(mangled_name)));
+  }
+}
diff --git a/source/Symbol/Symbol.cpp b/source/Symbol/Symbol.cpp
index ab297ef33..4f47a7ace 100644
--- a/source/Symbol/Symbol.cpp
+++ b/source/Symbol/Symbol.cpp
@@ -117,6 +117,8 @@ bool Symbol::ValueIsAddress() const {
 }
 
 ConstString Symbol::GetDisplayName() const {
+  if (!m_mangled)
+    return GetName();
   return m_mangled.GetDisplayDemangledName(GetLanguage());
 }
 
@@ -207,7 +209,8 @@ void Symbol::GetDescription(Stream *s, lldb::DescriptionLevel level,
     s->Printf(", mangled=\"%s\"", m_mangled.GetMangledName().AsCString());
 }
 
-void Symbol::Dump(Stream *s, Target *target, uint32_t index) const {
+void Symbol::Dump(Stream *s, Target *target, uint32_t index,
+                  Mangled::NamePreference name_preference) const {
   s->Printf("[%5u] %6u %c%c%c %-15s ", index, GetID(), m_is_debug ? 'D' : ' ',
             m_is_synthetic ? 'S' : ' ', m_is_external ? 'X' : ' ',
             GetTypeAsString());
@@ -215,7 +218,7 @@ void Symbol::Dump(Stream *s, Target *target, uint32_t index) const {
   // Make sure the size of the symbol is up to date before dumping
   GetByteSize();
 
-  ConstString name = m_mangled.GetName(GetLanguage());
+  ConstString name = m_mangled.GetName(GetLanguage(), name_preference);
   if (ValueIsAddress()) {
     if (!m_addr_range.GetBaseAddress().Dump(s, nullptr,
                                             Address::DumpStyleFileAddress))
@@ -371,6 +374,8 @@ const char *Symbol::GetTypeAsString() const {
     ENUM_TO_CSTRING(ObjCClass);
     ENUM_TO_CSTRING(ObjCMetaClass);
     ENUM_TO_CSTRING(ObjCIVar);
+    ENUM_TO_CSTRING(IVarOffset);
+    ENUM_TO_CSTRING(Metadata)
     ENUM_TO_CSTRING(ReExported);
   default:
     break;
diff --git a/source/Symbol/SymbolFile.cpp b/source/Symbol/SymbolFile.cpp
index eb20b80f4..733047874 100644
--- a/source/Symbol/SymbolFile.cpp
+++ b/source/Symbol/SymbolFile.cpp
@@ -12,6 +12,8 @@
 #include "lldb/Core/Module.h"
 #include "lldb/Core/PluginManager.h"
 #include "lldb/Symbol/ObjectFile.h"
+#include "lldb/Symbol/SymbolContext.h"
+#include "lldb/Symbol/TypeList.h"
 #include "lldb/Symbol/TypeMap.h"
 #include "lldb/Symbol/TypeSystem.h"
 #include "lldb/Symbol/VariableList.h"
@@ -90,6 +92,53 @@ TypeSystem *SymbolFile::GetTypeSystemForLanguage(lldb::LanguageType language) {
   return type_system;
 }
 
+bool SymbolFile::ForceInlineSourceFileCheck() {
+  // Force checking for inline breakpoint locations for any JIT object files.
+  // If we have a symbol file for something that has been JIT'ed, chances
+  // are we used "#line" directives to point to the expression code and this
+  // means we will have DWARF line tables that have source implementation
+  // entries that do not match the compile unit source (usually a memory buffer)
+  // file. Returning true for JIT files means all breakpoints set by file and
+  // line
+  // will be found correctly.
+  return m_obj_file->GetType() == ObjectFile::eTypeJIT;
+}
+
+bool SymbolFile::SetLimitSourceFileRange(const FileSpec &file,
+                                         uint32_t first_line,
+                                         uint32_t last_line) {
+  if (file && first_line <= last_line) {
+    m_limit_source_ranges.push_back(SourceRange(file, first_line, last_line));
+    return true;
+  }
+  return false;
+}
+
+bool SymbolFile::SymbolContextShouldBeExcluded(const SymbolContext &sc,
+                                               uint32_t actual_line) {
+  if (!m_limit_source_ranges.empty()) {
+    bool file_match = false;
+    bool line_match = false;
+    for (const auto &range : m_limit_source_ranges) {
+      const auto &line_entry = sc.line_entry;
+      if (range.file == line_entry.file) {
+        file_match = true;
+        if (range.first_line <= actual_line && actual_line <= range.last_line)
+          line_match = true;
+      }
+    }
+    if (file_match && !line_match)
+      return true;
+  }
+  return false;
+}
+
+std::vector<lldb::DataBufferSP>
+SymbolFile::GetASTData(lldb::LanguageType language) {
+  // SymbolFile subclasses must add this functionality
+  return std::vector<lldb::DataBufferSP>();
+}
+
 uint32_t SymbolFile::ResolveSymbolContext(const FileSpec &file_spec,
                                           uint32_t line, bool check_inlines,
                                           uint32_t resolve_scope,
diff --git a/source/Symbol/SymbolVendor.cpp b/source/Symbol/SymbolVendor.cpp
index f5a08739f..7a5f1ec17 100644
--- a/source/Symbol/SymbolVendor.cpp
+++ b/source/Symbol/SymbolVendor.cpp
@@ -15,9 +15,11 @@
 // Project includes
 #include "lldb/Core/Module.h"
 #include "lldb/Core/PluginManager.h"
+#include "lldb/Core/Section.h"
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/ObjectFile.h"
 #include "lldb/Symbol/SymbolFile.h"
+#include "lldb/Utility/DataBufferHeap.h"
 #include "lldb/Utility/Stream.h"
 
 using namespace lldb;
@@ -457,6 +459,37 @@ void SymbolVendor::ClearSymtab() {
   }
 }
 
+bool SymbolVendor::GetCompileOption(const char *option, std::string &value,
+                                    lldb_private::CompileUnit *cu) {
+  SymbolFile *sym_file = GetSymbolFile();
+
+  if (sym_file)
+    return sym_file->GetCompileOption(option, value, cu);
+
+  value.clear();
+  return false;
+}
+
+int SymbolVendor::GetCompileOptions(const char *option,
+                                    std::vector<std::string> &values,
+                                    lldb_private::CompileUnit *cu) {
+  SymbolFile *sym_file = GetSymbolFile();
+
+  if (sym_file)
+    return sym_file->GetCompileOptions(option, values, cu);
+
+  values.clear();
+  return false;
+}
+
+void SymbolVendor::GetLoadedModules(lldb::LanguageType language,
+                                    FileSpecList &modules) {
+  SymbolFile *sym_file = GetSymbolFile();
+
+  if (sym_file)
+    sym_file->GetLoadedModules(language, modules);
+}
+
 void SymbolVendor::SectionFileAddressesChanged() {
   ModuleSP module_sp(GetModule());
   if (module_sp) {
@@ -482,3 +515,66 @@ lldb_private::ConstString SymbolVendor::GetPluginName() {
 }
 
 uint32_t SymbolVendor::GetPluginVersion() { return 1; }
+
+bool SymbolVendor::SetLimitSourceFileRange(const FileSpec &file,
+                                           uint32_t first_line,
+                                           uint32_t last_line) {
+  SymbolFile *sym_file = GetSymbolFile();
+
+  if (sym_file)
+    return sym_file->SetLimitSourceFileRange(file, first_line, last_line);
+
+  return false;
+}
+
+bool SymbolVendor::SymbolContextShouldBeExcluded(const SymbolContext &sc,
+                                                 uint32_t actual_line) {
+  SymbolFile *sym_file = GetSymbolFile();
+
+  if (sym_file)
+    return sym_file->SymbolContextShouldBeExcluded(sc, actual_line);
+
+  return false;
+}
+
+std::vector<DataBufferSP>
+SymbolVendor::GetASTData(lldb::LanguageType language) {
+  std::vector<DataBufferSP> ast_datas;
+
+  if (language != eLanguageTypeSwift)
+    return ast_datas;
+
+  // Sometimes the AST Section data is found from the module, so look there
+  // first:
+  SectionList *section_list = GetModule()->GetSectionList();
+
+  if (section_list) {
+    SectionSP section_sp(
+        section_list->FindSectionByType(eSectionTypeSwiftModules, true));
+    if (section_sp) {
+      DataExtractor section_data;
+
+      if (section_sp->GetSectionData(section_data)) {
+        ast_datas.push_back(DataBufferSP(
+            new DataBufferHeap((const char *)section_data.GetDataStart(),
+                               section_data.GetByteSize())));
+        return ast_datas;
+      }
+    }
+  }
+
+  // If we couldn't find it in the Module, then look for it in the SymbolFile:
+  SymbolFile *sym_file = GetSymbolFile();
+  if (sym_file)
+    ast_datas = sym_file->GetASTData(language);
+
+  return ast_datas;
+}
+
+bool SymbolVendor::ForceInlineSourceFileCheck() {
+  SymbolFile *sym_file = GetSymbolFile();
+  if (sym_file)
+    return sym_file->ForceInlineSourceFileCheck();
+
+  return false;
+}
diff --git a/source/Symbol/Symtab.cpp b/source/Symbol/Symtab.cpp
index 3e2c96550..cb5e86510 100644
--- a/source/Symbol/Symtab.cpp
+++ b/source/Symbol/Symtab.cpp
@@ -23,6 +23,9 @@
 #include "lldb/Utility/Stream.h"
 #include "lldb/Utility/Timer.h"
 
+
+#include "lldb/Target/SwiftLanguageRuntime.h"
+
 using namespace lldb;
 using namespace lldb_private;
 
@@ -68,7 +71,8 @@ void Symtab::SectionFileAddressesChanged() {
   m_file_addr_to_index_computed = false;
 }
 
-void Symtab::Dump(Stream *s, Target *target, SortOrder sort_order) {
+void Symtab::Dump(Stream *s, Target *target, SortOrder sort_order,
+                  Mangled::NamePreference name_preference) {
   std::lock_guard<std::recursive_mutex> guard(m_mutex);
 
   //    s->Printf("%.*p: ", (int)sizeof(void*) * 2, this);
@@ -95,7 +99,7 @@ void Symtab::Dump(Stream *s, Target *target, SortOrder sort_order) {
       const_iterator end = m_symbols.end();
       for (const_iterator pos = m_symbols.begin(); pos != end; ++pos) {
         s->Indent();
-        pos->Dump(s, target, std::distance(begin, pos));
+        pos->Dump(s, target, std::distance(begin, pos), name_preference);
       }
     } break;
 
@@ -120,7 +124,8 @@ void Symtab::Dump(Stream *s, Target *target, SortOrder sort_order) {
                                            end = name_map.end();
            pos != end; ++pos) {
         s->Indent();
-        pos->second->Dump(s, target, pos->second - &m_symbols[0]);
+        pos->second->Dump(s, target, pos->second - &m_symbols[0],
+                          name_preference);
       }
     } break;
 
@@ -133,15 +138,15 @@ void Symtab::Dump(Stream *s, Target *target, SortOrder sort_order) {
       for (size_t i = 0; i < num_entries; ++i) {
         s->Indent();
         const uint32_t symbol_idx = m_file_addr_to_index.GetEntryRef(i).data;
-        m_symbols[symbol_idx].Dump(s, target, symbol_idx);
+        m_symbols[symbol_idx].Dump(s, target, symbol_idx, name_preference);
       }
       break;
     }
   }
 }
 
-void Symtab::Dump(Stream *s, Target *target,
-                  std::vector<uint32_t> &indexes) const {
+void Symtab::Dump(Stream *s, Target *target, std::vector<uint32_t> &indexes,
+                  Mangled::NamePreference name_preference) const {
   std::lock_guard<std::recursive_mutex> guard(m_mutex);
 
   const size_t num_symbols = GetNumSymbols();
@@ -159,7 +164,7 @@ void Symtab::Dump(Stream *s, Target *target,
       size_t idx = *pos;
       if (idx < num_symbols) {
         s->Indent();
-        m_symbols[idx].Dump(s, target, idx);
+        m_symbols[idx].Dump(s, target, idx, name_preference);
       }
     }
   }
@@ -268,6 +273,10 @@ void Symtab::InitNameIndexes() {
       if (entry.cstring) {
         m_name_to_index.Append(entry);
 
+        // Now try and figure out the basename and figure out if the
+        // basename is a method, function, etc and put that in the
+        // appropriate table.
+        llvm::StringRef name = entry.cstring.GetStringRef();
         if (symbol->ContainsLinkerAnnotations()) {
           // If the symbol has linker annotations, also add the version without
           // the annotations.
@@ -337,6 +346,21 @@ void Symtab::InitNameIndexes() {
                 }
               }
             }
+          } else if (SwiftLanguageRuntime::IsSwiftMangledName(name.str().c_str())) {
+            lldb_private::ConstString basename;
+            bool is_method = false;
+            ConstString mangled_name = mangled.GetMangledName();
+            if (SwiftLanguageRuntime::MethodName::
+                    ExtractFunctionBasenameFromMangled(mangled_name, basename,
+                                                       is_method)) {
+              if (basename && basename != mangled_name) {
+                entry.cstring = basename;
+                if (is_method)
+                  m_method_to_index.Append(entry);
+                else
+                  m_basename_to_index.Append(entry);
+              }
+            }
           }
         }
       }
diff --git a/source/Symbol/TypeSystem.cpp b/source/Symbol/TypeSystem.cpp
index fa5e0bc7d..f19fecdea 100644
--- a/source/Symbol/TypeSystem.cpp
+++ b/source/Symbol/TypeSystem.cpp
@@ -19,6 +19,7 @@
 
 #include <set>
 
+#include "lldb/Utility/Status.h"
 #include "lldb/Core/PluginManager.h"
 #include "lldb/Symbol/CompilerType.h"
 
@@ -35,7 +36,7 @@ lldb::TypeSystemSP TypeSystem::CreateInstance(lldb::LanguageType language,
   while ((create_callback = PluginManager::GetTypeSystemCreateCallbackAtIndex(
               i++)) != nullptr) {
     lldb::TypeSystemSP type_system_sp =
-        create_callback(language, module, nullptr);
+        create_callback(language, module, nullptr, nullptr);
     if (type_system_sp)
       return type_system_sp;
   }
@@ -44,13 +45,14 @@ lldb::TypeSystemSP TypeSystem::CreateInstance(lldb::LanguageType language,
 }
 
 lldb::TypeSystemSP TypeSystem::CreateInstance(lldb::LanguageType language,
-                                              Target *target) {
+                                              Target *target,
+                                              const char *compiler_options) {
   uint32_t i = 0;
   TypeSystemCreateInstance create_callback;
   while ((create_callback = PluginManager::GetTypeSystemCreateCallbackAtIndex(
               i++)) != nullptr) {
     lldb::TypeSystemSP type_system_sp =
-        create_callback(language, nullptr, target);
+        create_callback(language, nullptr, target, compiler_options);
     if (type_system_sp)
       return type_system_sp;
   }
@@ -113,6 +115,24 @@ bool TypeSystem::IsMeaninglessWithoutDynamicResolution(void *type) {
   return false;
 }
 
+Status TypeSystem::IsCompatible() {
+  // Assume a language is compatible. Override this virtual function
+  // in your TypeSystem plug-in if version checking is desired.
+  return Status();
+}
+
+ConstString TypeSystem::GetDisplayTypeName(void *type) {
+  return GetTypeName(type);
+}
+
+ConstString TypeSystem::GetTypeSymbolName(void *type) {
+  return GetTypeName(type);
+}
+
+ConstString TypeSystem::GetMangledTypeName(void *type) {
+  return GetTypeName(type);
+}
+
 ConstString TypeSystem::DeclGetMangledName(void *opaque_decl) {
   return ConstString();
 }
@@ -145,6 +165,8 @@ TypeSystemMap::TypeSystemMap()
 
 TypeSystemMap::~TypeSystemMap() {}
 
+void TypeSystemMap::operator=(const TypeSystemMap &rhs) { m_map = rhs.m_map; }
+
 void TypeSystemMap::Clear() {
   collection map;
   {
@@ -210,9 +232,10 @@ TypeSystem *TypeSystemMap::GetTypeSystemForLanguage(lldb::LanguageType language,
   return type_system_sp.get();
 }
 
-TypeSystem *TypeSystemMap::GetTypeSystemForLanguage(lldb::LanguageType language,
-                                                    Target *target,
-                                                    bool can_create) {
+TypeSystem *
+TypeSystemMap::GetTypeSystemForLanguage(lldb::LanguageType language,
+                                        Target *target, bool can_create,
+                                        const char *compiler_options) {
   std::lock_guard<std::mutex> guard(m_mutex);
   collection::iterator pos = m_map.find(language);
   if (pos != m_map.end())
@@ -234,12 +257,24 @@ TypeSystem *TypeSystemMap::GetTypeSystemForLanguage(lldb::LanguageType language,
   // Cache even if we get a shared pointer that contains null type system back
   lldb::TypeSystemSP type_system_sp;
   if (!m_clear_in_progress)
-    type_system_sp = TypeSystem::CreateInstance(language, target);
+    type_system_sp =
+        TypeSystem::CreateInstance(language, target, compiler_options);
 
   AddToMap(language, type_system_sp);
   return type_system_sp.get();
 }
 
+void TypeSystemMap::RemoveTypeSystemsForLanguage(lldb::LanguageType language) {
+  std::lock_guard<std::mutex> guard(m_mutex);
+  collection::iterator pos = m_map.find(language);
+  // If we are clearing the map, we don't need to remove this individual
+  // item.  It will go away soon enough.
+  if (!m_clear_in_progress) {
+    if (pos != m_map.end())
+      m_map.erase(pos);
+  }
+}
+
 void TypeSystemMap::AddToMap(lldb::LanguageType language,
                              lldb::TypeSystemSP const &type_system_sp) {
   if (!m_clear_in_progress)
diff --git a/source/Symbol/Variable.cpp b/source/Symbol/Variable.cpp
index ff32aa731..5b4c4ebde 100644
--- a/source/Symbol/Variable.cpp
+++ b/source/Symbol/Variable.cpp
@@ -737,7 +737,8 @@ static void PrivateAutoComplete(
               continue;
 
             const char *variable_name = variable->GetName().AsCString();
-            if (strstr(variable_name, token.c_str()) == variable_name) {
+            if (variable_name &&
+                strstr(variable_name, token.c_str()) == variable_name) {
               if (strcmp(variable_name, token.c_str()) == 0) {
                 Type *variable_type = variable->GetType();
                 if (variable_type) {
diff --git a/source/Target/CMakeLists.txt b/source/Target/CMakeLists.txt
index 1d858ae58..0168f05ca 100644
--- a/source/Target/CMakeLists.txt
+++ b/source/Target/CMakeLists.txt
@@ -1,4 +1,5 @@
 include_directories(../Plugins/Process/Utility)
+include_directories(/usr/lib/swift)
 
 add_lldb_library(lldbTarget
   ABI.cpp
@@ -33,6 +34,7 @@ add_lldb_library(lldbTarget
   StackID.cpp
   StopInfo.cpp
   StructuredDataPlugin.cpp
+  SwiftLanguageRuntime.cpp
   SystemRuntime.cpp
   Target.cpp
   TargetList.cpp
@@ -62,6 +64,11 @@ add_lldb_library(lldbTarget
   UnwindAssembly.cpp
 
   LINK_LIBS
+    swiftAST
+    swiftBasic
+    swiftDemangling
+    swiftFrontend
+    swiftRemoteAST
     lldbBreakpoint
     lldbCore
     lldbExpression
@@ -70,7 +77,9 @@ add_lldb_library(lldbTarget
     lldbSymbol
     lldbUtility
     lldbPluginExpressionParserClang
+    lldbPluginExpressionParserSwift
     lldbPluginObjCLanguage
+    lldbPluginSwiftLanguage
     lldbPluginProcessUtility
 
   LINK_COMPONENTS
diff --git a/source/Target/JITLoaderList.cpp b/source/Target/JITLoaderList.cpp
index 1e908bd54..326dd7314 100644
--- a/source/Target/JITLoaderList.cpp
+++ b/source/Target/JITLoaderList.cpp
@@ -7,8 +7,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "lldb/Target/JITLoader.h"
 #include "lldb/Target/JITLoaderList.h"
+#include "lldb/Target/JITLoader.h"
 #include "lldb/lldb-private.h"
 
 using namespace lldb;
diff --git a/source/Target/LanguageRuntime.cpp b/source/Target/LanguageRuntime.cpp
index bd02121f6..1e8aa201e 100644
--- a/source/Target/LanguageRuntime.cpp
+++ b/source/Target/LanguageRuntime.cpp
@@ -12,11 +12,14 @@
 // Other libraries and framework includes
 // Project includes
 #include "lldb/Target/LanguageRuntime.h"
+#include "Plugins/Language/CPlusPlus/CPlusPlusLanguage.h"
 #include "Plugins/Language/ObjC/ObjCLanguage.h"
 #include "lldb/Core/PluginManager.h"
 #include "lldb/Core/SearchFilter.h"
 #include "lldb/Interpreter/CommandInterpreter.h"
+#include "lldb/Target/CPPLanguageRuntime.h"
 #include "lldb/Target/ObjCLanguageRuntime.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 
 using namespace lldb;
@@ -230,7 +233,13 @@ LanguageRuntime::~LanguageRuntime() = default;
 Breakpoint::BreakpointPreconditionSP
 LanguageRuntime::CreateExceptionPrecondition(lldb::LanguageType language,
                                              bool catch_bp, bool throw_bp) {
+  // Currently only Swift has one of these gadgets:
   switch (language) {
+  case eLanguageTypeSwift:
+    if (throw_bp)
+      return Breakpoint::BreakpointPreconditionSP(
+          new SwiftLanguageRuntime::SwiftExceptionPrecondition());
+    break;
   case eLanguageTypeObjC:
     if (throw_bp)
       return Breakpoint::BreakpointPreconditionSP(
@@ -299,3 +308,58 @@ void LanguageRuntime::InitializeCommands(CommandObject *parent) {
 lldb::SearchFilterSP LanguageRuntime::CreateExceptionSearchFilter() {
   return m_process->GetTarget().GetSearchFilterForModule(nullptr);
 }
+
+lldb::LanguageType
+LanguageRuntime::GuessLanguageForSymbolByName(Target &target,
+                                              const char *symbol_name) {
+  // We "guess" the language because we can't determine a symbol's language from
+  // it's name.
+  // For example, a Pascal symbol can be mangled using the C++ Itanium scheme,
+  // and defined
+  // in a compilation unit within the same module as other C++ units.
+  //
+  // In addition, different targets could have different ways of mangling names
+  // from a given
+  // language, likewise compilation units within those targets.  It would help
+  // to be able to
+  // ask the various LanguageRuntime plugin instances for this target to
+  // recognize the name,
+  // but right now the plugin instances depend on the process, not the target.
+  // That is
+  // unfortunate, because to use this for filtering breakpoints by language, we
+  // need to know
+  // the "language for symbol-name" prior to running.  So we'd have to make a
+  // "LanguageRuntimeTarget" and "LanguageRuntimeProcess", and direct the
+  // questions that don't
+  // need a running process to the former, and that do to the latter.
+  //
+  // That's more work than I want to do for this feature.
+  if (CPlusPlusLanguage::IsCPPMangledName(symbol_name))
+    return eLanguageTypeC_plus_plus;
+  else if (ObjCLanguage::IsPossibleObjCMethodName(symbol_name))
+    return eLanguageTypeObjC;
+  else if (SwiftLanguageRuntime::IsSwiftMangledName(symbol_name))
+    return eLanguageTypeSwift;
+  else
+    return eLanguageTypeUnknown;
+}
+
+bool
+LanguageRuntime::IsSymbolAnyRuntimeThunk(ProcessSP process_sp, Symbol &symbol)
+{
+  if (!process_sp)
+    return false;
+
+  enum LanguageType languages_to_try[] = {
+      eLanguageTypeSwift, eLanguageTypeObjC, eLanguageTypeC_plus_plus};
+
+  LanguageRuntime *language_runtime;
+  for (enum LanguageType language : languages_to_try) {
+    language_runtime = process_sp->GetLanguageRuntime(language);
+    if (language_runtime) {
+        if (language_runtime->IsSymbolARuntimeThunk(symbol))
+          return true;
+    }
+  }
+  return false;
+}
diff --git a/source/Target/Process.cpp b/source/Target/Process.cpp
index 6cbe289ef..3ab30797c 100644
--- a/source/Target/Process.cpp
+++ b/source/Target/Process.cpp
@@ -58,6 +58,7 @@
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/StopInfo.h"
 #include "lldb/Target/StructuredDataPlugin.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/SystemRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/TargetList.h"
@@ -746,12 +747,14 @@ Process::Process(lldb::TargetSP target_sp, ListenerSP listener_sp,
       m_private_run_lock(), m_stop_info_override_callback(nullptr),
       m_finalizing(false), m_finalize_called(false),
       m_clear_thread_plans_on_stop(false), m_force_next_event_delivery(false),
-      m_last_broadcast_state(eStateInvalid), m_destroy_in_process(false),
+      m_destroy_in_process(false), m_destroy_complete(false),
+      m_last_broadcast_state(eStateInvalid),
       m_can_interpret_function_calls(false), m_warnings_issued(),
       m_run_thread_plan_lock(), m_can_jit(eCanJITDontKnow) {
   CheckInWithManager();
 
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_OBJECT));
+
   if (log)
     log->Printf("%p Process::Process()", static_cast<void *>(this));
 
@@ -1007,8 +1010,9 @@ StateType Process::WaitForProcessToStop(const Timeout<std::micro> &timeout,
       *event_sp_ptr = event_sp;
 
     bool pop_process_io_handler = (hijack_listener_sp.get() != nullptr);
-    Process::HandleProcessStateChangedEvent(event_sp, stream,
-                                            pop_process_io_handler);
+    bool pop_command_interpreter = false;
+    Process::HandleProcessStateChangedEvent(
+        event_sp, stream, pop_process_io_handler, pop_command_interpreter);
 
     switch (state) {
     case eStateCrashed:
@@ -1037,36 +1041,62 @@ StateType Process::WaitForProcessToStop(const Timeout<std::micro> &timeout,
   return state;
 }
 
+static bool
+BreakpointSiteMatchesREPLBreakpoint(const BreakpointSiteSP &bp_site_sp) {
+  if (bp_site_sp) {
+    size_t owner_idx = 0;
+    BreakpointLocationSP bp_loc_sp = bp_site_sp->GetOwnerAtIndex(owner_idx);
+    while (bp_loc_sp) {
+      Breakpoint &bp = bp_loc_sp->GetBreakpoint();
+      if (bp.IsInternal()) {
+        const char *kind = bp.GetBreakpointKind();
+        if (kind && strcmp(kind, "REPL") == 0)
+          return true;
+      }
+      bp_loc_sp = bp_site_sp->GetOwnerAtIndex(++owner_idx);
+    }
+  }
+  return false;
+}
+
 bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
                                              Stream *stream,
-                                             bool &pop_process_io_handler) {
+                                             bool &pop_process_io_handler,
+                                             bool &pop_command_interpreter) {
   const bool handle_pop = pop_process_io_handler;
 
   pop_process_io_handler = false;
   ProcessSP process_sp =
       Process::ProcessEventData::GetProcessFromEvent(event_sp.get());
+  pop_command_interpreter = false;
 
   if (!process_sp)
     return false;
 
-  StateType event_state =
+  StateType state =
       Process::ProcessEventData::GetStateFromEvent(event_sp.get());
-  if (event_state == eStateInvalid)
+  if (state == eStateInvalid)
     return false;
 
-  switch (event_state) {
+  const bool repl_is_active =
+      process_sp->GetTarget().GetDebugger().REPLIsActive();
+  const bool repl_is_enabled =
+      process_sp->GetTarget().GetDebugger().REPLIsEnabled();
+
+  switch (state) {
   case eStateInvalid:
   case eStateUnloaded:
   case eStateAttaching:
   case eStateLaunching:
   case eStateStepping:
-  case eStateDetached:
-    if (stream)
+  case eStateDetached: {
+    if (!repl_is_active && stream)
       stream->Printf("Process %" PRIu64 " %s\n", process_sp->GetID(),
-                     StateAsCString(event_state));
-    if (event_state == eStateDetached)
+                     StateAsCString(state));
+
+    if (state == eStateDetached)
       pop_process_io_handler = true;
-    break;
+  } break;
 
   case eStateConnected:
   case eStateRunning:
@@ -1074,17 +1104,18 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
     break;
 
   case eStateExited:
-    if (stream)
+    if (!repl_is_active && stream)
       process_sp->GetStatus(*stream);
     pop_process_io_handler = true;
     break;
 
   case eStateStopped:
   case eStateCrashed:
-  case eStateSuspended:
+  case eStateSuspended: {
     // Make sure the program hasn't been auto-restarted:
-    if (Process::ProcessEventData::GetRestartedFromEvent(event_sp.get())) {
-      if (stream) {
+    if (event_sp &&
+        Process::ProcessEventData::GetRestartedFromEvent(event_sp.get())) {
+      if (!repl_is_active && stream) {
         size_t num_reasons =
             Process::ProcessEventData::GetNumRestartedReasons(event_sp.get());
         if (num_reasons > 0) {
@@ -1112,6 +1143,9 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
         }
       }
     } else {
+      bool check_for_repl_breakpoint = false;
+      bool is_repl_breakpoint = false;
+      ThreadSP curr_thread;
       StopInfoSP curr_thread_stop_info_sp;
       // Lock the thread list so it doesn't change on us, this is the scope for
       // the locker:
@@ -1119,7 +1153,7 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
         ThreadList &thread_list = process_sp->GetThreadList();
         std::lock_guard<std::recursive_mutex> guard(thread_list.GetMutex());
 
-        ThreadSP curr_thread(thread_list.GetSelectedThread());
+        curr_thread = thread_list.GetSelectedThread();
         ThreadSP thread;
         StopReason curr_thread_stop_reason = eStopReasonInvalid;
         if (curr_thread) {
@@ -1160,6 +1194,8 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
             case eStopReasonTrace:
             case eStopReasonBreakpoint:
             case eStopReasonWatchpoint:
+              check_for_repl_breakpoint = repl_is_enabled;
+              LLVM_FALLTHROUGH;
             case eStopReasonException:
             case eStopReasonExec:
             case eStopReasonThreadExiting:
@@ -1168,26 +1204,80 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
                 other_thread = thread;
               break;
             case eStopReasonPlanComplete:
+              check_for_repl_breakpoint = repl_is_enabled;
               if (!plan_thread)
                 plan_thread = thread;
               break;
             }
           }
-          if (plan_thread)
+          if (plan_thread) {
             thread_list.SetSelectedThreadByID(plan_thread->GetID());
-          else if (other_thread)
+            curr_thread = plan_thread;
+          } else if (other_thread) {
             thread_list.SetSelectedThreadByID(other_thread->GetID());
-          else {
+            curr_thread = other_thread;
+          } else {
             if (curr_thread && curr_thread->IsValid())
               thread = curr_thread;
-            else
+            else {
               thread = thread_list.GetThreadAtIndex(0);
+              curr_thread = thread;
+            }
 
             if (thread)
               thread_list.SetSelectedThreadByID(thread->GetID());
           }
+        } else {
+          switch (curr_thread_stop_reason) {
+          case eStopReasonBreakpoint:
+          case eStopReasonWatchpoint:
+            check_for_repl_breakpoint = repl_is_enabled;
+            break;
+          case eStopReasonPlanComplete:
+            // We might have hit a breakpoint during our REPL evaluation and be
+            // stopped
+            // at the REPL breakpoint
+            check_for_repl_breakpoint = repl_is_enabled;
+            break;
+          default:
+            break;
+          }
+        }
+      }
+
+      BreakpointSiteSP bp_site_sp;
+      if (check_for_repl_breakpoint) {
+        // Make sure this isn't the internal "REPL" breakpoint
+        if (curr_thread) {
+          StopInfoSP stop_info_sp = curr_thread->GetStopInfo();
+          if (stop_info_sp) {
+            bp_site_sp = process_sp->GetBreakpointSiteList().FindByID(
+                stop_info_sp->GetValue());
+            if (bp_site_sp) {
+              is_repl_breakpoint =
+                  BreakpointSiteMatchesREPLBreakpoint(bp_site_sp);
+            }
+          }
+
+          // Only check the breakpoint site for the current PC if the stop
+          // reason didn't have
+          // a valid breakpoint site
+          if (!bp_site_sp) {
+            // We might have stopped with a eStopReasonPlanComplete, see the PC
+            // is at
+
+            lldb::StackFrameSP frame_sp = curr_thread->GetStackFrameAtIndex(0);
+            if (frame_sp) {
+              bp_site_sp = process_sp->GetBreakpointSiteList().FindByAddress(
+                  frame_sp->GetStackID().GetPC());
+              if (bp_site_sp)
+                is_repl_breakpoint =
+                    BreakpointSiteMatchesREPLBreakpoint(bp_site_sp);
+            }
+          }
         }
       }
+
       // Drop the ThreadList mutex by here, since GetThreadStatus below might
       // have to run code,
       // e.g. for Data formatters, and if we hold the ThreadList mutex, then the
@@ -1207,7 +1297,7 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
                                       start_frame, num_frames,
                                       num_frames_with_source,
                                       stop_format);
-          if (curr_thread_stop_info_sp) {
+          if (false && curr_thread_stop_info_sp) {
             lldb::addr_t crashing_address;
             ValueObjectSP valobj_sp = StopInfo::GetCrashingDereference(
                 curr_thread_stop_info_sp, &crashing_address);
@@ -1222,27 +1312,33 @@ bool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,
                                            format);
               stream->Printf(" accessed 0x%" PRIx64 "\n", crashing_address);
             }
+          } else {
+            uint32_t target_idx = debugger.GetTargetList().GetIndexOfTarget(
+                process_sp->GetTarget().shared_from_this());
+            if (target_idx != UINT32_MAX)
+              stream->Printf("Target %d: (", target_idx);
+            else
+              stream->Printf("Target <unknown index>: (");
+            process_sp->GetTarget().Dump(stream, eDescriptionLevelBrief);
+            stream->Printf(") stopped.\n");
           }
-        } else {
-          uint32_t target_idx = debugger.GetTargetList().GetIndexOfTarget(
-              process_sp->GetTarget().shared_from_this());
-          if (target_idx != UINT32_MAX)
-            stream->Printf("Target %d: (", target_idx);
-          else
-            stream->Printf("Target <unknown index>: (");
-          process_sp->GetTarget().Dump(stream, eDescriptionLevelBrief);
-          stream->Printf(") stopped.\n");
         }
       }
 
       // Pop the process IO handler
       pop_process_io_handler = true;
+
+      // If the REPL is enabled, but not active, and we hit the REPL breakpoint,
+      // we need to pop
+      // off the command interpreter after the process IO Handler
+      if (repl_is_enabled && !repl_is_active && is_repl_breakpoint)
+        pop_command_interpreter = true;
     }
-    break;
+  } break;
   }
 
   if (handle_pop && pop_process_io_handler)
-    process_sp->PopProcessIOHandler();
+    process_sp->PopProcessIOHandler(pop_command_interpreter);
 
   return true;
 }
@@ -1394,6 +1490,12 @@ bool Process::SetExitStatus(int status, const char *cstr) {
 
 bool Process::IsAlive() {
   switch (m_private_state.GetValue()) {
+  case eStateInvalid:
+  case eStateUnloaded:
+  case eStateDetached:
+  case eStateExited:
+    return false;
+
   case eStateConnected:
   case eStateAttaching:
   case eStateLaunching:
@@ -1462,7 +1564,7 @@ void Process::UpdateThreadListIfNeeded() {
         // already held by whoever is
         // shutting us down, causing a deadlock.
         OperatingSystem *os = GetOperatingSystem();
-        if (os && !m_destroy_in_process) {
+        if (os && !m_destroy_in_process && !m_destroy_complete) {
           // Clear any old backing threads where memory threads might have been
           // backed by actual threads from the lldb_private::Process subclass
           size_t num_old_threads = old_thread_list.GetSize(false);
@@ -1757,6 +1859,9 @@ LanguageRuntime *Process::GetLanguageRuntime(lldb::LanguageType language,
 }
 
 CPPLanguageRuntime *Process::GetCPPLanguageRuntime(bool retry_if_null) {
+  if (!IsValid())
+    return NULL;
+
   LanguageRuntime *runtime =
       GetLanguageRuntime(eLanguageTypeC_plus_plus, retry_if_null);
   if (runtime != nullptr &&
@@ -1766,6 +1871,9 @@ CPPLanguageRuntime *Process::GetCPPLanguageRuntime(bool retry_if_null) {
 }
 
 ObjCLanguageRuntime *Process::GetObjCLanguageRuntime(bool retry_if_null) {
+  if (!IsValid())
+    return NULL;
+
   LanguageRuntime *runtime =
       GetLanguageRuntime(eLanguageTypeObjC, retry_if_null);
   if (runtime != nullptr && runtime->GetLanguageType() == eLanguageTypeObjC)
@@ -1773,12 +1881,27 @@ ObjCLanguageRuntime *Process::GetObjCLanguageRuntime(bool retry_if_null) {
   return nullptr;
 }
 
+SwiftLanguageRuntime *Process::GetSwiftLanguageRuntime(bool retry_if_null) {
+  if (!IsValid())
+    return NULL;
+
+  LanguageRuntime *runtime =
+      GetLanguageRuntime(eLanguageTypeSwift, retry_if_null);
+  if (runtime != NULL && runtime->GetLanguageType() == eLanguageTypeSwift)
+    return static_cast<SwiftLanguageRuntime *>(runtime);
+  return NULL;
+}
+
 bool Process::IsPossibleDynamicValue(ValueObject &in_value) {
   if (m_finalizing)
     return false;
 
   if (in_value.IsDynamic())
     return false;
+
+  if (!in_value.GetCompilerType().IsValid())
+    return false;
+
   LanguageType known_type = in_value.GetObjectRuntimeLanguage();
 
   if (known_type != eLanguageTypeUnknown && known_type != eLanguageTypeC) {
@@ -1791,7 +1914,14 @@ bool Process::IsPossibleDynamicValue(ValueObject &in_value) {
     return true;
 
   LanguageRuntime *objc_runtime = GetLanguageRuntime(eLanguageTypeObjC);
-  return objc_runtime ? objc_runtime->CouldHaveDynamicValue(in_value) : false;
+  if (objc_runtime && objc_runtime->CouldHaveDynamicValue(in_value))
+    return true;
+
+  LanguageRuntime *swift_runtime = GetLanguageRuntime(eLanguageTypeSwift);
+  if (swift_runtime && swift_runtime->CouldHaveDynamicValue(in_value))
+    return true;
+
+  return false;
 }
 
 void Process::SetDynamicCheckers(DynamicCheckerFunctions *dynamic_checkers) {
@@ -3446,7 +3576,7 @@ Status Process::Detach(bool keep_stopped) {
     }
   }
   m_destroy_in_process = false;
-
+  m_destroy_complete = true;
   // If we exited when we were waiting for a process to stop, then
   // forward the event here so we don't lose the event
   if (exit_event_sp) {
@@ -3537,6 +3667,7 @@ Status Process::Destroy(bool force_kill) {
   }
 
   m_destroy_in_process = false;
+  m_destroy_complete = true;
 
   return error;
 }
@@ -3954,7 +4085,7 @@ void Process::HandlePrivateEvent(EventSP &event_sp) {
         // correctly.
 
         if (is_hijacked || !GetTarget().GetDebugger().IsHandlingEvents())
-          PopProcessIOHandler();
+          PopProcessIOHandler(false);
       }
     }
 
@@ -4735,10 +4866,16 @@ bool Process::PushProcessIOHandler() {
   return false;
 }
 
-bool Process::PopProcessIOHandler() {
+bool Process::PopProcessIOHandler(bool pop_command_interpreter) {
   IOHandlerSP io_handler_sp(m_process_input_reader);
-  if (io_handler_sp)
-    return GetTarget().GetDebugger().PopIOHandler(io_handler_sp);
+  if (io_handler_sp) {
+    if (pop_command_interpreter)
+      return GetTarget().GetDebugger().PopIOHandlers(
+          io_handler_sp,
+          GetTarget().GetDebugger().GetCommandInterpreter().GetIOHandler());
+    else
+      return GetTarget().GetDebugger().PopIOHandler(io_handler_sp);
+  }
   return false;
 }
 
@@ -4872,7 +5009,20 @@ Process::RunThreadPlan(ExecutionContext &exe_ctx,
                        DiagnosticManager &diagnostic_manager) {
   ExpressionResults return_value = eExpressionSetupError;
 
-  std::lock_guard<std::mutex> run_thread_plan_locker(m_run_thread_plan_lock);
+  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STEP |
+                                                  LIBLLDB_LOG_PROCESS));
+
+  if (!m_run_thread_plan_lock.try_lock()) {
+    if (log)
+      log->Printf("RunThreadPlan could not acquire the RunThreadPlan lock.");
+    diagnostic_manager.PutString(
+        eDiagnosticSeverityError,
+        "RunThreadPlan could not acquire the RunThreadPlan lock.");
+    return eExpressionSetupError;
+  }
+
+  std::lock_guard<std::mutex> run_thread_plan_locker(m_run_thread_plan_lock,
+                                                     std::adopt_lock_t());
 
   if (!thread_plan_sp) {
     diagnostic_manager.PutString(
@@ -4976,8 +5126,6 @@ Process::RunThreadPlan(ExecutionContext &exe_ctx,
   lldb::StateType old_state = eStateInvalid;
   lldb::ThreadPlanSP stopper_base_plan_sp;
 
-  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STEP |
-                                                  LIBLLDB_LOG_PROCESS));
   if (m_private_state_thread.EqualsThread(Host::GetCurrentThread())) {
     // Yikes, we are running on the private state thread!  So we can't wait for
     // public events on this thread, since
@@ -5026,6 +5174,8 @@ Process::RunThreadPlan(ExecutionContext &exe_ctx,
     // developers who can
     // live with not pretty...
     thread->Flush();
+    BroadcastEvent(eBroadcastBitStateChanged,
+                   new ProcessEventData(shared_from_this(), eStateStopped));
     return eExpressionStoppedForDebug;
   }
 
@@ -5981,6 +6131,13 @@ void Process::PrintWarningOptimization(const SymbolContext &sc) {
   }
 }
 
+void Process::PrintWarningCantLoadSwift(const Module &module) {
+  PrintWarning(Process::Warnings::eWarningsCantLoadSwift, (void *)&module,
+               "%s had Swift information that isn't usable on the current "
+               "system; its internals will be unavailable.\n",
+               module.GetFileSpec().GetCString());
+}
+
 bool Process::GetProcessInfo(ProcessInstanceInfo &info) {
   info.Clear();
 
diff --git a/source/Target/StopInfo.cpp b/source/Target/StopInfo.cpp
index 6af5ce1b2..f1b9c1ee1 100644
--- a/source/Target/StopInfo.cpp
+++ b/source/Target/StopInfo.cpp
@@ -1033,10 +1033,12 @@ public:
 class StopInfoThreadPlan : public StopInfo {
 public:
   StopInfoThreadPlan(ThreadPlanSP &plan_sp, ValueObjectSP &return_valobj_sp,
-                     ExpressionVariableSP &expression_variable_sp)
+                     ExpressionVariableSP &expression_variable_sp,
+                     bool return_is_swift_error_value)
       : StopInfo(plan_sp->GetThread(), LLDB_INVALID_UID), m_plan_sp(plan_sp),
         m_return_valobj_sp(return_valobj_sp),
-        m_expression_variable_sp(expression_variable_sp) {}
+        m_expression_variable_sp(expression_variable_sp),
+        m_return_value_is_swift_error_value(return_is_swift_error_value) {}
 
   ~StopInfoThreadPlan() override = default;
 
@@ -1051,7 +1053,10 @@ public:
     return m_description.c_str();
   }
 
-  ValueObjectSP GetReturnValueObject() { return m_return_valobj_sp; }
+  ValueObjectSP GetReturnValueObject(bool &is_swift_error_result) {
+    is_swift_error_result = m_return_value_is_swift_error_value;
+    return m_return_valobj_sp;
+  }
 
   ExpressionVariableSP GetExpressionVariable() {
     return m_expression_variable_sp;
@@ -1069,6 +1074,7 @@ private:
   ThreadPlanSP m_plan_sp;
   ValueObjectSP m_return_valobj_sp;
   ExpressionVariableSP m_expression_variable_sp;
+  bool m_return_value_is_swift_error_value;
 };
 
 class StopInfoExec : public StopInfo {
@@ -1124,11 +1130,14 @@ StopInfoSP StopInfo::CreateStopReasonToTrace(Thread &thread) {
   return StopInfoSP(new StopInfoTrace(thread));
 }
 
-StopInfoSP StopInfo::CreateStopReasonWithPlan(
-    ThreadPlanSP &plan_sp, ValueObjectSP return_valobj_sp,
-    ExpressionVariableSP expression_variable_sp) {
+StopInfoSP
+StopInfo::CreateStopReasonWithPlan(ThreadPlanSP &plan_sp,
+                                   ValueObjectSP return_valobj_sp,
+                                   ExpressionVariableSP expression_variable_sp,
+                                   bool return_is_swift_error_value) {
   return StopInfoSP(new StopInfoThreadPlan(plan_sp, return_valobj_sp,
-                                           expression_variable_sp));
+                                           expression_variable_sp,
+                                           return_is_swift_error_value));
 }
 
 StopInfoSP StopInfo::CreateStopReasonWithException(Thread &thread,
@@ -1140,12 +1149,13 @@ StopInfoSP StopInfo::CreateStopReasonWithExec(Thread &thread) {
   return StopInfoSP(new StopInfoExec(thread));
 }
 
-ValueObjectSP StopInfo::GetReturnValueObject(StopInfoSP &stop_info_sp) {
+ValueObjectSP StopInfo::GetReturnValueObject(StopInfoSP &stop_info_sp,
+                                             bool &is_swift_error_result) {
   if (stop_info_sp &&
       stop_info_sp->GetStopReason() == eStopReasonPlanComplete) {
     StopInfoThreadPlan *plan_stop_info =
         static_cast<StopInfoThreadPlan *>(stop_info_sp.get());
-    return plan_stop_info->GetReturnValueObject();
+    return plan_stop_info->GetReturnValueObject(is_swift_error_result);
   } else
     return ValueObjectSP();
 }
diff --git a/source/Target/SwiftLanguageRuntime.cpp b/source/Target/SwiftLanguageRuntime.cpp
index e69de29bb..2805e6137 100644
--- a/source/Target/SwiftLanguageRuntime.cpp
+++ b/source/Target/SwiftLanguageRuntime.cpp
@@ -0,0 +1,4328 @@
+//===-- SwiftLanguageRuntime.cpp --------------------------------*- C++ -*-===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#include "lldb/Target/SwiftLanguageRuntime.h"
+
+#include <string.h>
+
+#include "llvm/Support/raw_ostream.h"
+
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/DeclCXX.h"
+
+#include "shims/System.h"
+#include "swift/ABI/MetadataValues.h"
+#include "swift/AST/ASTContext.h"
+#include "swift/AST/ASTMangler.h"
+#include "swift/AST/Decl.h"
+#include "swift/AST/Module.h"
+#include "swift/AST/Types.h"
+#include "swift/Demangling/Demangle.h"
+#include "swift/Remote/MemoryReader.h"
+#include "swift/RemoteAST/RemoteAST.h"
+
+#include "lldb/Breakpoint/StoppointCallbackContext.h"
+#include "lldb/Core/Debugger.h"
+#include "lldb/Core/Mangled.h"
+#include "lldb/Core/Module.h"
+#include "lldb/Core/PluginManager.h"
+#include "lldb/Core/UniqueCStringMap.h"
+#include "lldb/Core/Value.h"
+#include "lldb/Core/ValueObjectConstResult.h"
+#include "lldb/DataFormatters/StringPrinter.h"
+#include "lldb/DataFormatters/TypeSynthetic.h"
+#include "lldb/DataFormatters/ValueObjectPrinter.h"
+#include "lldb/Host/HostInfo.h"
+#include "lldb/Host/OptionParser.h"
+#include "lldb/Interpreter/CommandInterpreter.h"
+#include "lldb/Interpreter/CommandObject.h"
+#include "lldb/Interpreter/CommandObjectMultiword.h"
+#include "lldb/Interpreter/CommandReturnObject.h"
+#include "lldb/Interpreter/OptionValueBoolean.h"
+#include "lldb/Symbol/ClangASTContext.h"
+#include "lldb/Symbol/CompileUnit.h"
+#include "lldb/Symbol/SwiftASTContext.h"
+#include "lldb/Symbol/Symbol.h"
+#include "lldb/Symbol/TypeList.h"
+#include "lldb/Symbol/VariableList.h"
+#include "lldb/Target/ExecutionContext.h"
+#include "lldb/Target/ProcessStructReader.h"
+#include "lldb/Target/RegisterContext.h"
+#include "lldb/Target/StackFrame.h"
+#include "lldb/Target/Target.h"
+#include "lldb/Target/ThreadPlanRunToAddress.h"
+#include "lldb/Target/ThreadPlanStepInRange.h"
+#include "lldb/Target/ThreadPlanStepOverRange.h"
+#include "lldb/Utility/Status.h"
+
+#include "lldb/Utility/CleanUp.h"
+#include "lldb/Utility/DataBuffer.h"
+#include "lldb/Utility/LLDBAssert.h"
+#include "lldb/Utility/Log.h"
+#include "lldb/Utility/StringLexer.h"
+
+// FIXME: we should not need this
+#include "Plugins/Language/Swift/SwiftFormatters.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+//----------------------------------------------------------------------
+// Destructor
+//----------------------------------------------------------------------
+SwiftLanguageRuntime::~SwiftLanguageRuntime() {}
+
+SwiftLanguageRuntime::SwiftLanguageRuntime(Process *process)
+    : LanguageRuntime(process), m_negative_cache_mutex(),
+      m_SwiftNativeNSErrorISA(), m_memory_reader_sp(), m_promises_map(),
+      m_resolvers_map(), m_bridged_synthetics_map(), m_box_metadata_type() {
+  SetupSwiftError();
+  SetupExclusivity();
+}
+
+static llvm::Optional<lldb::addr_t>
+FindSymbolForSwiftObject(Target &target, const ConstString &object,
+                         const SymbolType sym_type) {
+  llvm::Optional<lldb::addr_t> retval;
+
+  SymbolContextList sc_list;
+  if (target.GetImages().FindSymbolsWithNameAndType(object, sym_type,
+                                                    sc_list)) {
+    SymbolContext SwiftObject_Class;
+    if (sc_list.GetSize() == 1 &&
+        sc_list.GetContextAtIndex(0, SwiftObject_Class)) {
+      if (SwiftObject_Class.symbol) {
+        lldb::addr_t SwiftObject_class_addr =
+            SwiftObject_Class.symbol->GetAddress().GetLoadAddress(&target);
+        if (SwiftObject_class_addr &&
+            SwiftObject_class_addr != LLDB_INVALID_ADDRESS)
+          retval = SwiftObject_class_addr;
+      }
+    }
+  }
+  return retval;
+}
+
+AppleObjCRuntimeV2 *SwiftLanguageRuntime::GetObjCRuntime() {
+  if (auto objc_runtime = GetProcess()->GetObjCLanguageRuntime()) {
+    if (objc_runtime->GetPluginName() ==
+        AppleObjCRuntimeV2::GetPluginNameStatic())
+      return (AppleObjCRuntimeV2 *)objc_runtime;
+  }
+  return nullptr;
+}
+
+void SwiftLanguageRuntime::SetupSwiftError() {
+  Target &target(m_process->GetTarget());
+
+  if (m_SwiftNativeNSErrorISA.hasValue())
+    return;
+
+  ConstString g_SwiftNativeNSError("_SwiftNativeNSError");
+
+  m_SwiftNativeNSErrorISA = FindSymbolForSwiftObject(
+      target, g_SwiftNativeNSError, eSymbolTypeObjCClass);
+}
+
+void SwiftLanguageRuntime::SetupExclusivity() {
+  Target &target(m_process->GetTarget());
+
+  ConstString g_disableExclusivityChecking("_swift_disableExclusivityChecking");
+
+  m_dynamic_exclusivity_flag_addr = FindSymbolForSwiftObject(
+      target, g_disableExclusivityChecking, eSymbolTypeData);
+
+  Log *log(GetLogIfAnyCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  if (log)
+    log->Printf(
+        "SwiftLanguageRuntime: _swift_disableExclusivityChecking = %llu",
+        m_dynamic_exclusivity_flag_addr ? *m_dynamic_exclusivity_flag_addr : 0);
+}
+
+void SwiftLanguageRuntime::ModulesDidLoad(const ModuleList &module_list) {}
+
+static bool GetObjectDescription_ResultVariable(Process *process, Stream &str,
+                                                ValueObject &object) {
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_DATAFORMATTERS));
+
+  StreamString expr_string;
+  expr_string.Printf("Swift._DebuggerSupport.stringForPrintObject(%s)",
+                     object.GetName().GetCString());
+
+  if (log)
+    log->Printf("[GetObjectDescription_ResultVariable] expression: %s",
+                expr_string.GetData());
+
+  ValueObjectSP result_sp;
+  EvaluateExpressionOptions eval_options;
+  eval_options.SetLanguage(lldb::eLanguageTypeSwift);
+  eval_options.SetResultIsInternal(true);
+  eval_options.SetGenerateDebugInfo(true);
+  auto eval_result = process->GetTarget().EvaluateExpression(
+      expr_string.GetData(),
+      process->GetThreadList().GetSelectedThread()->GetSelectedFrame().get(),
+      result_sp, eval_options);
+
+  if (log) {
+    switch (eval_result) {
+    case eExpressionCompleted:
+      log->Printf("[GetObjectDescription_ResultVariable] eExpressionCompleted");
+      break;
+    case eExpressionSetupError:
+      log->Printf(
+          "[GetObjectDescription_ResultVariable] eExpressionSetupError");
+      break;
+    case eExpressionParseError:
+      log->Printf(
+          "[GetObjectDescription_ResultVariable] eExpressionParseError");
+      break;
+    case eExpressionDiscarded:
+      log->Printf("[GetObjectDescription_ResultVariable] eExpressionDiscarded");
+      break;
+    case eExpressionInterrupted:
+      log->Printf(
+          "[GetObjectDescription_ResultVariable] eExpressionInterrupted");
+      break;
+    case eExpressionHitBreakpoint:
+      log->Printf(
+          "[GetObjectDescription_ResultVariable] eExpressionHitBreakpoint");
+      break;
+    case eExpressionTimedOut:
+      log->Printf("[GetObjectDescription_ResultVariable] eExpressionTimedOut");
+      break;
+    case eExpressionResultUnavailable:
+      log->Printf(
+          "[GetObjectDescription_ResultVariable] eExpressionResultUnavailable");
+      break;
+    case eExpressionStoppedForDebug:
+      log->Printf(
+          "[GetObjectDescription_ResultVariable] eExpressionStoppedForDebug");
+      break;
+    }
+  }
+
+  // sanitize the result of the expression before moving forward
+  if (!result_sp) {
+    if (log)
+      log->Printf("[GetObjectDescription_ResultVariable] expression generated "
+                  "no result");
+    return false;
+  }
+  if (result_sp->GetError().Fail()) {
+    if (log)
+      log->Printf("[GetObjectDescription_ResultVariable] expression generated "
+                  "error: %s",
+                  result_sp->GetError().AsCString());
+    return false;
+  }
+  if (false == result_sp->GetCompilerType().IsValid()) {
+    if (log)
+      log->Printf("[GetObjectDescription_ResultVariable] expression generated "
+                  "invalid type");
+    return false;
+  }
+
+  lldb_private::formatters::StringPrinter::ReadStringAndDumpToStreamOptions
+      dump_options;
+  dump_options.SetEscapeNonPrintables(false).SetQuote('\0').SetPrefixToken(
+      nullptr);
+  if (lldb_private::formatters::swift::String_SummaryProvider(
+          *result_sp.get(), str,
+          TypeSummaryOptions()
+              .SetLanguage(lldb::eLanguageTypeSwift)
+              .SetCapping(eTypeSummaryUncapped),
+          dump_options)) {
+    if (log)
+      log->Printf("[GetObjectDescription_ResultVariable] expression completed "
+                  "successfully");
+    return true;
+  } else {
+    if (log)
+      log->Printf("[GetObjectDescription_ResultVariable] expression generated "
+                  "invalid string data");
+    return false;
+  }
+}
+
+static bool GetObjectDescription_ObjectReference(Process *process, Stream &str,
+                                                 ValueObject &object) {
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_DATAFORMATTERS));
+
+  StreamString expr_string;
+  expr_string.Printf("Swift._DebuggerSupport.stringForPrintObject(Swift."
+                     "unsafeBitCast(0x%" PRIx64 ", to: AnyObject.self))",
+                     object.GetValueAsUnsigned(0));
+
+  if (log)
+    log->Printf("[GetObjectDescription_ObjectReference] expression: %s",
+                expr_string.GetData());
+
+  ValueObjectSP result_sp;
+  EvaluateExpressionOptions eval_options;
+  eval_options.SetLanguage(lldb::eLanguageTypeSwift);
+  eval_options.SetResultIsInternal(true);
+  eval_options.SetGenerateDebugInfo(true);
+  auto eval_result = process->GetTarget().EvaluateExpression(
+      expr_string.GetData(),
+      process->GetThreadList().GetSelectedThread()->GetSelectedFrame().get(),
+      result_sp, eval_options);
+
+  if (log) {
+    switch (eval_result) {
+    case eExpressionCompleted:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionCompleted");
+      break;
+    case eExpressionSetupError:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionSetupError");
+      break;
+    case eExpressionParseError:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionParseError");
+      break;
+    case eExpressionDiscarded:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionDiscarded");
+      break;
+    case eExpressionInterrupted:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionInterrupted");
+      break;
+    case eExpressionHitBreakpoint:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionHitBreakpoint");
+      break;
+    case eExpressionTimedOut:
+      log->Printf("[GetObjectDescription_ObjectReference] eExpressionTimedOut");
+      break;
+    case eExpressionResultUnavailable:
+      log->Printf("[GetObjectDescription_ObjectReference] "
+                  "eExpressionResultUnavailable");
+      break;
+    case eExpressionStoppedForDebug:
+      log->Printf(
+          "[GetObjectDescription_ObjectReference] eExpressionStoppedForDebug");
+      break;
+    }
+  }
+
+  // sanitize the result of the expression before moving forward
+  if (!result_sp) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectReference] expression generated "
+                  "no result");
+    return false;
+  }
+  if (result_sp->GetError().Fail()) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectReference] expression generated "
+                  "error: %s",
+                  result_sp->GetError().AsCString());
+    return false;
+  }
+  if (false == result_sp->GetCompilerType().IsValid()) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectReference] expression generated "
+                  "invalid type");
+    return false;
+  }
+
+  lldb_private::formatters::StringPrinter::ReadStringAndDumpToStreamOptions
+      dump_options;
+  dump_options.SetEscapeNonPrintables(false).SetQuote('\0').SetPrefixToken(
+      nullptr);
+  if (lldb_private::formatters::swift::String_SummaryProvider(
+          *result_sp.get(), str,
+          TypeSummaryOptions()
+              .SetLanguage(lldb::eLanguageTypeSwift)
+              .SetCapping(eTypeSummaryUncapped),
+          dump_options)) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectReference] expression completed "
+                  "successfully");
+    return true;
+  } else {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectReference] expression generated "
+                  "invalid string data");
+    return false;
+  }
+}
+
+static bool GetObjectDescription_ObjectCopy(Process *process, Stream &str,
+                                            ValueObject &object) {
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_DATAFORMATTERS));
+
+  ValueObjectSP static_sp(object.GetStaticValue());
+
+  CompilerType static_type(static_sp->GetCompilerType());
+  if (auto non_reference_type = static_type.GetNonReferenceType())
+    static_type = non_reference_type;
+
+  Status error;
+
+  lldb::addr_t copy_location = process->AllocateMemory(
+      static_type.GetByteStride(), ePermissionsReadable | ePermissionsWritable,
+      error);
+  if (copy_location == LLDB_INVALID_ADDRESS) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectCopy] copy_location invalid");
+    return false;
+  }
+  lldb_utility::CleanUp<lldb::addr_t> cleanup(
+      copy_location, [process](lldb::addr_t value) {
+        (void)process->DeallocateMemory(value);
+      });
+
+  DataExtractor data_extractor;
+  if (0 == static_sp->GetData(data_extractor, error)) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectCopy] data extraction failed");
+    return false;
+  }
+
+  if (0 == process->WriteMemory(copy_location, data_extractor.GetDataStart(),
+                                data_extractor.GetByteSize(), error)) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectCopy] memory copy failed");
+    return false;
+  }
+
+  StreamString expr_string;
+  expr_string.Printf("Swift._DebuggerSupport.stringForPrintObject(Swift."
+                     "UnsafePointer<%s>(bitPattern: 0x%" PRIx64 ")!.pointee)",
+                     static_type.GetTypeName().GetCString(), copy_location);
+
+  if (log)
+    log->Printf("[GetObjectDescription_ObjectCopy] expression: %s",
+                expr_string.GetData());
+
+  ValueObjectSP result_sp;
+  EvaluateExpressionOptions eval_options;
+  eval_options.SetLanguage(lldb::eLanguageTypeSwift);
+  eval_options.SetResultIsInternal(true);
+  eval_options.SetGenerateDebugInfo(true);
+  auto eval_result = process->GetTarget().EvaluateExpression(
+      expr_string.GetData(),
+      process->GetThreadList().GetSelectedThread()->GetSelectedFrame().get(),
+      result_sp, eval_options);
+
+  if (log) {
+    switch (eval_result) {
+    case eExpressionCompleted:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionCompleted");
+      break;
+    case eExpressionSetupError:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionSetupError");
+      break;
+    case eExpressionParseError:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionParseError");
+      break;
+    case eExpressionDiscarded:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionDiscarded");
+      break;
+    case eExpressionInterrupted:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionInterrupted");
+      break;
+    case eExpressionHitBreakpoint:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionHitBreakpoint");
+      break;
+    case eExpressionTimedOut:
+      log->Printf("[GetObjectDescription_ObjectCopy] eExpressionTimedOut");
+      break;
+    case eExpressionResultUnavailable:
+      log->Printf(
+          "[GetObjectDescription_ObjectCopy] eExpressionResultUnavailable");
+      break;
+    case eExpressionStoppedForDebug:
+      log->Printf(
+          "[GetObjectDescription_ObjectCopy] eExpressionStoppedForDebug");
+      break;
+    }
+  }
+
+  // sanitize the result of the expression before moving forward
+  if (!result_sp) {
+    if (log)
+      log->Printf(
+          "[GetObjectDescription_ObjectCopy] expression generated no result");
+
+    str.Printf("expression produced no result");
+    return true;
+  }
+  if (result_sp->GetError().Fail()) {
+    if (log)
+      log->Printf(
+          "[GetObjectDescription_ObjectCopy] expression generated error: %s",
+          result_sp->GetError().AsCString());
+
+    str.Printf("expression produced error: %s",
+               result_sp->GetError().AsCString());
+    return true;
+  }
+  if (false == result_sp->GetCompilerType().IsValid()) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectCopy] expression generated "
+                  "invalid type");
+
+    str.Printf("expression produced invalid result type");
+    return true;
+  }
+
+  lldb_private::formatters::StringPrinter::ReadStringAndDumpToStreamOptions
+      dump_options;
+  dump_options.SetEscapeNonPrintables(false).SetQuote('\0').SetPrefixToken(
+      nullptr);
+  if (lldb_private::formatters::swift::String_SummaryProvider(
+          *result_sp.get(), str,
+          TypeSummaryOptions()
+              .SetLanguage(lldb::eLanguageTypeSwift)
+              .SetCapping(eTypeSummaryUncapped),
+          dump_options)) {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectCopy] expression completed "
+                  "successfully");
+  } else {
+    if (log)
+      log->Printf("[GetObjectDescription_ObjectCopy] expression generated "
+                  "invalid string data");
+
+    str.Printf("expression produced unprintable string");
+  }
+  return true;
+}
+
+static bool IsSwiftResultVariable(const ConstString &name) {
+  if (name) {
+    llvm::StringRef name_sr(name.GetStringRef());
+    if (name_sr.size() > 2 &&
+        (name_sr.startswith("$R") || name_sr.startswith("$E")) &&
+        ::isdigit(name_sr[2]))
+      return true;
+  }
+  return false;
+}
+
+static bool IsSwiftReferenceType(ValueObject &object) {
+  CompilerType object_type(object.GetCompilerType());
+  if (llvm::dyn_cast_or_null<SwiftASTContext>(object_type.GetTypeSystem())) {
+    Flags type_flags(object_type.GetTypeInfo());
+    if (type_flags.AllSet(eTypeIsClass | eTypeHasValue |
+                          eTypeInstanceIsPointer))
+      return true;
+  }
+  return false;
+}
+
+bool SwiftLanguageRuntime::GetObjectDescription(Stream &str,
+                                                ValueObject &object) {
+  if (object.IsUninitializedReference()) {
+    str.Printf("<uninitialized>");
+    return true;
+  }
+
+  if (::IsSwiftResultVariable(object.GetName())) {
+    // if this thing is a Swift expression result variable, it has two
+    // properties:
+    // a) its name is something we can refer to in expressions for free
+    // b) its type may be something we can't actually talk about in expressions
+    // so, just use the result variable's name in the expression and be done
+    // with it
+    StreamString probe_stream;
+    if (GetObjectDescription_ResultVariable(m_process, probe_stream, object)) {
+      str.Printf("%s", probe_stream.GetData());
+      return true;
+    }
+  } else if (::IsSwiftReferenceType(object)) {
+    // if this is a Swift class, it has two properties:
+    // a) we do not need its type name, AnyObject is just as good
+    // b) its value is something we can directly use to refer to it
+    // so, just use the ValueObject's pointer-value and be done with it
+    StreamString probe_stream;
+    if (GetObjectDescription_ObjectReference(m_process, probe_stream, object)) {
+      str.Printf("%s", probe_stream.GetData());
+      return true;
+    }
+  }
+
+  // in general, don't try to use the name of the ValueObject as it might end up
+  // referring to the wrong thing
+  return GetObjectDescription_ObjectCopy(m_process, str, object);
+}
+
+bool SwiftLanguageRuntime::GetObjectDescription(
+    Stream &str, Value &value, ExecutionContextScope *exe_scope) {
+  // This is only interesting to do with a ValueObject for Swift
+  return false;
+}
+
+bool SwiftLanguageRuntime::IsSwiftMangledName(const char *name) {
+  return swift::Demangle::isSwiftSymbol(name);
+}
+
+std::string SwiftLanguageRuntime::DemangleSymbolAsString(const char *symbol,
+                                                         bool simplified) {
+  if (simplified) {
+    swift::Demangle::DemangleOptions options(
+        swift::Demangle::DemangleOptions::SimplifiedUIDemangleOptions());
+    return swift::Demangle::demangleSymbolAsString(symbol, strlen(symbol),
+                                                   options);
+  } else
+    return swift::Demangle::demangleSymbolAsString(symbol, strlen(symbol));
+}
+
+std::string
+SwiftLanguageRuntime::DemangleSymbolAsString(const ConstString &symbol,
+                                             bool simplified) {
+  if (simplified) {
+    swift::Demangle::DemangleOptions options(
+        swift::Demangle::DemangleOptions::SimplifiedUIDemangleOptions());
+    return swift::Demangle::demangleSymbolAsString(symbol.GetStringRef(),
+                                                   options);
+  } else
+    return swift::Demangle::demangleSymbolAsString(symbol.GetStringRef());
+}
+
+bool SwiftLanguageRuntime::IsSwiftClassName(const char *name) {
+  // _TtC in the old mangling
+  if (!name)
+    return false;
+
+  swift::Demangle::Context demangle_ctx;
+  swift::Demangle::NodePointer node_ptr =
+      demangle_ctx.demangleSymbolAsNode(name);
+  if (!node_ptr)
+    return false;
+
+  size_t num_children = node_ptr->getNumChildren();
+
+  if (num_children != 1)
+    return false;
+
+  if (node_ptr->getKind() != swift::Demangle::Node::Kind::Global)
+    return false;
+
+  num_children = node_ptr->getNumChildren();
+  if (num_children != 1)
+    return true;
+
+  swift::Demangle::NodePointer type_mangling_ptr = node_ptr->getFirstChild();
+  if (type_mangling_ptr->getKind() != swift::Demangle::Node::Kind::TypeMangling)
+    return false;
+
+  if (type_mangling_ptr->getNumChildren() != 1)
+    return false;
+
+  swift::Demangle::NodePointer type_ptr = type_mangling_ptr->getFirstChild();
+  if (type_ptr->getKind() != swift::Demangle::Node::Kind::Type)
+    return false;
+
+  if (type_ptr->getNumChildren() != 1)
+    return false;
+
+  swift::Demangle::NodePointer class_ptr = type_ptr->getFirstChild();
+  if (class_ptr->getKind() != swift::Demangle::Node::Kind::Class)
+    return false;
+
+  return true;
+}
+
+bool SwiftLanguageRuntime::IsMetadataSymbol(const char *symbol) {
+  if (!symbol)
+    return false;
+
+  swift::Demangle::Context demangle_ctx;
+  swift::Demangle::NodePointer node_ptr =
+      demangle_ctx.demangleSymbolAsNode(symbol);
+  if (!node_ptr)
+    return false;
+
+  size_t num_children = node_ptr->getNumChildren();
+
+  if (num_children != 1)
+    return false;
+
+  if (node_ptr->getKind() != swift::Demangle::Node::Kind::Global)
+    return false;
+
+  num_children = node_ptr->getNumChildren();
+  if (num_children != 1)
+    return false;
+  swift::Demangle::NodePointer type_meta_ptr = node_ptr->getFirstChild();
+  if (type_meta_ptr->getKind() != swift::Demangle::Node::Kind::TypeMetadata)
+    return false;
+  else
+    return true;
+
+  return true;
+}
+
+bool SwiftLanguageRuntime::IsIvarOffsetSymbol(const char *symbol) {
+  if (!symbol)
+    return false;
+  swift::Demangle::Context demangle_ctx;
+  swift::Demangle::NodePointer node_pointer =
+      demangle_ctx.demangleSymbolAsNode(symbol);
+  if (!node_pointer)
+    return false;
+
+  size_t num_children = node_pointer->getNumChildren();
+  if (num_children < 2)
+    return false;
+  if (node_pointer->getChild(0)->getKind() !=
+      swift::Demangle::Node::Kind::Global)
+    return false;
+  swift::Demangle::NodePointer field_offset = node_pointer->getChild(1);
+  if (field_offset->getKind() != swift::Demangle::Node::Kind::FieldOffset)
+    return false;
+  if (node_pointer->getNumChildren() < 1)
+    return false;
+  if (node_pointer->getChild(0)->getKind() !=
+      swift::Demangle::Node::Kind::Directness)
+    return false;
+
+  return true;
+}
+
+const std::string
+SwiftLanguageRuntime::GetCurrentMangledName(const char *mangled_name) {
+#ifndef USE_NEW_MANGLING
+  return std::string(mangled_name);
+#else
+  // FIXME: Check if we need to cache these lookups...
+  swift::Demangle::Context demangle_ctx;
+  swift::Demangle::NodePointer node_ptr =
+      demangle_ctx.demangleSymbolAsNode(mangled_name);
+  if (!node_ptr) {
+    // Sometimes this gets passed the prefix of a name, in which case we
+    // won't be able to demangle it.  In that case return what was passed in.
+    printf("Couldn't get mangled name for %s.\n", mangled_name);
+    return mangled_name;
+  } else
+    return swift::Demangle::mangleNode(node_ptr);
+#endif
+}
+
+uint32_t SwiftLanguageRuntime::FindEquivalentNames(
+    ConstString type_name, std::vector<ConstString> &equivalents) {
+  return 0;
+}
+
+void SwiftLanguageRuntime::MethodName::Clear() {
+  m_full.Clear();
+  m_basename = llvm::StringRef();
+  m_context = llvm::StringRef();
+  m_arguments = llvm::StringRef();
+  m_qualifiers = llvm::StringRef();
+  m_template_args = llvm::StringRef();
+  m_metatype_ref = llvm::StringRef();
+  m_return_type = llvm::StringRef();
+  m_type = eTypeInvalid;
+  m_parsed = false;
+  m_parse_error = false;
+}
+
+static bool StringHasAllOf(const llvm::StringRef &s, const char *which) {
+  for (const char *c = which; *c != 0; c++) {
+    if (s.find(*c) == llvm::StringRef::npos)
+      return false;
+  }
+  return true;
+}
+
+static bool StringHasAnyOf(const llvm::StringRef &s,
+                           std::initializer_list<const char *> which,
+                           size_t &where) {
+  for (const char *item : which) {
+    size_t where_item = s.find(item);
+    if (where_item != llvm::StringRef::npos) {
+      where = where_item;
+      return true;
+    }
+  }
+  where = llvm::StringRef::npos;
+  return false;
+}
+
+bool StringHasAnyOf(const llvm::StringRef &s, const char *which,
+                    size_t &where) {
+  for (const char *c = which; *c != 0; c++) {
+    size_t where_item = s.find(*c);
+    if (where_item != llvm::StringRef::npos) {
+      where = where_item;
+      return true;
+    }
+  }
+  where = llvm::StringRef::npos;
+  return false;
+}
+
+static bool UnpackTerminatedSubstring(const llvm::StringRef &s,
+                                      const char start, const char stop,
+                                      llvm::StringRef &dest) {
+  size_t pos_of_start = s.find(start);
+  if (pos_of_start == llvm::StringRef::npos)
+    return false;
+  size_t pos_of_stop = s.rfind(stop);
+  if (pos_of_stop == llvm::StringRef::npos)
+    return false;
+  size_t token_count = 1;
+  size_t idx = pos_of_start + 1;
+  while (idx < s.size()) {
+    if (s[idx] == start)
+      ++token_count;
+    if (s[idx] == stop) {
+      if (token_count == 1) {
+        dest = s.slice(pos_of_start, idx + 1);
+        return true;
+      }
+    }
+    idx++;
+  }
+  return false;
+}
+
+static bool UnpackQualifiedName(const llvm::StringRef &s, llvm::StringRef &decl,
+                                llvm::StringRef &basename, bool &was_operator) {
+  size_t pos_of_dot = s.rfind('.');
+  if (pos_of_dot == llvm::StringRef::npos)
+    return false;
+  decl = s.substr(0, pos_of_dot);
+  basename = s.substr(pos_of_dot + 1);
+  size_t idx_of_operator;
+  was_operator = StringHasAnyOf(basename, {"@infix", "@prefix", "@postfix"},
+                                idx_of_operator);
+  if (was_operator)
+    basename = basename.substr(0, idx_of_operator - 1);
+  return !decl.empty() && !basename.empty();
+}
+
+static bool ParseLocalDeclName(const swift::Demangle::NodePointer &node,
+                               StreamString &identifier,
+                               swift::Demangle::Node::Kind &parent_kind,
+                               swift::Demangle::Node::Kind &kind) {
+  swift::Demangle::Node::iterator end = node->end();
+  for (swift::Demangle::Node::iterator pos = node->begin(); pos != end; ++pos) {
+    swift::Demangle::NodePointer child = *pos;
+
+    swift::Demangle::Node::Kind child_kind = child->getKind();
+    switch (child_kind) {
+    case swift::Demangle::Node::Kind::Number:
+      break;
+
+    default:
+      if (child->hasText()) {
+        identifier.PutCString(child->getText());
+        return true;
+      }
+      break;
+    }
+  }
+  return false;
+}
+
+static bool ParseFunction(const swift::Demangle::NodePointer &node,
+                          StreamString &identifier,
+                          swift::Demangle::Node::Kind &parent_kind,
+                          swift::Demangle::Node::Kind &kind) {
+  swift::Demangle::Node::iterator end = node->end();
+  swift::Demangle::Node::iterator pos = node->begin();
+  // First child is the function's scope
+  parent_kind = (*pos)->getKind();
+  ++pos;
+  // Second child is either the type (no identifier)
+  if (pos != end) {
+    switch ((*pos)->getKind()) {
+    case swift::Demangle::Node::Kind::Type:
+      break;
+
+    case swift::Demangle::Node::Kind::LocalDeclName:
+      if (ParseLocalDeclName(*pos, identifier, parent_kind, kind))
+        return true;
+      else
+        return false;
+      break;
+
+    default:
+    case swift::Demangle::Node::Kind::InfixOperator:
+    case swift::Demangle::Node::Kind::PostfixOperator:
+    case swift::Demangle::Node::Kind::PrefixOperator:
+    case swift::Demangle::Node::Kind::Identifier:
+      if ((*pos)->hasText())
+        identifier.PutCString((*pos)->getText());
+      return true;
+    }
+  }
+  return false;
+}
+
+static bool ParseGlobal(const swift::Demangle::NodePointer &node,
+                        StreamString &identifier,
+                        swift::Demangle::Node::Kind &parent_kind,
+                        swift::Demangle::Node::Kind &kind) {
+  swift::Demangle::Node::iterator end = node->end();
+  for (swift::Demangle::Node::iterator pos = node->begin(); pos != end; ++pos) {
+    swift::Demangle::NodePointer child = *pos;
+    if (child) {
+      kind = child->getKind();
+      switch (child->getKind()) {
+      case swift::Demangle::Node::Kind::Allocator:
+        identifier.PutCString("__allocating_init");
+        ParseFunction(child, identifier, parent_kind, kind);
+        return true;
+
+      case swift::Demangle::Node::Kind::Constructor:
+        identifier.PutCString("init");
+        ParseFunction(child, identifier, parent_kind, kind);
+        return true;
+
+      case swift::Demangle::Node::Kind::Deallocator:
+        identifier.PutCString("__deallocating_deinit");
+        ParseFunction(child, identifier, parent_kind, kind);
+        return true;
+
+      case swift::Demangle::Node::Kind::Destructor:
+        identifier.PutCString("deinit");
+        ParseFunction(child, identifier, parent_kind, kind);
+        return true;
+
+      case swift::Demangle::Node::Kind::Getter:
+      case swift::Demangle::Node::Kind::Setter:
+      case swift::Demangle::Node::Kind::Function:
+        return ParseFunction(child, identifier, parent_kind, kind);
+
+      // Ignore these, they decorate a function at the same level, but don't
+      // contain any text
+      case swift::Demangle::Node::Kind::ObjCAttribute:
+        break;
+
+      default:
+        return false;
+      }
+    }
+  }
+  return false;
+}
+
+bool SwiftLanguageRuntime::MethodName::ExtractFunctionBasenameFromMangled(
+    const ConstString &mangled, ConstString &basename, bool &is_method) {
+  bool success = false;
+  swift::Demangle::Node::Kind kind = swift::Demangle::Node::Kind::Global;
+  swift::Demangle::Node::Kind parent_kind = swift::Demangle::Node::Kind::Global;
+  if (mangled) {
+    const char *mangled_cstr = mangled.GetCString();
+    const size_t mangled_cstr_len = mangled.GetLength();
+
+    if (mangled_cstr_len > 3) {
+      llvm::StringRef mangled_ref(mangled_cstr, mangled_cstr_len);
+
+      // Only demangle swift functions
+      // This is a no-op right now for the new mangling, because you
+      // have to demangle the whole name to figure this out anyway.
+      // I'm leaving the test here in case we actually need to do this
+      // only to functions.
+      swift::Demangle::Context demangle_ctx;
+      swift::Demangle::NodePointer node =
+          demangle_ctx.demangleSymbolAsNode(mangled_ref);
+      StreamString identifier;
+      if (node) {
+        switch (node->getKind()) {
+        case swift::Demangle::Node::Kind::Global:
+          success = ParseGlobal(node, identifier, parent_kind, kind);
+          break;
+
+        default:
+          break;
+        }
+
+        if (!identifier.GetString().empty()) {
+          basename = ConstString(identifier.GetString());
+        }
+      }
+    }
+  }
+  if (success) {
+    switch (kind) {
+    case swift::Demangle::Node::Kind::Allocator:
+    case swift::Demangle::Node::Kind::Constructor:
+    case swift::Demangle::Node::Kind::Deallocator:
+    case swift::Demangle::Node::Kind::Destructor:
+      is_method = true;
+      break;
+
+    case swift::Demangle::Node::Kind::Getter:
+    case swift::Demangle::Node::Kind::Setter:
+      // don't handle getters and setters right now...
+      return false;
+
+    case swift::Demangle::Node::Kind::Function:
+      switch (parent_kind) {
+      case swift::Demangle::Node::Kind::BoundGenericClass:
+      case swift::Demangle::Node::Kind::BoundGenericEnum:
+      case swift::Demangle::Node::Kind::BoundGenericStructure:
+      case swift::Demangle::Node::Kind::Class:
+      case swift::Demangle::Node::Kind::Enum:
+      case swift::Demangle::Node::Kind::Structure:
+        is_method = true;
+        break;
+
+      default:
+        break;
+      }
+      break;
+
+    default:
+      break;
+    }
+  }
+  return success;
+}
+
+void SwiftLanguageRuntime::MethodName::Parse() {
+  if (!m_parsed && m_full) {
+    //        ConstString mangled;
+    //        m_full.GetMangledCounterpart(mangled);
+    //        printf ("\n   parsing = '%s'\n", m_full.GetCString());
+    //        if (mangled)
+    //            printf ("   mangled = '%s'\n", mangled.GetCString());
+    m_parse_error = false;
+    m_parsed = true;
+    llvm::StringRef full(m_full.GetCString());
+    bool was_operator = false;
+
+    if (full.find("::") != llvm::StringRef::npos) {
+      // :: is not an allowed operator in Swift (func ::(...) { fails to
+      // compile)
+      // but it's a very legitimate token in C++ - as a defense, reject anything
+      // with a :: in it as invalid Swift
+      m_parse_error = true;
+      return;
+    }
+
+    if (StringHasAllOf(full, ".:()")) {
+      const size_t open_paren = full.find(" (");
+      llvm::StringRef funcname = full.substr(0, open_paren);
+      UnpackQualifiedName(funcname, m_context, m_basename, was_operator);
+      if (was_operator)
+        m_type = eTypeOperator;
+      // check for obvious constructor/destructor cases
+      else if (m_basename.equals("__deallocating_destructor"))
+        m_type = eTypeDeallocator;
+      else if (m_basename.equals("__allocating_constructor"))
+        m_type = eTypeAllocator;
+      else if (m_basename.equals("init"))
+        m_type = eTypeConstructor;
+      else if (m_basename.equals("destructor"))
+        m_type = eTypeDestructor;
+      else
+        m_type = eTypeUnknownMethod;
+
+      const size_t idx_of_colon =
+          full.find(':', open_paren == llvm::StringRef::npos ? 0 : open_paren);
+      full = full.substr(idx_of_colon + 2);
+      if (full.empty())
+        return;
+      if (full[0] == '<') {
+        if (UnpackTerminatedSubstring(full, '<', '>', m_template_args)) {
+          full = full.substr(m_template_args.size());
+        } else {
+          m_parse_error = true;
+          return;
+        }
+      }
+      if (full.empty())
+        return;
+      if (full[0] == '(') {
+        if (UnpackTerminatedSubstring(full, '(', ')', m_metatype_ref)) {
+          full = full.substr(m_template_args.size());
+          if (full[0] == '<') {
+            if (UnpackTerminatedSubstring(full, '<', '>', m_template_args)) {
+              full = full.substr(m_template_args.size());
+            } else {
+              m_parse_error = true;
+              return;
+            }
+          }
+        } else {
+          m_parse_error = true;
+          return;
+        }
+      }
+      if (full.empty())
+        return;
+      if (full[0] == '(') {
+        if (UnpackTerminatedSubstring(full, '(', ')', m_arguments)) {
+          full = full.substr(m_template_args.size());
+        } else {
+          m_parse_error = true;
+          return;
+        }
+      }
+      if (full.empty())
+        return;
+      size_t idx_of_ret = full.find("->");
+      if (idx_of_ret == llvm::StringRef::npos) {
+        full = full.substr(idx_of_ret);
+        if (full.empty()) {
+          m_parse_error = true;
+          return;
+        }
+        if (full[0] == ' ')
+          full = full.substr(1);
+        m_return_type = full;
+      }
+    } else if (full.find('.') != llvm::StringRef::npos) {
+      // this is probably just a full name (module.type.func)
+      UnpackQualifiedName(full, m_context, m_basename, was_operator);
+      if (was_operator)
+        m_type = eTypeOperator;
+      else
+        m_type = eTypeUnknownMethod;
+    } else {
+      // this is most probably just a basename
+      m_basename = full;
+      m_type = eTypeUnknownMethod;
+    }
+  }
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetBasename() {
+  if (!m_parsed)
+    Parse();
+  return m_basename;
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetContext() {
+  if (!m_parsed)
+    Parse();
+  return m_context;
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetArguments() {
+  if (!m_parsed)
+    Parse();
+  return m_arguments;
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetQualifiers() {
+  if (!m_parsed)
+    Parse();
+  return m_qualifiers;
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetMetatypeReference() {
+  if (!m_parsed)
+    Parse();
+  return m_qualifiers;
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetTemplateArguments() {
+  if (!m_parsed)
+    Parse();
+  return m_template_args;
+}
+
+llvm::StringRef SwiftLanguageRuntime::MethodName::GetReturnType() {
+  if (!m_parsed)
+    Parse();
+  return m_return_type;
+}
+
+const CompilerType &SwiftLanguageRuntime::GetBoxMetadataType() {
+  if (m_box_metadata_type.IsValid())
+    return m_box_metadata_type;
+
+  static ConstString g_type_name("__lldb_autogen_boxmetadata");
+  const bool is_packed = false;
+  if (ClangASTContext *ast_ctx =
+          GetProcess()->GetTarget().GetScratchClangASTContext()) {
+    CompilerType voidstar =
+        ast_ctx->GetBasicType(lldb::eBasicTypeVoid).GetPointerType();
+    CompilerType uint32 = ClangASTContext::GetIntTypeFromBitSize(
+        ast_ctx->getASTContext(), 32, false);
+
+    m_box_metadata_type = ast_ctx->GetOrCreateStructForIdentifier(
+        g_type_name, {{"kind", voidstar}, {"offset", uint32}}, is_packed);
+  }
+
+  return m_box_metadata_type;
+}
+
+std::shared_ptr<swift::remote::MemoryReader>
+SwiftLanguageRuntime::GetMemoryReader() {
+  class MemoryReader : public swift::remote::MemoryReader {
+  public:
+    MemoryReader(Process *p, size_t max_read_amount = 50 * 1024)
+        : m_process(p) {
+      lldbassert(m_process && "MemoryReader requires a valid Process");
+      m_max_read_amount = max_read_amount;
+    }
+
+    virtual ~MemoryReader() = default;
+
+    uint8_t getPointerSize() override {
+      return m_process->GetAddressByteSize();
+    }
+
+    uint8_t getSizeSize() override {
+      return getPointerSize(); // FIXME: sizeof(size_t)
+    }
+
+    swift::remote::RemoteAddress
+    getSymbolAddress(const std::string &name) override {
+      Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+      if (name.empty())
+        return swift::remote::RemoteAddress(nullptr);
+
+      if (log)
+        log->Printf("[MemoryReader] asked to retrieve address of symbol %s",
+                    name.c_str());
+
+      ConstString name_cs(name.c_str(), name.size());
+      SymbolContextList sc_list;
+      if (m_process->GetTarget().GetImages().FindSymbolsWithNameAndType(
+              name_cs, lldb::eSymbolTypeAny, sc_list)) {
+        SymbolContext sym_ctx;
+        if (sc_list.GetSize() == 1 && sc_list.GetContextAtIndex(0, sym_ctx)) {
+          if (sym_ctx.symbol) {
+            auto load_addr =
+                sym_ctx.symbol->GetLoadAddress(&m_process->GetTarget());
+            if (log)
+              log->Printf("[MemoryReader] symbol resolved to 0x%" PRIx64,
+                          load_addr);
+            return swift::remote::RemoteAddress(load_addr);
+          }
+        }
+      }
+
+      if (log)
+        log->Printf("[MemoryReader] symbol resolution failed");
+      return swift::remote::RemoteAddress(nullptr);
+    }
+
+    bool readBytes(swift::remote::RemoteAddress address, uint8_t *dest,
+                   uint64_t size) override {
+      Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+      if (log)
+        log->Printf("[MemoryReader] asked to read %" PRIu64
+                    " bytes at address 0x%" PRIx64,
+                    size, address.getAddressData());
+
+      if (size > m_max_read_amount) {
+        if (log)
+          log->Printf(
+              "[MemoryReader] memory read exceeds maximum allowed size");
+        return false;
+      }
+
+      Target &target(m_process->GetTarget());
+      Address addr(address.getAddressData());
+      Status error;
+      if (size > target.ReadMemory(addr, false, dest, size, error)) {
+        if (log)
+          log->Printf(
+              "[MemoryReader] memory read returned fewer bytes than asked for");
+        return false;
+      }
+      if (error.Fail()) {
+        if (log)
+          log->Printf("[MemoryReader] memory read returned error: %s",
+                      error.AsCString());
+        return false;
+      }
+
+      if (log) {
+        StreamString stream;
+        for (uint64_t i = 0; i < size; i++) {
+          stream.PutHex8(dest[i]);
+          stream.PutChar(' ');
+        }
+        log->Printf("[MemoryReader] memory read returned data: %s",
+                    stream.GetData());
+      }
+
+      return true;
+    }
+
+    bool readString(swift::remote::RemoteAddress address,
+                    std::string &dest) override {
+      Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+      if (log)
+        log->Printf(
+            "[MemoryReader] asked to read string data at address 0x%" PRIx64,
+            address.getAddressData());
+
+      std::vector<char> storage(m_max_read_amount, 0);
+      Target &target(m_process->GetTarget());
+      Address addr(address.getAddressData());
+      Status error;
+      target.ReadCStringFromMemory(addr, &storage[0], storage.size(), error);
+      if (error.Success()) {
+        dest.assign(&storage[0]);
+        if (log)
+          log->Printf("[MemoryReader] memory read returned data: %s",
+                      dest.c_str());
+        return true;
+      } else {
+        if (log)
+          log->Printf("[MemoryReader] memory read returned error: %s",
+                      error.AsCString());
+        return false;
+      }
+    }
+
+  private:
+    Process *m_process;
+    size_t m_max_read_amount;
+  };
+
+  if (!m_memory_reader_sp)
+    m_memory_reader_sp.reset(new MemoryReader(GetProcess()));
+
+  return m_memory_reader_sp;
+}
+
+SwiftASTContext *SwiftLanguageRuntime::GetScratchSwiftASTContext() {
+  Status error;
+  return m_process->GetTarget().GetScratchSwiftASTContext(error);
+}
+
+SwiftLanguageRuntime::MemberVariableOffsetResolver::
+    MemberVariableOffsetResolver(swift::ASTContext *ast_ctx,
+                                 SwiftLanguageRuntime *runtime,
+                                 swift::TypeBase *type)
+    : m_swift_ast(ast_ctx), m_swift_runtime(runtime), m_offsets() {
+  lldbassert(m_swift_ast &&
+             "MemberVariableOffsetResolver requires a swift::ASTContext");
+  lldbassert(m_swift_runtime &&
+             "MemberVariableOffsetResolver requires a SwiftLanguageRuntime");
+  lldbassert(type && "MemberVariableOffsetResolver requires a swift::Type");
+  m_swift_type = type;
+  m_remote_ast.reset(new swift::remoteAST::RemoteASTContext(
+      *ast_ctx, m_swift_runtime->GetMemoryReader()));
+}
+
+llvm::Optional<uint64_t>
+SwiftLanguageRuntime::MemberVariableOffsetResolver::ResolveOffset(
+    ValueObject *valobj, ConstString ivar_name, Status *error) {
+  if (error)
+    error->Clear();
+
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  if (log)
+    log->Printf(
+        "[MemberVariableOffsetResolver] asked to resolve offset for ivar %s",
+        ivar_name.AsCString());
+
+  auto iter = m_offsets.find(ivar_name.AsCString()), end = m_offsets.end();
+  if (iter != end)
+    return iter->second;
+
+  auto optmeta = swift::remote::RemoteAddress(nullptr);
+
+  const swift::TypeKind type_kind = m_swift_type->getKind();
+  switch (type_kind) {
+  case swift::TypeKind::Class:
+  case swift::TypeKind::BoundGenericClass: {
+    if (log)
+      log->Printf("[MemberVariableOffsetResolver] type is a class - trying to "
+                  "get metadata for valueobject %s",
+                  (valobj ? valobj->GetName().AsCString() : "<null>"));
+    // retrieve the metadata for class types as this is where we get the maximum
+    // benefit
+    if (valobj) {
+      lldb::addr_t value = valobj->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+      if (value == 0 || value == LLDB_INVALID_ADDRESS)
+        break;
+      Status error;
+      lldb::addr_t meta_ptr =
+          m_swift_runtime->GetProcess()->ReadPointerFromMemory(value, error);
+      if (error.Fail() || meta_ptr == 0 || meta_ptr == LLDB_INVALID_ADDRESS)
+        break;
+      if (auto objc_runtime = m_swift_runtime->GetObjCRuntime()) {
+        if (objc_runtime->GetRuntimeVersion() ==
+            ObjCLanguageRuntime::ObjCRuntimeVersions::eAppleObjC_V2) {
+          meta_ptr =
+              ((AppleObjCRuntimeV2 *)objc_runtime)->GetPointerISA(meta_ptr);
+        }
+      }
+      optmeta = swift::remote::RemoteAddress(meta_ptr);
+    }
+    if (log)
+      log->Printf("[MemberVariableOffsetResolver] optmeta = 0x%" PRIx64,
+                  optmeta.getAddressData());
+  } break;
+  default: {
+    if (log)
+      log->Printf("[MemberVariableOffsetResolver] type is not a class - no "
+                  "metadata needed");
+  } break;
+  }
+
+  swift::remoteAST::Result<uint64_t> result = m_remote_ast->getOffsetOfMember(
+      m_swift_type, optmeta, ivar_name.GetStringRef());
+  if (result) {
+    if (log)
+      log->Printf("[MemberVariableOffsetResolver] offset discovered = %" PRIu64,
+                  (uint64_t)result.getValue());
+    m_offsets.emplace(ivar_name.AsCString(), result.getValue());
+    return result.getValue();
+  } else {
+    const auto &failure = result.getFailure();
+    if (error)
+      error->SetErrorStringWithFormat("error in resolving type offset: %s",
+                                      failure.render().c_str());
+    if (log)
+      log->Printf("[MemberVariableOffsetResolver] failure: %s",
+                  failure.render().c_str());
+    return llvm::Optional<uint64_t>();
+  }
+}
+
+SwiftLanguageRuntime::MetadataPromise::MetadataPromise(
+    swift::ASTContext *ast_ctx, SwiftLanguageRuntime *runtime,
+    lldb::addr_t location)
+    : m_swift_ast(ast_ctx), m_swift_runtime(runtime),
+      m_metadata_location(location) {
+  lldbassert(m_swift_ast && "MetadataPromise requires a swift::ASTContext");
+  lldbassert(m_swift_runtime &&
+             "MetadataPromise requires a SwiftLanguageRuntime");
+  m_remote_ast.reset(new swift::remoteAST::RemoteASTContext(
+      *ast_ctx, m_swift_runtime->GetMemoryReader()));
+}
+
+CompilerType
+SwiftLanguageRuntime::MetadataPromise::FulfillTypePromise(Status *error) {
+  if (error)
+    error->Clear();
+
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  if (log)
+    log->Printf("[MetadataPromise] asked to fulfill type promise at location "
+                "0x%" PRIx64,
+                m_metadata_location);
+
+  if (m_compiler_type.hasValue())
+    return m_compiler_type.getValue();
+
+  swift::remoteAST::Result<swift::Type> result =
+      m_remote_ast->getTypeForRemoteTypeMetadata(
+          swift::remote::RemoteAddress(m_metadata_location));
+
+  if (result) {
+    m_compiler_type = CompilerType(m_swift_ast, result.getValue().getPointer());
+    if (log)
+      log->Printf("[MetadataPromise] result is type %s",
+                  m_compiler_type->GetTypeName().AsCString());
+    return m_compiler_type.getValue();
+  } else {
+    const auto &failure = result.getFailure();
+    if (error)
+      error->SetErrorStringWithFormat("error in resolving type: %s",
+                                      failure.render().c_str());
+    if (log)
+      log->Printf("[MetadataPromise] failure: %s", failure.render().c_str());
+    return (m_compiler_type = CompilerType()).getValue();
+  }
+}
+
+llvm::Optional<swift::MetadataKind>
+SwiftLanguageRuntime::MetadataPromise::FulfillKindPromise(Status *error) {
+  if (error)
+    error->Clear();
+
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_TYPES));
+
+  if (log)
+    log->Printf("[MetadataPromise] asked to fulfill kind promise at location "
+                "0x%" PRIx64,
+                m_metadata_location);
+
+  if (m_metadata_kind.hasValue())
+    return m_metadata_kind;
+
+  swift::remoteAST::Result<swift::MetadataKind> result =
+      m_remote_ast->getKindForRemoteTypeMetadata(
+          swift::remote::RemoteAddress(m_metadata_location));
+
+  if (result) {
+    m_metadata_kind = result.getValue();
+    if (log)
+      log->Printf("[MetadataPromise] result is kind %u", result.getValue());
+    return m_metadata_kind;
+  } else {
+    const auto &failure = result.getFailure();
+    if (error)
+      error->SetErrorStringWithFormat("error in resolving type: %s",
+                                      failure.render().c_str());
+    if (log)
+      log->Printf("[MetadataPromise] failure: %s", failure.render().c_str());
+    return m_metadata_kind;
+  }
+}
+
+bool SwiftLanguageRuntime::MetadataPromise::IsStaticallyDetermined() {
+  if (llvm::Optional<swift::MetadataKind> kind_promise = FulfillKindPromise()) {
+    switch (kind_promise.getValue()) {
+    case swift::MetadataKind::Class:
+    case swift::MetadataKind::Existential:
+    case swift::MetadataKind::ObjCClassWrapper:
+      return false;
+    default:
+      return true;
+    }
+  }
+
+  return true;
+}
+
+static inline swift::Type GetSwiftType(const CompilerType &type) {
+  return swift::Type(
+      reinterpret_cast<swift::TypeBase *>(type.GetOpaqueQualType()));
+}
+
+SwiftLanguageRuntime::MetadataPromiseSP
+SwiftLanguageRuntime::GetMetadataPromise(lldb::addr_t addr,
+                                         SwiftASTContext *swift_ast_ctx) {
+  if (!swift_ast_ctx)
+    swift_ast_ctx = GetScratchSwiftASTContext();
+
+  if (!swift_ast_ctx || swift_ast_ctx->HasFatalErrors())
+    return nullptr;
+
+  if (addr == 0 || addr == LLDB_INVALID_ADDRESS)
+    return nullptr;
+
+  if (auto objc_runtime = GetObjCRuntime()) {
+    if (objc_runtime->GetRuntimeVersion() ==
+        ObjCLanguageRuntime::ObjCRuntimeVersions::eAppleObjC_V2) {
+      addr = ((AppleObjCRuntimeV2 *)objc_runtime)->GetPointerISA(addr);
+    }
+  }
+
+  typename decltype(m_promises_map)::key_type key{
+      swift_ast_ctx->GetASTContext(), addr};
+
+  auto iter = m_promises_map.find(key), end = m_promises_map.end();
+  if (iter != end)
+    return iter->second;
+
+  MetadataPromiseSP promise_sp(
+      new MetadataPromise(std::get<0>(key), this, std::get<1>(key)));
+  m_promises_map.emplace(key, promise_sp);
+  return promise_sp;
+}
+
+SwiftLanguageRuntime::MemberVariableOffsetResolverSP
+SwiftLanguageRuntime::GetMemberVariableOffsetResolver(
+    CompilerType compiler_type) {
+  if (!compiler_type.IsValid())
+    return nullptr;
+
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(compiler_type.GetTypeSystem());
+  if (!swift_ast_ctx || swift_ast_ctx->HasFatalErrors())
+    return nullptr;
+
+  swift::TypeBase *swift_type = reinterpret_cast<swift::TypeBase *>(
+      compiler_type.GetCanonicalType().GetOpaqueQualType());
+
+  typename decltype(m_resolvers_map)::key_type key{
+      swift_ast_ctx->GetASTContext(), swift_type};
+
+  auto iter = m_resolvers_map.find(key), end = m_resolvers_map.end();
+  if (iter != end)
+    return iter->second;
+
+  MemberVariableOffsetResolverSP resolver_sp(new MemberVariableOffsetResolver(
+      std::get<0>(key), this, std::get<1>(key)));
+  m_resolvers_map.emplace(key, resolver_sp);
+  return resolver_sp;
+}
+
+static size_t BaseClassDepth(ValueObject &in_value) {
+  ValueObject *ptr = &in_value;
+  size_t depth = 0;
+  while (ptr->IsBaseClass()) {
+    depth++;
+    ptr = ptr->GetParent();
+  }
+  return depth;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Class(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  CompilerType value_type(in_value.GetCompilerType());
+
+  AddressType address_type;
+  lldb::addr_t class_metadata_ptr = in_value.GetPointerValue(&address_type);
+  if (auto objc_runtime = GetObjCRuntime()) {
+    if (objc_runtime->IsTaggedPointer(class_metadata_ptr)) {
+      Value::ValueType value_type;
+      return objc_runtime->GetDynamicTypeAndAddress(
+          in_value, use_dynamic, class_type_or_name, address, value_type,
+          /* allow_swift = */ true);
+    }
+  }
+  if (class_metadata_ptr == LLDB_INVALID_ADDRESS || class_metadata_ptr == 0)
+    return false;
+  address.SetRawAddress(class_metadata_ptr);
+
+  size_t base_depth = BaseClassDepth(in_value);
+
+  lldb::addr_t class_instance_location;
+  if (in_value.IsBaseClass())
+    class_instance_location = in_value.GetPointerValue();
+  else
+    class_instance_location = in_value.GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+  if (class_instance_location == LLDB_INVALID_ADDRESS)
+    return false;
+  Status error;
+  lldb::addr_t class_metadata_location =
+      m_process->ReadPointerFromMemory(class_instance_location, error);
+  if (error.Fail() || class_metadata_location == 0 ||
+      class_metadata_location == LLDB_INVALID_ADDRESS)
+    return false;
+
+  SwiftASTContext *swift_ast_ctx = llvm::dyn_cast_or_null<SwiftASTContext>(
+      in_value.GetCompilerType().GetTypeSystem());
+
+  MetadataPromiseSP promise_sp(
+      GetMetadataPromise(class_metadata_location, swift_ast_ctx));
+  if (!promise_sp)
+    return false;
+
+  CompilerType class_type(promise_sp->FulfillTypePromise());
+  if (!class_type)
+    return false;
+
+  while (base_depth > 0) {
+    class_type = class_type.GetDirectBaseClassAtIndex(0, nullptr);
+    assert(class_type && "failed to get base class");
+    base_depth--;
+  }
+
+  class_type_or_name.SetCompilerType(class_type);
+
+  if (error.Fail())
+    return false;
+
+  return class_type_or_name.GetCompilerType().IsValid();
+}
+
+SwiftLanguageRuntime::SwiftErrorDescriptor::SwiftErrorDescriptor()
+    : m_kind(Kind::eNotAnError) {}
+
+bool SwiftLanguageRuntime::IsValidErrorValue(
+    ValueObject &in_value, SwiftErrorDescriptor *out_error_descriptor) {
+  // see GetDynamicTypeAndAddress_ErrorType for details
+
+  CompilerType var_type(in_value.GetStaticValue()->GetCompilerType());
+  SwiftASTContext::ProtocolInfo protocol_info;
+  if (!SwiftASTContext::GetProtocolTypeInfo(var_type, protocol_info))
+    return false;
+  if (!protocol_info.m_is_errortype)
+    return false;
+
+  static ConstString g_instance_type_child_name("instance_type");
+  ValueObjectSP instance_type_sp(
+      in_value.GetStaticValue()->GetChildMemberWithName(
+          g_instance_type_child_name, true));
+  if (!instance_type_sp)
+    return false;
+  lldb::addr_t metadata_location = instance_type_sp->GetValueAsUnsigned(0);
+  if (metadata_location == 0 || metadata_location == LLDB_INVALID_ADDRESS)
+    return false;
+
+  SetupSwiftError();
+  if (m_SwiftNativeNSErrorISA.hasValue()) {
+    if (auto objc_runtime = GetObjCRuntime()) {
+      if (auto descriptor =
+              objc_runtime->GetClassDescriptor(*instance_type_sp)) {
+        if (descriptor->GetISA() != m_SwiftNativeNSErrorISA.getValue()) {
+          // not a _SwiftNativeNSError - but statically typed as ErrorType
+          // return true here
+          if (out_error_descriptor) {
+            *out_error_descriptor = SwiftErrorDescriptor();
+            out_error_descriptor->m_kind = SwiftErrorDescriptor::Kind::eBridged;
+            out_error_descriptor->m_bridged.instance_ptr_value =
+                instance_type_sp->GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+          }
+          return true;
+        }
+      }
+    }
+  }
+
+  if (GetObjCRuntime()) {
+    // this is a swift native error but it can be bridged to ObjC
+    // so it needs to be layout compatible
+
+    size_t ptr_size = m_process->GetAddressByteSize();
+    size_t metadata_offset =
+        ptr_size + 4 + (ptr_size == 8 ? 4 : 0);        // CFRuntimeBase
+    metadata_offset += ptr_size + ptr_size + ptr_size; // CFIndex + 2*CFRef
+
+    metadata_location += metadata_offset;
+    Status error;
+    lldb::addr_t metadata_ptr_value =
+        m_process->ReadPointerFromMemory(metadata_location, error);
+    if (metadata_ptr_value == 0 || metadata_ptr_value == LLDB_INVALID_ADDRESS ||
+        error.Fail())
+      return false;
+
+    if (out_error_descriptor) {
+      *out_error_descriptor = SwiftErrorDescriptor();
+      out_error_descriptor->m_kind =
+          SwiftErrorDescriptor::Kind::eSwiftBridgeableNative;
+      out_error_descriptor->m_bridgeable_native.metadata_location =
+          metadata_location;
+      out_error_descriptor->m_bridgeable_native.metadata_ptr_value =
+          metadata_ptr_value;
+    }
+  } else {
+    // this is a swift native error and it has no way to be bridged to ObjC
+    // so it adopts a more compact layout
+
+    Status error;
+
+    size_t ptr_size = m_process->GetAddressByteSize();
+    size_t metadata_offset = 2 * ptr_size;
+    metadata_location += metadata_offset;
+    lldb::addr_t metadata_ptr_value =
+        m_process->ReadPointerFromMemory(metadata_location, error);
+    if (metadata_ptr_value == 0 || metadata_ptr_value == LLDB_INVALID_ADDRESS ||
+        error.Fail())
+      return false;
+
+    lldb::addr_t witness_table_location = metadata_location + ptr_size;
+    lldb::addr_t witness_table_ptr_value =
+        m_process->ReadPointerFromMemory(witness_table_location, error);
+    if (witness_table_ptr_value == 0 ||
+        witness_table_ptr_value == LLDB_INVALID_ADDRESS || error.Fail())
+      return false;
+
+    lldb::addr_t payload_location = witness_table_location + ptr_size;
+
+    if (out_error_descriptor) {
+      *out_error_descriptor = SwiftErrorDescriptor();
+      out_error_descriptor->m_kind =
+          SwiftErrorDescriptor::Kind::eSwiftPureNative;
+      out_error_descriptor->m_pure_native.metadata_location =
+          metadata_ptr_value;
+      out_error_descriptor->m_pure_native.witness_table_location =
+          witness_table_ptr_value;
+      out_error_descriptor->m_pure_native.payload_ptr = payload_location;
+    }
+  }
+
+  return true;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_ErrorType(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  // layout of error type
+  // pointer to -------> SwiftError {
+  // --------------
+  // CFRuntimeBase
+  // CFIndex
+  // CFStringRef
+  // CFDictionaryRef
+  // --------------
+  // Metadata
+  // WitnessTable
+  // hashable Metadata
+  // hashable WitnessTable
+  // --------------
+  // tail allocated actual object data *
+  // }
+  // * for a struct, it's the inline data
+  // * for a class, it's the inline pointer-to-the-data (aka, the swift class
+  // instance)
+  SwiftErrorDescriptor error_descriptor;
+  if (!IsValidErrorValue(in_value, &error_descriptor))
+    return false;
+
+  Status error;
+  CompilerType var_type(in_value.GetStaticValue()->GetCompilerType());
+  size_t ptr_size = m_process->GetAddressByteSize();
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(var_type.GetTypeSystem());
+  if (!swift_ast_ctx)
+    return false;
+
+  switch (error_descriptor.m_kind) {
+  case SwiftErrorDescriptor::Kind::eNotAnError:
+    return false;
+  case SwiftErrorDescriptor::Kind::eSwiftBridgeableNative: {
+    MetadataPromiseSP promise_sp(GetMetadataPromise(
+        error_descriptor.m_bridgeable_native.metadata_ptr_value,
+        swift_ast_ctx));
+    if (!promise_sp)
+      return false;
+    error_descriptor.m_bridgeable_native.metadata_location += 4 * ptr_size;
+    if (!promise_sp->IsStaticallyDetermined()) {
+      // figure out the actual dynamic type via the metadata at the "isa"
+      // pointer
+      error_descriptor.m_bridgeable_native.metadata_location =
+          m_process->ReadPointerFromMemory(
+              error_descriptor.m_bridgeable_native.metadata_location, error);
+      if (error_descriptor.m_bridgeable_native.metadata_location == 0 ||
+          error_descriptor.m_bridgeable_native.metadata_location ==
+              LLDB_INVALID_ADDRESS ||
+          error.Fail())
+        return false;
+      error_descriptor.m_bridgeable_native.metadata_ptr_value =
+          m_process->ReadPointerFromMemory(
+              error_descriptor.m_bridgeable_native.metadata_location, error);
+      if (error_descriptor.m_bridgeable_native.metadata_ptr_value == 0 ||
+          error_descriptor.m_bridgeable_native.metadata_ptr_value ==
+              LLDB_INVALID_ADDRESS ||
+          error.Fail())
+        return false;
+      promise_sp = GetMetadataPromise(
+          error_descriptor.m_bridgeable_native.metadata_ptr_value,
+          swift_ast_ctx);
+      if (!promise_sp || !promise_sp->FulfillTypePromise()) {
+        // this could still be a random ObjC object
+        if (auto objc_runtime = GetObjCRuntime()) {
+          DataExtractor extractor(
+              &error_descriptor.m_bridgeable_native.metadata_location,
+              sizeof(error_descriptor.m_bridgeable_native.metadata_location),
+              GetProcess()->GetByteOrder(), GetProcess()->GetAddressByteSize());
+          ExecutionContext exe_ctx(GetProcess());
+          auto scratch_ast =
+              GetProcess()->GetTarget().GetScratchClangASTContext();
+          if (scratch_ast) {
+            auto valobj_sp = ValueObject::CreateValueObjectFromData(
+                in_value.GetName().AsCString(), extractor, exe_ctx,
+                scratch_ast->GetBasicType(eBasicTypeObjCID));
+            if (valobj_sp) {
+              Value::ValueType value_type;
+              if (objc_runtime->GetDynamicTypeAndAddress(
+                      *valobj_sp, use_dynamic, class_type_or_name, address,
+                      value_type)) {
+                address.SetLoadAddress(
+                    error_descriptor.m_bridgeable_native.metadata_location,
+                    &GetProcess()->GetTarget());
+                if (!class_type_or_name.GetCompilerType().IsPointerType()) {
+                  // the language runtimes do not return pointer-to-types when
+                  // doing dynamic type resolution
+                  // what usually happens is that the static type has
+                  // pointer-like traits that ValueObjectDynamic
+                  // then preserves in the dynamic value - since the static type
+                  // here is a Swift protocol object
+                  // the dynamic type won't know to pointerize. But we truly
+                  // need an ObjCObjectPointer here or else
+                  // type printing WILL be confused. Hence, make the pointer
+                  // type ourselves if we didn't get one already
+                  class_type_or_name.SetCompilerType(
+                      class_type_or_name.GetCompilerType().GetPointerType());
+                }
+                return true;
+              }
+            }
+          }
+        }
+
+        return false;
+      }
+    }
+
+    if (!promise_sp)
+      return false;
+    address.SetLoadAddress(
+        error_descriptor.m_bridgeable_native.metadata_location,
+        &m_process->GetTarget());
+    CompilerType metadata_type(promise_sp->FulfillTypePromise());
+    if (metadata_type.IsValid() && error.Success()) {
+      class_type_or_name.SetCompilerType(metadata_type);
+      return true;
+    }
+  } break;
+  case SwiftErrorDescriptor::Kind::eBridged: {
+    if (error_descriptor.m_bridged.instance_ptr_value != 0 &&
+        error_descriptor.m_bridged.instance_ptr_value != LLDB_INVALID_ADDRESS) {
+      Status error_type_lookup_error;
+      if (CompilerType error_type =
+              swift_ast_ctx->GetNSErrorType(error_type_lookup_error)) {
+        class_type_or_name.SetCompilerType(error_type);
+        address.SetRawAddress(error_descriptor.m_bridged.instance_ptr_value);
+        return true;
+      }
+    }
+  } break;
+  case SwiftErrorDescriptor::Kind::eSwiftPureNative: {
+    Status error;
+    if (MetadataPromiseSP promise_sp = GetMetadataPromise(
+            error_descriptor.m_pure_native.metadata_location, swift_ast_ctx)) {
+      if (promise_sp->IsStaticallyDetermined()) {
+        if (CompilerType compiler_type = promise_sp->FulfillTypePromise()) {
+          class_type_or_name.SetCompilerType(compiler_type);
+          address.SetRawAddress(error_descriptor.m_pure_native.payload_ptr);
+          return true;
+        }
+      } else {
+        error_descriptor.m_pure_native.metadata_location =
+            m_process->ReadPointerFromMemory(
+                error_descriptor.m_pure_native.payload_ptr, error);
+        if (error_descriptor.m_pure_native.metadata_location == 0 ||
+            error_descriptor.m_pure_native.metadata_location ==
+                LLDB_INVALID_ADDRESS ||
+            error.Fail())
+          return false;
+        error_descriptor.m_pure_native.payload_ptr =
+            error_descriptor.m_pure_native.metadata_location;
+        error_descriptor.m_pure_native.metadata_location =
+            m_process->ReadPointerFromMemory(
+                error_descriptor.m_pure_native.payload_ptr, error);
+        if (MetadataPromiseSP promise_sp = GetMetadataPromise(
+                error_descriptor.m_pure_native.metadata_location,
+                swift_ast_ctx)) {
+          if (CompilerType compiler_type = promise_sp->FulfillTypePromise()) {
+            class_type_or_name.SetCompilerType(compiler_type);
+            address.SetRawAddress(error_descriptor.m_pure_native.payload_ptr);
+            return true;
+          }
+        }
+      }
+    }
+  } break;
+  }
+
+  return false;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Protocol(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  CompilerType var_type(in_value.GetCompilerType());
+  SwiftASTContext::ProtocolInfo protocol_info;
+  if (!SwiftASTContext::GetProtocolTypeInfo(var_type, protocol_info))
+    return false;
+
+  if (protocol_info.m_is_errortype)
+    return GetDynamicTypeAndAddress_ErrorType(in_value, use_dynamic,
+                                              class_type_or_name, address);
+
+  MetadataPromiseSP promise_sp;
+  static ConstString g_instance_type_child_name("instance_type");
+  ValueObjectSP instance_type_sp(
+      in_value.GetStaticValue()->GetChildMemberWithName(
+          g_instance_type_child_name, true));
+  if (!instance_type_sp)
+    return false;
+  ValueObjectSP payload0_sp(
+      in_value.GetStaticValue()->GetChildAtIndex(0, true));
+  if (!payload0_sp)
+    return false;
+  // @objc protocols are automatically class-only, and there is no
+  // static/dynamic to deal with
+  bool is_class = protocol_info.m_is_objc || protocol_info.m_is_class_only ||
+                  protocol_info.m_is_anyobject;
+  if (!is_class) {
+    promise_sp = GetMetadataPromise(instance_type_sp->GetValueAsUnsigned(0));
+    if (!promise_sp)
+      return false;
+    if (promise_sp->FulfillKindPromise().hasValue() &&
+        promise_sp->FulfillKindPromise().getValue() ==
+            swift::MetadataKind::Class)
+      is_class = true;
+  }
+  if (is_class) {
+    if (GetDynamicTypeAndAddress_Class(*payload0_sp, use_dynamic,
+                                       class_type_or_name, address))
+      return true;
+
+    // only for @objc protocols, try to fallback to the ObjC runtime as a source
+    // of type information
+    // this is not exactly a great solution and we need to be careful with how
+    // we use the results of this
+    // computation, but assuming some care, at least data formatters will work
+    if (!protocol_info.m_is_objc)
+      return false;
+    auto objc_runtime = GetObjCRuntime();
+    if (!objc_runtime)
+      return false;
+    auto descriptor_sp = objc_runtime->GetClassDescriptor(*payload0_sp);
+    if (!descriptor_sp)
+      return false;
+    std::vector<clang::NamedDecl *> decls;
+    DeclVendor *vendor = objc_runtime->GetDeclVendor();
+    if (!vendor)
+      return false;
+    vendor->FindDecls(descriptor_sp->GetClassName(), true, 1, decls);
+    if (decls.size() == 0)
+      return false;
+    CompilerType type = ClangASTContext::GetTypeForDecl(decls[0]);
+    if (!type.IsValid())
+      return false;
+
+    lldb::addr_t class_metadata_ptr = payload0_sp->GetAddressOf();
+    if (class_metadata_ptr == LLDB_INVALID_ADDRESS || class_metadata_ptr == 0)
+      return false;
+    address.SetRawAddress(class_metadata_ptr);
+
+    class_type_or_name.SetCompilerType(type.GetPointerType());
+    return class_type_or_name.GetCompilerType().IsValid();
+  }
+
+  if (promise_sp->FulfillKindPromise().hasValue() &&
+      (promise_sp->FulfillKindPromise().getValue() ==
+           swift::MetadataKind::Struct ||
+       promise_sp->FulfillKindPromise().getValue() ==
+           swift::MetadataKind::Enum ||
+       promise_sp->FulfillKindPromise().getValue() ==
+           swift::MetadataKind::Tuple)) {
+    Status error;
+    class_type_or_name.SetCompilerType(promise_sp->FulfillTypePromise());
+    if (error.Fail())
+      return false;
+    // the choices made here affect dynamic type resolution
+    // for an inline protocol object, e.g.:
+    // (P) $R1 = {
+    //     (Builtin.RawPointer) payload_data_0 = 0x0000000000000001
+    //     (Builtin.RawPointer) payload_data_1 = 0x0000000000000002
+    //     (Builtin.RawPointer) payload_data_2 = 0x0000000000000000
+    //     (Builtin.RawPointer) instance_type = 0x000000010054c2f8
+    //     (Builtin.RawPointer) protocol_witness_0 = 0x000000010054c100
+    // }
+    // pick &payload_data_0
+    // for a pointed-to protocol object, e.g.:
+    // (Q) $R2 = {
+    //     (Builtin.RawPointer) payload_data_0 = 0x00000001006079b0
+    //     (Builtin.RawPointer) payload_data_1 = 0x0000000000000000
+    //     (Builtin.RawPointer) payload_data_2 = 0x0000000000000000
+    //     (Builtin.RawPointer) instance_type = 0x000000010054c648
+    //     (Builtin.RawPointer) protocol_witness_0 = 0x000000010054c7b0
+    // }
+    // pick the value of payload_data_0
+    switch (SwiftASTContext::GetAllocationStrategy(
+        class_type_or_name.GetCompilerType())) {
+    case SwiftASTContext::TypeAllocationStrategy::eInline:
+      // FIXME: we should not have to do this - but we are getting confused
+      // w.r.t.
+      // frozen-dried vs. live versions of objects, so hack around it for now
+      if (in_value.GetValue().GetValueAddressType() == eAddressTypeHost)
+        address.SetRawAddress(in_value.GetValue().GetScalar().ULongLong());
+      else
+        address.SetRawAddress(in_value.GetAddressOf());
+      return true;
+    case SwiftASTContext::TypeAllocationStrategy::ePointer:
+      address.SetRawAddress(payload0_sp->GetValueAsUnsigned(0));
+      return true;
+    default:
+      // TODO we don't know how to deal with the dynamic case quite yet
+      return false;
+    }
+  }
+  return false;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Promise(
+    ValueObject &in_value, MetadataPromiseSP promise_sp,
+    lldb::DynamicValueType use_dynamic, TypeAndOrName &class_type_or_name,
+    Address &address) {
+  if (!promise_sp)
+    return false;
+
+  CompilerType var_type(in_value.GetCompilerType());
+  Status error;
+
+  if (!promise_sp->FulfillKindPromise())
+    return false;
+
+  switch (promise_sp->FulfillKindPromise().getValue()) {
+  case swift::MetadataKind::Class: {
+    CompilerType dyn_type(promise_sp->FulfillTypePromise());
+    if (!dyn_type.IsValid())
+      return false;
+    class_type_or_name.SetCompilerType(dyn_type);
+    lldb::addr_t val_ptr_addr = in_value.GetPointerValue();
+    val_ptr_addr = GetProcess()->ReadPointerFromMemory(val_ptr_addr, error);
+    address.SetLoadAddress(val_ptr_addr, &m_process->GetTarget());
+    return true;
+  } break;
+  case swift::MetadataKind::Struct:
+  case swift::MetadataKind::Tuple: {
+    CompilerType dyn_type(promise_sp->FulfillTypePromise());
+    if (!dyn_type.IsValid())
+      return false;
+    class_type_or_name.SetCompilerType(dyn_type);
+    lldb::addr_t val_ptr_addr = in_value.GetPointerValue();
+    address.SetLoadAddress(val_ptr_addr, &m_process->GetTarget());
+    return true;
+  } break;
+  case swift::MetadataKind::Enum: {
+    CompilerType dyn_type(promise_sp->FulfillTypePromise());
+    if (!dyn_type.IsValid())
+      return false;
+    class_type_or_name.SetCompilerType(dyn_type);
+    lldb::addr_t val_ptr_addr = in_value.GetPointerValue();
+    {
+      auto swift_type = GetSwiftType(dyn_type);
+      if (swift_type->getAnyOptionalObjectType())
+        val_ptr_addr = GetProcess()->ReadPointerFromMemory(val_ptr_addr, error);
+    }
+    address.SetLoadAddress(val_ptr_addr, &m_process->GetTarget());
+    return true;
+  } break;
+  case swift::MetadataKind::Existential: {
+    SwiftASTContext *swift_ast_ctx =
+        llvm::dyn_cast_or_null<SwiftASTContext>(var_type.GetTypeSystem());
+
+    CompilerType protocol_type(promise_sp->FulfillTypePromise());
+    if (swift_ast_ctx->IsErrorType(protocol_type)) {
+      if (swift_ast_ctx) {
+        Status error;
+        // the offset
+        size_t ptr_size = m_process->GetAddressByteSize();
+        size_t metadata_offset = ptr_size + 4 + (ptr_size == 8 ? 4 : 0);
+        metadata_offset += ptr_size + ptr_size + ptr_size;
+        lldb::addr_t archetype_ptr_value = in_value.GetValueAsUnsigned(0);
+        lldb::addr_t base_errortype_ptr =
+            m_process->ReadPointerFromMemory(archetype_ptr_value, error);
+        lldb::addr_t static_metadata_ptrptr =
+            base_errortype_ptr + metadata_offset;
+        lldb::addr_t static_metadata_ptr =
+            m_process->ReadPointerFromMemory(static_metadata_ptrptr, error);
+        MetadataPromiseSP promise_sp(
+            GetMetadataPromise(static_metadata_ptr, swift_ast_ctx));
+        if (promise_sp) {
+          lldb::addr_t load_addr = static_metadata_ptrptr + 2 * ptr_size;
+          if (promise_sp->FulfillKindPromise() &&
+              promise_sp->FulfillKindPromise().getValue() ==
+                  swift::MetadataKind::Class) {
+            load_addr = m_process->ReadPointerFromMemory(load_addr, error);
+            lldb::addr_t dynamic_metadata_location =
+                m_process->ReadPointerFromMemory(load_addr, error);
+            promise_sp =
+                GetMetadataPromise(dynamic_metadata_location, swift_ast_ctx);
+          }
+          CompilerType clang_type(promise_sp->FulfillTypePromise());
+          if (clang_type.IsValid() && load_addr != 0 &&
+              load_addr != LLDB_INVALID_ADDRESS) {
+            class_type_or_name.SetCompilerType(clang_type);
+            address.SetLoadAddress(load_addr, &m_process->GetTarget());
+            return true;
+          }
+        }
+      }
+    } else {
+      Status error;
+      lldb::addr_t ptr_to_instance_type = in_value.GetValueAsUnsigned(0) +
+                                          (3 * m_process->GetAddressByteSize());
+      lldb::addr_t metadata_of_impl_addr =
+          m_process->ReadPointerFromMemory(ptr_to_instance_type, error);
+      if (error.Fail() || metadata_of_impl_addr == 0 ||
+          metadata_of_impl_addr == LLDB_INVALID_ADDRESS)
+        return false;
+      MetadataPromiseSP promise_of_impl_sp(
+          GetMetadataPromise(metadata_of_impl_addr, swift_ast_ctx));
+      if (GetDynamicTypeAndAddress_Promise(in_value, promise_of_impl_sp,
+                                           use_dynamic, class_type_or_name,
+                                           address)) {
+        lldb::addr_t load_addr = in_value.GetValueAsUnsigned(0);
+        if (promise_of_impl_sp->FulfillKindPromise() &&
+            promise_of_impl_sp->FulfillKindPromise().getValue() ==
+                swift::MetadataKind::Class) {
+          load_addr = m_process->ReadPointerFromMemory(load_addr, error);
+          if (error.Fail() || load_addr == 0 ||
+              load_addr == LLDB_INVALID_ADDRESS)
+            return false;
+        } else if (promise_of_impl_sp->FulfillKindPromise() &&
+                   (promise_of_impl_sp->FulfillKindPromise().getValue() ==
+                        swift::MetadataKind::Enum ||
+                    promise_of_impl_sp->FulfillKindPromise().getValue() ==
+                        swift::MetadataKind::Struct)) {
+        } else
+          lldbassert(false && "class, enum and struct are the only protocol "
+                              "implementor types I know about");
+        address.SetLoadAddress(load_addr, &m_process->GetTarget());
+        return true;
+      }
+    }
+  } break;
+  default:
+    break;
+  }
+
+  return false;
+}
+
+SwiftLanguageRuntime::MetadataPromiseSP
+SwiftLanguageRuntime::GetPromiseForTypeNameAndFrame(const char *type_name,
+                                                    StackFrame *frame) {
+  if (!frame || !type_name || !type_name[0])
+    return nullptr;
+
+  SwiftASTContext *swift_ast_ctx = nullptr;
+  const SymbolContext &sc(frame->GetSymbolContext(eSymbolContextFunction));
+  if (sc.function)
+    swift_ast_ctx = llvm::dyn_cast_or_null<SwiftASTContext>(
+        sc.function->GetCompilerType().GetTypeSystem());
+
+  StreamString type_metadata_ptr_var_name;
+  type_metadata_ptr_var_name.Printf("$swift.type.%s", type_name);
+  VariableList *var_list = frame->GetVariableList(false);
+  if (!var_list)
+    return nullptr;
+
+  VariableSP var_sp(var_list->FindVariable(
+      ConstString(type_metadata_ptr_var_name.GetData())));
+  if (!var_sp)
+    return nullptr;
+
+  ValueObjectSP metadata_ptr_var_sp(
+      frame->GetValueObjectForFrameVariable(var_sp, lldb::eNoDynamicValues));
+  if (!metadata_ptr_var_sp ||
+      metadata_ptr_var_sp->UpdateValueIfNeeded() == false)
+    return nullptr;
+
+  lldb::addr_t metadata_location(metadata_ptr_var_sp->GetValueAsUnsigned(0));
+  if (metadata_location == 0 || metadata_location == LLDB_INVALID_ADDRESS)
+    return nullptr;
+
+  return GetMetadataPromise(metadata_location, swift_ast_ctx);
+}
+
+CompilerType
+SwiftLanguageRuntime::DoArchetypeBindingForType(StackFrame &stack_frame,
+                                                CompilerType base_type,
+                                                SwiftASTContext *ast_context) {
+  if (base_type.GetTypeInfo() & lldb::eTypeIsSwift) {
+    if (!ast_context)
+      ast_context =
+          llvm::dyn_cast_or_null<SwiftASTContext>(base_type.GetTypeSystem());
+
+    if (ast_context) {
+      swift::Type target_swift_type(GetSwiftType(base_type));
+
+      target_swift_type = target_swift_type.transform(
+          [this, &stack_frame,
+           ast_context](swift::Type candidate_type) -> swift::Type {
+            if (swift::ArchetypeType *candidate_archetype =
+                    llvm::dyn_cast_or_null<swift::ArchetypeType>(
+                        candidate_type.getPointer())) {
+              llvm::StringRef candidate_name =
+                  candidate_archetype->getFullName();
+
+              CompilerType concrete_type = this->GetConcreteType(
+                  &stack_frame, ConstString(candidate_name));
+              Status import_error;
+              CompilerType target_concrete_type =
+                  ast_context->ImportType(concrete_type, import_error);
+
+              if (target_concrete_type.IsValid())
+                return swift::Type(GetSwiftType(target_concrete_type));
+              else
+                return candidate_type;
+            } else
+              return candidate_type;
+          });
+
+      return CompilerType(ast_context->GetASTContext(),
+                          target_swift_type.getPointer());
+    }
+  }
+  return base_type;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Archetype(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  const char *type_name(in_value.GetTypeName().GetCString());
+  StackFrame *frame(in_value.GetFrameSP().get());
+  MetadataPromiseSP promise_sp(GetPromiseForTypeNameAndFrame(type_name, frame));
+  if (!promise_sp)
+    return false;
+  if (!GetDynamicTypeAndAddress_Promise(in_value, promise_sp, use_dynamic,
+                                        class_type_or_name, address))
+    return false;
+  if (promise_sp->FulfillKindPromise() &&
+      promise_sp->FulfillKindPromise().getValue() ==
+          swift::MetadataKind::Class) {
+    // when an archetype represents a class, it will represent the static type
+    // of the class
+    // but the dynamic type might be different
+    Status error;
+    lldb::addr_t addr_of_meta = address.GetLoadAddress(&m_process->GetTarget());
+    addr_of_meta = m_process->ReadPointerFromMemory(addr_of_meta, error);
+    if (addr_of_meta == LLDB_INVALID_ADDRESS || addr_of_meta == 0 ||
+        error.Fail())
+      return true; // my gut says we should fail here, but we seemed to be on a
+                   // good track before..
+    MetadataPromiseSP actual_type_promise(GetMetadataPromise(addr_of_meta));
+    if (actual_type_promise && actual_type_promise.get() != promise_sp.get()) {
+      CompilerType static_type(class_type_or_name.GetCompilerType());
+      class_type_or_name.SetCompilerType(
+          actual_type_promise->FulfillTypePromise());
+      if (error.Fail() ||
+          class_type_or_name.GetCompilerType().IsValid() == false)
+        class_type_or_name.SetCompilerType(static_type);
+    }
+  }
+  return true;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Tuple(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  std::vector<CompilerType> dyn_types;
+
+  for (size_t idx = 0; idx < in_value.GetNumChildren(); idx++) {
+    ValueObjectSP child_sp(in_value.GetChildAtIndex(idx, true));
+    TypeAndOrName type_and_or_name;
+    Address address;
+    Value::ValueType value_type;
+    if (GetDynamicTypeAndAddress(*child_sp.get(), use_dynamic, type_and_or_name,
+                                 address, value_type) == false)
+      dyn_types.push_back(child_sp->GetCompilerType());
+    else
+      dyn_types.push_back(type_and_or_name.GetCompilerType());
+  }
+
+  SwiftASTContext *swift_ast_ctx = llvm::dyn_cast_or_null<SwiftASTContext>(
+      in_value.GetCompilerType().GetTypeSystem());
+
+  CompilerType dyn_tuple_type(swift_ast_ctx->CreateTupleType(dyn_types));
+
+  class_type_or_name.SetCompilerType(dyn_tuple_type);
+  lldb::addr_t tuple_address = in_value.GetPointerValue();
+  Status error;
+  tuple_address = m_process->ReadPointerFromMemory(tuple_address, error);
+  if (error.Fail() || tuple_address == 0 ||
+      tuple_address == LLDB_INVALID_ADDRESS)
+    return false;
+
+  address.SetLoadAddress(tuple_address, in_value.GetTargetSP().get());
+
+  return true;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Struct(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  // struct can't inherit from each other, but they can be generic, in which
+  // case
+  // we need to turn MyStruct<U> into MyStruct<$swift.type.U>
+  std::vector<CompilerType> generic_args;
+
+  lldb_private::StackFrame *frame =
+      in_value.GetExecutionContextRef().GetFrameSP().get();
+
+  if (!frame)
+    return false;
+
+  // this will be a BoundGenericStruct, bound to archetypes
+  CompilerType struct_type(in_value.GetCompilerType());
+
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(struct_type.GetTypeSystem());
+
+  CompilerType resolved_type(
+      DoArchetypeBindingForType(*frame, struct_type, swift_ast_ctx));
+  if (!resolved_type)
+    return false;
+
+  class_type_or_name.SetCompilerType(resolved_type);
+
+  lldb::addr_t struct_address = in_value.GetPointerValue();
+  if (0 == struct_address || LLDB_INVALID_ADDRESS == struct_address)
+    struct_address = in_value.GetAddressOf(true, nullptr);
+  if (0 == struct_address || LLDB_INVALID_ADDRESS == struct_address) {
+    if (false == SwiftASTContext::IsPossibleZeroSizeType(
+                     class_type_or_name.GetCompilerType()))
+      return false;
+  }
+
+  address.SetLoadAddress(struct_address, in_value.GetTargetSP().get());
+  return true;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_Enum(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  // enums can't inherit from each other, but they can be generic, in which case
+  // we need to turn MyEnum<U> into MyEnum<$swift.type.U>
+  std::vector<CompilerType> generic_args;
+
+  lldb_private::StackFrame *frame =
+      in_value.GetExecutionContextRef().GetFrameSP().get();
+
+  if (!frame)
+    return false;
+
+  // this will be a BoundGenericEnum, bound to archetypes
+  CompilerType enum_type(in_value.GetCompilerType());
+
+  SwiftASTContext *swift_ast_ctx =
+      llvm::dyn_cast_or_null<SwiftASTContext>(enum_type.GetTypeSystem());
+
+  CompilerType resolved_type(
+      DoArchetypeBindingForType(*frame, enum_type, swift_ast_ctx));
+  if (!resolved_type)
+    return false;
+
+  class_type_or_name.SetCompilerType(resolved_type);
+
+  lldb::addr_t enum_address = in_value.GetPointerValue();
+  if (0 == enum_address || LLDB_INVALID_ADDRESS == enum_address)
+    enum_address = in_value.GetAddressOf(true, nullptr);
+  if (0 == enum_address || LLDB_INVALID_ADDRESS == enum_address) {
+    if (false == SwiftASTContext::IsPossibleZeroSizeType(
+                     class_type_or_name.GetCompilerType()))
+      return false;
+  }
+
+  address.SetLoadAddress(enum_address, in_value.GetTargetSP().get());
+  return true;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress_IndirectEnumCase(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address) {
+  static ConstString g_offset("offset");
+
+  DataExtractor data;
+  Status error;
+  if (in_value.GetParent() && in_value.GetParent()->GetData(data, error) &&
+      error.Success()) {
+    bool has_payload;
+    bool is_indirect;
+    CompilerType payload_type;
+    if (SwiftASTContext::GetSelectedEnumCase(
+            in_value.GetParent()->GetCompilerType(), data, nullptr,
+            &has_payload, &payload_type, &is_indirect)) {
+      if (has_payload && is_indirect && payload_type)
+        class_type_or_name.SetCompilerType(payload_type);
+      lldb::addr_t box_addr = in_value.GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+      if (box_addr != LLDB_INVALID_ADDRESS) {
+        box_addr = MaskMaybeBridgedPointer(box_addr);
+        lldb::addr_t box_location =
+            m_process->ReadPointerFromMemory(box_addr, error);
+        if (box_location != LLDB_INVALID_ADDRESS) {
+          box_location = MaskMaybeBridgedPointer(box_location);
+          ProcessStructReader reader(m_process, box_location,
+                                     GetBoxMetadataType());
+          uint32_t offset = reader.GetField<uint32_t>(g_offset);
+          lldb::addr_t box_value = box_addr + offset;
+
+          // try to read one byte at the box value
+          m_process->ReadUnsignedIntegerFromMemory(box_value, 1, 0, error);
+          if (error
+                  .Fail()) // and if that fails, then we're off in no man's land
+            return false;
+
+          Flags type_info(payload_type.GetTypeInfo());
+          if (type_info.AllSet(eTypeIsSwift | eTypeIsClass)) {
+            lldb::addr_t old_box_value = box_value;
+            box_value = m_process->ReadPointerFromMemory(box_value, error);
+            if (box_value != LLDB_INVALID_ADDRESS) {
+              DataExtractor data(&box_value, m_process->GetAddressByteSize(),
+                                 m_process->GetByteOrder(),
+                                 m_process->GetAddressByteSize());
+              ValueObjectSP valobj_sp(ValueObject::CreateValueObjectFromData(
+                  "_", data, *m_process, payload_type));
+              if (valobj_sp) {
+                Value::ValueType value_type;
+                if (GetDynamicTypeAndAddress(*valobj_sp, use_dynamic,
+                                             class_type_or_name, address,
+                                             value_type)) {
+                  address.SetRawAddress(old_box_value);
+                  return true;
+                }
+              }
+            }
+          } else if (type_info.AllSet(eTypeIsSwift | eTypeIsProtocol)) {
+            SwiftASTContext::ProtocolInfo protocol_info;
+            if (SwiftASTContext::GetProtocolTypeInfo(payload_type,
+                                                     protocol_info)) {
+              auto ptr_size = m_process->GetAddressByteSize();
+              std::vector<uint8_t> buffer(
+                  ptr_size * protocol_info.m_num_storage_words, 0);
+              for (uint32_t idx = 0; idx < protocol_info.m_num_storage_words;
+                   idx++) {
+                lldb::addr_t word = m_process->ReadUnsignedIntegerFromMemory(
+                    box_value + idx * ptr_size, ptr_size, 0, error);
+                if (error.Fail())
+                  return false;
+                memcpy(&buffer[idx * ptr_size], &word, ptr_size);
+              }
+              DataExtractor data(&buffer[0], buffer.size(),
+                                 m_process->GetByteOrder(),
+                                 m_process->GetAddressByteSize());
+              ValueObjectSP valobj_sp(ValueObject::CreateValueObjectFromData(
+                  "_", data, *m_process, payload_type));
+              if (valobj_sp) {
+                Value::ValueType value_type;
+                if (GetDynamicTypeAndAddress(*valobj_sp, use_dynamic,
+                                             class_type_or_name, address,
+                                             value_type)) {
+                  address.SetRawAddress(box_value);
+                  return true;
+                }
+              }
+            }
+          } else {
+            // this is most likely a statically known type
+            address.SetLoadAddress(box_value, &m_process->GetTarget());
+            return true;
+          }
+        }
+      }
+    }
+  }
+  return false;
+}
+
+// Dynamic type resolution tends to want to generate scalar data - but there are
+// caveats
+// Per original comment here
+// "Our address is the location of the dynamic type stored in memory.  It isn't
+// a load address,
+//  because we aren't pointing to the LOCATION that stores the pointer to us,
+//  we're pointing to us..."
+// See inlined comments for exceptions to this general rule.
+Value::ValueType SwiftLanguageRuntime::GetValueType(
+    Value::ValueType static_value_type, const CompilerType &static_type,
+    const CompilerType &dynamic_type, bool is_indirect_enum_case) {
+  Flags static_type_flags(static_type.GetTypeInfo());
+  Flags dynamic_type_flags(dynamic_type.GetTypeInfo());
+
+  if (dynamic_type_flags.AllSet(eTypeIsSwift)) {
+    // for a protocol object where does the dynamic data live if the target
+    // object is a struct? (for a class, it's easy)
+    if (static_type_flags.AllSet(eTypeIsSwift | eTypeIsProtocol) &&
+        dynamic_type_flags.AnySet(eTypeIsStructUnion | eTypeIsEnumeration)) {
+      SwiftASTContext *swift_ast_ctx =
+          llvm::dyn_cast_or_null<SwiftASTContext>(static_type.GetTypeSystem());
+
+      if (swift_ast_ctx && swift_ast_ctx->IsErrorType(static_type)) {
+        // ErrorType values are always a pointer
+        return Value::eValueTypeLoadAddress;
+      }
+
+      switch (SwiftASTContext::GetAllocationStrategy(dynamic_type)) {
+      case SwiftASTContext::TypeAllocationStrategy::eDynamic:
+      case SwiftASTContext::TypeAllocationStrategy::eUnknown:
+        break;
+      case SwiftASTContext::TypeAllocationStrategy::eInline: // inline data;
+                                                             // same as the
+                                                             // static data
+        return static_value_type;
+      case SwiftASTContext::TypeAllocationStrategy::ePointer: // pointed-to; in
+                                                              // the target
+        return Value::eValueTypeLoadAddress;
+      }
+    }
+    if (static_type_flags.AllSet(eTypeIsSwift | eTypeIsArchetype)) {
+      // if I am handling a non-pointer Swift type obtained from an archetype,
+      // then the runtime vends the location
+      // of the object, not the object per se (since the object is not a pointer
+      // itself, this is way easier to achieve)
+      // hence, it's a load address, not a scalar containing a pointer as for
+      // ObjC classes
+      if (dynamic_type_flags.AllClear(eTypeIsPointer | eTypeIsReference |
+                                      eTypeInstanceIsPointer))
+        return Value::eValueTypeLoadAddress;
+    }
+
+    if (static_type_flags.AllSet(eTypeIsSwift | eTypeIsPointer) &&
+        static_type_flags.AllClear(eTypeIsArchetype)) {
+      if (is_indirect_enum_case || static_type_flags.AllClear(eTypeIsBuiltIn))
+        return Value::eValueTypeLoadAddress;
+    }
+  }
+
+  if (static_type_flags.AllSet(eTypeIsSwift) &&
+      dynamic_type_flags.AllSet(eTypeIsSwift) &&
+      dynamic_type_flags.AllClear(eTypeIsPointer | eTypeInstanceIsPointer))
+    return static_value_type;
+  else
+    return Value::eValueTypeScalar;
+}
+
+static bool IsIndirectEnumCase(ValueObject &valobj) {
+  return (valobj.GetLanguageFlags() &
+          SwiftASTContext::LanguageFlags::eIsIndirectEnumCase) ==
+         SwiftASTContext::LanguageFlags::eIsIndirectEnumCase;
+}
+
+bool SwiftLanguageRuntime::GetDynamicTypeAndAddress(
+    ValueObject &in_value, lldb::DynamicValueType use_dynamic,
+    TypeAndOrName &class_type_or_name, Address &address,
+    Value::ValueType &value_type) {
+  class_type_or_name.Clear();
+
+  if (SwiftASTContext *swift_ast = llvm::dyn_cast_or_null<SwiftASTContext>(
+          in_value.GetCompilerType().GetTypeSystem())) {
+    if (swift_ast->HasFatalErrors() || !swift_ast->GetClangImporter()) {
+      return false;
+    }
+  } else {
+    return false;
+  }
+
+  if (use_dynamic == lldb::eNoDynamicValues || !CouldHaveDynamicValue(in_value))
+    return false;
+
+  bool success = false;
+  const bool is_indirect_enum_case = IsIndirectEnumCase(in_value);
+
+  if (is_indirect_enum_case)
+    success = GetDynamicTypeAndAddress_IndirectEnumCase(
+        in_value, use_dynamic, class_type_or_name, address);
+  else {
+    CompilerType var_type(in_value.GetCompilerType());
+    Flags type_info(var_type.GetTypeInfo());
+    if (type_info.AnySet(eTypeIsSwift)) {
+      if (type_info.AnySet(eTypeIsClass))
+        success = GetDynamicTypeAndAddress_Class(in_value, use_dynamic,
+                                                 class_type_or_name, address);
+      else if (type_info.AnySet(eTypeIsEnumeration))
+        success = GetDynamicTypeAndAddress_Enum(in_value, use_dynamic,
+                                                class_type_or_name, address);
+      else if (type_info.AnySet(eTypeIsProtocol))
+        success = GetDynamicTypeAndAddress_Protocol(
+            in_value, use_dynamic, class_type_or_name, address);
+      else if (type_info.AnySet(eTypeIsArchetype))
+        success = GetDynamicTypeAndAddress_Archetype(
+            in_value, use_dynamic, class_type_or_name, address);
+      else if (type_info.AnySet(eTypeIsTuple))
+        success = GetDynamicTypeAndAddress_Tuple(in_value, use_dynamic,
+                                                 class_type_or_name, address);
+      else if (type_info.AnySet(eTypeIsStructUnion))
+        success = GetDynamicTypeAndAddress_Struct(in_value, use_dynamic,
+                                                  class_type_or_name, address);
+      else if (type_info.AllSet(eTypeIsBuiltIn | eTypeIsPointer |
+                                eTypeHasValue))
+        success = GetDynamicTypeAndAddress_Class(in_value, use_dynamic,
+                                                 class_type_or_name, address);
+    }
+  }
+
+  if (success) {
+    value_type = GetValueType(
+        in_value.GetValue().GetValueType(), in_value.GetCompilerType(),
+        class_type_or_name.GetCompilerType(), is_indirect_enum_case);
+  }
+  return success;
+}
+
+TypeAndOrName
+SwiftLanguageRuntime::FixUpDynamicType(const TypeAndOrName &type_and_or_name,
+                                       ValueObject &static_value) {
+  TypeAndOrName ret(type_and_or_name);
+  bool should_be_made_into_ref = false;
+  bool should_be_made_into_ptr = false;
+  Flags type_flags(static_value.GetCompilerType().GetTypeInfo());
+  Flags type_andor_name_flags(type_and_or_name.GetCompilerType().GetTypeInfo());
+
+  // if the static type is a pointer or reference, so should the dynamic type
+  // caveat: if the static type is a Swift class instance, the dynamic type
+  // could either be a Swift type (no need to change anything), or an ObjC type
+  // in which case it needs to be made into a pointer
+  if (type_flags.AnySet(eTypeIsPointer))
+    should_be_made_into_ptr =
+        (type_flags.AllClear(eTypeIsArchetype | eTypeIsBuiltIn) &&
+         !IsIndirectEnumCase(static_value));
+  else if (type_flags.AnySet(eTypeInstanceIsPointer))
+    should_be_made_into_ptr = !type_andor_name_flags.AllSet(eTypeIsSwift);
+  else if (type_flags.AnySet(eTypeIsReference))
+    should_be_made_into_ref = true;
+  else if (type_flags.AllSet(eTypeIsSwift | eTypeIsProtocol))
+    should_be_made_into_ptr =
+        type_and_or_name.GetCompilerType().IsRuntimeGeneratedType() &&
+        !type_and_or_name.GetCompilerType().IsPointerType();
+
+  if (type_and_or_name.HasType()) {
+    // The type will always be the type of the dynamic object.  If our parent's
+    // type was a pointer,
+    // then our type should be a pointer to the type of the dynamic object.  If
+    // a reference, then the original type
+    // should be okay...
+    CompilerType orig_type = type_and_or_name.GetCompilerType();
+    CompilerType corrected_type = orig_type;
+    if (should_be_made_into_ptr)
+      corrected_type = orig_type.GetPointerType();
+    else if (should_be_made_into_ref)
+      corrected_type = orig_type.GetLValueReferenceType();
+    ret.SetCompilerType(corrected_type);
+  } else /*if (m_dynamic_type_info.HasName())*/
+  {
+    // If we are here we need to adjust our dynamic type name to include the
+    // correct & or * symbol
+    std::string corrected_name(type_and_or_name.GetName().GetCString());
+    if (should_be_made_into_ptr)
+      corrected_name.append(" *");
+    else if (should_be_made_into_ref)
+      corrected_name.append(" &");
+    // the parent type should be a correctly pointer'ed or referenc'ed type
+    ret.SetCompilerType(static_value.GetCompilerType());
+    ret.SetName(corrected_name.c_str());
+  }
+  return ret;
+}
+
+bool SwiftLanguageRuntime::IsRuntimeSupportValue(ValueObject &valobj) {
+  static llvm::StringRef g_dollar_swift_type("$swift.type.");
+  ConstString valobj_name(valobj.GetName());
+  llvm::StringRef valobj_name_sr(valobj_name.GetStringRef());
+  if (valobj_name_sr.startswith(g_dollar_swift_type))
+    return true;
+  static llvm::StringRef g_globalinit("globalinit_");
+  static ConstString g_builtin_word("Builtin.Word");
+  static ConstString g__argc("_argc");
+  static ConstString g__unsafeArgv("_unsafeArgv");
+  static ConstString g_dollar_error("$error");
+  static ConstString g_tmp_closure("$tmpClosure");
+
+  ConstString valobj_type_name(valobj.GetTypeName());
+  if (valobj_name_sr.startswith(g_globalinit) &&
+      valobj_type_name == g_builtin_word)
+    return true;
+  if (valobj_name == g__argc || valobj_name == g__unsafeArgv ||
+      valobj_name == g_dollar_error || valobj_name == g_tmp_closure)
+    return true;
+  return false;
+}
+
+bool SwiftLanguageRuntime::CouldHaveDynamicValue(ValueObject &in_value) {
+  // if (in_value.IsDynamic())
+  //    return false;
+  if (IsIndirectEnumCase(in_value))
+    return true;
+  CompilerType var_type(in_value.GetCompilerType());
+  Flags var_type_flags(var_type.GetTypeInfo());
+  if (var_type_flags.AllSet(eTypeIsSwift | eTypeInstanceIsPointer)) {
+    // Swift class instances are actually pointers, but base class instances
+    // are inlined at offset 0 in the class data. If we just let base classes
+    // be dynamic, it would cause an infinite recursion. So we would usually
+    // disable it
+    // But if the base class is a generic type we still need to bind it, and
+    // that is
+    // a good job for dynamic types to perform
+    if (in_value.IsBaseClass()) {
+      CompilerType base_type(in_value.GetCompilerType());
+      if (SwiftASTContext::IsFullyRealized(base_type))
+        return false;
+    }
+    return true;
+  }
+  return var_type.IsPossibleDynamicType(nullptr, false, false, true);
+}
+
+CompilerType
+SwiftLanguageRuntime::GetConcreteType(ExecutionContextScope *exe_scope,
+                                      ConstString abstract_type_name) {
+  if (!exe_scope)
+    return CompilerType();
+
+  StackFrame *frame(exe_scope->CalculateStackFrame().get());
+  if (!frame)
+    return CompilerType();
+
+  MetadataPromiseSP promise_sp(
+      GetPromiseForTypeNameAndFrame(abstract_type_name.GetCString(), frame));
+  if (!promise_sp)
+    return CompilerType();
+
+  return promise_sp->FulfillTypePromise();
+}
+
+namespace {
+
+enum class ThunkKind {
+  Unknown = 0,
+  AllocatingInit,
+  PartialApply,
+  ObjCAttribute,
+  Reabstraction,
+  ProtocolConformance,
+};
+
+enum class ThunkAction {
+  Unknown = 0,
+  GetThunkTarget,
+  StepIntoConformance,
+  StepThrough
+};
+
+} // namespace
+
+static ThunkKind GetThunkKind(llvm::StringRef symbol_name) {
+  swift::Demangle::Node::Kind kind;
+  swift::Demangle::Context demangle_ctx;
+  if (!demangle_ctx.isThunkSymbol(symbol_name))
+    return ThunkKind::Unknown;
+
+  swift::Demangle::NodePointer nodes =
+      demangle_ctx.demangleSymbolAsNode(symbol_name);
+  size_t num_global_children = nodes->getNumChildren();
+  if (num_global_children == 0)
+    return ThunkKind::Unknown;
+
+  if (nodes->getKind() != swift::Demangle::Node::Kind::Global)
+    return ThunkKind::Unknown;
+  if (nodes->getNumChildren() == 0)
+    return ThunkKind::Unknown;
+
+  swift::Demangle::NodePointer node_ptr = nodes->getFirstChild();
+  kind = node_ptr->getKind();
+  switch (kind) {
+  case swift::Demangle::Node::Kind::ObjCAttribute:
+    return ThunkKind::ObjCAttribute;
+    break;
+  case swift::Demangle::Node::Kind::ProtocolWitness:
+    if (node_ptr->getNumChildren() == 0)
+      return ThunkKind::Unknown;
+    if (node_ptr->getFirstChild()->getKind() ==
+        swift::Demangle::Node::Kind::ProtocolConformance)
+      return ThunkKind::ProtocolConformance;
+    break;
+  case swift::Demangle::Node::Kind::ReabstractionThunkHelper:
+    return ThunkKind::Reabstraction;
+  case swift::Demangle::Node::Kind::PartialApplyForwarder:
+    return ThunkKind::PartialApply;
+  case swift::Demangle::Node::Kind::Allocator:
+    if (node_ptr->getNumChildren() == 0)
+      return ThunkKind::Unknown;
+    if (node_ptr->getFirstChild()->getKind() ==
+        swift::Demangle::Node::Kind::Class)
+      return ThunkKind::AllocatingInit;
+  default:
+    break;
+  }
+
+  return ThunkKind::Unknown;
+}
+static const char *GetThunkKindName(ThunkKind kind) {
+  switch (kind) {
+  case ThunkKind::Unknown:
+    return "Unknown";
+  case ThunkKind::AllocatingInit:
+    return "StepThrough";
+  case ThunkKind::PartialApply:
+    return "GetThunkTarget";
+  case ThunkKind::ObjCAttribute:
+    return "GetThunkTarget";
+  case ThunkKind::Reabstraction:
+    return "GetThunkTarget";
+  case ThunkKind::ProtocolConformance:
+    return "StepIntoConformance";
+  }
+}
+
+static ThunkAction GetThunkAction(ThunkKind kind) {
+  switch (kind) {
+  case ThunkKind::Unknown:
+    return ThunkAction::Unknown;
+  case ThunkKind::AllocatingInit:
+    return ThunkAction::StepThrough;
+  case ThunkKind::PartialApply:
+    return ThunkAction::GetThunkTarget;
+  case ThunkKind::ObjCAttribute:
+    return ThunkAction::GetThunkTarget;
+  case ThunkKind::Reabstraction:
+    return ThunkAction::StepThrough;
+  case ThunkKind::ProtocolConformance:
+    return ThunkAction::StepIntoConformance;
+  }
+}
+
+bool SwiftLanguageRuntime::GetTargetOfPartialApply(SymbolContext &curr_sc,
+                                                   ConstString &apply_name,
+                                                   SymbolContext &sc) {
+  if (!curr_sc.module_sp)
+    return false;
+
+  SymbolContextList sc_list;
+  swift::Demangle::Context demangle_ctx;
+  // Make sure this is a partial apply:
+
+  std::string apply_target =
+      demangle_ctx.getThunkTarget(apply_name.GetStringRef());
+  if (!apply_target.empty()) {
+    size_t num_symbols = curr_sc.module_sp->FindFunctions(
+        ConstString(apply_target), NULL, eFunctionNameTypeFull, true, false,
+        false, sc_list);
+    if (num_symbols == 0)
+      return false;
+
+    CompileUnit *curr_cu = curr_sc.comp_unit;
+
+    size_t num_found = 0;
+    for (size_t i = 0; i < num_symbols; i++) {
+      SymbolContext tmp_sc;
+      if (sc_list.GetContextAtIndex(i, tmp_sc)) {
+        if (tmp_sc.comp_unit && curr_cu && tmp_sc.comp_unit == curr_cu) {
+          sc = tmp_sc;
+          num_found++;
+        } else if (curr_sc.module_sp == tmp_sc.module_sp) {
+          sc = tmp_sc;
+          num_found++;
+        }
+      }
+    }
+    if (num_found == 1)
+      return true;
+    else {
+      sc.Clear(false);
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+bool SwiftLanguageRuntime::IsSymbolARuntimeThunk(const Symbol &symbol) {
+
+  llvm::StringRef symbol_name =
+      symbol.GetMangled().GetMangledName().GetStringRef();
+  if (symbol_name.empty())
+    return false;
+
+  swift::Demangle::Context demangle_ctx;
+  return demangle_ctx.isThunkSymbol(symbol_name);
+}
+
+lldb::ThreadPlanSP
+SwiftLanguageRuntime::GetStepThroughTrampolinePlan(Thread &thread,
+                                                   bool stop_others) {
+  // Here are the trampolines we have at present.
+  // 1) The thunks from protocol invocations to the call in the actual object
+  // implementing the protocol.
+  // 2) Thunks for going from Swift ObjC classes to their actual method
+  // invocations
+  // 3) Thunks that retain captured objects in closure invocations.
+
+  ThreadPlanSP new_thread_plan_sp;
+
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
+  StackFrameSP stack_sp = thread.GetStackFrameAtIndex(0);
+  if (!stack_sp)
+    return new_thread_plan_sp;
+
+  SymbolContext sc = stack_sp->GetSymbolContext(eSymbolContextEverything);
+  Symbol *symbol = sc.symbol;
+
+  // Note, I don't really need to consult IsSymbolARuntimeThunk here, but it
+  // is fast to do and
+  // keeps this list and the one in IsSymbolARuntimeThunk in sync.
+  if (!symbol || !IsSymbolARuntimeThunk(*symbol))
+    return new_thread_plan_sp;
+
+  // Only do this if you are at the beginning of the thunk function:
+  lldb::addr_t cur_addr = thread.GetRegisterContext()->GetPC();
+  lldb::addr_t symbol_addr =
+      symbol->GetAddress().GetLoadAddress(&thread.GetProcess()->GetTarget());
+
+  if (symbol_addr != cur_addr)
+    return new_thread_plan_sp;
+
+  Address target_address;
+  ConstString symbol_mangled_name = symbol->GetMangled().GetMangledName();
+  const char *symbol_name = symbol_mangled_name.AsCString();
+
+  ThunkKind thunk_kind = GetThunkKind(symbol_mangled_name.GetStringRef());
+  ThunkAction thunk_action = GetThunkAction(thunk_kind);
+
+  switch (thunk_action) {
+  case ThunkAction::Unknown:
+    return new_thread_plan_sp;
+  case ThunkAction::GetThunkTarget: {
+    swift::Demangle::Context demangle_ctx;
+    std::string thunk_target = demangle_ctx.getThunkTarget(symbol_name);
+    if (thunk_target.empty()) {
+      if (log)
+        log->Printf("Stepped to thunk \"%s\" (kind: %s) but could not "
+                    "find the thunk target. ",
+                    symbol_name, GetThunkKindName(thunk_kind));
+      return new_thread_plan_sp;
+    }
+    if (log)
+      log->Printf(
+          "Stepped to thunk \"%s\" (kind: %s) stepping to target: \"%s\".",
+          symbol_name, GetThunkKindName(thunk_kind), thunk_target.c_str());
+
+    ModuleList modules = thread.GetProcess()->GetTarget().GetImages();
+    SymbolContextList sc_list;
+    modules.FindFunctionSymbols(ConstString(thunk_target),
+                                eFunctionNameTypeFull, sc_list);
+    if (sc_list.GetSize() == 1) {
+      SymbolContext sc;
+      sc_list.GetContextAtIndex(0, sc);
+
+      if (sc.symbol)
+        target_address = sc.symbol->GetAddress();
+    }
+  } break;
+  case ThunkAction::StepIntoConformance: {
+    // The TTW symbols encode the protocol conformance requirements and it
+    // is possible to go to
+    // the AST and get it to replay the logic that it used to determine
+    // what to dispatch to.
+    // But that ties us too closely to the logic of the compiler, and
+    // these thunks are quite
+    // simple, they just do a little retaining, and then call the correct
+    // function.
+    // So for simplicity's sake, I'm just going to get the base name of
+    // the function
+    // this protocol thunk is preparing to call, then step into through
+    // the thunk, stopping if I end up
+    // in a frame with that function name.
+
+    swift::Demangle::Context demangle_ctx;
+    swift::Demangle::NodePointer demangled_nodes =
+        demangle_ctx.demangleSymbolAsNode(symbol_mangled_name.GetStringRef());
+
+    // Now find the ProtocolWitness node in the demangled result.
+
+    swift::Demangle::NodePointer witness_node = demangled_nodes;
+    bool found_witness_node = false;
+    while (witness_node) {
+      if (witness_node->getKind() ==
+          swift::Demangle::Node::Kind::ProtocolWitness) {
+        found_witness_node = true;
+        break;
+      }
+      witness_node = witness_node->getFirstChild();
+    }
+    if (!found_witness_node) {
+      if (log)
+        log->Printf("Stepped into witness thunk \"%s\" but could not "
+                    "find the ProtocolWitness node in the demangled "
+                    "nodes.",
+                    symbol_name);
+      return new_thread_plan_sp;
+    }
+
+    size_t num_children = witness_node->getNumChildren();
+    if (num_children < 2) {
+      if (log)
+        log->Printf("Stepped into witness thunk \"%s\" but the "
+                    "ProtocolWitness node doesn't have enough nodes.",
+                    symbol_name);
+      return new_thread_plan_sp;
+    }
+
+    swift::Demangle::NodePointer function_node = witness_node->getChild(1);
+    if (function_node == nullptr ||
+        function_node->getKind() != swift::Demangle::Node::Kind::Function) {
+      if (log)
+        log->Printf("Stepped into witness thunk \"%s\" but could not "
+                    "find the function in the ProtocolWitness node.",
+                    symbol_name);
+      return new_thread_plan_sp;
+    }
+
+    // Okay, now find the name of this function.
+    num_children = function_node->getNumChildren();
+    swift::Demangle::NodePointer name_node(nullptr);
+    for (size_t i = 0; i < num_children; i++) {
+      if (function_node->getChild(i)->getKind() ==
+          swift::Demangle::Node::Kind::Identifier) {
+        name_node = function_node->getChild(i);
+        break;
+      }
+    }
+
+    if (!name_node) {
+      if (log)
+        log->Printf("Stepped into witness thunk \"%s\" but could not "
+                    "find the Function name in the function node.",
+                    symbol_name);
+      return new_thread_plan_sp;
+    }
+
+    std::string function_name(name_node->getText());
+    if (function_name.empty()) {
+      if (log)
+        log->Printf("Stepped into witness thunk \"%s\" but the Function "
+                    "name was empty.",
+                    symbol_name);
+      return new_thread_plan_sp;
+    }
+
+    // We have to get the address range of the thunk symbol, and make a
+    // "step through range stepping in"
+    AddressRange sym_addr_range(sc.symbol->GetAddress(),
+                                sc.symbol->GetByteSize());
+    new_thread_plan_sp.reset(new ThreadPlanStepInRange(
+        thread, sym_addr_range, sc, function_name.c_str(), eOnlyDuringStepping,
+        eLazyBoolNo, eLazyBoolNo));
+    return new_thread_plan_sp;
+
+  } break;
+  case ThunkAction::StepThrough: {
+    if (log)
+      log->Printf("Stepping through thunk: %s kind: %s", symbol_name,
+                  GetThunkKindName(thunk_kind));
+    AddressRange sym_addr_range(sc.symbol->GetAddress(),
+                                sc.symbol->GetByteSize());
+    new_thread_plan_sp.reset(new ThreadPlanStepInRange(
+        thread, sym_addr_range, sc, nullptr, eOnlyDuringStepping, eLazyBoolNo,
+        eLazyBoolNo));
+    return new_thread_plan_sp;
+  } break;
+  }
+
+  if (target_address.IsValid()) {
+    new_thread_plan_sp.reset(
+        new ThreadPlanRunToAddress(thread, target_address, stop_others));
+  }
+
+  return new_thread_plan_sp;
+}
+
+void SwiftLanguageRuntime::FindFunctionPointersInCall(
+    StackFrame &frame, std::vector<Address> &addresses, bool debug_only,
+    bool resolve_thunks) {
+  // Extract the mangled name from the stack frame, and realize the function
+  // type in the Target's SwiftASTContext.
+  // Then walk the arguments looking for function pointers.  If we find one in
+  // the FIRST argument, we can fetch
+  // the pointer value and return that.
+  // FIXME: when we can ask swift/llvm for the location of function arguments,
+  // then we can do this for all the
+  // function pointer arguments we find.
+
+  SymbolContext sc = frame.GetSymbolContext(eSymbolContextSymbol);
+  if (sc.symbol) {
+    Mangled mangled_name = sc.symbol->GetMangled();
+    if (mangled_name.GuessLanguage() == lldb::eLanguageTypeSwift) {
+      Status error;
+      Target &target = frame.GetThread()->GetProcess()->GetTarget();
+      SwiftASTContext *swift_ast = target.GetScratchSwiftASTContext(error);
+      if (swift_ast) {
+        CompilerType function_type = swift_ast->GetTypeFromMangledTypename(
+            mangled_name.GetMangledName().AsCString(), error);
+        if (error.Success()) {
+          if (function_type.IsFunctionType()) {
+            // FIXME: For now we only check the first argument since we don't
+            // know how to find the values
+            // of arguments further in the argument list.
+            // int num_arguments = function_type.GetFunctionArgumentCount();
+            // for (int i = 0; i < num_arguments; i++)
+
+            for (int i = 0; i < 1; i++) {
+              CompilerType argument_type =
+                  function_type.GetFunctionArgumentTypeAtIndex(i);
+              if (argument_type.IsFunctionPointerType()) {
+                // We found a function pointer argument.  Try to track down its
+                // value.  This is a hack
+                // for now, we really should ask swift/llvm how to find the
+                // argument(s) given the
+                // Swift decl for this function, and then look those up in the
+                // frame.
+
+                ABISP abi_sp(frame.GetThread()->GetProcess()->GetABI());
+                ValueList argument_values;
+                Value input_value;
+                CompilerType clang_void_ptr_type =
+                    target.GetScratchClangASTContext()
+                        ->GetBasicType(eBasicTypeVoid)
+                        .GetPointerType();
+
+                input_value.SetValueType(Value::eValueTypeScalar);
+                input_value.SetCompilerType(clang_void_ptr_type);
+                argument_values.PushValue(input_value);
+
+                bool success = abi_sp->GetArgumentValues(
+                    *(frame.GetThread().get()), argument_values);
+                if (success) {
+                  // Now get a pointer value from the zeroth argument.
+                  Status error;
+                  DataExtractor data;
+                  ExecutionContext exe_ctx;
+                  frame.CalculateExecutionContext(exe_ctx);
+                  error = argument_values.GetValueAtIndex(0)->GetValueAsData(
+                      &exe_ctx, data, 0, NULL);
+                  lldb::offset_t offset = 0;
+                  lldb::addr_t fn_ptr_addr = data.GetPointer(&offset);
+                  Address fn_ptr_address;
+                  fn_ptr_address.SetLoadAddress(fn_ptr_addr, &target);
+                  // Now check to see if this has debug info:
+                  bool add_it = true;
+
+                  if (resolve_thunks) {
+                    SymbolContext sc;
+                    fn_ptr_address.CalculateSymbolContext(
+                        &sc, eSymbolContextEverything);
+                    if (sc.comp_unit && sc.symbol) {
+                      ConstString symbol_name =
+                          sc.symbol->GetMangled().GetMangledName();
+                      if (symbol_name) {
+                        SymbolContext target_context;
+                        if (GetTargetOfPartialApply(sc, symbol_name,
+                                                    target_context)) {
+                          if (target_context.symbol)
+                            fn_ptr_address =
+                                target_context.symbol->GetAddress();
+                          else if (target_context.function)
+                            fn_ptr_address =
+                                target_context.function->GetAddressRange()
+                                    .GetBaseAddress();
+                        }
+                      }
+                    }
+                  }
+
+                  if (debug_only) {
+                    LineEntry line_entry;
+                    fn_ptr_address.CalculateSymbolContextLineEntry(line_entry);
+                    if (!line_entry.IsValid())
+                      add_it = false;
+                  }
+                  if (add_it)
+                    addresses.push_back(fn_ptr_address);
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+//------------------------------------------------------------------
+// Exception breakpoint Precondition class for Swift:
+//------------------------------------------------------------------
+void SwiftLanguageRuntime::SwiftExceptionPrecondition::AddTypeName(
+    const char *class_name) {
+  m_type_names.insert(class_name);
+}
+
+void SwiftLanguageRuntime::SwiftExceptionPrecondition::AddEnumSpec(
+    const char *enum_name, const char *element_name) {
+  std::unordered_map<std::string, std::vector<std::string>>::value_type
+      new_value(enum_name, std::vector<std::string>());
+  auto result = m_enum_spec.emplace(new_value);
+  result.first->second.push_back(element_name);
+}
+
+SwiftLanguageRuntime::SwiftExceptionPrecondition::SwiftExceptionPrecondition() {
+}
+
+ValueObjectSP SwiftLanguageRuntime::CalculateErrorValueObjectFromValue(
+    Value &value, ConstString name, bool persistent) {
+  ValueObjectSP error_valobj_sp;
+  Status error;
+  SwiftASTContext *ast_context =
+      m_process->GetTarget().GetScratchSwiftASTContext(error);
+  if (!ast_context || error.Fail())
+    return error_valobj_sp;
+
+  CompilerType swift_error_proto_type = ast_context->GetErrorType();
+  value.SetCompilerType(swift_error_proto_type);
+
+  error_valobj_sp = ValueObjectConstResult::Create(m_process, value, name);
+
+  if (error_valobj_sp && error_valobj_sp->GetError().Success()) {
+    error_valobj_sp = error_valobj_sp->GetQualifiedRepresentationIfAvailable(
+        lldb::eDynamicCanRunTarget, true);
+    if (!IsValidErrorValue(*(error_valobj_sp.get()))) {
+      error_valobj_sp.reset();
+    }
+  }
+
+  if (persistent && error_valobj_sp) {
+    PersistentExpressionState *persistent_state =
+        m_process->GetTarget().GetPersistentExpressionStateForLanguage(
+            eLanguageTypeSwift);
+
+    ConstString persistent_variable_name(
+        persistent_state->GetNextPersistentVariableName(true));
+
+    lldb::ValueObjectSP const_valobj_sp;
+
+    // Check in case our value is already a constant value
+    if (error_valobj_sp->GetIsConstant()) {
+      const_valobj_sp = error_valobj_sp;
+      const_valobj_sp->SetName(persistent_variable_name);
+    } else
+      const_valobj_sp =
+          error_valobj_sp->CreateConstantValue(persistent_variable_name);
+
+    lldb::ValueObjectSP live_valobj_sp = error_valobj_sp;
+
+    error_valobj_sp = const_valobj_sp;
+
+    ExpressionVariableSP clang_expr_variable_sp(
+        persistent_state->CreatePersistentVariable(error_valobj_sp));
+    clang_expr_variable_sp->m_live_sp = live_valobj_sp;
+    clang_expr_variable_sp->m_flags |=
+        ClangExpressionVariable::EVIsProgramReference;
+
+    error_valobj_sp = clang_expr_variable_sp->GetValueObject();
+  }
+  return error_valobj_sp;
+}
+
+ValueObjectSP SwiftLanguageRuntime::CalculateErrorValueFromFirstArgument(
+    StackFrameSP frame_sp, ConstString variable_name) {
+  ProcessSP process_sp(frame_sp->GetThread()->GetProcess());
+  ABISP abi_sp(process_sp->GetABI());
+  ValueList argument_values;
+  Value input_value;
+  Status error;
+  Target *target = frame_sp->CalculateTarget().get();
+  ValueObjectSP error_valobj_sp;
+
+  ClangASTContext *clang_ast_context = target->GetScratchClangASTContext();
+  CompilerType clang_void_ptr_type =
+      clang_ast_context->GetBasicType(eBasicTypeVoid).GetPointerType();
+
+  input_value.SetValueType(Value::eValueTypeScalar);
+  input_value.SetCompilerType(clang_void_ptr_type);
+  argument_values.PushValue(input_value);
+
+  bool success = abi_sp->GetArgumentValues(*(frame_sp->GetThread().get()),
+                                           argument_values);
+  if (success) {
+    ExecutionContext exe_ctx;
+    frame_sp->CalculateExecutionContext(exe_ctx);
+    DataExtractor data;
+
+    SwiftASTContext *ast_context = target->GetScratchSwiftASTContext(error);
+    if (!ast_context || error.Fail())
+      return error_valobj_sp;
+
+    CompilerType swift_error_proto_type = ast_context->GetErrorType();
+    if (swift_error_proto_type.IsValid()) {
+      Value *arg0 = argument_values.GetValueAtIndex(0);
+      Status extract_error = arg0->GetValueAsData(&exe_ctx, data, 0, nullptr);
+      if (extract_error.Success()) {
+        error_valobj_sp = ValueObjectConstResult::Create(
+            frame_sp.get(), swift_error_proto_type, variable_name, data);
+        if (error_valobj_sp->GetError().Fail()) {
+          // If we couldn't make the error ValueObject, then we will always
+          // stop.
+          // FIXME: Some logging here would be good.
+          return error_valobj_sp;
+        }
+
+        error_valobj_sp =
+            error_valobj_sp->GetQualifiedRepresentationIfAvailable(
+                lldb::eDynamicCanRunTarget, true);
+      }
+    }
+  }
+  return error_valobj_sp;
+}
+
+void SwiftLanguageRuntime::RegisterGlobalError(Target &target, ConstString name,
+                                               lldb::addr_t addr) {
+  Status ast_context_error;
+  SwiftASTContext *ast_context =
+      target.GetScratchSwiftASTContext(ast_context_error);
+
+  if (ast_context_error.Success() && ast_context &&
+      !ast_context->HasFatalErrors()) {
+    SwiftPersistentExpressionState *persistent_state =
+        llvm::cast<SwiftPersistentExpressionState>(
+            target.GetPersistentExpressionStateForLanguage(
+                lldb::eLanguageTypeSwift));
+
+    std::string module_name = "$__lldb_module_for_";
+    module_name.append(&name.GetCString()[1]);
+
+    Status module_creation_error;
+    swift::ModuleDecl *module_decl = ast_context->CreateModule(
+        ConstString(module_name), module_creation_error);
+
+    if (module_creation_error.Success() && module_decl) {
+      const bool is_static = false;
+      const auto specifier = swift::VarDecl::Specifier::Let;
+      const bool is_capture_list = false;
+
+      swift::VarDecl *var_decl =
+          new (*ast_context->GetASTContext()) swift::VarDecl(
+              is_static, specifier, is_capture_list, swift::SourceLoc(),
+              ast_context->GetIdentifier(name.GetCString()),
+              GetSwiftType(ast_context->GetErrorType()), module_decl);
+      var_decl->setInterfaceType(var_decl->getType());
+      var_decl->setDebuggerVar(true);
+
+      persistent_state->RegisterSwiftPersistentDecl(var_decl);
+
+      ConstString mangled_name;
+
+      {
+        swift::Mangle::ASTMangler mangler(true);
+        mangled_name = ConstString(mangler.mangleGlobalVariableFull(var_decl));
+      }
+
+      lldb::addr_t symbol_addr;
+
+      {
+        ProcessSP process_sp(target.GetProcessSP());
+        Status alloc_error;
+
+        symbol_addr = process_sp->AllocateMemory(
+            process_sp->GetAddressByteSize(),
+            lldb::ePermissionsWritable | lldb::ePermissionsReadable,
+            alloc_error);
+
+        if (alloc_error.Success() && symbol_addr != LLDB_INVALID_ADDRESS) {
+          Status write_error;
+          process_sp->WritePointerToMemory(symbol_addr, addr, write_error);
+
+          if (write_error.Success()) {
+            persistent_state->RegisterSymbol(mangled_name, symbol_addr);
+          }
+        }
+      }
+    }
+  }
+}
+
+bool SwiftLanguageRuntime::SwiftExceptionPrecondition::EvaluatePrecondition(
+    StoppointCallbackContext &context) {
+  if (!m_type_names.empty()) {
+    StackFrameSP frame_sp = context.exe_ctx_ref.GetFrameSP();
+    if (!frame_sp)
+      return true;
+
+    ValueObjectSP error_valobj_sp = CalculateErrorValueFromFirstArgument(
+        frame_sp, ConstString("__swift_error_var"));
+    if (!error_valobj_sp || error_valobj_sp->GetError().Fail())
+      return true;
+
+    // This shouldn't fail, since at worst it will return me the object I just
+    // successfully got.
+    std::string full_error_name(
+        error_valobj_sp->GetCompilerType().GetTypeName().AsCString());
+    size_t last_dot_pos = full_error_name.rfind('.');
+    std::string type_name_base;
+    if (last_dot_pos == std::string::npos)
+      type_name_base = full_error_name;
+    else {
+      if (last_dot_pos + 1 <= full_error_name.size())
+        type_name_base =
+            full_error_name.substr(last_dot_pos + 1, full_error_name.size());
+    }
+
+    // The type name will be the module and then the type.  If the match name
+    // has a dot, we require a complete
+    // match against the type, if the type name has no dot, we match it against
+    // the base.
+
+    for (std::string name : m_type_names) {
+      if (name.rfind('.') != std::string::npos) {
+        if (name == full_error_name)
+          return true;
+      } else {
+        if (name == type_name_base)
+          return true;
+      }
+    }
+    return false;
+  }
+  return true;
+}
+
+void SwiftLanguageRuntime::SwiftExceptionPrecondition::GetDescription(
+    Stream &stream, lldb::DescriptionLevel level) {
+  if (level == eDescriptionLevelFull || level == eDescriptionLevelVerbose) {
+    if (m_type_names.size() > 0) {
+      stream.Printf("\nType Filters:");
+      for (std::string name : m_type_names) {
+        stream.Printf(" %s", name.c_str());
+      }
+      stream.Printf("\n");
+    }
+  }
+}
+
+Status SwiftLanguageRuntime::SwiftExceptionPrecondition::ConfigurePrecondition(
+    Args &args) {
+  Status error;
+  std::vector<std::string> object_typenames;
+  args.GetOptionValuesAsStrings("exception-typename", object_typenames);
+  for (auto type_name : object_typenames)
+    AddTypeName(type_name.c_str());
+  return error;
+}
+
+void SwiftLanguageRuntime::AddToLibraryNegativeCache(const char *library_name) {
+  std::lock_guard<std::mutex> locker(m_negative_cache_mutex);
+  m_library_negative_cache.insert(library_name);
+}
+
+bool SwiftLanguageRuntime::IsInLibraryNegativeCache(const char *library_name) {
+  std::lock_guard<std::mutex> locker(m_negative_cache_mutex);
+  return m_library_negative_cache.count(library_name) == 1;
+}
+
+lldb::addr_t
+SwiftLanguageRuntime::MaskMaybeBridgedPointer(lldb::addr_t addr,
+                                              lldb::addr_t *masked_bits) {
+  if (!m_process)
+    return addr;
+  const ArchSpec &arch_spec(m_process->GetTarget().GetArchitecture());
+  ArchSpec::Core core_kind = arch_spec.GetCore();
+  bool is_arm = false;
+  bool is_intel = false;
+  bool is_32 = false;
+  bool is_64 = false;
+  if (core_kind == ArchSpec::Core::eCore_arm_arm64) {
+    is_arm = is_64 = true;
+  } else if (core_kind >= ArchSpec::Core::kCore_arm_first &&
+             core_kind <= ArchSpec::Core::kCore_arm_last) {
+    is_arm = true;
+  } else if (core_kind >= ArchSpec::Core::kCore_x86_64_first &&
+             core_kind <= ArchSpec::Core::kCore_x86_64_last) {
+    is_intel = true;
+  } else if (core_kind >= ArchSpec::Core::kCore_x86_32_first &&
+             core_kind <= ArchSpec::Core::kCore_x86_32_last) {
+    is_intel = true;
+  } else {
+    // this is a really random CPU core to be running on - just get out fast
+    return addr;
+  }
+
+  switch (arch_spec.GetAddressByteSize()) {
+  case 4:
+    is_32 = true;
+    break;
+  case 8:
+    is_64 = true;
+    break;
+  default:
+    // this is a really random pointer size to be running on - just get out fast
+    return addr;
+  }
+
+  lldb::addr_t mask = 0;
+
+  if (is_arm && is_64)
+    mask = SWIFT_ABI_ARM64_SWIFT_SPARE_BITS_MASK;
+
+  if (is_arm && is_32)
+    mask = SWIFT_ABI_ARM_SWIFT_SPARE_BITS_MASK;
+
+  if (is_intel && is_64)
+    mask = SWIFT_ABI_X86_64_SWIFT_SPARE_BITS_MASK;
+
+  if (is_intel && is_32)
+    mask = SWIFT_ABI_I386_SWIFT_SPARE_BITS_MASK;
+
+  if (masked_bits)
+    *masked_bits = addr & mask;
+  return addr & ~mask;
+}
+
+lldb::addr_t SwiftLanguageRuntime::MaybeMaskNonTrivialReferencePointer(
+    lldb::addr_t addr,
+    SwiftASTContext::NonTriviallyManagedReferenceStrategy strategy) {
+
+  if (addr == 0)
+    return addr;
+
+  AppleObjCRuntime *objc_runtime = GetObjCRuntime();
+
+  if (objc_runtime) {
+    // tagged pointers don't perform any masking
+    if (objc_runtime->IsTaggedPointer(addr))
+      return addr;
+  }
+
+  if (!m_process)
+    return addr;
+  const ArchSpec &arch_spec(m_process->GetTarget().GetArchitecture());
+  ArchSpec::Core core_kind = arch_spec.GetCore();
+  bool is_arm = false;
+  bool is_intel = false;
+  bool is_32 = false;
+  bool is_64 = false;
+  if (core_kind == ArchSpec::Core::eCore_arm_arm64) {
+    is_arm = is_64 = true;
+  } else if (core_kind >= ArchSpec::Core::kCore_arm_first &&
+             core_kind <= ArchSpec::Core::kCore_arm_last) {
+    is_arm = true;
+  } else if (core_kind >= ArchSpec::Core::kCore_x86_64_first &&
+             core_kind <= ArchSpec::Core::kCore_x86_64_last) {
+    is_intel = true;
+  } else if (core_kind >= ArchSpec::Core::kCore_x86_32_first &&
+             core_kind <= ArchSpec::Core::kCore_x86_32_last) {
+    is_intel = true;
+  } else {
+    // this is a really random CPU core to be running on - just get out fast
+    return addr;
+  }
+
+  switch (arch_spec.GetAddressByteSize()) {
+  case 4:
+    is_32 = true;
+    break;
+  case 8:
+    is_64 = true;
+    break;
+  default:
+    // this is a really random pointer size to be running on - just get out fast
+    return addr;
+  }
+
+  lldb::addr_t mask = 0;
+
+  if (strategy ==
+      SwiftASTContext::NonTriviallyManagedReferenceStrategy::eWeak) {
+    bool is_indirect = true;
+
+    // On non-objc platforms, the weak reference pointer always pointed to a
+    // runtime structure.
+    // For ObjC platforms, the masked value determines whether it is indirect.
+
+    uint32_t value = 0;
+
+    if (objc_runtime) {
+
+      if (is_intel) {
+        if (is_64) {
+          mask = SWIFT_ABI_X86_64_OBJC_WEAK_REFERENCE_MARKER_MASK;
+          value = SWIFT_ABI_X86_64_OBJC_WEAK_REFERENCE_MARKER_VALUE;
+        } else {
+          mask = SWIFT_ABI_I386_OBJC_WEAK_REFERENCE_MARKER_MASK;
+          value = SWIFT_ABI_I386_OBJC_WEAK_REFERENCE_MARKER_VALUE;
+        }
+      } else if (is_arm) {
+        if (is_64) {
+          mask = SWIFT_ABI_ARM64_OBJC_WEAK_REFERENCE_MARKER_MASK;
+          value = SWIFT_ABI_ARM64_OBJC_WEAK_REFERENCE_MARKER_VALUE;
+        } else {
+          mask = SWIFT_ABI_ARM_OBJC_WEAK_REFERENCE_MARKER_MASK;
+          value = SWIFT_ABI_ARM_OBJC_WEAK_REFERENCE_MARKER_VALUE;
+        }
+      }
+    } else {
+      // This name is a little confusing. The "DEFAULT" marking in System.h
+      // is supposed to mean: the value for non-ObjC platforms.  So
+      // DEFAULT_OBJC here actually means "non-ObjC".
+      mask = SWIFT_ABI_DEFAULT_OBJC_WEAK_REFERENCE_MARKER_MASK;
+      value = SWIFT_ABI_DEFAULT_OBJC_WEAK_REFERENCE_MARKER_VALUE;
+    }
+
+    is_indirect = ((addr & mask) == value);
+
+    if (!is_indirect)
+      return addr;
+
+    // The masked value of address is a pointer to the runtime structure.
+    // The first field of the structure is the actual pointer.
+    Process *process = GetProcess();
+    Status error;
+
+    lldb::addr_t masked_addr = addr & ~mask;
+    lldb::addr_t isa_addr = process->ReadPointerFromMemory(masked_addr, error);
+    if (error.Fail()) {
+      // FIXME: do some logging here.
+      return addr;
+    }
+    return isa_addr;
+
+  } else {
+    if (is_arm && is_64)
+      mask = SWIFT_ABI_ARM64_OBJC_NUM_RESERVED_LOW_BITS;
+    else if (is_intel && is_64)
+      mask = SWIFT_ABI_X86_64_OBJC_NUM_RESERVED_LOW_BITS;
+    else
+      mask = SWIFT_ABI_DEFAULT_OBJC_NUM_RESERVED_LOW_BITS;
+
+    mask = (1 << mask) | (1 << (mask + 1));
+
+    return addr & ~mask;
+  }
+
+  return addr;
+}
+
+ConstString SwiftLanguageRuntime::GetErrorBackstopName() {
+  return ConstString("swift_errorInMain");
+}
+
+ConstString SwiftLanguageRuntime::GetStandardLibraryBaseName() {
+  static ConstString g_swiftCore("swiftCore");
+  return g_swiftCore;
+}
+
+ConstString SwiftLanguageRuntime::GetStandardLibraryName() {
+  PlatformSP platform_sp(m_process->GetTarget().GetPlatform());
+  if (platform_sp)
+    return platform_sp->GetFullNameForDylib(GetStandardLibraryBaseName());
+  return GetStandardLibraryBaseName();
+}
+
+bool SwiftLanguageRuntime::GetReferenceCounts(ValueObject &valobj,
+                                              size_t &strong, size_t &weak) {
+  CompilerType compiler_type(valobj.GetCompilerType());
+  Flags type_flags(compiler_type.GetTypeInfo());
+  if (llvm::isa<SwiftASTContext>(compiler_type.GetTypeSystem()) &&
+      type_flags.AllSet(eTypeInstanceIsPointer)) {
+    lldb::addr_t ptr_value = valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS);
+    if (ptr_value == LLDB_INVALID_ADDRESS)
+      return false;
+    ptr_value += GetProcess()->GetAddressByteSize();
+    Status error;
+    strong =
+        GetProcess()->ReadUnsignedIntegerFromMemory(ptr_value, 4, 0, error) >>
+        2;
+    if (error.Fail())
+      return false;
+    weak = GetProcess()->ReadUnsignedIntegerFromMemory(ptr_value + 4, 4, 0,
+                                                       error) >>
+           2;
+    if (error.Fail())
+      return false;
+    return true;
+  }
+  return false;
+}
+
+class ProjectionSyntheticChildren : public SyntheticChildren {
+public:
+  struct FieldProjection {
+    ConstString name;
+    CompilerType type;
+    int32_t byte_offset;
+
+    FieldProjection(CompilerType parent_type, ExecutionContext *exe_ctx,
+                    size_t idx) {
+      const bool transparent_pointers = false;
+      const bool omit_empty_base_classes = true;
+      const bool ignore_array_bounds = false;
+      bool child_is_base_class = false;
+      bool child_is_deref_of_parent = false;
+      std::string child_name;
+
+      uint32_t child_byte_size;
+      uint32_t child_bitfield_bit_size;
+      uint32_t child_bitfield_bit_offset;
+      uint64_t language_flags;
+
+      type = parent_type.GetChildCompilerTypeAtIndex(
+          exe_ctx, idx, transparent_pointers, omit_empty_base_classes,
+          ignore_array_bounds, child_name, child_byte_size, byte_offset,
+          child_bitfield_bit_size, child_bitfield_bit_offset,
+          child_is_base_class, child_is_deref_of_parent, nullptr,
+          language_flags);
+
+      if (child_is_base_class)
+        type.Clear(); // invalidate - base classes are dealt with outside of the
+                      // projection
+      else
+        name.SetCStringWithLength(child_name.c_str(), child_name.size());
+    }
+
+    bool IsValid() { return !name.IsEmpty() && type.IsValid(); }
+
+    explicit operator bool() { return IsValid(); }
+  };
+
+  struct TypeProjection {
+    std::vector<FieldProjection> field_projections;
+    ConstString type_name;
+  };
+
+  typedef std::unique_ptr<TypeProjection> TypeProjectionUP;
+
+  bool IsScripted() { return false; }
+
+  std::string GetDescription() { return "projection synthetic children"; }
+
+  ProjectionSyntheticChildren(const Flags &flags, TypeProjectionUP &&projection)
+      : SyntheticChildren(flags), m_projection(std::move(projection)) {}
+
+protected:
+  TypeProjectionUP m_projection;
+
+  class ProjectionFrontEndProvider : public SyntheticChildrenFrontEnd {
+  public:
+    ProjectionFrontEndProvider(ValueObject &backend,
+                               TypeProjectionUP &projection)
+        : SyntheticChildrenFrontEnd(backend), m_num_bases(0),
+          m_projection(projection.get()) {
+      lldbassert(m_projection && "need a valid projection");
+      CompilerType type(backend.GetCompilerType());
+      m_num_bases = type.GetNumDirectBaseClasses();
+    }
+
+    size_t CalculateNumChildren() override {
+      return m_projection->field_projections.size() + m_num_bases;
+    }
+
+    lldb::ValueObjectSP GetChildAtIndex(size_t idx) override {
+      if (idx < m_num_bases) {
+        if (ValueObjectSP base_object_sp =
+                m_backend.GetChildAtIndex(idx, true)) {
+          CompilerType base_type(base_object_sp->GetCompilerType());
+          ConstString base_type_name(base_type.GetTypeName());
+          if (base_type_name.IsEmpty() ||
+              !SwiftLanguageRuntime::IsSwiftClassName(
+                  base_type_name.GetCString()))
+            return base_object_sp;
+          base_object_sp = m_backend.GetSyntheticBase(
+              0, base_type, true,
+              Mangled(base_type_name, true)
+                  .GetDemangledName(lldb::eLanguageTypeSwift));
+          return base_object_sp;
+        } else
+          return nullptr;
+      }
+      idx -= m_num_bases;
+      if (idx < m_projection->field_projections.size()) {
+        auto &projection(m_projection->field_projections.at(idx));
+        return m_backend.GetSyntheticChildAtOffset(
+            projection.byte_offset, projection.type, true, projection.name);
+      }
+      return nullptr;
+    }
+
+    size_t GetIndexOfChildWithName(const ConstString &name) override {
+      for (size_t idx = 0; idx < m_projection->field_projections.size();
+           idx++) {
+        if (m_projection->field_projections.at(idx).name == name)
+          return idx;
+      }
+      return UINT32_MAX;
+    }
+
+    bool Update() override { return false; }
+
+    bool MightHaveChildren() override { return true; }
+
+    ConstString GetSyntheticTypeName() override {
+      return m_projection->type_name;
+    }
+
+  private:
+    size_t m_num_bases;
+    TypeProjectionUP::element_type *m_projection;
+  };
+
+public:
+  SyntheticChildrenFrontEnd::AutoPointer GetFrontEnd(ValueObject &backend) {
+    return SyntheticChildrenFrontEnd::AutoPointer(
+        new ProjectionFrontEndProvider(backend, m_projection));
+  }
+};
+
+lldb::SyntheticChildrenSP
+SwiftLanguageRuntime::GetBridgedSyntheticChildProvider(ValueObject &valobj) {
+  const char *type_name(valobj.GetCompilerType().GetTypeName().AsCString());
+
+  if (type_name && *type_name) {
+    auto iter = m_bridged_synthetics_map.find(type_name),
+         end = m_bridged_synthetics_map.end();
+    if (iter != end)
+      return iter->second;
+  }
+
+  ProjectionSyntheticChildren::TypeProjectionUP type_projection(
+      new ProjectionSyntheticChildren::TypeProjectionUP::element_type());
+
+  if (SwiftASTContext *swift_ast_ctx = GetScratchSwiftASTContext()) {
+    Status error;
+    CompilerType swift_type =
+        swift_ast_ctx->GetTypeFromMangledTypename(type_name, error);
+
+    if (swift_type.IsValid()) {
+      ExecutionContext exe_ctx(GetProcess());
+      bool any_projected = false;
+      for (size_t idx = 0; idx < swift_type.GetNumChildren(true); idx++) {
+        // if a projection fails, keep going - we have offsets here, so it
+        // should be OK to skip some members
+        if (auto projection = ProjectionSyntheticChildren::FieldProjection(
+                swift_type, &exe_ctx, idx)) {
+          any_projected = true;
+          type_projection->field_projections.push_back(projection);
+        }
+      }
+
+      if (any_projected) {
+        type_projection->type_name = swift_type.GetDisplayTypeName();
+        SyntheticChildrenSP synth_sp =
+            SyntheticChildrenSP(new ProjectionSyntheticChildren(
+                SyntheticChildren::Flags(), std::move(type_projection)));
+        return (m_bridged_synthetics_map[type_name] = synth_sp);
+      }
+    }
+  }
+
+  return nullptr;
+}
+
+void SwiftLanguageRuntime::WillStartExecutingUserExpression() {
+  std::lock_guard<std::mutex> lock(m_active_user_expr_mutex);
+  Log *log(GetLogIfAnyCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  if (m_active_user_expr_count == 0 && m_dynamic_exclusivity_flag_addr) {
+    // We're executing the first user expression. Toggle the flag.
+    Status error;
+    TypeSystem *type_system =
+        m_process->GetTarget().GetScratchTypeSystemForLanguage(
+            &error, eLanguageTypeC_plus_plus);
+    if (error.Fail()) {
+      if (log)
+        log->Printf("SwiftLanguageRuntime: Unable to get pointer to type "
+                    "system: %s",
+                    error.AsCString());
+      return;
+    }
+    ConstString BoolName("bool");
+    size_t bool_size =
+        type_system->GetBuiltinTypeByName(BoolName).GetByteSize(nullptr);
+
+    Scalar original_value;
+    m_process->ReadScalarIntegerFromMemory(*m_dynamic_exclusivity_flag_addr,
+                                           bool_size, false, original_value,
+                                           error);
+
+    m_original_dynamic_exclusivity_flag_state = original_value.UInt() != 0;
+
+    if (error.Fail()) {
+      if (log)
+        log->Printf("SwiftLanguageRuntime: Unable to read "
+                    "disableExclusivityChecking flag state: %s",
+                    error.AsCString());
+    } else {
+      Scalar new_value(1U);
+      m_process->WriteScalarToMemory(*m_dynamic_exclusivity_flag_addr,
+                                     new_value, bool_size, error);
+      if (error.Fail()) {
+        if (log)
+          log->Printf("SwiftLanguageRuntime: Unable to set "
+                      "disableExclusivityChecking flag state: %s",
+                      error.AsCString());
+      } else {
+        if (log)
+          log->Printf("SwiftLanguageRuntime: Changed "
+                      "disableExclusivityChecking flag state from %u to 1",
+                      m_original_dynamic_exclusivity_flag_state);
+      }
+    }
+  }
+  ++m_active_user_expr_count;
+
+  if (log)
+    log->Printf("SwiftLanguageRuntime: starting user expression. "
+                "Number active: %u",
+                m_active_user_expr_count);
+}
+
+void SwiftLanguageRuntime::DidFinishExecutingUserExpression() {
+  std::lock_guard<std::mutex> lock(m_active_user_expr_mutex);
+  Log *log(GetLogIfAnyCategoriesSet(LIBLLDB_LOG_EXPRESSIONS));
+
+  --m_active_user_expr_count;
+  if (log)
+    log->Printf("SwiftLanguageRuntime: finished user expression. "
+                "Number active: %u",
+                m_active_user_expr_count);
+
+  if (m_active_user_expr_count == 0 && m_dynamic_exclusivity_flag_addr) {
+    Status error;
+    TypeSystem *type_system =
+        m_process->GetTarget().GetScratchTypeSystemForLanguage(
+            &error, eLanguageTypeC_plus_plus);
+    if (error.Fail()) {
+      if (log)
+        log->Printf("SwiftLanguageRuntime: Unable to get pointer to type "
+                    "system: %s",
+                    error.AsCString());
+      return;
+    }
+    ConstString BoolName("bool");
+    size_t bool_size =
+        type_system->GetBuiltinTypeByName(BoolName).GetByteSize(nullptr);
+
+    Scalar original_value(m_original_dynamic_exclusivity_flag_state ? 1U : 0U);
+    m_process->WriteScalarToMemory(*m_dynamic_exclusivity_flag_addr,
+                                   original_value, bool_size, error);
+    if (error.Fail()) {
+      if (log)
+        log->Printf("SwiftLanguageRuntime: Unable to reset "
+                    "disableExclusivityChecking flag state: %s",
+                    error.AsCString());
+    } else {
+      if (log)
+        log->Printf("SwiftLanguageRuntime: Changed "
+                    "disableExclusivityChecking flag state back to %u",
+                    m_original_dynamic_exclusivity_flag_state);
+    }
+  }
+}
+
+llvm::Optional<Value> SwiftLanguageRuntime::GetErrorReturnLocationAfterReturn(
+    lldb::StackFrameSP frame_sp) {
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
+  llvm::Optional<Value> error_val;
+
+  llvm::StringRef error_reg_name;
+  ArchSpec arch_spec(GetTargetRef().GetArchitecture());
+  switch (arch_spec.GetMachine()) {
+  case llvm::Triple::ArchType::arm:
+    error_reg_name = "r6";
+    break;
+  case llvm::Triple::ArchType::aarch64:
+    error_reg_name = "x19";
+    break;
+  case llvm::Triple::ArchType::x86_64:
+    error_reg_name = "r12";
+    break;
+  default:
+    break;
+  }
+
+  if (error_reg_name.empty())
+    return error_val;
+
+  RegisterContextSP reg_ctx = frame_sp->GetRegisterContext();
+  const RegisterInfo *reg_info = reg_ctx->GetRegisterInfoByName(error_reg_name);
+  lldbassert(reg_info &&
+             "didn't get the right register name for swift error register");
+  if (!reg_info)
+    return error_val;
+
+  RegisterValue reg_value;
+  if (!reg_ctx->ReadRegister(reg_info, reg_value)) {
+    // Do some logging here.
+    return error_val;
+  }
+
+  lldb::addr_t error_addr = reg_value.GetAsUInt64();
+  if (error_addr == 0)
+    return error_val;
+
+  Value val;
+  if (reg_value.GetScalarValue(val.GetScalar())) {
+    val.SetValueType(Value::eValueTypeScalar);
+    val.SetContext(Value::eContextTypeRegisterInfo,
+                   const_cast<RegisterInfo *>(reg_info));
+    error_val = val;
+  }
+  //  if (log)
+  //    log->Printf("Found return address: 0x%" PRIu64 " from register %s.",
+  //                return_addr,
+  //                error_reg_name.str().c_str());
+
+  return error_val;
+}
+
+llvm::Optional<Value> SwiftLanguageRuntime::GetErrorReturnLocationBeforeReturn(
+    lldb::StackFrameSP frame_sp, bool &need_to_check_after_return) {
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
+  llvm::Optional<Value> error_val;
+
+  if (!frame_sp) {
+    need_to_check_after_return = false;
+    return error_val;
+  }
+
+  // For Architectures where the error isn't returned in a register,
+  // there's a magic variable that points to the value.  Check that first:
+
+  ConstString error_location_name("$error");
+  VariableListSP variables_sp = frame_sp->GetInScopeVariableList(false);
+  VariableSP error_loc_var_sp = variables_sp->FindVariable(
+      error_location_name, eValueTypeVariableArgument);
+  if (error_loc_var_sp) {
+    need_to_check_after_return = false;
+
+    ValueObjectSP error_loc_val_sp = frame_sp->GetValueObjectForFrameVariable(
+        error_loc_var_sp, eNoDynamicValues);
+    if (error_loc_val_sp && error_loc_val_sp->GetError().Success())
+      error_val = error_loc_val_sp->GetValue();
+
+    //    if (log)
+    //      log->Printf("Found return address: 0x%" PRIu64 " from error
+    //      variable.", return_addr);
+    return error_val;
+  }
+
+  // Otherwise, see if we know which register it lives in from the calling
+  // convention. This should probably go in the ABI plugin not here, but the
+  // Swift ABI can change with swiftlang versions and that would make it awkward
+  // in the ABI.
+
+  Function *func = frame_sp->GetSymbolContext(eSymbolContextFunction).function;
+  if (!func) {
+    need_to_check_after_return = false;
+    return error_val;
+  }
+
+  need_to_check_after_return = func->CanThrow();
+  return error_val;
+}
+
+//------------------------------------------------------------------
+// Static Functions
+//------------------------------------------------------------------
+LanguageRuntime *
+SwiftLanguageRuntime::CreateInstance(Process *process,
+                                     lldb::LanguageType language) {
+  if (language == eLanguageTypeSwift)
+    return new SwiftLanguageRuntime(process);
+  else
+    return NULL;
+}
+
+lldb::BreakpointResolverSP
+SwiftLanguageRuntime::CreateExceptionResolver(Breakpoint *bkpt, bool catch_bp,
+                                              bool throw_bp) {
+  BreakpointResolverSP resolver_sp;
+
+  if (throw_bp)
+    resolver_sp.reset(new BreakpointResolverName(
+        bkpt, "swift_willThrow", eFunctionNameTypeBase, eLanguageTypeUnknown,
+        Breakpoint::Exact, 0, eLazyBoolNo));
+  // FIXME: We don't do catch breakpoints for ObjC yet.
+  // Should there be some way for the runtime to specify what it can do in this
+  // regard?
+  return resolver_sp;
+}
+
+static const char *
+SwiftDemangleNodeKindToCString(const swift::Demangle::Node::Kind node_kind) {
+#define NODE(e)                                                                \
+  case swift::Demangle::Node::Kind::e:                                         \
+    return #e;
+
+  switch (node_kind) {
+#include "swift/Demangling/DemangleNodes.def"
+  }
+  return "swift::Demangle::Node::Kind::???";
+#undef NODE
+}
+
+static OptionDefinition g_swift_demangle_options[] = {
+    // clang-format off
+  {LLDB_OPT_SET_1, false, "expand", 'e', OptionParser::eNoArgument, nullptr, nullptr, 0, eArgTypeNone, "Whether LLDB should print the demangled tree"},
+    // clang-format on
+};
+
+class CommandObjectSwift_Demangle : public CommandObjectParsed {
+public:
+  CommandObjectSwift_Demangle(CommandInterpreter &interpreter)
+      : CommandObjectParsed(interpreter, "demangle",
+                            "Demangle a Swift mangled name",
+                            "language swift demangle"),
+        m_options() {}
+
+  ~CommandObjectSwift_Demangle() {}
+
+  virtual Options *GetOptions() { return &m_options; }
+
+  class CommandOptions : public Options {
+  public:
+    CommandOptions() : Options(), m_expand(false, false) {
+      OptionParsingStarting(nullptr);
+    }
+
+    virtual ~CommandOptions() {}
+
+    Status SetOptionValue(uint32_t option_idx, llvm::StringRef option_arg,
+                          ExecutionContext *execution_context) override {
+      Status error;
+      const int short_option = m_getopt_table[option_idx].val;
+      switch (short_option) {
+      case 'e':
+        m_expand.SetCurrentValue(true);
+        break;
+
+      default:
+        error.SetErrorStringWithFormat("invalid short option character '%c'",
+                                       short_option);
+        break;
+      }
+
+      return error;
+    }
+
+    void OptionParsingStarting(ExecutionContext *execution_context) override {
+      m_expand.Clear();
+    }
+
+    llvm::ArrayRef<OptionDefinition> GetDefinitions() override {
+      return llvm::makeArrayRef(g_swift_demangle_options);
+    }
+
+    // Options table: Required for subclasses of Options.
+
+    OptionValueBoolean m_expand;
+  };
+
+protected:
+  void PrintNode(swift::Demangle::NodePointer node_ptr, Stream &stream,
+                 int depth = 0) {
+    if (!node_ptr)
+      return;
+
+    std::string indent(2 * depth, ' ');
+
+    stream.Printf("%s", indent.c_str());
+
+    stream.Printf("kind=%s",
+                  SwiftDemangleNodeKindToCString(node_ptr->getKind()));
+    if (node_ptr->hasText()) {
+      std::string Text = node_ptr->getText();
+      stream.Printf(", text=\"%s\"", Text.c_str());
+    }
+    if (node_ptr->hasIndex())
+      stream.Printf(", index=%" PRIu64, node_ptr->getIndex());
+
+    stream.Printf("\n");
+
+    for (auto &&child : *node_ptr) {
+      PrintNode(child, stream, depth + 1);
+    }
+  }
+
+  bool DoExecute(Args &command, CommandReturnObject &result) {
+    for (size_t i = 0; i < command.GetArgumentCount(); i++) {
+      const char *arg = command.GetArgumentAtIndex(i);
+      if (arg && *arg) {
+        swift::Demangle::Context demangle_ctx;
+        auto node_ptr = demangle_ctx.demangleSymbolAsNode(llvm::StringRef(arg));
+        if (node_ptr) {
+          if (m_options.m_expand) {
+            PrintNode(node_ptr, result.GetOutputStream());
+          }
+          result.GetOutputStream().Printf(
+              "%s ---> %s\n", arg,
+              swift::Demangle::nodeToString(node_ptr).c_str());
+        }
+      }
+    }
+    result.SetStatus(lldb::eReturnStatusSuccessFinishResult);
+    return true;
+  }
+
+  CommandOptions m_options;
+};
+
+class CommandObjectSwift_RefCount : public CommandObjectRaw {
+public:
+  CommandObjectSwift_RefCount(CommandInterpreter &interpreter)
+      : CommandObjectRaw(interpreter, "refcount",
+                         "Inspect the reference count data for a Swift object",
+                         "language swift refcount",
+                         eCommandProcessMustBePaused | eCommandRequiresFrame) {}
+
+  ~CommandObjectSwift_RefCount() {}
+
+  virtual Options *GetOptions() { return nullptr; }
+
+protected:
+  bool DoExecute(const char *command, CommandReturnObject &result) {
+    ExecutionContext exe_ctx(m_interpreter.GetExecutionContext());
+    StackFrameSP frame_sp(exe_ctx.GetFrameSP());
+    EvaluateExpressionOptions options;
+    options.SetLanguage(lldb::eLanguageTypeSwift);
+    options.SetResultIsInternal(true);
+    options.SetUseDynamic();
+    ValueObjectSP result_valobj_sp;
+    if (exe_ctx.GetTargetSP()->EvaluateExpression(command, frame_sp.get(),
+                                                  result_valobj_sp) ==
+        eExpressionCompleted) {
+      if (result_valobj_sp) {
+        if (result_valobj_sp->GetError().Fail()) {
+          result.SetStatus(lldb::eReturnStatusFailed);
+          result.AppendError(result_valobj_sp->GetError().AsCString());
+          return false;
+        }
+        result_valobj_sp =
+            result_valobj_sp->GetQualifiedRepresentationIfAvailable(
+                lldb::eDynamicCanRunTarget, true);
+        CompilerType result_type(result_valobj_sp->GetCompilerType());
+        if (result_type.GetTypeInfo() & lldb::eTypeInstanceIsPointer) {
+          size_t strong = 0, weak = 0;
+          if (!exe_ctx.GetProcessSP()
+                   ->GetSwiftLanguageRuntime()
+                   ->GetReferenceCounts(*result_valobj_sp.get(), strong,
+                                        weak)) {
+            result.AppendError("refcount not available");
+            result.SetStatus(lldb::eReturnStatusFailed);
+            return false;
+          } else {
+            result.AppendMessageWithFormat(
+                "refcount data: (strong = %zu, weak = %zu)\n", strong, weak);
+            result.SetStatus(lldb::eReturnStatusSuccessFinishResult);
+            return true;
+          }
+        } else {
+          result.AppendError("refcount only available for class types");
+          result.SetStatus(lldb::eReturnStatusFailed);
+          return false;
+        }
+      }
+    }
+    result.SetStatus(lldb::eReturnStatusFailed);
+    if (result_valobj_sp && result_valobj_sp->GetError().Fail())
+      result.AppendError(result_valobj_sp->GetError().AsCString());
+    return false;
+  }
+};
+
+class CommandObjectMultiwordSwift : public CommandObjectMultiword {
+public:
+  CommandObjectMultiwordSwift(CommandInterpreter &interpreter)
+      : CommandObjectMultiword(
+            interpreter, "swift",
+            "A set of commands for operating on the Swift Language Runtime.",
+            "swift <subcommand> [<subcommand-options>]") {
+    LoadSubCommand("demangle", CommandObjectSP(new CommandObjectSwift_Demangle(
+                                   interpreter)));
+    LoadSubCommand("refcount", CommandObjectSP(new CommandObjectSwift_RefCount(
+                                   interpreter)));
+  }
+
+  virtual ~CommandObjectMultiwordSwift() {}
+};
+
+void SwiftLanguageRuntime::Initialize() {
+  PluginManager::RegisterPlugin(
+      GetPluginNameStatic(), "Language runtime for the Swift language",
+      CreateInstance,
+      [](CommandInterpreter &interpreter) -> lldb::CommandObjectSP {
+        return CommandObjectSP(new CommandObjectMultiwordSwift(interpreter));
+      });
+}
+
+void SwiftLanguageRuntime::Terminate() {
+  PluginManager::UnregisterPlugin(CreateInstance);
+}
+
+lldb_private::ConstString SwiftLanguageRuntime::GetPluginNameStatic() {
+  static ConstString g_name("swift");
+  return g_name;
+}
+
+//------------------------------------------------------------------
+// PluginInterface protocol
+//------------------------------------------------------------------
+lldb_private::ConstString SwiftLanguageRuntime::GetPluginName() {
+  return GetPluginNameStatic();
+}
+
+uint32_t SwiftLanguageRuntime::GetPluginVersion() { return 1; }
diff --git a/source/Target/Target.cpp b/source/Target/Target.cpp
index d97f651ca..d9f5f88ad 100644
--- a/source/Target/Target.cpp
+++ b/source/Target/Target.cpp
@@ -11,10 +11,12 @@
 // C++ Includes
 #include <mutex>
 // Other libraries and framework includes
+#include "swift/Frontend/Frontend.h"
 // Project includes
 #include "Plugins/ExpressionParser/Clang/ClangASTSource.h"
 #include "Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.h"
 #include "Plugins/ExpressionParser/Clang/ClangPersistentVariables.h"
+#include "Plugins/ExpressionParser/Swift/SwiftREPL.h"
 #include "lldb/Breakpoint/BreakpointIDList.h"
 #include "lldb/Breakpoint/BreakpointResolver.h"
 #include "lldb/Breakpoint/BreakpointResolverAddress.h"
@@ -31,6 +33,7 @@
 #include "lldb/Core/State.h"
 #include "lldb/Core/StreamFile.h"
 #include "lldb/Core/ValueObject.h"
+#include "lldb/Expression/DiagnosticManager.h"
 #include "lldb/Expression/REPL.h"
 #include "lldb/Expression/UserExpression.h"
 #include "lldb/Host/Host.h"
@@ -44,6 +47,8 @@
 #include "lldb/Symbol/Function.h"
 #include "lldb/Symbol/ObjectFile.h"
 #include "lldb/Symbol/Symbol.h"
+#include "lldb/Symbol/SymbolFile.h"
+#include "lldb/Symbol/SymbolVendor.h"
 #include "lldb/Target/Language.h"
 #include "lldb/Target/LanguageRuntime.h"
 #include "lldb/Target/ObjCLanguageRuntime.h"
@@ -185,6 +190,13 @@ const lldb::ProcessSP &Target::GetProcessSP() const { return m_process_sp; }
 
 lldb::REPLSP Target::GetREPL(Status &err, lldb::LanguageType language,
                              const char *repl_options, bool can_create) {
+  err.Clear();
+
+  if (!GetProcessSP()) {
+    err.SetErrorStringWithFormat("Can't run the REPL without a live process.");
+    return REPLSP();
+  }
+
   if (language == eLanguageTypeUnknown) {
     std::set<LanguageType> repl_languages;
 
@@ -323,9 +335,15 @@ BreakpointSP Target::CreateBreakpoint(const FileSpecList *containingModules,
       break;
 
     case eInlineBreakpointsHeaders:
-      if (remapped_file.IsSourceImplementationFile())
-        check_inlines = eLazyBoolNo;
-      else
+      if (remapped_file.IsSourceImplementationFile()) {
+        // Swift can inline a lot of code from other swift files so always
+        // check inlines for swift source files
+        static ConstString g_swift_extension("swift");
+        if (remapped_file.GetFileNameExtension() == g_swift_extension)
+          check_inlines = eLazyBoolYes;
+        else
+          check_inlines = eLazyBoolNo;
+      } else
         check_inlines = eLazyBoolYes;
       break;
 
@@ -1409,6 +1427,13 @@ void Target::ModulesDidLoad(ModuleList &module_list) {
     if (m_process_sp) {
       m_process_sp->ModulesDidLoad(module_list);
     }
+    // if there's no SwiftASTContext, clearing it doesn't really matter
+    const bool create_on_demand = false;
+    Status error;
+    auto swift_ast_ctx = GetScratchSwiftASTContext(error, create_on_demand);
+    if (swift_ast_ctx)
+      swift_ast_ctx->ModulesDidLoad(module_list);
+    module_list.ClearModuleDependentCaches();
     BroadcastEvent(eBroadcastBitModulesLoaded,
                    new TargetEventData(this->shared_from_this(), module_list));
   }
@@ -1920,9 +1945,10 @@ void Target::ImageSearchPathsChanged(const PathMappingList &path_list,
     target->SetExecutableModule(exe_module_sp, true);
 }
 
-TypeSystem *Target::GetScratchTypeSystemForLanguage(Status *error,
-                                                    lldb::LanguageType language,
-                                                    bool create_on_demand) {
+TypeSystem *Target::GetScratchTypeSystemForLanguage(
+    Status *error, lldb::LanguageType language, bool create_on_demand,
+    const char *compiler_options)
+{
   if (!m_valid)
     return nullptr;
 
@@ -1951,12 +1977,80 @@ TypeSystem *Target::GetScratchTypeSystemForLanguage(Status *error,
     }
   }
 
-  return m_scratch_type_system_map.GetTypeSystemForLanguage(language, this,
-                                                            create_on_demand);
+  if (m_cant_make_scratch_type_system.find(language) !=
+      m_cant_make_scratch_type_system.end()) {
+    return nullptr;
+  }
+
+  TypeSystem *type_system = m_scratch_type_system_map.GetTypeSystemForLanguage(
+      language, this, create_on_demand, compiler_options);
+  if (language == eLanguageTypeSwift) {
+    if (SwiftASTContext *swift_ast_ctx =
+            llvm::dyn_cast_or_null<SwiftASTContext>(type_system)) {
+      if (swift_ast_ctx->CheckProcessChanged() ||
+          swift_ast_ctx->HasFatalErrors()) {
+        if (swift_ast_ctx->HasFatalErrors()) {
+          if (StreamSP error_stream_sp = GetDebugger().GetAsyncErrorStream()) {
+            error_stream_sp->Printf("Shared Swift state for %s has developed "
+                                    "fatal errors and is being discarded.\n",
+                                    GetExecutableModule()
+                                        ->GetPlatformFileSpec()
+                                        .GetFilename()
+                                        .AsCString());
+            error_stream_sp->PutCString(
+                "REPL definitions and persistent names/types will be lost.\n");
+            error_stream_sp->Flush();
+          }
+        }
+        m_scratch_type_system_map.RemoveTypeSystemsForLanguage(language);
+        type_system = m_scratch_type_system_map.GetTypeSystemForLanguage(
+            language, this, create_on_demand, compiler_options);
+
+        if (SwiftASTContext *new_swift_ast_ctx =
+                llvm::dyn_cast_or_null<SwiftASTContext>(type_system)) {
+          if (new_swift_ast_ctx->HasFatalErrors()) {
+            if (StreamSP error_stream_sp =
+                    GetDebugger().GetAsyncErrorStream()) {
+              error_stream_sp->PutCString("Can't construct shared Swift state "
+                                          "for this process after repeated "
+                                          "attempts.\n");
+              error_stream_sp->PutCString("Giving up.  Fatal errors:\n");
+              DiagnosticManager diag_mgr;
+              new_swift_ast_ctx->PrintDiagnostics(diag_mgr);
+              error_stream_sp->PutCString(diag_mgr.GetString().c_str());
+              error_stream_sp->Flush();
+            }
+
+            m_cant_make_scratch_type_system[language] = true;
+            m_scratch_type_system_map.RemoveTypeSystemsForLanguage(language);
+            type_system = nullptr;
+          }
+        }
+      }
+    } else if (create_on_demand) {
+      if (StreamSP error_stream_sp = GetDebugger().GetAsyncErrorStream()) {
+        error_stream_sp->Printf(
+            "Shared Swift state for %s could not be initialized.\n",
+            GetExecutableModule()
+                ->GetPlatformFileSpec()
+                .GetFilename()
+                .AsCString());
+        error_stream_sp->PutCString(
+            "The REPL and expressions are unavailable.\n");
+        error_stream_sp->Flush();
+      }
+    }
+  }
+  return type_system;
+}
+
+const TypeSystemMap &Target::GetTypeSystemMap() {
+  return m_scratch_type_system_map;
 }
 
 PersistentExpressionState *
-Target::GetPersistentExpressionStateForLanguage(lldb::LanguageType language) {
+Target::GetPersistentExpressionStateForLanguage(lldb::LanguageType language)
+{
   TypeSystem *type_system =
       GetScratchTypeSystemForLanguage(nullptr, language, true);
 
@@ -2048,7 +2142,8 @@ Target::GetUtilityFunctionForLanguage(const char *text,
   return utility_fn;
 }
 
-ClangASTContext *Target::GetScratchClangASTContext(bool create_on_demand) {
+ClangASTContext *Target::GetScratchClangASTContext(bool create_on_demand)
+{
   if (m_valid) {
     if (TypeSystem *type_system = GetScratchTypeSystemForLanguage(
             nullptr, eLanguageTypeC, create_on_demand))
@@ -2067,6 +2162,15 @@ ClangASTImporterSP Target::GetClangASTImporter() {
   return ClangASTImporterSP();
 }
 
+SwiftASTContext *Target::GetScratchSwiftASTContext(Status &error,
+                                                   bool create_on_demand,
+                                                   const char *extra_options)
+{
+  return llvm::dyn_cast_or_null<SwiftASTContext>(
+      GetScratchTypeSystemForLanguage(&error, eLanguageTypeSwift,
+                                      create_on_demand, extra_options));
+}
+
 void Target::SettingsInitialize() { Process::SettingsInitialize(); }
 
 void Target::SettingsTerminate() { Process::SettingsTerminate(); }
@@ -2786,6 +2890,52 @@ bool Target::SetSectionUnloaded(const lldb::SectionSP &section_sp,
 
 void Target::ClearAllLoadedSections() { m_section_load_history.Clear(); }
 
+lldb::addr_t Target::FindLoadAddrForNameInSymbolsAndPersistentVariables(
+    ConstString name_const_str, SymbolType symbol_type) {
+  lldb::addr_t symbol_addr = LLDB_INVALID_ADDRESS;
+  SymbolContextList sc_list;
+
+  if (GetImages().FindSymbolsWithNameAndType(name_const_str, symbol_type,
+                                             sc_list)) {
+    SymbolContext desired_symbol;
+
+    if (sc_list.GetSize() == 1 &&
+        sc_list.GetContextAtIndex(0, desired_symbol)) {
+      if (desired_symbol.symbol) {
+        symbol_addr = desired_symbol.symbol->GetAddress().GetLoadAddress(this);
+      }
+    } else if (sc_list.GetSize() > 1) {
+      for (size_t i = 0; i < sc_list.GetSize(); i++) {
+        if (sc_list.GetContextAtIndex(i, desired_symbol)) {
+          if (desired_symbol.symbol) {
+            symbol_addr =
+                desired_symbol.symbol->GetAddress().GetLoadAddress(this);
+            if (symbol_addr != LLDB_INVALID_ADDRESS)
+              break;
+          }
+        }
+      }
+    }
+  }
+
+  if (symbol_addr == LLDB_INVALID_ADDRESS) {
+    // If we didn't find it in the symbols, check the ClangPersistentVariables,
+    // 'cause we may have
+    // made it by hand.
+    ConstString mangled_const_str;
+    if (name_const_str.GetMangledCounterpart(mangled_const_str))
+      symbol_addr = GetPersistentSymbol(mangled_const_str);
+  }
+
+  if (symbol_addr == LLDB_INVALID_ADDRESS) {
+    // Let's try looking for the name passed-in itself, as it might be a mangled
+    // name
+    symbol_addr = GetPersistentSymbol(name_const_str);
+  }
+
+  return symbol_addr;
+}
+
 Status Target::Launch(ProcessLaunchInfo &launch_info, Stream *stream) {
   Status error;
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_TARGET));
@@ -3240,9 +3390,18 @@ static PropertyDefinition g_properties[] = {
     {"clang-module-search-paths", OptionValue::eTypeFileSpecList, false, 0,
      nullptr, nullptr,
      "List of directories to be searched when locating modules for Clang."},
+    {"swift-framework-search-paths", OptionValue::eTypeFileSpecList, false, 0,
+     nullptr, nullptr,
+     "List of directories to be searched when locating frameworks for Swift."},
+    {"swift-module-search-paths", OptionValue::eTypeFileSpecList, false, 0,
+     nullptr, nullptr,
+     "List of directories to be searched when locating modules for Swift."},
     {"auto-import-clang-modules", OptionValue::eTypeBoolean, false, true,
      nullptr, nullptr,
      "Automatically load Clang modules referred to by the program."},
+    {"use-all-compiler-flags", OptionValue::eTypeBoolean, false, false, nullptr,
+     nullptr, "Try to use compiler flags for all modules when setting up the "
+              "Swift expression parser, not just the main executable."},
     {"auto-apply-fixits", OptionValue::eTypeBoolean, false, true, nullptr,
      nullptr, "Automatically apply fix-it hints to expressions."},
     {"notify-about-fixits", OptionValue::eTypeBoolean, false, true, nullptr,
@@ -3352,6 +3511,10 @@ static PropertyDefinition g_properties[] = {
      OptionValue::eTypeString, nullptr, nullptr,
      "A list of trap handler function names, e.g. a common Unix user process "
      "one is _sigtramp."},
+    {"sdk-path", OptionValue::eTypeFileSpec, false, 0, nullptr, nullptr,
+     "The path to the SDK used to build the current target."},
+    {"module-cache-path", OptionValue::eTypeFileSpec, false, 0, nullptr,
+     nullptr, "The path to the module-cache directory."},
     {"display-runtime-support-values", OptionValue::eTypeBoolean, false, false,
      nullptr, nullptr, "If true, LLDB will show variables that are meant to "
                        "support the operation of a language's runtime "
@@ -3372,7 +3535,10 @@ enum {
   ePropertyExecutableSearchPaths,
   ePropertyDebugFileSearchPaths,
   ePropertyClangModuleSearchPaths,
+  ePropertySwiftFrameworkSearchPaths,
+  ePropertySwiftModuleSearchPaths,
   ePropertyAutoImportClangModules,
+  ePropertyUseAllCompilerFlags,
   ePropertyAutoApplyFixIts,
   ePropertyNotifyAboutFixIts,
   ePropertySaveObjects,
@@ -3401,6 +3567,8 @@ enum {
   ePropertyMemoryModuleLoadLevel,
   ePropertyDisplayExpressionsInCrashlogs,
   ePropertyTrapHandlerNames,
+  ePropertySDKPath,
+  ePropertyModuleCachePath,
   ePropertyDisplayRuntimeSupportValues,
   ePropertyNonStopModeEnabled,
   ePropertyExperimental
@@ -3499,7 +3667,7 @@ protected:
 // TargetProperties
 //----------------------------------------------------------------------
 static PropertyDefinition g_experimental_properties[]{
-    {"inject-local-vars", OptionValue::eTypeBoolean, true, true, nullptr,
+    {"inject-local-vars", OptionValue::eTypeBoolean, true, false, nullptr,
      nullptr,
      "If true, inject local variables explicitly into the expression text.  "
      "This will fix symbol resolution when there are name collisions between "
@@ -3779,6 +3947,42 @@ FileSpecList &TargetProperties::GetDebugFileSearchPaths() {
   return option_value->GetCurrentValue();
 }
 
+FileSpec &TargetProperties::GetModuleCachePath() {
+  const uint32_t idx = ePropertyModuleCachePath;
+  OptionValueFileSpec *option_value =
+      m_collection_sp->GetPropertyAtIndexAsOptionValueFileSpec(NULL, false,
+                                                               idx);
+  assert(option_value);
+  return option_value->GetCurrentValue();
+}
+
+FileSpec &TargetProperties::GetSDKPath() {
+  const uint32_t idx = ePropertySDKPath;
+  OptionValueFileSpec *option_value =
+      m_collection_sp->GetPropertyAtIndexAsOptionValueFileSpec(NULL, false,
+                                                               idx);
+  assert(option_value);
+  return option_value->GetCurrentValue();
+}
+
+FileSpecList &TargetProperties::GetSwiftFrameworkSearchPaths() {
+  const uint32_t idx = ePropertySwiftFrameworkSearchPaths;
+  OptionValueFileSpecList *option_value =
+      m_collection_sp->GetPropertyAtIndexAsOptionValueFileSpecList(NULL, false,
+                                                                   idx);
+  assert(option_value);
+  return option_value->GetCurrentValue();
+}
+
+FileSpecList &TargetProperties::GetSwiftModuleSearchPaths() {
+  const uint32_t idx = ePropertySwiftModuleSearchPaths;
+  OptionValueFileSpecList *option_value =
+      m_collection_sp->GetPropertyAtIndexAsOptionValueFileSpecList(NULL, false,
+                                                                   idx);
+  assert(option_value);
+  return option_value->GetCurrentValue();
+}
+
 FileSpecList &TargetProperties::GetClangModuleSearchPaths() {
   const uint32_t idx = ePropertyClangModuleSearchPaths;
   OptionValueFileSpecList *option_value =
@@ -3794,6 +3998,12 @@ bool TargetProperties::GetEnableAutoImportClangModules() const {
       nullptr, idx, g_properties[idx].default_uint_value != 0);
 }
 
+bool TargetProperties::GetUseAllCompilerFlags() const {
+  const uint32_t idx = ePropertyUseAllCompilerFlags;
+  return m_collection_sp->GetPropertyAtIndexAsBoolean(
+      NULL, idx, g_properties[idx].default_uint_value != 0);
+}
+
 bool TargetProperties::GetEnableAutoApplyFixIts() const {
   const uint32_t idx = ePropertyAutoApplyFixIts;
   return m_collection_sp->GetPropertyAtIndexAsBoolean(
@@ -4080,6 +4290,14 @@ void TargetProperties::DisableSTDIOValueChangedCallback(
     this_->m_launch_info.GetFlags().Clear(lldb::eLaunchFlagDisableSTDIO);
 }
 
+uint32_t EvaluateExpressionOptions::GetExpressionNumber() const {
+  if (m_expr_number == 0) {
+    static uint32_t g_expr_idx = 0;
+    m_expr_number = ++g_expr_idx;
+  }
+  return m_expr_number;
+}
+
 //----------------------------------------------------------------------
 // Target::TargetEventData
 //----------------------------------------------------------------------
diff --git a/source/Target/Thread.cpp b/source/Target/Thread.cpp
index 505d14012..d4db8273b 100644
--- a/source/Target/Thread.cpp
+++ b/source/Target/Thread.cpp
@@ -402,8 +402,12 @@ lldb::StopInfoSP Thread::GetStopInfo() {
   if (have_valid_stop_info && !plan_overrides_trace) {
     return m_stop_info_sp;
   } else if (have_valid_completed_plan) {
+    bool is_swift_error_value;
+    lldb::ValueObjectSP return_value_sp =
+        GetReturnValueObject(&is_swift_error_value);
     return StopInfo::CreateStopReasonWithPlan(
-        completed_plan_sp, GetReturnValueObject(), GetExpressionVariable());
+        completed_plan_sp, return_value_sp, GetExpressionVariable(),
+        is_swift_error_value);
   } else {
     GetPrivateStopInfo();
     return m_stop_info_sp;
@@ -1116,13 +1120,20 @@ ThreadPlanSP Thread::GetCompletedPlan() {
   return empty_plan_sp;
 }
 
-ValueObjectSP Thread::GetReturnValueObject() {
+ValueObjectSP Thread::GetReturnValueObject(bool *is_swift_error_value) {
+  if (is_swift_error_value)
+    *is_swift_error_value = false;
+
   if (!m_completed_plan_stack.empty()) {
     for (int i = m_completed_plan_stack.size() - 1; i >= 0; i--) {
       ValueObjectSP return_valobj_sp;
       return_valobj_sp = m_completed_plan_stack[i]->GetReturnValueObject();
-      if (return_valobj_sp)
+      if (return_valobj_sp) {
+        if (is_swift_error_value)
+          *is_swift_error_value =
+              m_completed_plan_stack[i]->IsReturnValueSwiftErrorValue();
         return return_valobj_sp;
+      }
     }
   }
   return ValueObjectSP();
@@ -1412,6 +1423,28 @@ ThreadPlanSP Thread::QueueThreadPlanForStepInRange(
   return thread_plan_sp;
 }
 
+ThreadPlanSP Thread::QueueThreadPlanForStepInRangeNoShouldStop(
+    bool abort_other_plans, const AddressRange &range,
+    const SymbolContext &addr_context, const char *step_in_target,
+    lldb::RunMode stop_other_threads,
+    LazyBool step_in_avoids_code_without_debug_info,
+    LazyBool step_out_avoids_code_without_debug_info) {
+  ThreadPlanSP thread_plan_sp(
+      new ThreadPlanStepInRange(*this, range, addr_context, stop_other_threads,
+                                step_in_avoids_code_without_debug_info,
+                                step_out_avoids_code_without_debug_info));
+  ThreadPlanStepInRange *plan =
+      static_cast<ThreadPlanStepInRange *>(thread_plan_sp.get());
+
+  if (step_in_target)
+    plan->SetStepInTarget(step_in_target);
+
+  plan->ClearShouldStopHereCallbacks();
+
+  QueueThreadPlan(thread_plan_sp, abort_other_plans);
+  return thread_plan_sp;
+}
+
 // Call the QueueThreadPlanForStepInRange method which takes an address range.
 ThreadPlanSP Thread::QueueThreadPlanForStepInRange(
     bool abort_other_plans, const LineEntry &line_entry,
diff --git a/source/Target/ThreadPlanCallFunction.cpp b/source/Target/ThreadPlanCallFunction.cpp
index e3b9ae15d..4e7e7482b 100644
--- a/source/Target/ThreadPlanCallFunction.cpp
+++ b/source/Target/ThreadPlanCallFunction.cpp
@@ -22,6 +22,7 @@
 #include "lldb/Target/Process.h"
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/StopInfo.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/Thread.h"
 #include "lldb/Target/ThreadPlanRunToAddress.h"
@@ -137,7 +138,9 @@ ThreadPlanCallFunction::ThreadPlanCallFunction(
       m_function_sp(0), m_takedown_done(false),
       m_should_clear_objc_exception_bp(false),
       m_should_clear_cxx_exception_bp(false),
-      m_stop_address(LLDB_INVALID_ADDRESS), m_return_type(return_type) {
+      m_stop_address(LLDB_INVALID_ADDRESS),
+      m_expression_language(options.GetLanguage()), m_hit_error_backstop(false),
+      m_return_type(return_type) {
   lldb::addr_t start_load_addr = LLDB_INVALID_ADDRESS;
   lldb::addr_t function_load_addr = LLDB_INVALID_ADDRESS;
   ABI *abi = nullptr;
@@ -387,7 +390,8 @@ bool ThreadPlanCallFunction::ShouldStop(Event *event_ptr) {
   // We do some computation in DoPlanExplainsStop that may or may not set the
   // plan as complete.
   // We need to do that here to make sure our state is correct.
-  DoPlanExplainsStop(event_ptr);
+  if (GetCachedPlanExplainsStop() == eLazyBoolCalculate)
+    DoPlanExplainsStop(event_ptr);
 
   if (IsPlanComplete()) {
     ReportRegisterState("Function completed.  Register state was:");
@@ -439,20 +443,42 @@ bool ThreadPlanCallFunction::MischiefManaged() {
 
 void ThreadPlanCallFunction::SetBreakpoints() {
   ProcessSP process_sp(m_thread.CalculateProcess());
-  if (m_trap_exceptions && process_sp) {
-    m_cxx_language_runtime =
-        process_sp->GetLanguageRuntime(eLanguageTypeC_plus_plus);
-    m_objc_language_runtime = process_sp->GetLanguageRuntime(eLanguageTypeObjC);
-
-    if (m_cxx_language_runtime) {
-      m_should_clear_cxx_exception_bp =
-          !m_cxx_language_runtime->ExceptionBreakpointsAreSet();
-      m_cxx_language_runtime->SetExceptionBreakpoints();
+  if (process_sp) {
+    if (m_trap_exceptions) {
+      m_cxx_language_runtime =
+          process_sp->GetLanguageRuntime(eLanguageTypeC_plus_plus);
+      m_objc_language_runtime =
+          process_sp->GetLanguageRuntime(eLanguageTypeObjC);
+
+      if (m_cxx_language_runtime) {
+        m_should_clear_cxx_exception_bp =
+            !m_cxx_language_runtime->ExceptionBreakpointsAreSet();
+        m_cxx_language_runtime->SetExceptionBreakpoints();
+      }
+      if (m_objc_language_runtime) {
+        m_should_clear_objc_exception_bp =
+            !m_objc_language_runtime->ExceptionBreakpointsAreSet();
+        m_objc_language_runtime->SetExceptionBreakpoints();
+      }
     }
-    if (m_objc_language_runtime) {
-      m_should_clear_objc_exception_bp =
-          !m_objc_language_runtime->ExceptionBreakpointsAreSet();
-      m_objc_language_runtime->SetExceptionBreakpoints();
+    if (GetExpressionLanguage() == eLanguageTypeSwift) {
+      SwiftLanguageRuntime *swift_runtime =
+          process_sp->GetSwiftLanguageRuntime();
+      if (swift_runtime) {
+        ConstString backstop_name = swift_runtime->GetErrorBackstopName();
+        if (!backstop_name.IsEmpty()) {
+          FileSpecList stdlib_module_list;
+          stdlib_module_list.Append(FileSpec(
+              swift_runtime->GetStandardLibraryName().AsCString(), false));
+          const LazyBool skip_prologue = eLazyBoolNo;
+          const bool is_internal = true;
+          const bool is_hardware = false;
+          m_error_backstop_bp_sp = process_sp->GetTarget().CreateBreakpoint(
+              &stdlib_module_list, NULL, backstop_name.AsCString(),
+              eFunctionNameTypeFull, eLanguageTypeUnknown, 0, skip_prologue,
+              is_internal, is_hardware);
+        }
+      }
     }
   }
 }
@@ -464,11 +490,17 @@ void ThreadPlanCallFunction::ClearBreakpoints() {
     if (m_objc_language_runtime && m_should_clear_objc_exception_bp)
       m_objc_language_runtime->ClearExceptionBreakpoints();
   }
+  if (m_error_backstop_bp_sp) {
+    GetTarget().RemoveBreakpointByID(m_error_backstop_bp_sp->GetID());
+  }
 }
 
 bool ThreadPlanCallFunction::BreakpointsExplainStop() {
   StopInfoSP stop_info_sp = GetPrivateStopInfo();
 
+  if (stop_info_sp->GetStopReason() != eStopReasonBreakpoint)
+    return false;
+
   if (m_trap_exceptions) {
     if ((m_cxx_language_runtime &&
          m_cxx_language_runtime->ExceptionBreakpointsExplainStop(
@@ -491,6 +523,47 @@ bool ThreadPlanCallFunction::BreakpointsExplainStop() {
       return true;
     }
   }
+  if (m_error_backstop_bp_sp) {
+    ProcessSP process_sp(m_thread.CalculateProcess());
+    if (process_sp) {
+      uint64_t break_site_id = stop_info_sp->GetValue();
+      if (process_sp->GetBreakpointSiteList().BreakpointSiteContainsBreakpoint(
+              break_site_id, m_error_backstop_bp_sp->GetID())) {
+        // Our expression threw an uncaught exception.  That will happen in REPL
+        // & Playground, though not in
+        // the regular expression parser.  In that case, we should fetch the
+        // actual return value from the
+        // argument passed to this function, and set that as the return value.
+        SetPlanComplete(true);
+        StackFrameSP frame_sp = m_thread.GetStackFrameAtIndex(0);
+        PersistentExpressionState *persistent_state =
+            GetTarget().GetPersistentExpressionStateForLanguage(
+                eLanguageTypeSwift);
+        const bool is_error = true;
+        ConstString persistent_variable_name(
+            persistent_state->GetNextPersistentVariableName(is_error));
+        m_return_valobj_sp =
+            SwiftLanguageRuntime::CalculateErrorValueFromFirstArgument(
+                frame_sp, persistent_variable_name);
+
+        DataExtractor data;
+        Status data_error;
+        size_t data_size =
+            m_return_valobj_sp->GetStaticValue()->GetData(data, data_error);
+
+        if (data_size == data.GetAddressByteSize()) {
+          lldb::offset_t offset = 0;
+          lldb::addr_t addr = data.GetAddress(&offset);
+
+          SwiftLanguageRuntime::RegisterGlobalError(
+              GetTarget(), persistent_variable_name, addr);
+        }
+
+        m_hit_error_backstop = true;
+        return true;
+      }
+    }
+  }
 
   return false;
 }
diff --git a/source/Target/ThreadPlanShouldStopHere.cpp b/source/Target/ThreadPlanShouldStopHere.cpp
index 42aaa4227..73333212c 100644
--- a/source/Target/ThreadPlanShouldStopHere.cpp
+++ b/source/Target/ThreadPlanShouldStopHere.cpp
@@ -13,6 +13,8 @@
 // Project includes
 #include "lldb/Target/ThreadPlanShouldStopHere.h"
 #include "lldb/Symbol/Symbol.h"
+#include "lldb/Target/LanguageRuntime.h"
+#include "lldb/Target/Process.h"
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/Thread.h"
 #include "lldb/Utility/Log.h"
@@ -83,6 +85,18 @@ bool ThreadPlanShouldStopHere::DefaultShouldStopHereCallback(
     }
   }
 
+  // Check whether the frame we are in is a language runtime thunk, only for
+  // step out:
+  if (operation == eFrameCompareOlder) {
+    Symbol *symbol = frame->GetSymbolContext(eSymbolContextSymbol).symbol;
+    if (symbol) {
+      ProcessSP process_sp(current_plan->GetThread().GetProcess());
+      if (LanguageRuntime::IsSymbolAnyRuntimeThunk(process_sp, *symbol)) {
+          should_stop_here = false;
+      }
+    }
+  }
+
   // Always avoid code with line number 0.
   // FIXME: At present the ShouldStop and the StepFromHere calculate this
   // independently.  If this ever
@@ -118,29 +132,54 @@ ThreadPlanSP ThreadPlanShouldStopHere::DefaultStepFromHereCallback(
   if (sc.line_entry.line == 0) {
     AddressRange range = sc.line_entry.range;
 
-    // If the whole function is marked line 0 just step out, that's easier &
-    // faster than continuing
-    // to step through it.
+    // If this is a runtime thunk, just step out:
     bool just_step_out = false;
-    if (sc.symbol && sc.symbol->ValueIsAddress()) {
-      Address symbol_end = sc.symbol->GetAddress();
-      symbol_end.Slide(sc.symbol->GetByteSize() - 1);
-      if (range.ContainsFileAddress(sc.symbol->GetAddress()) &&
-          range.ContainsFileAddress(symbol_end)) {
-        if (log)
-          log->Printf("Stopped in a function with only line 0 lines, just "
-                      "stepping out.");
+    if (sc.symbol) {
+      ProcessSP process_sp(current_plan->GetThread().GetProcess());
+
+      if (LanguageRuntime::IsSymbolAnyRuntimeThunk(process_sp, *sc.symbol)) {
+          if (log)
+            log->Printf("In runtime thunk %s - stepping out.",
+              sc.symbol->GetName().GetCString());
         just_step_out = true;
       }
+      // If the whole function is marked line 0 just step out, that's easier &
+      // faster than continuing to step through it.
+      // FIXME: This assumes that the function is a single line range.  It could
+      // be a series of contiguous line 0 ranges.  Check for that too.
+      if (!just_step_out && sc.symbol->ValueIsAddress()) {
+        Address symbol_end = sc.symbol->GetAddress();
+        symbol_end.Slide(sc.symbol->GetByteSize() - 1);
+        if (range.ContainsFileAddress(sc.symbol->GetAddress()) &&
+            range.ContainsFileAddress(symbol_end)) {
+          if (log)
+            log->Printf("Stopped in a function with only line 0 lines, just "
+                        "stepping out.");
+          just_step_out = true;
+        }
+      }
     }
-    if (!just_step_out) {
-      if (log)
-        log->Printf("ThreadPlanShouldStopHere::DefaultStepFromHereCallback "
-                    "Queueing StepInRange plan to step through line 0 code.");
 
-      return_plan_sp = current_plan->GetThread().QueueThreadPlanForStepInRange(
-          false, range, sc, NULL, eOnlyDuringStepping, eLazyBoolCalculate,
-          eLazyBoolNo);
+    if (!just_step_out) {
+      // If the current plan is a "Step In" plan we should use step in, otherwise
+      // just step over:
+      if (current_plan->GetKind() == ThreadPlan::eKindStepInRange) {
+        if (log)
+          log->Printf("ThreadPlanShouldStopHere::DefaultStepFromHereCallback "
+                      "Queueing StepInRange plan to step through line 0 code.");
+        return_plan_sp =
+          current_plan
+            ->GetThread().QueueThreadPlanForStepInRangeNoShouldStop(
+              false, range, sc, NULL, eOnlyDuringStepping, eLazyBoolCalculate,
+              eLazyBoolNo);
+      } else {
+        if (log)
+          log->Printf("ThreadPlanShouldStopHere::DefaultStepFromHereCallback "
+                      "Queueing StepOverRange plan to step through line 0 code.");
+        return_plan_sp =
+            current_plan->GetThread().QueueThreadPlanForStepOverRange(
+              false, range, sc, eOnlyDuringStepping, eLazyBoolNo);
+      }
     }
   }
 
diff --git a/source/Target/ThreadPlanStepInRange.cpp b/source/Target/ThreadPlanStepInRange.cpp
index caaaffea8..9cc60547a 100644
--- a/source/Target/ThreadPlanStepInRange.cpp
+++ b/source/Target/ThreadPlanStepInRange.cpp
@@ -11,12 +11,15 @@
 // C++ Includes
 // Other libraries and framework includes
 // Project includes
+
 #include "lldb/Target/ThreadPlanStepInRange.h"
+#include "lldb/Breakpoint/BreakpointLocation.h"
 #include "lldb/Core/Module.h"
 #include "lldb/Symbol/Function.h"
 #include "lldb/Symbol/Symbol.h"
 #include "lldb/Target/Process.h"
 #include "lldb/Target/RegisterContext.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/Thread.h"
 #include "lldb/Target/ThreadPlanStepOut.h"
@@ -69,7 +72,9 @@ ThreadPlanStepInRange::ThreadPlanStepInRange(
                     step_out_avoids_code_without_debug_info);
 }
 
-ThreadPlanStepInRange::~ThreadPlanStepInRange() = default;
+ThreadPlanStepInRange::~ThreadPlanStepInRange() {
+  ClearStepInDeepBreakpoints();
+}
 
 void ThreadPlanStepInRange::SetupAvoidNoDebug(
     LazyBool step_in_avoids_code_without_debug_info,
@@ -297,6 +302,13 @@ bool ThreadPlanStepInRange::ShouldStop(Event *event_ptr) {
   }
 }
 
+bool ThreadPlanStepInRange::MischiefManaged() {
+  bool return_value = ThreadPlanStepRange::MischiefManaged();
+  if (return_value)
+    ClearStepInDeepBreakpoints();
+  return return_value;
+}
+
 void ThreadPlanStepInRange::SetAvoidRegexp(const char *name) {
   auto name_ref = llvm::StringRef::withNullAsEmpty(name);
   if (!m_avoid_regexp_ap)
@@ -310,25 +322,91 @@ void ThreadPlanStepInRange::SetDefaultFlagValue(uint32_t new_value) {
   ThreadPlanStepInRange::s_default_flag_values = new_value;
 }
 
+bool ThreadPlanStepInRange::StepInDeepBreakpointExplainsStop(
+    lldb::StopInfoSP stop_info_sp) {
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
+  size_t num_step_in_deep_bps = m_step_in_deep_bps.size();
+  if (num_step_in_deep_bps == 0)
+    return false;
+
+  break_id_t bp_site_id = stop_info_sp->GetValue();
+  BreakpointSiteSP bp_site_sp =
+      m_thread.GetProcess()->GetBreakpointSiteList().FindByID(bp_site_id);
+  if (!bp_site_sp)
+    return false;
+
+  bool explains_stop = false;
+  bool hit_step_in_deep_bp = false;
+  for (size_t i = 0; i < num_step_in_deep_bps && hit_step_in_deep_bp == false;
+       i++) {
+    if (bp_site_sp->IsBreakpointAtThisSite(m_step_in_deep_bps[i])) {
+      // We've hit a step in deep breakpoint, see if it is the only breakpoint
+      // at this site:
+      explains_stop = true;
+      hit_step_in_deep_bp = true;
+      size_t num_owners = bp_site_sp->GetNumberOfOwners();
+
+      // If all the owners are internal, then we are probably just stepping over
+      // this range from multiple threads,
+      // or multiple frames, so we want to continue.  If one is not internal,
+      // then we should not explain the stop,
+      // and let the user breakpoint handle the stop.
+      // Of course, if there's only one owner, it's us so we don't need to
+      // check.
+
+      if (num_owners == 1)
+        continue;
+
+      for (size_t i = 0; i < num_owners; i++) {
+        BreakpointLocationSP owner_loc_sp(bp_site_sp->GetOwnerAtIndex(i));
+        Breakpoint &owner_bp(owner_loc_sp->GetBreakpoint());
+        if (owner_loc_sp->ValidForThisThread(&GetThread()) &&
+            !owner_bp.IsInternal()) {
+          explains_stop = false;
+          break;
+        }
+      }
+      if (log)
+        log->Printf("ThreadPlanStepRange::StepInDeepBreakpointExplainsStop - "
+                    "Hit step in deep breakpoint %d which has %zu owners - "
+                    "explains stop: %u.",
+                    m_step_in_deep_bps[i], num_owners, explains_stop);
+    }
+  }
+
+  // For now, if we trigger one of our "step in deep" breakpoints we delete them
+  // all:
+  if (hit_step_in_deep_bp) {
+    ClearStepInDeepBreakpoints();
+  }
+
+  return explains_stop;
+}
+
+void ThreadPlanStepInRange::ClearStepInDeepBreakpoints() {
+  size_t num_step_in_deep_bps = m_step_in_deep_bps.size();
+  for (size_t i = 0; i < num_step_in_deep_bps; i++) {
+    GetTarget().RemoveBreakpointByID(m_step_in_deep_bps[i]);
+  }
+  m_step_in_deep_bps.clear();
+}
+
 bool ThreadPlanStepInRange::FrameMatchesAvoidCriteria() {
   StackFrame *frame = GetThread().GetStackFrameAtIndex(0).get();
 
   // Check the library list first, as that's cheapest:
-  bool libraries_say_avoid = false;
-
   FileSpecList libraries_to_avoid(GetThread().GetLibrariesToAvoid());
   size_t num_libraries = libraries_to_avoid.GetSize();
-  if (num_libraries > 0) {
-    SymbolContext sc(frame->GetSymbolContext(eSymbolContextModule));
-    FileSpec frame_library(sc.module_sp->GetFileSpec());
-
-    if (frame_library) {
-      for (size_t i = 0; i < num_libraries; i++) {
-        const FileSpec &file_spec(libraries_to_avoid.GetFileSpecAtIndex(i));
-        if (FileSpec::Equal(file_spec, frame_library, false)) {
-          libraries_say_avoid = true;
-          break;
-        }
+  bool libraries_say_avoid = false;
+  SymbolContext sc(frame->GetSymbolContext(eSymbolContextModule));
+  FileSpec frame_library(sc.module_sp->GetFileSpec());
+
+  if (frame_library) {
+    for (size_t i = 0; i < num_libraries; i++) {
+      const FileSpec &file_spec(libraries_to_avoid.GetFileSpecAtIndex(i));
+      if (FileSpec::Equal(file_spec, frame_library, false)) {
+        libraries_say_avoid = true;
+        break;
       }
     }
   }
@@ -378,56 +456,137 @@ bool ThreadPlanStepInRange::DefaultShouldStopHereCallback(
     ThreadPlan *current_plan, Flags &flags, FrameComparison operation,
     void *baton) {
   bool should_stop_here = true;
-  StackFrame *frame = current_plan->GetThread().GetStackFrameAtIndex(0).get();
-  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
 
   // First see if the ThreadPlanShouldStopHere default implementation thinks we
   // should get out of here:
   should_stop_here = ThreadPlanShouldStopHere::DefaultShouldStopHereCallback(
       current_plan, flags, operation, baton);
   if (!should_stop_here)
-    return should_stop_here;
+    return false;
 
   if (should_stop_here && current_plan->GetKind() == eKindStepInRange &&
       operation == eFrameCompareYounger) {
     ThreadPlanStepInRange *step_in_range_plan =
         static_cast<ThreadPlanStepInRange *>(current_plan);
-    if (step_in_range_plan->m_step_into_target) {
+    should_stop_here =
+        step_in_range_plan->DefaultShouldStopHereImpl(flags, !should_stop_here);
+
+    //        if (should_stop_here)
+    //        {
+    //            ThreadPlanStepInRange *step_in_range_plan =
+    //            static_cast<ThreadPlanStepInRange *> (current_plan);
+    //            // Don't log the should_step_out here, it's easier to do it in
+    //            FrameMatchesAvoidCriteria.
+    //            should_stop_here =
+    //            !step_in_range_plan->FrameMatchesAvoidCriteria ();
+    //        }
+  }
+
+  return should_stop_here;
+}
+
+bool ThreadPlanStepInRange::DefaultShouldStopHereImpl(Flags &flags,
+                                                      bool should_step_out) {
+  StackFrame *frame = GetThread().GetStackFrameAtIndex(0).get();
+  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
+
+  if (m_step_into_target) {
+    SymbolContext sc = frame->GetSymbolContext(
+        eSymbolContextFunction | eSymbolContextBlock | eSymbolContextSymbol);
+    if (sc.symbol != NULL) {
       SymbolContext sc = frame->GetSymbolContext(
           eSymbolContextFunction | eSymbolContextBlock | eSymbolContextSymbol);
       if (sc.symbol != nullptr) {
         // First try an exact match, since that's cheap with ConstStrings.  Then
         // do a strstr compare.
-        if (step_in_range_plan->m_step_into_target == sc.GetFunctionName()) {
-          should_stop_here = true;
+        if (m_step_into_target == sc.GetFunctionName()) {
+          should_step_out = false;
         } else {
-          const char *target_name =
-              step_in_range_plan->m_step_into_target.AsCString();
+          const char *target_name = m_step_into_target.AsCString();
           const char *function_name = sc.GetFunctionName().AsCString();
 
           if (function_name == nullptr)
-            should_stop_here = false;
+            should_step_out = true;
           else if (strstr(function_name, target_name) == nullptr)
-            should_stop_here = false;
+            should_step_out = true;
         }
-        if (log && !should_stop_here)
+        if (log && should_step_out)
           log->Printf("Stepping out of frame %s which did not match step into "
                       "target %s.",
                       sc.GetFunctionName().AsCString(),
-                      step_in_range_plan->m_step_into_target.AsCString());
+                      m_step_into_target.AsCString());
+      } else {
+        const char *target_name = m_step_into_target.AsCString();
+        const char *function_name = sc.GetFunctionName().AsCString();
+
+        if (function_name == NULL)
+          should_step_out = true;
+        else if (strstr(function_name, target_name) == NULL)
+          should_step_out = true;
       }
+      if (log && should_step_out)
+        log->Printf(
+            "Stepping out of frame %s which did not match step into target %s.",
+            sc.GetFunctionName().AsCString(), m_step_into_target.AsCString());
     }
+  }
 
-    if (should_stop_here) {
-      ThreadPlanStepInRange *step_in_range_plan =
-          static_cast<ThreadPlanStepInRange *>(current_plan);
-      // Don't log the should_step_out here, it's easier to do it in
-      // FrameMatchesAvoidCriteria.
-      should_stop_here = !step_in_range_plan->FrameMatchesAvoidCriteria();
-    }
+  if (!should_step_out) {
+    // Don't log the should_step_out here, it's easier to do it in
+    // FrameMatchesAvoidRegexp.
+    should_step_out = FrameMatchesAvoidCriteria();
   }
 
-  return should_stop_here;
+  if (should_step_out) {
+    // We are going to step out, but first let's examine the function we are
+    // stepping past to see if it tells us
+    // about any interesting places we could stop while running it.  For
+    // instance, if we can tell from the signature
+    // that we're being passed a function pointer that points to user code,
+    // we'll prospectively stop there.
+    // We only know how to do this for Swift at present.
+    // FIXME: We could probably do this for C++ mangled names as well, if we
+    // could come up with some
+    // good heuristic to identify function pointers in the mangled function
+    // arguments.
+
+    SymbolContext sc = frame->GetSymbolContext(eSymbolContextSymbol);
+    if (sc.symbol) {
+      Mangled mangled_name = sc.symbol->GetMangled();
+      if (mangled_name.GuessLanguage() == lldb::eLanguageTypeSwift) {
+        ProcessSP process_sp(GetThread().GetProcess());
+        SwiftLanguageRuntime *swift_runtime =
+            process_sp->GetSwiftLanguageRuntime();
+        if (swift_runtime) {
+          std::vector<Address> interesting_addresses;
+          swift_runtime->FindFunctionPointersInCall(*frame,
+                                                    interesting_addresses);
+          size_t num_addresses = interesting_addresses.size();
+          if (num_addresses) {
+            // Run through the addresses we found, make sure they have debug
+            // info, and if so set breakpoints
+            // on all these addresses.
+            for (size_t i = 0; i < num_addresses; i++) {
+              LineEntry line_entry;
+              if (interesting_addresses[i].CalculateSymbolContextLineEntry(
+                      line_entry)) {
+                // It has debug information, use it:
+                const bool internal = true;
+                const bool hardware = false;
+                BreakpointSP bkpt_sp = GetTarget().CreateBreakpoint(
+                    interesting_addresses[i], internal, hardware);
+                bkpt_sp->SetThreadID(GetThread().GetID());
+                m_step_in_deep_bps.push_back(bkpt_sp->GetID());
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  // We're returning an answer to "Should Stop Here" which is the opposite of
+  // "should_step_out".
+  return !should_step_out;
 }
 
 bool ThreadPlanStepInRange::DoPlanExplainsStop(Event *event_ptr) {
@@ -462,7 +621,13 @@ bool ThreadPlanStepInRange::DoPlanExplainsStop(Event *event_ptr) {
       StopReason reason = stop_info_sp->GetStopReason();
 
       if (reason == eStopReasonBreakpoint) {
-        if (NextRangeBreakpointExplainsStop(stop_info_sp)) {
+        bool hit_next_range_bp = NextRangeBreakpointExplainsStop(stop_info_sp);
+        bool hit_step_in_deep_bp =
+            StepInDeepBreakpointExplainsStop(stop_info_sp);
+        if (hit_next_range_bp || hit_step_in_deep_bp) {
+          if (hit_step_in_deep_bp)
+            SetPlanComplete();
+
           return_value = true;
         }
       } else if (IsUsuallyUnexplainedStopReason(reason)) {
diff --git a/source/Target/ThreadPlanStepOut.cpp b/source/Target/ThreadPlanStepOut.cpp
index 6b6ed06e9..d5bca312c 100644
--- a/source/Target/ThreadPlanStepOut.cpp
+++ b/source/Target/ThreadPlanStepOut.cpp
@@ -16,13 +16,16 @@
 #include "lldb/Core/Value.h"
 #include "lldb/Core/ValueObjectConstResult.h"
 #include "lldb/Symbol/Block.h"
+#include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/Function.h"
 #include "lldb/Symbol/Symbol.h"
 #include "lldb/Symbol/Type.h"
+#include "lldb/Symbol/VariableList.h"
 #include "lldb/Target/ABI.h"
 #include "lldb/Target/Process.h"
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/StopInfo.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Target/ThreadPlanStepOverRange.h"
 #include "lldb/Target/ThreadPlanStepThrough.h"
@@ -45,8 +48,11 @@ ThreadPlanStepOut::ThreadPlanStepOut(
                  run_vote),
       ThreadPlanShouldStopHere(this), m_step_from_insn(LLDB_INVALID_ADDRESS),
       m_return_bp_id(LLDB_INVALID_BREAK_ID),
-      m_return_addr(LLDB_INVALID_ADDRESS), m_stop_others(stop_others),
-      m_immediate_step_from_function(nullptr),
+      m_return_addr(LLDB_INVALID_ADDRESS),
+      m_swift_error_return(),
+      m_swift_error_check_after_return(false),
+      m_stop_others(stop_others), m_immediate_step_from_function(nullptr),
+      m_is_swift_error_value(false),
       m_calculate_return_value(gather_return_value) {
   SetFlagsToDefault();
   SetupAvoidNoDebug(step_out_avoids_code_without_debug_info);
@@ -132,6 +138,41 @@ ThreadPlanStepOut::ThreadPlanStepOut(
       }
     }
   }
+
+  // If we are about to step out of a swift frame, we need to store away the
+  // location that swift will use for
+  // any error return:
+  // FIXME: I'm only doing this if you are stepping out ONE frame at present.
+  // I'll have to change the stepping
+  // code so that it first runs to the frame we are stepping out FROM, then
+  // capture the error return pointer, then
+  // step out.  That's more than I have time to do right now.
+
+  if (frame_idx == 0) {
+    bool stepping_from_swift = false;
+    StackFrameSP frame_sp = m_thread.GetStackFrameAtIndex(0);
+    Symbol *symbol = frame_sp->GetSymbolContext(eSymbolContextSymbol).symbol;
+    if (symbol) {
+      Mangled symbol_mangled = symbol->GetMangled();
+      if (symbol_mangled.GuessLanguage() == eLanguageTypeSwift)
+        stepping_from_swift = true;
+    } else {
+      CompileUnit *comp_unit =
+          frame_sp->GetSymbolContext(eSymbolContextCompUnit).comp_unit;
+      if (comp_unit && comp_unit->GetLanguage() == eLanguageTypeSwift)
+        stepping_from_swift = true;
+    }
+
+    if (stepping_from_swift) {
+      SwiftLanguageRuntime *swift_runtime =
+          m_thread.GetProcess()->GetSwiftLanguageRuntime();
+      if (swift_runtime) {
+        m_swift_error_return =
+            swift_runtime->GetErrorReturnLocationBeforeReturn(frame_sp,
+                                                              m_swift_error_check_after_return);
+      }
+    }
+  }
 }
 
 void ThreadPlanStepOut::SetupAvoidNoDebug(
@@ -261,8 +302,8 @@ bool ThreadPlanStepOut::DoPlanExplainsStop(Event *event_ptr) {
         }
 
         if (done) {
+          CalculateReturnValue();
           if (InvokeShouldStopHereCallback(eFrameCompareOlder)) {
-            CalculateReturnValue();
             SetPlanComplete();
           }
         }
@@ -325,12 +366,21 @@ bool ThreadPlanStepOut::ShouldStop(Event *event_ptr) {
   // and we are done.
 
   if (done) {
+    CalculateReturnValue();
     if (InvokeShouldStopHereCallback(eFrameCompareOlder)) {
-      CalculateReturnValue();
       SetPlanComplete();
     } else {
       m_step_out_further_plan_sp =
           QueueStepOutFromHerePlan(m_flags, eFrameCompareOlder);
+      if (m_step_out_further_plan_sp->GetKind() == eKindStepOut)
+      {
+        // If we are planning to step out further, then the frame we are going
+        // to step out to is about to go away, so we need to reset the frame
+        // we are stepping out to to the one our step out plan is aiming for.
+        ThreadPlanStepOut *as_step_out
+          = static_cast<ThreadPlanStepOut *>(m_step_out_further_plan_sp.get());
+        m_step_out_to_id = as_step_out->m_step_out_to_id;
+      }
       done = false;
     }
   }
@@ -457,12 +507,44 @@ bool ThreadPlanStepOut::QueueInlinedStepPlan(bool queue_now) {
 }
 
 void ThreadPlanStepOut::CalculateReturnValue() {
-  if (m_return_valobj_sp)
+  if (!m_calculate_return_value)
     return;
 
-  if (!m_calculate_return_value)
+  if (m_return_valobj_sp)
     return;
+  // First check if we have an error return address, and if that pointer
+  // contains a valid error return, grab it:
+  SwiftLanguageRuntime *swift_runtime =
+        m_thread.GetProcess()->GetSwiftLanguageRuntime();
+
+  if (swift_runtime) {
+    // In some ABI's the error is in a memory location in the caller's frame
+    // and we need to fetch that location from the frame before we leave the
+    // throwing frame.  In others, the actual error address is in a register,
+    // so we need to fetch the value of the address AFTER leaving the frame.
+    if (m_swift_error_check_after_return)
+    {
+      StackFrameSP frame_sp = m_thread.GetStackFrameAtIndex(0);
+      if (!frame_sp)
+          return;
+
+      m_swift_error_return =
+            swift_runtime->GetErrorReturnLocationAfterReturn(frame_sp);
+    }
+    if (m_swift_error_return) {
+      ConstString name("swift_thrown_error");
+
+      m_return_valobj_sp = swift_runtime->CalculateErrorValueObjectFromValue(
+          m_swift_error_return.getValue(), name, true);
+      // Even if we couldn't figure out what the error return was, we
+      // were told there was an error, so don't show the user a false return value
+      // instead.
+      m_is_swift_error_value = true;
+      return;
+    }
+  }
 
+  // We don't have a swift error, so let's compute the actual return:
   if (m_immediate_step_from_function != nullptr) {
     CompilerType return_compiler_type =
         m_immediate_step_from_function->GetCompilerType()
diff --git a/source/Target/ThreadPlanStepRange.cpp b/source/Target/ThreadPlanStepRange.cpp
index 09e606f49..210f0ecf8 100644
--- a/source/Target/ThreadPlanStepRange.cpp
+++ b/source/Target/ThreadPlanStepRange.cpp
@@ -413,24 +413,25 @@ StateType ThreadPlanStepRange::GetPlanRunState() {
 }
 
 bool ThreadPlanStepRange::MischiefManaged() {
-  // If we have pushed some plans between ShouldStop & MischiefManaged, then
-  // we're not done...
-  // I do this check first because we might have stepped somewhere that will
-  // fool InRange into
-  // thinking it needs to step past the end of that line.  This happens, for
-  // instance, when stepping
-  // over inlined code that is in the middle of the current line.
-
-  if (!m_no_more_plans)
-    return false;
-
   bool done = true;
   if (!IsPlanComplete()) {
-    if (InRange()) {
+    // If we have pushed some plans between ShouldStop & MischiefManaged, then
+    // we're not done...
+    // I do this check first because we might have stepped somewhere that will
+    // fool InRange into
+    // thinking it needs to step past the end of that line.  This happens, for
+    // instance, when stepping
+    // over inlined code that is in the middle of the current line.
+
+    if (!m_no_more_plans)
       done = false;
-    } else {
-      FrameComparison frame_order = CompareCurrentFrameToStartFrame();
-      done = (frame_order != eFrameCompareOlder) ? m_no_more_plans : true;
+    else {
+      if (InRange()) {
+        done = false;
+      } else {
+        FrameComparison frame_order = CompareCurrentFrameToStartFrame();
+        done = (frame_order != eFrameCompareOlder) ? m_no_more_plans : true;
+      }
     }
   }
 
diff --git a/source/Target/ThreadPlanStepThrough.cpp b/source/Target/ThreadPlanStepThrough.cpp
index 46aadb00f..9be23fe69 100644
--- a/source/Target/ThreadPlanStepThrough.cpp
+++ b/source/Target/ThreadPlanStepThrough.cpp
@@ -17,6 +17,7 @@
 #include "lldb/Target/ObjCLanguageRuntime.h"
 #include "lldb/Target/Process.h"
 #include "lldb/Target/RegisterContext.h"
+#include "lldb/Target/SwiftLanguageRuntime.h"
 #include "lldb/Target/Target.h"
 #include "lldb/Utility/Log.h"
 #include "lldb/Utility/Stream.h"
@@ -29,7 +30,6 @@ using namespace lldb_private;
 // through it
 // If it is the beginning of the prologue of a function, step through that as
 // well.
-// FIXME: At present only handles DYLD trampolines.
 //----------------------------------------------------------------------
 
 ThreadPlanStepThrough::ThreadPlanStepThrough(Thread &thread,
@@ -98,6 +98,13 @@ void ThreadPlanStepThrough::LookForPlanToStepThroughFromCurrentPC() {
       m_sub_plan_sp =
           objc_runtime->GetStepThroughTrampolinePlan(m_thread, m_stop_others);
   }
+  if (!m_sub_plan_sp.get()) {
+    SwiftLanguageRuntime *swift_runtime =
+        m_thread.GetProcess()->GetSwiftLanguageRuntime();
+    if (swift_runtime)
+      m_sub_plan_sp =
+          swift_runtime->GetStepThroughTrampolinePlan(m_thread, m_stop_others);
+  }
 
   Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));
   if (log) {
diff --git a/source/lldb.cpp b/source/lldb.cpp
index efdcef8f0..550ba7a20 100644
--- a/source/lldb.cpp
+++ b/source/lldb.cpp
@@ -8,11 +8,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "lldb/lldb-private.h"
+#include "llvm/ADT/StringExtras.h"
 
 using namespace lldb;
 using namespace lldb_private;
 
 #include "clang/Basic/Version.h"
+#include "swift/Basic/Version.h"
 
 #ifdef HAVE_SVN_VERSION_INC
 #  include "SVNVersion.inc"
@@ -26,7 +28,7 @@ static const char *GetLLDBRevision() {
 #ifdef LLDB_REVISION
   return LLDB_REVISION;
 #else
-  return NULL;
+  return nullptr;
 #endif
 }
 
@@ -38,6 +40,15 @@ static const char *GetLLDBRepository() {
 #endif
 }
 
+#if LLDB_IS_BUILDBOT_BUILD
+static std::string GetBuildDate() {
+#if defined(LLDB_BUILD_DATE)
+  return std::string(LLDB_BUILD_DATE);
+#else
+  return std::string();
+#endif
+}
+#endif
 
 #define QUOTE(str) #str
 #define EXPAND_AND_QUOTE(str) QUOTE(str)
@@ -67,6 +78,21 @@ const char *lldb_private::GetVersion() {
       g_version_str += ")";
     }
 
+#if LLDB_IS_BUILDBOT_BUILD
+    std::string build_date = GetBuildDate();
+    if(!build_date.empty())
+      g_version_str += " (buildbot " + build_date + ")";
+#endif
+
+    auto const swift_version = swift::version::getSwiftNumericVersion();
+    g_version_str += "\n  Swift-";
+    g_version_str += llvm::utostr(swift_version.first) + ".";
+    g_version_str += llvm::utostr(swift_version.second);
+    std::string swift_rev(swift::version::getSwiftRevision());
+    if (swift_rev.length() > 0) {
+      g_version_str += " (revision " + swift_rev + ")";
+    }
+
     std::string clang_rev(clang::getClangRevision());
     if (clang_rev.length() > 0) {
       g_version_str += "\n  clang revision ";
@@ -77,7 +103,6 @@ const char *lldb_private::GetVersion() {
       g_version_str += "\n  llvm revision ";
       g_version_str += llvm_rev;
     }
-      
   }
   return g_version_str.c_str();
 }
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 7b26f5907..3d219a2a0 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -9,3 +9,4 @@ if (LLDB_CAN_USE_LLDB_SERVER)
   add_subdirectory(lldb-server)
 endif()
 add_subdirectory(intel-mpx)
+add_subdirectory(repl/swift)
diff --git a/tools/driver/Driver.cpp b/tools/driver/Driver.cpp
index 102ba775d..07fd63a92 100644
--- a/tools/driver/Driver.cpp
+++ b/tools/driver/Driver.cpp
@@ -452,6 +452,8 @@ void Driver::OptionData::Clear() {
   m_print_python_path = false;
   m_use_external_editor = false;
   m_wait_for = false;
+  m_repl = false;
+  m_repl_options.erase();
   m_process_name.erase();
   m_batch = false;
   m_after_crash_commands.clear();
diff --git a/tools/lldb-server/CMakeLists.txt b/tools/lldb-server/CMakeLists.txt
index f8c57cb94..b73ba2bf6 100644
--- a/tools/lldb-server/CMakeLists.txt
+++ b/tools/lldb-server/CMakeLists.txt
@@ -24,7 +24,13 @@ endif ()
 
 include_directories(../../source)
 
+
+
 set(LLDB_SYSTEM_LIBS)
+
+list(APPEND LLDB_SYSTEM_LIBS uuid)
+list(APPEND LLDB_SYSTEM_LIBS cmark)
+
 if (NOT LLDB_DISABLE_LIBEDIT)
   list(APPEND LLDB_SYSTEM_LIBS edit)
 endif()
@@ -77,16 +83,32 @@ add_lldb_tool(lldb-server INCLUDE_IN_FRAMEWORK
     LLDBServerUtilities.cpp
 
     LINK_LIBS
+      clangAnalysis
+      clangIndex
       lldbBase
       lldbCore
       lldbHost
       lldbInitialization
       lldbInterpreter
+      swiftMarkup
+      swiftLLVMPasses
+      swiftOption
+      swiftParseSIL
+      swiftSyntax
       ${LLDB_PLUGINS}
       ${LLDB_SYSTEM_LIBS}
 
     LINK_COMPONENTS
+      BitWriter
+      BitReader
+      Coverage
+      Instrumentation
+      Object
+      ObjCARCOpts
+      Option
+      ProfileData
       Support
+      TransformUtils
 )
 
 target_link_libraries(lldb-server ${LLDB_SYSTEM_LIBS})
diff --git a/tools/repl/swift/CMakeLists.txt b/tools/repl/swift/CMakeLists.txt
index e69de29bb..dbb2c9c33 100644
--- a/tools/repl/swift/CMakeLists.txt
+++ b/tools/repl/swift/CMakeLists.txt
@@ -0,0 +1,70 @@
+set(LLVM_NO_RTTI 1)
+
+include(AddLLVM)
+include(SwiftAddCustomCommandTarget)
+
+set(output_dir "${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin")
+set(module_cache_dir "${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/repl_swift_module_cache")
+
+if(NOT LLDB_BUILT_STANDALONE)
+  set(swift_depends swift swift-stdlib)
+endif()
+
+if(NOT LLDB_SWIFTC)
+  if(NOT LLDB_BUILT_STANDALONE)
+    set(LLDB_SWIFTC $<TARGET_FILE:swift>c)
+  else()
+    set(LLDB_SWIFTC /usr/bin/swiftc)
+  endif()
+endif()
+
+set(swift_compile_cmd "${LLDB_SWIFTC}"
+                      -resource-dir "/usr/lib/swift"
+                      -module-cache-path "${module_cache_dir}")
+
+if(CMAKE_CROSSCOMPILING)
+  set(swift_compile_cmd ${swift_compile_cmd} -target "${LLVM_HOST_TRIPLE}" -sdk "${CMAKE_SYSROOT}")
+  if(CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN)
+    set(swift_compile_cmd ${swift_compile_cmd} -tools-directory "${CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN}")
+  endif()
+endif()
+
+if (CMAKE_SYSTEM_NAME MATCHES "Linux")
+  set(swift_compile_cmd ${swift_compile_cmd} -Xlinker -rpath -Xlinker \$ORIGIN/../lib/swift/linux)
+endif()
+
+add_custom_command_target(
+    unused_var
+    COMMAND "${swift_compile_cmd}"
+            -o "${output_dir}/repl_swift"
+            "${CMAKE_CURRENT_SOURCE_DIR}/main.swift"
+    OUTPUT "${output_dir}/repl_swift"
+    VERBATIM
+    ALL
+    CUSTOM_TARGET_NAME repl_swift
+    DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/main.swift"
+            create_swift_module_dir
+            ${swift_depends})
+
+# Ensure we get a fresh, clean module cache for the swift repl run
+# before we build repl_swift.
+
+# Note we need to support cmake 2.8, so I could not use named
+# add_custom_command entries here.  This will force delete/create
+# of the module cache each run of the build.  Not a big deal, but
+# if we ever require cmake 3, changing these to add_custom_command
+# would do this if repl_swift was out of date.
+add_custom_target(
+  delete_swift_module_dir
+  COMMAND ${CMAKE_COMMAND} -E remove_directory "${module_cache_dir}"
+  )
+
+add_custom_target(
+  create_swift_module_dir
+  COMMAND ${CMAKE_COMMAND} -E make_directory "${module_cache_dir}"
+  DEPENDS delete_swift_module_dir
+  )
+
+install(
+  PROGRAMS "${output_dir}/repl_swift"
+  DESTINATION bin)
diff --git a/tools/repl/swift/main.c b/tools/repl/swift/main.c
index e69de29bb..69db2fac2 100644
--- a/tools/repl/swift/main.c
+++ b/tools/repl/swift/main.c
@@ -0,0 +1,67 @@
+// main.c
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+// -----------------------------------------------------------------------------
+
+#ifdef __APPLE__
+#include <mach/mach_time.h>
+#endif
+
+#ifdef __APPLE__
+#include <dlfcn.h>
+#endif
+
+#define REPL_MAIN _TF10repl_swift9repl_mainFT_Si
+
+int REPL_MAIN() {
+  return 0;
+}
+
+int main() {
+#ifdef __APPLE__
+  // Force loading of libswiftCore.dylib, which is not linked at build time.
+  dlopen("@rpath/libswiftCore.dylib", RTLD_LAZY);
+#endif
+  
+#ifdef __APPLE__
+  // This code will be run when running the REPL. A breakpoint will be set at
+  // "repl_main" and we will hit that breakpoint and then allow REPL statements
+  // to be evaluated. Since LLDB allows process control, the user can accidentally
+  // continue the target:
+  //
+  // 1> :c
+  //
+  // So to safeguard against this we hit the breakpoint over and over. If the user
+  // detaches:
+  //
+  // 1> :process detach
+  //
+  // we want this program to exit without consuming 100% CPU, so we detect any loops
+  // that take less than 100us and if we get three of them in a row, we exit.
+
+  struct mach_timebase_info TimebaseInfo;
+  mach_timebase_info(&TimebaseInfo);
+  int SubsequentShort = 0;
+  while (SubsequentShort < 3) {
+    const uint64_t Start = mach_absolute_time();
+    REPL_MAIN();
+    const uint64_t End = mach_absolute_time();
+    const uint64_t ElapsedTicks = End - Start;
+    const uint64_t ElapsedNano = (ElapsedTicks * (uint64_t)(TimebaseInfo.numer)) / (uint64_t)(TimebaseInfo.denom);
+    if (ElapsedNano < 100000) {
+      SubsequentShort += 1;
+    } else {
+      SubsequentShort = 0;
+    }
+  }
+#else
+  REPL_MAIN();
+#endif
+}
diff --git a/tools/repl/swift/main.swift b/tools/repl/swift/main.swift
index e69de29bb..5c400df53 100644
--- a/tools/repl/swift/main.swift
+++ b/tools/repl/swift/main.swift
@@ -0,0 +1,61 @@
+// main.swift
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+// -----------------------------------------------------------------------------
+
+// The following #if can be removed once the fix for rdar://problem/23332517
+// lands in an external Xcode build.
+#if XCODE_BUILD_ME || !_runtime(_ObjC)
+#if _runtime(_ObjC)
+import Darwin
+#endif
+
+@discardableResult
+func repl_main() -> Int
+{
+    return 0
+}
+
+#if _runtime(_ObjC)
+// This code will be run when running the REPL. A breakpoint will be set at
+// "repl_main" and we will hit that breakpoint and then allow REPL statements
+// to be evaluated. Since LLDB allows process control, the user can accidentally
+// continue the target:
+//
+// 1> :c
+//
+// So to safeguard against this we hit the breakpoint over and over. If the user
+// detaches:
+//
+// 1> :process detach
+//
+// we want this program to exit without consuming 100% CPU, so we detect any loops
+// that take less than 100us and if we get three of them in a row, we exit.
+
+var timebase_info = mach_timebase_info(numer: 0, denom: 0)
+Darwin.mach_timebase_info(&timebase_info)
+var subsequent_short = 0
+while subsequent_short < 3 {
+    var start = Darwin.mach_absolute_time()
+    repl_main()
+    var end = Darwin.mach_absolute_time()
+    var elapsedTicks = end - start
+    var elapsedNano = (elapsedTicks * UInt64(timebase_info.numer)) / UInt64(timebase_info.denom)
+    if elapsedNano < 100000 {
+        subsequent_short += 1
+    } else {
+        subsequent_short = 0
+    }
+}
+#else
+repl_main()
+#endif
+#endif
+

diff --git a/Sources/Commands/UserToolchain.swift b/Sources/Commands/UserToolchain.swift
index 17c96d9..65be20d 100644
--- a/Sources/Commands/UserToolchain.swift
+++ b/Sources/Commands/UserToolchain.swift
@@ -44,11 +44,51 @@ struct UserToolchain: Toolchain {
     let swiftPlatformArgs: [String] = []
 #endif
 
+    /// Lookup an executable path from environment variable value. This method searches in the following order:
+    /// * If env value is a valid abolsute path, return it.
+    /// * If env value is relative path, first try to locate it in current working directory.
+    /// * Otherwise, in provided search paths.
+    ///
+    /// - Parameters:
+    ///   - value: The value from environment variable.
+    ///   - cwd: The current working directory to look in.
+    ///   - searchPath: The addtional search path to look in if not found in cwd.
+    /// - Returns: Valid path to executable if present, otherwise nil.
+    static func lookupExecutablePath(inEnvValue value: String?, currentWorkingDirectory cwd: AbsolutePath, searchPaths: [AbsolutePath]) -> AbsolutePath? {
+        // We should have a value to continue.
+        guard let value = value, !value.isEmpty else {
+            return nil
+        }
+        // We have a value, but it could be an absolute or a relative path.
+        let path = AbsolutePath(value, relativeTo: cwd)
+        if exists(path) {
+            return path
+        }
+        // Ensure the value is not a path.
+        guard !value.characters.contains("/") else {
+            return nil
+        }
+        // Try to locate in search paths.
+        for path in searchPaths {
+            let exec = path.appending(component: value)
+            if exists(exec) {
+                return exec
+            }
+        }
+        return nil
+    }
+
     init() throws {
+        // Compute search paths from PATH variable.
+        let envSearchPaths = (getenv("PATH") ?? "").characters.split(separator: ":").map(String.init).map(AbsolutePath.init)
+
+        func lookup(env: String) -> AbsolutePath? {
+            return UserToolchain.lookupExecutablePath(inEnvValue: getenv(env), currentWorkingDirectory: currentWorkingDirectory, searchPaths: envSearchPaths)
+        }
+
         // Find the Swift compiler, looking first in the environment.
-        if let value = getenv("SWIFT_EXEC"), !value.isEmpty {
-            // We have a value, but it could be an absolute or a relative path.
-            swiftCompiler = AbsolutePath(value, relativeTo: currentWorkingDirectory)
+        if let value = lookup(env: "SWIFT_EXEC") {
+            swiftCompiler = value
         }
         else {
             // No value in env, so look for `swiftc` alongside our own binary.
@@ -63,9 +103,8 @@ struct UserToolchain: Toolchain {
         }
         
         // Find the Clang compiler, looking first in the environment.
-        if let value = getenv("CC"), !value.isEmpty {
-            // We have a value, but it could be an absolute or a relative path.
-            clangCompiler = AbsolutePath(value, relativeTo: currentWorkingDirectory)
+        if let value = lookup(env: "CC") {
+            clangCompiler = value
         }
         else {
             // No value in env, so search for `clang`.
@@ -84,9 +123,8 @@ struct UserToolchain: Toolchain {
         
         // Find the default SDK (on macOS only).
       #if os(macOS)
-        if let value = getenv("SYSROOT"), !value.isEmpty {
-            // We have a value, but it could be an absolute or a relative path.
-            defaultSDK = AbsolutePath(value, relativeTo: currentWorkingDirectory)
+        if let value = UserToolchain.lookupExecutablePath(inEnvValue: getenv("SYSROOT"), currentWorkingDirectory: currentWorkingDirectory, searchPaths: []) {
+            defaultSDK = value
         }
         else {
             // No value in env, so search for it.
diff --git a/Tests/CommandsTests/UserToolchainTests.swift b/Tests/CommandsTests/UserToolchainTests.swift
new file mode 100644
index 0000000..62fdf4e
--- /dev/null
+++ b/Tests/CommandsTests/UserToolchainTests.swift
@@ -0,0 +1,52 @@
+/*
+ This source file is part of the Swift.org open source project
+
+ Copyright 2016 Apple Inc. and the Swift project authors
+ Licensed under Apache License v2.0 with Runtime Library Exception
+
+ See http://swift.org/LICENSE.txt for license information
+ See http://swift.org/CONTRIBUTORS.txt for Swift project authors
+*/
+
+import XCTest
+
+import Basic
+import TestSupport
+@testable import Commands
+
+final class UserToolchainTests: XCTestCase {
+
+    func testExecutableLookup() throws {
+        mktmpdir { path in
+
+            let pathEnv1 = path.appending(component: "pathEnv1")
+            try localFileSystem.createDirectory(pathEnv1)
+            let pathEnvClang = pathEnv1.appending(component: "clang")
+            try localFileSystem.writeFileContents(pathEnvClang, bytes: "")
+            let pathEnv = [path.appending(component: "pathEnv2"), pathEnv1]
+
+            // nil and empty string should fail.
+            XCTAssertNil(UserToolchain.lookupExecutablePath(inEnvValue: nil, currentWorkingDirectory: path, searchPaths: pathEnv))
+            XCTAssertNil(UserToolchain.lookupExecutablePath(inEnvValue: "", currentWorkingDirectory: path, searchPaths: pathEnv))
+
+            // Absolute path to a binary should return it.
+            var exec = UserToolchain.lookupExecutablePath(inEnvValue: pathEnvClang.asString, currentWorkingDirectory: path, searchPaths: pathEnv)
+            XCTAssertEqual(exec, pathEnvClang)
+
+            // This should lookup from PATH variable since executable is not present in cwd.
+            exec = UserToolchain.lookupExecutablePath(inEnvValue: "clang", currentWorkingDirectory: path, searchPaths: pathEnv)
+            XCTAssertEqual(exec, pathEnvClang)
+
+            // Create the binary relative to cwd.
+            let clang = path.appending(component: "clang")
+            try localFileSystem.writeFileContents(clang, bytes: "")
+            // We should now find clang which is in cwd.
+            exec = UserToolchain.lookupExecutablePath(inEnvValue: "clang", currentWorkingDirectory: path, searchPaths: pathEnv)
+            XCTAssertEqual(exec, clang)
+        }
+    }
+
+    static var allTests = [
+        ("testExecutableLookup", testExecutableLookup),
+    ]
+}
diff --git a/Tests/CommandsTests/XCTestManifests.swift b/Tests/CommandsTests/XCTestManifests.swift
index c16d2fd..522c3fd 100644
--- a/Tests/CommandsTests/XCTestManifests.swift
+++ b/Tests/CommandsTests/XCTestManifests.swift
@@ -18,6 +18,7 @@ public func allTests() -> [XCTestCaseEntry] {
         testCase(PinsStoreTests.allTests),
         testCase(TestToolTests.allTests),
         testCase(WorkspaceTests.allTests),
+        testCase(UserToolchainTests.allTests),
     ]
 }

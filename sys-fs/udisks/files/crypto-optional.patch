--- a/configure.ac       2020-05-26 15:29:35.000000000 +0200
+++ b/configure.ac       2020-06-17 19:43:11.745141925 +0200
@@ -663,8 +663,15 @@
   if test "x$have_fs" = "xno"; then
     AC_MSG_ERROR([BLOCKDEV FS support requested but header or library not found])
   fi
+fi
 
-  # libblockdev crypto
+# libblockdev crypto
+have_crypto=no
+AC_ARG_ENABLE(crypto,
+              AS_HELP_STRING([--enable-crypto], [enable BLOCKDEV CRYPTO support]),
+             [],
+             [enable_crypto=no])
+if test "x$enable_crypto" = "xyes" && test "x$enable_daemon" = "xyes"; then
   SAVE_CFLAGS=$CFLAGS
   SAVE_LDFLAGS=$LDFLAGS
 
@@ -685,6 +692,7 @@
   fi
 fi
 
+AM_CONDITIONAL(HAVE_CRYPTO, test "x$have_crypto" = "xyes")
 
 # Internationalization
 #
--- a/src/udisksstate.h	2018-11-10 01:22:54.199735914 +0100
+++ b/src/udisksstate.h	2018-11-10 01:08:37.800076237 +0100
@@ -45,6 +45,7 @@
                                                   dev_t          block_device,
                                                   uid_t         *out_uid,
                                                   gboolean      *out_fstab_mount);
+#ifdef HAVE_CRYPTO
 /* unlocked-crypto-dev */
 void           udisks_state_add_unlocked_crypto_dev    (UDisksState   *state,
                                                         dev_t          cleartext_device,
@@ -54,6 +55,7 @@
 dev_t            udisks_state_find_unlocked_crypto_dev (UDisksState   *state,
                                                         dev_t          crypto_device,
                                                         uid_t         *out_uid);
+#endif
 /* loop */
 void             udisks_state_add_loop           (UDisksState   *state,
                                                   const gchar   *device_file,
--- a/src/udisksdaemonutil.c	2018-11-10 01:07:44.893165376 +0100
+++ b/src/udisksdaemonutil.c	2018-11-10 01:09:03.216033830 +0100
@@ -511,7 +511,9 @@
   UDisksPartition *partition = NULL;
   UDisksState *state;
   uid_t setup_by_user;
+#ifdef HAVE_CRYPTO
   UDisksObject *crypto_object;
+#endif
 
   ret = FALSE;
 
@@ -549,6 +549,7 @@
     }
 
   /* LUKS devices */
+#ifdef HAVE_CRYPTO
   crypto_object = udisks_daemon_find_object (daemon, udisks_block_get_crypto_backing_device (block));
   if (crypto_object != NULL)
     {
@@ -567,6 +568,7 @@
         }
       g_object_unref (crypto_object);
     }
+#endif
 
 #ifdef HAVE_MDRAID
   /* MDRaid devices */
--- a/src/udiskslinuxprovider.c   2018-08-07 10:43:26.000000000 +0200
+++ b/src/udiskslinuxprovider.c   2018-11-10 01:48:15.375407269 +0100
@@ -190,12 +190,14 @@
   g_signal_handlers_disconnect_by_func (udisks_daemon_get_fstab_monitor (daemon),
                                         G_CALLBACK (fstab_monitor_on_entry_removed),
                                         provider);
+#ifdef HAVE_CRYPTO
   g_signal_handlers_disconnect_by_func (udisks_daemon_get_crypttab_monitor (daemon),
                                         G_CALLBACK (crypttab_monitor_on_entry_added),
                                         provider);
   g_signal_handlers_disconnect_by_func (udisks_daemon_get_crypttab_monitor (daemon),
                                         G_CALLBACK (crypttab_monitor_on_entry_removed),
                                         provider);
+#endif
 
   if (G_OBJECT_CLASS (udisks_linux_provider_parent_class)->finalize != NULL)
     G_OBJECT_CLASS (udisks_linux_provider_parent_class)->finalize (object);
@@ -707,6 +709,7 @@
                     "entry-removed",
                     G_CALLBACK (fstab_monitor_on_entry_removed),
                     provider);
+#ifdef CRYPTO
   g_signal_connect (udisks_daemon_get_crypttab_monitor (daemon),
                     "entry-added",
                     G_CALLBACK (crypttab_monitor_on_entry_added),
@@ -715,6 +718,7 @@
                     "entry-removed",
                     G_CALLBACK (crypttab_monitor_on_entry_removed),
                     provider);
+#endif
 #ifdef HAVE_LIBMOUNT_UTAB
   g_signal_connect (udisks_daemon_get_utab_monitor (daemon),
                     "entry-added",

@@ -1544,6 +1544,7 @@
   update_all_block_objects (provider);
 }
 
+#ifdef HAVE_CRYPTO
 static void
 crypttab_monitor_on_entry_added (UDisksCrypttabMonitor *monitor,
                                  UDisksCrypttabEntry   *entry,
@@ -1561,6 +1562,7 @@
   UDisksLinuxProvider *provider = UDISKS_LINUX_PROVIDER (user_data);
   update_all_block_objects (provider);
 }
+#endif
 
 #ifdef HAVE_LIBMOUNT
 static void
--- a/src/Makefile.am	2020-06-17 19:50:44.590726228 +0200
+++ b/src/Makefile.am	2020-06-17 19:51:50.579399048 +0200
@@ -72,8 +72,6 @@
 	udiskslinuxpartitiontable.h    udiskslinuxpartitiontable.c             \
 	udiskslinuxfilesystem.h        udiskslinuxfilesystem.c                 \
 	udiskslinuxfilesystemhelpers.h udiskslinuxfilesystemhelpers.c          \
-	udiskslinuxencrypted.h         udiskslinuxencrypted.c                  \
-	udiskslinuxencryptedhelpers.h udiskslinuxencryptedhelpers.c            \
 	udiskslinuxswapspace.h         udiskslinuxswapspace.c                  \
 	udiskslinuxloop.h              udiskslinuxloop.c                       \
 	udiskslinuxdriveobject.h       udiskslinuxdriveobject.c                \
@@ -96,8 +94,6 @@
 	udisksstate.h                  udisksstate.c                           \
 	udisksprivate.h                                                        \
 	udisksfstabentry.h             udisksfstabentry.c                      \
-	udiskscrypttabentry.h          udiskscrypttabentry.c                   \
-	udiskscrypttabmonitor.h        udiskscrypttabmonitor.c                 \
 	udiskslinuxdevice.h            udiskslinuxdevice.c                     \
 	udisksata.h                    udisksata.c                             \
 	udisksmodulemanager.h          udisksmodulemanager.c                   \
@@ -107,6 +103,14 @@
 	$(BUILT_SOURCES)                                                       \
 	$(NULL)
 
+if HAVE_CRYPTO
+libudisks_daemon_la_SOURCES += \
+	udiskslinuxencrypted.h         udiskslinuxencrypted.c                  \
+	udiskslinuxencryptedhelpers.h udiskslinuxencryptedhelpers.c            \
+	udiskscrypttabentry.h          udiskscrypttabentry.c                   \
+	udiskscrypttabmonitor.h        udiskscrypttabmonitor.c
+endif
+
 if HAVE_LIBMOUNT_UTAB
 libudisks_daemon_la_SOURCES +=                                                 \
 	udisksutabentry.h              udisksutabentry.c                       \
--- a/src/udisksdaemon.c	2020-06-17 20:27:01.794409968 +0200
+++ b/src/udisksdaemon.c	2020-06-17 20:31:38.948043679 +0200
@@ -36,8 +36,10 @@
 #include "udisksthreadedjob.h"
 #include "udiskssimplejob.h"
 #include "udisksstate.h"
+#ifdef HAVE_CRYPTO
 #include "udiskscrypttabmonitor.h"
 #include "udiskscrypttabentry.h"
+#endif
 #include "udiskslinuxblockobject.h"
 #include "udiskslinuxdevice.h"
 #include "udisksmodulemanager.h"
@@ -80,7 +82,9 @@
 
   UDisksState *state;
 
+#ifdef HAVE_CRYPTO
   UDisksCrypttabMonitor *crypttab_monitor;
+#endif
 
 #ifdef HAVE_LIBMOUNT_UTAB
   UDisksUtabMonitor *utab_monitor;
@@ -136,7 +140,9 @@
   /* Modules use the monitors and try to reference them when cleaning up */
   udisks_module_manager_unload_modules (daemon->module_manager);
   g_object_unref (daemon->mount_monitor);
+#ifdef HAVE_CRYPTO
   g_object_unref (daemon->crypttab_monitor);
+#endif
 #ifdef HAVE_LIBMOUNT_UTAB
   g_object_unref (daemon->utab_monitor);
 #endif
@@ -173,9 +179,11 @@
       g_value_set_object (value, udisks_daemon_get_mount_monitor (daemon));
       break;
 
+#ifdef HAVE_CRYPTO
     case PROP_CRYPTTAB_MONITOR:
       g_value_set_object (value, udisks_daemon_get_crypttab_monitor (daemon));
       break;
+#endif
 
     case PROP_MODULE_MANAGER:
       g_value_set_object (value, udisks_daemon_get_module_manager (daemon));
@@ -300,13 +308,19 @@
   BDPluginSpec loop_plugin = {BD_PLUGIN_LOOP, NULL};
   BDPluginSpec mdraid_plugin = {BD_PLUGIN_MDRAID, NULL};
   BDPluginSpec fs_plugin = {BD_PLUGIN_FS, NULL};
+#ifdef HAVE_CRYPTO
   BDPluginSpec crypto_plugin = {BD_PLUGIN_CRYPTO, NULL};
+#endif
 
   /* The core daemon needs the part, swap, loop, mdraid, fs and crypto plugins.
      Additional plugins are required by various modules, but they make sure
      plugins are loaded themselves. */
   BDPluginSpec *plugins[] = {&part_plugin, &swap_plugin, &loop_plugin, &mdraid_plugin,
-                             &fs_plugin, &crypto_plugin, NULL};
+                             &fs_plugin,
+#ifdef HAVE_CRYPTO
+                             &crypto_plugin,
+#endif
+                             NULL};
   BDPluginSpec **plugin_p = NULL;
   error = NULL;
 
@@ -393,7 +407,9 @@
                     G_CALLBACK (mount_monitor_on_mount_removed),
                     daemon);
 
+#ifdef HAVE_CRYPTO
   daemon->crypttab_monitor = udisks_crypttab_monitor_new ();
+#endif
 #ifdef HAVE_LIBMOUNT_UTAB
   daemon->utab_monitor = udisks_utab_monitor_new ();
 #endif
@@ -633,6 +649,7 @@
   return daemon->mount_monitor;
 }
 
+#ifdef HAVE_CRYPTO
 /**
  * udisks_daemon_get_crypttab_monitor:
  * @daemon: A #UDisksDaemon
@@ -647,6 +664,7 @@
   g_return_val_if_fail (UDISKS_IS_DAEMON (daemon), NULL);
   return daemon->crypttab_monitor;
 }
+#endif
 
 #ifdef HAVE_LIBMOUNT_UTAB
 /**
--- a/src/udiskslinuxblock.c	2020-06-17 20:34:08.599486746 +0200
+++ b/src/udiskslinuxblock.c	2020-06-17 20:41:10.604602315 +0200
@@ -41,7 +41,9 @@
 
 #include <blockdev/part.h>
 #include <blockdev/fs.h>
+#ifdef HAVE_CRYPTO
 #include <blockdev/crypto.h>
+#endif
 
 #include "udiskslogging.h"
 #include "udiskslinuxblock.h"
@@ -55,8 +55,6 @@
 #include "udisksdaemonutil.h"
 #include "udiskslinuxprovider.h"
 #include "udisksfstabentry.h"
-#include "udiskscrypttabmonitor.h"
-#include "udiskscrypttabentry.h"
 #include "udisksdaemonutil.h"
 #include "udisksbasejob.h"
 #include "udiskssimplejob.h"
@@ -64,8 +62,12 @@
 #include "udiskslinuxmdraidobject.h"
 #include "udiskslinuxdevice.h"
 #include "udiskslinuxpartition.h"
+#ifdef HAVE_CRYPTO
+#include "udiskscrypttabmonitor.h"
+#include "udiskscrypttabentry.h"
 #include "udiskslinuxencrypted.h"
 #include "udiskslinuxencryptedhelpers.h"
+#endif
 #include "udiskslinuxpartitiontable.h"
 #include "udiskslinuxfilesystemhelpers.h"
 
@@ -607,6 +609,7 @@
   return g_list_reverse (ret);
 }
 
+#ifdef HAVE_CRYPTO
 static GList *
 find_crypttab_entries_for_device (UDisksLinuxBlock *block,
                                   UDisksDaemon     *daemon)
@@ -691,6 +694,7 @@
   g_list_free_full (entries, g_object_unref);
   return ret;
 }
+#endif
 
 #ifdef HAVE_LIBMOUNT_UTAB
 static GList *
@@ -743,6 +747,7 @@
                          "fstab", &dict_builder);
 }
 
+#ifdef HAVE_CRYPTO
 static gboolean
 add_crypttab_entry (GVariantBuilder       *builder,
                     UDisksCrypttabEntry   *entry,
@@ -805,6 +810,7 @@
 
   return TRUE;
 }
+#endif
 
 /* returns a floating GVariant */
 static GVariant *
@@ -829,6 +835,7 @@
     add_fstab_entry (&builder, UDISKS_FSTAB_ENTRY (l->data));
   g_list_free_full (entries, g_object_unref);
 
+#ifdef HAVE_CRYPTO
   /* Then the /etc/crypttab entries (currently only supported for LUKS) */
   if (udisks_linux_block_is_luks (UDISKS_BLOCK (block)))
     {
@@ -839,15 +846,15 @@
             {
               g_variant_builder_clear (&builder);
               g_list_free_full (entries, g_object_unref);
-              goto out;
+              return ret;
             }
         }
       g_list_free_full (entries, g_object_unref);
     }
+#endif
 
   ret = g_variant_builder_end (&builder);
 
- out:
   return ret;
 }
 
@@ -936,6 +943,7 @@
     add_fstab_entry (&builder, UDISKS_FSTAB_ENTRY (l->data));
   g_list_free_full (entries, g_object_unref);
 
+#ifdef HAVE_CRYPTO
   /* Then the /etc/crypttab entries */
   entries = find_crypttab_entries_for_needle (needle, daemon);
   for (l = entries; l != NULL; l = l->next)
@@ -944,14 +952,14 @@
         {
           g_variant_builder_clear (&builder);
           g_list_free_full (entries, g_object_unref);
-          goto out;
+          return ret;
         }
     }
+#endif
   g_list_free_full (entries, g_object_unref);
 
   ret = g_variant_builder_end (&builder);
 
- out:
   return ret;
 }
 
@@ -1018,7 +1026,9 @@
   gboolean media_available;
   gboolean media_change_detected;
   gboolean read_only;
+#ifdef HAVE_CRYPTO
   gboolean seems_encrypted = FALSE;
+#endif
   guint n;
   GError *error = NULL;
 
@@ -1238,6 +1248,7 @@
       udisks_block_set_id (iface, NULL);
     }
 
+#ifdef HAVE_CRYPTO
   if (udisks_daemon_get_enable_tcrypt (daemon))
     {
       seems_encrypted = bd_crypto_device_seems_encrypted (device_file, &error);
@@ -1255,6 +1266,7 @@
       udisks_block_set_id_type (iface, "crypto_unknown");
     }
   else
+#endif
     {
       udisks_block_set_id_usage (iface, g_udev_device_get_property (device->udev_device, "ID_FS_USAGE"));
       udisks_block_set_id_type (iface, g_udev_device_get_property (device->udev_device, "ID_FS_TYPE"));
@@ -1673,6 +1685,7 @@
   return FALSE;
 }
 
+#ifdef HAVE_CRYPTO
 static gchar *
 make_block_luksname (UDisksBlock *block, GError **error)
 {
@@ -1692,6 +1705,7 @@
   else
     return NULL;
 }
+#endif
 
 static gboolean
 add_remove_crypttab_entry (UDisksBlock *block,
@@ -2297,6 +2311,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+#ifdef HAVE_CRYPTO
 static UDisksObject *
 wait_for_luks_uuid (UDisksDaemon *daemon,
                     gpointer      user_data)
@@ -2353,6 +2368,7 @@
   g_list_free_full (objects, g_object_unref);
   return ret;
 }
+#endif
 
 /* ---------------------------------------------------------------------------------------------------- */
 
@@ -2750,6 +2766,7 @@
                        gpointer       user_data,
                        GError       **error)
 {
+#ifdef HAVE_CRYPTO
   struct TeardownData *data = user_data;
   UDisksObject *object = UDISKS_OBJECT (g_dbus_interface_get_object (G_DBUS_INTERFACE (block)));
   UDisksEncrypted *enc = udisks_object_peek_encrypted (object);
@@ -2779,6 +2796,7 @@
               return FALSE;
         }
     }
+#endif
 
   return udisks_linux_remove_configuration (udisks_block_get_configuration (block), error);
 }
@@ -3228,6 +3230,7 @@
   /* And now create the desired filesystem */
   wait_data->type = type;
 
+#ifdef HAVE_CRYPTO
   if (encrypt_passphrase != NULL)
     {
       UDisksObject *luks_uuid_object;
@@ -3340,6 +3343,7 @@
       block_to_mkfs = cleartext_block;
     }
   else
+#endif
     {
       object_to_mkfs = object;
       block_to_mkfs = block;
--- a/src/udiskslinuxblockobject.c	2020-06-17 20:44:26.883530655 +0200
+++ b/src/udiskslinuxblockobject.c	2020-06-17 20:45:56.223410190 +0200
@@ -52,12 +52,14 @@
 #include "udiskslinuxpartitiontable.h"
 #include "udiskslinuxpartition.h"
 #include "udiskslinuxfilesystem.h"
+#ifdef HAVE_CRYPTO
 #include "udiskslinuxencrypted.h"
+#include "udiskscrypttabmonitor.h"
+#include "udiskscrypttabentry.h"
+#endif
 #include "udiskslinuxswapspace.h"
 #include "udiskslinuxloop.h"
 #include "udiskslinuxprovider.h"
-#include "udiskscrypttabmonitor.h"
-#include "udiskscrypttabentry.h"
 #include "udiskslinuxdevice.h"
 #include "udisksmodulemanager.h"
 #include "udisksmodule.h"
@@ -789,6 +791,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+#ifdef HAVE_CRYPTO
 static gboolean
 encrypted_check (UDisksObject *object)
 {
@@ -817,6 +816,7 @@
   udisks_linux_encrypted_update (UDISKS_LINUX_ENCRYPTED (_iface), UDISKS_LINUX_BLOCK_OBJECT (object));
   return TRUE;
 }
+#endif
 
 /* ---------------------------------------------------------------------------------------------------- */
 
@@ -881,8 +885,10 @@
                 UDISKS_TYPE_LINUX_FILESYSTEM, &object->iface_filesystem);
   update_iface (UDISKS_OBJECT (object), action, swapspace_check, swapspace_connect, swapspace_update,
                 UDISKS_TYPE_LINUX_SWAPSPACE, &object->iface_swapspace);
+#ifdef HAVE_CRYPTO
   update_iface (UDISKS_OBJECT (object), action, encrypted_check, encrypted_connect, encrypted_update,
                 UDISKS_TYPE_LINUX_ENCRYPTED, &object->iface_encrypted);
+#endif
   update_iface (UDISKS_OBJECT (object), action, loop_check, loop_connect, loop_update,
                 UDISKS_TYPE_LINUX_LOOP, &object->iface_loop);
   update_iface (UDISKS_OBJECT (object), action, partition_table_check, partition_table_connect, partition_table_update,
--- a/src/udisksstate.c	2020-05-26 14:59:20.000000000 +0200
+++ b/src/udisksstate.c	2020-06-17 21:10:17.481938766 +0200
@@ -40,7 +40,9 @@
 #include "udiskslogging.h"
 #include "udiskslinuxprovider.h"
 #include "udisksdaemonutil.h"
+#ifdef HAVE_CRYPTO
 #include "udiskslinuxencryptedhelpers.h"
+#endif
 #include "udiskslinuxblockobject.h"
 
 /**
@@ -199,9 +201,11 @@
                                                    const gchar          *key,
                                                    GArray               *devs_to_clean,
                                                    dev_t                 match_block_device);
+#ifdef HAVE_CRYPTO
 static void      udisks_state_check_unlocked_crypto_dev (UDisksState          *state,
                                                          gboolean              check_only,
                                                          GArray               *devs_to_clean);
+#endif
 static void      udisks_state_check_loop          (UDisksState          *state,
                                                    gboolean              check_only,
                                                    GArray               *devs_to_clean);
@@ -535,9 +539,11 @@
    * but only check + record devices marked for cleaning
    */
   devs_to_clean = g_array_new (FALSE, FALSE, sizeof (dev_t));
+#ifdef HAVE_CRYPTO
   udisks_state_check_unlocked_crypto_dev (state,
                                           TRUE, /* check_only */
                                           devs_to_clean);
+#endif
   udisks_state_check_loop (state,
                            TRUE, /* check_only */
                            devs_to_clean);
@@ -561,9 +567,11 @@
   /* Then go through all block devices and clear them up
    * ... for real this time
    */
+#ifdef HAVE_CRYPTO
   udisks_state_check_unlocked_crypto_dev (state,
                                           FALSE, /* check_only */
                                           NULL);
+#endif
   udisks_state_check_loop (state,
                            FALSE, /* check_only */
                            NULL);
@@ -1191,6 +1199,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* returns TRUE if the entry should be kept */
+#ifdef HAVE_CRYPTO
 static gboolean
 udisks_state_check_unlocked_crypto_dev_entry (UDisksState  *state,
                                               GVariant     *value,
@@ -1583,6 +1592,7 @@
   g_mutex_unlock (&state->lock);
   return ret;
 }
+#endif
 
 /* ---------------------------------------------------------------------------------------------------- */
 

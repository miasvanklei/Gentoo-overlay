--- ldso/dynlink.c	2016-02-07 19:39:38.329833357 +0100
+++ ldso/dynlink.c	2016-02-07 19:38:05.112905967 +0100
@@ -114,12 +114,14 @@
 
 static struct dso ldso;
 static struct dso *head, *tail, *fini_head;
-static char *env_path, *sys_path;
+static char *env_path, *sys_path, *exec_sys_path;
 static unsigned long long gencnt;
 static int runtime;
 static int ldd_mode;
 static int ldso_fail;
 static int noload;
+int execerror = -2;
+int tryexecerror = -1;
 static jmp_buf *rtld_fail;
 static pthread_rwlock_t lock;
 static struct debug debug;
@@ -707,12 +709,15 @@
 	if (dso->tls.size) dso->tls.image = laddr(dso, tls_image);
 	if (!runtime) reclaim_gaps(dso);
 	free(allocated_buf);
+	execerror = 0;
 	return map;
 noexec:
 	errno = ENOEXEC;
+	execerror = -1;
 error:
 	if (map!=MAP_FAILED) unmap_library(dso);
 	free(allocated_buf);
+	execerror = -1;
 	return 0;
 }
 
@@ -990,7 +995,10 @@
 				}
 			}
 			if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib";
-			fd = path_open(name, sys_path, buf, sizeof buf);
+			if(execerror == -1)
+				fd = path_open(name, exec_sys_path, buf, sizeof buf);
+			else
+				fd = path_open(name, sys_path, buf, sizeof buf);
 		}
 		pathname = buf;
 	}
@@ -1013,6 +1021,19 @@
 	}
 	map = noload ? 0 : map_library(fd, &temp_dso);
 	close(fd);
+
+	if(execerror == -1) {
+		char str[strlen(sys_path) + 1];
+		if(tryexecerror == 0)
+        		strcpy (str, exec_sys_path);
+		else {
+        		strcpy (str, sys_path);
+			tryexecerror = 0;
+		}
+        	strtok_r (str, "\n", &exec_sys_path);
+		return load_library(name, needed_by);
+	}
+	tryexecerror = -1;
 	if (!map) return 0;
 
 	/* Allocate storage for the new DSO. When there is TLS, this

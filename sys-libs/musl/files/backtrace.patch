--- /dev/null	2015-08-21 21:30:31.093138902 -0200
+++ src/compat/backtrace.c	2015-08-21 23:13:44.956985806 -0200
@@ -0,0 +1,63 @@
+/*
+ * Perform stack unwinding by using the _Unwind_Backtrace.
+ *
+ * User application that wants to use backtrace needs to be
+ * compiled with -fasynchronous-unwind-tables option and -rdynamic to get full
+ * symbols printed.
+ *
+ * Copyright (C) 2009, 2010 STMicroelectronics Ltd.
+ *
+ * Author(s): Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ * - Initial implementation for glibc
+ *
+ * Author(s): Carmelo Amoroso <carmelo.amoroso@st.com>
+ * - Reworked for uClibc
+ *   - use dlsym/dlopen from libdl
+ *   - rewrite initialisation to not use libc_once
+ *   - make it available in static link too
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <execinfo.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <unwind.h>
+#include <assert.h>
+#include <stdio.h>
+
+struct trace_arg
+{
+  void **array;
+  int cnt, size;
+};
+
+static _Unwind_Reason_Code
+backtrace_helper (struct _Unwind_Context *ctx, void *a)
+{
+	struct trace_arg *arg = a;
+
+	/* We are first called with address in the __backtrace function. Skip it. */
+	if (arg->cnt != -1)
+		arg->array[arg->cnt] = (void *) _Unwind_GetIP (ctx);
+	if (++arg->cnt == arg->size)
+		return _URC_END_OF_STACK;
+	return _URC_NO_REASON;
+}
+
+/*
+ * Perform stack unwinding by using the _Unwind_Backtrace.
+ *
+ */
+int backtrace (void **array, int size)
+{
+	struct trace_arg arg = { .array = array, .size = size, .cnt = -1 };
+
+	if (size >= 1)
+		_Unwind_Backtrace (backtrace_helper, &arg);
+
+	return arg.cnt != -1 ? arg.cnt : 0;
+}
--- /dev/null	2015-08-21 21:30:31.093138902 -0200
+++ src/compat/backtracesyms.c	2015-08-21 23:13:59.836940941 -0200
@@ -0,0 +1,106 @@
+/* Return list with names for address in backtrace.
+   Copyright (C) 1998,1999,2000,2001,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.
+
+   Based on glibc/sysdeps/generic/elf/backtracesyms.c
+
+   Copyright (C) 2010 STMicroelectronics Ltd
+   Author(s): Carmelo Amoroso <carmelo.amoroso@st.com>
+   * Modified to work with uClibc
+     - updated headers inclusion
+     - updated formatting and style
+     - updated to use dladdr from libdl */
+
+#define _GNU_SOURCE
+
+#include <execinfo.h>
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dlfcn.h>
+#include <link.h>	/* required for __ELF_NATIVE_CLASS */
+
+#if UINTPTR_MAX > 0xffffffff
+# define WORD_WIDTH 16
+#else
+/* We assyme 64bits.  */
+# define WORD_WIDTH 8
+#endif
+
+
+char ** backtrace_symbols (void *const *array,  int size)
+{
+	Dl_info info[size];
+	int status[size];
+	int cnt;
+	size_t total = 0;
+	char **result;
+
+	/* Fill in the information we can get from `dladdr'.  */
+	for (cnt = 0; cnt < size; ++cnt) {
+		status[cnt] = dladdr (array[cnt], &info[cnt]);
+		if (status[cnt] && info[cnt].dli_fname &&
+			info[cnt].dli_fname[0] != '\0')
+		/*
+		 * We have some info, compute the length of the string which will be
+		 * "<file-name>(<sym-name>) [+offset].
+		 */
+		total += (strlen (info[cnt].dli_fname ?: "") +
+				  (info[cnt].dli_sname ?
+				  strlen (info[cnt].dli_sname) + 3 + WORD_WIDTH + 3 : 1)
+				  + WORD_WIDTH + 5);
+		else
+			total += 5 + WORD_WIDTH;
+	}
+
+	/* Allocate memory for the result.  */
+	result = (char **) malloc (size * sizeof (char *) + total);
+	if (result != NULL) {
+		char *last = (char *) (result + size);
+		for (cnt = 0; cnt < size; ++cnt) {
+			result[cnt] = last;
+
+			if (status[cnt] && info[cnt].dli_fname
+				&& info[cnt].dli_fname[0] != '\0') {
+
+				char buf[20];
+
+				if (array[cnt] >= (void *) info[cnt].dli_saddr)
+					sprintf (buf, "+%#lx",
+							(unsigned long)(array[cnt] - info[cnt].dli_saddr));
+				else
+					sprintf (buf, "-%#lx",
+					(unsigned long)(info[cnt].dli_saddr - array[cnt]));
+
+				last += 1 + sprintf (last, "%s%s%s%s%s[%p]",
+				info[cnt].dli_fname ?: "",
+				info[cnt].dli_sname ? "(" : "",
+				info[cnt].dli_sname ?: "",
+				info[cnt].dli_sname ? buf : "",
+				info[cnt].dli_sname ? ") " : " ",
+				array[cnt]);
+			} else
+				last += 1 + sprintf (last, "[%p]", array[cnt]);
+		}
+		assert (last <= (char *) result + size * sizeof (char *) + total);
+	}
+
+	return result;
+}
--- /dev/null	2015-08-21 21:30:31.093138902 -0200
+++ src/compat/backtracesymsfd.c	2015-08-21 23:14:12.204902819 -0200
@@ -0,0 +1,117 @@
+/* Write formatted list with names for addresses in backtrace to a file.
+   Copyright (C) 1998, 2000, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.
+
+   Based on glibc/sysdeps/generic/elf/backtracesymsfd.c
+
+   Copyright (C) 2010 STMicroelectronics Ltd
+   Author(s): Carmelo Amoroso <carmelo.amoroso@st.com>
+   * Modified to work with uClibc
+     - updated headers inclusion
+     - updated formatting and style
+     - updated to use dladdr from libdl
+     - updated to use snprintf instead of _itoa_word */
+
+#define _GNU_SOURCE
+
+#include <execinfo.h>
+#include <string.h>
+#include <sys/uio.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <link.h>	/* required for __ELF_NATIVE_CLASS */
+
+#if UINTPTR_MAX > 0xffffffff
+# define WORD_WIDTH 16
+#else
+/* We assyme 64bits.  */
+# define WORD_WIDTH 8
+#endif
+
+#define BUF_SIZE (WORD_WIDTH + 1)
+
+void backtrace_symbols_fd (void *const *array, int size, int fd)
+{
+	struct iovec iov[9];
+	int cnt;
+
+	for (cnt = 0; cnt < size; ++cnt) {
+		char buf[BUF_SIZE];
+		Dl_info info;
+		size_t last = 0;
+		size_t len = 0;
+
+		memset(buf, 0, sizeof(buf));
+		if (dladdr (array[cnt], &info)
+			&& info.dli_fname && info.dli_fname[0] != '\0')	{
+			/* Name of the file.  */
+			iov[0].iov_base = (void *) info.dli_fname;
+			iov[0].iov_len = strlen (info.dli_fname);
+			last = 1;
+
+			/* Symbol name.  */
+			if (info.dli_sname != NULL) {
+				char buf2[BUF_SIZE];
+				memset(buf2, 0, sizeof(buf2));
+				size_t diff;
+
+				iov[1].iov_base = (void *) "(";
+				iov[1].iov_len = 1;
+				iov[2].iov_base = (void *) info.dli_sname;
+				iov[2].iov_len = strlen (info.dli_sname);
+
+				if (array[cnt] >= (void *) info.dli_saddr) {
+					iov[3].iov_base = (void *) "+0x";
+					diff = array[cnt] - info.dli_saddr;
+				} else {
+					iov[3].iov_base = (void *) "-0x";
+					diff = info.dli_saddr - array[cnt];
+				}
+
+				iov[3].iov_len = 3;
+
+				/* convert diff to a string in hex format */
+				len = snprintf(buf2, sizeof(buf2), "%lx", (unsigned long) diff);
+				iov[4].iov_base = buf2;
+				iov[4].iov_len = len;
+
+				iov[5].iov_base = (void *) ")";
+				iov[5].iov_len = 1;
+
+				last = 6;
+			}
+		}
+
+		iov[last].iov_base = (void *) "[0x";
+		iov[last].iov_len = 3;
+		++last;
+
+		/* convert array[cnt] to a string in hex format */
+		len = snprintf(buf, sizeof(buf), "%lx", (unsigned long) array[cnt]);
+		iov[last].iov_base = buf;
+		iov[last].iov_len = len;
+
+		++last;
+
+		iov[last].iov_base = (void *) "]\n";
+		iov[last].iov_len = 2;
+		++last;
+
+		writev (fd, iov, last);
+	}
+}
--- /dev/null	2015-08-21 21:30:31.093138902 -0200
+++ include/execinfo.h	2015-08-21 23:14:28.724852898 -0200
@@ -0,0 +1,45 @@
+/* Copyright (C) 1998, 1999, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _EXECINFO_H
+#define _EXECINFO_H 1
+
+#include <features.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Store up to SIZE return address of the current program state in
+   ARRAY and return the exact number of values stored.  */
+extern int backtrace (void **__array, int __size);
+
+
+/* Return names of functions from the backtrace list in ARRAY in a newly
+   malloc()ed memory block.  */
+extern char **backtrace_symbols (void *const *__array, int __size);
+
+
+/* This function is similar to backtrace_symbols() but it writes the result
+   immediately to a file.  */
+extern void backtrace_symbols_fd (void *const *__array, int __size, int __fd);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* execinfo.h  */

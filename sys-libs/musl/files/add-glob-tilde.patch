diff --git a/include/glob.h b/include/glob.h
index 76f6c1c6..fc8106b2 100644
--- a/include/glob.h
+++ b/include/glob.h
@@ -30,6 +30,7 @@ void globfree(glob_t *);
 #define GLOB_APPEND   0x20
 #define GLOB_NOESCAPE 0x40
 #define	GLOB_PERIOD   0x80
+#define GLOB_TILDE    0x100
 
 #define GLOB_NOSPACE 1
 #define GLOB_ABORTED 2
diff --git a/src/regex/glob.c b/src/regex/glob.c
index 5b6ff124..90111909 100644
--- a/src/regex/glob.c
+++ b/src/regex/glob.c
@@ -3,11 +3,15 @@
 #include <sys/stat.h>
 #include <dirent.h>
 #include <limits.h>
+#define _GNU_SOURCE // needed for strlcat, strlcpy
 #include <string.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <stddef.h>
 #include "libc.h"
+#include <stdbool.h>
+#include <pwd.h>
+#include <unistd.h>
 
 struct match
 {
@@ -154,13 +158,87 @@ static int sort(const void *a, const void *b)
 	return strcmp(*(const char **)a, *(const char **)b);
 }
 
+/*"~" or "~/(...)" case*/
+static bool expand_tilde_cur_user(const char *pat_after_tilde, char *new_pat, size_t new_pat_size)
+{
+	char *home;
+	struct passwd pw_store, *pw_result;
+	char pw_buf[1024];
+
+	/*FIXME: add check for issetugid as in libc of openbsd?*/
+	home = getenv("HOME");
+	if(home == NULL) {
+		getpwuid_r(getuid(), &pw_store, pw_buf, sizeof(pw_buf), &pw_result);
+		if(pw_result == NULL) {
+			return false;
+		}
+		home = pw_store.pw_dir;
+	}
+
+	return strlcpy(new_pat, home, new_pat_size) < new_pat_size
+		&& strlcat(new_pat, pat_after_tilde, new_pat_size) < new_pat_size;
+}
+
+/* "~user/(...) case*/
+static bool expand_tilde_named_user(const char *pat_after_tilde, char *new_pat, size_t new_pat_size)
+{
+	struct passwd pw_store, *pw_result;
+	char pw_buf[1024], username[1024];
+	const char *slash_pos = strchr(pat_after_tilde, '/');
+	if(slash_pos == NULL) {
+		return false;
+	}
+
+	ptrdiff_t pat_username_size = slash_pos - pat_after_tilde;
+	if(pat_username_size <= 0 || pat_username_size >= sizeof(username)) {
+		return false;
+	}
+	strncpy(username, pat_after_tilde, pat_username_size);
+	username[pat_username_size] = '\0';
+
+	getpwnam_r(username, &pw_store, pw_buf, sizeof(pw_buf), &pw_result);
+	if (pw_result == NULL)
+		return false;
+
+	return strlcpy(new_pat, pw_store.pw_dir, new_pat_size) < new_pat_size
+		&& strlcat(new_pat, slash_pos, new_pat_size) < new_pat_size;
+}
+
+/* expands:
+ *  ~ into /home/user/
+ *  ~/asd into /home/user/asd
+ *  ~user1/asd into /home/user1/asd
+ * the values for the home directory are taken from passwd
+ *
+ * returning true means successful expansion and that expanded_pat is valid
+ */
+static bool expand_tilde(const char *pat, char *new_pat, int new_pat_size)
+{
+	const char *pat_after_tilde = pat + 1;
+	if(*pat_after_tilde == '\0' || *pat_after_tilde == '/') {
+		return expand_tilde_cur_user(pat_after_tilde, new_pat, new_pat_size);
+	} else {
+		return expand_tilde_named_user(pat_after_tilde, new_pat, new_pat_size);
+	}
+}
+
 int glob(const char *restrict pat, int flags, int (*errfunc)(const char *path, int err), glob_t *restrict g)
 {
-	const char *p=pat, *d;
+	const char *p, *d;
+	char new_pat[PATH_MAX + 1];
 	struct match head = { .next = NULL }, *tail = &head;
 	size_t cnt, i;
 	size_t offs = (flags & GLOB_DOOFFS) ? g->gl_offs : 0;
 	int error = 0;
+
+	/*even if expanding fails(e.g. expansion make pat too big)
+	 * we should try to match the ~ or ~user literally*/
+	bool should_expand_tilde = (flags & GLOB_TILDE) && (pat[0] == '~');
+	if(should_expand_tilde && expand_tilde(pat, new_pat, sizeof(new_pat))) {
+		p = new_pat;
+	} else {
+		p = pat;
+	}
 	
 	if (*p == '/') {
 		for (; *p == '/'; p++);

--- src/context/i386/getcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ src/context/i386/getcontext.S	2015-10-01 18:20:18.810030492 +0200
@@ -0,0 +1,48 @@
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
+#include <sys/syscall.h>
+
+.text
+.global getcontext
+.type getcontext,@function
+/* store current CPU context into struct ucontext* */
+getcontext:
+  movl 4(%esp),%eax	/* load ucontext* */
+  /* the registers are in uc_mcontext, which starts at offset 20 */
+  movw %gs,20(%eax)
+  movw %fs,24(%eax)
+  movw %es,28(%eax)
+  movw %ds,32(%eax)
+  movl %edi,36(%eax)
+  movl %esi,40(%eax)
+  movl %ebp,44(%eax)
+  /* skip esp until we stored ecx */
+  movl %ebx,52(%eax)
+  movl %edx,56(%eax)
+  movl %ecx,60(%eax)
+  lea 4(%esp),%ecx	/* store esp+4 to esp */
+  mov %ecx,48(%eax)
+  movl $0,64(%eax)	/* eax */
+  /* not touching trapno and err, no idea what do store there */
+  movl (%esp),%ecx
+  movl %ecx,76(%eax)	/* store return value from stack into eip of struct */
+  movw %cs,80(%eax)
+  /* 84: eflags */
+  /* 88: esp_at_signal */
+  movw %ss,92(%eax)
+
+  lea 236(%eax),%ecx
+  movl %ecx,96(%eax)
+  fnstenv (%ecx)
+  fldenv (%ecx)
+  mov %ebx,%edi
+  xor %ebx,%ebx
+  xor %ecx,%ecx
+  lea 108(%eax),%edx
+  mov $__NR_sigprocmask,%eax
+  int $0x80
+  mov %edi,%ebx
+  xor %eax,%eax
+  ret
+.size getcontext, .-getcontext
--- src/context/i386/setcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ src/context/i386/setcontext.S	2015-10-01 18:20:26.185031256 +0200
@@ -0,0 +1,58 @@
+#include <sys/syscall.h>
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
+
+.text
+.global __setcontext_trampoline
+.type __setcontext_trampoline,@function
+__setcontext_trampoline:
+  mov %ebx,4(%esp)
+  /* fall through */
+.size __setcontext_trampoline,.-__setcontext_trampoline
+
+.global __error_unified_syscall
+.type	__error_unified_syscall,@function
+__error_unified_syscall:
+	push	%eax
+	call	__errno_location
+	pop	(%eax)
+	orl	$-1,%eax
+.global setcontext
+.type setcontext,@function
+/* switch to stored CPU context from struct ucontext* */
+setcontext:
+  movl 4(%esp),%eax	/* load ucontext* */
+  /* first, load the signal mask */
+  movl %ebx,%edi
+  xorl %edx,%edx
+  movl $2,%ebx	/* SIG_SETMASK */
+  lea 108(%eax),%ecx
+  movl $__NR_sigprocmask,%eax
+  int $0x80
+  cmp $-4095,%eax
+  jb .Lnoerror
+  jmp __error_unified_syscall
+.Lnoerror:
+  movl 4(%esp),%eax	/* load ucontext* */
+  mov %edi,%ebx
+  lea 236(%eax),%ecx
+  fldenv (%ecx)
+
+  /* the registers are in uc_mcontext, which starts at offset 20 */
+  /* do not restore gs because it's thread-specific */
+  movw 24(%eax),%fs
+  movw 28(%eax),%es
+  movw 32(%eax),%ds
+  movl 36(%eax),%edi
+  movl 40(%eax),%esi
+  movl 44(%eax),%ebp
+  movl 48(%eax),%esp
+  movw 92(%eax),%ss
+  movl 52(%eax),%ebx
+  movl 56(%eax),%edx
+  movl 60(%eax),%ecx
+
+  movl 76(%eax),%eax
+  jmp *%eax
+.size setcontext, .-setcontext
--- src/context/makecontext.c	1970-01-01 01:00:00.000000000 +0100
+++ src/context/makecontext.c	2015-10-01 17:56:31.052882501 +0200
@@ -0,0 +1,70 @@
+#define _GNU_SOURCE
+#include <ucontext.h>
+#include <stdarg.h>
+
+extern void __setcontext_trampoline();
+
+void makecontext(ucontext_t* c, void (*func)(void), int argc, ...) {
+  size_t* sp;
+  va_list v;
+  int i;
+#ifdef __hppa__
+#define PUSH(val) *++sp=(val);
+#else
+#define PUSH(val) *--sp=(val);
+#endif
+  /* we are called like this:
+
+    if (getcontext(&uctx_func1) == -1)
+        handle_error("getcontext");
+    uctx_func1.uc_stack.ss_sp = func1_stack;
+    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);
+    uctx_func1.uc_link = &uctx_main;
+    makecontext(&uctx_func1, func1, 0);
+  */
+
+  /* first order of business: set up the stack */
+  /* the &-16 aligns it to 16 bytes */
+  sp=(size_t*)((size_t)(c->uc_stack.ss_sp + c->uc_stack.ss_size)&-16);
+  /* note that if the provided stack is to small, we will just crash in here */
+  va_start(v,argc);
+#ifdef __i386__
+  /* if there are no args, we need to make sure there is space on the
+   * stack for the trampoline to pretend uc_link was passed as stack
+   * argument */
+  if (!argc) PUSH(0);
+  /* we set up the context so we jump to it directly, and we leave
+   * __setcontext_trampoline as return address on the stack. */
+  /* __setcontext_trampoline needs to know the c->uc_link, so we put
+   * that into ebx, which is callee-saved */
+  c->uc_sigcontext.ebx=(size_t)c->uc_link;
+  sp-=argc;
+  for (i=0; i<argc; ++i)
+    sp[i]=va_arg(v,size_t);
+  PUSH((size_t)__setcontext_trampoline);
+  c->uc_sigcontext.esp=(size_t)sp;
+  c->uc_sigcontext.eip=(size_t)func;
+#elif defined __x86_64__
+  /* __setcontext_trampoline needs to know the c->uc_link, so we put
+   * that into ebx, which is callee-saved */
+  c->uc_sigcontext.rbx=(size_t)c->uc_link;
+  for (i=0; i<argc; ++i) {
+    switch(i) {
+    case 0: c->uc_sigcontext.rdi=va_arg(v,size_t); break;
+    case 1: c->uc_sigcontext.rsi=va_arg(v,size_t); break;
+    case 2: c->uc_sigcontext.rdx=va_arg(v,size_t); break;
+    case 3: c->uc_sigcontext.rcx=va_arg(v,size_t); break;
+    case 4: c->uc_sigcontext.r8=va_arg(v,size_t); break;
+    case 5: c->uc_sigcontext.r9=va_arg(v,size_t); break;
+    default: /* the rest goes on the stack */
+      PUSH(va_arg(v,size_t));
+    }
+  }
+  PUSH((size_t)__setcontext_trampoline);
+  c->uc_sigcontext.rsp=(size_t)sp;
+  c->uc_sigcontext.rip=(size_t)func;
+#else
+#warning platform not supported yet in makecontext
+#endif
+  va_end(v);
+}
--- src/context/swapcontext.c	1970-01-01 01:00:00.000000000 +0100
+++ src/context/swapcontext.c	2015-10-01 17:56:31.052882501 +0200
@@ -0,0 +1,12 @@
+#include <ucontext.h>
+#include <stdio.h>
+
+int swapcontext(ucontext_t* o,const ucontext_t* n) {
+  volatile int once=0;
+  if (getcontext(o)==-1) return -1;
+  if (!once) {
+    ++once;
+    return setcontext(n);
+  }
+  return 0;
+}
--- src/context/x86_64/getcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ src/context/x86_64/getcontext.S	2015-10-01 17:56:31.052882501 +0200
@@ -0,0 +1,50 @@
+#include <sys/syscall.h>
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
+
+.text
+.global getcontext
+.type getcontext,@function
+/* store current CPU context into struct ucontext* */
+getcontext:
+  /* the registers are in uc_mcontext, which starts at offset 40 */
+  movq %r8,40(%rdi)
+  movq %r9,48(%rdi)
+//  movq %r10,56(%rdi)
+//  movq %r11,64(%rdi)
+  movq %r12,72(%rdi)
+  movq %r13,80(%rdi)
+  movq %r14,88(%rdi)
+  movq %r15,96(%rdi)
+  movq %rdi,104(%rdi)	/* what a useless statement :-) */
+  movq %rsi,112(%rdi)
+  movq %rbp,120(%rdi)
+  movq %rbx,128(%rdi)
+  movq %rdx,136(%rdi)
+  movq $0,144(%rdi)	/* store 0 as value of rax because that's the return value of the function */
+  movq %rcx,152(%rdi)
+  leaq 8(%rsp),%rax
+  movq %rax,160(%rdi)
+  movq (%rsp),%rax
+  movq %rax,168(%rdi)	/* store function return address as rip */
+  lahf
+  movq %rax,176(%rdi)
+  /* valgrind dies if we use these instructions */
+//  movw %cs,184(%rdi)
+//  movw %gs,186(%rdi)
+//  movw %fs,188(%rdi)
+  /* write nothing to err (192) and trapno (200) */
+
+  leaq 424(%rdi),%rax
+  movq %rax,224(%rdi)
+  fnstenv (%rax)
+  fldenv (%rax)
+  stmxcsr 448(%rdi)
+
+  /* now call sigprocmask(SIG_BLOCK, NULL, &uc->uc_sigmask) */
+  leaq 296(%rdi),%rdx
+  xorl %esi,%esi
+  xorl %edi,%edi
+  jmp sigprocmask
+.size getcontext, .-getcontext
--- src/context/x86_64/setcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ src/context/x86_64/setcontext.S	2015-10-01 17:56:31.052882501 +0200
@@ -0,0 +1,59 @@
+#include <sys/syscall.h>
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
+
+.text
+
+.global __setcontext_trampoline
+.type __setcontext_trampoline,@function
+__setcontext_trampoline:
+  movq %rbx,%rdi
+  /* fall through */
+  .size __setcontext_trampoline, .-__setcontext_trampoline
+
+.global setcontext
+.type setcontext,@function
+/* load current CPU context from struct ucontext* */
+setcontext:
+  /* first restore the signal mask, call sigprocmask(SIG_SETMASK,&uc->uc_sigmask,NULL) */
+  movq %rdi,%rbx
+  leaq 296(%rdi),%rsi
+  xorl %edx,%edx
+  movl $2,%edi
+  call sigprocmask
+  mov %rbx,%rdi
+  test %rax,%rax
+  jc .Lexit
+
+  /* now the floating point context */
+  movq 224(%rdi),%rax
+  fldenv (%rax)
+  ldmxcsr 448(%rdi)
+
+  /* the registers are in uc_mcontext, which starts at offset 40 */
+  movq 40(%rdi),%r8
+  movq 48(%rdi),%r9
+  movq 72(%rdi),%r12
+  movq 80(%rdi),%r13
+  movq 88(%rdi),%r14
+  movq 96(%rdi),%r15
+
+  movq 112(%rdi),%rsi
+  movq 120(%rdi),%rbp
+  movq 128(%rdi),%rbx
+  movq 136(%rdi),%rdx
+  movq 152(%rdi),%rcx
+  movq 160(%rdi),%rsp
+  pushq 168(%rdi)	/* push return value so ret goes to the right place */
+
+//  movw 186(%rdi),%gs
+//  movw 188(%rdi),%fs
+
+  movq 104(%rdi),%rdi
+
+  xorl %eax,%eax
+
+.Lexit:
+  ret
+.size setcontext, .-setcontext
--- arch/x86_64/bits/signal.h	2015-10-01 18:31:36.273100713 +0200
+++ arch/x86_64/bits/signal.h	2015-10-01 19:15:22.835372964 +0200
@@ -76,6 +76,9 @@
 	struct __ucontext *uc_link;
 	stack_t uc_stack;
 	mcontext_t uc_mcontext;
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+	struct sigcontext uc_sigcontext;
+#endif
 	sigset_t uc_sigmask;
 	unsigned long __fpregs_mem[64];
 } ucontext_t;
--- arch/i386/bits/signal.h	2015-10-01 18:31:36.266100712 +0200
+++ arch/i386/bits/signal.h	2015-10-01 19:16:28.960379818 +0200
@@ -69,6 +69,9 @@
 	struct __ucontext *uc_link;
 	stack_t uc_stack;
 	mcontext_t uc_mcontext;
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+        struct sigcontext uc_sigcontext;
+#endif
 	sigset_t uc_sigmask;
 	unsigned long __fpregs_mem[28];
 } ucontext_t;

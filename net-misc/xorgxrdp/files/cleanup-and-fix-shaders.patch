--- a/module/rdpEgl.c	2025-08-07 23:25:15.206374213 +0200
+++ b/module/rdpEgl.c	2025-08-07 23:26:05.753917116 +0200
@@ -76,15 +76,15 @@
 
 static const GLchar g_vs[] =
 "\
-#version 330 core\n\
-layout (location = 0) in vec2 position;\n\
+#version 140\n\
+attribute vec2 position;\n\
 void main(void)\n\
 {\n\
     gl_Position = vec4(position.xy, 0.0, 1.0);\n\
 }\n";
 static const GLchar g_fs_copy[] =
 "\
-#version 330 core\n\
+#version 140\n\
 uniform sampler2D tex;\n\
 uniform vec2 tex_size;\n\
 void main()\n\
@@ -93,7 +93,7 @@
 }\n";
 static const GLchar g_fs_rfx_rgb_to_yuv[] =
 "\
-#version 330 core\n\
+#version 140\n\
 uniform sampler2D tex;\n\
 uniform vec2 tex_size;\n\
 void main()\n\
@@ -120,7 +120,7 @@
 }\n";
 static const GLchar g_fs_rfx_yuv_to_yuvlp[] =
 "\
-#version 330 core\n\
+#version 140\n\
 uniform sampler2D tex;\n\
 uniform vec2 tex_size;\n\
 vec4 getpixel(int x1, int y1, int offset)\n\
@@ -186,7 +186,7 @@
 }\n";
 static const GLchar g_fs_rfx_crc[] =
 "\
-#version 330 core\n\
+#version 140\n\
 uniform sampler2D tex;\n\
 uniform vec2 tex_size;\n\
 const int g_crc_table[256] = int[256](\n\
@@ -288,19 +288,87 @@
 #define LLOGLN(_level, _args) \
     do { if (_level < LOG_LEVEL) { ErrorF _args ; ErrorF("\n"); } } while (0)
 
+void rdpEglCheckshader(GLuint id, GLuint type, GLint *ret, const char *onfail)
+{
+ //Check if something is wrong with the shader
+ switch(type) {
+ case(GL_COMPILE_STATUS):
+   glGetShaderiv(id, type, ret);
+   if(*ret == false){
+    int infologLength =  0;
+    glGetShaderiv(id, GL_INFO_LOG_LENGTH, &infologLength);
+    GLchar buffer[infologLength];
+    GLsizei charsWritten = 0;
+    LLOGLN(0, ("rdpEglCreate: %s", onfail));
+    glGetShaderInfoLog(id, infologLength, &charsWritten, buffer);
+    LLOGLN(0, ("rdpEglCreate: %s", buffer));
+   }
+   break;
+ case(GL_LINK_STATUS):
+   glGetProgramiv(id, type, ret);
+   if(*ret == false){
+    int infologLength =  0;
+    glGetProgramiv(id, GL_INFO_LOG_LENGTH, &infologLength);
+    GLchar buffer[infologLength];
+    GLsizei charsWritten = 0;
+    LLOGLN(0, ("rdpEglCreate: %s", onfail));
+    glGetProgramInfoLog(id, infologLength, &charsWritten, buffer);
+    LLOGLN(0, ("rdpEglCreate: %s", buffer));
+   }
+   break;
+ default:
+   break;
+ };
+}
+
 /******************************************************************************/
-void *
-rdpEglCreate(ScreenPtr screen)
+static int
+rdpEglSetupShader(struct rdp_egl *egl,
+                  const GLchar *vsource,
+                  const GLchar *fsource,
+                  int index)
 {
-    struct rdp_egl *egl;
-    GLint old_vertex_array;
-    const GLchar *vsource;
-    const GLchar *fsource;
     GLint vlength;
     GLint flength;
     GLint linked;
     GLint compiled;
 
+    egl->vertex_shader[index] = glCreateShader(GL_VERTEX_SHADER);
+    egl->fragment_shader[index] = glCreateShader(GL_FRAGMENT_SHADER);
+    vlength = strlen(vsource);
+    flength = strlen(fsource);
+
+    glShaderSource(egl->vertex_shader[index], 1, &vsource, &vlength);
+    glShaderSource(egl->fragment_shader[index], 1, &fsource, &flength);
+
+    glCompileShader(egl->vertex_shader[index]);
+    rdpEglCheckshader(egl->vertex_shader[index], GL_COMPILE_STATUS, &compiled, "unable to compile the vertex shader!");
+
+    glCompileShader(egl->fragment_shader[index]);
+    rdpEglCheckshader(egl->fragment_shader[index], GL_COMPILE_STATUS, &compiled, "unable to compile the fragment shader!");
+
+    egl->program[index] = glCreateProgram();
+
+    glAttachShader(egl->program[index], egl->vertex_shader[index]);
+    glBindAttribLocation(egl->program[index], 0, "position");
+    glAttachShader(egl->program[index], egl->fragment_shader[index]);
+
+    glLinkProgram(egl->program[index]);
+    rdpEglCheckshader(egl->program[index], GL_LINK_STATUS, &linked, "unable to link te program!");
+
+    egl->tex_loc[index] = glGetUniformLocation(egl->program[index], "tex");
+    egl->tex_size_loc[index] = glGetUniformLocation(egl->program[index], "tex_size");
+
+    LLOGLN(0, ("rdpEglCreate: copy_tex_loc %d copy_tex_size_loc %d",
+           egl->tex_loc[index], egl->tex_size_loc[index]));
+}
+
+void *
+rdpEglCreate(ScreenPtr screen)
+{
+    struct rdp_egl *egl;
+    GLint old_vertex_array;
+
     egl = g_new0(struct rdp_egl, 1);
     /* create vertex array */
     glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vertex_array);
@@ -314,106 +382,16 @@
     glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, NULL);
     glBindVertexArray(old_vertex_array);
     glGenFramebuffers(1, egl->fb);
+
     /* create copy shader */
-    vsource = g_vs;
-    fsource = g_fs_copy;
-    egl->vertex_shader[0] = glCreateShader(GL_VERTEX_SHADER);
-    egl->fragment_shader[0] = glCreateShader(GL_FRAGMENT_SHADER);
-    vlength = strlen(vsource);
-    flength = strlen(fsource);
-    glShaderSource(egl->vertex_shader[0], 1, &vsource, &vlength);
-    glShaderSource(egl->fragment_shader[0], 1, &fsource, &flength);
-    glCompileShader(egl->vertex_shader[0]);
-    glGetShaderiv(egl->vertex_shader[0], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: vertex_shader compiled %d", compiled));
-    glCompileShader(egl->fragment_shader[0]);
-    glGetShaderiv(egl->fragment_shader[0], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: fragment_shader compiled %d", compiled));
-    egl->program[0] = glCreateProgram();
-    glAttachShader(egl->program[0], egl->vertex_shader[0]);
-    glAttachShader(egl->program[0], egl->fragment_shader[0]);
-    glLinkProgram(egl->program[0]);
-    glGetProgramiv(egl->program[0], GL_LINK_STATUS, &linked);
-    LLOGLN(0, ("rdpEglCreate: linked %d", linked));
-    egl->tex_loc[0] = glGetUniformLocation(egl->program[0], "tex");
-    egl->tex_size_loc[0] = glGetUniformLocation(egl->program[0], "tex_size");
-    LLOGLN(0, ("rdpEglCreate: copy_tex_loc %d copy_tex_size_loc %d",
-           egl->tex_loc[0], egl->tex_size_loc[0]));
+    rdpEglSetupShader(egl, g_vs, g_fs_copy, 0);
     /* create yuv shader */
-    vsource = g_vs;
-    fsource = g_fs_rfx_rgb_to_yuv;
-    egl->vertex_shader[1] = glCreateShader(GL_VERTEX_SHADER);
-    egl->fragment_shader[1] = glCreateShader(GL_FRAGMENT_SHADER);
-    vlength = strlen(vsource);
-    flength = strlen(fsource);
-    glShaderSource(egl->vertex_shader[1], 1, &vsource, &vlength);
-    glShaderSource(egl->fragment_shader[1], 1, &fsource, &flength);
-    glCompileShader(egl->vertex_shader[1]);
-    glGetShaderiv(egl->vertex_shader[1], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: vertex_shader compiled %d", compiled));
-    glCompileShader(egl->fragment_shader[1]);
-    glGetShaderiv(egl->fragment_shader[1], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: fragment_shader compiled %d", compiled));
-    egl->program[1] = glCreateProgram();
-    glAttachShader(egl->program[1], egl->vertex_shader[1]);
-    glAttachShader(egl->program[1], egl->fragment_shader[1]);
-    glLinkProgram(egl->program[1]);
-    glGetProgramiv(egl->program[1], GL_LINK_STATUS, &linked);
-    LLOGLN(0, ("rdpEglCreate: linked %d", linked));
-    egl->tex_loc[1] = glGetUniformLocation(egl->program[1], "tex");
-    egl->tex_size_loc[1] = glGetUniformLocation(egl->program[1], "tex_size");
-    LLOGLN(0, ("rdpEglCreate: yuv_tex_loc %d yuv_tex_size_loc %d",
-           egl->tex_loc[1], egl->tex_size_loc[1]));
+    rdpEglSetupShader(egl, g_vs, g_fs_rfx_rgb_to_yuv, 1);
     /* create yuvlp shader */
-    vsource = g_vs;
-    fsource = g_fs_rfx_yuv_to_yuvlp;
-    egl->vertex_shader[2] = glCreateShader(GL_VERTEX_SHADER);
-    egl->fragment_shader[2] = glCreateShader(GL_FRAGMENT_SHADER);
-    vlength = strlen(vsource);
-    flength = strlen(fsource);
-    glShaderSource(egl->vertex_shader[2], 1, &vsource, &vlength);
-    glShaderSource(egl->fragment_shader[2], 1, &fsource, &flength);
-    glCompileShader(egl->vertex_shader[2]);
-    glGetShaderiv(egl->vertex_shader[2], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: vertex_shader compiled %d", compiled));
-    glCompileShader(egl->fragment_shader[2]);
-    glGetShaderiv(egl->fragment_shader[2], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: fragment_shader compiled %d", compiled));
-    egl->program[2] = glCreateProgram();
-    glAttachShader(egl->program[2], egl->vertex_shader[2]);
-    glAttachShader(egl->program[2], egl->fragment_shader[2]);
-    glLinkProgram(egl->program[2]);
-    glGetProgramiv(egl->program[2], GL_LINK_STATUS, &linked);
-    LLOGLN(0, ("rdpEglCreate: linked %d", linked));
-    egl->tex_loc[2] = glGetUniformLocation(egl->program[2], "tex");
-    egl->tex_size_loc[2] = glGetUniformLocation(egl->program[2], "tex_size");
-    LLOGLN(0, ("rdpEglCreate: yuvlp_tex_loc %d yuvlp_tex_size_loc %d",
-           egl->tex_loc[2], egl->tex_size_loc[2]));
+    rdpEglSetupShader(egl, g_vs, g_fs_rfx_yuv_to_yuvlp, 2);
     /* create crc shader */
-    vsource = g_vs;
-    fsource = g_fs_rfx_crc;
-    egl->vertex_shader[3] = glCreateShader(GL_VERTEX_SHADER);
-    egl->fragment_shader[3] = glCreateShader(GL_FRAGMENT_SHADER);
-    vlength = strlen(vsource);
-    flength = strlen(fsource);
-    glShaderSource(egl->vertex_shader[3], 1, &vsource, &vlength);
-    glShaderSource(egl->fragment_shader[3], 1, &fsource, &flength);
-    glCompileShader(egl->vertex_shader[3]);
-    glGetShaderiv(egl->vertex_shader[3], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: vertex_shader compiled %d", compiled));
-    glCompileShader(egl->fragment_shader[3]);
-    glGetShaderiv(egl->fragment_shader[3], GL_COMPILE_STATUS, &compiled);
-    LLOGLN(0, ("rdpEglCreate: fragment_shader compiled %d", compiled));
-    egl->program[3] = glCreateProgram();
-    glAttachShader(egl->program[3], egl->vertex_shader[3]);
-    glAttachShader(egl->program[3], egl->fragment_shader[3]);
-    glLinkProgram(egl->program[3]);
-    glGetProgramiv(egl->program[3], GL_LINK_STATUS, &linked);
-    LLOGLN(0, ("rdpEglCreate: linked %d", linked));
-    egl->tex_loc[3] = glGetUniformLocation(egl->program[3], "tex");
-    egl->tex_size_loc[3] = glGetUniformLocation(egl->program[3], "tex_size");
-    LLOGLN(0, ("rdpEglCreate: crc_tex_loc %d crc_tex_size_loc %d",
-           egl->tex_loc[3], egl->tex_size_loc[3]));
+    rdpEglSetupShader(egl, g_vs, g_fs_rfx_crc, 3);
+
     return egl;
 }
 

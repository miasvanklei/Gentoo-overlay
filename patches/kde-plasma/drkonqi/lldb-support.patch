--- a/src/backtracegenerator.h
+++ b/src/backtracegenerator.h
@@ -84,6 +84,7 @@
     State             m_state;
     BacktraceParser * m_parser;
     QString           m_parsedBacktrace;
+    bool              m_lldbDetached;
 
 #ifdef BACKTRACE_PARSER_DEBUG
     BacktraceParser * m_debugParser;
--- a/src/backtracegenerator.cpp
+++ b/src/backtracegenerator.cpp
@@ -37,7 +37,8 @@
 BacktraceGenerator::BacktraceGenerator(const Debugger & debugger, QObject *parent)
         : QObject(parent),
           m_debugger(debugger), m_proc(nullptr),
-          m_temp(nullptr), m_state(NotLoaded)
+          m_temp(nullptr), m_state(NotLoaded),
+          m_lldbDetached(false)
 {
     m_parser = BacktraceParser::newParser(m_debugger.codeName(), this);
     m_parser->connectToGenerator(this);
@@ -56,6 +57,8 @@
         m_proc->terminate();
         if (!m_proc->waitForFinished(10000)) {
             m_proc->kill();
+            // NB: lldb can get stuck here, a waitForFinished() without timeout is safe
+            // only if lldbrc's BatchCommand ends with something like "\nimport os ; os._exit(0)\nquit"
             m_proc->waitForFinished();
         }
         delete m_proc;
@@ -95,9 +98,17 @@
     *m_proc << KShell::splitArgs(str);
     m_proc->setOutputChannelMode(KProcess::OnlyStdoutChannel);
     m_proc->setNextOpenMode(QIODevice::ReadWrite | QIODevice::Text);
+    // check if the debugger should take its input from a file we'll generate,
+    // and take the appropriate steps if so
+    QString stdinFile = m_debugger.backendValueOfParameter(QStringLiteral("ExecInputFile"));
+    Debugger::expandString(stdinFile, Debugger::ExpansionUsageShell, m_temp->fileName());
+    if (!stdinFile.isEmpty() && QFile::exists(stdinFile)) {
+        m_proc->setStandardInputFile(stdinFile);
+    }
     connect(m_proc, &KProcess::readyReadStandardOutput, this, &BacktraceGenerator::slotReadInput);
     connect(m_proc, static_cast<void (KProcess::*)(int, QProcess::ExitStatus)>(&KProcess::finished), this, &BacktraceGenerator::slotProcessExited);
 
+    m_lldbDetached = false;
     m_proc->start();
     if (!m_proc->waitForStarted()) {
         //we mustn't keep these around...
@@ -116,15 +127,34 @@
 
 void BacktraceGenerator::slotReadInput()
 {
+    if (m_lldbDetached) {
+        return;
+    }
+
     // we do not know if the output array ends in the middle of an utf-8 sequence
     m_output += m_proc->readAllStandardOutput();
 
     int pos;
-    while ((pos = m_output.indexOf('\n')) != -1) {
+    while ((pos = m_output.indexOf('\n')) != -1 && m_proc->state() == QProcess::Running) {
         QString line = QString::fromLocal8Bit(m_output, pos + 1);
         m_output.remove(0, pos + 1);
 
         emit newLine(line);
+        line = line.simplified();
+        if (line.startsWith(QLatin1String("Process ")) && line.endsWith(QLatin1String(" detached"))) {
+            // Anything following this line doesn't interest us and shouldn't show in the backtrace.
+            m_lldbDetached = true;
+            // Also, lldb has been known to turn into a zombie instead of exitting, thereby blocking us.
+            // Recent versions should react correctly to the quit or else to the Python os._exit() commands
+            // in lldbrc and we will thus assume that the application has terminated.
+            // (see also http://stackoverflow.com/questions/26267289/how-can-i-exit-lldb-after-running-commands-with-o)
+            if (!m_proc->waitForFinished(500)) {
+                m_proc->kill();
+            }
+            slotProcessExited(0, QProcess::NormalExit);
+            // either way we should stop reading now.
+            return;
+        }
     }
 }
 
--- a/src/backtracewidget.cpp
+++ b/src/backtracewidget.cpp
@@ -205,6 +205,9 @@
 
         // scroll to crash
         QTextCursor crashCursor = ui.m_backtraceEdit->document()->find(QStringLiteral("[KCrash Handler]"));
+        if (crashCursor.isNull()) {
+            crashCursor = ui.m_backtraceEdit->document()->find(QStringLiteral("KCrash::defaultCrashHandler"));
+        }
         if (!crashCursor.isNull()) {
             crashCursor.movePosition(QTextCursor::Up, QTextCursor::MoveAnchor);
             ui.m_backtraceEdit->verticalScrollBar()->setValue(ui.m_backtraceEdit->cursorRect(crashCursor).top());
--- a/src/data/CMakeLists.txt
+++ b/src/data/CMakeLists.txt
@@ -1,2 +1,9 @@
 install(FILES mappings DESTINATION ${KDE_INSTALL_DATADIR}/drkonqi)
-install(DIRECTORY debuggers DESTINATION ${KDE_INSTALL_DATADIR}/drkonqi PATTERN ".svn" EXCLUDE)
+install(DIRECTORY debuggers/internal DESTINATION ${KDE_INSTALL_DATADIR}/drkonqi/debuggers PATTERN ".svn" EXCLUDE)
+if(APPLE)
+    # note the trailing slash for external.mac; this copies the contents into the destination dir instead of external.mac itself!
+    install(DIRECTORY debuggers/external.mac/ DESTINATION ${KDE_INSTALL_DATADIR}/drkonqi/debuggers/external PATTERN ".svn" EXCLUDE)
+    install(PROGRAMS AppleTerminal DESTINATION ${KDE_INSTALL_BINDIR})
+else()
+    install(DIRECTORY debuggers/external DESTINATION ${KDE_INSTALL_DATADIR}/drkonqi/debuggers PATTERN ".svn" EXCLUDE)
+endif()
--- /dev/null
+++ b/src/data/debuggers/external/lldbrc
@@ -0,0 +1,8 @@
+[General]
+Name=lldb
+TryExec=lldb
+Backends=KCrash
+
+[KCrash]
+Exec=konsole --nofork -e lldb --attach-pid %pid
+Terminal=true
--- /dev/null
+++ b/src/data/debuggers/internal/lldbrc
@@ -0,0 +1,9 @@
+[General]
+Name=lldb
+TryExec=lldb
+Backends=KCrash
+
+[KCrash]
+Exec=lldb --attach-pid %pid
+ExecInputFile=%tempfile
+BatchCommands=set term-width 200\nthread info\nbt all\ndetach\nscript import os ; os._exit(0)\nquit
--- a/src/debugger.h
+++ b/src/debugger.h
@@ -70,6 +70,8 @@
     /** If this is an external debugger, it returns whether it should be run in a terminal or not */
     bool runInTerminal() const;
 
+    /** Returns the value of the arbitrary configuration parameter @param key, or an empty QString if @param key isn't defined */
+    QString backendValueOfParameter(const QString &key) const;
 
     enum ExpandStringUsage {
         ExpansionUsagePlainText,
--- a/src/debugger.cpp
+++ b/src/debugger.cpp
@@ -104,6 +104,15 @@
     }
 }
 
+QString Debugger::backendValueOfParameter(const QString &key) const
+{
+    if (!isValid() || !m_config->hasGroup(m_backend)) {
+        return QString();
+    } else {
+        return m_config->group(m_backend).readEntry(key, QString());
+    }
+}
+
 //static
 void Debugger::expandString(QString & str, ExpandStringUsage usage, const QString & tempFile)
 {
--- a/src/parser/CMakeLists.txt
+++ b/src/parser/CMakeLists.txt
@@ -3,6 +3,7 @@
     backtraceparsergdb.cpp
     backtraceparserkdbgwin.cpp
     backtraceparsernull.cpp
+    backtraceparserlldb.cpp
 )
 
 add_library(drkonqi_backtrace_parser STATIC ${BACKTRACEPARSER_SRCS})
--- a/src/parser/backtraceparser.cpp
+++ b/src/parser/backtraceparser.cpp
@@ -18,6 +18,7 @@
 #include "backtraceparser_p.h"
 #include "backtraceparsergdb.h"
 #include "backtraceparserkdbgwin.h"
+#include "backtraceparserlldb.h"
 #include "backtraceparsernull.h"
 #include <QtCore/QRegExp>
 #include <QtCore/QMetaEnum>
@@ -30,6 +31,8 @@
         return new BacktraceParserGdb(parent);
     } else if (debuggerName == QLatin1String("kdbgwin")) {
         return new BacktraceParserKdbgwin(parent);
+    } else if (debuggerName == QLatin1String("lldb")) {
+        return new BacktraceParserLldb(parent);
     } else {
         return new BacktraceParserNull(parent);
     }
--- /dev/null
+++ b/src/parser/backtraceparserlldb.h
@@ -0,0 +1,37 @@
+/*
+    Copyright (C) 2014-2016 René J.V. Bertin <rjvbertin@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+#ifndef BACKTRACEPARSERLLDB_H
+#define BACKTRACEPARSERLLDB_H
+
+#include "backtraceparser.h"
+
+class BacktraceParserLldb : public BacktraceParser
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(BacktraceParser)
+public:
+    explicit BacktraceParserLldb(QObject *parent = nullptr);
+
+protected Q_SLOTS:
+    void newLine(const QString & lineStr) override;
+
+protected:
+    virtual BacktraceParserPrivate *constructPrivate() const;
+};
+
+#endif // BACKTRACEPARSERLLDB_H
--- /dev/null
+++ b/src/parser/backtraceparserlldb.cpp
@@ -0,0 +1,57 @@
+/*
+    Copyright (C) 2014 René J.V. Bertin <rjvbertin@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+#include "backtraceparserlldb.h"
+#include "backtraceparser_p.h"
+
+//BEGIN BacktraceParserLldb
+
+class BacktraceLineLldb : public BacktraceLine
+{
+public:
+    BacktraceLineLldb(const QString &line);
+};
+
+BacktraceLineLldb::BacktraceLineLldb(const QString &line)
+    : BacktraceLine()
+{
+    d->m_line = line;
+    // For now we'll have faith that lldb provides useful information, and that it would
+    // be unwarranted to give it a rating of "MissingEverything".
+    d->m_rating = Good;
+}
+
+//END BacktraceLineLldb
+
+//BEGIN BacktraceParserLldb
+
+BacktraceParserLldb::BacktraceParserLldb(QObject *parent) : BacktraceParser(parent) {}
+
+BacktraceParserPrivate *BacktraceParserLldb::constructPrivate() const
+{
+    BacktraceParserPrivate *d = BacktraceParser::constructPrivate();
+    d->m_usefulness = MayBeUseful;
+    return d;
+}
+
+void BacktraceParserLldb::newLine(const QString &lineStr)
+{
+    d_ptr->m_linesList.append(BacktraceLineLldb(lineStr));
+}
+
+
+//END BacktraceParserLldb

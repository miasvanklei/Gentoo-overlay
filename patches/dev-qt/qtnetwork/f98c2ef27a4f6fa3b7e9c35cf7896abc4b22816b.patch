From f98c2ef27a4f6fa3b7e9c35cf7896abc4b22816b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20L=C3=B6sch?= <sebastian.loesch@governikus.com>
Date: Mon, 10 Aug 2015 12:47:04 +0200
Subject: [PATCH] Abort underlying socket when aborting QNetworkReply

If we abort a connection in QNetworkReply::encrypted the underlying
socket gets flushed. This patch fixes that no data will be transmitted
after someone called abort().

Change-Id: I59306e69cb9f2e1421b324e11947375130e52135
Task-number: QTBUG-47471
Reviewed-by: Markus Goetz (Woboq GmbH) <markus@woboq.com>
Reviewed-by: Thiago Macieira <thiago.macieira@intel.com>
---
 src/network/access/qhttpnetworkconnection.cpp        |  9 +++++++--
 src/network/access/qhttpnetworkconnectionchannel.cpp | 20 ++++++++++++++++++++
 src/network/access/qhttpnetworkconnectionchannel_p.h |  1 +
 src/network/access/qhttpnetworkreply.cpp             | 11 +++++++++++
 src/network/access/qhttpnetworkreply_p.h             |  6 +++++-
 src/network/access/qhttpthreaddelegate.cpp           |  1 +
 6 files changed, 45 insertions(+), 3 deletions(-)

diff --git a/src/network/access/qhttpnetworkconnection.cpp b/src/network/access/qhttpnetworkconnection.cpp
index b7d17be..f810df5 100644
--- a/src/network/access/qhttpnetworkconnection.cpp
+++ b/src/network/access/qhttpnetworkconnection.cpp
@@ -835,8 +835,13 @@ void QHttpNetworkConnectionPrivate::removeReply(QHttpNetworkReply *reply)
             // if HTTP mandates we should close
             // or the reply is not finished yet, e.g. it was aborted
             // we have to close that connection
-            if (reply->d_func()->isConnectionCloseEnabled() || !reply->isFinished())
-                channels[i].close();
+            if (reply->d_func()->isConnectionCloseEnabled() || !reply->isFinished()) {
+                if (reply->isAborted()) {
+                    channels[i].abort();
+                } else {
+                    channels[i].close();
+                }
+            }
 
             QMetaObject::invokeMethod(q, "_q_startNextRequest", Qt::QueuedConnection);
             return;
diff --git a/src/network/access/qhttpnetworkconnectionchannel.cpp b/src/network/access/qhttpnetworkconnectionchannel.cpp
index 477cba2..0820a8d 100644
--- a/src/network/access/qhttpnetworkconnectionchannel.cpp
+++ b/src/network/access/qhttpnetworkconnectionchannel.cpp
@@ -205,6 +205,26 @@ void QHttpNetworkConnectionChannel::close()
 }
 
 
+void QHttpNetworkConnectionChannel::abort()
+{
+    if (!socket)
+        state = QHttpNetworkConnectionChannel::IdleState;
+    else if (socket->state() == QAbstractSocket::UnconnectedState)
+        state = QHttpNetworkConnectionChannel::IdleState;
+    else
+        state = QHttpNetworkConnectionChannel::ClosingState;
+
+    // pendingEncrypt must only be true in between connected and encrypted states
+    pendingEncrypt = false;
+
+    if (socket) {
+        // socket can be 0 since the host lookup is done from qhttpnetworkconnection.cpp while
+        // there is no socket yet.
+        socket->abort();
+    }
+}
+
+
 bool QHttpNetworkConnectionChannel::sendRequest()
 {
     Q_ASSERT(!protocolHandler.isNull());
diff --git a/src/network/access/qhttpnetworkconnectionchannel_p.h b/src/network/access/qhttpnetworkconnectionchannel_p.h
index 37ad6c9..87329b7 100644
--- a/src/network/access/qhttpnetworkconnectionchannel_p.h
+++ b/src/network/access/qhttpnetworkconnectionchannel_p.h
@@ -157,6 +157,7 @@ class QHttpNetworkConnectionChannel : public QObject {
 
     void init();
     void close();
+    void abort();
 
     bool sendRequest();
 
diff --git a/src/network/access/qhttpnetworkreply.cpp b/src/network/access/qhttpnetworkreply.cpp
index 80f3670..b744a99 100644
--- a/src/network/access/qhttpnetworkreply.cpp
+++ b/src/network/access/qhttpnetworkreply.cpp
@@ -247,6 +247,17 @@ char* QHttpNetworkReply::userProvidedDownloadBuffer()
     return d->userProvidedDownloadBuffer;
 }
 
+void QHttpNetworkReply::abort()
+{
+    Q_D(QHttpNetworkReply);
+    d->state = QHttpNetworkReplyPrivate::Aborted;
+}
+
+bool QHttpNetworkReply::isAborted() const
+{
+    return d_func()->state == QHttpNetworkReplyPrivate::Aborted;
+}
+
 bool QHttpNetworkReply::isFinished() const
 {
     return d_func()->state == QHttpNetworkReplyPrivate::AllDoneState;
diff --git a/src/network/access/qhttpnetworkreply_p.h b/src/network/access/qhttpnetworkreply_p.h
index 0fe298d..46b6541 100644
--- a/src/network/access/qhttpnetworkreply_p.h
+++ b/src/network/access/qhttpnetworkreply_p.h
@@ -121,6 +121,9 @@ class Q_AUTOTEST_EXPORT QHttpNetworkReply : public QObject, public QHttpNetworkH
     void setUserProvidedDownloadBuffer(char*);
     char* userProvidedDownloadBuffer();
 
+    void abort();
+
+    bool isAborted() const;
     bool isFinished() const;
 
     bool isPipeliningUsed() const;
@@ -205,7 +208,8 @@ class QHttpNetworkReplyPrivate : public QObjectPrivate, public QHttpNetworkHeade
         SPDYSYNSent,
         SPDYUploading,
         SPDYHalfClosed,
-        SPDYClosed
+        SPDYClosed,
+        Aborted
     } state;
 
     QHttpNetworkRequest request;
diff --git a/src/network/access/qhttpthreaddelegate.cpp b/src/network/access/qhttpthreaddelegate.cpp
index be6fa01..e4931db 100644
--- a/src/network/access/qhttpthreaddelegate.cpp
+++ b/src/network/access/qhttpthreaddelegate.cpp
@@ -396,6 +396,7 @@ void QHttpThreadDelegate::abortRequest()
     qDebug() << "QHttpThreadDelegate::abortRequest() thread=" << QThread::currentThreadId() << "sync=" << synchronous;
 #endif
     if (httpReply) {
+        httpReply->abort();
         delete httpReply;
         httpReply = 0;
     }

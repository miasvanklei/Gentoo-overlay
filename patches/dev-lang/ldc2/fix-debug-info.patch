From c3ee617d8a13bf5b5526e8456c93bfb81cba31d4 Mon Sep 17 00:00:00 2001
From: Elie Morisse <syniurge@gmail.com>
Date: Mon, 27 Jun 2016 23:03:57 -0300
Subject: [PATCH 1/4] Fix LLVM >=3.8 debug info by assigning DISubprograms to
 their corresponding function.

---
 gen/dibuilder.cpp | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git a/gen/dibuilder.cpp b/gen/dibuilder.cpp
index ab2e1dc..1df547c 100644
--- a/gen/dibuilder.cpp
+++ b/gen/dibuilder.cpp
@@ -650,7 +650,7 @@ ldc::DISubprogram ldc::DIBuilder::EmitSubProgram(FuncDeclaration *fd) {
     CreateFunctionType(static_cast<TypeFunction *>(fd->type));
 
   // FIXME: duplicates?
-  return DBuilder.createFunction(
+  auto SP = DBuilder.createFunction(
       CU,                                 // context
       fd->toPrettyChars(),                // name
       getIrFunc(fd)->func->getName(),     // linkage name
@@ -667,6 +667,12 @@ ldc::DISubprogram ldc::DIBuilder::EmitSubProgram(FuncDeclaration *fd) {
       getIrFunc(fd)->func
 #endif
       );
+#if LDC_LLVM_VER >= 308
+  if (fd->fbody) {
+    getIrFunc(fd)->func->setSubprogram(SP);
+  }
+#endif
+  return SP;
 }
 
 ldc::DISubprogram ldc::DIBuilder::EmitThunk(llvm::Function *Thunk,
@@ -695,7 +701,7 @@ ldc::DISubprogram ldc::DIBuilder::EmitThunk(llvm::Function *Thunk,
   name.append(".__thunk");
 
   // FIXME: duplicates?
-  return DBuilder.createFunction(
+  auto SP = DBuilder.createFunction(
       CU,                                 // context
       name,                               // name
       Thunk->getName(),                   // linkage name
@@ -712,6 +718,12 @@ ldc::DISubprogram ldc::DIBuilder::EmitThunk(llvm::Function *Thunk,
       getIrFunc(fd)->func
 #endif
       );
+#if LDC_LLVM_VER >= 308
+  if (fd->fbody) {
+    getIrFunc(fd)->func->setSubprogram(SP);
+  }
+#endif
+  return SP;
 }
 
 ldc::DISubprogram ldc::DIBuilder::EmitModuleCTor(llvm::Function *Fn,
@@ -756,7 +768,7 @@ ldc::DISubprogram ldc::DIBuilder::EmitModuleCTor(llvm::Function *Fn,
 #endif
 
   // FIXME: duplicates?
-  return DBuilder.createFunction(
+  auto SP = DBuilder.createFunction(
       CU,            // context
       prettyname,    // name
       Fn->getName(), // linkage name
@@ -773,6 +785,10 @@ ldc::DISubprogram ldc::DIBuilder::EmitModuleCTor(llvm::Function *Fn,
       Fn
 #endif
       );
+#if LDC_LLVM_VER >= 308
+  Fn->setSubprogram(SP);
+#endif
+  return SP;
 }
 
 void ldc::DIBuilder::EmitFuncStart(FuncDeclaration *fd) {

From 7ac12162920dd6e5d8322e31b22b4f6a97f9b0e3 Mon Sep 17 00:00:00 2001
From: Elie Morisse <syniurge@gmail.com>
Date: Tue, 28 Jun 2016 22:40:49 -0300
Subject: [PATCH 2/4] Nested variables debug info fixes.

 - Fix the value of closure variables in the parent function. Previously the passed value was the GEP instruction into .frame, and that instruction corresponds to a register  so resulted in "DWARF-2 expression error: DW_OP_reg operations must be used either alone(...)" (also the address was incorrect anyway because the offset would get doubled by 'addr')

 - When emitting debug info for a parent function parameter that is accessed from a nested function, call DIBuilder.createAutoVariable instead of createParameterVariable. Two different variables for the same parameter index was triggering an assert in llvm::DbgVariable::addMMIEntry. This fixes the compilation of druntime and phobos when building against LLVM 3.8.
---
 gen/dibuilder.cpp | 6 +++---
 gen/dibuilder.h   | 3 ++-
 gen/nested.cpp    | 4 ++--
 3 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/gen/dibuilder.cpp b/gen/dibuilder.cpp
index 1df547c..e570cef 100644
--- a/gen/dibuilder.cpp
+++ b/gen/dibuilder.cpp
@@ -900,7 +900,7 @@ void ldc::DIBuilder::EmitValue(llvm::Value *val, VarDeclaration *vd) {
 }
 
 void ldc::DIBuilder::EmitLocalVariable(llvm::Value *ll, VarDeclaration *vd,
-                                       Type *type, bool isThisPtr,
+                                       Type *type, bool isThisPtr, bool fromNested,
 #if LDC_LLVM_VER >= 306
                                        llvm::ArrayRef<int64_t> addr
 #else
@@ -935,7 +935,7 @@ void ldc::DIBuilder::EmitLocalVariable(llvm::Value *ll, VarDeclaration *vd,
 
 #if LDC_LLVM_VER < 308
   unsigned tag;
-  if (vd->isParameter()) {
+  if (!fromNested && vd->isParameter()) {
     tag = llvm::dwarf::DW_TAG_arg_variable;
   } else {
     tag = llvm::dwarf::DW_TAG_auto_variable;
@@ -979,7 +979,7 @@ void ldc::DIBuilder::EmitLocalVariable(llvm::Value *ll, VarDeclaration *vd,
                                                Flags                // flags
                                                );
 #else
-  if (vd->isParameter()) {
+  if (!fromNested && vd->isParameter()) {
     FuncDeclaration *fd = vd->parent->isFuncDeclaration();
     assert(fd);
     size_t argNo = 0;
diff --git a/gen/dibuilder.h b/gen/dibuilder.h
index 73d27d3..c936a34 100644
--- a/gen/dibuilder.h
+++ b/gen/dibuilder.h
@@ -137,10 +137,11 @@ class DIBuilder {
   /// \param vd       Variable declaration to emit debug info for.
   /// \param type     Type of parameter if diferent from vd->type
   /// \param isThisPtr Parameter is hidden this pointer
+  /// \param fromNested Is a closure variable accessed through nest_arg
   /// \param addr     An array of complex address operations.
   void
   EmitLocalVariable(llvm::Value *ll, VarDeclaration *vd, Type *type = nullptr,
-                    bool isThisPtr = false,
+                    bool isThisPtr = false, bool fromNested = false,
 #if LDC_LLVM_VER >= 306
                     llvm::ArrayRef<int64_t> addr = llvm::ArrayRef<int64_t>()
 #else
diff --git a/gen/nested.cpp b/gen/nested.cpp
index 688e51e..2076c7d 100644
--- a/gen/nested.cpp
+++ b/gen/nested.cpp
@@ -154,7 +154,7 @@ DValue *DtoNestedVariable(Loc &loc, Type *astype, VarDeclaration *vd,
   }
 
   if (dwarfValue && global.params.symdebug) {
-    gIR->DBuilder.EmitLocalVariable(dwarfValue, vd, nullptr, false, dwarfAddr);
+    gIR->DBuilder.EmitLocalVariable(dwarfValue, vd, nullptr, false, /*fromNested=*/ true, dwarfAddr);
   }
 
   return makeVarDValue(astype, vd, val);
@@ -508,7 +508,7 @@ void DtoCreateNestedContext(FuncDeclaration *fd) {
         LLSmallVector<LLValue *, 2> addr;
 #endif
         gIR->DBuilder.OpOffset(addr, frameType, irLocal->nestedIndex);
-        gIR->DBuilder.EmitLocalVariable(gep, vd, nullptr, false, addr);
+        gIR->DBuilder.EmitLocalVariable(frame, vd, nullptr, false, false, addr);
       }
     }
   }

From 302d71a9de80a0b6c7fc43676ef002f7c1d7d314 Mon Sep 17 00:00:00 2001
From: Elie Morisse <syniurge@gmail.com>
Date: Sat, 2 Jul 2016 21:25:57 -0300
Subject: [PATCH 3/4] MSVC: Attach !dbg info to _d_eh_enter_catch,
 _d_enter_cleanup and _d_leave_cleanup calls.

---
 gen/dibuilder.cpp  |  5 +++++
 gen/dibuilder.h    |  4 ++++
 gen/statements.cpp |  2 ++
 ir/irfunction.cpp  | 21 +++++++++++++++------
 4 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/gen/dibuilder.cpp b/gen/dibuilder.cpp
index e570cef..fee7658 100644
--- a/gen/dibuilder.cpp
+++ b/gen/dibuilder.cpp
@@ -874,6 +874,11 @@ void ldc::DIBuilder::EmitStopPoint(Loc &loc) {
   LOG_SCOPE;
   IR->ir->SetCurrentDebugLocation(
       llvm::DebugLoc::get(loc.linnum, charnum, GetCurrentScope()));
+  currentLoc = loc;
+}
+
+Loc ldc::DIBuilder::GetCurrentLoc() const {
+  return currentLoc;
 }
 
 void ldc::DIBuilder::EmitValue(llvm::Value *val, VarDeclaration *vd) {
diff --git a/gen/dibuilder.h b/gen/dibuilder.h
index c936a34..2285c13 100644
--- a/gen/dibuilder.h
+++ b/gen/dibuilder.h
@@ -87,6 +87,8 @@ class DIBuilder {
 #endif
   }
 
+  Loc currentLoc;
+
 public:
   explicit DIBuilder(IRState *const IR);
 
@@ -127,6 +129,8 @@ class DIBuilder {
   /// \brief Emits debug info for block end
   void EmitBlockEnd();
 
+  Loc GetCurrentLoc() const;
+
   void EmitStopPoint(Loc &loc);
 
   void EmitValue(llvm::Value *val, VarDeclaration *vd);
diff --git a/gen/statements.cpp b/gen/statements.cpp
index e096423..5564634 100644
--- a/gen/statements.cpp
+++ b/gen/statements.cpp
@@ -816,6 +816,8 @@ class ToIRVisitor : public Visitor {
         exnObj = DtoAlloca(var->type, "exnObj");
       }
       irs->scope() = save;
+      irs->DBuilder.EmitStopPoint(ctch->loc); // re-set debug loc after the
+                                              // SetInsertPoint(allocaInst) call
     } else if (ctch->type) {
       // catch without var
       exnObj = DtoAlloca(ctch->type, "exnObj");
diff --git a/ir/irfunction.cpp b/ir/irfunction.cpp
index ed9e929..4fb4c0a 100644
--- a/ir/irfunction.cpp
+++ b/ir/irfunction.cpp
@@ -283,21 +283,30 @@ llvm::BasicBlock *ScopeStack::runCleanupPad(CleanupCursor scope,
   //  can place an exception frame (but not done here)
   auto frame = getNullPtr(getVoidPtrType());
 
+  auto savedInsertBlock = irs->ir->GetInsertBlock();
+  auto savedInsertPoint = irs->ir->GetInsertPoint();
+  auto savedDbgLoc = irs->DBuilder.GetCurrentLoc();
+
   auto endFn = getRuntimeFunction(Loc(), irs->module, "_d_leave_cleanup");
-  llvm::CallInst::Create(endFn, frame,
-                         {llvm::OperandBundleDef("funclet", cleanuppad)}, "",
-                         cleanupret);
+  irs->ir->SetInsertPoint(cleanupret);
+  irs->DBuilder.EmitStopPoint(irs->func()->decl->loc);
+  irs->ir->CreateCall(endFn, frame,
+                      {llvm::OperandBundleDef("funclet", cleanuppad)}, "");
   llvm::CleanupReturnInst::Create(cleanuppad, unwindTo, cleanupret);
 
   auto copybb = executeCleanupCopying(irs, cleanupScopes[scope], cleanupbb,
                                       cleanupret, unwindTo, cleanuppad);
 
   auto beginFn = getRuntimeFunction(Loc(), irs->module, "_d_enter_cleanup");
-  auto exec = llvm::CallInst::Create(
-      beginFn, frame, {llvm::OperandBundleDef("funclet", cleanuppad)}, "",
-      cleanupbb);
+  irs->ir->SetInsertPoint(cleanupbb);
+  irs->DBuilder.EmitStopPoint(irs->func()->decl->loc);
+  auto exec = irs->ir->CreateCall(
+      beginFn, frame, {llvm::OperandBundleDef("funclet", cleanuppad)}, "");
   llvm::BranchInst::Create(copybb, cleanupret, exec, cleanupbb);
 
+  irs->ir->SetInsertPoint(savedInsertBlock, savedInsertPoint);
+  irs->DBuilder.EmitStopPoint(savedDbgLoc);
+
   return cleanupbb;
 }
 #endif

From 282bfb4a5df917ccee1bcae5d8e29c164e7306fe Mon Sep 17 00:00:00 2001
From: Elie Morisse <syniurge@gmail.com>
Date: Sun, 3 Jul 2016 16:49:42 -0300
Subject: [PATCH 4/4] IR debug info tests for nested functions, MSVC
 EH/cleanups.

---
 tests/debuginfo/msvc_eh.d        | 34 ++++++++++++++++++++++++++++++++++
 tests/debuginfo/nested.d         | 28 ++++++++++++++++++++++++++++
 tests/debuginfo/nested_llvm306.d | 22 ++++++++++++++++++++++
 tests/debuginfo/nested_llvm307.d | 23 +++++++++++++++++++++++
 tests/lit.site.cfg.in            |  2 ++
 5 files changed, 109 insertions(+)
 create mode 100755 tests/debuginfo/msvc_eh.d
 create mode 100644 tests/debuginfo/nested.d
 create mode 100644 tests/debuginfo/nested_llvm306.d
 create mode 100644 tests/debuginfo/nested_llvm307.d

diff --git a/tests/debuginfo/msvc_eh.d b/tests/debuginfo/msvc_eh.d
new file mode 100755
index 0000000..8de87a6
--- /dev/null
+++ b/tests/debuginfo/msvc_eh.d
@@ -0,0 +1,34 @@
+// Checks that !dbg is being attached to MSVC EH/cleanup runtime calls.
+// REQUIRES: atleast_llvm308
+// REQUIRES: Windows
+// RUN: %ldc -g -c -output-ll -of=%t.ll %s && FileCheck %s < %t.ll
+
+struct WithDtor
+{
+    int z;
+    ~this() { z = -1; }
+}
+
+void throwSome() 
+{
+    throw new Exception("!");
+}
+
+// CHECK: define {{.*}} @{{.*}}foo_msvc
+// CHECK-SAME: !dbg
+void foo_msvc()
+{
+    try 
+    {
+        WithDtor swd_1;
+        swd_1.z = 24;
+        throwSome();
+    } 
+    catch(Throwable t) 
+    {
+        WithDtor swd_2 = { 48 };
+    }
+    // CHECK-DAG: call {{.*}}@_d_eh_enter_catch{{.*}} !dbg
+    // CHECK-DAG: call {{.*}}@_d_enter_cleanup{{.*}} !dbg
+    // CHECK-DAG: call {{.*}}@_d_leave_cleanup{{.*}} !dbg
+}
diff --git a/tests/debuginfo/nested.d b/tests/debuginfo/nested.d
new file mode 100644
index 0000000..d601941
--- /dev/null
+++ b/tests/debuginfo/nested.d
@@ -0,0 +1,28 @@
+// Tests debug info generation for nested functions
+// REQUIRES: atleast_llvm308
+// RUN: %ldc -g -c -output-ll -of=%t.ll %s && FileCheck %s < %t.ll
+
+// CHECK: define {{.*}} @{{.*}}encloser
+// CHECK-SAME: !dbg
+void encloser(int arg0, int arg1)
+{
+    // CHECK: @llvm.dbg.declare{{.*}}%.frame{{.*}}enc_n
+    int enc_n;
+
+    // CHECK-LABEL: define {{.*}}encloser{{.*}}nested
+    void nested(int nes_i)
+    {
+        // CHECK: @llvm.dbg.declare{{.*}}%nestedFrame{{.*}}arg1
+        arg0 = arg1 = enc_n = nes_i; // accessing arg0, arg1 and enc_n from a nested function turns them into closure variables
+
+        // nes_i and arg1 have the same parameter index in the generated IR, if both get declared as
+        // function parameters this triggers off an assert in LLVM >=3.8 (see Github PR #1598)
+    }
+}
+
+// CHECK-LABEL: !DISubprogram(name:{{.*}}"{{.*}}encloser.nested"
+// CHECK: !DILocalVariable{{.*}}nes_i
+// CHECK-SAME: arg: 2
+// CHECK: !DILocalVariable{{.*}}arg1
+// CHECK-NOT: arg:
+// CHECK-SAME: ){{$}}
diff --git a/tests/debuginfo/nested_llvm306.d b/tests/debuginfo/nested_llvm306.d
new file mode 100644
index 0000000..063c54e
--- /dev/null
+++ b/tests/debuginfo/nested_llvm306.d
@@ -0,0 +1,22 @@
+// Tests debug info generation for nested functions
+// REQUIRES: atmost_llvm306
+// RUN: %ldc -g -c -output-ll -of=%t.ll %s && FileCheck %s < %t.ll
+
+// CHECK-LABEL: define {{.*}} @_D{{.*}}8encloserFiiZv
+void encloser(int arg0, int arg1)
+{
+    // CHECK: @llvm.dbg.declare{{.*}}%.frame{{.*}}enc_n
+    int enc_n;
+
+    // CHECK-LABEL: define {{.*}} @_D{{.*}}encloser{{.*}}nested
+    void nested(int nes_i)
+    {
+        // CHECK: @llvm.dbg.declare{{.*}}%nestedFrame{{.*}}arg1
+        arg0 = arg1 = enc_n = nes_i; // accessing arg0, arg1 and enc_n from a nested function turns them into closure variables
+    }
+}
+
+// CHECK: @_D{{.*}}8encloserFiiZv{{.*}}DW_TAG_subprogram
+// CHECK: @_D{{.*}}8encloserFiiZ6nestedMFiZv{{.*}}DW_TAG_subprogram
+// CHECK: nes_i{{.*}}DW_TAG_arg_variable
+// CHECK: arg1{{.*}}DW_TAG_auto_variable
diff --git a/tests/debuginfo/nested_llvm307.d b/tests/debuginfo/nested_llvm307.d
new file mode 100644
index 0000000..3a3b5b1
--- /dev/null
+++ b/tests/debuginfo/nested_llvm307.d
@@ -0,0 +1,23 @@
+// Tests debug info generation for nested functions
+// REQUIRES: llvm307
+// RUN: %ldc -g -c -output-ll -of=%t.ll %s && FileCheck %s < %t.ll
+
+// CHECK-LABEL: define {{.*}} @_D{{.*}}8encloser
+void encloser(int arg0, int arg1)
+{
+    // CHECK: @llvm.dbg.declare{{.*}}%.frame{{.*}}enc_n
+    int enc_n;
+
+    // CHECK-LABEL: define {{.*}} @_D{{.*}}8encloser{{.*}}nested
+    void nested(int nes_i)
+    {
+        // CHECK: @llvm.dbg.declare{{.*}}%nestedFrame{{.*}}arg1
+        arg0 = arg1 = enc_n = nes_i; // accessing arg0, arg1 and enc_n from a nested function turns them into closure variables
+    }
+}
+
+// CHECK: !DISubprogram(name:{{.*}}"{{.*}}.encloser"
+// CHECK-SAME: function: void {{.*}} @_D{{.*}}8encloserFiiZv
+// CHECK-LABEL: !DISubprogram(name:{{.*}}"{{.*}}.encloser.nested"
+// CHECK: !DILocalVariable{{.*}}DW_TAG_arg_variable{{.*}}nes_i
+// CHECK: !DILocalVariable{{.*}}DW_TAG_auto_variable{{.*}}arg1
diff --git a/tests/lit.site.cfg.in b/tests/lit.site.cfg.in
index 68ba1ca..d89befa 100644
--- a/tests/lit.site.cfg.in
+++ b/tests/lit.site.cfg.in
@@ -43,6 +43,8 @@ if not config.with_PGO:
 config.available_features.add("llvm%d" % config.llvm_version)
 for version in range(305, config.llvm_version+1):
     config.available_features.add("atleast_llvm%d" % version)
+for version in range(config.llvm_version, 310):
+    config.available_features.add("atmost_llvm%d" % version)
 
 # Define OS as available feature (Windows, Darwin, Linux)
 config.available_features.add(platform.system())

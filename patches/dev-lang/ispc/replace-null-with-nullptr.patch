--- ctx.cpp.bak	2016-01-29 22:27:46.902659258 +0100
+++ ctx.cpp	2016-01-29 22:30:56.927062077 +0100
@@ -124,19 +124,19 @@
         Assert(t == If);
         type = t;
         isUniform = uniformIf;
-        savedBreakTarget = savedContinueTarget = NULL;
-        savedBreakLanesPtr = savedContinueLanesPtr = NULL;
+        savedBreakTarget = savedContinueTarget = nullptr;
+        savedBreakLanesPtr = savedContinueLanesPtr = nullptr;
         savedMask = savedBlockEntryMask = sm;
-        savedSwitchExpr = NULL;
-        savedDefaultBlock = NULL;
-        savedCaseBlocks = NULL;
-        savedNextBlocks = NULL;
+        savedSwitchExpr = nullptr;
+        savedDefaultBlock = nullptr;
+        savedCaseBlocks = nullptr;
+        savedNextBlocks = nullptr;
     }
     CFInfo(CFType t, bool iu, llvm::BasicBlock *bt, llvm::BasicBlock *ct,
            llvm::Value *sb, llvm::Value *sc, llvm::Value *sm,
-           llvm::Value *lm, llvm::Value *sse = NULL, llvm::BasicBlock *bbd = NULL,
-           const std::vector<std::pair<int, llvm::BasicBlock *> > *bbc = NULL,
-           const std::map<llvm::BasicBlock *, llvm::BasicBlock *> *bbn = NULL,
+           llvm::Value *lm, llvm::Value *sse = nullptr, llvm::BasicBlock *bbd = nullptr,
+           const std::vector<std::pair<int, llvm::BasicBlock *> > *bbc = nullptr,
+           const std::map<llvm::BasicBlock *, llvm::BasicBlock *> *bbn = nullptr,
            bool scu = false) {
         Assert(t == Loop || t == Switch);
         type = t;
@@ -165,10 +165,10 @@
         savedContinueLanesPtr = sc;
         savedMask = sm;
         savedBlockEntryMask = lm;
-        savedSwitchExpr = NULL;
-        savedDefaultBlock = NULL;
-        savedCaseBlocks = NULL;
-        savedNextBlocks = NULL;
+        savedSwitchExpr = nullptr;
+        savedDefaultBlock = nullptr;
+        savedCaseBlocks = nullptr;
+        savedNextBlocks = nullptr;
     }
 };
 
@@ -211,7 +211,7 @@
         break;
     default:
         FATAL("Unhandled foreach type");
-        return NULL;
+        return nullptr;
     }
 
     return new CFInfo(cfType, breakTarget, continueTarget,
@@ -260,14 +260,14 @@
     fullMaskPointer = AllocaInst(LLVMTypes::MaskType, "full_mask_memory");
     StoreInst(LLVMMaskAllOn, fullMaskPointer);
 
-    blockEntryMask = NULL;
-    breakLanesPtr = continueLanesPtr = NULL;
-    breakTarget = continueTarget = NULL;
-
-    switchExpr = NULL;
-    caseBlocks = NULL;
-    defaultBlock = NULL;
-    nextBlocks = NULL;
+    blockEntryMask = nullptr;
+    breakLanesPtr = continueLanesPtr = nullptr;
+    breakTarget = continueTarget = nullptr;
+
+    switchExpr = nullptr;
+    caseBlocks = nullptr;
+    defaultBlock = nullptr;
+    nextBlocks = nullptr;
 
     returnedLanesPtr = AllocaInst(LLVMTypes::MaskType, "returned_lanes_memory");
     StoreInst(LLVMMaskAllOff, returnedLanesPtr);
@@ -281,7 +281,7 @@
 
     const Type *returnType = function->GetReturnType();
     if (!returnType || returnType->IsVoidType())
-        returnValuePtr = NULL;
+        returnValuePtr = nullptr;
     else {
         llvm::Type *ftype = returnType->LLVMType(g->ctx);
         returnValuePtr = AllocaInst(ftype, "return_value_memory");
@@ -305,7 +305,7 @@
         // function is never actually called.)
         llvm::Value *globalAllOnMaskPtr =
             m->module->getNamedGlobal("__all_on_mask");
-        if (globalAllOnMaskPtr == NULL) {
+        if (globalAllOnMaskPtr == nullptr) {
             globalAllOnMaskPtr =
                 new llvm::GlobalVariable(*m->module, LLVMTypes::MaskType, false,
                                          llvm::GlobalValue::InternalLinkage,
@@ -315,7 +315,7 @@
             sprintf(buf, "__off_all_on_mask_%s", g->target->GetISAString());
             llvm::Constant *offFunc =
                 m->module->getOrInsertFunction(buf, LLVMTypes::VoidType,
-                                               NULL);
+                                               nullptr);
             AssertPos(currentPos, llvm::isa<llvm::Function>(offFunc));
             llvm::BasicBlock *offBB =
                    llvm::BasicBlock::Create(*g->ctx, "entry",
@@ -356,12 +356,12 @@
         llvm::DIType diSubprogramType;
         AssertPos(currentPos, scope.Verify());
 #else /* LLVM 3.7+ */
-        llvm::DIType *diSubprogramType = NULL;
-        //llvm::MDType *diSubprogramType = NULL;
+        llvm::DIType *diSubprogramType = nullptr;
+        //llvm::MDType *diSubprogramType = nullptr;
 #endif
 
         const FunctionType *functionType = function->GetType();
-        if (functionType == NULL)
+        if (functionType == nullptr)
             AssertPos(currentPos, m->errorCount > 0);
         else {
             diSubprogramType = functionType->GetDIType(scope);
@@ -485,7 +485,7 @@
 void
 FunctionEmitContext::SetFunctionMask(llvm::Value *value) {
     functionMaskValue = value;
-    if (bblock != NULL)
+    if (bblock != nullptr)
         StoreInst(GetFullMask(), fullMaskPointer);
 }
 
@@ -524,34 +524,34 @@
 
 void
 FunctionEmitContext::BranchIfMaskAny(llvm::BasicBlock *btrue, llvm::BasicBlock *bfalse) {
-    AssertPos(currentPos, bblock != NULL);
+    AssertPos(currentPos, bblock != nullptr);
     llvm::Value *any = Any(GetFullMask());
     BranchInst(btrue, bfalse, any);
     // It's illegal to add any additional instructions to the basic block
-    // now that it's terminated, so set bblock to NULL to be safe
-    bblock = NULL;
+    // now that it's terminated, so set bblock to nullptr to be safe
+    bblock = nullptr;
 }
 
 
 void
 FunctionEmitContext::BranchIfMaskAll(llvm::BasicBlock *btrue, llvm::BasicBlock *bfalse) {
-    AssertPos(currentPos, bblock != NULL);
+    AssertPos(currentPos, bblock != nullptr);
     llvm::Value *all = All(GetFullMask());
     BranchInst(btrue, bfalse, all);
     // It's illegal to add any additional instructions to the basic block
-    // now that it's terminated, so set bblock to NULL to be safe
-    bblock = NULL;
+    // now that it's terminated, so set bblock to nullptr to be safe
+    bblock = nullptr;
 }
 
 
 void
 FunctionEmitContext::BranchIfMaskNone(llvm::BasicBlock *btrue, llvm::BasicBlock *bfalse) {
-    AssertPos(currentPos, bblock != NULL);
+    AssertPos(currentPos, bblock != nullptr);
     // switch sense of true/false bblocks
     BranchIfMaskAny(bfalse, btrue);
     // It's illegal to add any additional instructions to the basic block
-    // now that it's terminated, so set bblock to NULL to be safe
-    bblock = NULL;
+    // now that it's terminated, so set bblock to nullptr to be safe
+    bblock = nullptr;
 }
 
 
@@ -575,7 +575,7 @@
 
     // 'uniform' ifs don't change the mask so we only need to restore the
     // mask going into the if for 'varying' if statements
-    if (ci->IsUniform() || bblock == NULL)
+    if (ci->IsUniform() || bblock == nullptr)
         return;
 
     // We can't just restore the mask as it was going into the 'if'
@@ -596,22 +596,22 @@
     //
     // There are three general cases to deal with here:
     // - Loops: both break and continue are allowed, and thus the corresponding
-    //   lane mask pointers are non-NULL
-    // - Foreach: only continueLanesPtr may be non-NULL
-    // - Switch: only breakLanesPtr may be non-NULL
-    if (continueLanesPtr != NULL || breakLanesPtr != NULL) {
+    //   lane mask pointers are non-nullptr
+    // - Foreach: only continueLanesPtr may be non-nullptr
+    // - Switch: only breakLanesPtr may be non-nullptr
+    if (continueLanesPtr != nullptr || breakLanesPtr != nullptr) {
         // We want to compute:
         // newMask = (oldMask & ~(breakLanes | continueLanes)),
         // treading breakLanes or continueLanes as "all off" if the
-        // corresponding pointer is NULL.
-        llvm::Value *bcLanes = NULL;
+        // corresponding pointer is nullptr.
+        llvm::Value *bcLanes = nullptr;
 
-        if (continueLanesPtr != NULL)
+        if (continueLanesPtr != nullptr)
             bcLanes = LoadInst(continueLanesPtr, "continue_lanes");
         else
             bcLanes = LLVMMaskAllOff;
 
-        if (breakLanesPtr != NULL) {
+        if (breakLanesPtr != nullptr) {
             llvm::Value *breakLanes = LoadInst(breakLanesPtr, "break_lanes");
             bcLanes = BinaryOperator(llvm::Instruction::Or, bcLanes,
                                      breakLanes, "|break_lanes");
@@ -643,7 +643,7 @@
         // If the loop has a uniform condition, we don't need to track
         // which lanes 'break' or 'continue'; all of the running ones go
         // together, so we just jump
-        breakLanesPtr = continueLanesPtr = NULL;
+        breakLanesPtr = continueLanesPtr = nullptr;
     else {
         // For loops with varying conditions, allocate space to store masks
         // that record which lanes have done these
@@ -655,7 +655,7 @@
 
     breakTarget = bt;
     continueTarget = ct;
-    blockEntryMask = NULL; // this better be set by the loop!
+    blockEntryMask = nullptr; // this better be set by the loop!
 }
 
 
@@ -697,14 +697,14 @@
     controlFlowInfo.push_back(CFInfo::GetForeach(ft, breakTarget, continueTarget,
                                                  breakLanesPtr, continueLanesPtr,
                                                  oldMask, blockEntryMask));
-    breakLanesPtr = NULL;
-    breakTarget = NULL;
+    breakLanesPtr = nullptr;
+    breakTarget = nullptr;
 
     continueLanesPtr = AllocaInst(LLVMTypes::MaskType, "foreach_continue_lanes");
     StoreInst(LLVMMaskAllOff, continueLanesPtr);
-    continueTarget = NULL; // should be set by SetContinueTarget()
+    continueTarget = nullptr; // should be set by SetContinueTarget()
 
-    blockEntryMask = NULL;
+    blockEntryMask = nullptr;
 }
 
 
@@ -753,14 +753,14 @@
 
 void
 FunctionEmitContext::Break(bool doCoherenceCheck) {
-    if (breakTarget == NULL) {
+    if (breakTarget == nullptr) {
         Error(currentPos, "\"break\" statement is illegal outside of "
               "for/while/do loops and \"switch\" statements.");
         return;
     }
     AssertPos(currentPos, controlFlowInfo.size() > 0);
 
-    if (bblock == NULL)
+    if (bblock == nullptr)
         return;
 
     if (inSwitchStatement() == true &&
@@ -768,9 +768,9 @@
         ifsInCFAllUniform(CFInfo::Switch)) {
         // We know that all program instances are executing the break, so
         // just jump to the block immediately after the switch.
-        AssertPos(currentPos, breakTarget != NULL);
+        AssertPos(currentPos, breakTarget != nullptr);
         BranchInst(breakTarget);
-        bblock = NULL;
+        bblock = nullptr;
         return;
     }
 
@@ -779,8 +779,8 @@
     // jump to the break location.
     if (inSwitchStatement() == false && ifsInCFAllUniform(CFInfo::Loop)) {
         BranchInst(breakTarget);
-        // Set bblock to NULL since the jump has terminated the basic block
-        bblock = NULL;
+        // Set bblock to nullptr since the jump has terminated the basic block
+        bblock = nullptr;
     }
     else {
         // Varying switch, uniform switch where the 'break' is under
@@ -788,7 +788,7 @@
         // break.  In these cases, we need to update the mask of the lanes
         // that have executed a 'break' statement:
         // breakLanes = breakLanes | mask
-        AssertPos(currentPos, breakLanesPtr != NULL);
+        AssertPos(currentPos, breakLanesPtr != nullptr);
 
         llvm::Value *mask = GetInternalMask();
         llvm::Value *breakMask = LoadInst(breakLanesPtr,
@@ -804,7 +804,7 @@
         SetInternalMask(LLVMMaskAllOff);
 
         if (doCoherenceCheck) {
-            if (continueTarget != NULL)
+            if (continueTarget != nullptr)
                 // If the user has indicated that this is a 'coherent'
                 // break statement, then check to see if the mask is all
                 // off.  If so, we have to conservatively jump to the
@@ -812,7 +812,7 @@
                 // reason the mask is all off may be due to 'continue'
                 // statements that executed in the current loop iteration.
                 jumpIfAllLoopLanesAreDone(continueTarget);
-            else if (breakTarget != NULL)
+            else if (breakTarget != nullptr)
                 // Similarly handle these for switch statements, where we
                 // only have a break target.
                 jumpIfAllLoopLanesAreDone(breakTarget);
@@ -850,7 +850,7 @@
         // executing.
         AddInstrumentationPoint("continue: uniform CF, jumped");
         BranchInst(continueTarget);
-        bblock = NULL;
+        bblock = nullptr;
     }
     else {
         // Otherwise update the stored value of which lanes have 'continue'd.
@@ -901,9 +901,9 @@
 
 void
 FunctionEmitContext::jumpIfAllLoopLanesAreDone(llvm::BasicBlock *target) {
-    llvm::Value *allDone = NULL;
+    llvm::Value *allDone = nullptr;
 
-    if (breakLanesPtr == NULL) {
+    if (breakLanesPtr == nullptr) {
         llvm::Value *continued = LoadInst(continueLanesPtr,
                                           "continue_lanes");
         continued = BinaryOperator(llvm::Instruction::And,
@@ -921,8 +921,8 @@
         llvm::Value *finishedLanes = BinaryOperator(llvm::Instruction::Or,
                                                     returned, breaked,
                                                     "returned|breaked");
-        if (continueLanesPtr != NULL) {
-            // It's NULL for "switch" statements...
+        if (continueLanesPtr != nullptr) {
+            // It's nullptr for "switch" statements...
             llvm::Value *continued = LoadInst(continueLanesPtr,
                                               "continue_lanes");
             finishedLanes = BinaryOperator(llvm::Instruction::Or, finishedLanes,
@@ -956,7 +956,7 @@
 
 void
 FunctionEmitContext::RestoreContinuedLanes() {
-    if (continueLanesPtr == NULL)
+    if (continueLanesPtr == nullptr)
         return;
 
     // mask = mask & continueFlags
@@ -974,7 +974,7 @@
 
 void
 FunctionEmitContext::ClearBreakLanes() {
-  if (breakLanesPtr == NULL)
+  if (breakLanesPtr == nullptr)
     return;
 
   // breakLanes = 0
@@ -996,24 +996,24 @@
     StoreInst(LLVMMaskAllOff, breakLanesPtr);
     breakTarget = bbBreak;
 
-    continueLanesPtr = NULL;
-    continueTarget = NULL;
-    blockEntryMask = NULL;
+    continueLanesPtr = nullptr;
+    continueTarget = nullptr;
+    blockEntryMask = nullptr;
 
     // These will be set by the SwitchInst() method
-    switchExpr = NULL;
-    defaultBlock = NULL;
-    caseBlocks = NULL;
-    nextBlocks = NULL;
+    switchExpr = nullptr;
+    defaultBlock = nullptr;
+    caseBlocks = nullptr;
+    nextBlocks = nullptr;
 }
 
 
 void
 FunctionEmitContext::EndSwitch() {
-    AssertPos(currentPos, bblock != NULL);
+    AssertPos(currentPos, bblock != nullptr);
 
     CFInfo *ci = popCFState();
-    if (ci->IsVarying() && bblock != NULL)
+    if (ci->IsVarying() && bblock != nullptr)
         restoreMaskGivenReturns(ci->savedMask);
 }
 
@@ -1062,9 +1062,9 @@
 
     // If there's a default label in the switch, a basic block for it
     // should have been provided in the previous call to SwitchInst().
-    AssertPos(currentPos, defaultBlock != NULL);
+    AssertPos(currentPos, defaultBlock != nullptr);
 
-    if (bblock != NULL)
+    if (bblock != nullptr)
         // The previous case in the switch fell through, or we're in a
         // varying switch; terminate the current block with a jump to the
         // block for the code for the default label.
@@ -1123,16 +1123,16 @@
     }
 
     // Find the basic block for this case statement.
-    llvm::BasicBlock *bbCase = NULL;
-    AssertPos(currentPos, caseBlocks != NULL);
+    llvm::BasicBlock *bbCase = nullptr;
+    AssertPos(currentPos, caseBlocks != nullptr);
     for (int i = 0; i < (int)caseBlocks->size(); ++i)
         if ((*caseBlocks)[i].first == value) {
             bbCase = (*caseBlocks)[i].second;
             break;
         }
-    AssertPos(currentPos, bbCase != NULL);
+    AssertPos(currentPos, bbCase != nullptr);
 
-    if (bblock != NULL)
+    if (bblock != nullptr)
         // fall through from the previous case
         BranchInst(bbCase);
     SetCurrentBasicBlock(bbCase);
@@ -1199,7 +1199,7 @@
 
         AddDebugPos(s);
         // switch is a terminator
-        bblock = NULL;
+        bblock = nullptr;
     }
     else {
         // For a varying switch, we first turn off all lanes of the mask
@@ -1210,11 +1210,11 @@
             // one; any code before the first label won't be executed by
             // anyone.
             std::map<llvm::BasicBlock *, llvm::BasicBlock *>::const_iterator iter;
-            iter = nextBlocks->find(NULL);
+            iter = nextBlocks->find(nullptr);
             AssertPos(currentPos, iter != nextBlocks->end());
             llvm::BasicBlock *bbFirst = iter->second;
             BranchInst(bbFirst);
-            bblock = NULL;
+            bblock = nullptr;
         }
     }
 }
@@ -1255,7 +1255,7 @@
 bool
 FunctionEmitContext::initLabelBBlocks(ASTNode *node, void *data) {
     LabeledStmt *ls = llvm::dyn_cast<LabeledStmt>(node);
-    if (ls == NULL)
+    if (ls == nullptr)
         return true;
 
     FunctionEmitContext *ctx = (FunctionEmitContext *)data;
@@ -1274,7 +1274,7 @@
 void
 FunctionEmitContext::InitializeLabelMap(Stmt *code) {
     labelMap.erase(labelMap.begin(), labelMap.end());
-    WalkAST(code, initLabelBBlocks, NULL, this);
+    WalkAST(code, initLabelBBlocks, nullptr, this);
 }
 
 
@@ -1283,7 +1283,7 @@
     if (labelMap.find(label) != labelMap.end())
         return labelMap[label];
     else
-        return NULL;
+        return nullptr;
 }
 
 std::vector<std::string>
@@ -1304,23 +1304,23 @@
 FunctionEmitContext::CurrentLanesReturned(Expr *expr, bool doCoherenceCheck) {
     const Type *returnType = function->GetReturnType();
     if (returnType->IsVoidType()) {
-        if (expr != NULL)
+        if (expr != nullptr)
             Error(expr->pos, "Can't return non-void type \"%s\" from void function.",
                   expr->GetType()->GetString().c_str());
     }
     else {
-        if (expr == NULL) {
+        if (expr == nullptr) {
             Error(funcStartPos, "Must provide return value for return "
                   "statement for non-void function.");
             return;
         }
 
         expr = TypeConvertExpr(expr, returnType, "return statement");
-        if (expr != NULL) {
+        if (expr != nullptr) {
             llvm::Value *retVal = expr->GetValue(this);
-            if (retVal != NULL) {
+            if (retVal != nullptr) {
                 if (returnType->IsUniformType() ||
-                    CastType<ReferenceType>(returnType) != NULL)
+                    CastType<ReferenceType>(returnType) != nullptr)
                     StoreInst(retVal, returnValuePtr);
                 else {
                     // Use a masked store to store the value of the expression
@@ -1389,7 +1389,7 @@
     // We can actually call either one, since both are i32s as far as
     // LLVM's type system is concerned...
     llvm::Function *fmm = mm[0]->function;
-    return CallInst(fmm, NULL, mask, LLVMGetName(mask, "_any"));
+    return CallInst(fmm, nullptr, mask, LLVMGetName(mask, "_any"));
 }
 
 
@@ -1407,7 +1407,7 @@
     // We can actually call either one, since both are i32s as far as
     // LLVM's type system is concerned...
     llvm::Function *fmm = mm[0]->function;
-    return CallInst(fmm, NULL, mask, LLVMGetName(mask, "_all"));
+    return CallInst(fmm, nullptr, mask, LLVMGetName(mask, "_all"));
 }
 
 
@@ -1425,7 +1425,7 @@
     // We can actually call either one, since both are i32s as far as
     // LLVM's type system is concerned...
     llvm::Function *fmm = mm[0]->function;
-    return CallInst(fmm, NULL, mask, LLVMGetName(mask, "_none"));
+    return CallInst(fmm, nullptr, mask, LLVMGetName(mask, "_none"));
 }
 
 
@@ -1450,7 +1450,7 @@
     // We can actually call either one, since both are i32s as far as
     // LLVM's type system is concerned...
     llvm::Function *fmm = mm[0]->function;
-    return CallInst(fmm, NULL, v, LLVMGetName(v, "_movmsk"));
+    return CallInst(fmm, nullptr, v, LLVMGetName(v, "_movmsk"));
 }
 
 #ifdef ISPC_NVPTX_ENABLED
@@ -1482,7 +1482,7 @@
   assert(lane->getType() == LLVMTypes::Int32Type);
   
   llvm::Function *func = m->module->getFunction(funcName.c_str());
-  assert(func != NULL);
+  assert(func != nullptr);
   std::vector<llvm::Value *> args;
   args.push_back(vector);
   args.push_back(lane);
@@ -1499,7 +1499,7 @@
   assert(lane->getType() == LLVMTypes::Int32Type);
   
   llvm::Function *func = m->module->getFunction(funcName.c_str());
-  assert(func != NULL);
+  assert(func != nullptr);
   std::vector<llvm::Value *> args;
   args.push_back(vector);
   args.push_back(lane);
@@ -1554,7 +1554,7 @@
 llvm::Value *
 FunctionEmitContext::ProgramIndexVectorPTX(bool is32bits) {
     llvm::Function *func_program_index  = m->module->getFunction("__program_index");
-    llvm::Value *__program_index    = CallInst(func_program_index, NULL, std::vector<llvm::Value*>(), "foreach__program_indexS");
+    llvm::Value *__program_index    = CallInst(func_program_index, nullptr, std::vector<llvm::Value*>(), "foreach__program_indexS");
     llvm::Value *index = InsertInst(llvm::UndefValue::get(LLVMTypes::Int32VectorType), __program_index, 0, "foreach__program_indexV");
 #if 0
     if (!is32bits)
@@ -1585,9 +1585,9 @@
 
 llvm::Value *
 FunctionEmitContext::I1VecToBoolVec(llvm::Value *b) {
-    if (b == NULL) {
+    if (b == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     if (g->target->getMaskBitCount() == 1)
@@ -1637,7 +1637,7 @@
 
 void
 FunctionEmitContext::AddInstrumentationPoint(const char *note) {
-    AssertPos(currentPos, note != NULL);
+    AssertPos(currentPos, note != nullptr);
     if (!g->emitInstrumentation)
         return;
 
@@ -1652,7 +1652,7 @@
     args.push_back(LaneMask(GetFullMask()));
 
     llvm::Function *finst = m->module->getFunction("ISPCInstrument");
-    CallInst(finst, NULL, args, "");
+    CallInst(finst, nullptr, args, "");
 }
 
 
@@ -1677,7 +1677,7 @@
                                  //llvm::MDScope *scope) {
 #endif
     llvm::Instruction *inst = llvm::dyn_cast<llvm::Instruction>(value);
-    if (inst != NULL && m->diBuilder) {
+    if (inst != nullptr && m->diBuilder) {
         SourcePos p = pos ? *pos : currentPos;
         if (p.first_line != 0)
             // If first_line == 0, then we're in the middle of setting up
@@ -1697,7 +1697,7 @@
 
 void
 FunctionEmitContext::StartScope() {
-    if (m->diBuilder != NULL) {
+    if (m->diBuilder != nullptr) {
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
         llvm::DIScope parentScope;
         llvm::DILexicalBlock lexicalBlock;
@@ -1738,7 +1738,7 @@
 
 void
 FunctionEmitContext::EndScope() {
-    if (m->diBuilder != NULL) {
+    if (m->diBuilder != nullptr) {
         AssertPos(currentPos, debugScopes.size() > 0);
         debugScopes.pop_back();
     }
@@ -1759,7 +1759,7 @@
 
 void
 FunctionEmitContext::EmitVariableDebugInfo(Symbol *sym) {
-    if (m->diBuilder == NULL)
+    if (m->diBuilder == nullptr)
         return;
 
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
@@ -1817,7 +1817,7 @@
 
 void
 FunctionEmitContext::EmitFunctionParameterDebugInfo(Symbol *sym, int argNum) {
-    if (m->diBuilder == NULL)
+    if (m->diBuilder == nullptr)
         return;
 
     int flags = 0;
@@ -1886,14 +1886,14 @@
 lArrayVectorWidth(llvm::Type *t) {
     llvm::ArrayType *arrayType =
         llvm::dyn_cast<llvm::ArrayType>(t);
-    if (arrayType == NULL)
+    if (arrayType == nullptr)
         return 0;
 
     // We shouldn't be seeing arrays of anything but vectors being passed
     // to things like FunctionEmitContext::BinaryOperator() as operands.
     llvm::VectorType *vectorElementType =
         llvm::dyn_cast<llvm::VectorType>(arrayType->getElementType());
-    Assert((vectorElementType != NULL &&
+    Assert((vectorElementType != nullptr &&
             (int)vectorElementType->getNumElements() == g->target->getVectorWidth()));
 
     return (int)arrayType->getNumElements();
@@ -1904,9 +1904,9 @@
 FunctionEmitContext::BinaryOperator(llvm::Instruction::BinaryOps inst,
                                     llvm::Value *v0, llvm::Value *v1,
                                     const char *name) {
-    if (v0 == NULL || v1 == NULL) {
+    if (v0 == nullptr || v1 == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     AssertPos(currentPos, v0->getType() == v1->getType());
@@ -1936,9 +1936,9 @@
 
 llvm::Value *
 FunctionEmitContext::NotOperator(llvm::Value *v, const char *name) {
-    if (v == NULL) {
+    if (v == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     // Similarly to BinaryOperator, do the operation on all the elements of
@@ -1973,11 +1973,11 @@
 lGetMatchingBoolVectorType(llvm::Type *type) {
     llvm::ArrayType *arrayType =
         llvm::dyn_cast<llvm::ArrayType>(type);
-    Assert(arrayType != NULL);
+    Assert(arrayType != nullptr);
 
     llvm::VectorType *vectorElementType =
         llvm::dyn_cast<llvm::VectorType>(arrayType->getElementType());
-    Assert(vectorElementType != NULL);
+    Assert(vectorElementType != nullptr);
     Assert((int)vectorElementType->getNumElements() == g->target->getVectorWidth());
 
     llvm::Type *base =
@@ -1991,9 +1991,9 @@
                              llvm::CmpInst::Predicate pred,
                              llvm::Value *v0, llvm::Value *v1,
                              const char *name) {
-    if (v0 == NULL || v1 == NULL) {
+    if (v0 == nullptr || v1 == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     AssertPos(currentPos, v0->getType() == v1->getType());
@@ -2022,18 +2022,18 @@
 
 llvm::Value *
 FunctionEmitContext::SmearUniform(llvm::Value *value, const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    llvm::Value *ret = NULL;
+    llvm::Value *ret = nullptr;
     llvm::Type *eltType = value->getType();
-    llvm::Type *vecType = NULL;
+    llvm::Type *vecType = nullptr;
 
     llvm::PointerType *pt =
         llvm::dyn_cast<llvm::PointerType>(eltType);
-    if (pt != NULL) {
+    if (pt != nullptr) {
         // Varying pointers are represented as vectors of i32/i64s
         vecType = LLVMTypes::VoidPointerVectorType;
         value = PtrToIntInst(value);
@@ -2061,12 +2061,12 @@
 llvm::Value *
 FunctionEmitContext::BitCastInst(llvm::Value *value, llvm::Type *type,
                                  const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_bitcast");
 
     llvm::Instruction *inst = new llvm::BitCastInst(value, type, name, bblock);
@@ -2077,16 +2077,16 @@
 
 llvm::Value *
 FunctionEmitContext::PtrToIntInst(llvm::Value *value, const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     if (llvm::isa<llvm::VectorType>(value->getType()))
         // no-op for varying pointers; they're already vectors of ints
         return value;
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_ptr2int");
     llvm::Type *type = LLVMTypes::PointerIntType;
     llvm::Instruction *inst = new llvm::PtrToIntInst(value, type, name, bblock);
@@ -2098,12 +2098,12 @@
 llvm::Value *
 FunctionEmitContext::PtrToIntInst(llvm::Value *value, llvm::Type *toType,
                                   const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_ptr2int");
 
     llvm::Type *fromType = value->getType();
@@ -2130,12 +2130,12 @@
 llvm::Value *
 FunctionEmitContext::IntToPtrInst(llvm::Value *value, llvm::Type *toType,
                                   const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_int2ptr");
 
     llvm::Type *fromType = value->getType();
@@ -2163,12 +2163,12 @@
 llvm::Instruction *
 FunctionEmitContext::TruncInst(llvm::Value *value, llvm::Type *type,
                                const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_trunc");
 
     // TODO: we should probably handle the array case as in
@@ -2182,12 +2182,12 @@
 llvm::Instruction *
 FunctionEmitContext::CastInst(llvm::Instruction::CastOps op, llvm::Value *value,
                               llvm::Type *type, const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_cast");
 
     // TODO: we should probably handle the array case as in
@@ -2202,12 +2202,12 @@
 llvm::Instruction *
 FunctionEmitContext::FPCastInst(llvm::Value *value, llvm::Type *type,
                                 const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_cast");
 
     // TODO: we should probably handle the array case as in
@@ -2221,12 +2221,12 @@
 llvm::Instruction *
 FunctionEmitContext::SExtInst(llvm::Value *value, llvm::Type *type,
                               const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_sext");
 
     // TODO: we should probably handle the array case as in
@@ -2240,12 +2240,12 @@
 llvm::Instruction *
 FunctionEmitContext::ZExtInst(llvm::Value *value, llvm::Type *type,
                               const char *name) {
-    if (value == NULL) {
+    if (value == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(value, "_zext");
 
     // TODO: we should probably handle the array case as in
@@ -2272,7 +2272,7 @@
 
     bool indexIsVarying =
         llvm::isa<llvm::VectorType>(index->getType());
-    llvm::Value *offset = NULL;
+    llvm::Value *offset = nullptr;
     if (indexIsVarying == false) {
         // Truncate or sign extend the index as appropriate to a 32 or
         // 64-bit type.
@@ -2427,18 +2427,18 @@
 llvm::Value *
 FunctionEmitContext::GetElementPtrInst(llvm::Value *basePtr, llvm::Value *index,
                                        const Type *ptrRefType, const char *name) {
-    if (basePtr == NULL || index == NULL) {
+    if (basePtr == nullptr || index == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     // Regularize to a standard pointer type for basePtr's type
     const PointerType *ptrType;
-    if (CastType<ReferenceType>(ptrRefType) != NULL)
+    if (CastType<ReferenceType>(ptrRefType) != nullptr)
         ptrType = PointerType::GetUniform(ptrRefType->GetReferenceTarget());
     else {
         ptrType = CastType<PointerType>(ptrRefType);
-        AssertPos(currentPos, ptrType != NULL);
+        AssertPos(currentPos, ptrType != nullptr);
     }
 
     if (ptrType->IsSlice()) {
@@ -2504,18 +2504,18 @@
 FunctionEmitContext::GetElementPtrInst(llvm::Value *basePtr, llvm::Value *index0,
                                        llvm::Value *index1, const Type *ptrRefType,
                                        const char *name) {
-    if (basePtr == NULL || index0 == NULL || index1 == NULL) {
+    if (basePtr == nullptr || index0 == nullptr || index1 == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     // Regaularize the pointer type for basePtr
-    const PointerType *ptrType = NULL;
-    if (CastType<ReferenceType>(ptrRefType) != NULL)
+    const PointerType *ptrType = nullptr;
+    if (CastType<ReferenceType>(ptrRefType) != nullptr)
         ptrType = PointerType::GetUniform(ptrRefType->GetReferenceTarget());
     else {
         ptrType = CastType<PointerType>(ptrRefType);
-        AssertPos(currentPos, ptrType != NULL);
+        AssertPos(currentPos, ptrType != nullptr);
     }
 
     if (ptrType->IsSlice()) {
@@ -2570,7 +2570,7 @@
         // out the type of ptr0.
         const Type *baseType = ptrType->GetBaseType();
         const SequentialType *st = CastType<SequentialType>(baseType);
-        AssertPos(currentPos, st != NULL);
+        AssertPos(currentPos, st != nullptr);
 
         bool ptr0IsUniform =
             llvm::isa<llvm::PointerType>(ptr0->getType());
@@ -2588,30 +2588,30 @@
 FunctionEmitContext::AddElementOffset(llvm::Value *fullBasePtr, int elementNum,
                                       const Type *ptrRefType, const char *name,
                                       const PointerType **resultPtrType) {
-    if (resultPtrType != NULL)
-        AssertPos(currentPos, ptrRefType != NULL);
+    if (resultPtrType != nullptr)
+        AssertPos(currentPos, ptrRefType != nullptr);
 
     llvm::PointerType *llvmPtrType =
         llvm::dyn_cast<llvm::PointerType>(fullBasePtr->getType());
-    if (llvmPtrType != NULL) {
+    if (llvmPtrType != nullptr) {
         llvm::StructType *llvmStructType =
             llvm::dyn_cast<llvm::StructType>(llvmPtrType->getElementType());
-        if (llvmStructType != NULL && llvmStructType->isSized() == false) {
+        if (llvmStructType != nullptr && llvmStructType->isSized() == false) {
             AssertPos(currentPos, m->errorCount > 0);
-            return NULL;
+            return nullptr;
         }
     }
 
-    // (Unfortunately) it's not required to pass a non-NULL ptrRefType, but
+    // (Unfortunately) it's not required to pass a non-nullptr ptrRefType, but
     // if we have one, regularize into a pointer type.
-    const PointerType *ptrType = NULL;
-    if (ptrRefType != NULL) {
+    const PointerType *ptrType = nullptr;
+    if (ptrRefType != nullptr) {
         // Normalize references to uniform pointers
-        if (CastType<ReferenceType>(ptrRefType) != NULL)
+        if (CastType<ReferenceType>(ptrRefType) != nullptr)
             ptrType = PointerType::GetUniform(ptrRefType->GetReferenceTarget());
         else
             ptrType = CastType<PointerType>(ptrRefType);
-        AssertPos(currentPos, ptrType != NULL);
+        AssertPos(currentPos, ptrType != nullptr);
     }
 
     // Similarly, we have to see if the pointer type is a struct to see if
@@ -2622,31 +2622,31 @@
         llvm::isa<llvm::StructType>(fullBasePtr->getType());
     const PointerType *rpt;
     if (baseIsSlicePtr) {
-        AssertPos(currentPos, ptrType != NULL);
+        AssertPos(currentPos, ptrType != nullptr);
         // Update basePtr to just be the part that actually points to the
         // start of an soa<> struct for now; the element offset computation
         // doesn't change the slice offset, so we'll incorporate that into
         // the final value right before this method returns.
         basePtr = ExtractInst(fullBasePtr, 0);
-        if (resultPtrType == NULL)
+        if (resultPtrType == nullptr)
             resultPtrType = &rpt;
     }
 
     // Return the pointer type of the result of this call, for callers that
     // want it.
-    if (resultPtrType != NULL) {
-        AssertPos(currentPos, ptrType != NULL);
+    if (resultPtrType != nullptr) {
+        AssertPos(currentPos, ptrType != nullptr);
         const CollectionType *ct =
             CastType<CollectionType>(ptrType->GetBaseType());
-        AssertPos(currentPos, ct != NULL);
+        AssertPos(currentPos, ct != nullptr);
         *resultPtrType = new PointerType(ct->GetElementType(elementNum),
                                          ptrType->GetVariability(),
                                          ptrType->IsConstType(),
                                          ptrType->IsSlice());
     }
 
-    llvm::Value *resultPtr = NULL;
-    if (ptrType == NULL || ptrType->IsUniformType()) {
+    llvm::Value *resultPtr = nullptr;
+    if (ptrType == nullptr || ptrType->IsUniformType()) {
         // If the pointer is uniform, we can use the regular LLVM GEP.
         llvm::Value *offsets[2] = { LLVMInt32(0), LLVMInt32(elementNum) };
         llvm::ArrayRef<llvm::Value *> arrayRef(&offsets[0], &offsets[2]);
@@ -2664,8 +2664,8 @@
         // Otherwise do the math to find the offset and add it to the given
         // varying pointers
         const StructType *st = CastType<StructType>(ptrType->GetBaseType());
-        llvm::Value *offset = NULL;
-        if (st != NULL)
+        llvm::Value *offset = nullptr;
+        if (st != nullptr)
             // If the pointer is to a structure, Target::StructOffset() gives
             // us the offset in bytes to the given element of the structure
             offset = g->target->StructOffset(st->LLVMType(g->ctx), elementNum,
@@ -2676,7 +2676,7 @@
             // type of the vector.
             const SequentialType *st =
                 CastType<SequentialType>(ptrType->GetBaseType());
-            AssertPos(currentPos, st != NULL);
+            AssertPos(currentPos, st != nullptr);
             llvm::Value *size =
                 g->target->SizeOf(st->GetElementType()->LLVMType(g->ctx), bblock);
             llvm::Value *scale = (g->target->is32Bit() || g->opt.force32BitAddressing) ?
@@ -2707,16 +2707,16 @@
 
 llvm::Value *
 FunctionEmitContext::LoadInst(llvm::Value *ptr, const char *name) {
-    if (ptr == NULL) {
+    if (ptr == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     llvm::PointerType *pt =
         llvm::dyn_cast<llvm::PointerType>(ptr->getType());
-    AssertPos(currentPos, pt != NULL);
+    AssertPos(currentPos, pt != nullptr);
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(ptr, "_load");
 
     llvm::LoadInst *inst = new llvm::LoadInst(ptr, name, bblock);
@@ -2738,7 +2738,7 @@
 static llvm::Value *
 lFinalSliceOffset(FunctionEmitContext *ctx, llvm::Value *ptr,
                   const PointerType **ptrType) {
-    Assert(CastType<PointerType>(*ptrType) != NULL);
+    Assert(CastType<PointerType>(*ptrType) != nullptr);
 
     llvm::Value *slicePtr = ctx->ExtractInst(ptr, 0, LLVMGetName(ptr, "_ptr"));
     llvm::Value *sliceOffset = ctx->ExtractInst(ptr, 1, LLVMGetName(ptr, "_offset"));
@@ -2776,7 +2776,7 @@
     const Type *unifType = ptrType->GetBaseType()->GetAsUniformType();
 
     const CollectionType *ct = CastType<CollectionType>(ptrType->GetBaseType());
-    if (ct != NULL) {
+    if (ct != nullptr) {
         // If we have a struct/array, we need to decompose it into
         // individual element loads to fill in the result structure since
         // the SOA slice of values we need isn't contiguous in memory...
@@ -2806,28 +2806,28 @@
 llvm::Value *
 FunctionEmitContext::LoadInst(llvm::Value *ptr, llvm::Value *mask,
                               const Type *ptrRefType, const char *name) {
-    if (ptr == NULL) {
+    if (ptr == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    AssertPos(currentPos, ptrRefType != NULL && mask != NULL);
+    AssertPos(currentPos, ptrRefType != nullptr && mask != nullptr);
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(ptr, "_load");
 
     const PointerType *ptrType;
-    if (CastType<ReferenceType>(ptrRefType) != NULL)
+    if (CastType<ReferenceType>(ptrRefType) != nullptr)
         ptrType = PointerType::GetUniform(ptrRefType->GetReferenceTarget());
     else {
         ptrType = CastType<PointerType>(ptrRefType);
-        AssertPos(currentPos, ptrType != NULL);
+        AssertPos(currentPos, ptrType != nullptr);
     }
 
     if (CastType<UndefinedStructType>(ptrType->GetBaseType())) {
         Error(currentPos, "Unable to load to undefined struct type \"%s\".",
               ptrType->GetBaseType()->GetString().c_str());
-        return NULL;
+        return nullptr;
     }
 
     if (ptrType->IsUniformType()) {
@@ -2845,7 +2845,7 @@
             int align = 0;
             const AtomicType *atomicType =
                 CastType<AtomicType>(ptrType->GetBaseType());
-            if (atomicType != NULL && atomicType->IsVaryingType())
+            if (atomicType != nullptr && atomicType->IsVaryingType())
                 // We actually just want to align to the vector element
                 // alignment, but can't easily get that here, so just tell LLVM
                 // it's totally unaligned.  (This shouldn't make any difference
@@ -2877,7 +2877,7 @@
 
     const CollectionType *collectionType =
         CastType<CollectionType>(ptrType->GetBaseType());
-    if (collectionType != NULL) {
+    if (collectionType != nullptr) {
         // For collections, recursively gather element wise to find the
         // result.
         llvm::Value *retValue = llvm::UndefValue::get(llvmReturnType);
@@ -2912,8 +2912,8 @@
     // Figure out which gather function to call based on the size of
     // the elements.
     const PointerType *pt = CastType<PointerType>(returnType);
-    const char *funcName = NULL;
-    if (pt != NULL)
+    const char *funcName = nullptr;
+    if (pt != nullptr)
         funcName = g->target->is32Bit() ? "__pseudo_gather32_i32" :
             "__pseudo_gather64_i64";
     else if (llvmReturnType == LLVMTypes::DoubleVectorType)
@@ -2938,9 +2938,9 @@
     }
 
     llvm::Function *gatherFunc = m->module->getFunction(funcName);
-    AssertPos(currentPos, gatherFunc != NULL);
+    AssertPos(currentPos, gatherFunc != nullptr);
 
-    llvm::Value *gatherCall = CallInst(gatherFunc, NULL, ptr, mask, name);
+    llvm::Value *gatherCall = CallInst(gatherFunc, nullptr, ptr, mask, name);
 
     // Add metadata about the source file location so that the
     // optimization passes can print useful performance warnings if we
@@ -2959,7 +2959,7 @@
 void
 FunctionEmitContext::addGSMetadata(llvm::Value *v, SourcePos pos) {
     llvm::Instruction *inst = llvm::dyn_cast<llvm::Instruction>(v);
-    if (inst == NULL)
+    if (inst == nullptr)
         return;
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 /* 3.2, 3.3, 3.4, 3.5 */
     llvm::Value *str = llvm::MDString::get(*g->ctx, pos.name);
@@ -3007,12 +3007,12 @@
 FunctionEmitContext::AllocaInst(llvm::Type *llvmType,
                                 const char *name, int align,
                                 bool atEntryBlock) {
-    if (llvmType == NULL) {
+    if (llvmType == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    llvm::AllocaInst *inst = NULL;
+    llvm::AllocaInst *inst = nullptr;
     if (atEntryBlock) {
         // We usually insert it right before the jump instruction at the
         // end of allocaBlock
@@ -3032,7 +3032,7 @@
     // in regular chunks.
     llvm::ArrayType *arrayType =
         llvm::dyn_cast<llvm::ArrayType>(llvmType);
-    if (align == 0 && arrayType != NULL &&
+    if (align == 0 && arrayType != nullptr &&
         !llvm::isa<llvm::VectorType>(arrayType->getElementType()))
         align = g->target->getNativeVectorAlignment();
 
@@ -3052,23 +3052,23 @@
 void
 FunctionEmitContext::maskedStore(llvm::Value *value, llvm::Value *ptr,
                                  const Type *ptrType, llvm::Value *mask) {
-    if (value == NULL || ptr == NULL) {
+    if (value == nullptr || ptr == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
         return;
     }
 
-    AssertPos(currentPos, CastType<PointerType>(ptrType) != NULL);
+    AssertPos(currentPos, CastType<PointerType>(ptrType) != nullptr);
     AssertPos(currentPos, ptrType->IsUniformType());
 
     const Type *valueType = ptrType->GetBaseType();
     const CollectionType *collectionType = CastType<CollectionType>(valueType);
-    if (collectionType != NULL) {
+    if (collectionType != nullptr) {
         // Assigning a structure / array / vector. Handle each element
         // individually with what turns into a recursive call to
         // makedStore()
         for (int i = 0; i < collectionType->GetElementCount(); ++i) {
             const Type *eltType = collectionType->GetElementType(i);
-            if (eltType == NULL) {
+            if (eltType == nullptr) {
                 Assert(m->errorCount > 0);
                 continue;
             }
@@ -3087,11 +3087,11 @@
     valueType = valueType->GetAsNonConstType();
 
     // Figure out if we need a 8, 16, 32 or 64-bit masked store.
-    llvm::Function *maskedStoreFunc = NULL;
+    llvm::Function *maskedStoreFunc = nullptr;
     llvm::Type *llvmValueType = value->getType();
 
     const PointerType *pt = CastType<PointerType>(valueType);
-    if (pt != NULL) {
+    if (pt != nullptr) {
         if (pt->IsSlice()) {
             // Masked store of (varying) slice pointer.
             AssertPos(currentPos, pt->IsVaryingType());
@@ -3148,13 +3148,13 @@
     else if (llvmValueType == LLVMTypes::Int8VectorType) {
         maskedStoreFunc = m->module->getFunction("__pseudo_masked_store_i8");
     }
-    AssertPos(currentPos, maskedStoreFunc != NULL);
+    AssertPos(currentPos, maskedStoreFunc != nullptr);
 
     std::vector<llvm::Value *> args;
     args.push_back(ptr);
     args.push_back(value);
     args.push_back(mask);
-    CallInst(maskedStoreFunc, NULL, args);
+    CallInst(maskedStoreFunc, nullptr, args);
 }
 
 
@@ -3170,12 +3170,12 @@
                              const Type *valueType, const Type *origPt,
                              llvm::Value *mask) {
     const PointerType *ptrType = CastType<PointerType>(origPt);
-    AssertPos(currentPos, ptrType != NULL);
+    AssertPos(currentPos, ptrType != nullptr);
     AssertPos(currentPos, ptrType->IsVaryingType());
 
     const CollectionType *srcCollectionType =
         CastType<CollectionType>(valueType);
-    if (srcCollectionType != NULL) {
+    if (srcCollectionType != nullptr) {
         // We're scattering a collection type--we need to keep track of the
         // source type (the type of the data values to be stored) and the
         // destination type (the type of objects in memory that will be
@@ -3186,7 +3186,7 @@
         // instances of the struct type, etc.
         const CollectionType *dstCollectionType =
             CastType<CollectionType>(ptrType->GetBaseType());
-        AssertPos(currentPos, dstCollectionType != NULL);
+        AssertPos(currentPos, dstCollectionType != nullptr);
 
         // Scatter the collection elements individually
         for (int i = 0; i < srcCollectionType->GetElementCount(); ++i) {
@@ -3234,13 +3234,13 @@
 
     // And everything should be a pointer or atomic (or enum) from here on out...
     AssertPos(currentPos, 
-              pt != NULL 
-              || CastType<AtomicType>(valueType) != NULL
-              || CastType<EnumType>(valueType) != NULL);
+              pt != nullptr 
+              || CastType<AtomicType>(valueType) != nullptr
+              || CastType<EnumType>(valueType) != nullptr);
 
     llvm::Type *type = value->getType();
-    const char *funcName = NULL;
-    if (pt != NULL) {
+    const char *funcName = nullptr;
+    if (pt != nullptr) {
         funcName = g->target->is32Bit() ? "__pseudo_scatter32_i32" :
             "__pseudo_scatter64_i64";
     }
@@ -3270,7 +3270,7 @@
     }
 
     llvm::Function *scatterFunc = m->module->getFunction(funcName);
-    AssertPos(currentPos, scatterFunc != NULL);
+    AssertPos(currentPos, scatterFunc != nullptr);
 
     AddInstrumentationPoint("scatter");
 
@@ -3278,7 +3278,7 @@
     args.push_back(ptr);
     args.push_back(value);
     args.push_back(mask);
-    llvm::Value *inst = CallInst(scatterFunc, NULL, args);
+    llvm::Value *inst = CallInst(scatterFunc, nullptr, args);
 
     if (disableGSWarningCount == 0)
         addGSMetadata(inst, currentPos);
@@ -3287,7 +3287,7 @@
 
 void
 FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr) {
-    if (value == NULL || ptr == NULL) {
+    if (value == nullptr || ptr == nullptr) {
         // may happen due to error elsewhere
         AssertPos(currentPos, m->errorCount > 0);
         return;
@@ -3295,7 +3295,7 @@
 
     llvm::PointerType *pt =
         llvm::dyn_cast<llvm::PointerType>(ptr->getType());
-    AssertPos(currentPos, pt != NULL);
+    AssertPos(currentPos, pt != nullptr);
 
     llvm::StoreInst *inst = new llvm::StoreInst(value, ptr, bblock);
 
@@ -3312,18 +3312,18 @@
 FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr,
                                llvm::Value *mask, const Type *valueType,
                                const Type *ptrRefType) {
-    if (value == NULL || ptr == NULL) {
+    if (value == nullptr || ptr == nullptr) {
         // may happen due to error elsewhere
         AssertPos(currentPos, m->errorCount > 0);
         return;
     }
 
     const PointerType *ptrType;
-    if (CastType<ReferenceType>(ptrRefType) != NULL)
+    if (CastType<ReferenceType>(ptrRefType) != nullptr)
         ptrType = PointerType::GetUniform(ptrRefType->GetReferenceTarget());
     else {
         ptrType = CastType<PointerType>(ptrRefType);
-        AssertPos(currentPos, ptrType != NULL);
+        AssertPos(currentPos, ptrType != nullptr);
     }
 
     if (CastType<UndefinedStructType>(ptrType->GetBaseType())) {
@@ -3366,7 +3366,7 @@
                                     valueType));
 
     const CollectionType *ct = CastType<CollectionType>(valueType);
-    if (ct != NULL) {
+    if (ct != nullptr) {
         // Handle collections element wise...
         for (int i = 0; i < ct->GetElementCount(); ++i) {
             llvm::Value *eltValue = ExtractInst(value, i);
@@ -3397,15 +3397,15 @@
         AssertPos(currentPos, count->getType() == LLVMTypes::Int32Type);
         count = ZExtInst(count, LLVMTypes::Int64Type, "count_to_64");
     }
-    if (align == NULL)
+    if (align == nullptr)
         align = LLVMInt32(1);
 
     llvm::Constant *mcFunc =
         m->module->getOrInsertFunction("llvm.memcpy.p0i8.p0i8.i64",
                                        LLVMTypes::VoidType, LLVMTypes::VoidPointerType,
                                        LLVMTypes::VoidPointerType, LLVMTypes::Int64Type,
-                                       LLVMTypes::Int32Type, LLVMTypes::BoolType, NULL);
-    AssertPos(currentPos, mcFunc != NULL);
+                                       LLVMTypes::Int32Type, LLVMTypes::BoolType, nullptr);
+    AssertPos(currentPos, mcFunc != nullptr);
     AssertPos(currentPos, llvm::isa<llvm::Function>(mcFunc));
 
     std::vector<llvm::Value *> args;
@@ -3414,7 +3414,7 @@
     args.push_back(count);
     args.push_back(align);
     args.push_back(LLVMFalse); /* not volatile */
-    CallInst(mcFunc, NULL, args, "");
+    CallInst(mcFunc, nullptr, args, "");
 }
 
 
@@ -3429,7 +3429,7 @@
 FunctionEmitContext::BranchInst(llvm::BasicBlock *trueBlock,
                                 llvm::BasicBlock *falseBlock,
                                 llvm::Value *test) {
-    if (test == NULL) {
+    if (test == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
         return;
     }
@@ -3442,18 +3442,18 @@
 
 llvm::Value *
 FunctionEmitContext::ExtractInst(llvm::Value *v, int elt, const char *name) {
-    if (v == NULL) {
+    if (v == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL) {
+    if (name == nullptr) {
         char buf[32];
         sprintf(buf, "_extract_%d", elt);
         name = LLVMGetName(v, buf);
     }
 
-    llvm::Instruction *ei = NULL;
+    llvm::Instruction *ei = nullptr;
     if (llvm::isa<llvm::VectorType>(v->getType()))
         ei = llvm::ExtractElementInst::Create(v, LLVMInt32(elt), name, bblock);
     else
@@ -3466,18 +3466,18 @@
 llvm::Value *
 FunctionEmitContext::InsertInst(llvm::Value *v, llvm::Value *eltVal, int elt,
                                 const char *name) {
-    if (v == NULL || eltVal == NULL) {
+    if (v == nullptr || eltVal == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL) {
+    if (name == nullptr) {
         char buf[32];
         sprintf(buf, "_insert_%d", elt);
         name = LLVMGetName(v, buf);
     }
 
-    llvm::Instruction *ii = NULL;
+    llvm::Instruction *ii = nullptr;
     if (llvm::isa<llvm::VectorType>(v->getType()))
         ii = llvm::InsertElementInst::Create(v, eltVal, LLVMInt32(elt),
                                              name, bblock);
@@ -3491,12 +3491,12 @@
 llvm::Value *
 FunctionEmitContext::ShuffleInst(llvm::Value *v1, llvm::Value *v2, llvm::Value *mask,
                                 const char *name) {
-    if (v1 == NULL || v2 == NULL || mask == NULL) {
+    if (v1 == nullptr || v2 == nullptr || mask == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL) {
+    if (name == nullptr) {
         char buf[32];
         sprintf(buf, "_shuffle");
         name = LLVMGetName(v1, buf);
@@ -3512,15 +3512,15 @@
 llvm::Value *
 FunctionEmitContext::BroadcastValue(llvm::Value *v, llvm::Type* vecType,
                                     const char *name) {
-    if (v == NULL || vecType == NULL) {
+    if (v == nullptr || vecType == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     llvm::VectorType *ty = llvm::dyn_cast<llvm::VectorType>(vecType);
     Assert(ty && ty->getVectorElementType() == v->getType());
 
-    if (name == NULL) {
+    if (name == nullptr) {
         char buf[32];
         sprintf(buf, "_broadcast");
         name = LLVMGetName(v, buf);
@@ -3561,12 +3561,12 @@
 llvm::Instruction *
 FunctionEmitContext::SelectInst(llvm::Value *test, llvm::Value *val0,
                                 llvm::Value *val1, const char *name) {
-    if (test == NULL || val0 == NULL || val1 == NULL) {
+    if (test == nullptr || val0 == nullptr || val1 == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
-    if (name == NULL)
+    if (name == nullptr)
         name = LLVMGetName(test, "_select");
 
     llvm::Instruction *inst = llvm::SelectInst::Create(test, val0, val1, name,
@@ -3584,10 +3584,10 @@
     llvm::FunctionType *ft =
         llvm::dyn_cast<llvm::FunctionType>(callee->getType());
 
-    if (ft == NULL) {
+    if (ft == nullptr) {
         llvm::PointerType *pt =
             llvm::dyn_cast<llvm::PointerType>(callee->getType());
-        if (pt == NULL) {
+        if (pt == nullptr) {
             // varying--in this case, it must be the version of the
             // function that takes a mask
             return funcType->GetNumParameters() + 1;
@@ -3595,7 +3595,7 @@
         ft = llvm::dyn_cast<llvm::FunctionType>(pt->getElementType());
     }
 
-    Assert(ft != NULL);
+    Assert(ft != nullptr);
     return ft->getNumParams();
 }
 
@@ -3604,9 +3604,9 @@
 FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType *funcType,
                               const std::vector<llvm::Value *> &args,
                               const char *name) {
-    if (func == NULL) {
+    if (func == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
     }
 
     std::vector<llvm::Value *> argVals = args;
@@ -3662,7 +3662,7 @@
         // instances' return values...
         const Type *returnType = funcType->GetReturnType();
         llvm::Type *llvmReturnType = returnType->LLVMType(g->ctx);
-        llvm::Value *resultPtr = NULL;
+        llvm::Value *resultPtr = nullptr;
         if (llvmReturnType->isVoidTy() == false)
             resultPtr = AllocaInst(llvmReturnType);
 
@@ -3693,8 +3693,8 @@
             llvm::Value *currentMask = LoadInst(maskPtr);
             llvm::Function *cttz =
                 m->module->getFunction("__count_trailing_zeros_i64");
-            AssertPos(currentPos, cttz != NULL);
-            llvm::Value *firstLane64 = CallInst(cttz, NULL, LaneMask(currentMask),
+            AssertPos(currentPos, cttz != nullptr);
+            llvm::Value *firstLane64 = CallInst(cttz, nullptr, LaneMask(currentMask),
                                                 "first_lane64");
             llvm::Value *firstLane =
                 TruncInst(firstLane64, LLVMTypes::Int32Type, "first_lane32");
@@ -3739,14 +3739,14 @@
 
             // Now, do a masked store into the memory allocated to
             // accumulate the result using the call mask.
-            if (callResult != NULL &&
+            if (callResult != nullptr &&
                 callResult->getType() != LLVMTypes::VoidType) {
-                AssertPos(currentPos, resultPtr != NULL);
+                AssertPos(currentPos, resultPtr != nullptr);
                 StoreInst(callResult, resultPtr, callMask, returnType,
                           PointerType::GetUniform(returnType));
             }
             else
-                AssertPos(currentPos, resultPtr == NULL);
+                AssertPos(currentPos, resultPtr == nullptr);
 
             // Update the mask to turn off the program instances for which
             // we just called the function.
@@ -3767,7 +3767,7 @@
         // accumulated in the result memory.
         SetCurrentBasicBlock(bbDone);
         SetInternalMask(origMask);
-        return resultPtr ? LoadInst(resultPtr) : NULL;
+        return resultPtr ? LoadInst(resultPtr) : nullptr;
     }
 }
 
@@ -3798,8 +3798,8 @@
         // Add a sync call at the end of any function that launched tasks
         SyncInst();
 
-    llvm::Instruction *rinst = NULL;
-    if (returnValuePtr != NULL) {
+    llvm::Instruction *rinst = nullptr;
+    if (returnValuePtr != nullptr) {
         // We have value(s) to return; load them from their storage
         // location
         llvm::Value *retVal = LoadInst(returnValuePtr, "return_value");
@@ -3811,7 +3811,7 @@
     }
 
     AddDebugPos(rinst);
-    bblock = NULL;
+    bblock = nullptr;
     return rinst;
 }
 
@@ -3823,9 +3823,9 @@
 #ifdef ISPC_NVPTX_ENABLED
     if (g->target->getISA() == Target::NVPTX)
     {
-      if (callee == NULL) {
+      if (callee == nullptr) {
         AssertPos(currentPos, m->errorCount > 0);
-        return NULL;
+        return nullptr;
       }
       launchedTasks = true;
 
@@ -3846,22 +3846,22 @@
 
       const int align = 8;
       llvm::Function *falloc = m->module->getFunction("ISPCAlloc");
-      AssertPos(currentPos, falloc != NULL);
+      AssertPos(currentPos, falloc != nullptr);
       std::vector<llvm::Value *> allocArgs;
       allocArgs.push_back(launchGroupHandlePtr);
       allocArgs.push_back(structSize);
       allocArgs.push_back(LLVMInt32(align));
-      llvm::Value *voidmem = CallInst(falloc, NULL, allocArgs, "args_ptr");
+      llvm::Value *voidmem = CallInst(falloc, nullptr, allocArgs, "args_ptr");
       llvm::Value *voidi64 = PtrToIntInst(voidmem, "args_i64");
       llvm::BasicBlock* if_true  = CreateBasicBlock("if_true");
       llvm::BasicBlock* if_false = CreateBasicBlock("if_false");
 
-      /* check if the pointer returned by ISPCAlloc is not NULL 
+      /* check if the pointer returned by ISPCAlloc is not nullptr 
        * --------------
        * this is a workaround for not checking the value of programIndex 
-       * because ISPCAlloc will return NULL pointer for all programIndex > 0
+       * because ISPCAlloc will return nullptr pointer for all programIndex > 0
        * of course, if ISPAlloc fails to get parameter buffer, the pointer for programIndex = 0
-       * will also be NULL
+       * will also be nullptr
        * This check must be added, and also rewrite the code to make it less opaque 
        */
       llvm::Value* cmp1 = CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_NE, voidi64, LLVMInt64(0), "cmp1");
@@ -3875,14 +3875,14 @@
       llvm::Value *argmem = BitCastInst(voidmem, pt);
       for (unsigned int i = 0; i < argVals.size(); ++i) 
       {
-        llvm::Value *ptr = AddElementOffset(argmem, i, NULL, "funarg");
+        llvm::Value *ptr = AddElementOffset(argmem, i, nullptr, "funarg");
         // don't need to do masked store here, I think
         StoreInst(argVals[i], ptr);
       }
       if (nArgs == argVals.size() + 1) {
         // copy in the mask
         llvm::Value *mask = GetFullMask();
-        llvm::Value *ptr = AddElementOffset(argmem, argVals.size(), NULL,
+        llvm::Value *ptr = AddElementOffset(argmem, argVals.size(), nullptr,
             "funarg_mask");
         StoreInst(mask, ptr);
       }
@@ -3893,7 +3893,7 @@
 
       llvm::Value *fptr = BitCastInst(callee, LLVMTypes::VoidPointerType);
       llvm::Function *flaunch = m->module->getFunction("ISPCLaunch");
-      AssertPos(currentPos, flaunch != NULL);
+      AssertPos(currentPos, flaunch != nullptr);
       std::vector<llvm::Value *> args;
       args.push_back(launchGroupHandlePtr);
       args.push_back(fptr);
@@ -3901,14 +3901,14 @@
       args.push_back(launchCount[0]);
       args.push_back(launchCount[1]);
       args.push_back(launchCount[2]);
-      llvm::Value *ret =  CallInst(flaunch, NULL, args, "");
+      llvm::Value *ret =  CallInst(flaunch, nullptr, args, "");
       return ret;
     }
 #endif /* ISPC_NVPTX_ENABLED */
 
-    if (callee == NULL) {
+    if (callee == nullptr) {
       AssertPos(currentPos, m->errorCount > 0);
-      return NULL;
+      return nullptr;
     }
 
     launchedTasks = true;
@@ -3924,7 +3924,7 @@
       static_cast<llvm::StructType *>(pt->getElementType());
 
     llvm::Function *falloc = m->module->getFunction("ISPCAlloc");
-    AssertPos(currentPos, falloc != NULL);
+    AssertPos(currentPos, falloc != nullptr);
     llvm::Value *structSize = g->target->SizeOf(argStructType, bblock);
     if (structSize->getType() != LLVMTypes::Int64Type)
       // ISPCAlloc expects the size as an uint64_t, but on 32-bit
@@ -3937,13 +3937,13 @@
     allocArgs.push_back(launchGroupHandlePtr);
     allocArgs.push_back(structSize);
     allocArgs.push_back(LLVMInt32(align));
-    llvm::Value *voidmem = CallInst(falloc, NULL, allocArgs, "args_ptr");
+    llvm::Value *voidmem = CallInst(falloc, nullptr, allocArgs, "args_ptr");
     llvm::Value *argmem = BitCastInst(voidmem, pt);
 
     // Copy the values of the parameters into the appropriate place in
     // the argument block
     for (unsigned int i = 0; i < argVals.size(); ++i) {
-      llvm::Value *ptr = AddElementOffset(argmem, i, NULL, "funarg");
+      llvm::Value *ptr = AddElementOffset(argmem, i, nullptr, "funarg");
       // don't need to do masked store here, I think
       StoreInst(argVals[i], ptr);
     }
@@ -3951,7 +3951,7 @@
     if (argStructType->getNumElements() == argVals.size() + 1) {
       // copy in the mask
       llvm::Value *mask = GetFullMask();
-      llvm::Value *ptr = AddElementOffset(argmem, argVals.size(), NULL,
+      llvm::Value *ptr = AddElementOffset(argmem, argVals.size(), nullptr,
           "funarg_mask");
       StoreInst(mask, ptr);
     }
@@ -3961,7 +3961,7 @@
     // argument block we just filled in
     llvm::Value *fptr = BitCastInst(callee, LLVMTypes::VoidPointerType);
     llvm::Function *flaunch = m->module->getFunction("ISPCLaunch");
-    AssertPos(currentPos, flaunch != NULL);
+    AssertPos(currentPos, flaunch != nullptr);
     std::vector<llvm::Value *> args;
     args.push_back(launchGroupHandlePtr);
     args.push_back(fptr);
@@ -3969,7 +3969,7 @@
     args.push_back(launchCount[0]);
     args.push_back(launchCount[1]);
     args.push_back(launchCount[2]);
-    return CallInst(flaunch, NULL, args, "");
+    return CallInst(flaunch, nullptr, args, "");
 }
 
 
@@ -3979,36 +3979,36 @@
     if (g->target->getISA() == Target::NVPTX)
     {
       llvm::Value *launchGroupHandle = LoadInst(launchGroupHandlePtr);
-      llvm::Value *nullPtrValue =
+      llvm::Value *nullptrPtrValue =
         llvm::Constant::getNullValue(LLVMTypes::VoidPointerType);
       llvm::Function *fsync = m->module->getFunction("ISPCSync");
-      if (fsync == NULL)
+      if (fsync == nullptr)
         FATAL("Couldn't find ISPCSync declaration?!");
-      CallInst(fsync, NULL, launchGroupHandle, "");
-      StoreInst(nullPtrValue, launchGroupHandlePtr);
+      CallInst(fsync, nullptr, launchGroupHandle, "");
+      StoreInst(nullptrPtrValue, launchGroupHandlePtr);
       return;
     }
 #endif /* ISPC_NVPTX_ENABLED */
 
     llvm::Value *launchGroupHandle = LoadInst(launchGroupHandlePtr);
-    llvm::Value *nullPtrValue =
+    llvm::Value *nullptrPtrValue =
         llvm::Constant::getNullValue(LLVMTypes::VoidPointerType);
-    llvm::Value *nonNull = CmpInst(llvm::Instruction::ICmp,
+    llvm::Value *nonnullptr = CmpInst(llvm::Instruction::ICmp,
                                    llvm::CmpInst::ICMP_NE,
-                                   launchGroupHandle, nullPtrValue);
+                                   launchGroupHandle, nullptrPtrValue);
     llvm::BasicBlock *bSync = CreateBasicBlock("call_sync");
     llvm::BasicBlock *bPostSync = CreateBasicBlock("post_sync");
-    BranchInst(bSync, bPostSync, nonNull);
+    BranchInst(bSync, bPostSync, nonnullptr);
 
     SetCurrentBasicBlock(bSync);
     llvm::Function *fsync = m->module->getFunction("ISPCSync");
-    if (fsync == NULL)
+    if (fsync == nullptr)
         FATAL("Couldn't find ISPCSync declaration?!");
-    CallInst(fsync, NULL, launchGroupHandle, "");
+    CallInst(fsync, nullptr, launchGroupHandle, "");
 
     // zero out the handle so that if ISPCLaunch is called again in this
     // function, it knows it's starting out from scratch
-    StoreInst(nullPtrValue, launchGroupHandlePtr);
+    StoreInst(nullptrPtrValue, launchGroupHandlePtr);
 
     BranchInst(bPostSync);
 
--- cbackend.cpp.bak	2016-01-29 22:27:12.477771262 +0100
+++ cbackend.cpp	2016-01-29 22:31:25.402975195 +0100
@@ -390,7 +390,7 @@
 
 static bool is_vec16_i64_ty(llvm::Type *Ty) {
   llvm::VectorType *VTy = llvm::dyn_cast<llvm::VectorType>(Ty);
-  if ((VTy != NULL) && (VTy->getElementType()->isIntegerTy()) && 
+  if ((VTy != nullptr) && (VTy->getElementType()->isIntegerTy()) && 
     VTy->getElementType()->getPrimitiveSizeInBits() == 64)
     return true;
   return false;
@@ -870,7 +870,7 @@
   case llvm::Type::VectorTyID: {
     llvm::VectorType *VTy = llvm::cast<llvm::VectorType>(Ty);
 #if 1
-    const char *suffix = NULL;
+    const char *suffix = nullptr;
     const llvm::Type *eltTy = VTy->getElementType();
     if (eltTy->isFloatTy())
         suffix = "f";
@@ -1133,7 +1133,7 @@
 
     llvm::StringRef Bytes = CDS->getAsCString();
 
-    // Do not include the last character, which we know is null
+    // Do not include the last character, which we know is nullptr
     for (unsigned i = 0, e = Bytes.size(); i != e; ++i) {
       unsigned char C = Bytes[i];
 
@@ -1363,11 +1363,11 @@
         case 16: desc = DESC_I16; break;
         case 32: desc = DESC_I32; break;
         case 64: desc = DESC_I64; break;
-        default: return NULL;
+        default: return nullptr;
         }
         break;
     }
-    default: return NULL;
+    default: return nullptr;
     }
 
     char buf[64];
@@ -1726,14 +1726,14 @@
     if (llvm::isa<llvm::ConstantAggregateZero>(CPV)) {
         // All zeros; call the __setzero_* function.
         const char *setZeroFunc = lGetTypedFunc("setzero", VT->getElementType(), vectorWidth);
-        assert(setZeroFunc != NULL);
+        assert(setZeroFunc != nullptr);
         Out << setZeroFunc << "()";
     }
     else if (llvm::isa<llvm::UndefValue>(CPV)) {
         // Undefined value; call __undef_* so that we can potentially pass
         // this information along..
         const char *undefFunc = lGetTypedFunc("undef", VT->getElementType(), vectorWidth);
-        assert(undefFunc != NULL);
+        assert(undefFunc != nullptr);
         Out << undefFunc << "()";
     }
     else {
@@ -1741,7 +1741,7 @@
 
         if (llvm::ConstantVector *CV = llvm::dyn_cast<llvm::ConstantVector>(CPV)) {
             llvm::Constant *splatValue = CV->getSplatValue();
-            if (splatValue != NULL && smearFunc != NULL) {
+            if (splatValue != nullptr && smearFunc != nullptr) {
                 // If it's a basic type and has a __smear_* function, then
                 // call that.
                 Out << smearFunc << "(";
@@ -1759,7 +1759,7 @@
         else if (llvm::ConstantDataVector *CDV =
                  llvm::dyn_cast<llvm::ConstantDataVector>(CPV)) {
             llvm::Constant *splatValue = CDV->getSplatValue();
-            if (splatValue != NULL && smearFunc != NULL) {
+            if (splatValue != nullptr && smearFunc != nullptr) {
                 Out << smearFunc << "(";
                 printConstant(splatValue, Static);
                 Out << ")";
@@ -1841,7 +1841,7 @@
     if (llvm::isa<llvm::ConstantPointerNull>(CPV)) {
       Out << "((";
       printType(Out, CPV->getType()); // sign doesn't matter
-      Out << ")/*NULL*/0)";
+      Out << ")/*nullptr*/0)";
       break;
     } else if (llvm::GlobalValue *GV = llvm::dyn_cast<llvm::GlobalValue>(CPV)) {
       writeOperand(GV, Static);
@@ -2151,7 +2151,7 @@
   // This has to do a cast to ensure the operand has the right signedness.
   // Also, if the operand is a pointer, we make sure to cast to an integer when
   // doing the comparison both for signedness and so that the C compiler doesn't
-  // optimize things like "p < NULL" to false (p may contain an integer value
+  // optimize things like "p < nullptr" to false (p may contain an integer value
   // f.e.).
   bool shouldCast = Cmp.isRelational();
 
@@ -2308,7 +2308,7 @@
       if (CS->getNumOperands() != 2) return;  // Not array of 2-element structs.
 
       if (CS->getOperand(1)->isNullValue())
-        return;  // Found a null terminator, exit printing.
+        return;  // Found a nullptr terminator, exit printing.
       llvm::Constant *FP = CS->getOperand(1);
       if (llvm::ConstantExpr *CE = llvm::dyn_cast<llvm::ConstantExpr>(FP))
         if (CE->isCast())
@@ -2396,9 +2396,9 @@
   TAsm = new CBEMCAsmInfo();
   MRI  = new llvm::MCRegisterInfo();
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 // LLVM 3.4+
-  TCtx = new llvm::MCContext(TAsm, MRI, NULL);
+  TCtx = new llvm::MCContext(TAsm, MRI, nullptr);
 #else
-  TCtx = new llvm::MCContext(*TAsm, *MRI, NULL);
+  TCtx = new llvm::MCContext(*TAsm, *MRI, nullptr);
 #endif
   //Mang = new llvm::Mangler(*TCtx, *TD);
 
@@ -2746,7 +2746,7 @@
         if (I->hasHiddenVisibility())
           Out << " __HIDDEN__";
 
-        // If the initializer is not null, emit the initializer.  If it is null,
+        // If the initializer is not nullptr, emit the initializer.  If it is nullptr,
         // we try to avoid emitting large amounts of zeros.  The problem with
         // this, however, occurs when the variable has weak linkage.  In this
         // case, the assembler will complain about the variable being both weak
@@ -2868,12 +2868,12 @@
     for (constant_scanner::constant_iterator I = constant_scanner::constant_begin(&F), 
          E = constant_scanner::constant_end(&F); I != E; ++I) {
         const llvm::ConstantDataVector *CDV = llvm::dyn_cast<llvm::ConstantDataVector>(*I);
-        if (CDV == NULL)
+        if (CDV == nullptr)
             continue;
 
         // Don't bother if this is a splat of the same value; a (more
         // efficient?) __splat_* call will be generated for these.
-        if (CDV->getSplatValue() != NULL)
+        if (CDV->getSplatValue() != nullptr)
             continue;
 
         // Don't align to anything more than 64 bytes
@@ -2914,7 +2914,7 @@
   Out << "  iN () {}                                                                                 \n";
   Out << "                                                                                           \n";
   Out << "  iN (const char *val) {                                                                   \n";
-  Out << "    if (val == NULL)                                                                       \n";
+  Out << "    if (val == nullptr)                                                                       \n";
   Out << "      return;                                                                              \n";
   Out << "    int length = num_bits / (sizeof (int) * 8);                                            \n";
   Out << "    int val_len = 0;                                                                       \n";
@@ -3105,7 +3105,7 @@
 #endif
 
   llvm::ArrayType *ChildTy = llvm::dyn_cast<llvm::ArrayType>(ATy->getElementType());
-  if (ChildTy != NULL)
+  if (ChildTy != nullptr)
       printContainedArrays(ChildTy, Printed);
 
   printType(Out, ATy, false, getArrayName(ATy), true);
@@ -3574,7 +3574,7 @@
   assert(!I.getType()->isPointerTy());
 
   if (llvm::isa<const llvm::VectorType>(I.getOperand(0)->getType())) {
-      const char *intrinsic = NULL;
+      const char *intrinsic = nullptr;
       switch (I.getOpcode()) {
       case llvm::Instruction::Add:  intrinsic = "__add";  break;
       case llvm::Instruction::FAdd: intrinsic = "__add";  break;
@@ -3607,7 +3607,7 @@
       if ((I.getOpcode() == llvm::Instruction::Shl ||
            I.getOpcode() == llvm::Instruction::LShr ||
            I.getOpcode() == llvm::Instruction::AShr)) {
-          llvm::Value *splat = NULL;
+          llvm::Value *splat = nullptr;
           if (LLVMVectorValuesAllEqual(I.getOperand(1), &splat)) {
               if (splat) {
                   // Avoid __extract_element(splat(value), 0), if possible.
@@ -3737,7 +3737,7 @@
     case llvm::FCmpInst::FCMP_OGT: return "__greater_than";
     case llvm::FCmpInst::FCMP_OGE: return "__greater_equal";
 
-    default: llvm_unreachable(0); return NULL;
+    default: llvm_unreachable(0); return nullptr;
     }
 }
 
@@ -3745,7 +3745,7 @@
 static const char *
 lTypeToSuffix(llvm::Type *t) {
     llvm::VectorType *vt = llvm::dyn_cast<llvm::VectorType>(t);
-    Assert(vt != NULL);
+    Assert(vt != nullptr);
     t = vt->getElementType();
 
     switch (t->getTypeID()) {
@@ -3760,9 +3760,9 @@
         case 64: return "i64";
         }
     }
-    default: llvm_unreachable(0); return NULL;
+    default: llvm_unreachable(0); return nullptr;
     }
-    return NULL;
+    return nullptr;
 }
 
 
@@ -4655,7 +4655,7 @@
 
 void CWriter::visitLoadInst(llvm::LoadInst &I) {
   llvm::VectorType *VT = llvm::dyn_cast<llvm::VectorType>(I.getType());
-  if (VT != NULL) {
+  if (VT != nullptr) {
       Out << "__load<" << I.getAlignment() << ">(";
       writeOperand(I.getOperand(0));
       Out << ")";
@@ -4668,7 +4668,7 @@
 
 void CWriter::visitStoreInst(llvm::StoreInst &I) {
   llvm::VectorType *VT = llvm::dyn_cast<llvm::VectorType>(I.getOperand(0)->getType());
-  if (VT != NULL) {
+  if (VT != nullptr) {
       Out << "__store<" << I.getAlignment() << ">(";
       writeOperand(I.getOperand(1));
       Out << ", ";
@@ -4917,7 +4917,7 @@
 unsigned int
 SmearCleanupPass::ChainLength(llvm::InsertElementInst *inst) const {
     unsigned int length = 0;
-    while (inst != NULL) {
+    while (inst != nullptr) {
         ++length;
         inst = llvm::dyn_cast<llvm::InsertElementInst>(inst->getOperand(0));
     }
@@ -4935,12 +4935,12 @@
     llvm::InsertElementInst *insertInst =
         llvm::dyn_cast<llvm::InsertElementInst>(inst);
     if (!insertInst) {
-        return NULL;
+        return nullptr;
     }
 
     // We consider only chians of vectorWidth length.
     if (ChainLength(insertInst) != vectorWidth) {
-        return NULL;
+        return nullptr;
     }
 
     // FIXME: we only want to do this to vectors with width equal to
@@ -4949,25 +4949,25 @@
     // want to do this.
     llvm::VectorType *vt = llvm::dyn_cast<llvm::VectorType>(insertInst->getType());
     if (vt->getNumElements() == 1) {
-        return NULL;
+        return nullptr;
     }
 
-    llvm::Value *smearValue = NULL;
-    while (insertInst != NULL) {
+    llvm::Value *smearValue = nullptr;
+    while (insertInst != nullptr) {
         // operand 1 is inserted value
         llvm::Value *insertValue = insertInst->getOperand(1);
-        if (smearValue == NULL) {
+        if (smearValue == nullptr) {
             smearValue = insertValue;
         }
         else if (smearValue != insertValue) {
-            return NULL;
+            return nullptr;
         }
 
         // operand 0 is a vector to insert into.
         insertInst =
             llvm::dyn_cast<llvm::InsertElementInst>(insertInst->getOperand(0));
     }
-    assert(smearValue != NULL);
+    assert(smearValue != nullptr);
 
     return smearValue;
 }
@@ -4978,7 +4978,7 @@
     llvm::ShuffleVectorInst *shuffleInst =
         llvm::dyn_cast<llvm::ShuffleVectorInst>(inst);
     if (!shuffleInst) {
-        return NULL;
+        return nullptr;
     }
 
     llvm::Constant* mask =
@@ -4993,7 +4993,7 @@
          (mask->isNullValue() || (shuffleInst->getMask()->getSplatValue() != 0))&&
 #endif
           llvm::dyn_cast<llvm::VectorType>(mask->getType())->getNumElements() == vectorWidth)) {
-        return NULL;
+        return nullptr;
     }
 
 
@@ -5008,28 +5008,28 @@
         // We can't extract element from vec1
         llvm::VectorType *operandVec = llvm::dyn_cast<llvm::VectorType>(shuffleInst->getOperand(0)->getType());
         if (operandVec && operandVec->getNumElements() == 1)
-          return NULL;
+          return nullptr;
 
         // Insert ExtractElementInstr to get value for smear        
 
         llvm::Function *extractFunc = module->getFunction("__extract_element");
        
-         if (extractFunc == NULL) {
+         if (extractFunc == nullptr) {
             // Declare the __extract_element function if needed; it takes a vector and 
             // a scalar parameter and returns a scalar of the vector parameter type.
             llvm::Constant *ef =
                 module->getOrInsertFunction("__extract_element", 
                                             shuffleInst->getOperand(0)->getType()->getVectorElementType(), 
                                             shuffleInst->getOperand(0)->getType(),
-                                            llvm::IntegerType::get(module->getContext(), 32), NULL);
+                                            llvm::IntegerType::get(module->getContext(), 32), nullptr);
             extractFunc = llvm::dyn_cast<llvm::Function>(ef);
-            assert(extractFunc != NULL);
+            assert(extractFunc != nullptr);
             extractFunc->setDoesNotThrow();
             extractFunc->setOnlyReadsMemory();
         } 
 
-        if (extractFunc == NULL) {
-            return NULL;
+        if (extractFunc == nullptr) {
+            return nullptr;
         }
         llvm::Instruction *extractCall = 
               llvm::ExtractElementInst::Create(shuffleInst->getOperand(0), 
@@ -5055,7 +5055,7 @@
 
  restart:
     for (llvm::BasicBlock::iterator iter = bb.begin(), e = bb.end(); iter != e; ++iter) {
-        llvm::Value *smearValue = NULL;
+        llvm::Value *smearValue = nullptr;
 
         if (!(smearValue = getInsertChainSmearValue(&*iter)) &&
             !(smearValue = getShuffleSmearValue(&*iter))) {
@@ -5064,27 +5064,27 @@
 
         llvm::Type *smearType = smearValue->getType();
         const char *smearFuncName = lGetTypedFunc("smear", smearType, vectorWidth);
-        if (smearFuncName != NULL) {
+        if (smearFuncName != nullptr) {
             llvm::Function *smearFunc = module->getFunction(smearFuncName);
-            if (smearFunc == NULL) {
+            if (smearFunc == nullptr) {
                 // Declare the smear function if needed; it takes a single
                 // scalar parameter and returns a vector of the same
                 // parameter type.
                 llvm::Constant *sf =
                     module->getOrInsertFunction(smearFuncName, iter->getType(),
-                                                smearType, NULL);
+                                                smearType, nullptr);
                 smearFunc = llvm::dyn_cast<llvm::Function>(sf);
-                assert(smearFunc != NULL);
+                assert(smearFunc != nullptr);
                 smearFunc->setDoesNotThrow();
                 smearFunc->setDoesNotAccessMemory();
             }
 
-            assert(smearFunc != NULL);
+            assert(smearFunc != nullptr);
             llvm::Value *args[1] = { smearValue };
             llvm::ArrayRef<llvm::Value *> argArray(&args[0], &args[1]);
             llvm::Instruction *smearCall =
                 llvm::CallInst::Create(smearFunc, argArray, LLVMGetName(smearValue, "_smear"),
-                                 (llvm::Instruction *)NULL);
+                                 (llvm::Instruction *)nullptr);
 
             ReplaceInstWithInst(&*iter, smearCall);
 
@@ -5125,7 +5125,7 @@
     for (llvm::BasicBlock::iterator iter = bb.begin(), e = bb.end(); iter != e; ++iter) {
         // See if we have an AND instruction
         llvm::BinaryOperator *bop = llvm::dyn_cast<llvm::BinaryOperator>(&*iter);
-        if (bop == NULL || bop->getOpcode() != llvm::Instruction::And)
+        if (bop == nullptr || bop->getOpcode() != llvm::Instruction::And)
             continue;
 
         // Make sure it's a vector AND
@@ -5141,7 +5141,7 @@
         for (int i = 0; i < 2; ++i) {
             llvm::Value *op = bop->getOperand(i);
             llvm::CmpInst *opCmp = llvm::dyn_cast<llvm::CmpInst>(op);
-            if (opCmp == NULL)
+            if (opCmp == nullptr)
                 continue;
 
             // We have a comparison.  However, we also need to make sure
@@ -5159,7 +5159,7 @@
             funcName += "_and_mask";
 
             llvm::Function *andCmpFunc = m->module->getFunction(funcName);
-            if (andCmpFunc == NULL) {
+            if (andCmpFunc == nullptr) {
                 // Declare the function if needed; the first two arguments
                 // are the same as the two arguments to the compare we're
                 // replacing and the third argument is the mask type.
@@ -5167,9 +5167,9 @@
                 llvm::Constant *acf =
                     m->module->getOrInsertFunction(funcName, LLVMTypes::MaskType,
                                                    cmpOpType, cmpOpType,
-                                                   LLVMTypes::MaskType, NULL);
+                                                   LLVMTypes::MaskType, nullptr);
                 andCmpFunc = llvm::dyn_cast<llvm::Function>(acf);
-                Assert(andCmpFunc != NULL);
+                Assert(andCmpFunc != nullptr);
                 andCmpFunc->setDoesNotThrow();
                 andCmpFunc->setDoesNotAccessMemory();
             }
@@ -5182,7 +5182,7 @@
             llvm::Instruction *cmpCall =
                 llvm::CallInst::Create(andCmpFunc, argArray,
                                        LLVMGetName(bop, "_and_mask"),
-                                       (llvm::Instruction *)NULL);
+                                       (llvm::Instruction *)nullptr);
 
             // And replace the original AND instruction with it.
             llvm::ReplaceInstWithInst(&*iter, cmpCall);
@@ -5213,8 +5213,8 @@
         // Declare the __not, __and_not1, and __and_not2 functions that we
         // expect the target to end up providing.
         notFunc =
-            llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__not", mt, mt, NULL));
-        assert(notFunc != NULL);
+            llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__not", mt, mt, nullptr));
+        assert(notFunc != nullptr);
 #if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
         notFunc->addFnAttr(llvm::Attributes::NoUnwind);
         notFunc->addFnAttr(llvm::Attributes::ReadNone);
@@ -5225,8 +5225,8 @@
 
         andNotFuncs[0] =
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not1", mt, mt, mt,
-                                                      NULL));
-        assert(andNotFuncs[0] != NULL);
+                                                      nullptr));
+        assert(andNotFuncs[0] != nullptr);
 #if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
         andNotFuncs[0]->addFnAttr(llvm::Attributes::NoUnwind);
         andNotFuncs[0]->addFnAttr(llvm::Attributes::ReadNone);
@@ -5236,8 +5236,8 @@
 #endif
         andNotFuncs[1] =
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not2", mt, mt, mt,
-                                                      NULL));
-        assert(andNotFuncs[1] != NULL);
+                                                      nullptr));
+        assert(andNotFuncs[1] != nullptr);
 #if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
         andNotFuncs[1]->addFnAttr(llvm::Attributes::NoUnwind);
         andNotFuncs[1]->addFnAttr(llvm::Attributes::ReadNone);
@@ -5268,15 +5268,15 @@
 lIsAllTrue(llvm::Value *v) {
     if (llvm::ConstantVector *cv = llvm::dyn_cast<llvm::ConstantVector>(v)) {
         llvm::ConstantInt *ci;
-        return (cv->getSplatValue() != NULL &&
-                (ci = llvm::dyn_cast<llvm::ConstantInt>(cv->getSplatValue())) != NULL &&
+        return (cv->getSplatValue() != nullptr &&
+                (ci = llvm::dyn_cast<llvm::ConstantInt>(cv->getSplatValue())) != nullptr &&
                 ci->isOne());
     }
 
     if (llvm::ConstantDataVector *cdv = llvm::dyn_cast<llvm::ConstantDataVector>(v)) {
         llvm::ConstantInt *ci;
-        return (cdv->getSplatValue() != NULL &&
-                (ci = llvm::dyn_cast<llvm::ConstantInt>(cdv->getSplatValue())) != NULL &&
+        return (cdv->getSplatValue() != nullptr &&
+                (ci = llvm::dyn_cast<llvm::ConstantInt>(cdv->getSplatValue())) != nullptr &&
                 ci->isOne());
     }
 
@@ -5285,7 +5285,7 @@
 
 
 /** Checks to see if the given value is the NOT of some other value.  If
-    so, it returns the operand of the NOT; otherwise returns NULL.
+    so, it returns the operand of the NOT; otherwise returns nullptr.
  */
 llvm::Value *
     MaskOpsCleanupPass::lGetNotOperand(llvm::Value *v) const {
@@ -5300,7 +5300,7 @@
             // XOR of all-true vector.
             return bop->getOperand(0);
 
-    return NULL;
+    return nullptr;
 }
 
 
@@ -5311,7 +5311,7 @@
  restart:
     for (llvm::BasicBlock::iterator iter = bb.begin(), e = bb.end(); iter != e; ++iter) {
         llvm::BinaryOperator *bop = llvm::dyn_cast<llvm::BinaryOperator>(&*iter);
-        if (bop == NULL)
+        if (bop == nullptr)
             continue;
 
         if (bop->getType() != LLVMTypes::MaskType)

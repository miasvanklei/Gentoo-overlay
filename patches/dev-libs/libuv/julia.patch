From 8122ac73c1badcdfbc333ee2d723dabbcf3d0024 Mon Sep 17 00:00:00 2001
From: Jameson Nash <jameson@mit.edu>
Date: Fri, 23 Nov 2012 03:32:25 -0500
Subject: [PATCH] make pipes more flexible for process spawn (using socketpair)

---
 include/uv-unix.h            |   1 +
 include/uv-win.h             |   5 +-
 include/uv.h                 |  95 +++++++++-------
 src/unix/core.c              |   2 +-
 src/unix/internal.h          |   6 +-
 src/unix/pipe.c              |  82 ++++++++++++-
 src/unix/process.c           | 164 ++++++--------------------
 src/unix/stream.c            |   4 +-
 src/win/internal.h           |   4 +
 src/win/pipe.c               | 177 ++++++++++++++++++++++++++---
 src/win/process-stdio.c      | 163 +++++++++++---------------
 src/win/process.c            |   7 +-
 test/benchmark-spawn.c       |  15 ++-
 test/test-ipc-send-recv.c    |  14 +--
 test/test-ipc.c              |  21 ++--
 test/test-ping-pong.c        |   2 +-
 test/test-shutdown-close.c   |   2 +-
 test/test-spawn.c            | 265 +++++++++++++++++++++++++++++--------------
 test/test-stdio-over-pipes.c |  27 +++--
 19 files changed, 645 insertions(+), 411 deletions(-)

diff --git a/include/uv-unix.h b/include/uv-unix.h
index 82d193bdc..869b21bc0 100644
--- a/include/uv-unix.h
+++ b/include/uv-unix.h
@@ -124,6 +124,7 @@ typedef struct uv_buf_t {
 } uv_buf_t;
 
 typedef int uv_file;
+typedef int uv_os_handle_t;
 typedef int uv_os_sock_t;
 typedef int uv_os_fd_t;
 
diff --git a/include/uv-win.h b/include/uv-win.h
index 6b537fed0..de04dc31b 100644
--- a/include/uv-win.h
+++ b/include/uv-win.h
@@ -458,7 +458,10 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);
 #define uv_pipe_connection_fields                                             \
   uv_timer_t* eof_timer;                                                      \
   uv_write_t ipc_header_write_req;                                            \
-  int ipc_pid;                                                                \
+  union {                                                                     \
+    int pid;                                                                  \
+    int *p_pid;                                                               \
+  } ipc_pid;                                                                  \
   uint64_t remaining_ipc_rawdata_bytes;                                       \
   struct {                                                                    \
     void* queue[2];                                                           \
diff --git a/include/uv.h b/include/uv.h
index baa0b2812..810eb2738 100644
--- a/include/uv.h
+++ b/include/uv.h
@@ -183,7 +183,9 @@ typedef enum {
   UV_HANDLE_TYPE_MAP(XX)
 #undef XX
   UV_FILE,
-  UV_HANDLE_TYPE_MAX
+  UV_HANDLE_TYPE_MAX,
+  UV_RAW_FD, /* fd for both unix and windows */
+  UV_RAW_HANDLE /* HANDLE on windows, same as UV_RAW_FD on unix */
 } uv_handle_type;
 
 typedef enum {
@@ -262,13 +264,13 @@ UV_EXTERN int uv_loop_close(uv_loop_t* loop);
 /*
  * NOTE:
  *  This function is DEPRECATED (to be removed after 0.12), users should
- *  allocate the loop manually and use uv_loop_init instead.
+ * allocate the loop manually and use uv_loop_init instead.
  */
 UV_EXTERN uv_loop_t* uv_loop_new(void);
 /*
  * NOTE:
  *  This function is DEPRECATED (to be removed after 0.12). Users should use
- *  uv_loop_close and free the memory manually instead.
+ * uv_loop_close and free the memory manually instead.
  */
 UV_EXTERN void uv_loop_delete(uv_loop_t*);
 UV_EXTERN size_t uv_loop_size(void);
@@ -414,7 +416,7 @@ struct uv_shutdown_s {
   } u;                                                                        \
   UV_HANDLE_PRIVATE_FIELDS                                                    \
 
-/* The abstract base class of all handles. */
+/* The abstract base class of all handles.  */
 struct uv_handle_s {
   UV_HANDLE_FIELDS
 };
@@ -681,15 +683,43 @@ UV_EXTERN uv_handle_type uv_guess_handle(uv_file file);
  *
  * Representing a pipe stream or pipe server. On Windows this is a Named
  * Pipe. On Unix this is a Unix domain socket.
+ *
+ * A single uv_pipe_t always represents one end of a pipe. You can use
+ * uv_pipe_link to create a pair of connected pipe ends.
  */
 struct uv_pipe_s {
   UV_HANDLE_FIELDS
   UV_STREAM_FIELDS
-  int ipc; /* non-zero if this pipe is used for passing handles */
   UV_PIPE_PRIVATE_FIELDS
 };
 
-UV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);
+enum uv_pipe_flags {
+	UV_PIPE_IPC			 = 0x01,
+	UV_PIPE_SPAWN_SAFE	 = 0x02,
+	UV_PIPE_READABLE	 = 0x04,
+	UV_PIPE_WRITABLE	 = 0x08
+};
+/*
+ * Initialize a pipe. The last argument is a boolean to indicate if
+ * this pipe will be used for handle passing between processes.
+ */
+UV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int flags);
+
+/*
+ * Creates a pipe and assigns the two pipe ends to the given uv_pipe_t's
+ */
+UV_EXTERN int uv_pipe_link(uv_pipe_t *read, uv_pipe_t *write);
+
+/*
+ * Attempt to synchronously close the given pipe. This will only work if the pipe is
+ * inactive (i.e. not reading, writing listening, connecting, etc. Otherwise this function 
+ * will abort()
+ */
+UV_EXTERN void uv_pipe_close_sync(uv_pipe_t *pipe);
+
+/*
+ * Opens an existing file descriptor or HANDLE as a pipe.
+ */
 UV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);
 UV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);
 UV_EXTERN void uv_pipe_connect(uv_connect_t* req,
@@ -811,7 +841,6 @@ UV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,
                              const struct addrinfo* hints);
 UV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);
 
-
 /*
 * uv_getnameinfo_t is a subclass of uv_req_t.
 *
@@ -831,32 +860,16 @@ UV_EXTERN int uv_getnameinfo(uv_loop_t* loop,
                              const struct sockaddr* addr,
                              int flags);
 
-
-/* uv_spawn() options. */
-typedef enum {
-  UV_IGNORE         = 0x00,
-  UV_CREATE_PIPE    = 0x01,
-  UV_INHERIT_FD     = 0x02,
-  UV_INHERIT_STREAM = 0x04,
-
-  /*
-   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE
-   * determine the direction of flow, from the child process' perspective. Both
-   * flags may be specified to create a duplex data stream.
-   */
-  UV_READABLE_PIPE  = 0x10,
-  UV_WRITABLE_PIPE  = 0x20
-} uv_stdio_flags;
-
 typedef struct uv_stdio_container_s {
-  uv_stdio_flags flags;
-
-  union {
-    uv_stream_t* stream;
-    int fd;
-  } data;
+	uv_handle_type type;
+	union {
+		uv_stream_t *stream;
+		uv_file fd;
+		uv_os_handle_t os_handle;
+	} data;
 } uv_stdio_container_t;
 
+/* uv_spawn() options */
 typedef struct uv_process_options_s {
   uv_exit_cb exit_cb; /* Called after the process exits. */
   const char* file;   /* Path to program to execute. */
@@ -1067,9 +1080,9 @@ UV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
 UV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);
 
 UV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,
-                                     int* count);
+  int* count);
 UV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,
-                                           int count);
+  int count);
 
 
 typedef enum {
@@ -1122,44 +1135,44 @@ UV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);
 UV_EXTERN int uv_fs_close(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
-                          uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_open(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          int flags,
                          int mode,
-                         uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_read(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          const uv_buf_t bufs[],
                          unsigned int nbufs,
                          int64_t offset,
-                         uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_unlink(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
-                           uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_write(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           const uv_buf_t bufs[],
                           unsigned int nbufs,
                           int64_t offset,
-                          uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           int mode,
-                          uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* tpl,
-                            uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
-                          uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_scandir(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
@@ -1249,7 +1262,7 @@ UV_EXTERN int uv_fs_symlink(uv_loop_t* loop,
                             const char* path,
                             const char* new_path,
                             int flags,
-                            uv_fs_cb cb);
+    uv_fs_cb cb);
 UV_EXTERN int uv_fs_readlink(uv_loop_t* loop,
                              uv_fs_t* req,
                              const char* path,
diff --git a/src/unix/core.c b/src/unix/core.c
index 9aaca8418..153cabaa6 100644
--- a/src/unix/core.c
+++ b/src/unix/core.c
@@ -226,7 +226,7 @@ int uv__getiovmax(void) {
 }
 
 
-static void uv__finish_close(uv_handle_t* handle) {
+void uv__finish_close(uv_handle_t* handle) {
   /* Note: while the handle is in the UV_CLOSING state now, it's still possible
    * for it to be active in the sense that uv__is_active() returns true.
    * A good example is when the user calls uv_shutdown(), immediately followed
diff --git a/src/unix/internal.h b/src/unix/internal.h
index 938e76f1d..4831cd7be 100644
--- a/src/unix/internal.h
+++ b/src/unix/internal.h
@@ -137,7 +137,9 @@
   UV_TCP_SINGLE_ACCEPT    = 0x1000, /* Only accept() when idle. */
   UV_HANDLE_IPV6          = 0x10000, /* Handle is bound to a IPv6 socket. */
   UV_UDP_PROCESSING       = 0x20000, /* Handle is running the send callback queue. */
-  UV_HANDLE_BOUND         = 0x40000  /* Handle is bound to an address and port */
+  UV_HANDLE_BOUND         = 0x40000,  /* Handle is bound to an address and port */
+  UV__PIPE_IPC            = 0x80000, /* Handle is configured for IPC */
+  UV__PIPE_SPAWN_SAFE     = 0x100000  /* Handle is "safe" to pass to a spawn child (blocking mode / non-overlapped) */
 };
 
 /* loop flags */
@@ -256,6 +258,7 @@ void uv__tcp_close(uv_tcp_t* handle);
 void uv__timer_close(uv_timer_t* handle);
 void uv__udp_close(uv_udp_t* handle);
 void uv__udp_finish_close(uv_udp_t* handle);
+void uv__finish_close(uv_handle_t* handle);
 uv_handle_type uv__handle_type(int fd);
 FILE* uv__open_file(const char* path);
 int uv__getpwuid_r(uv_passwd_t* pwd);
@@ -274,7 +277,6 @@ int uv___stream_fd(const uv_stream_t* handle);
 # define UV__F_NONBLOCK 1
 #endif
 
-int uv__make_socketpair(int fds[2], int flags);
 int uv__make_pipe(int fds[2], int flags);
 
 #if defined(__APPLE__)
diff --git a/src/unix/pipe.c b/src/unix/pipe.c
index d4fdfa9d5..26983d11f 100644
--- a/src/unix/pipe.c
+++ b/src/unix/pipe.c
@@ -30,12 +30,18 @@
 #include <stdlib.h>
 
 
-int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {
+int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int flags) {
   uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);
   handle->shutdown_req = NULL;
   handle->connect_req = NULL;
   handle->pipe_fname = NULL;
-  handle->ipc = ipc;
+    
+  handle->flags |= ((flags&UV_PIPE_IPC)?UV__PIPE_IPC:0)|
+          ((flags&UV_PIPE_SPAWN_SAFE)?UV__PIPE_SPAWN_SAFE:0)|
+          ((flags&UV_PIPE_READABLE)?UV_STREAM_READABLE:0)|
+          ((flags&UV_PIPE_WRITABLE)?UV_STREAM_WRITABLE:0);
+  /*if (flags == 0 || flags == 1)
+      handle->flags |= UV_STREAM_READABLE|UV_STREAM_WRITABLE;*/
   return 0;
 }
 
@@ -92,6 +98,74 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
   return err;
 }
 
+int uv_pipe_link(uv_pipe_t *read, uv_pipe_t *write) {
+  int err;
+  int fds[2];
+
+  assert(read->loop==write->loop);
+  assert(read->flags&UV_STREAM_READABLE);
+  assert(write->flags&UV_STREAM_WRITABLE);
+  assert(!(write->flags&read->flags&UV__PIPE_IPC));
+
+#ifdef SOCK_NONBLOCK
+  int fl;
+
+  fl = SOCK_CLOEXEC;
+
+  if (~((read->flags|write->flags)&UV_PIPE_SPAWN_SAFE)) {
+    if (socketpair(AF_UNIX, SOCK_STREAM|SOCK_NONBLOCK|fl, 0, fds) == 0)
+        goto open_fds;
+
+    if (errno != EINVAL)
+      goto pipe_error;
+    /* errno == EINVAL so maybe the kernel headers lied about
+     * the availability of SOCK_NONBLOCK. This can happen if people
+     * build libuv against newer kernel headers than the kernel
+     * they actually run the software on.
+     */
+  }
+#endif
+
+  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))
+    goto pipe_error;
+
+  uv__cloexec(fds[0], 1);
+  uv__cloexec(fds[1], 1);
+
+  if (~(read->flags & UV_PIPE_SPAWN_SAFE))
+    uv__nonblock(fds[0], 1);
+  if (~(write->flags & UV_PIPE_SPAWN_SAFE))
+    uv__nonblock(fds[1], 1);
+
+open_fds: 
+  
+  err = uv__stream_open((uv_stream_t*)read, fds[0], 0);
+  if (err) {
+      close(fds[0]);
+      close(fds[1]);
+      goto pipe_error;
+  }
+
+  err = uv__stream_open((uv_stream_t*)write, fds[1], 0);
+  if (err) {
+      uv_pipe_close_sync(read);
+      close(fds[0]);
+      close(fds[1]);
+      goto pipe_error;
+  }
+
+  return 0;
+  
+pipe_error:
+  return -1;
+}
+
+void uv_pipe_close_sync(uv_pipe_t *pipe) {
+    uv__stream_close((uv_stream_t*)pipe); /* TODO: ??? */
+    pipe->close_cb=0;
+    pipe->flags |= UV_CLOSING;
+    uv__finish_close((uv_handle_t*)pipe);
+}
 
 int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {
   if (uv__stream_fd(handle) == -1)
@@ -264,7 +338,7 @@ void uv_pipe_pending_instances(uv_pipe_t* handle, int count) {
 int uv_pipe_pending_count(uv_pipe_t* handle) {
   uv__stream_queued_fds_t* queued_fds;
 
-  if (!handle->ipc)
+  if (!handle->flags&UV__PIPE_IPC)
     return 0;
 
   if (handle->accepted_fd == -1)
@@ -279,7 +353,7 @@ int uv_pipe_pending_count(uv_pipe_t* handle) {
 
 
 uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {
-  if (!handle->ipc)
+  if (!handle->flags&UV__PIPE_IPC)
     return UV_UNKNOWN_HANDLE;
 
   if (handle->accepted_fd == -1)
diff --git a/src/unix/process.c b/src/unix/process.c
index ef10a3422..1fe76ce37 100644
--- a/src/unix/process.c
+++ b/src/unix/process.c
@@ -109,44 +109,8 @@ static void uv__chld(uv_signal_t* handle, int signum) {
     process->exit_cb(process, exit_status, term_signal);
   }
   assert(QUEUE_EMPTY(&pending));
-}
-
-
-int uv__make_socketpair(int fds[2], int flags) {
-#if defined(__linux__)
-  static int no_cloexec;
-
-  if (no_cloexec)
-    goto skip;
-
-  if (socketpair(AF_UNIX, SOCK_STREAM | UV__SOCK_CLOEXEC | flags, 0, fds) == 0)
-    return 0;
-
-  /* Retry on EINVAL, it means SOCK_CLOEXEC is not supported.
-   * Anything else is a genuine error.
-   */
-  if (errno != EINVAL)
-    return -errno;
-
-  no_cloexec = 1;
-
-skip:
-#endif
-
-  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))
-    return -errno;
-
-  uv__cloexec(fds[0], 1);
-  uv__cloexec(fds[1], 1);
-
-  if (flags & UV__F_NONBLOCK) {
-    uv__nonblock(fds[0], 1);
-    uv__nonblock(fds[1], 1);
   }
 
-  return 0;
-}
-
 
 int uv__make_pipe(int fds[2], int flags) {
 #if defined(__linux__)
@@ -185,74 +149,30 @@ int uv__make_pipe(int fds[2], int flags) {
  * Used for initializing stdio streams like options.stdin_stream. Returns
  * zero on success. See also the cleanup section in uv_spawn().
  */
-static int uv__process_init_stdio(uv_stdio_container_t* container, int fds[2]) {
-  int mask;
-  int fd;
-
-  mask = UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD | UV_INHERIT_STREAM;
-
-  switch (container->flags & mask) {
-  case UV_IGNORE:
-    return 0;
-
-  case UV_CREATE_PIPE:
-    assert(container->data.stream != NULL);
-    if (container->data.stream->type != UV_NAMED_PIPE)
-      return -EINVAL;
-    else
-      return uv__make_socketpair(fds, 0);
-
-  case UV_INHERIT_FD:
-  case UV_INHERIT_STREAM:
-    if (container->flags & UV_INHERIT_FD)
-      fd = container->data.fd;
-    else
-      fd = uv__stream_fd(container->data.stream);
-
-    if (fd == -1)
-      return -EINVAL;
-
-    fds[1] = fd;
-    return 0;
-
-  default:
-    assert(0 && "Unexpected flags");
+static int uv__process_init_stdio(uv_stdio_container_t* container, int *fd) {
+  switch (container->type) {
+    case UV_STREAM:
+      if (container->data.stream == NULL) {
+        *fd = -1;
+        return 0;
+      } else {
+        *fd = container->data.stream->io_watcher.fd;
+      }
+      break;
+    case UV_RAW_FD:
+    case UV_RAW_HANDLE:
+      *fd = container->data.fd;
+      break;
+    default:
+      assert (0 && "Unexpected flags");
+      *fd = -1;
     return -EINVAL;
   }
-}
-
-
-static int uv__process_open_stream(uv_stdio_container_t* container,
-                                   int pipefds[2],
-                                   int writable) {
-  int flags;
-  int err;
-
-  if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0)
+  if (*fd == -1) {
+    return -EINVAL;
+  } else {
     return 0;
-
-  err = uv__close(pipefds[1]);
-  if (err != 0)
-    abort();
-
-  pipefds[1] = -1;
-  uv__nonblock(pipefds[0], 1);
-
-  if (container->data.stream->type == UV_NAMED_PIPE &&
-      ((uv_pipe_t*)container->data.stream)->ipc)
-    flags = UV_STREAM_READABLE | UV_STREAM_WRITABLE;
-  else if (writable)
-    flags = UV_STREAM_WRITABLE;
-  else
-    flags = UV_STREAM_READABLE;
-
-  return uv__stream_open(container->data.stream, pipefds[0], flags);
-}
-
-
-static void uv__process_close_stream(uv_stdio_container_t* container) {
-  if (!(container->flags & UV_CREATE_PIPE)) return;
-  uv__stream_close((uv_stream_t*)container->data.stream);
+  }
 }
 
 
@@ -277,7 +197,7 @@ static void uv__write_int(int fd, int val) {
  */
 static void uv__process_child_init(const uv_process_options_t* options,
                                    int stdio_count,
-                                   int (*pipes)[2],
+                                   int *pipes,
                                    int error_fd) {
   int close_fd;
   int use_fd;
@@ -291,19 +211,19 @@ static void uv__process_child_init(const uv_process_options_t* options,
    * this fd 2 (stderr) would be duplicated into fd 1, thus making both
    * stdout and stderr go to the same fd, which was not the intention. */
   for (fd = 0; fd < stdio_count; fd++) {
-    use_fd = pipes[fd][1];
+    use_fd = pipes[fd];
     if (use_fd < 0 || use_fd >= fd)
       continue;
-    pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);
-    if (pipes[fd][1] == -1) {
+    pipes[fd] = fcntl(use_fd, F_DUPFD, stdio_count);
+    if (pipes[fd] == -1) {
       uv__write_int(error_fd, -errno);
       _exit(127);
     }
   }
 
   for (fd = 0; fd < stdio_count; fd++) {
-    close_fd = pipes[fd][0];
-    use_fd = pipes[fd][1];
+    close_fd = -1;
+    use_fd = pipes[fd];
 
     if (use_fd < 0) {
       if (fd >= 3)
@@ -340,7 +260,7 @@ static void uv__process_child_init(const uv_process_options_t* options,
   }
 
   for (fd = 0; fd < stdio_count; fd++) {
-    use_fd = pipes[fd][1];
+    use_fd = pipes[fd];
 
     if (use_fd >= stdio_count)
       uv__close(use_fd);
@@ -391,7 +311,7 @@ int uv_spawn(uv_loop_t* loop,
   return -ENOSYS;
 #else
   int signal_pipe[2] = { -1, -1 };
-  int (*pipes)[2];
+  int *pipes;
   int stdio_count;
   ssize_t r;
   pid_t pid;
@@ -420,12 +340,11 @@ int uv_spawn(uv_loop_t* loop,
     goto error;
 
   for (i = 0; i < stdio_count; i++) {
-    pipes[i][0] = -1;
-    pipes[i][1] = -1;
+    pipes[i] = -1;
   }
 
   for (i = 0; i < options->stdio_count; i++) {
-    err = uv__process_init_stdio(options->stdio + i, pipes[i]);
+    err = uv__process_init_stdio(options->stdio + i, &pipes[i]);
     if (err)
       goto error;
   }
@@ -500,17 +419,6 @@ int uv_spawn(uv_loop_t* loop,
 
   uv__close_nocheckstdio(signal_pipe[0]);
 
-  for (i = 0; i < options->stdio_count; i++) {
-    err = uv__process_open_stream(options->stdio + i, pipes[i], i == 0);
-    if (err == 0)
-      continue;
-
-    while (i--)
-      uv__process_close_stream(options->stdio + i);
-
-    goto error;
-  }
-
   /* Only activate this handle if exec() happened successfully */
   if (exec_errorno == 0) {
     QUEUE_INSERT_TAIL(&loop->process_handles, &process->queue);
@@ -526,13 +434,9 @@ int uv_spawn(uv_loop_t* loop,
 error:
   if (pipes != NULL) {
     for (i = 0; i < stdio_count; i++) {
-      if (i < options->stdio_count)
-        if (options->stdio[i].flags & (UV_INHERIT_FD | UV_INHERIT_STREAM))
-          continue;
-      if (pipes[i][0] != -1)
-        uv__close_nocheckstdio(pipes[i][0]);
-      if (pipes[i][1] != -1)
-        uv__close_nocheckstdio(pipes[i][1]);
+      if (options->stdio[i].type == UV_STREAM && options->stdio[i].data.stream == NULL)
+        if (pipes[i] != -1)
+          uv__close_nocheckstdio(pipes[i]);
     }
     uv__free(pipes);
   }
diff --git a/src/unix/stream.c b/src/unix/stream.c
index 9043664df..3d74d155b 100644
--- a/src/unix/stream.c
+++ b/src/unix/stream.c
@@ -1112,7 +1112,7 @@ static void uv__read(uv_stream_t* stream) {
    */
   count = 32;
 
-  is_ipc = stream->type == UV_NAMED_PIPE && ((uv_pipe_t*) stream)->ipc;
+  is_ipc = stream->type == UV_NAMED_PIPE && ((uv_pipe_t*) stream)->flags&UV__PIPE_IPC;
 
   /* XXX: Maybe instead of having UV_STREAM_READING we just test if
    * tcp->read_cb is NULL or not?
@@ -1361,7 +1361,7 @@ int uv_write2(uv_write_t* req,
     return -EBADF;
 
   if (send_handle) {
-    if (stream->type != UV_NAMED_PIPE || !((uv_pipe_t*)stream)->ipc)
+    if (stream->type != UV_NAMED_PIPE || !(((uv_pipe_t*)stream)->flags&UV__PIPE_IPC))
       return -EINVAL;
 
     /* XXX We abuse uv_write2() to send over UDP handles to child processes.
diff --git a/src/win/internal.h b/src/win/internal.h
index c724793bf..29cd6e3cd 100644
--- a/src/win/internal.h
+++ b/src/win/internal.h
@@ -99,6 +99,10 @@ extern UV_THREAD_LOCAL int uv__crt_assert_enabled;
 #define UV_HANDLE_NON_OVERLAPPED_PIPE           0x01000000
 #define UV_HANDLE_PIPESERVER                    0x02000000
 #define UV_HANDLE_PIPE_READ_CANCELABLE          0x04000000
+#define UV_HANDLE_PIPE_IPC                      0x08000000
+#define UV_HANDLE_PIPE_SPAWN_SAFE               0x10000000
+#define UV_HANDLE_PIPE_IPC_CLIENT               0x20000000
+
 
 /* Only used by uv_tty_t handles. */
 #define UV_HANDLE_TTY_READABLE                  0x01000000
diff --git a/src/win/pipe.c b/src/win/pipe.c
index a784325c5..24e58028c 100644
--- a/src/win/pipe.c
+++ b/src/win/pipe.c
@@ -89,20 +89,24 @@ static void uv_unique_pipe_name(char* ptr, char* name, size_t size) {
 }
 
 
-int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {
+int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int flags) {
   uv_stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);
 
   handle->reqs_pending = 0;
   handle->handle = INVALID_HANDLE_VALUE;
   handle->name = NULL;
-  handle->pipe.conn.ipc_pid = 0;
+  handle->pipe.conn.ipc_pid.pid = 0;
   handle->pipe.conn.remaining_ipc_rawdata_bytes = 0;
   QUEUE_INIT(&handle->pipe.conn.pending_ipc_info.queue);
   handle->pipe.conn.pending_ipc_info.queue_len = 0;
-  handle->ipc = ipc;
   handle->pipe.conn.non_overlapped_writes_tail = NULL;
   handle->pipe.conn.readfile_thread = NULL;
 
+  handle->flags |= ((flags&UV_PIPE_IPC)?UV_HANDLE_PIPE_IPC:0)|
+                    ((flags&UV_PIPE_SPAWN_SAFE)?UV_HANDLE_PIPE_SPAWN_SAFE:0)|
+                    ((flags&UV_PIPE_READABLE)?UV_HANDLE_READABLE:0)|
+                    ((flags&UV_PIPE_WRITABLE)?UV_HANDLE_WRITABLE:0);
+
   uv_req_init(loop, (uv_req_t*) &handle->pipe.conn.ipc_header_write_req);
 
   return 0;
@@ -240,7 +244,147 @@ int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,
 
   return err;
 }
+static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
+    uv_pipe_t* read, uv_pipe_t* write) {
+  char pipe_name[64];
+  SECURITY_ATTRIBUTES sa;
+  DWORD server_access = 0;
+  DWORD client_access = 0;
+  uv_pipe_t *server_pipe, *client_pipe;
+  int err;
+  
+  if (read->flags & UV_HANDLE_PIPE_SPAWN_SAFE || write->flags & UV_HANDLE_PIPE_IPC) {
+    /* server_pipe is always owned by libuv, is never SPAWN_SAFE */
+    server_access |= PIPE_ACCESS_OUTBOUND;
+    if (write->flags&UV_HANDLE_READABLE);
+      server_access |= PIPE_ACCESS_INBOUND;
+    client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;
+    if (read->flags&UV_HANDLE_WRITABLE)
+      client_access |= GENERIC_WRITE;
+    server_pipe=write;
+    client_pipe=read;
+  } else {
+    server_access |= PIPE_ACCESS_INBOUND;
+    if(read->flags&UV_HANDLE_WRITABLE)
+        server_access |= PIPE_ACCESS_OUTBOUND;
+    client_access |= GENERIC_WRITE;
+    if(write->flags&UV_HANDLE_READABLE)
+        client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;
+    server_pipe=read;
+    client_pipe=write;
+  }
+
+  /* Create server pipe handle. */
+  err = uv_stdio_pipe_server(loop,
+                             server_pipe,
+                             server_access,
+                             pipe_name,
+                             sizeof(pipe_name));
+  if (err != 0)
+    goto error;
 
+  /* Create child pipe handle. */
+  sa.nLength = sizeof sa;
+  sa.lpSecurityDescriptor = NULL;
+  sa.bInheritHandle = TRUE;
+
+  client_pipe->handle = CreateFileA(pipe_name,
+                           client_access,
+                           0,
+                           &sa,
+                           OPEN_EXISTING,
+                           (client_pipe->flags&UV_HANDLE_PIPE_SPAWN_SAFE) ? 0 : FILE_FLAG_OVERLAPPED,
+                           NULL);
+  if (client_pipe->handle == INVALID_HANDLE_VALUE) {
+    err = GetLastError();
+    goto error;
+  }
+
+#ifndef NDEBUG
+  /* Validate that the pipe was opened in the right mode. */
+  {
+    DWORD mode;
+    BOOL r = GetNamedPipeHandleState(client_pipe->handle,
+                                     &mode,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     0);
+    assert(r == TRUE);
+    assert(mode == (PIPE_READMODE_BYTE | PIPE_WAIT));
+  }
+#endif
+
+  /* Do a blocking ConnectNamedPipe.  This should not block because we have */
+  /* both ends of the pipe created. */
+  if (!ConnectNamedPipe(server_pipe->handle, NULL)) {
+    if (GetLastError() != ERROR_PIPE_CONNECTED) {
+      err = GetLastError();
+      goto error;
+    }
+  }
+
+  if (client_pipe->flags&UV_HANDLE_PIPE_SPAWN_SAFE) {
+        client_pipe->flags|=UV_HANDLE_NON_OVERLAPPED_PIPE;
+  }
+  uv_pipe_connection_init(client_pipe);
+
+  return 0;
+
+ error:
+  if (server_pipe->handle != INVALID_HANDLE_VALUE) {
+    uv_pipe_cleanup(loop, server_pipe);
+  }
+
+  if (client_pipe->handle != INVALID_HANDLE_VALUE) {
+    uv_pipe_cleanup(loop, client_pipe);
+  }
+  
+  return err;
+}
+
+int uv_pipe_link(uv_pipe_t* read, uv_pipe_t* write)
+{
+    int err;
+    assert(read->loop==write->loop);
+    assert(read->flags&UV_HANDLE_READABLE);
+    assert(write->flags&UV_HANDLE_WRITABLE);
+    assert(!(write->flags&read->flags&UV_HANDLE_PIPE_IPC));
+    if (read->flags & write->flags & UV_HANDLE_PIPE_SPAWN_SAFE) {
+        if (!CreatePipe(&(read->handle),&(write->handle),NULL,65536)) {
+            err = GetLastError();
+            goto done;
+        }
+        read->flags |= UV_HANDLE_NON_OVERLAPPED_PIPE;
+        write->flags |= UV_HANDLE_NON_OVERLAPPED_PIPE;
+        uv_pipe_connection_init(read);
+        uv_pipe_connection_init(write);
+        err = 0;
+    } else {
+        err = uv__create_stdio_pipe_pair(read->loop,read,write);
+        if (read->flags&UV_HANDLE_PIPE_IPC) {
+            write->flags |= UV_HANDLE_PIPE_IPC_CLIENT;
+            write->ipc_pid.p_pid = &(read->ipc_pid.pid);
+        } else if (write->flags&UV_HANDLE_PIPE_IPC) {
+            read->flags |= UV_HANDLE_PIPE_IPC_CLIENT;
+            read->ipc_pid.p_pid = &(write->ipc_pid.pid);
+        }
+    }
+done:
+    return err;
+}
+
+void uv_pipe_close_sync(uv_pipe_t *pipe)
+{
+    assert(!(pipe->flags&(UV_HANDLE_LISTENING|UV_HANDLE_BOUND|
+        UV_HANDLE_READING))&&pipe->reqs_pending==0);
+    pipe->close_cb=NULL;
+    uv_pipe_cleanup(pipe->loop,pipe);
+    uv_pipe_endgame(pipe->loop,pipe);
+    uv__handle_closing(pipe);
+    uv__handle_close(pipe);
+}
 
 static int uv_set_pipe_handle(uv_loop_t* loop,
                               uv_pipe_t* handle,
@@ -858,7 +1002,7 @@ int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client) {
   uv__ipc_queue_item_t* item;
   int err;
 
-  if (server->ipc) {
+  if (server->flags & UV_HANDLE_PIPE_IPC) {
     if (QUEUE_EMPTY(&server->pipe.conn.pending_ipc_info.queue)) {
       /* No valid pending sockets. */
       return WSAEWOULDBLOCK;
@@ -1248,7 +1392,7 @@ static int uv_pipe_write_impl(uv_loop_t* loop,
   req->wait_handle = INVALID_HANDLE_VALUE;
   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
 
-  if (handle->ipc) {
+  if (handle->flags&UV_HANDLE_PIPE_IPC) {
     assert(!(handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));
     ipc_frame.header.flags = 0;
 
@@ -1256,11 +1400,11 @@ static int uv_pipe_write_impl(uv_loop_t* loop,
     if (send_handle) {
       tcp_send_handle = (uv_tcp_t*)send_handle;
 
-      if (handle->pipe.conn.ipc_pid == 0) {
-          handle->pipe.conn.ipc_pid = uv_current_pid();
+      if (handle->pipe.conn.ipc_pid.pid == 0) {
+          handle->pipe.conn.ipc_pid.pid = uv_current_pid();
       }
 
-      err = uv_tcp_duplicate_socket(tcp_send_handle, handle->pipe.conn.ipc_pid,
+      err = uv_tcp_duplicate_socket(tcp_send_handle, handle->pipe.conn.ipc_pid.pid,
           &ipc_frame.socket_info_ex.socket_info);
       if (err) {
         return err;
@@ -1476,7 +1620,6 @@ int uv_pipe_write(uv_loop_t* loop,
   return uv_pipe_write_impl(loop, req, handle, bufs, nbufs, NULL, cb);
 }
 
-
 int uv_pipe_write2(uv_loop_t* loop,
                    uv_write_t* req,
                    uv_pipe_t* handle,
@@ -1484,7 +1627,7 @@ int uv_pipe_write2(uv_loop_t* loop,
                    unsigned int nbufs,
                    uv_stream_t* send_handle,
                    uv_write_cb cb) {
-  if (!handle->ipc) {
+  if (!(handle->flags&UV_HANDLE_PIPE_IPC)) {
     return WSAEINVAL;
   }
 
@@ -1580,7 +1723,7 @@ void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,
         break;
       }
 
-      if (handle->ipc) {
+      if (handle->flags&UV_HANDLE_PIPE_IPC) {
         /* Use the IPC framing protocol to read the incoming data. */
         if (handle->pipe.conn.remaining_ipc_rawdata_bytes == 0) {
           /* We're reading a new frame.  First, read the header. */
@@ -1647,7 +1790,7 @@ void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,
                    &bytes,
                    NULL)) {
         /* Successful read */
-        if (handle->ipc) {
+        if (handle->flags & UV_HANDLE_PIPE_IPC) {
           assert(handle->pipe.conn.remaining_ipc_rawdata_bytes >= bytes);
           handle->pipe.conn.remaining_ipc_rawdata_bytes =
             handle->pipe.conn.remaining_ipc_rawdata_bytes - bytes;
@@ -1962,10 +2105,10 @@ int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {
 
   uv_pipe_connection_init(pipe);
 
-  if (pipe->ipc) {
+  if (pipe->flags&UV_HANDLE_PIPE_IPC) {
     assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));
-    pipe->pipe.conn.ipc_pid = uv_parent_pid();
-    assert(pipe->pipe.conn.ipc_pid != -1);
+    pipe->pipe.conn.ipc_pid.pid = uv_parent_pid();
+    assert(pipe->pipe.conn.ipc_pid.pid != -1);
   }
   return 0;
 }
@@ -2087,7 +2230,7 @@ static int uv__pipe_getname(const uv_pipe_t* handle, char* buffer, size_t* size)
 
 
 int uv_pipe_pending_count(uv_pipe_t* handle) {
-  if (!handle->ipc)
+  if (!(handle->flags&UV_HANDLE_PIPE_IPC))
     return 0;
   return handle->pipe.conn.pending_ipc_info.queue_len;
 }
@@ -2120,7 +2263,7 @@ int uv_pipe_getpeername(const uv_pipe_t* handle, char* buffer, size_t* size) {
 
 
 uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {
-  if (!handle->ipc)
+  if (!(handle->flags&UV_HANDLE_PIPE_IPC))
     return UV_UNKNOWN_HANDLE;
   if (handle->pipe.conn.pending_ipc_info.queue_len == 0)
     return UV_UNKNOWN_HANDLE;
diff --git a/src/win/process-stdio.c b/src/win/process-stdio.c
index e3c06f57d..03f7d1308 100644
--- a/src/win/process-stdio.c
+++ b/src/win/process-stdio.c
@@ -104,7 +104,7 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
   HANDLE child_pipe = INVALID_HANDLE_VALUE;
   int err;
 
-  if (flags & UV_READABLE_PIPE) {
+  if (flags & UV_PIPE_READABLE) {
     /* The server needs inbound access too, otherwise CreateNamedPipe() */
     /* won't give us the FILE_READ_ATTRIBUTES permission. We need that to */
     /* probe the state of the write buffer when we're trying to shutdown */
@@ -112,7 +112,7 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
     server_access |= PIPE_ACCESS_OUTBOUND | PIPE_ACCESS_INBOUND;
     client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;
   }
-  if (flags & UV_WRITABLE_PIPE) {
+  if (flags & UV_PIPE_WRITABLE) {
     server_access |= PIPE_ACCESS_INBOUND;
     client_access |= GENERIC_WRITE | FILE_READ_ATTRIBUTES;
   }
@@ -136,7 +136,7 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
                            0,
                            &sa,
                            OPEN_EXISTING,
-                           server_pipe->ipc ? FILE_FLAG_OVERLAPPED : 0,
+                           (flags & UV_PIPE_IPC) ? FILE_FLAG_OVERLAPPED : 0,
                            NULL);
   if (child_pipe == INVALID_HANDLE_VALUE) {
     err = GetLastError();
@@ -169,9 +169,9 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
   }
 
   /* The server end is now readable and/or writable. */
-  if (flags & UV_READABLE_PIPE)
+  if (flags & UV_PIPE_READABLE)
     server_pipe->flags |= UV_HANDLE_WRITABLE;
-  if (flags & UV_WRITABLE_PIPE)
+  if (flags & UV_PIPE_WRITABLE)
     server_pipe->flags |= UV_HANDLE_READABLE;
 
   *child_pipe_ptr = child_pipe;
@@ -293,74 +293,31 @@ int uv__stdio_create(uv_loop_t* loop,
   }
 
   for (i = 0; i < count; i++) {
-    uv_stdio_container_t fdopt;
-    if (i < options->stdio_count) {
-      fdopt = options->stdio[i];
-    } else {
-      fdopt.flags = UV_IGNORE;
-    }
-
-    switch (fdopt.flags & (UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD |
-            UV_INHERIT_STREAM)) {
-      case UV_IGNORE:
-        /* Starting a process with no stdin/stout/stderr can confuse it. */
-        /* So no matter what the user specified, we make sure the first */
-        /* three FDs are always open in their typical modes, e.g. stdin */
-        /* be readable and stdout/err should be writable. For FDs > 2, don't */
-        /* do anything - all handles in the stdio buffer are initialized with */
-        /* INVALID_HANDLE_VALUE, which should be okay. */
-        if (i <= 2) {
-          DWORD access = (i == 0) ? FILE_GENERIC_READ :
-                                    FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES;
-
-          err = uv__create_nul_handle(&CHILD_STDIO_HANDLE(buffer, i),
-                                      access);
-          if (err)
-            goto error;
-
-          CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;
-        }
-        break;
-
-      case UV_CREATE_PIPE: {
-        /* Create a pair of two connected pipe ends; one end is turned into */
-        /* an uv_pipe_t for use by the parent. The other one is given to */
-        /* the child. */
-        uv_pipe_t* parent_pipe = (uv_pipe_t*) fdopt.data.stream;
-        HANDLE child_pipe = INVALID_HANDLE_VALUE;
-
-        /* Create a new, connected pipe pair. stdio[i].stream should point */
-        /* to an uninitialized, but not connected pipe handle. */
-        assert(fdopt.data.stream->type == UV_NAMED_PIPE);
-        assert(!(fdopt.data.stream->flags & UV_HANDLE_CONNECTION));
-        assert(!(fdopt.data.stream->flags & UV_HANDLE_PIPESERVER));
-
-        err = uv__create_stdio_pipe_pair(loop,
-                                         parent_pipe,
-                                         &child_pipe,
-                                         fdopt.flags);
-        if (err)
-          goto error;
-
-        CHILD_STDIO_HANDLE(buffer, i) = child_pipe;
-        CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FPIPE;
-        break;
-      }
+    uv_stream_t *stream;
+    HANDLE stream_handle, child_handle;
+    int crt_flags;
 
-      case UV_INHERIT_FD: {
+    if (i >= options->stdio_count) {
+        stream = NULL;
+    } else {
+      if (options->stdio[i].type == UV_STREAM) {
+          stream = options->stdio[i].data.stream;
+      } else {
         /* Inherit a raw FD. */
         HANDLE child_handle;
-
+        switch (options->stdio[i].type) {
+          case UV_RAW_FD:
         /* Make an inheritable duplicate of the handle. */
-        err = uv__duplicate_fd(loop, fdopt.data.fd, &child_handle);
-        if (err) {
-          /* If fdopt.data.fd is not valid and fd fd <= 2, then ignore the */
-          /* error. */
-          if (fdopt.data.fd <= 2 && err == ERROR_INVALID_HANDLE) {
-            CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;
-            CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;
+            err = uv__duplicate_fd(loop, options->stdio[i].data.fd, &child_handle);
+	        if (err != 0)
+              goto error;
+            break;
+          case UV_RAW_HANDLE:
+            err = uv__duplicate_handle(loop, options->stdio[i].data.os_handle, &child_handle);
+            if (err != 0)
+              goto error;
             break;
-          }
+          default:
           goto error;
         }
 
@@ -393,50 +350,58 @@ int uv__stdio_create(uv_loop_t* loop,
         }
 
         CHILD_STDIO_HANDLE(buffer, i) = child_handle;
-        break;
+        continue;
       }
+    }
 
-      case UV_INHERIT_STREAM: {
-        /* Use an existing stream as the stdio handle for the child. */
-        HANDLE stream_handle, child_handle;
-        unsigned char crt_flags;
-        uv_stream_t* stream = fdopt.data.stream;
+    if(stream == NULL) {
+      /* Starting a process with no stdin/stout/stderr can confuse it. */
+      /* So no matter what the user specified, we make sure the first */
+      /* three FDs are always open in their typical modes, e.g. stdin */
+      /* be readable and stdout/err should be writable. For FDs > 2, don't */
+      /* do anything - all handles in the stdio buffer are initialized with */
+      /* INVALID_HANDLE_VALUE, which should be okay. */
+      if (i <= 2) {
+        DWORD access = (i == 0) ? FILE_GENERIC_READ :
+            (FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES);
+        err = uv__create_nul_handle(&CHILD_STDIO_HANDLE(buffer, i), access);
+        if (err != 0)
+          goto error;
+        CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;
+      }
+      continue;
+    }
 
-        /* Leech the handle out of the stream. */
-        if (stream->type == UV_TTY) {
+    /* Leech the handle out of the stream. */
+    switch (stream->type) {
+      case UV_TTY:
           stream_handle = ((uv_tty_t*) stream)->handle;
           crt_flags = FOPEN | FDEV;
-        } else if (stream->type == UV_NAMED_PIPE &&
-                   stream->flags & UV_HANDLE_CONNECTION) {
+          break;
+      case UV_NAMED_PIPE:
           stream_handle = ((uv_pipe_t*) stream)->handle;
           crt_flags = FOPEN | FPIPE;
-        } else {
+          break;
+      default:
           stream_handle = INVALID_HANDLE_VALUE;
           crt_flags = 0;
-        }
+      }
 
-        if (stream_handle == NULL ||
-            stream_handle == INVALID_HANDLE_VALUE) {
-          /* The handle is already closed, or not yet created, or the */
-          /* stream type is not supported. */
+      if (stream_handle == NULL ||
+          stream_handle == INVALID_HANDLE_VALUE) {
+              /* The handle is already closed, or not yet created, or the */
+              /* stream type is not supported. */
           err = ERROR_NOT_SUPPORTED;
-          goto error;
-        }
-
-        /* Make an inheritable copy of the handle. */
-        err = uv__duplicate_handle(loop, stream_handle, &child_handle);
-        if (err)
-          goto error;
-
-        CHILD_STDIO_HANDLE(buffer, i) = child_handle;
-        CHILD_STDIO_CRT_FLAGS(buffer, i) = crt_flags;
-        break;
+              goto error;
       }
 
-      default:
-        assert(0);
-        return -1;
-    }
+      /* Make an inheritable copy of the handle. */
+      err = uv__duplicate_handle(loop, stream_handle, &child_handle);
+      if (err != 0)
+        goto error;
+
+      CHILD_STDIO_HANDLE(buffer, i) = child_handle;
+      CHILD_STDIO_CRT_FLAGS(buffer, i) = crt_flags;
   }
 
   *buffer_ptr  = buffer;
diff --git a/src/win/process.c b/src/win/process.c
index 855c37408..6bc727ef0 100644
--- a/src/win/process.c
+++ b/src/win/process.c
@@ -1121,10 +1121,11 @@ int uv_spawn(uv_loop_t* loop,
   /* Set IPC pid to all IPC pipes. */
   for (i = 0; i < options->stdio_count; i++) {
     const uv_stdio_container_t* fdopt = &options->stdio[i];
-    if (fdopt->flags & UV_CREATE_PIPE &&
+    if (fdopt->type == UV_STREAM &&
+      fdopt->data.stream != NULL &&
         fdopt->data.stream->type == UV_NAMED_PIPE &&
-        ((uv_pipe_t*) fdopt->data.stream)->ipc) {
-      ((uv_pipe_t*) fdopt->data.stream)->pipe.conn.ipc_pid = info.dwProcessId;
+        ((uv_pipe_t*) fdopt->data.stream)->flags & UV_HANDLE_PIPE_IPC_CLIENT) {
+      *((uv_pipe_t*) fdopt->data.stream)->pipe.conn.ipc_pid.p_pid = info.dwProcessId;
     }
   }
 
diff --git a/test/benchmark-spawn.c b/test/benchmark-spawn.c
index ed9ad608f..1def82ab4 100644
--- a/test/benchmark-spawn.c
+++ b/test/benchmark-spawn.c
@@ -102,6 +102,7 @@ static void on_read(uv_stream_t* pipe, ssize_t nread, const uv_buf_t* buf) {
 
 static void spawn(void) {
   uv_stdio_container_t stdio[2];
+  uv_pipe_t child_stdout;
   int r;
 
   ASSERT(process_open == 0);
@@ -114,17 +115,23 @@ static void spawn(void) {
   options.args = args;
   options.exit_cb = exit_cb;
 
-  uv_pipe_init(loop, &out, 0);
+  uv_pipe_init(loop, &out, UV_PIPE_READABLE);
+  uv_pipe_init(loop, &child_stdout, UV_PIPE_SPAWN_SAFE|UV_PIPE_WRITABLE);
+  r = uv_pipe_link(&out,&child_stdout);
+  ASSERT( r == 0 );
 
   options.stdio = stdio;
   options.stdio_count = 2;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_stdout;
 
   r = uv_spawn(loop, &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_stdout);
+
   process_open = 1;
   pipe_open = 1;
   output_used = 0;
diff --git a/test/test-ipc-send-recv.c b/test/test-ipc-send-recv.c
index c445483fa..7c894d7ee 100644
--- a/test/test-ipc-send-recv.c
+++ b/test/test-ipc-send-recv.c
@@ -117,7 +117,7 @@
       ASSERT(pending == ctx.expected_type);
 
       if (pending == UV_NAMED_PIPE)
-        r = uv_pipe_init(ctx.channel.loop, &recv->pipe, 0);
+        r = uv_pipe_init(ctx.channel.loop, &recv->pipe, UV_PIPE_READABLE|UV_PIPE_WRITABLE);
       else if (pending == UV_TCP)
         r = uv_tcp_init(ctx.channel.loop, &recv->tcp);
       else
@@ -173,7 +173,7 @@ static int run_test(int inprocess) {
 
     uv_sleep(1000);
 
-    r = uv_pipe_init(uv_default_loop(), &ctx.channel, 1);
+    r = uv_pipe_init(uv_default_loop(), &ctx.channel, UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
     ASSERT(r == 0);
 
     uv_pipe_connect(&ctx.connect_req, &ctx.channel, TEST_PIPENAME_3, connect_cb);
@@ -201,13 +201,13 @@ static int run_ipc_send_recv_pipe(int inprocess) {
 
   ctx.expected_type = UV_NAMED_PIPE;
 
-  r = uv_pipe_init(uv_default_loop(), &ctx.send.pipe, 1);
+  r = uv_pipe_init(uv_default_loop(), &ctx.send.pipe, UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
   ASSERT(r == 0);
 
   r = uv_pipe_bind(&ctx.send.pipe, TEST_PIPENAME);
   ASSERT(r == 0);
 
-  r = uv_pipe_init(uv_default_loop(), &ctx.send2.pipe, 1);
+  r = uv_pipe_init(uv_default_loop(), &ctx.send2.pipe, UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
   ASSERT(r == 0);
 
   r = uv_pipe_bind(&ctx.send2.pipe, TEST_PIPENAME_2);
@@ -314,7 +314,7 @@
     ASSERT(pending == UV_NAMED_PIPE || pending == UV_TCP);
 
     if (pending == UV_NAMED_PIPE)
-      r = uv_pipe_init(ctx2.channel.loop, &recv->pipe, 0);
+      r = uv_pipe_init(ctx2.channel.loop, &recv->pipe, UV_PIPE_READABLE|UV_PIPE_WRITABLE);
     else if (pending == UV_TCP)
       r = uv_tcp_init(ctx2.channel.loop, &recv->tcp);
     else
@@ -358,10 +358,10 @@ int run_ipc_send_recv_helper(uv_loop_t* loop, int inprocess) {
 
   memset(&ctx2, 0, sizeof(ctx2));
 
-  r = uv_pipe_init(loop, &ctx2.listen, 0);
+  r = uv_pipe_init(loop, &ctx2.listen, UV_PIPE_READABLE|UV_PIPE_WRITABLE);
   ASSERT(r == 0);
 
-  r = uv_pipe_init(loop, &ctx2.channel, 1);
+  r = uv_pipe_init(loop, &ctx2.channel, UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
   ASSERT(r == 0);
 
   if (inprocess) {
diff --git a/test/test-ipc.c b/test/test-ipc.c
index f018c2d4d..b3c4c8b51 100644
--- a/test/test-ipc.c
+++ b/test/test-ipc.c
@@ -280,10 +280,16 @@ void spawn_helper(uv_pipe_t* channel,
   char* args[3];
   int r;
   uv_stdio_container_t stdio[1];
+  uv_pipe_t child_channel;
 
-  r = uv_pipe_init(uv_default_loop(), channel, 1);
+  r = uv_pipe_init(uv_default_loop(), channel,
+	  UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
+  ASSERT(r == 0);
+  r = uv_pipe_init(uv_default_loop(), &child_channel,
+	  UV_PIPE_READABLE|UV_PIPE_WRITABLE);
+  ASSERT(r == 0);
+  r = uv_pipe_link(&child_channel,channel);
   ASSERT(r == 0);
-  ASSERT(channel->ipc);
 
   exepath_size = sizeof(exepath);
   r = uv_exepath(exepath, &exepath_size);
@@ -300,13 +306,14 @@ void spawn_helper(uv_pipe_t* channel,
   options.exit_cb = exit_cb;
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE |
-    UV_READABLE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*)channel;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_channel;
   options.stdio_count = 1;
 
   r = uv_spawn(uv_default_loop(), process, &options);
   ASSERT(r == 0);
+
+  uv_pipe_close_sync(&child_channel);
 }
 
 
@@ -637,7 +644,7 @@ int ipc_helper(int listen_after_write) {
 
   ASSERT(0 == uv_ip4_addr("0.0.0.0", TEST_PORT, &addr));
 
-  r = uv_pipe_init(uv_default_loop(), &channel, 1);
+  r = uv_pipe_init(uv_default_loop(), &channel, UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
   ASSERT(r == 0);
 
   uv_pipe_open(&channel, 0);
@@ -687,7 +694,7 @@ int ipc_helper_tcp_connection(void) {
   int r;
   struct sockaddr_in addr;
 
-  r = uv_pipe_init(uv_default_loop(), &channel, 1);
+  r = uv_pipe_init(uv_default_loop(), &channel, UV_PIPE_READABLE|UV_PIPE_WRITABLE|UV_PIPE_IPC);
   ASSERT(r == 0);
 
   uv_pipe_open(&channel, 0);
diff --git a/test/test-ping-pong.c b/test/test-ping-pong.c
index c07417854..dedf8388f 100644
--- a/test/test-ping-pong.c
+++ b/test/test-ping-pong.c
@@ -219,7 +219,7 @@ static void pipe_pinger_new(void) {
   pinger->pongs = 0;
 
   /* Try to connect to the server and do NUM_PINGS ping-pongs. */
-  r = uv_pipe_init(uv_default_loop(), &pinger->stream.pipe, 0);
+  r = uv_pipe_init(uv_default_loop(), &pinger->stream.pipe, UV_PIPE_READABLE);
   pinger->stream.pipe.data = pinger;
   ASSERT(!r);
 
diff --git a/test/test-shutdown-close.c b/test/test-shutdown-close.c
index 78c369be2..f9c197c13 100644
--- a/test/test-shutdown-close.c
+++ b/test/test-shutdown-close.c
@@ -93,7 +93,7 @@ TEST_IMPL(shutdown_close_pipe) {
   uv_pipe_t h;
   int r;
 
-  r = uv_pipe_init(uv_default_loop(), &h, 0);
+  r = uv_pipe_init(uv_default_loop(), &h, UV_PIPE_READABLE);
   ASSERT(r == 0);
   uv_pipe_connect(&connect_req, &h, TEST_PIPENAME, connect_cb);
   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);
diff --git a/test/test-spawn.c b/test/test-spawn.c
index eba54ae70..c01ff420e 100644
--- a/test/test-spawn.c
+++ b/test/test-spawn.c
@@ -234,21 +234,28 @@ TEST_IMPL(spawn_exit_code) {
 
 TEST_IMPL(spawn_stdout) {
   int r;
-  uv_pipe_t out;
+  uv_pipe_t out, child_stdout;
   uv_stdio_container_t stdio[2];
 
   init_process_options("spawn_helper2", exit_cb);
 
-  uv_pipe_init(uv_default_loop(), &out, 0);
+  uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &child_stdout, UV_PIPE_SPAWN_SAFE|UV_PIPE_WRITABLE);
+  r = uv_pipe_link(&out,&child_stdout);
+  ASSERT(r == 0);
+
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_stdout;
   options.stdio_count = 2;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_stdout);
+
   r = uv_read_start((uv_stream_t*) &out, on_alloc, on_read);
   ASSERT(r == 0);
 
@@ -285,8 +292,9 @@ TEST_IMPL(spawn_stdout_to_file) {
   file = r;
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_INHERIT_FD;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_RAW_FD;
   options.stdio[1].data.fd = file;
   options.stdio_count = 2;
 
@@ -339,10 +347,11 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file) {
   file = r;
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_INHERIT_FD;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_RAW_FD;
   options.stdio[1].data.fd = file;
-  options.stdio[2].flags = UV_INHERIT_FD;
+  options.stdio[2].type = UV_RAW_FD;
   options.stdio[2].data.fd = file;
   options.stdio_count = 3;
 
@@ -401,10 +410,11 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file2) {
   ASSERT(file != -1);
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_INHERIT_FD;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_RAW_FD;
   options.stdio[1].data.fd = file;
-  options.stdio[2].flags = UV_INHERIT_FD;
+  options.stdio[2].type = UV_RAW_FD;
   options.stdio[2].data.fd = file;
   options.stdio_count = 3;
 
@@ -478,10 +488,11 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file_swap) {
   /* now we're going to swap them: the child process' stdout will be our
    * stderr_file and vice versa */
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_INHERIT_FD;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_RAW_FD;
   options.stdio[1].data.fd = stderr_file;
-  options.stdio[2].flags = UV_INHERIT_FD;
+  options.stdio[2].type = UV_RAW_FD;
   options.stdio[2].data.fd = stdout_file;
   options.stdio_count = 3;
 
@@ -539,22 +550,33 @@ TEST_IMPL(spawn_stdin) {
   uv_write_t write_req;
   uv_buf_t buf;
   uv_stdio_container_t stdio[2];
+  uv_pipe_t child_pipes[2];
   char buffer[] = "hello-from-spawn_stdin";
 
   init_process_options("spawn_helper3", exit_cb);
 
-  uv_pipe_init(uv_default_loop(), &out, 0);
-  uv_pipe_init(uv_default_loop(), &in, 0);
+  uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &in, UV_PIPE_WRITABLE);
+  uv_pipe_init(uv_default_loop(), &child_pipes[0], UV_PIPE_READABLE|UV_PIPE_SPAWN_SAFE);
+  uv_pipe_init(uv_default_loop(), &child_pipes[1], UV_PIPE_WRITABLE|UV_PIPE_SPAWN_SAFE);
+  r = uv_pipe_link(&child_pipes[0],&in);
+  ASSERT(r == 0);
+  r = uv_pipe_link(&out,&child_pipes[1]);
+  ASSERT(r == 0);
+
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*)&in;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipes[0];
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_pipes[1];
   options.stdio_count = 2;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_pipes[0]);
+  uv_pipe_close_sync(&child_pipes[1]);
+
   buf.base = buffer;
   buf.len = sizeof(buffer);
   r = uv_write(&write_req, (uv_stream_t*)&in, &buf, 1, write_cb);
@@ -577,23 +599,32 @@ TEST_IMPL(spawn_stdin) {
 
 TEST_IMPL(spawn_stdio_greater_than_3) {
   int r;
-  uv_pipe_t pipe;
+  uv_pipe_t pipe, child_pipe;
   uv_stdio_container_t stdio[4];
+  uv_stdio_container_t ignore;
+
+  ignore.type=UV_STREAM;
+  ignore.data.stream = NULL;
 
   init_process_options("spawn_helper5", exit_cb);
 
-  uv_pipe_init(uv_default_loop(), &pipe, 0);
+  uv_pipe_init(uv_default_loop(), &pipe, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &child_pipe, UV_PIPE_WRITABLE|UV_PIPE_SPAWN_SAFE);
+  r = uv_pipe_link(&pipe,&child_pipe);
+  ASSERT(r == 0);
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_IGNORE;
-  options.stdio[2].flags = UV_IGNORE;
-  options.stdio[3].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[3].data.stream = (uv_stream_t*)&pipe;
+  options.stdio[0] = ignore;
+  options.stdio[1] = ignore;
+  options.stdio[2] = ignore;
+  options.stdio[3].type = UV_STREAM;
+  options.stdio[3].data.stream = (uv_stream_t*)&child_pipe;
   options.stdio_count = 4;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_pipe);
+
   r = uv_read_start((uv_stream_t*) &pipe, on_alloc, on_read);
   ASSERT(r == 0);
 
@@ -659,16 +690,21 @@ TEST_IMPL(spawn_and_kill) {
 
 TEST_IMPL(spawn_preserve_env) {
   int r;
-  uv_pipe_t out;
+  uv_pipe_t child_out, out;
   uv_stdio_container_t stdio[2];
 
   init_process_options("spawn_helper7", exit_cb);
 
-  uv_pipe_init(uv_default_loop(), &out, 0);
+  uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &child_out, UV_PIPE_WRITABLE|UV_PIPE_SPAWN_SAFE);
+  r = uv_pipe_link(&out,&child_out);
+  ASSERT(r == 0);
+
   options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*) &out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*) &child_out;
   options.stdio_count = 2;
 
   r = putenv("ENV_TEST=testval");
@@ -680,6 +716,8 @@ TEST_IMPL(spawn_preserve_env) {
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_out);
+
   r = uv_read_start((uv_stream_t*) &out, on_alloc, on_read);
   ASSERT(r == 0);
 
@@ -727,6 +765,7 @@ TEST_IMPL(spawn_detached) {
 TEST_IMPL(spawn_and_kill_with_std) {
   int r;
   uv_pipe_t in, out, err;
+  uv_pipe_t child_pipes[3];
   uv_write_t write;
   char message[] = "Nancy's joining me because the message this evening is "
                    "not my message but ours.";
@@ -735,27 +774,49 @@ TEST_IMPL(spawn_and_kill_with_std) {
 
   init_process_options("spawn_helper4", kill_cb);
 
-  r = uv_pipe_init(uv_default_loop(), &in, 0);
+  r = uv_pipe_init(uv_default_loop(), &in, UV_PIPE_WRITABLE);
+  ASSERT(r == 0);
+
+  r = uv_pipe_init(uv_default_loop(), &child_pipes[0], UV_PIPE_READABLE|
+														UV_PIPE_SPAWN_SAFE);
+
+  r = uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
   ASSERT(r == 0);
 
-  r = uv_pipe_init(uv_default_loop(), &out, 0);
+  r = uv_pipe_init(uv_default_loop(), &child_pipes[1], UV_PIPE_WRITABLE|
+														UV_PIPE_SPAWN_SAFE);
   ASSERT(r == 0);
 
-  r = uv_pipe_init(uv_default_loop(), &err, 0);
+  r = uv_pipe_init(uv_default_loop(), &err, UV_PIPE_READABLE);
+  ASSERT(r == 0);
+
+  r = uv_pipe_init(uv_default_loop(), &child_pipes[2], UV_PIPE_WRITABLE|
+														UV_PIPE_SPAWN_SAFE);
+  ASSERT(r == 0);
+
+  r = uv_pipe_link(&child_pipes[0],&in);
+  ASSERT(r==0);
+  r = uv_pipe_link(&out,&child_pipes[1]);
+  ASSERT(r==0);
+  r = uv_pipe_link(&err,&child_pipes[2]);
   ASSERT(r == 0);
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*)&in;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
-  options.stdio[2].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[2].data.stream = (uv_stream_t*)&err;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipes[0];
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_pipes[1];
+  options.stdio[2].type = UV_STREAM;
+  options.stdio[2].data.stream = (uv_stream_t*)&child_pipes[2];
   options.stdio_count = 3;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_pipes[0]);
+  uv_pipe_close_sync(&child_pipes[1]);
+  uv_pipe_close_sync(&child_pipes[2]);
+
   buf = uv_buf_init(message, sizeof message);
   r = uv_write(&write, (uv_stream_t*) &in, &buf, 1, write_cb);
   ASSERT(r == 0);
@@ -788,23 +849,33 @@ TEST_IMPL(spawn_and_ping) {
   uv_pipe_t in, out;
   uv_buf_t buf;
   uv_stdio_container_t stdio[2];
+  uv_pipe_t child_pipes[2];
   int r;
 
   init_process_options("spawn_helper3", exit_cb);
   buf = uv_buf_init("TEST", 4);
 
-  uv_pipe_init(uv_default_loop(), &out, 0);
-  uv_pipe_init(uv_default_loop(), &in, 0);
+  uv_pipe_init(uv_default_loop(), &child_pipes[0], UV_PIPE_READABLE|UV_PIPE_SPAWN_SAFE);
+  uv_pipe_init(uv_default_loop(), &in, UV_PIPE_WRITABLE);
+  r = uv_pipe_link(&child_pipes[0],&in);
+  ASSERT(r == 0);
+  uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &child_pipes[1], UV_PIPE_WRITABLE|UV_PIPE_SPAWN_SAFE);
+  r = uv_pipe_link(&out,&child_pipes[1]);
+  ASSERT(r == 0);
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*)&in;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipes[0];
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_pipes[1];
   options.stdio_count = 2;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_pipes[0]);
+  uv_pipe_close_sync(&child_pipes[1]);
+
   /* Sending signum == 0 should check if the
    * child process is still alive, not kill it.
    */
@@ -833,6 +904,7 @@ TEST_IMPL(spawn_and_ping) {
 TEST_IMPL(spawn_same_stdout_stderr) {
   uv_write_t write_req;
   uv_pipe_t in, out;
+  uv_pipe_t child_pipes[2];
   uv_buf_t buf;
   uv_stdio_container_t stdio[3];
   int r;
@@ -840,18 +912,28 @@ TEST_IMPL(spawn_same_stdout_stderr) {
   init_process_options("spawn_helper3", exit_cb);
   buf = uv_buf_init("TEST", 4);
 
-  uv_pipe_init(uv_default_loop(), &out, 0);
-  uv_pipe_init(uv_default_loop(), &in, 0);
+  uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &child_pipes[0], UV_PIPE_READABLE|UV_PIPE_SPAWN_SAFE);
+  r = uv_pipe_link(&out,&child_pipes[1]);
+  ASSERT(r == 0);
+  uv_pipe_init(uv_default_loop(), &in, UV_PIPE_WRITABLE);
+  uv_pipe_init(uv_default_loop(), &child_pipes[1], UV_PIPE_WRITABLE|UV_PIPE_SPAWN_SAFE);
+  r = uv_pipe_link(&child_pipes[0],&in);
+  ASSERT(r == 0);
+
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*)&in;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipes[0];
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_pipes[1];
   options.stdio_count = 2;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_pipes[0]);
+  uv_pipe_close_sync(&child_pipes[1]);
+
   /* Sending signum == 0 should check if the
    * child process is still alive, not kill it.
    */
@@ -878,7 +960,7 @@ TEST_IMPL(spawn_same_stdout_stderr) {
 
 
 TEST_IMPL(spawn_closed_process_io) {
-  uv_pipe_t in;
+  uv_pipe_t in, child_pipe;
   uv_write_t write_req;
   uv_buf_t buf;
   uv_stdio_container_t stdio[2];
@@ -887,15 +969,21 @@ TEST_IMPL(spawn_closed_process_io) {
   init_process_options("spawn_helper3", exit_cb);
 
   uv_pipe_init(uv_default_loop(), &in, 0);
+  ASSERT(0 == uv_pipe_init(uv_default_loop(), &in, UV_PIPE_WRITABLE));
+  uv_pipe_init(uv_default_loop(), &child_pipe, UV_PIPE_READABLE|UV_PIPE_SPAWN_SAFE);
+  ASSERT(0 == uv_pipe_link(&child_pipe, &in));
+
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*) &in;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipe;
   options.stdio_count = 1;
 
   close(0); /* Close process stdin. */
 
   ASSERT(0 == uv_spawn(uv_default_loop(), &process, &options));
 
+  uv_pipe_close_sync(&child_pipe);
+
   buf = uv_buf_init(buffer, sizeof(buffer));
   ASSERT(0 == uv_write(&write_req, (uv_stream_t*) &in, &buf, 1, write_cb));
 
@@ -945,19 +1033,15 @@ TEST_IMPL(kill) {
 #ifdef _WIN32
 TEST_IMPL(spawn_detect_pipe_name_collisions_on_windows) {
   int r;
-  uv_pipe_t out;
+  uv_pipe_t out,child_stdout;
   char name[64];
   HANDLE pipe_handle;
   uv_stdio_container_t stdio[2];
 
   init_process_options("spawn_helper2", exit_cb);
 
-  uv_pipe_init(uv_default_loop(), &out, 0);
-  options.stdio = stdio;
-  options.stdio[0].flags = UV_IGNORE;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
-  options.stdio_count = 2;
+  uv_pipe_init(uv_default_loop(), &out, UV_PIPE_READABLE);
+  uv_pipe_init(uv_default_loop(), &child_stdout, UV_PIPE_WRITABLE|UV_PIPE_SPAWN_SAFE);
 
   /* Create a pipe that'll cause a collision. */
   snprintf(name,
@@ -975,9 +1059,20 @@ TEST_IMPL(spawn_detect_pipe_name_collisions_on_windows) {
                                 NULL);
   ASSERT(pipe_handle != INVALID_HANDLE_VALUE);
 
+  r = uv_pipe_link(&out, &child_stdout);
+  ASSERT(r == 0);
+  options.stdio = stdio;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = NULL;
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_stdout;
+  options.stdio_count = 2;
+
   r = uv_spawn(uv_default_loop(), &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_stdout);
+
   r = uv_read_start((uv_stream_t*) &out, on_alloc, on_read);
   ASSERT(r == 0);
 
@@ -1394,7 +1489,7 @@ TEST_IMPL(spawn_auto_unref) {
 TEST_IMPL(spawn_fs_open) {
   int fd;
   uv_fs_t fs_req;
-  uv_pipe_t in;
+  uv_pipe_t in, child_pipe;
   uv_write_t write_req;
   uv_buf_t buf;
   uv_stdio_container_t stdio[1];
@@ -1405,15 +1500,19 @@ TEST_IMPL(spawn_fs_open) {
 
   init_process_options("spawn_helper8", exit_cb);
 
-  ASSERT(0 == uv_pipe_init(uv_default_loop(), &in, 0));
+  ASSERT(0 == uv_pipe_init(uv_default_loop(), &in, UV_PIPE_WRITABLE));
+  uv_pipe_init(uv_default_loop(), &child_pipe, UV_PIPE_READABLE|UV_PIPE_SPAWN_SAFE);
+  ASSERT(0 == uv_pipe_link(&child_pipe,&in));
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*) &in;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipe;
   options.stdio_count = 1;
 
   ASSERT(0 == uv_spawn(uv_default_loop(), &process, &options));
 
+  uv_pipe_close_sync(&child_pipe);
+
   buf = uv_buf_init((char*) &fd, sizeof(fd));
   ASSERT(0 == uv_write(&write_req, (uv_stream_t*) &in, &buf, 1, write_cb));
 
@@ -1431,7 +1530,11 @@ TEST_IMPL(spawn_fs_open) {
 #if defined(__MVS__)
   RETURN_SKIP("Filesystem watching not supported on this platform.");
 #endif
-  uv_stdio_container_t stdio[3];
+  uv_stdio_container_t stdio[3] = {
+    { .type=UV_RAW_FD, .data={.fd=0} },
+    { .type=UV_STREAM, .data={.stream=NULL} },
+    { .type=UV_STREAM, .data={.stream=NULL} }
+  };
   uv_pipe_t pipe_handle;
   int fd[2];
 
@@ -1442,16 +1545,12 @@ TEST_IMPL(closed_fd_events) {
   init_process_options("spawn_helper4", exit_cb);
   options.stdio_count = 3;
   options.stdio = stdio;
-  options.stdio[0].flags = UV_INHERIT_FD;
-  options.stdio[0].data.fd = fd[0];
-  options.stdio[1].flags = UV_IGNORE;
-  options.stdio[2].flags = UV_IGNORE;
 
   ASSERT(0 == uv_spawn(uv_default_loop(), &process, &options));
   uv_unref((uv_handle_t*) &process);
 
   /* read from the pipe with uv */
-  ASSERT(0 == uv_pipe_init(uv_default_loop(), &pipe_handle, 0));
+  ASSERT(0 == uv_pipe_init(uv_default_loop(), &pipe_handle, UV_PIPE_READABLE));
   ASSERT(0 == uv_pipe_open(&pipe_handle, fd[0]));
   fd[0] = -1;
 
@@ -1578,7 +1677,10 @@ static int mpipe(int *fds) {
 
 TEST_IMPL(spawn_inherit_streams) {
   uv_process_t child_req;
-  uv_stdio_container_t child_stdio[2];
+  uv_stdio_container_t child_stdio[2] = {
+    { .type=UV_STREAM, .data={.stream=NULL} },
+    { .type=UV_STREAM, .data={.stream=NULL} },
+  };
   int fds_stdin[2];
   int fds_stdout[2];
   uv_pipe_t pipe_stdin_child;
@@ -1595,10 +1697,10 @@ TEST_IMPL(spawn_inherit_streams) {
   init_process_options("spawn_helper9", exit_cb);
 
   loop = uv_default_loop();
-  ASSERT(uv_pipe_init(loop, &pipe_stdin_child, 0) == 0);
-  ASSERT(uv_pipe_init(loop, &pipe_stdout_child, 0) == 0);
-  ASSERT(uv_pipe_init(loop, &pipe_stdin_parent, 0) == 0);
-  ASSERT(uv_pipe_init(loop, &pipe_stdout_parent, 0) == 0);
+  ASSERT(uv_pipe_init(loop, &pipe_stdin_child, UV_PIPE_READABLE) == 0);
+  ASSERT(uv_pipe_init(loop, &pipe_stdout_child, UV_PIPE_WRITABLE) == 0);
+  ASSERT(uv_pipe_init(loop, &pipe_stdin_parent, UV_PIPE_WRITABLE) == 0);
+  ASSERT(uv_pipe_init(loop, &pipe_stdout_parent, UV_PIPE_READABLE) == 0);
 
   ASSERT(mpipe(fds_stdin) != -1);
   ASSERT(mpipe(fds_stdout) != -1);
@@ -1608,10 +1710,7 @@ TEST_IMPL(spawn_inherit_streams) {
   ASSERT(uv_pipe_open(&pipe_stdin_parent, fds_stdin[1]) == 0);
   ASSERT(uv_pipe_open(&pipe_stdout_parent, fds_stdout[0]) == 0);
 
-  child_stdio[0].flags = UV_INHERIT_STREAM;
   child_stdio[0].data.stream = (uv_stream_t *)&pipe_stdin_child;
-
-  child_stdio[1].flags = UV_INHERIT_STREAM;
   child_stdio[1].data.stream = (uv_stream_t *)&pipe_stdout_child;
 
   options.stdio = child_stdio;
diff --git a/test/test-stdio-over-pipes.c b/test/test-stdio-over-pipes.c
index 157447610..f540e5e7d 100644
--- a/test/test-stdio-over-pipes.c
+++ b/test/test-stdio-over-pipes.c
@@ -120,24 +120,35 @@ TEST_IMPL(stdio_over_pipes) {
   int r;
   uv_process_t process;
   uv_stdio_container_t stdio[2];
+  uv_pipe_t child_pipes[2];
 
   loop = uv_default_loop();
 
   init_process_options("stdio_over_pipes_helper", exit_cb);
 
-  uv_pipe_init(loop, &out, 0);
-  uv_pipe_init(loop, &in, 0);
+  uv_pipe_init(loop, &child_pipes[0], UV_PIPE_SPAWN_SAFE|UV_PIPE_READABLE);
+  uv_pipe_init(loop, &in, UV_PIPE_WRITABLE);
+  r = uv_pipe_link(&child_pipes[0],&in);
+  ASSERT( r == 0 );
+  
+  uv_pipe_init(loop, &out, UV_PIPE_READABLE);
+  uv_pipe_init(loop, &child_pipes[1], UV_PIPE_SPAWN_SAFE|UV_PIPE_WRITABLE);
+  r = uv_pipe_link(&out,&child_pipes[1]);
+  ASSERT( r == 0 );
 
   options.stdio = stdio;
-  options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
-  options.stdio[0].data.stream = (uv_stream_t*)&in;
-  options.stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;
-  options.stdio[1].data.stream = (uv_stream_t*)&out;
+  options.stdio[0].type = UV_STREAM;
+  options.stdio[0].data.stream = (uv_stream_t*)&child_pipes[0];
+  options.stdio[1].type = UV_STREAM;
+  options.stdio[1].data.stream = (uv_stream_t*)&child_pipes[1];
   options.stdio_count = 2;
 
   r = uv_spawn(loop, &process, &options);
   ASSERT(r == 0);
 
+  uv_pipe_close_sync(&child_pipes[0]);
+  uv_pipe_close_sync(&child_pipes[1]);
+
   r = uv_read_start((uv_stream_t*) &out, on_alloc, on_read);
   ASSERT(r == 0);
 
@@ -210,9 +221,9 @@ int stdio_over_pipes_helper(void) {
   ASSERT(UV_NAMED_PIPE == uv_guess_handle(0));
   ASSERT(UV_NAMED_PIPE == uv_guess_handle(1));
 
-  r = uv_pipe_init(loop, &stdin_pipe, 0);
+  r = uv_pipe_init(loop, &stdin_pipe, UV_PIPE_READABLE);
   ASSERT(r == 0);
-  r = uv_pipe_init(loop, &stdout_pipe, 0);
+  r = uv_pipe_init(loop, &stdout_pipe, UV_PIPE_WRITABLE);
   ASSERT(r == 0);
 
   uv_pipe_open(&stdin_pipe, 0);
From 5904323111468eac9cbbdb750e4652a35b6dff42 Mon Sep 17 00:00:00 2001
From: Keno Fischer <kfischer@college.harvard.edu>
Date: Fri, 21 Jun 2013 17:26:35 -0400
Subject: [PATCH] Add option to reset SIGPIPE in child process

---
 include/uv.h       | 7 ++++++-
 src/unix/process.c | 9 ++++++++-
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/include/uv.h b/include/uv.h
index 810eb2738..938aacff2 100644
--- a/include/uv.h
+++ b/include/uv.h
@@ -950,7 +950,12 @@ enum uv_process_flags {
    * option is only meaningful on Windows systems. On Unix it is silently
    * ignored.
    */
-  UV_PROCESS_WINDOWS_HIDE = (1 << 4)
+  UV_PROCESS_WINDOWS_HIDE = (1 << 4),
+  /*
+   * Reset SIGPIPE to the default handler. Useful for parent processes that ignore 
+   * SIGPIPE, but don't want to make the same assumption for child processes
+   */
+  UV_PROCESS_RESET_SIGPIPE = (1 << 5)
 };
 
 /*
diff --git a/src/unix/process.c b/src/unix/process.c
index 39c1c586c..a44779aa9 100644
--- a/src/unix/process.c
+++ b/src/unix/process.c
@@ -293,6 +293,12 @@ static void uv__process_child_init(const uv_process_options_t* options,
     _exit(127);
   }
 
+  if ((options->flags & UV_PROCESS_RESET_SIGPIPE) && signal(SIGPIPE,SIG_DFL) == SIG_ERR)
+  {
+    uv__write_int(error_fd, -errno);
+    _exit(127);
+  }
+
   if (options->env != NULL) {
     environ = options->env;
   }
@@ -328,7 +334,8 @@ int uv_spawn(uv_loop_t* loop,
                               UV_PROCESS_SETGID |
                               UV_PROCESS_SETUID |
                               UV_PROCESS_WINDOWS_HIDE |
-                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));
+                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS |
+                              UV_PROCESS_RESET_SIGPIPE)));
 
   uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);
   QUEUE_INIT(&process->queue);
From eddb3cf4e0e376063b6106cea149778840ef2177 Mon Sep 17 00:00:00 2001
From: Kiran Pamnany <kiran.pamnany@intel.com>
Date: Thu, 29 Oct 2015 13:53:38 -0700
Subject: [PATCH] thread: support for affinity and detach

int uv_thread_setaffinity(uv_thread_t *tid,
                          char *cpumask,
                          char *oldmask,
                          size_t mask_size);
Sets the specified thread's affinity to cpumask, which must be
specified in bytes. Returns the previous affinity setting in oldmask,
if provided. On Unix, uses pthread_getaffinity_np() to get the
affinity setting and maps the cpu_set_t to bytes in oldmask. Then
maps the bytes in cpumask to a cpu_set_t and uses pthread_setaffinity_np().
On Windows, maps the bytes in cpumask to a bitmask and uses
SetThreadAffinityMask() which returns the previous affinity setting.

int uv_thread_getaffinity(uv_thread_t *tid,
                          char *cpumask,
                          size_t mask_size);
Gets the specified thread's affinity setting. On Unix, maps the
cpu_set_t returned by pthread_getaffinity_np() to bytes in cpumask.
Unsupported on Windows, which doesn't have any way to get the current
affinity setting.

int uv_thread_detach(uv_thread_t *tid);
Detaches the specified thread so it will be cleaned up on exit
automatically; joining it is no longer necessary or possible. Uses
pthread_detach() on Unix and CloseHandle() on Windows.

Empty implementations (returning -ENOTSUP) on OS X and AIX.
---
 Makefile.am                 |  1 +
 docs/src/threading.rst      |  4 +++
 include/uv.h                | 12 ++++++-
 src/unix/thread.c           | 78 +++++++++++++++++++++++++++++++++++++++++
 src/win/thread.c            | 85 +++++++++++++++++++++++++++++++++++++++++++++
 test/test-list.h            |  2 ++
 test/test-thread-affinity.c | 63 +++++++++++++++++++++++++++++++++
 7 files changed, 244 insertions(+), 1 deletion(-)
 create mode 100644 test/test-thread-affinity.c

diff --git a/Makefile.am b/Makefile.am
index 88b536248..7df79c8bc 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -240,6 +240,7 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-tcp-write-queue-order.c \
                          test/test-thread-equal.c \
                          test/test-thread.c \
+                         test/test-thread-affinity.c \
                          test/test-threadpool-cancel.c \
                          test/test-threadpool.c \
                          test/test-timer-again.c \
diff --git a/docs/src/threading.rst b/docs/src/threading.rst
index e876dde12..6c2ee033a 100644
--- a/docs/src/threading.rst
+++ b/docs/src/threading.rst
@@ -59,6 +59,10 @@ Threads
 
     .. versionchanged:: 1.4.1 returns a UV_E* error code on failure
 
+.. c:function:: int uv_thread_cpumasksize(void)
+.. c:function:: int uv_thread_setaffinity(uv_thread_t* tid, char* cpumask, char* oldmask, size_t mask_size)
+.. c:function:: int uv_thread_getaffinity(uv_thread_t* tid, char* cpumask, size_t mask_size)
+.. c:function:: int uv_thread_detach(uv_thread_t* tid)
 .. c:function:: uv_thread_t uv_thread_self(void)
 .. c:function:: int uv_thread_join(uv_thread_t *tid)
 .. c:function:: int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2)
diff --git a/include/uv.h b/include/uv.h
index baa0b2812..20f125e02 100644
--- a/include/uv.h
+++ b/include/uv.h
@@ -1437,11 +1437,21 @@ UV_EXTERN void uv_key_delete(uv_key_t* key);
 UV_EXTERN void* uv_key_get(uv_key_t* key);
 UV_EXTERN void uv_key_set(uv_key_t* key, void* value);
 
+
 typedef void (*uv_thread_cb)(void* arg);
 
 UV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);
+UV_EXTERN int uv_thread_cpumasksize(void);
+UV_EXTERN int uv_thread_setaffinity(uv_thread_t* tid,
+                                    char* cpumask,
+                                    char* oldmask,
+                                    size_t mask_size);
+UV_EXTERN int uv_thread_getaffinity(uv_thread_t* tid,
+                                    char* cpumask,
+                                    size_t mask_size);
+UV_EXTERN int uv_thread_detach(uv_thread_t* tid);
 UV_EXTERN uv_thread_t uv_thread_self(void);
-UV_EXTERN int uv_thread_join(uv_thread_t *tid);
+UV_EXTERN int uv_thread_join(uv_thread_t* tid);
 UV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);
 
 /* The presence of these unions force similar struct layout. */
diff --git a/src/unix/thread.c b/src/unix/thread.c
index b1fb02bd2..45d1861e5 100644
--- a/src/unix/thread.c
+++ b/src/unix/thread.c
@@ -23,6 +23,7 @@
 #include "internal.h"
 
 #include <pthread.h>
+#include <sched.h>
 #include <assert.h>
 #include <errno.h>
 
@@ -102,10 +103,87 @@ int uv_thread_create(uv_thread_t *tid, void (*entry)(void *arg), void *arg) {
 }
 
 
+#if defined(__APPLE__) && defined(__MACH__) || defined(_AIX)
+int uv_thread_cpumasksize(void) {
+  return -ENOTSUP;
+}
+
+int uv_thread_setaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          char* oldmask,
+                          size_t mask_size) {
+  return -ENOTSUP;
+}
+
+
+int uv_thread_getaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          size_t mask_size) {
+  return -ENOTSUP;
+}
+
+#else /* !((defined(__APPLE__) && defined(__MACH__)) || defined(_AIX)) */
+
+int uv_thread_cpumasksize(void) {
+  return CPU_SETSIZE;
+}
+
+int uv_thread_setaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          char* oldmask,
+                          size_t mask_size) {
+  int i;
+  int r;
+  cpu_set_t cpuset;
+  int cpumasksize;
+  
+  cpumasksize = uv_thread_cpumasksize();
+  assert(mask_size >= (size_t)cpumasksize);
+
+  if (oldmask) {
+    r = uv_thread_getaffinity(tid, oldmask, mask_size);
+    if (!r)
+      return r;
+  }
+
+  CPU_ZERO(&cpuset);
+  for (i = 0;  i < cpumasksize;  i++)
+    if (cpumask[i])
+        CPU_SET(i, &cpuset);
+
+  return -pthread_setaffinity_np(*tid, sizeof(cpuset), &cpuset);
+}
+
+
+int uv_thread_getaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          size_t mask_size) {
+  int i;
+  cpu_set_t cpuset;
+  int cpumasksize;
+  
+  cpumasksize = uv_thread_cpumasksize();
+  assert(mask_size >= (size_t)cpumasksize);
+
+  CPU_ZERO(&cpuset);
+  pthread_getaffinity_np(*tid, sizeof(cpuset), &cpuset);
+  for (i = 0;  i < cpumasksize;  i++)
+    cpumask[i] = CPU_ISSET(i, &cpuset);
+
+  return 0;
+}
+#endif /* (defined(__APPLE__) && defined(__MACH__)) || defined(_AIX) */
+
+int uv_thread_detach(uv_thread_t* tid) {
+  return -pthread_detach(*tid);
+}
+
+
 uv_thread_t uv_thread_self(void) {
   return pthread_self();
 }
 
+
 int uv_thread_join(uv_thread_t *tid) {
   return -pthread_join(*tid, NULL);
 }
diff --git a/src/win/thread.c b/src/win/thread.c
index 91684e938..4ea707925 100644
--- a/src/win/thread.c
+++ b/src/win/thread.c
@@ -170,6 +170,91 @@ int uv_thread_create(uv_thread_t *tid, void (*entry)(void *arg), void *arg) {
 }
 
 
+int uv_thread_cpumasksize(void) {
+#if defined(_WIN64)
+  return 64;
+#else
+  return 32;
+#endif
+}
+
+int uv_thread_setaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          char* oldmask,
+                          size_t mask_size) {
+  int i;
+  HANDLE hproc;
+  DWORD_PTR procmask;
+  DWORD_PTR sysmask;
+  DWORD_PTR threadmask = 0;
+  DWORD_PTR oldthreadmask;
+  int cpumasksize;
+  
+  cpumasksize = uv_thread_cpumasksize();
+  assert(mask_size >= (size_t)cpumasksize);
+
+  hproc = GetCurrentProcess();
+  if (!GetProcessAffinityMask(hproc, &procmask, &sysmask))
+    return uv_translate_sys_error(GetLastError());
+
+  for (i = 0;  i < cpumasksize;  i++) {
+    if (cpumask[i]) {
+      if (procmask & (1 << i))
+        threadmask |= 1 << i;
+      else
+        return UV_EINVAL;
+    }
+  }
+
+  oldthreadmask = SetThreadAffinityMask(*tid, threadmask);
+  if (!oldthreadmask)
+    return uv_translate_sys_error(GetLastError());
+
+  if (oldmask) {
+    for (i = 0;  i < cpumasksize;  i++)
+      oldmask[i] = (oldthreadmask >> i) & 1;
+  }
+
+  return 0;
+}
+
+
+int uv_thread_getaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          size_t mask_size) {
+  int i;
+  HANDLE hproc;
+  DWORD_PTR procmask;
+  DWORD_PTR sysmask;
+  DWORD_PTR threadmask;
+  int cpumasksize;
+  
+  threadmask = 0;
+  cpumasksize = uv_thread_cpumasksize();
+  assert(mask_size >= (size_t)cpumasksize);
+
+  hproc = GetCurrentProcess();
+  if (!GetProcessAffinityMask(hproc, &procmask, &sysmask))
+    return uv_translate_sys_error(GetLastError());
+
+  threadmask = SetThreadAffinityMask(*tid, procmask);
+  if (!threadmask)
+    return uv_translate_sys_error(GetLastError());
+  SetThreadAffinityMask(*tid, threadmask);
+
+  for (i = 0;  i < cpumasksize;  i++)
+    cpumask[i] = (threadmask >> i) & 1;
+
+  return 0;
+}
+
+
+int uv_thread_detach(uv_thread_t* tid) {
+  CloseHandle(*tid);
+  return 0;
+}
+
+
 uv_thread_t uv_thread_self(void) {
   uv_once(&uv__current_thread_init_guard, uv__init_current_thread_key);
   return (uv_thread_t) uv_key_get(&uv__current_thread_key);
diff --git a/test/test-list.h b/test/test-list.h
index 8b10f1a5f..bb86afeb9 100644
--- a/test/test-list.h
+++ b/test/test-list.h
@@ -306,6 +306,7 @@ TEST_DECLARE   (thread_rwlock)
 TEST_DECLARE   (thread_rwlock_trylock)
 TEST_DECLARE   (thread_create)
 TEST_DECLARE   (thread_equal)
+TEST_DECLARE   (thread_affinity)
 TEST_DECLARE   (dlerror)
 TEST_DECLARE   (poll_duplex)
 TEST_DECLARE   (poll_unidirectional)
@@ -747,6 +748,7 @@ TASK_LIST_START
   TEST_ENTRY  (thread_rwlock_trylock)
   TEST_ENTRY  (thread_create)
   TEST_ENTRY  (thread_equal)
+  TEST_ENTRY  (thread_affinity)
   TEST_ENTRY  (dlerror)
   TEST_ENTRY  (ip4_addr)
   TEST_ENTRY  (ip6_addr_link_local)
diff --git a/test/test-thread-affinity.c b/test/test-thread-affinity.c
new file mode 100644
index 000000000..8510530b1
--- /dev/null
+++ b/test/test-thread-affinity.c
@@ -0,0 +1,63 @@
+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
+ */
+
+#include "uv.h"
+#include "task.h"
+
+#include <string.h>
+
+static void check_affinity(void* arg) {
+  int r;
+  char *cpumask = arg;
+  int cpumasksize = uv_thread_cpumasksize();
+
+  uv_thread_t tid = uv_thread_self();
+  uv_thread_setaffinity(&tid, cpumask, NULL, cpumasksize);
+  r = uv_thread_setaffinity(&tid, cpumask + cpumasksize, cpumask, cpumasksize);
+  if (r != 0)
+    cpumask[0] = cpumask[1] = -1;
+}
+
+TEST_IMPL(thread_affinity) {
+  int t1first, t1second, t2first, t2second;
+  int cpumasksize;
+  char *cpumask;
+  uv_thread_t threads[2];
+
+  cpumasksize = uv_thread_cpumasksize();
+  t1first = cpumasksize * 0;
+  t1second = cpumasksize * 1;
+  t2first = cpumasksize * 2;
+  t2second = cpumasksize * 3;
+
+  cpumask = (char*)calloc(4 * cpumasksize, sizeof(char));
+
+  cpumask[t1first  + 1] = cpumask[t1first  + 3] = 1;
+  cpumask[t1second + 0] = cpumask[t1second + 2] = 1;
+
+  cpumask[t2first  + 0] = cpumask[t2first  + 2] = 1;
+  cpumask[t2second + 1] = cpumask[t2second + 3] = 1;
+
+  ASSERT(0 == uv_thread_create(threads + 0,
+                               check_affinity,
+                               &cpumask[t1first]));
+  ASSERT(0 == uv_thread_create(threads + 1,
+                               check_affinity,
+                               &cpumask[t2first]));
+  ASSERT(0 == uv_thread_join(threads + 0));
+  ASSERT(0 == uv_thread_join(threads + 1));
+
+  ASSERT(0 == cpumask[t1first + 0]);
+  ASSERT(1 == cpumask[t1first + 1]);
+  ASSERT(0 == cpumask[t1first + 2]);
+  ASSERT(1 == cpumask[t1first + 3]);
+
+  ASSERT(1 == cpumask[t2first + 0]);
+  ASSERT(0 == cpumask[t2first + 1]);
+  ASSERT(1 == cpumask[t2first + 2]);
+  ASSERT(0 == cpumask[t2first + 3]);
+
+  free(cpumask);
+
+  return 0;
+}
